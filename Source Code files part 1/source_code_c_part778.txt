yInterface(This,riid,ppvObject)

#define IHtmlDlgSafeHelper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHtmlDlgSafeHelper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHtmlDlgSafeHelper_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHtmlDlgSafeHelper_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHtmlDlgSafeHelper_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHtmlDlgSafeHelper_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHtmlDlgSafeHelper_choosecolordlg(This,initColor,rgbColor)	\
    (This)->lpVtbl -> choosecolordlg(This,initColor,rgbColor)

#define IHtmlDlgSafeHelper_getCharset(This,fontName,charset)	\
    (This)->lpVtbl -> getCharset(This,fontName,charset)

#define IHtmlDlgSafeHelper_get_Fonts(This,p)	\
    (This)->lpVtbl -> get_Fonts(This,p)

#define IHtmlDlgSafeHelper_get_BlockFormats(This,p)	\
    (This)->lpVtbl -> get_BlockFormats(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IHtmlDlgSafeHelper_choosecolordlg_Proxy( 
    IHtmlDlgSafeHelper * This,
    /* [in][optional] */ VARIANT initColor,
    /* [out][retval] */ VARIANT *rgbColor);


void __RPC_STUB IHtmlDlgSafeHelper_choosecolordlg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IHtmlDlgSafeHelper_getCharset_Proxy( 
    IHtmlDlgSafeHelper * This,
    /* [in] */ BSTR fontName,
    /* [out][retval] */ VARIANT *charset);


void __RPC_STUB IHtmlDlgSafeHelper_getCharset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHtmlDlgSafeHelper_get_Fonts_Proxy( 
    IHtmlDlgSafeHelper * This,
    /* [out][retval] */ IDispatch **p);


void __RPC_STUB IHtmlDlgSafeHelper_get_Fonts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHtmlDlgSafeHelper_get_BlockFormats_Proxy( 
    IHtmlDlgSafeHelper * This,
    /* [out][retval] */ IDispatch **p);


void __RPC_STUB IHtmlDlgSafeHelper_get_BlockFormats_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHtmlDlgSafeHelper_INTERFACE_DEFINED__ */


#ifndef __IBlockFormats_INTERFACE_DEFINED__
#define __IBlockFormats_INTERFACE_DEFINED__

/* interface IBlockFormats */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IBlockFormats;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f830-98b5-11cf-bb82-00aa00bdce0b")
    IBlockFormats : public IDispatch
    {
    public:
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [out][retval] */ IUnknown **p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [out][retval] */ long *p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ VARIANT *pvarIndex,
            /* [out][retval] */ BSTR *pbstrBlockFormat) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBlockFormatsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBlockFormats * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBlockFormats * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBlockFormats * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IBlockFormats * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IBlockFormats * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IBlockFormats * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IBlockFormats * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IBlockFormats * This,
            /* [out][retval] */ IUnknown **p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IBlockFormats * This,
            /* [out][retval] */ long *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IBlockFormats * This,
            /* [in] */ VARIANT *pvarIndex,
            /* [out][retval] */ BSTR *pbstrBlockFormat);
        
        END_INTERFACE
    } IBlockFormatsVtbl;

    interface IBlockFormats
    {
        CONST_VTBL struct IBlockFormatsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBlockFormats_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBlockFormats_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBlockFormats_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBlockFormats_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IBlockFormats_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IBlockFormats_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IBlockFormats_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IBlockFormats_get__NewEnum(This,p)	\
    (This)->lpVtbl -> get__NewEnum(This,p)

#define IBlockFormats_get_Count(This,p)	\
    (This)->lpVtbl -> get_Count(This,p)

#define IBlockFormats_Item(This,pvarIndex,pbstrBlockFormat)	\
    (This)->lpVtbl -> Item(This,pvarIndex,pbstrBlockFormat)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IBlockFormats_get__NewEnum_Proxy( 
    IBlockFormats * This,
    /* [out][retval] */ IUnknown **p);


void __RPC_STUB IBlockFormats_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IBlockFormats_get_Count_Proxy( 
    IBlockFormats * This,
    /* [out][retval] */ long *p);


void __RPC_STUB IBlockFormats_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IBlockFormats_Item_Proxy( 
    IBlockFormats * This,
    /* [in] */ VARIANT *pvarIndex,
    /* [out][retval] */ BSTR *pbstrBlockFormat);


void __RPC_STUB IBlockFormats_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBlockFormats_INTERFACE_DEFINED__ */


#ifndef __IFontNames_INTERFACE_DEFINED__
#define __IFontNames_INTERFACE_DEFINED__

/* interface IFontNames */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IFontNames;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f839-98b5-11cf-bb82-00aa00bdce0b")
    IFontNames : public IDispatch
    {
    public:
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [out][retval] */ IUnknown **p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [out][retval] */ long *p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ VARIANT *pvarIndex,
            /* [out][retval] */ BSTR *pbstrFontName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFontNamesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFontNames * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFontNames * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFontNames * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFontNames * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFontNames * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFontNames * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFontNames * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IFontNames * This,
            /* [out][retval] */ IUnknown **p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFontNames * This,
            /* [out][retval] */ long *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IFontNames * This,
            /* [in] */ VARIANT *pvarIndex,
            /* [out][retval] */ BSTR *pbstrFontName);
        
        END_INTERFACE
    } IFontNamesVtbl;

    interface IFontNames
    {
        CONST_VTBL struct IFontNamesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFontNames_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFontNames_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFontNames_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFontNames_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFontNames_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFontNames_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFontNames_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFontNames_get__NewEnum(This,p)	\
    (This)->lpVtbl -> get__NewEnum(This,p)

#define IFontNames_get_Count(This,p)	\
    (This)->lpVtbl -> get_Count(This,p)

#define IFontNames_Item(This,pvarIndex,pbstrFontName)	\
    (This)->lpVtbl -> Item(This,pvarIndex,pbstrFontName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IFontNames_get__NewEnum_Proxy( 
    IFontNames * This,
    /* [out][retval] */ IUnknown **p);


void __RPC_STUB IFontNames_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IFontNames_get_Count_Proxy( 
    IFontNames * This,
    /* [out][retval] */ long *p);


void __RPC_STUB IFontNames_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IFontNames_Item_Proxy( 
    IFontNames * This,
    /* [in] */ VARIANT *pvarIndex,
    /* [out][retval] */ BSTR *pbstrFontName);


void __RPC_STUB IFontNames_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFontNames_INTERFACE_DEFINED__ */


#ifndef __ICSSFilter_INTERFACE_DEFINED__
#define __ICSSFilter_INTERFACE_DEFINED__

/* interface ICSSFilter */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_ICSSFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f3ec-98b5-11cf-bb82-00aa00bdce0b")
    ICSSFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetSite( 
            /* [in] */ ICSSFilterSite *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnAmbientPropertyChange( 
            /* [in] */ LONG dispid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICSSFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICSSFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICSSFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICSSFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSite )( 
            ICSSFilter * This,
            /* [in] */ ICSSFilterSite *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *OnAmbientPropertyChange )( 
            ICSSFilter * This,
            /* [in] */ LONG dispid);
        
        END_INTERFACE
    } ICSSFilterVtbl;

    interface ICSSFilter
    {
        CONST_VTBL struct ICSSFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICSSFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICSSFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICSSFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICSSFilter_SetSite(This,pSink)	\
    (This)->lpVtbl -> SetSite(This,pSink)

#define ICSSFilter_OnAmbientPropertyChange(This,dispid)	\
    (This)->lpVtbl -> OnAmbientPropertyChange(This,dispid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICSSFilter_SetSite_Proxy( 
    ICSSFilter * This,
    /* [in] */ ICSSFilterSite *pSink);


void __RPC_STUB ICSSFilter_SetSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICSSFilter_OnAmbientPropertyChange_Proxy( 
    ICSSFilter * This,
    /* [in] */ LONG dispid);


void __RPC_STUB ICSSFilter_OnAmbientPropertyChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICSSFilter_INTERFACE_DEFINED__ */


#ifndef __ISecureUrlHost_INTERFACE_DEFINED__
#define __ISecureUrlHost_INTERFACE_DEFINED__

/* interface ISecureUrlHost */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_ISecureUrlHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c81984c4-74c8-11d2-baa9-00c04fc2040e")
    ISecureUrlHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ValidateSecureUrl( 
            /* [out] */ BOOL *pfAllow,
            /* [in] */ OLECHAR *pchUrlInQuestion,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISecureUrlHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISecureUrlHost * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISecureUrlHost * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISecureUrlHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *ValidateSecureUrl )( 
            ISecureUrlHost * This,
            /* [out] */ BOOL *pfAllow,
            /* [in] */ OLECHAR *pchUrlInQuestion,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } ISecureUrlHostVtbl;

    interface ISecureUrlHost
    {
        CONST_VTBL struct ISecureUrlHostVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISecureUrlHost_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISecureUrlHost_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISecureUrlHost_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISecureUrlHost_ValidateSecureUrl(This,pfAllow,pchUrlInQuestion,dwFlags)	\
    (This)->lpVtbl -> ValidateSecureUrl(This,pfAllow,pchUrlInQuestion,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISecureUrlHost_ValidateSecureUrl_Proxy( 
    ISecureUrlHost * This,
    /* [out] */ BOOL *pfAllow,
    /* [in] */ OLECHAR *pchUrlInQuestion,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ISecureUrlHost_ValidateSecureUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISecureUrlHost_INTERFACE_DEFINED__ */


#ifndef __IMarkupServices_INTERFACE_DEFINED__
#define __IMarkupServices_INTERFACE_DEFINED__

/* interface IMarkupServices */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IMarkupServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f4a0-98b5-11cf-bb82-00aa00bdce0b")
    IMarkupServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateMarkupPointer( 
            /* [out] */ IMarkupPointer **ppPointer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateMarkupContainer( 
            /* [out] */ IMarkupContainer **ppMarkupContainer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateElement( 
            /* [in] */ ELEMENT_TAG_ID tagID,
            /* [in] */ OLECHAR *pchAttributes,
            /* [out] */ IHTMLElement **ppElement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloneElement( 
            /* [in] */ IHTMLElement *pElemCloneThis,
            /* [out] */ IHTMLElement **ppElementTheClone) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertElement( 
            /* [in] */ IHTMLElement *pElementInsert,
            /* [in] */ IMarkupPointer *pPointerStart,
            /* [in] */ IMarkupPointer *pPointerFinish) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveElement( 
            /* [in] */ IHTMLElement *pElementRemove) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ IMarkupPointer *pPointerStart,
            /* [in] */ IMarkupPointer *pPointerFinish) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Copy( 
            /* [in] */ IMarkupPointer *pPointerSourceStart,
            /* [in] */ IMarkupPointer *pPointerSourceFinish,
            /* [in] */ IMarkupPointer *pPointerTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Move( 
            /* [in] */ IMarkupPointer *pPointerSourceStart,
            /* [in] */ IMarkupPointer *pPointerSourceFinish,
            /* [in] */ IMarkupPointer *pPointerTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertText( 
            /* [in] */ OLECHAR *pchText,
            /* [in] */ long cch,
            /* [in] */ IMarkupPointer *pPointerTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParseString( 
            /* [in] */ OLECHAR *pchHTML,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IMarkupContainer **ppContainerResult,
            /* [in] */ IMarkupPointer *ppPointerStart,
            /* [in] */ IMarkupPointer *ppPointerFinish) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParseGlobal( 
            /* [in] */ HGLOBAL hglobalHTML,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IMarkupContainer **ppContainerResult,
            /* [in] */ IMarkupPointer *pPointerStart,
            /* [in] */ IMarkupPointer *pPointerFinish) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsScopedElement( 
            /* [in] */ IHTMLElement *pElement,
            /* [out] */ BOOL *pfScoped) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetElementTagId( 
            /* [in] */ IHTMLElement *pElement,
            /* [out] */ ELEMENT_TAG_ID *ptagId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTagIDForName( 
            /* [in] */ BSTR bstrName,
            /* [out] */ ELEMENT_TAG_ID *ptagId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNameForTagID( 
            /* [in] */ ELEMENT_TAG_ID tagId,
            /* [out] */ BSTR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MovePointersToRange( 
            /* [in] */ IHTMLTxtRange *pIRange,
            /* [in] */ IMarkupPointer *pPointerStart,
            /* [in] */ IMarkupPointer *pPointerFinish) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveRangeToPointers( 
            /* [in] */ IMarkupPointer *pPointerStart,
            /* [in] */ IMarkupPointer *pPointerFinish,
            /* [in] */ IHTMLTxtRange *pIRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginUndoUnit( 
            /* [in] */ OLECHAR *pchTitle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndUndoUnit( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMarkupServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMarkupServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMarkupServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMarkupServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateMarkupPointer )( 
            IMarkupServices * This,
            /* [out] */ IMarkupPointer **ppPointer);
        
        HRESULT ( STDMETHODCALLTYPE *CreateMarkupContainer )( 
            IMarkupServices * This,
            /* [out] */ IMarkupContainer **ppMarkupContainer);
        
        HRESULT ( STDMETHODCALLTYPE *CreateElement )( 
            IMarkupServices * This,
            /* [in] */ ELEMENT_TAG_ID tagID,
            /* [in] */ OLECHAR *pchAttributes,
            /* [out] */ IHTMLElement **ppElement);
        
        HRESULT ( STDMETHODCALLTYPE *CloneElement )( 
            IMarkupServices * This,
            /* [in] */ IHTMLElement *pElemCloneThis,
            /* [out] */ IHTMLElement **ppElementTheClone);
        
        HRESULT ( STDMETHODCALLTYPE *InsertElement )( 
            IMarkupServices * This,
            /* [in] */ IHTMLElement *pElementInsert,
            /* [in] */ IMarkupPointer *pPointerStart,
            /* [in] */ IMarkupPointer *pPointerFinish);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveElement )( 
            IMarkupServices * This,
            /* [in] */ IHTMLElement *pElementRemove);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IMarkupServices * This,
            /* [in] */ IMarkupPointer *pPointerStart,
            /* [in] */ IMarkupPointer *pPointerFinish);
        
        HRESULT ( STDMETHODCALLTYPE *Copy )( 
            IMarkupServices * This,
            /* [in] */ IMarkupPointer *pPointerSourceStart,
            /* [in] */ IMarkupPointer *pPointerSourceFinish,
            /* [in] */ IMarkupPointer *pPointerTarget);
        
        HRESULT ( STDMETHODCALLTYPE *Move )( 
            IMarkupServices * This,
            /* [in] */ IMarkupPointer *pPointerSourceStart,
            /* [in] */ IMarkupPointer *pPointerSourceFinish,
            /* [in] */ IMarkupPointer *pPointerTarget);
        
        HRESULT ( STDMETHODCALLTYPE *InsertText )( 
            IMarkupServices * This,
            /* [in] */ OLECHAR *pchText,
            /* [in] */ long cch,
            /* [in] */ IMarkupPointer *pPointerTarget);
        
        HRESULT ( STDMETHODCALLTYPE *ParseString )( 
            IMarkupServices * This,
            /* [in] */ OLECHAR *pchHTML,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IMarkupContainer **ppContainerResult,
            /* [in] */ IMarkupPointer *ppPointerStart,
            /* [in] */ IMarkupPointer *ppPointerFinish);
        
        HRESULT ( STDMETHODCALLTYPE *ParseGlobal )( 
            IMarkupServices * This,
            /* [in] */ HGLOBAL hglobalHTML,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IMarkupContainer **ppContainerResult,
            /* [in] */ IMarkupPointer *pPointerStart,
            /* [in] */ IMarkupPointer *pPointerFinish);
        
        HRESULT ( STDMETHODCALLTYPE *IsScopedElement )( 
            IMarkupServices * This,
            /* [in] */ IHTMLElement *pElement,
            /* [out] */ BOOL *pfScoped);
        
        HRESULT ( STDMETHODCALLTYPE *GetElementTagId )( 
            IMarkupServices * This,
            /* [in] */ IHTMLElement *pElement,
            /* [out] */ ELEMENT_TAG_ID *ptagId);
        
        HRESULT ( STDMETHODCALLTYPE *GetTagIDForName )( 
            IMarkupServices * This,
            /* [in] */ BSTR bstrName,
            /* [out] */ ELEMENT_TAG_ID *ptagId);
        
        HRESULT ( STDMETHODCALLTYPE *GetNameForTagID )( 
            IMarkupServices * This,
            /* [in] */ ELEMENT_TAG_ID tagId,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *MovePointersToRange )( 
            IMarkupServices * This,
            /* [in] */ IHTMLTxtRange *pIRange,
            /* [in] */ IMarkupPointer *pPointerStart,
            /* [in] */ IMarkupPointer *pPointerFinish);
        
        HRESULT ( STDMETHODCALLTYPE *MoveRangeToPointers )( 
            IMarkupServices * This,
            /* [in] */ IMarkupPointer *pPointerStart,
            /* [in] */ IMarkupPointer *pPointerFinish,
            /* [in] */ IHTMLTxtRange *pIRange);
        
        HRESULT ( STDMETHODCALLTYPE *BeginUndoUnit )( 
            IMarkupServices * This,
            /* [in] */ OLECHAR *pchTitle);
        
        HRESULT ( STDMETHODCALLTYPE *EndUndoUnit )( 
            IMarkupServices * This);
        
        END_INTERFACE
    } IMarkupServicesVtbl;

    interface IMarkupServices
    {
        CONST_VTBL struct IMarkupServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMarkupServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMarkupServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMarkupServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMarkupServices_CreateMarkupPointer(This,ppPointer)	\
    (This)->lpVtbl -> CreateMarkupPointer(This,ppPointer)

#define IMarkupServices_CreateMarkupContainer(This,ppMarkupContainer)	\
    (This)->lpVtbl -> CreateMarkupContainer(This,ppMarkupContainer)

#define IMarkupServices_CreateElement(This,tagID,pchAttributes,ppElement)	\
    (This)->lpVtbl -> CreateElement(This,tagID,pchAttributes,ppElement)

#define IMarkupServices_CloneElement(This,pElemCloneThis,ppElementTheClone)	\
    (This)->lpVtbl -> CloneElement(This,pElemCloneThis,ppElementTheClone)

#define IMarkupServices_InsertElement(This,pElementInsert,pPointerStart,pPointerFinish)	\
    (This)->lpVtbl -> InsertElement(This,pElementInsert,pPointerStart,pPointerFinish)

#define IMarkupServices_RemoveElement(This,pElementRemove)	\
    (This)->lpVtbl -> RemoveElement(This,pElementRemove)

#define IMarkupServices_Remove(This,pPointerStart,pPointerFinish)	\
    (This)->lpVtbl -> Remove(This,pPointerStart,pPointerFinish)

#define IMarkupServices_Copy(This,pPointerSourceStart,pPointerSourceFinish,pPointerTarget)	\
    (This)->lpVtbl -> Copy(This,pPointerSourceStart,pPointerSourceFinish,pPointerTarget)

#define IMarkupServices_Move(This,pPointerSourceStart,pPointerSourceFinish,pPointerTarget)	\
    (This)->lpVtbl -> Move(This,pPointerSourceStart,pPointerSourceFinish,pPointerTarget)

#define IMarkupServices_InsertText(This,pchText,cch,pPointerTarget)	\
    (This)->lpVtbl -> InsertText(This,pchText,cch,pPointerTarget)

#define IMarkupServices_ParseString(This,pchHTML,dwFlags,ppContainerResult,ppPointerStart,ppPointerFinish)	\
    (This)->lpVtbl -> ParseString(This,pchHTML,dwFlags,ppContainerResult,ppPointerStart,ppPointerFinish)

#define IMarkupServices_ParseGlobal(This,hglobalHTML,dwFlags,ppContainerResult,pPointerStart,pPointerFinish)	\
    (This)->lpVtbl -> ParseGlobal(This,hglobalHTML,dwFlags,ppContainerResult,pPointerStart,pPointerFinish)

#define IMarkupServices_IsScopedElement(This,pElement,pfScoped)	\
    (This)->lpVtbl -> IsScopedElement(This,pElement,pfScoped)

#define IMarkupServices_GetElementTagId(This,pElement,ptagId)	\
    (This)->lpVtbl -> GetElementTagId(This,pElement,ptagId)

#define IMarkupServices_GetTagIDForName(This,bstrName,ptagId)	\
    (This)->lpVtbl -> GetTagIDForName(This,bstrName,ptagId)

#define IMarkupServices_GetNameForTagID(This,tagId,pbstrName)	\
    (This)->lpVtbl -> GetNameForTagID(This,tagId,pbstrName)

#define IMarkupServices_MovePointersToRange(This,pIRange,pPointerStart,pPointerFinish)	\
    (This)->lpVtbl -> MovePointersToRange(This,pIRange,pPointerStart,pPointerFinish)

#define IMarkupServices_MoveRangeToPointers(This,pPointerStart,pPointerFinish,pIRange)	\
    (This)->lpVtbl -> MoveRangeToPointers(This,pPointerStart,pPointerFinish,pIRange)

#define IMarkupServices_BeginUndoUnit(This,pchTitle)	\
    (This)->lpVtbl -> BeginUndoUnit(This,pchTitle)

#define IMarkupServices_EndUndoUnit(This)	\
    (This)->lpVtbl -> EndUndoUnit(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMarkupServices_CreateMarkupPointer_Proxy( 
    IMarkupServices * This,
    /* [out] */ IMarkupPointer **ppPointer);


void __RPC_STUB IMarkupServices_CreateMarkupPointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupServices_CreateMarkupContainer_Proxy( 
    IMarkupServices * This,
    /* [out] */ IMarkupContainer **ppMarkupContainer);


void __RPC_STUB IMarkupServices_CreateMarkupContainer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupServices_CreateElement_Proxy( 
    IMarkupServices * This,
    /* [in] */ ELEMENT_TAG_ID tagID,
    /* [in] */ OLECHAR *pchAttributes,
    /* [out] */ IHTMLElement **ppElement);


void __RPC_STUB IMarkupServices_CreateElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupServices_CloneElement_Proxy( 
    IMarkupServices * This,
    /* [in] */ IHTMLElement *pElemCloneThis,
    /* [out] */ IHTMLElement **ppElementTheClone);


void __RPC_STUB IMarkupServices_CloneElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupServices_InsertElement_Proxy( 
    IMarkupServices * This,
    /* [in] */ IHTMLElement *pElementInsert,
    /* [in] */ IMarkupPointer *pPointerStart,
    /* [in] */ IMarkupPointer *pPointerFinish);


void __RPC_STUB IMarkupServices_InsertElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupServices_RemoveElement_Proxy( 
    IMarkupServices * This,
    /* [in] */ IHTMLElement *pElementRemove);


void __RPC_STUB IMarkupServices_RemoveElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupServices_Remove_Proxy( 
    IMarkupServices * This,
    /* [in] */ IMarkupPointer *pPointerStart,
    /* [in] */ IMarkupPointer *pPointerFinish);


void __RPC_STUB IMarkupServices_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupServices_Copy_Proxy( 
    IMarkupServices * This,
    /* [in] */ IMarkupPointer *pPointerSourceStart,
    /* [in] */ IMarkupPointer *pPointerSourceFinish,
    /* [in] */ IMarkupPointer *pPointerTarget);


void __RPC_STUB IMarkupServices_Copy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupServices_Move_Proxy( 
    IMarkupServices * This,
    /* [in] */ IMarkupPointer *pPointerSourceStart,
    /* [in] */ IMarkupPointer *pPointerSourceFinish,
    /* [in] */ IMarkupPointer *pPointerTarget);


void __RPC_STUB IMarkupServices_Move_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupServices_InsertText_Proxy( 
    IMarkupServices * This,
    /* [in] */ OLECHAR *pchText,
    /* [in] */ long cch,
    /* [in] */ IMarkupPointer *pPointerTarget);


void __RPC_STUB IMarkupServices_InsertText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupServices_ParseString_Proxy( 
    IMarkupServices * This,
    /* [in] */ OLECHAR *pchHTML,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IMarkupContainer **ppContainerResult,
    /* [in] */ IMarkupPointer *ppPointerStart,
    /* [in] */ IMarkupPointer *ppPointerFinish);


void __RPC_STUB IMarkupServices_ParseString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupServices_ParseGlobal_Proxy( 
    IMarkupServices * This,
    /* [in] */ HGLOBAL hglobalHTML,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IMarkupContainer **ppContainerResult,
    /* [in] */ IMarkupPointer *pPointerStart,
    /* [in] */ IMarkupPointer *pPointerFinish);


void __RPC_STUB IMarkupServices_ParseGlobal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupServices_IsScopedElement_Proxy( 
    IMarkupServices * This,
    /* [in] */ IHTMLElement *pElement,
    /* [out] */ BOOL *pfScoped);


void __RPC_STUB IMarkupServices_IsScopedElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupServices_GetElementTagId_Proxy( 
    IMarkupServices * This,
    /* [in] */ IHTMLElement *pElement,
    /* [out] */ ELEMENT_TAG_ID *ptagId);


void __RPC_STUB IMarkupServices_GetElementTagId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupServices_GetTagIDForName_Proxy( 
    IMarkupServices * This,
    /* [in] */ BSTR bstrName,
    /* [out] */ ELEMENT_TAG_ID *ptagId);


void __RPC_STUB IMarkupServices_GetTagIDForName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupServices_GetNameForTagID_Proxy( 
    IMarkupServices * This,
    /* [in] */ ELEMENT_TAG_ID tagId,
    /* [out] */ BSTR *pbstrName);


void __RPC_STUB IMarkupServices_GetNameForTagID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupServices_MovePointersToRange_Proxy( 
    IMarkupServices * This,
    /* [in] */ IHTMLTxtRange *pIRange,
    /* [in] */ IMarkupPointer *pPointerStart,
    /* [in] */ IMarkupPointer *pPointerFinish);


void __RPC_STUB IMarkupServices_MovePointersToRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupServices_MoveRangeToPointers_Proxy( 
    IMarkupServices * This,
    /* [in] */ IMarkupPointer *pPointerStart,
    /* [in] */ IMarkupPointer *pPointerFinish,
    /* [in] */ IHTMLTxtRange *pIRange);


void __RPC_STUB IMarkupServices_MoveRangeToPointers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupServices_BeginUndoUnit_Proxy( 
    IMarkupServices * This,
    /* [in] */ OLECHAR *pchTitle);


void __RPC_STUB IMarkupServices_BeginUndoUnit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupServices_EndUndoUnit_Proxy( 
    IMarkupServices * This);


void __RPC_STUB IMarkupServices_EndUndoUnit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMarkupServices_INTERFACE_DEFINED__ */


#ifndef __IMarkupServices2_INTERFACE_DEFINED__
#define __IMarkupServices2_INTERFACE_DEFINED__

/* interface IMarkupServices2 */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IMarkupServices2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f682-98b5-11cf-bb82-00aa00bdce0b")
    IMarkupServices2 : public IMarkupServices
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParseGlobalEx( 
            /* [in] */ HGLOBAL hglobalHTML,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IMarkupContainer *pContext,
            /* [out] */ IMarkupContainer **ppContainerResult,
            /* [in] */ IMarkupPointer *pPointerStart,
            /* [in] */ IMarkupPointer *pPointerFinish) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ValidateElements( 
            /* [in] */ IMarkupPointer *pPointerStart,
            /* [in] */ IMarkupPointer *pPointerFinish,
            /* [in] */ IMarkupPointer *pPointerTarget,
            /* [out][in] */ IMarkupPointer *pPointerStatus,
            /* [out] */ IHTMLElement **ppElemFailBottom,
            /* [out] */ IHTMLElement **ppElemFailTop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveSegmentsToClipboard( 
            /* [in] */ ISegmentList *pSegmentList,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMarkupServices2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMarkupServices2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMarkupServices2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMarkupServices2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateMarkupPointer )( 
            IMarkupServices2 * This,
            /* [out] */ IMarkupPointer **ppPointer);
        
        HRESULT ( STDMETHODCALLTYPE *CreateMarkupContainer )( 
            IMarkupServices2 * This,
            /* [out] */ IMarkupContainer **ppMarkupContainer);
        
        HRESULT ( STDMETHODCALLTYPE *CreateElement )( 
            IMarkupServices2 * This,
            /* [in] */ ELEMENT_TAG_ID tagID,
            /* [in] */ OLECHAR *pchAttributes,
            /* [out] */ IHTMLElement **ppElement);
        
        HRESULT ( STDMETHODCALLTYPE *CloneElement )( 
            IMarkupServices2 * This,
            /* [in] */ IHTMLElement *pElemCloneThis,
            /* [out] */ IHTMLElement **ppElementTheClone);
        
        HRESULT ( STDMETHODCALLTYPE *InsertElement )( 
            IMarkupServices2 * This,
            /* [in] */ IHTMLElement *pElementInsert,
            /* [in] */ IMarkupPointer *pPointerStart,
            /* [in] */ IMarkupPointer *pPointerFinish);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveElement )( 
            IMarkupServices2 * This,
            /* [in] */ IHTMLElement *pElementRemove);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IMarkupServices2 * This,
            /* [in] */ IMarkupPointer *pPointerStart,
            /* [in] */ IMarkupPointer *pPointerFinish);
        
        HRESULT ( STDMETHODCALLTYPE *Copy )( 
            IMarkupServices2 * This,
            /* [in] */ IMarkupPointer *pPointerSourceStart,
            /* [in] */ IMarkupPointer *pPointerSourceFinish,
            /* [in] */ IMarkupPointer *pPointerTarget);
        
        HRESULT ( STDMETHODCALLTYPE *Move )( 
            IMarkupServices2 * This,
            /* [in] */ IMarkupPointer *pPointerSourceStart,
            /* [in] */ IMarkupPointer *pPointerSourceFinish,
            /* [in] */ IMarkupPointer *pPointerTarget);
        
        HRESULT ( STDMETHODCALLTYPE *InsertText )( 
            IMarkupServices2 * This,
            /* [in] */ OLECHAR *pchText,
            /* [in] */ long cch,
            /* [in] */ IMarkupPointer *pPointerTarget);
        
        HRESULT ( STDMETHODCALLTYPE *ParseString )( 
            IMarkupServices2 * This,
            /* [in] */ OLECHAR *pchHTML,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IMarkupContainer **ppContainerResult,
            /* [in] */ IMarkupPointer *ppPointerStart,
            /* [in] */ IMarkupPointer *ppPointerFinish);
        
        HRESULT ( STDMETHODCALLTYPE *ParseGlobal )( 
            IMarkupServices2 * This,
            /* [in] */ HGLOBAL hglobalHTML,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IMarkupContainer **ppContainerResult,
            /* [in] */ IMarkupPointer *pPointerStart,
            /* [in] */ IMarkupPointer *pPointerFinish);
        
        HRESULT ( STDMETHODCALLTYPE *IsScopedElement )( 
            IMarkupServices2 * This,
            /* [in] */ IHTMLElement *pElement,
            /* [out] */ BOOL *pfScoped);
        
        HRESULT ( STDMETHODCALLTYPE *GetElementTagId )( 
            IMarkupServices2 * This,
            /* [in] */ IHTMLElement *pElement,
            /* [out] */ ELEMENT_TAG_ID *ptagId);
        
        HRESULT ( STDMETHODCALLTYPE *GetTagIDForName )( 
            IMarkupServices2 * This,
            /* [in] */ BSTR bstrName,
            /* [out] */ ELEMENT_TAG_ID *ptagId);
        
        HRESULT ( STDMETHODCALLTYPE *GetNameForTagID )( 
            IMarkupServices2 * This,
            /* [in] */ ELEMENT_TAG_ID tagId,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *MovePointersToRange )( 
            IMarkupServices2 * This,
            /* [in] */ IHTMLTxtRange *pIRange,
            /* [in] */ IMarkupPointer *pPointerStart,
            /* [in] */ IMarkupPointer *pPointerFinish);
        
        HRESULT ( STDMETHODCALLTYPE *MoveRangeToPointers )( 
            IMarkupServices2 * This,
            /* [in] */ IMarkupPointer *pPointerStart,
            /* [in] */ IMarkupPointer *pPointerFinish,
            /* [in] */ IHTMLTxtRange *pIRange);
        
        HRESULT ( STDMETHODCALLTYPE *BeginUndoUnit )( 
            IMarkupServices2 * This,
            /* [in] */ OLECHAR *pchTitle);
        
        HRESULT ( STDMETHODCALLTYPE *EndUndoUnit )( 
            IMarkupServices2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParseGlobalEx )( 
            IMarkupServices2 * This,
            /* [in] */ HGLOBAL hglobalHTML,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IMarkupContainer *pContext,
            /* [out] */ IMarkupContainer **ppContainerResult,
            /* [in] */ IMarkupPointer *pPointerStart,
            /* [in] */ IMarkupPointer *pPointerFinish);
        
        HRESULT ( STDMETHODCALLTYPE *ValidateElements )( 
            IMarkupServices2 * This,
            /* [in] */ IMarkupPointer *pPointerStart,
            /* [in] */ IMarkupPointer *pPointerFinish,
            /* [in] */ IMarkupPointer *pPointerTarget,
            /* [out][in] */ IMarkupPointer *pPointerStatus,
            /* [out] */ IHTMLElement **ppElemFailBottom,
            /* [out] */ IHTMLElement **ppElemFailTop);
        
        HRESULT ( STDMETHODCALLTYPE *SaveSegmentsToClipboard )( 
            IMarkupServices2 * This,
            /* [in] */ ISegmentList *pSegmentList,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IMarkupServices2Vtbl;

    interface IMarkupServices2
    {
        CONST_VTBL struct IMarkupServices2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMarkupServices2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMarkupServices2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMarkupServices2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMarkupServices2_CreateMarkupPointer(This,ppPointer)	\
    (This)->lpVtbl -> CreateMarkupPointer(This,ppPointer)

#define IMarkupServices2_CreateMarkupContainer(This,ppMarkupContainer)	\
    (This)->lpVtbl -> CreateMarkupContainer(This,ppMarkupContainer)

#define IMarkupServices2_CreateElement(This,tagID,pchAttributes,ppElement)	\
    (This)->lpVtbl -> CreateElement(This,tagID,pchAttributes,ppElement)

#define IMarkupServices2_CloneElement(This,pElemCloneThis,ppElementTheClone)	\
    (This)->lpVtbl -> CloneElement(This,pElemCloneThis,ppElementTheClone)

#define IMarkupServices2_InsertElement(This,pElementInsert,pPointerStart,pPointerFinish)	\
    (This)->lpVtbl -> InsertElement(This,pElementInsert,pPointerStart,pPointerFinish)

#define IMarkupServices2_RemoveElement(This,pElementRemove)	\
    (This)->lpVtbl -> RemoveElement(This,pElementRemove)

#define IMarkupServices2_Remove(This,pPointerStart,pPointerFinish)	\
    (This)->lpVtbl -> Remove(This,pPointerStart,pPointerFinish)

#define IMarkupServices2_Copy(This,pPointerSourceStart,pPointerSourceFinish,pPointerTarget)	\
    (This)->lpVtbl -> Copy(This,pPointerSourceStart,pPointerSourceFinish,pPointerTarget)

#define IMarkupServices2_Move(This,pPointerSourceStart,pPointerSourceFinish,pPointerTarget)	\
    (This)->lpVtbl -> Move(This,pPointerSourceStart,pPointerSourceFinish,pPointerTarget)

#define IMarkupServices2_InsertText(This,pchText,cch,pPointerTarget)	\
    (This)->lpVtbl -> InsertText(This,pchText,cch,pPointerTarget)

#define IMarkupServices2_ParseString(This,pchHTML,dwFlags,ppContainerResult,ppPointerStart,ppPointerFinish)	\
    (This)->lpVtbl -> ParseString(This,pchHTML,dwFlags,ppContainerResult,ppPointerStart,ppPointerFinish)

#define IMarkupServices2_ParseGlobal(This,hglobalHTML,dwFlags,ppContainerResult,pPointerStart,pPointerFinish)	\
    (This)->lpVtbl -> ParseGlobal(This,hglobalHTML,dwFlags,ppContainerResult,pPointerStart,pPointerFinish)

#define IMarkupServices2_IsScopedElement(This,pElement,pfScoped)	\
    (This)->lpVtbl -> IsScopedElement(This,pElement,pfScoped)

#define IMarkupServices2_GetElementTagId(This,pElement,ptagId)	\
    (This)->lpVtbl -> GetElementTagId(This,pElement,ptagId)

#define IMarkupServices2_GetTagIDForName(This,bstrName,ptagId)	\
    (This)->lpVtbl -> GetTagIDForName(This,bstrName,ptagId)

#define IMarkupServices2_GetNameForTagID(This,tagId,pbstrName)	\
    (This)->lpVtbl -> GetNameForTagID(This,tagId,pbstrName)

#define IMarkupServices2_MovePointersToRange(This,pIRange,pPointerStart,pPointerFinish)	\
    (This)->lpVtbl -> MovePointersToRange(This,pIRange,pPointerStart,pPointerFinish)

#define IMarkupServices2_MoveRangeToPointers(This,pPointerStart,pPointerFinish,pIRange)	\
    (This)->lpVtbl -> MoveRangeToPointers(This,pPointerStart,pPointerFinish,pIRange)

#define IMarkupServices2_BeginUndoUnit(This,pchTitle)	\
    (This)->lpVtbl -> BeginUndoUnit(This,pchTitle)

#define IMarkupServices2_EndUndoUnit(This)	\
    (This)->lpVtbl -> EndUndoUnit(This)


#define IMarkupServices2_ParseGlobalEx(This,hglobalHTML,dwFlags,pContext,ppContainerResult,pPointerStart,pPointerFinish)	\
    (This)->lpVtbl -> ParseGlobalEx(This,hglobalHTML,dwFlags,pContext,ppContainerResult,pPointerStart,pPointerFinish)

#define IMarkupServices2_ValidateElements(This,pPointerStart,pPointerFinish,pPointerTarget,pPointerStatus,ppElemFailBottom,ppElemFailTop)	\
    (This)->lpVtbl -> ValidateElements(This,pPointerStart,pPointerFinish,pPointerTarget,pPointerStatus,ppElemFailBottom,ppElemFailTop)

#define IMarkupServices2_SaveSegmentsToClipboard(This,pSegmentList,dwFlags)	\
    (This)->lpVtbl -> SaveSegmentsToClipboard(This,pSegmentList,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMarkupServices2_ParseGlobalEx_Proxy( 
    IMarkupServices2 * This,
    /* [in] */ HGLOBAL hglobalHTML,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IMarkupContainer *pContext,
    /* [out] */ IMarkupContainer **ppContainerResult,
    /* [in] */ IMarkupPointer *pPointerStart,
    /* [in] */ IMarkupPointer *pPointerFinish);


void __RPC_STUB IMarkupServices2_ParseGlobalEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupServices2_ValidateElements_Proxy( 
    IMarkupServices2 * This,
    /* [in] */ IMarkupPointer *pPointerStart,
    /* [in] */ IMarkupPointer *pPointerFinish,
    /* [in] */ IMarkupPointer *pPointerTarget,
    /* [out][in] */ IMarkupPointer *pPointerStatus,
    /* [out] */ IHTMLElement **ppElemFailBottom,
    /* [out] */ IHTMLElement **ppElemFailTop);


void __RPC_STUB IMarkupServices2_ValidateElements_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupServices2_SaveSegmentsToClipboard_Proxy( 
    IMarkupServices2 * This,
    /* [in] */ ISegmentList *pSegmentList,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IMarkupServices2_SaveSegmentsToClipboard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMarkupServices2_INTERFACE_DEFINED__ */


#ifndef __IHTMLChangePlayback_INTERFACE_DEFINED__
#define __IHTMLChangePlayback_INTERFACE_DEFINED__

/* interface IHTMLChangePlayback */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLChangePlayback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f6e0-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLChangePlayback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ExecChange( 
            /* [in] */ BYTE *pbRecord,
            /* [in] */ BOOL fForward) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLChangePlaybackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLChangePlayback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLChangePlayback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLChangePlayback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ExecChange )( 
            IHTMLChangePlayback * This,
            /* [in] */ BYTE *pbRecord,
            /* [in] */ BOOL fForward);
        
        END_INTERFACE
    } IHTMLChangePlaybackVtbl;

    interface IHTMLChangePlayback
    {
        CONST_VTBL struct IHTMLChangePlaybackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLChangePlayback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLChangePlayback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLChangePlayback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLChangePlayback_ExecChange(This,pbRecord,fForward)	\
    (This)->lpVtbl -> ExecChange(This,pbRecord,fForward)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLChangePlayback_ExecChange_Proxy( 
    IHTMLChangePlayback * This,
    /* [in] */ BYTE *pbRecord,
    /* [in] */ BOOL fForward);


void __RPC_STUB IHTMLChangePlayback_ExecChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLChangePlayback_INTERFACE_DEFINED__ */


#ifndef __IMarkupPointer2_INTERFACE_DEFINED__
#define __IMarkupPointer2_INTERFACE_DEFINED__

/* interface IMarkupPointer2 */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IMarkupPointer2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f675-98b5-11cf-bb82-00aa00bdce0b")
    IMarkupPointer2 : public IMarkupPointer
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsAtWordBreak( 
            /* [out] */ BOOL *pfAtBreak) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMarkupPosition( 
            /* [out] */ long *plMP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveToMarkupPosition( 
            /* [in] */ IMarkupContainer *pContainer,
            /* [in] */ long lMP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveUnitBounded( 
            /* [in] */ MOVEUNIT_ACTION muAction,
            /* [in] */ IMarkupPointer *pIBoundary) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsInsideURL( 
            /* [in] */ IMarkupPointer *pRight,
            /* [out] */ BOOL *pfResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveToContent( 
            /* [in] */ IHTMLElement *pIElement,
            /* [in] */ BOOL fAtStart) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMarkupPointer2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMarkupPointer2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMarkupPointer2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMarkupPointer2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *OwningDoc )( 
            IMarkupPointer2 * This,
            /* [out] */ IHTMLDocument2 **ppDoc);
        
        HRESULT ( STDMETHODCALLTYPE *Gravity )( 
            IMarkupPointer2 * This,
            /* [out] */ POINTER_GRAVITY *pGravity);
        
        HRESULT ( STDMETHODCALLTYPE *SetGravity )( 
            IMarkupPointer2 * This,
            /* [in] */ POINTER_GRAVITY Gravity);
        
        HRESULT ( STDMETHODCALLTYPE *Cling )( 
            IMarkupPointer2 * This,
            /* [out] */ BOOL *pfCling);
        
        HRESULT ( STDMETHODCALLTYPE *SetCling )( 
            IMarkupPointer2 * This,
            /* [in] */ BOOL fCLing);
        
        HRESULT ( STDMETHODCALLTYPE *Unposition )( 
            IMarkupPointer2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsPositioned )( 
            IMarkupPointer2 * This,
            /* [out] */ BOOL *pfPositioned);
        
        HRESULT ( STDMETHODCALLTYPE *GetContainer )( 
            IMarkupPointer2 * This,
            /* [out] */ IMarkupContainer **ppContainer);
        
        HRESULT ( STDMETHODCALLTYPE *MoveAdjacentToElement )( 
            IMarkupPointer2 * This,
            /* [in] */ IHTMLElement *pElement,
            /* [in] */ ELEMENT_ADJACENCY eAdj);
        
        HRESULT ( STDMETHODCALLTYPE *MoveToPointer )( 
            IMarkupPointer2 * This,
            /* [in] */ IMarkupPointer *pPointer);
        
        HRESULT ( STDMETHODCALLTYPE *MoveToContainer )( 
            IMarkupPointer2 * This,
            /* [in] */ IMarkupContainer *pContainer,
            /* [in] */ BOOL fAtStart);
        
        HRESULT ( STDMETHODCALLTYPE *Left )( 
            IMarkupPointer2 * This,
            /* [in] */ BOOL fMove,
            /* [out] */ MARKUP_CONTEXT_TYPE *pContext,
            /* [out] */ IHTMLElement **ppElement,
            /* [out][in] */ long *pcch,
            /* [out] */ OLECHAR *pchText);
        
        HRESULT ( STDMETHODCALLTYPE *Right )( 
            IMarkupPointer2 * This,
            /* [in] */ BOOL fMove,
            /* [out] */ MARKUP_CONTEXT_TYPE *pContext,
            /* [out] */ IHTMLElement **ppElement,
            /* [out][in] */ long *pcch,
            /* [out] */ OLECHAR *pchText);
        
        HRESULT ( STDMETHODCALLTYPE *CurrentScope )( 
            IMarkupPointer2 * This,
            /* [out] */ IHTMLElement **ppElemCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *IsLeftOf )( 
            IMarkupPointer2 * This,
            /* [in] */ IMarkupPointer *pPointerThat,
            /* [out] */ BOOL *pfResult);
        
        HRESULT ( STDMETHODCALLTYPE *IsLeftOfOrEqualTo )( 
            IMarkupPointer2 * This,
            /* [in] */ IMarkupPointer *pPointerThat,
            /* [out] */ BOOL *pfResult);
        
        HRESULT ( STDMETHODCALLTYPE *IsRightOf )( 
            IMarkupPointer2 * This,
            /* [in] */ IMarkupPointer *pPointerThat,
            /* [out] */ BOOL *pfResult);
        
        HRESULT ( STDMETHODCALLTYPE *IsRightOfOrEqualTo )( 
            IMarkupPointer2 * This,
            /* [in] */ IMarkupPointer *pPointerThat,
            /* [out] */ BOOL *pfResult);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqualTo )( 
            IMarkupPointer2 * This,
            /* [in] */ IMarkupPointer *pPointerThat,
            /* [out] */ BOOL *pfAreEqual);
        
        HRESULT ( STDMETHODCALLTYPE *MoveUnit )( 
            IMarkupPointer2 * This,
            /* [in] */ MOVEUNIT_ACTION muAction);
        
        HRESULT ( STDMETHODCALLTYPE *FindText )( 
            IMarkupPointer2 * This,
            /* [in] */ OLECHAR *pchFindText,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IMarkupPointer *pIEndMatch,
            /* [in] */ IMarkupPointer *pIEndSearch);
        
        HRESULT ( STDMETHODCALLTYPE *IsAtWordBreak )( 
            IMarkupPointer2 * This,
            /* [out] */ BOOL *pfAtBreak);
        
        HRESULT ( STDMETHODCALLTYPE *GetMarkupPosition )( 
            IMarkupPointer2 * This,
            /* [out] */ long *plMP);
        
        HRESULT ( STDMETHODCALLTYPE *MoveToMarkupPosition )( 
            IMarkupPointer2 * This,
            /* [in] */ IMarkupContainer *pContainer,
            /* [in] */ long lMP);
        
        HRESULT ( STDMETHODCALLTYPE *MoveUnitBounded )( 
            IMarkupPointer2 * This,
            /* [in] */ MOVEUNIT_ACTION muAction,
            /* [in] */ IMarkupPointer *pIBoundary);
        
        HRESULT ( STDMETHODCALLTYPE *IsInsideURL )( 
            IMarkupPointer2 * This,
            /* [in] */ IMarkupPointer *pRight,
            /* [out] */ BOOL *pfResult);
        
        HRESULT ( STDMETHODCALLTYPE *MoveToContent )( 
            IMarkupPointer2 * This,
            /* [in] */ IHTMLElement *pIElement,
            /* [in] */ BOOL fAtStart);
        
        END_INTERFACE
    } IMarkupPointer2Vtbl;

    interface IMarkupPointer2
    {
        CONST_VTBL struct IMarkupPointer2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMarkupPointer2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMarkupPointer2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMarkupPointer2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMarkupPointer2_OwningDoc(This,ppDoc)	\
    (This)->lpVtbl -> OwningDoc(This,ppDoc)

#define IMarkupPointer2_Gravity(This,pGravity)	\
    (This)->lpVtbl -> Gravity(This,pGravity)

#define IMarkupPointer2_SetGravity(This,Gravity)	\
    (This)->lpVtbl -> SetGravity(This,Gravity)

#define IMarkupPointer2_Cling(This,pfCling)	\
    (This)->lpVtbl -> Cling(This,pfCling)

#define IMarkupPointer2_SetCling(This,fCLing)	\
    (This)->lpVtbl -> SetCling(This,fCLing)

#define IMarkupPointer2_Unposition(This)	\
    (This)->lpVtbl -> Unposition(This)

#define IMarkupPointer2_IsPositioned(This,pfPositioned)	\
    (This)->lpVtbl -> IsPositioned(This,pfPositioned)

#define IMarkupPointer2_GetContainer(This,ppContainer)	\
    (This)->lpVtbl -> GetContainer(This,ppContainer)

#define IMarkupPointer2_MoveAdjacentToElement(This,pElement,eAdj)	\
    (This)->lpVtbl -> MoveAdjacentToElement(This,pElement,eAdj)

#define IMarkupPointer2_MoveToPointer(This,pPointer)	\
    (This)->lpVtbl -> MoveToPointer(This,pPointer)

#define IMarkupPointer2_MoveToContainer(This,pContainer,fAtStart)	\
    (This)->lpVtbl -> MoveToContainer(This,pContainer,fAtStart)

#define IMarkupPointer2_Left(This,fMove,pContext,ppElement,pcch,pchText)	\
    (This)->lpVtbl -> Left(This,fMove,pContext,ppElement,pcch,pchText)

#define IMarkupPointer2_Right(This,fMove,pContext,ppElement,pcch,pchText)	\
    (This)->lpVtbl -> Right(This,fMove,pContext,ppElement,pcch,pchText)

#define IMarkupPointer2_CurrentScope(This,ppElemCurrent)	\
    (This)->lpVtbl -> CurrentScope(This,ppElemCurrent)

#define IMarkupPointer2_IsLeftOf(This,pPointerThat,pfResult)	\
    (This)->lpVtbl -> IsLeftOf(This,pPointerThat,pfResult)

#define IMarkupPointer2_IsLeftOfOrEqualTo(This,pPointerThat,pfResult)	\
    (This)->lpVtbl -> IsLeftOfOrEqualTo(This,pPointerThat,pfResult)

#define IMarkupPointer2_IsRightOf(This,pPointerThat,pfResult)	\
    (This)->lpVtbl -> IsRightOf(This,pPointerThat,pfResult)

#define IMarkupPointer2_IsRightOfOrEqualTo(This,pPointerThat,pfResult)	\
    (This)->lpVtbl -> IsRightOfOrEqualTo(This,pPointerThat,pfResult)

#define IMarkupPointer2_IsEqualTo(This,pPointerThat,pfAreEqual)	\
    (This)->lpVtbl -> IsEqualTo(This,pPointerThat,pfAreEqual)

#define IMarkupPointer2_MoveUnit(This,muAction)	\
    (This)->lpVtbl -> MoveUnit(This,muAction)

#define IMarkupPointer2_FindText(This,pchFindText,dwFlags,pIEndMatch,pIEndSearch)	\
    (This)->lpVtbl -> FindText(This,pchFindText,dwFlags,pIEndMatch,pIEndSearch)


#define IMarkupPointer2_IsAtWordBreak(This,pfAtBreak)	\
    (This)->lpVtbl -> IsAtWordBreak(This,pfAtBreak)

#define IMarkupPointer2_GetMarkupPosition(This,plMP)	\
    (This)->lpVtbl -> GetMarkupPosition(This,plMP)

#define IMarkupPointer2_MoveToMarkupPosition(This,pContainer,lMP)	\
    (This)->lpVtbl -> MoveToMarkupPosition(This,pContainer,lMP)

#define IMarkupPointer2_MoveUnitBounded(This,muAction,pIBoundary)	\
    (This)->lpVtbl -> MoveUnitBounded(This,muAction,pIBoundary)

#define IMarkupPointer2_IsInsideURL(This,pRight,pfResult)	\
    (This)->lpVtbl -> IsInsideURL(This,pRight,pfResult)

#define IMarkupPointer2_MoveToContent(This,pIElement,fAtStart)	\
    (This)->lpVtbl -> MoveToContent(This,pIElement,fAtStart)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMarkupPointer2_IsAtWordBreak_Proxy( 
    IMarkupPointer2 * This,
    /* [out] */ BOOL *pfAtBreak);


void __RPC_STUB IMarkupPointer2_IsAtWordBreak_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupPointer2_GetMarkupPosition_Proxy( 
    IMarkupPointer2 * This,
    /* [out] */ long *plMP);


void __RPC_STUB IMarkupPointer2_GetMarkupPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupPointer2_MoveToMarkupPosition_Proxy( 
    IMarkupPointer2 * This,
    /* [in] */ IMarkupContainer *pContainer,
    /* [in] */ long lMP);


void __RPC_STUB IMarkupPointer2_MoveToMarkupPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupPointer2_MoveUnitBounded_Proxy( 
    IMarkupPointer2 * This,
    /* [in] */ MOVEUNIT_ACTION muAction,
    /* [in] */ IMarkupPointer *pIBoundary);


void __RPC_STUB IMarkupPointer2_MoveUnitBounded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupPointer2_IsInsideURL_Proxy( 
    IMarkupPointer2 * This,
    /* [in] */ IMarkupPointer *pRight,
    /* [out] */ BOOL *pfResult);


void __RPC_STUB IMarkupPointer2_IsInsideURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupPointer2_MoveToContent_Proxy( 
    IMarkupPointer2 * This,
    /* [in] */ IHTMLElement *pIElement,
    /* [in] */ BOOL fAtStart);


void __RPC_STUB IMarkupPointer2_MoveToContent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMarkupPointer2_INTERFACE_DEFINED__ */


#ifndef __IMarkupTextFrags_INTERFACE_DEFINED__
#define __IMarkupTextFrags_INTERFACE_DEFINED__

/* interface IMarkupTextFrags */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IMarkupTextFrags;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f5fa-98b5-11cf-bb82-00aa00bdce0b")
    IMarkupTextFrags : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTextFragCount( 
            /* [out] */ long *pcFrags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTextFrag( 
            /* [in] */ long iFrag,
            /* [out] */ BSTR *pbstrFrag,
            /* [in] */ IMarkupPointer *pPointerFrag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveTextFrag( 
            /* [in] */ long iFrag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertTextFrag( 
            /* [in] */ long iFrag,
            /* [in] */ BSTR bstrInsert,
            /* [in] */ IMarkupPointer *pPointerInsert) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindTextFragFromMarkupPointer( 
            /* [in] */ IMarkupPointer *pPointerFind,
            /* [out] */ long *piFrag,
            /* [out] */ BOOL *pfFragFound) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMarkupTextFragsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMarkupTextFrags * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMarkupTextFrags * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMarkupTextFrags * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTextFragCount )( 
            IMarkupTextFrags * This,
            /* [out] */ long *pcFrags);
        
        HRESULT ( STDMETHODCALLTYPE *GetTextFrag )( 
            IMarkupTextFrags * This,
            /* [in] */ long iFrag,
            /* [out] */ BSTR *pbstrFrag,
            /* [in] */ IMarkupPointer *pPointerFrag);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveTextFrag )( 
            IMarkupTextFrags * This,
            /* [in] */ long iFrag);
        
        HRESULT ( STDMETHODCALLTYPE *InsertTextFrag )( 
            IMarkupTextFrags * This,
            /* [in] */ long iFrag,
            /* [in] */ BSTR bstrInsert,
            /* [in] */ IMarkupPointer *pPointerInsert);
        
        HRESULT ( STDMETHODCALLTYPE *FindTextFragFromMarkupPointer )( 
            IMarkupTextFrags * This,
            /* [in] */ IMarkupPointer *pPointerFind,
            /* [out] */ long *piFrag,
            /* [out] */ BOOL *pfFragFound);
        
        END_INTERFACE
    } IMarkupTextFragsVtbl;

    interface IMarkupTextFrags
    {
        CONST_VTBL struct IMarkupTextFragsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMarkupTextFrags_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMarkupTextFrags_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMarkupTextFrags_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMarkupTextFrags_GetTextFragCount(This,pcFrags)	\
    (This)->lpVtbl -> GetTextFragCount(This,pcFrags)

#define IMarkupTextFrags_GetTextFrag(This,iFrag,pbstrFrag,pPointerFrag)	\
    (This)->lpVtbl -> GetTextFrag(This,iFrag,pbstrFrag,pPointerFrag)

#define IMarkupTextFrags_RemoveTextFrag(This,iFrag)	\
    (This)->lpVtbl -> RemoveTextFrag(This,iFrag)

#define IMarkupTextFrags_InsertTextFrag(This,iFrag,bstrInsert,pPointerInsert)	\
    (This)->lpVtbl -> InsertTextFrag(This,iFrag,bstrInsert,pPointerInsert)

#define IMarkupTextFrags_FindTextFragFromMarkupPointer(This,pPointerFind,piFrag,pfFragFound)	\
    (This)->lpVtbl -> FindTextFragFromMarkupPointer(This,pPointerFind,piFrag,pfFragFound)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMarkupTextFrags_GetTextFragCount_Proxy( 
    IMarkupTextFrags * This,
    /* [out] */ long *pcFrags);


void __RPC_STUB IMarkupTextFrags_GetTextFragCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupTextFrags_GetTextFrag_Proxy( 
    IMarkupTextFrags * This,
    /* [in] */ long iFrag,
    /* [out] */ BSTR *pbstrFrag,
    /* [in] */ IMarkupPointer *pPointerFrag);


void __RPC_STUB IMarkupTextFrags_GetTextFrag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupTextFrags_RemoveTextFrag_Proxy( 
    IMarkupTextFrags * This,
    /* [in] */ long iFrag);


void __RPC_STUB IMarkupTextFrags_RemoveTextFrag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupTextFrags_InsertTextFrag_Proxy( 
    IMarkupTextFrags * This,
    /* [in] */ long iFrag,
    /* [in] */ BSTR bstrInsert,
    /* [in] */ IMarkupPointer *pPointerInsert);


void __RPC_STUB IMarkupTextFrags_InsertTextFrag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupTextFrags_FindTextFragFromMarkupPointer_Proxy( 
    IMarkupTextFrags * This,
    /* [in] */ IMarkupPointer *pPointerFind,
    /* [out] */ long *piFrag,
    /* [out] */ BOOL *pfFragFound);


void __RPC_STUB IMarkupTextFrags_FindTextFragFromMarkupPointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMarkupTextFrags_INTERFACE_DEFINED__ */


#ifndef __IXMLGenericParse_INTERFACE_DEFINED__
#define __IXMLGenericParse_INTERFACE_DEFINED__

/* interface IXMLGenericParse */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IXMLGenericParse;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E4E23071-4D07-11d2-AE76-0080C73BC199")
    IXMLGenericParse : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetGenericParse( 
            /* [in] */ VARIANT_BOOL fDoGeneric) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLGenericParseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLGenericParse * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLGenericParse * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLGenericParse * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetGenericParse )( 
            IXMLGenericParse * This,
            /* [in] */ VARIANT_BOOL fDoGeneric);
        
        END_INTERFACE
    } IXMLGenericParseVtbl;

    interface IXMLGenericParse
    {
        CONST_VTBL struct IXMLGenericParseVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLGenericParse_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLGenericParse_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLGenericParse_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLGenericParse_SetGenericParse(This,fDoGeneric)	\
    (This)->lpVtbl -> SetGenericParse(This,fDoGeneric)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLGenericParse_SetGenericParse_Proxy( 
    IXMLGenericParse * This,
    /* [in] */ VARIANT_BOOL fDoGeneric);


void __RPC_STUB IXMLGenericParse_SetGenericParse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLGenericParse_INTERFACE_DEFINED__ */


#ifndef __IHTMLEditHost_INTERFACE_DEFINED__
#define __IHTMLEditHost_INTERFACE_DEFINED__

/* interface IHTMLEditHost */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLEditHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f6a0-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLEditHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SnapRect( 
            /* [in] */ IHTMLElement *pIElement,
            /* [out][in] */ RECT *prcNew,
            /* [in] */ ELEMENT_CORNER eHandle) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLEditHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLEditHost * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLEditHost * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLEditHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *SnapRect )( 
            IHTMLEditHost * This,
            /* [in] */ IHTMLElement *pIElement,
            /* [out][in] */ RECT *prcNew,
            /* [in] */ ELEMENT_CORNER eHandle);
        
        END_INTERFACE
    } IHTMLEditHostVtbl;

    interface IHTMLEditHost
    {
        CONST_VTBL struct IHTMLEditHostVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLEditHost_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLEditHost_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLEditHost_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLEditHost_SnapRect(This,pIElement,prcNew,eHandle)	\
    (This)->lpVtbl -> SnapRect(This,pIElement,prcNew,eHandle)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLEditHost_SnapRect_Proxy( 
    IHTMLEditHost * This,
    /* [in] */ IHTMLElement *pIElement,
    /* [out][in] */ RECT *prcNew,
    /* [in] */ ELEMENT_CORNER eHandle);


void __RPC_STUB IHTMLEditHost_SnapRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLEditHost_INTERFACE_DEFINED__ */


#ifndef __IHTMLEditHost2_INTERFACE_DEFINED__
#define __IHTMLEditHost2_INTERFACE_DEFINED__

/* interface IHTMLEditHost2 */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLEditHost2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f848-98b5-11cf-bb82-00aa00bdce0d")
    IHTMLEditHost2 : public IHTMLEditHost
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PreDrag( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLEditHost2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLEditHost2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLEditHost2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLEditHost2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SnapRect )( 
            IHTMLEditHost2 * This,
            /* [in] */ IHTMLElement *pIElement,
            /* [out][in] */ RECT *prcNew,
            /* [in] */ ELEMENT_CORNER eHandle);
        
        HRESULT ( STDMETHODCALLTYPE *PreDrag )( 
            IHTMLEditHost2 * This);
        
        END_INTERFACE
    } IHTMLEditHost2Vtbl;

    interface IHTMLEditHost2
    {
        CONST_VTBL struct IHTMLEditHost2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLEditHost2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLEditHost2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLEditHost2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLEditHost2_SnapRect(This,pIElement,prcNew,eHandle)	\
    (This)->lpVtbl -> SnapRect(This,pIElement,prcNew,eHandle)


#define IHTMLEditHost2_PreDrag(This)	\
    (This)->lpVtbl -> PreDrag(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLEditHost2_PreDrag_Proxy( 
    IHTMLEditHost2 * This);


void __RPC_STUB IHTMLEditHost2_PreDrag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLEditHost2_INTERFACE_DEFINED__ */


#ifndef __ISequenceNumber_INTERFACE_DEFINED__
#define __ISequenceNumber_INTERFACE_DEFINED__

/* interface ISequenceNumber */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_ISequenceNumber;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f6c1-98b5-11cf-bb82-00aa00bdce0b")
    ISequenceNumber : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSequenceNumber( 
            /* [in] */ long nCurrent,
            /* [out] */ long *pnNew) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISequenceNumberVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISequenceNumber * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISequenceNumber * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISequenceNumber * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSequenceNumber )( 
            ISequenceNumber * This,
            /* [in] */ long nCurrent,
            /* [out] */ long *pnNew);
        
        END_INTERFACE
    } ISequenceNumberVtbl;

    interface ISequenceNumber
    {
        CONST_VTBL struct ISequenceNumberVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISequenceNumber_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISequenceNumber_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISequenceNumber_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISequenceNumber_GetSequenceNumber(This,nCurrent,pnNew)	\
    (This)->lpVtbl -> GetSequenceNumber(This,nCurrent,pnNew)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISequenceNumber_GetSequenceNumber_Proxy( 
    ISequenceNumber * This,
    /* [in] */ long nCurrent,
    /* [out] */ long *pnNew);


void __RPC_STUB ISequenceNumber_GetSequenceNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISequenceNumber_INTERFACE_DEFINED__ */


#ifndef __IIMEServices_INTERFACE_DEFINED__
#define __IIMEServices_INTERFACE_DEFINED__

/* interface IIMEServices */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IIMEServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f6ca-98b5-11cf-bb82-00aa00bdce0b")
    IIMEServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetActiveIMM( 
            /* [out] */ IActiveIMMApp **ppActiveIMM) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIMEServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIMEServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIMEServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIMEServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetActiveIMM )( 
            IIMEServices * This,
            /* [out] */ IActiveIMMApp **ppActiveIMM);
        
        END_INTERFACE
    } IIMEServicesVtbl;

    interface IIMEServices
    {
        CONST_VTBL struct IIMEServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIMEServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IIMEServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IIMEServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IIMEServices_GetActiveIMM(This,ppActiveIMM)	\
    (This)->lpVtbl -> GetActiveIMM(This,ppActiveIMM)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IIMEServices_GetActiveIMM_Proxy( 
    IIMEServices * This,
    /* [out] */ IActiveIMMApp **ppActiveIMM);


void __RPC_STUB IIMEServices_GetActiveIMM_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IIMEServices_INTERFACE_DEFINED__ */


#ifndef __ISelectionServicesListener_INTERFACE_DEFINED__
#define __ISelectionServicesListener_INTERFACE_DEFINED__

/* interface ISelectionServicesListener */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_ISelectionServicesListener;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f699-98b5-11cf-bb82-00aa00bdce0b")
    ISelectionServicesListener : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginSelectionUndo( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndSelectionUndo( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSelectedElementExit( 
            /* [in] */ IMarkupPointer *pIElementStart,
            /* [in] */ IMarkupPointer *pIElementEnd,
            /* [in] */ IMarkupPointer *pIElementContentStart,
            /* [in] */ IMarkupPointer *pIElementContentEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnChangeType( 
            /* [in] */ SELECTION_TYPE eType,
            /* [in] */ ISelectionServicesListener *pIListener) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeDetail( 
            /* [out] */ BSTR *pTypeDetail) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISelectionServicesListenerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISelectionServicesListener * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISelectionServicesListener * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISelectionServicesListener * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginSelectionUndo )( 
            ISelectionServicesListener * This);
        
        HRESULT ( STDMETHODCALLTYPE *EndSelectionUndo )( 
            ISelectionServicesListener * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnSelectedElementExit )( 
            ISelectionServicesListener * This,
            /* [in] */ IMarkupPointer *pIElementStart,
            /* [in] */ IMarkupPointer *pIElementEnd,
            /* [in] */ IMarkupPointer *pIElementContentStart,
            /* [in] */ IMarkupPointer *pIElementContentEnd);
        
        HRESULT ( STDMETHODCALLTYPE *OnChangeType )( 
            ISelectionServicesListener * This,
            /* [in] */ SELECTION_TYPE eType,
            /* [in] */ ISelectionServicesListener *pIListener);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeDetail )( 
            ISelectionServicesListener * This,
            /* [out] */ BSTR *pTypeDetail);
        
        END_INTERFACE
    } ISelectionServicesListenerVtbl;

    interface ISelectionServicesListener
    {
        CONST_VTBL struct ISelectionServicesListenerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISelectionServicesListener_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISelectionServicesListener_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISelectionServicesListener_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISelectionServicesListener_BeginSelectionUndo(This)	\
    (This)->lpVtbl -> BeginSelectionUndo(This)

#define ISelectionServicesListener_EndSelectionUndo(This)	\
    (This)->lpVtbl -> EndSelectionUndo(This)

#define ISelectionServicesListener_OnSelectedElementExit(This,pIElementStart,pIElementEnd,pIElementContentStart,pIElementContentEnd)	\
    (This)->lpVtbl -> OnSelectedElementExit(This,pIElementStart,pIElementEnd,pIElementContentStart,pIElementContentEnd)

#define ISelectionServicesListener_OnChangeType(This,eType,pIListener)	\
    (This)->lpVtbl -> OnChangeType(This,eType,pIListener)

#define ISelectionServicesListener_GetTypeDetail(This,pTypeDetail)	\
    (This)->lpVtbl -> GetTypeDetail(This,pTypeDetail)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISelectionServicesListener_BeginSelectionUndo_Proxy( 
    ISelectionServicesListener * This);


void __RPC_STUB ISelectionServicesListener_BeginSelectionUndo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISelectionServicesListener_EndSelectionUndo_Proxy( 
    ISelectionServicesListener * This);


void __RPC_STUB ISelectionServicesListener_EndSelectionUndo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISelectionServicesListener_OnSelectedElementExit_Proxy( 
    ISelectionServicesListener * This,
    /* [in] */ IMarkupPointer *pIElementStart,
    /* [in] */ IMarkupPointer *pIElementEnd,
    /* [in] */ IMarkupPointer *pIElementContentStart,
    /* [in] */ IMarkupPointer *pIElementContentEnd);


void __RPC_STUB ISelectionServicesListener_OnSelectedElementExit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISelectionServicesListener_OnChangeType_Proxy( 
    ISelectionServicesListener * This,
    /* [in] */ SELECTION_TYPE eType,
    /* [in] */ ISelectionServicesListener *pIListener);


void __RPC_STUB ISelectionServicesListener_OnChangeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISelectionServicesListener_GetTypeDetail_Proxy( 
    ISelectionServicesListener * This,
    /* [out] */ BSTR *pTypeDetail);


void __RPC_STUB ISelectionServicesListener_GetTypeDetail_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISelectionServicesListener_INTERFACE_DEFINED__ */


#ifndef __ISelectionServices_INTERFACE_DEFINED__
#define __ISelectionServices_INTERFACE_DEFINED__

/* interface ISelectionServices */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_ISelectionServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f684-98b5-11cf-bb82-00aa00bdce0b")
    ISelectionServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetSelectionType( 
            /* [in] */ SELECTION_TYPE eType,
            /* [in] */ ISelectionServicesListener *pIListener) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMarkupContainer( 
            /* [out] */ IMarkupContainer **ppIContainer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddSegment( 
            /* [in] */ IMarkupPointer *pIStart,
            /* [in] */ IMarkupPointer *pIEnd,
            /* [out] */ ISegment **ppISegmentAdded) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddElementSegment( 
            /* [in] */ IHTMLElement *pIElement,
            /* [out] */ IElementSegment **ppISegmentAdded) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveSegment( 
            /* [in] */ ISegment *pISegment) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelectionServicesListener( 
            /* [out] */ ISelectionServicesListener **ppISelectionServicesListener) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISelectionServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISelectionServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISelectionServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISelectionServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSelectionType )( 
            ISelectionServices * This,
            /* [in] */ SELECTION_TYPE eType,
            /* [in] */ ISelectionServicesListener *pIListener);
        
        HRESULT ( STDMETHODCALLTYPE *GetMarkupContainer )( 
            ISelectionServices * This,
            /* [out] */ IMarkupContainer **ppIContainer);
        
        HRESULT ( STDMETHODCALLTYPE *AddSegment )( 
            ISelectionServices * This,
            /* [in] */ IMarkupPointer *pIStart,
            /* [in] */ IMarkupPointer *pIEnd,
            /* [out] */ ISegment **ppISegmentAdded);
        
        HRESULT ( STDMETHODCALLTYPE *AddElementSegment )( 
            ISelectionServices * This,
            /* [in] */ IHTMLElement *pIElement,
            /* [out] */ IElementSegment **ppISegmentAdded);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveSegment )( 
            ISelectionServices * This,
            /* [in] */ ISegment *pISegment);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectionServicesListener )( 
            ISelectionServices * This,
            /* [out] */ ISelectionServicesListener **ppISelectionServicesListener);
        
        END_INTERFACE
    } ISelectionServicesVtbl;

    interface ISelectionServices
    {
        CONST_VTBL struct ISelectionServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISelectionServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISelectionServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISelectionServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISelectionServices_SetSelectionType(This,eType,pIListener)	\
    (This)->lpVtbl -> SetSelectionType(This,eType,pIListener)

#define ISelectionServices_GetMarkupContainer(This,ppIContainer)	\
    (This)->lpVtbl -> GetMarkupContainer(This,ppIContainer)

#define ISelectionServices_AddSegment(This,pIStart,pIEnd,ppISegmentAdded)	\
    (This)->lpVtbl -> AddSegment(This,pIStart,pIEnd,ppISegmentAdded)

#define ISelectionServices_AddElementSegment(This,pIElement,ppISegmentAdded)	\
    (This)->lpVtbl -> AddElementSegment(This,pIElement,ppISegmentAdded)

#define ISelectionServices_RemoveSegment(This,pISegment)	\
    (This)->lpVtbl -> RemoveSegment(This,pISegment)

#define ISelectionServices_GetSelectionServicesListener(This,ppISelectionServicesListener)	\
    (This)->lpVtbl -> GetSelectionServicesListener(This,ppISelectionServicesListener)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISelectionServices_SetSelectionType_Proxy( 
    ISelectionServices * This,
    /* [in] */ SELECTION_TYPE eType,
    /* [in] */ ISelectionServicesListener *pIListener);


void __RPC_STUB ISelectionServices_SetSelectionType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISelectionServices_GetMarkupContainer_Proxy( 
    ISelectionServices * This,
    /* [out] */ IMarkupContainer **ppIContainer);


void __RPC_STUB ISelectionServices_GetMarkupContainer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISelectionServices_AddSegment_Proxy( 
    ISelectionServices * This,
    /* [in] */ IMarkupPointer *pIStart,
    /* [in] */ IMarkupPointer *pIEnd,
    /* [out] */ ISegment **ppISegmentAdded);


void __RPC_STUB ISelectionServices_AddSegment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISelectionServices_AddElementSegment_Proxy( 
    ISelectionServices * This,
    /* [in] */ IHTMLElement *pIElement,
    /* [out] */ IElementSegment **ppISegmentAdded);


void __RPC_STUB ISelectionServices_AddElementSegment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISelectionServices_RemoveSegment_Proxy( 
    ISelectionServices * This,
    /* [in] */ ISegment *pISegment);


void __RPC_STUB ISelectionServices_RemoveSegment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISelectionServices_GetSelectionServicesListener_Proxy( 
    ISelectionServices * This,
    /* [out] */ ISelectionServicesListener **ppISelectionServicesListener);


void __RPC_STUB ISelectionServices_GetSelectionServicesListener_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISelectionServices_INTERFACE_DEFINED__ */


#ifndef __IHTMLEditDesigner_INTERFACE_DEFINED__
#define __IHTMLEditDesigner_INTERFACE_DEFINED__

/* interface IHTMLEditDesigner */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLEditDesigner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f662-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLEditDesigner : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PreHandleEvent( 
            /* [in] */ DISPID inEvtDispId,
            /* [in] */ IHTMLEventObj *pIEventObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PostHandleEvent( 
            /* [in] */ DISPID inEvtDispId,
            /* [in] */ IHTMLEventObj *pIEventObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator( 
            /* [in] */ DISPID inEvtDispId,
            /* [in] */ IHTMLEventObj *pIEventObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PostEditorEventNotify( 
            /* [in] */ DISPID inEvtDispId,
            /* [in] */ IHTMLEventObj *pIEventObj) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLEditDesignerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLEditDesigner * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLEditDesigner * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLEditDesigner * This);
        
        HRESULT ( STDMETHODCALLTYPE *PreHandleEvent )( 
            IHTMLEditDesigner * This,
            /* [in] */ DISPID inEvtDispId,
            /* [in] */ IHTMLEventObj *pIEventObj);
        
        HRESULT ( STDMETHODCALLTYPE *PostHandleEvent )( 
            IHTMLEditDesigner * This,
            /* [in] */ DISPID inEvtDispId,
            /* [in] */ IHTMLEventObj *pIEventObj);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateAccelerator )( 
            IHTMLEditDesigner * This,
            /* [in] */ DISPID inEvtDispId,
            /* [in] */ IHTMLEventObj *pIEventObj);
        
        HRESULT ( STDMETHODCALLTYPE *PostEditorEventNotify )( 
            IHTMLEditDesigner * This,
            /* [in] */ DISPID inEvtDispId,
            /* [in] */ IHTMLEventObj *pIEventObj);
        
        END_INTERFACE
    } IHTMLEditDesignerVtbl;

    interface IHTMLEditDesigner
    {
        CONST_VTBL struct IHTMLEditDesignerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLEditDesigner_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLEditDesigner_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLEditDesigner_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLEditDesigner_PreHandleEvent(This,inEvtDispId,pIEventObj)	\
    (This)->lpVtbl -> PreHandleEvent(This,inEvtDispId,pIEventObj)

#define IHTMLEditDesigner_PostHandleEvent(This,inEvtDispId,pIEventObj)	\
    (This)->lpVtbl -> PostHandleEvent(This,inEvtDispId,pIEventObj)

#define IHTMLEditDesigner_TranslateAccelerator(This,inEvtDispId,pIEventObj)	\
    (This)->lpVtbl -> TranslateAccelerator(This,inEvtDispId,pIEventObj)

#define IHTMLEditDesigner_PostEditorEventNotify(This,inEvtDispId,pIEventObj)	\
    (This)->lpVtbl -> PostEditorEventNotify(This,inEvtDispId,pIEventObj)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLEditDesigner_PreHandleEvent_Proxy( 
    IHTMLEditDesigner * This,
    /* [in] */ DISPID inEvtDispId,
    /* [in] */ IHTMLEventObj *pIEventObj);


void __RPC_STUB IHTMLEditDesigner_PreHandleEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditDesigner_PostHandleEvent_Proxy( 
    IHTMLEditDesigner * This,
    /* [in] */ DISPID inEvtDispId,
    /* [in] */ IHTMLEventObj *pIEventObj);


void __RPC_STUB IHTMLEditDesigner_PostHandleEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditDesigner_TranslateAccelerator_Proxy( 
    IHTMLEditDesigner * This,
    /* [in] */ DISPID inEvtDispId,
    /* [in] */ IHTMLEventObj *pIEventObj);


void __RPC_STUB IHTMLEditDesigner_TranslateAccelerator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditDesigner_PostEditorEventNotify_Proxy( 
    IHTMLEditDesigner * This,
    /* [in] */ DISPID inEvtDispId,
    /* [in] */ IHTMLEventObj *pIEventObj);


void __RPC_STUB IHTMLEditDesigner_PostEditorEventNotify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLEditDesigner_INTERFACE_DEFINED__ */


#ifndef __IHTMLEditServices_INTERFACE_DEFINED__
#define __IHTMLEditServices_INTERFACE_DEFINED__

/* interface IHTMLEditServices */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLEditServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f663-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLEditServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddDesigner( 
            /* [in] */ IHTMLEditDesigner *pIDesigner) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveDesigner( 
            /* [in] */ IHTMLEditDesigner *pIDesigner) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelectionServices( 
            /* [in] */ IMarkupContainer *pIContainer,
            /* [out] */ ISelectionServices **ppSelSvc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveToSelectionAnchor( 
            /* [in] */ IMarkupPointer *pIStartAnchor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveToSelectionEnd( 
            /* [in] */ IMarkupPointer *pIEndAnchor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectRange( 
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd,
            /* [in] */ SELECTION_TYPE eType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLEditServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLEditServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLEditServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLEditServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddDesigner )( 
            IHTMLEditServices * This,
            /* [in] */ IHTMLEditDesigner *pIDesigner);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveDesigner )( 
            IHTMLEditServices * This,
            /* [in] */ IHTMLEditDesigner *pIDesigner);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectionServices )( 
            IHTMLEditServices * This,
            /* [in] */ IMarkupContainer *pIContainer,
            /* [out] */ ISelectionServices **ppSelSvc);
        
        HRESULT ( STDMETHODCALLTYPE *MoveToSelectionAnchor )( 
            IHTMLEditServices * This,
            /* [in] */ IMarkupPointer *pIStartAnchor);
        
        HRESULT ( STDMETHODCALLTYPE *MoveToSelectionEnd )( 
            IHTMLEditServices * This,
            /* [in] */ IMarkupPointer *pIEndAnchor);
        
        HRESULT ( STDMETHODCALLTYPE *SelectRange )( 
            IHTMLEditServices * This,
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd,
            /* [in] */ SELECTION_TYPE eType);
        
        END_INTERFACE
    } IHTMLEditServicesVtbl;

    interface IHTMLEditServices
    {
        CONST_VTBL struct IHTMLEditServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLEditServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLEditServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLEditServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLEditServices_AddDesigner(This,pIDesigner)	\
    (This)->lpVtbl -> AddDesigner(This,pIDesigner)

#define IHTMLEditServices_RemoveDesigner(This,pIDesigner)	\
    (This)->lpVtbl -> RemoveDesigner(This,pIDesigner)

#define IHTMLEditServices_GetSelectionServices(This,pIContainer,ppSelSvc)	\
    (This)->lpVtbl -> GetSelectionServices(This,pIContainer,ppSelSvc)

#define IHTMLEditServices_MoveToSelectionAnchor(This,pIStartAnchor)	\
    (This)->lpVtbl -> MoveToSelectionAnchor(This,pIStartAnchor)

#define IHTMLEditServices_MoveToSelectionEnd(This,pIEndAnchor)	\
    (This)->lpVtbl -> MoveToSelectionEnd(This,pIEndAnchor)

#define IHTMLEditServices_SelectRange(This,pStart,pEnd,eType)	\
    (This)->lpVtbl -> SelectRange(This,pStart,pEnd,eType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLEditServices_AddDesigner_Proxy( 
    IHTMLEditServices * This,
    /* [in] */ IHTMLEditDesigner *pIDesigner);


void __RPC_STUB IHTMLEditServices_AddDesigner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditServices_RemoveDesigner_Proxy( 
    IHTMLEditServices * This,
    /* [in] */ IHTMLEditDesigner *pIDesigner);


void __RPC_STUB IHTMLEditServices_RemoveDesigner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditServices_GetSelectionServices_Proxy( 
    IHTMLEditServices * This,
    /* [in] */ IMarkupContainer *pIContainer,
    /* [out] */ ISelectionServices **ppSelSvc);


void __RPC_STUB IHTMLEditServices_GetSelectionServices_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditServices_MoveToSelectionAnchor_Proxy( 
    IHTMLEditServices * This,
    /* [in] */ IMarkupPointer *pIStartAnchor);


void __RPC_STUB IHTMLEditServices_MoveToSelectionAnchor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditServices_MoveToSelectionEnd_Proxy( 
    IHTMLEditServices * This,
    /* [in] */ IMarkupPointer *pIEndAnchor);


void __RPC_STUB IHTMLEditServices_MoveToSelectionEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditServices_SelectRange_Proxy( 
    IHTMLEditServices * This,
    /* [in] */ IMarkupPointer *pStart,
    /* [in] */ IMarkupPointer *pEnd,
    /* [in] */ SELECTION_TYPE eType);


void __RPC_STUB IHTMLEditServices_SelectRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLEditServices_INTERFACE_DEFINED__ */


#ifndef __IHTMLEditServices2_INTERFACE_DEFINED__
#define __IHTMLEditServices2_INTERFACE_DEFINED__

/* interface IHTMLEditServices2 */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLEditServices2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f812-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLEditServices2 : public IHTMLEditServices
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MoveToSelectionAnchorEx( 
            /* [in] */ IDisplayPointer *pIStartAnchor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveToSelectionEndEx( 
            /* [in] */ IDisplayPointer *pIEndAnchor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreezeVirtualCaretPos( 
            /* [in] */ BOOL fReCompute) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnFreezeVirtualCaretPos( 
            /* [in] */ BOOL fReset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLEditServices2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLEditServices2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLEditServices2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLEditServices2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddDesigner )( 
            IHTMLEditServices2 * This,
            /* [in] */ IHTMLEditDesigner *pIDesigner);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveDesigner )( 
            IHTMLEditServices2 * This,
            /* [in] */ IHTMLEditDesigner *pIDesigner);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectionServices )( 
            IHTMLEditServices2 * This,
            /* [in] */ IMarkupContainer *pIContainer,
            /* [out] */ ISelectionServices **ppSelSvc);
        
        HRESULT ( STDMETHODCALLTYPE *MoveToSelectionAnchor )( 
            IHTMLEditServices2 * This,
            /* [in] */ IMarkupPointer *pIStartAnchor);
        
        HRESULT ( STDMETHODCALLTYPE *MoveToSelectionEnd )( 
            IHTMLEditServices2 * This,
            /* [in] */ IMarkupPointer *pIEndAnchor);
        
        HRESULT ( STDMETHODCALLTYPE *SelectRange )( 
            IHTMLEditServices2 * This,
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd,
            /* [in] */ SELECTION_TYPE eType);
        
        HRESULT ( STDMETHODCALLTYPE *MoveToSelectionAnchorEx )( 
            IHTMLEditServices2 * This,
            /* [in] */ IDisplayPointer *pIStartAnchor);
        
        HRESULT ( STDMETHODCALLTYPE *MoveToSelectionEndEx )( 
            IHTMLEditServices2 * This,
            /* [in] */ IDisplayPointer *pIEndAnchor);
        
        HRESULT ( STDMETHODCALLTYPE *FreezeVirtualCaretPos )( 
            IHTMLEditServices2 * This,
            /* [in] */ BOOL fReCompute);
        
        HRESULT ( STDMETHODCALLTYPE *UnFreezeVirtualCaretPos )( 
            IHTMLEditServices2 * This,
            /* [in] */ BOOL fReset);
        
        END_INTERFACE
    } IHTMLEditServices2Vtbl;

    interface IHTMLEditServices2
    {
        CONST_VTBL struct IHTMLEditServices2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLEditServices2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLEditServices2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLEditServices2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLEditServices2_AddDesigner(This,pIDesigner)	\
    (This)->lpVtbl -> AddDesigner(This,pIDesigner)

#define IHTMLEditServices2_RemoveDesigner(This,pIDesigner)	\
    (This)->lpVtbl -> RemoveDesigner(This,pIDesigner)

#define IHTMLEditServices2_GetSelectionServices(This,pIContainer,ppSelSvc)	\
    (This)->lpVtbl -> GetSelectionServices(This,pIContainer,ppSelSvc)

#define IHTMLEditServices2_MoveToSelectionAnchor(This,pIStartAnchor)	\
    (This)->lpVtbl -> MoveToSelectionAnchor(This,pIStartAnchor)

#define IHTMLEditServices2_MoveToSelectionEnd(This,pIEndAnchor)	\
    (This)->lpVtbl -> MoveToSelectionEnd(This,pIEndAnchor)

#define IHTMLEditServices2_SelectRange(This,pStart,pEnd,eType)	\
    (This)->lpVtbl -> SelectRange(This,pStart,pEnd,eType)


#define IHTMLEditServices2_MoveToSelectionAnchorEx(This,pIStartAnchor)	\
    (This)->lpVtbl -> MoveToSelectionAnchorEx(This,pIStartAnchor)

#define IHTMLEditServices2_MoveToSelectionEndEx(This,pIEndAnchor)	\
    (This)->lpVtbl -> MoveToSelectionEndEx(This,pIEndAnchor)

#define IHTMLEditServices2_FreezeVirtualCaretPos(This,fReCompute)	\
    (This)->lpVtbl -> FreezeVirtualCaretPos(This,fReCompute)

#define IHTMLEditServices2_UnFreezeVirtualCaretPos(This,fReset)	\
    (This)->lpVtbl -> UnFreezeVirtualCaretPos(This,fReset)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLEditServices2_MoveToSelectionAnchorEx_Proxy( 
    IHTMLEditServices2 * This,
    /* [in] */ IDisplayPointer *pIStartAnchor);


void __RPC_STUB IHTMLEditServices2_MoveToSelectionAnchorEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditServices2_MoveToSelectionEndEx_Proxy( 
    IHTMLEditServices2 * This,
    /* [in] */ IDisplayPointer *pIEndAnchor);


void __RPC_STUB IHTMLEditServices2_MoveToSelectionEndEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditServices2_FreezeVirtualCaretPos_Proxy( 
    IHTMLEditServices2 * This,
    /* [in] */ BOOL fReCompute);


void __RPC_STUB IHTMLEditServices2_FreezeVirtualCaretPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditServices2_UnFreezeVirtualCaretPos_Proxy( 
    IHTMLEditServices2 * This,
    /* [in] */ BOOL fReset);


void __RPC_STUB IHTMLEditServices2_UnFreezeVirtualCaretPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLEditServices2_INTERFACE_DEFINED__ */


#ifndef __IHTMLComputedStyle_INTERFACE_DEFINED__
#define __IHTMLComputedStyle_INTERFACE_DEFINED__

/* interface IHTMLComputedStyle */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLComputedStyle;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f6c3-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLComputedStyle : public IUnknown
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_bold( 
            /* [out][retval] */ VARIANT_BOOL *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_italic( 
            /* [out][retval] */ VARIANT_BOOL *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_underline( 
            /* [out][retval] */ VARIANT_BOOL *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_overline( 
            /* [out][retval] */ VARIANT_BOOL *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_strikeOut( 
            /* [out][retval] */ VARIANT_BOOL *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_subScript( 
            /* [out][retval] */ VARIANT_BOOL *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_superScript( 
            /* [out][retval] */ VARIANT_BOOL *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_explicitFace( 
            /* [out][retval] */ VARIANT_BOOL *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_fontWeight( 
            /* [out][retval] */ long *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_fontSize( 
            /* [out][retval] */ long *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_fontName( 
            /* [out][retval] */ TCHAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_hasBgColor( 
            /* [out][retval] */ VARIANT_BOOL *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_textColor( 
            /* [out][retval] */ DWORD *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_backgroundColor( 
            /* [out][retval] */ DWORD *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_preFormatted( 
            /* [out][retval] */ VARIANT_BOOL *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_direction( 
            /* [out][retval] */ VARIANT_BOOL *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_blockDirection( 
            /* [out][retval] */ VARIANT_BOOL *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_OL( 
            /* [out][retval] */ VARIANT_BOOL *p) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEqual( 
            /* [in] */ IHTMLComputedStyle *pComputedStyle,
            /* [out] */ VARIANT_BOOL *pfEqual) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLComputedStyleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLComputedStyle * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLComputedStyle * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLComputedStyle * This);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_bold )( 
            IHTMLComputedStyle * This,
            /* [out][retval] */ VARIANT_BOOL *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_italic )( 
            IHTMLComputedStyle * This,
            /* [out][retval] */ VARIANT_BOOL *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_underline )( 
            IHTMLComputedStyle * This,
            /* [out][retval] */ VARIANT_BOOL *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_overline )( 
            IHTMLComputedStyle * This,
            /* [out][retval] */ VARIANT_BOOL *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_strikeOut )( 
            IHTMLComputedStyle * This,
            /* [out][retval] */ VARIANT_BOOL *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_subScript )( 
            IHTMLComputedStyle * This,
            /* [out][retval] */ VARIANT_BOOL *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_superScript )( 
            IHTMLComputedStyle * This,
            /* [out][retval] */ VARIANT_BOOL *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_explicitFace )( 
            IHTMLComputedStyle * This,
            /* [out][retval] */ VARIANT_BOOL *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_fontWeight )( 
            IHTMLComputedStyle * This,
            /* [out][retval] */ long *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_fontSize )( 
            IHTMLComputedStyle * This,
            /* [out][retval] */ long *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_fontName )( 
            IHTMLComputedStyle * This,
            /* [out][retval] */ TCHAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_hasBgColor )( 
            IHTMLComputedStyle * This,
            /* [out][retval] */ VARIANT_BOOL *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_textColor )( 
            IHTMLComputedStyle * This,
            /* [out][retval] */ DWORD *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_backgroundColor )( 
            IHTMLComputedStyle * This,
            /* [out][retval] */ DWORD *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_preFormatted )( 
            IHTMLComputedStyle * This,
            /* [out][retval] */ VARIANT_BOOL *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_direction )( 
            IHTMLComputedStyle * This,
            /* [out][retval] */ VARIANT_BOOL *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_blockDirection )( 
            IHTMLComputedStyle * This,
            /* [out][retval] */ VARIANT_BOOL *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OL )( 
            IHTMLComputedStyle * This,
            /* [out][retval] */ VARIANT_BOOL *p);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqual )( 
            IHTMLComputedStyle * This,
            /* [in] */ IHTMLComputedStyle *pComputedStyle,
            /* [out] */ VARIANT_BOOL *pfEqual);
        
        END_INTERFACE
    } IHTMLComputedStyleVtbl;

    interface IHTMLComputedStyle
    {
        CONST_VTBL struct IHTMLComputedStyleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLComputedStyle_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLComputedStyle_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLComputedStyle_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLComputedStyle_get_bold(This,p)	\
    (This)->lpVtbl -> get_bold(This,p)

#define IHTMLComputedStyle_get_italic(This,p)	\
    (This)->lpVtbl -> get_italic(This,p)

#define IHTMLComputedStyle_get_underline(This,p)	\
    (This)->lpVtbl -> get_underline(This,p)

#define IHTMLComputedStyle_get_overline(This,p)	\
    (This)->lpVtbl -> get_overline(This,p)

#define IHTMLComputedStyle_get_strikeOut(This,p)	\
    (This)->lpVtbl -> get_strikeOut(This,p)

#define IHTMLComputedStyle_get_subScript(This,p)	\
    (This)->lpVtbl -> get_subScript(This,p)

#define IHTMLComputedStyle_get_superScript(This,p)	\
    (This)->lpVtbl -> get_superScript(This,p)

#define IHTMLComputedStyle_get_explicitFace(This,p)	\
    (This)->lpVtbl -> get_explicitFace(This,p)

#define IHTMLComputedStyle_get_fontWeight(This,p)	\
    (This)->lpVtbl -> get_fontWeight(This,p)

#define IHTMLComputedStyle_get_fontSize(This,p)	\
    (This)->lpVtbl -> get_fontSize(This,p)

#define IHTMLComputedStyle_get_fontName(This,p)	\
    (This)->lpVtbl -> get_fontName(This,p)

#define IHTMLComputedStyle_get_hasBgColor(This,p)	\
    (This)->lpVtbl -> get_hasBgColor(This,p)

#define IHTMLComputedStyle_get_textColor(This,p)	\
    (This)->lpVtbl -> get_textColor(This,p)

#define IHTMLComputedStyle_get_backgroundColor(This,p)	\
    (This)->lpVtbl -> get_backgroundColor(This,p)

#define IHTMLComputedStyle_get_preFormatted(This,p)	\
    (This)->lpVtbl -> get_preFormatted(This,p)

#define IHTMLComputedStyle_get_direction(This,p)	\
    (This)->lpVtbl -> get_direction(This,p)

#define IHTMLComputedStyle_get_blockDirection(This,p)	\
    (This)->lpVtbl -> get_blockDirection(This,p)

#define IHTMLComputedStyle_get_OL(This,p)	\
    (This)->lpVtbl -> get_OL(This,p)

#define IHTMLComputedStyle_IsEqual(This,pComputedStyle,pfEqual)	\
    (This)->lpVtbl -> IsEqual(This,pComputedStyle,pfEqual)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLComputedStyle_get_bold_Proxy( 
    IHTMLComputedStyle * This,
    /* [out][retval] */ VARIANT_BOOL *p);


void __RPC_STUB IHTMLComputedStyle_get_bold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLComputedStyle_get_italic_Proxy( 
    IHTMLComputedStyle * This,
    /* [out][retval] */ VARIANT_BOOL *p);


void __RPC_STUB IHTMLComputedStyle_get_italic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLComputedStyle_get_underline_Proxy( 
    IHTMLComputedStyle * This,
    /* [out][retval] */ VARIANT_BOOL *p);


void __RPC_STUB IHTMLComputedStyle_get_underline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLComputedStyle_get_overline_Proxy( 
    IHTMLComputedStyle * This,
    /* [out][retval] */ VARIANT_BOOL *p);


void __RPC_STUB IHTMLComputedStyle_get_overline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLComputedStyle_get_strikeOut_Proxy( 
    IHTMLComputedStyle * This,
    /* [out][retval] */ VARIANT_BOOL *p);


void __RPC_STUB IHTMLComputedStyle_get_strikeOut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLComputedStyle_get_subScript_Proxy( 
    IHTMLComputedStyle * This,
    /* [out][retval] */ VARIANT_BOOL *p);


void __RPC_STUB IHTMLComputedStyle_get_subScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLComputedStyle_get_superScript_Proxy( 
    IHTMLComputedStyle * This,
    /* [out][retval] */ VARIANT_BOOL *p);


void __RPC_STUB IHTMLComputedStyle_get_superScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLComputedStyle_get_explicitFace_Proxy( 
    IHTMLComputedStyle * This,
    /* [out][retval] */ VARIANT_BOOL *p);


void __RPC_STUB IHTMLComputedStyle_get_explicitFace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLComputedStyle_get_fontWeight_Proxy( 
    IHTMLComputedStyle * This,
    /* [out][retval] */ long *p);


void __RPC_STUB IHTMLComputedStyle_get_fontWeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLComputedStyle_get_fontSize_Proxy( 
    IHTMLComputedStyle * This,
    /* [out][retval] */ long *p);


void __RPC_STUB IHTMLComputedStyle_get_fontSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLComputedStyle_get_fontName_Proxy( 
    IHTMLComputedStyle * This,
    /* [out][retval] */ TCHAR *p);


void __RPC_STUB IHTMLComputedStyle_get_fontName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLComputedStyle_get_hasBgColor_Proxy( 
    IHTMLComputedStyle * This,
    /* [out][retval] */ VARIANT_BOOL *p);


void __RPC_STUB IHTMLComputedStyle_get_hasBgColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLComputedStyle_get_textColor_Proxy( 
    IHTMLComputedStyle * This,
    /* [out][retval] */ DWORD *p);


void __RPC_STUB IHTMLComputedStyle_get_textColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLComputedStyle_get_backgroundColor_Proxy( 
    IHTMLComputedStyle * This,
    /* [out][retval] */ DWORD *p);


void __RPC_STUB IHTMLComputedStyle_get_backgroundColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLComputedStyle_get_preFormatted_Proxy( 
    IHTMLComputedStyle * This,
    /* [out][retval] */ VARIANT_BOOL *p);


void __RPC_STUB IHTMLComputedStyle_get_preFormatted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLComputedStyle_get_direction_Proxy( 
    IHTMLComputedStyle * This,
    /* [out][retval] */ VARIANT_BOOL *p);


void __RPC_STUB IHTMLComputedStyle_get_direction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLComputedStyle_get_blockDirection_Proxy( 
    IHTMLComputedStyle * This,
    /* [out][retval] */ VARIANT_BOOL *p);


void __RPC_STUB IHTMLComputedStyle_get_blockDirection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLComputedStyle_get_OL_Proxy( 
    IHTMLComputedStyle * This,
    /* [out][retval] */ VARIANT_BOOL *p);


void __RPC_STUB IHTMLComputedStyle_get_OL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLComputedStyle_IsEqual_Proxy( 
    IHTMLComputedStyle * This,
    /* [in] */ IHTMLComputedStyle *pComputedStyle,
    /* [out] */ VARIANT_BOOL *pfEqual);


void __RPC_STUB IHTMLComputedStyle_IsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLComputedStyle_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_HtmlDlgSafeHelper;

#ifdef __cplusplus

class DECLSPEC_UUID("3050f819-98b5-11cf-bb82-00aa00bdce0b")
HtmlDlgSafeHelper;
#endif

EXTERN_C const CLSID CLSID_BlockFormats;

#ifdef __cplusplus

class DECLSPEC_UUID("3050f831-98b5-11cf-bb82-00aa00bdce0b")
BlockFormats;
#endif

EXTERN_C const CLSID CLSID_FontNames;

#ifdef __cplusplus

class DECLSPEC_UUID("3050f83a-98b5-11cf-bb82-00aa00bdce0b")
FontNames;
#endif

#ifndef __HTMLNamespaceEvents_DISPINTERFACE_DEFINED__
#define __HTMLNamespaceEvents_DISPINTERFACE_DEFINED__

/* dispinterface HTMLNamespaceEvents */
/* [uuid][hidden] */ 


EXTERN_C const IID DIID_HTMLNamespaceEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("3050f6bd-98b5-11cf-bb82-00aa00bdce0b")
    HTMLNamespaceEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct HTMLNamespaceEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            HTMLNamespaceEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            HTMLNamespaceEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            HTMLNamespaceEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            HTMLNamespaceEvents * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            HTMLNamespaceEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            HTMLNamespaceEvents * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            HTMLNamespaceEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } HTMLNamespaceEventsVtbl;

    interface HTMLNamespaceEvents
    {
        CONST_VTBL struct HTMLNamespaceEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define HTMLNamespaceEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define HTMLNamespaceEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define HTMLNamespaceEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define HTMLNamespaceEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define HTMLNamespaceEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define HTMLNamespaceEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define HTMLNamespaceEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __HTMLNamespaceEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IHTMLNamespace_INTERFACE_DEFINED__
#define __IHTMLNamespace_INTERFACE_DEFINED__

/* interface IHTMLNamespace */
/* [object][uuid][dual][oleautomation] */ 


EXTERN_C const IID IID_IHTMLNamespace;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f6bb-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLNamespace : public IDispatch
    {
    public:
        virtual /* [bindable][id][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [bindable][id][propget] */ HRESULT STDMETHODCALLTYPE get_urn( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [bindable][id][propget] */ HRESULT STDMETHODCALLTYPE get_tagNames( 
            /* [out][retval] */ IDispatch **p) = 0;
        
        virtual /* [bindable][id][propget] */ HRESULT STDMETHODCALLTYPE get_readyState( 
            /* [out][retval] */ VARIANT *p) = 0;
        
        virtual /* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE put_onreadystatechange( 
            /* [in] */ VARIANT v) = 0;
        
        virtual /* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE get_onreadystatechange( 
            /* [out][retval] */ VARIANT *p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE doImport( 
            /* [in] */ BSTR bstrImplementationUrl) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE attachEvent( 
            /* [in] */ BSTR event,
            /* [in] */ IDispatch *pDisp,
            /* [out][retval] */ VARIANT_BOOL *pfResult) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE detachEvent( 
            /* [in] */ BSTR event,
            /* [in] */ IDispatch *pDisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLNamespaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLNamespace * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLNamespace * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLNamespace * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IHTMLNamespace * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IHTMLNamespace * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IHTMLNamespace * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IHTMLNamespace * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [bindable][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            IHTMLNamespace * This,
            /* [out][retval] */ BSTR *p);
        
        /* [bindable][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_urn )( 
            IHTMLNamespace * This,
            /* [out][retval] */ BSTR *p);
        
        /* [bindable][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_tagNames )( 
            IHTMLNamespace * This,
            /* [out][retval] */ IDispatch **p);
        
        /* [bindable][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_readyState )( 
            IHTMLNamespace * This,
            /* [out][retval] */ VARIANT *p);
        
        /* [bindable][displaybind][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_onreadystatechange )( 
            IHTMLNamespace * This,
            /* [in] */ VARIANT v);
        
        /* [bindable][displaybind][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_onreadystatechange )( 
            IHTMLNamespace * This,
            /* [out][retval] */ VARIANT *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *doImport )( 
            IHTMLNamespace * This,
            /* [in] */ BSTR bstrImplementationUrl);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *attachEvent )( 
            IHTMLNamespace * This,
            /* [in] */ BSTR event,
            /* [in] */ IDispatch *pDisp,
            /* [out][retval] */ VARIANT_BOOL *pfResult);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *detachEvent )( 
            IHTMLNamespace * This,
            /* [in] */ BSTR event,
            /* [in] */ IDispatch *pDisp);
        
        END_INTERFACE
    } IHTMLNamespaceVtbl;

    interface IHTMLNamespace
    {
        CONST_VTBL struct IHTMLNamespaceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLNamespace_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLNamespace_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLNamespace_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLNamespace_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHTMLNamespace_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHTMLNamespace_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHTMLNamespace_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHTMLNamespace_get_name(This,p)	\
    (This)->lpVtbl -> get_name(This,p)

#define IHTMLNamespace_get_urn(This,p)	\
    (This)->lpVtbl -> get_urn(This,p)

#define IHTMLNamespace_get_tagNames(This,p)	\
    (This)->lpVtbl -> get_tagNames(This,p)

#define IHTMLNamespace_get_readyState(This,p)	\
    (This)->lpVtbl -> get_readyState(This,p)

#define IHTMLNamespace_put_onreadystatechange(This,v)	\
    (This)->lpVtbl -> put_onreadystatechange(This,v)

#define IHTMLNamespace_get_onreadystatechange(This,p)	\
    (This)->lpVtbl -> get_onreadystatechange(This,p)

#define IHTMLNamespace_doImport(This,bstrImplementationUrl)	\
    (This)->lpVtbl -> doImport(This,bstrImplementationUrl)

#define IHTMLNamespace_attachEvent(This,event,pDisp,pfResult)	\
    (This)->lpVtbl -> attachEvent(This,event,pDisp,pfResult)

#define IHTMLNamespace_detachEvent(This,event,pDisp)	\
    (This)->lpVtbl -> detachEvent(This,event,pDisp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLNamespace_get_name_Proxy( 
    IHTMLNamespace * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IHTMLNamespace_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLNamespace_get_urn_Proxy( 
    IHTMLNamespace * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IHTMLNamespace_get_urn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLNamespace_get_tagNames_Proxy( 
    IHTMLNamespace * This,
    /* [out][retval] */ IDispatch **p);


void __RPC_STUB IHTMLNamespace_get_tagNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLNamespace_get_readyState_Proxy( 
    IHTMLNamespace * This,
    /* [out][retval] */ VARIANT *p);


void __RPC_STUB IHTMLNamespace_get_readyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propput] */ HRESULT STDMETHODCALLTYPE IHTMLNamespace_put_onreadystatechange_Proxy( 
    IHTMLNamespace * This,
    /* [in] */ VARIANT v);


void __RPC_STUB IHTMLNamespace_put_onreadystatechange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLNamespace_get_onreadystatechange_Proxy( 
    IHTMLNamespace * This,
    /* [out][retval] */ VARIANT *p);


void __RPC_STUB IHTMLNamespace_get_onreadystatechange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IHTMLNamespace_doImport_Proxy( 
    IHTMLNamespace * This,
    /* [in] */ BSTR bstrImplementationUrl);


void __RPC_STUB IHTMLNamespace_doImport_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IHTMLNamespace_attachEvent_Proxy( 
    IHTMLNamespace * This,
    /* [in] */ BSTR event,
    /* [in] */ IDispatch *pDisp,
    /* [out][retval] */ VARIANT_BOOL *pfResult);


void __RPC_STUB IHTMLNamespace_attachEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IHTMLNamespace_detachEvent_Proxy( 
    IHTMLNamespace * This,
    /* [in] */ BSTR event,
    /* [in] */ IDispatch *pDisp);


void __RPC_STUB IHTMLNamespace_detachEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLNamespace_INTERFACE_DEFINED__ */


#ifndef __IHTMLNamespaceCollection_INTERFACE_DEFINED__
#define __IHTMLNamespaceCollection_INTERFACE_DEFINED__

/* interface IHTMLNamespaceCollection */
/* [object][uuid][dual][oleautomation] */ 


EXTERN_C const IID IID_IHTMLNamespaceCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f6b8-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLNamespaceCollection : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [out][retval] */ long *p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE item( 
            /* [in] */ VARIANT index,
            /* [out][retval] */ IDispatch **ppNamespace) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE add( 
            /* [in] */ BSTR bstrNamespace,
            /* [in] */ BSTR bstrUrn,
            /* [in][optional] */ VARIANT implementationUrl,
            /* [out][retval] */ IDispatch **ppNamespace) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLNamespaceCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLNamespaceCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLNamespaceCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLNamespaceCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IHTMLNamespaceCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IHTMLNamespaceCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IHTMLNamespaceCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IHTMLNamespaceCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IHTMLNamespaceCollection * This,
            /* [out][retval] */ long *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *item )( 
            IHTMLNamespaceCollection * This,
            /* [in] */ VARIANT index,
            /* [out][retval] */ IDispatch **ppNamespace);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *add )( 
            IHTMLNamespaceCollection * This,
            /* [in] */ BSTR bstrNamespace,
            /* [in] */ BSTR bstrUrn,
            /* [in][optional] */ VARIANT implementationUrl,
            /* [out][retval] */ IDispatch **ppNamespace);
        
        END_INTERFACE
    } IHTMLNamespaceCollectionVtbl;

    interface IHTMLNamespaceCollection
    {
        CONST_VTBL struct IHTMLNamespaceCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLNamespaceCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLNamespaceCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLNamespaceCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLNamespaceCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHTMLNamespaceCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHTMLNamespaceCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHTMLNamespaceCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHTMLNamespaceCollection_get_length(This,p)	\
    (This)->lpVtbl -> get_length(This,p)

#define IHTMLNamespaceCollection_item(This,index,ppNamespace)	\
    (This)->lpVtbl -> item(This,index,ppNamespace)

#define IHTMLNamespaceCollection_add(This,bstrNamespace,bstrUrn,implementationUrl,ppNamespace)	\
    (This)->lpVtbl -> add(This,bstrNamespace,bstrUrn,implementationUrl,ppNamespace)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLNamespaceCollection_get_length_Proxy( 
    IHTMLNamespaceCollection * This,
    /* [out][retval] */ long *p);


void __RPC_STUB IHTMLNamespaceCollection_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IHTMLNamespaceCollection_item_Proxy( 
    IHTMLNamespaceCollection * This,
    /* [in] */ VARIANT index,
    /* [out][retval] */ IDispatch **ppNamespace);


void __RPC_STUB IHTMLNamespaceCollection_item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IHTMLNamespaceCollection_add_Proxy( 
    IHTMLNamespaceCollection * This,
    /* [in] */ BSTR bstrNamespace,
    /* [in] */ BSTR bstrUrn,
    /* [in][optional] */ VARIANT implementationUrl,
    /* [out][retval] */ IDispatch **ppNamespace);


void __RPC_STUB IHTMLNamespaceCollection_add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLNamespaceCollection_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_HTMLNamespace;

#ifdef __cplusplus

class DECLSPEC_UUID("3050f6bc-98b5-11cf-bb82-00aa00bdce0b")
HTMLNamespace;
#endif

EXTERN_C const CLSID CLSID_HTMLNamespaceCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("3050f6b9-98b5-11cf-bb82-00aa00bdce0b")
HTMLNamespaceCollection;
#endif

#ifndef __IHTMLPainter_INTERFACE_DEFINED__
#define __IHTMLPainter_INTERFACE_DEFINED__

/* interface IHTMLPainter */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLPainter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f6a6-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLPainter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Draw( 
            /* [in] */ RECT rcBounds,
            /* [in] */ RECT rcUpdate,
            /* [in] */ LONG lDrawFlags,
            /* [in] */ HDC hdc,
            /* [in] */ LPVOID pvDrawObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnResize( 
            /* [in] */ SIZE size) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPainterInfo( 
            /* [out] */ HTML_PAINTER_INFO *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HitTestPoint( 
            /* [in] */ POINT pt,
            /* [out] */ BOOL *pbHit,
            /* [out] */ LONG *plPartID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLPainterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLPainter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLPainter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLPainter * This);
        
        HRESULT ( STDMETHODCALLTYPE *Draw )( 
            IHTMLPainter * This,
            /* [in] */ RECT rcBounds,
            /* [in] */ RECT rcUpdate,
            /* [in] */ LONG lDrawFlags,
            /* [in] */ HDC hdc,
            /* [in] */ LPVOID pvDrawObject);
        
        HRESULT ( STDMETHODCALLTYPE *OnResize )( 
            IHTMLPainter * This,
            /* [in] */ SIZE size);
        
        HRESULT ( STDMETHODCALLTYPE *GetPainterInfo )( 
            IHTMLPainter * This,
            /* [out] */ HTML_PAINTER_INFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *HitTestPoint )( 
            IHTMLPainter * This,
            /* [in] */ POINT pt,
            /* [out] */ BOOL *pbHit,
            /* [out] */ LONG *plPartID);
        
        END_INTERFACE
    } IHTMLPainterVtbl;

    interface IHTMLPainter
    {
        CONST_VTBL struct IHTMLPainterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLPainter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLPainter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLPainter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLPainter_Draw(This,rcBounds,rcUpdate,lDrawFlags,hdc,pvDrawObject)	\
    (This)->lpVtbl -> Draw(This,rcBounds,rcUpdate,lDrawFlags,hdc,pvDrawObject)

#define IHTMLPainter_OnResize(This,size)	\
    (This)->lpVtbl -> OnResize(This,size)

#define IHTMLPainter_GetPainterInfo(This,pInfo)	\
    (This)->lpVtbl -> GetPainterInfo(This,pInfo)

#define IHTMLPainter_HitTestPoint(This,pt,pbHit,plPartID)	\
    (This)->lpVtbl -> HitTestPoint(This,pt,pbHit,plPartID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLPainter_Draw_Proxy( 
    IHTMLPainter * This,
    /* [in] */ RECT rcBounds,
    /* [in] */ RECT rcUpdate,
    /* [in] */ LONG lDrawFlags,
    /* [in] */ HDC hdc,
    /* [in] */ LPVOID pvDrawObject);


void __RPC_STUB IHTMLPainter_Draw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLPainter_OnResize_Proxy( 
    IHTMLPainter * This,
    /* [in] */ SIZE size);


void __RPC_STUB IHTMLPainter_OnResize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLPainter_GetPainterInfo_Proxy( 
    IHTMLPainter * This,
    /* [out] */ HTML_PAINTER_INFO *pInfo);


void __RPC_STUB IHTMLPainter_GetPainterInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLPainter_HitTestPoint_Proxy( 
    IHTMLPainter * This,
    /* [in] */ POINT pt,
    /* [out] */ BOOL *pbHit,
    /* [out] */ LONG *plPartID);


void __RPC_STUB IHTMLPainter_HitTestPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLPainter_INTERFACE_DEFINED__ */


#ifndef __IHTMLPaintSite_INTERFACE_DEFINED__
#define __IHTMLPaintSite_INTERFACE_DEFINED__

/* interface IHTMLPaintSite */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLPaintSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f6a7-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLPaintSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InvalidatePainterInfo( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvalidateRect( 
            /* [in] */ RECT *prcInvalid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvalidateRegion( 
            /* [in] */ HRGN rgnInvalid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDrawInfo( 
            /* [in] */ LONG lFlags,
            /* [out] */ HTML_PAINT_DRAW_INFO *pDrawInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TransformGlobalToLocal( 
            /* [in] */ POINT ptGlobal,
            /* [out] */ POINT *pptLocal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TransformLocalToGlobal( 
            /* [in] */ POINT ptLocal,
            /* [out] */ POINT *pptGlobal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHitTestCookie( 
            /* [out] */ LONG *plCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLPaintSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLPaintSite * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLPaintSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLPaintSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *InvalidatePainterInfo )( 
            IHTMLPaintSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *InvalidateRect )( 
            IHTMLPaintSite * This,
            /* [in] */ RECT *prcInvalid);
        
        HRESULT ( STDMETHODCALLTYPE *InvalidateRegion )( 
            IHTMLPaintSite * This,
            /* [in] */ HRGN rgnInvalid);
        
        HRESULT ( STDMETHODCALLTYPE *GetDrawInfo )( 
            IHTMLPaintSite * This,
            /* [in] */ LONG lFlags,
            /* [out] */ HTML_PAINT_DRAW_INFO *pDrawInfo);
        
        HRESULT ( STDMETHODCALLTYPE *TransformGlobalToLocal )( 
            IHTMLPaintSite * This,
            /* [in] */ POINT ptGlobal,
            /* [out] */ POINT *pptLocal);
        
        HRESULT ( STDMETHODCALLTYPE *TransformLocalToGlobal )( 
            IHTMLPaintSite * This,
            /* [in] */ POINT ptLocal,
            /* [out] */ POINT *pptGlobal);
        
        HRESULT ( STDMETHODCALLTYPE *GetHitTestCookie )( 
            IHTMLPaintSite * This,
            /* [out] */ LONG *plCookie);
        
        END_INTERFACE
    } IHTMLPaintSiteVtbl;

    interface IHTMLPaintSite
    {
        CONST_VTBL struct IHTMLPaintSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLPaintSite_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLPaintSite_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLPaintSite_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLPaintSite_InvalidatePainterInfo(This)	\
    (This)->lpVtbl -> InvalidatePainterInfo(This)

#define IHTMLPaintSite_InvalidateRect(This,prcInvalid)	\
    (This)->lpVtbl -> InvalidateRect(This,prcInvalid)

#define IHTMLPaintSite_InvalidateRegion(This,rgnInvalid)	\
    (This)->lpVtbl -> InvalidateRegion(This,rgnInvalid)

#define IHTMLPaintSite_GetDrawInfo(This,lFlags,pDrawInfo)	\
    (This)->lpVtbl -> GetDrawInfo(This,lFlags,pDrawInfo)

#define IHTMLPaintSite_TransformGlobalToLocal(This,ptGlobal,pptLocal)	\
    (This)->lpVtbl -> TransformGlobalToLocal(This,ptGlobal,pptLocal)

#define IHTMLPaintSite_TransformLocalToGlobal(This,ptLocal,pptGlobal)	\
    (This)->lpVtbl -> TransformLocalToGlobal(This,ptLocal,pptGlobal)

#define IHTMLPaintSite_GetHitTestCookie(This,plCookie)	\
    (This)->lpVtbl -> GetHitTestCookie(This,plCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLPaintSite_InvalidatePainterInfo_Proxy( 
    IHTMLPaintSite * This);


void __RPC_STUB IHTMLPaintSite_InvalidatePainterInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLPaintSite_InvalidateRect_Proxy( 
    IHTMLPaintSite * This,
    /* [in] */ RECT *prcInvalid);


void __RPC_STUB IHTMLPaintSite_InvalidateRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLPaintSite_InvalidateRegion_Proxy( 
    IHTMLPaintSite * This,
    /* [in] */ HRGN rgnInvalid);


void __RPC_STUB IHTMLPaintSite_InvalidateRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLPaintSite_GetDrawInfo_Proxy( 
    IHTMLPaintSite * This,
    /* [in] */ LONG lFlags,
    /* [out] */ HTML_PAINT_DRAW_INFO *pDrawInfo);


void __RPC_STUB IHTMLPaintSite_GetDrawInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLPaintSite_TransformGlobalToLocal_Proxy( 
    IHTMLPaintSite * This,
    /* [in] */ POINT ptGlobal,
    /* [out] */ POINT *pptLocal);


void __RPC_STUB IHTMLPaintSite_TransformGlobalToLocal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLPaintSite_TransformLocalToGlobal_Proxy( 
    IHTMLPaintSite * This,
    /* [in] */ POINT ptLocal,
    /* [out] */ POINT *pptGlobal);


void __RPC_STUB IHTMLPaintSite_TransformLocalToGlobal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLPaintSite_GetHitTestCookie_Proxy( 
    IHTMLPaintSite * This,
    /* [out] */ LONG *plCookie);


void __RPC_STUB IHTMLPaintSite_GetHitTestCookie_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLPaintSite_INTERFACE_DEFINED__ */


#ifndef __IHTMLPainterEventInfo_INTERFACE_DEFINED__
#define __IHTMLPainterEventInfo_INTERFACE_DEFINED__

/* interface IHTMLPainterEventInfo */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLPainterEventInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f6df-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLPainterEventInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetEventInfoFlags( 
            /* [out] */ long *plEventInfoFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEventTarget( 
            /* [in] */ IHTMLElement **ppElement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCursor( 
            /* [in] */ LONG lPartID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StringFromPartID( 
            /* [in] */ LONG lPartID,
            /* [out] */ BSTR *pbstrPart) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLPainterEventInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLPainterEventInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLPainterEventInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLPainterEventInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEventInfoFlags )( 
            IHTMLPainterEventInfo * This,
            /* [out] */ long *plEventInfoFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetEventTarget )( 
            IHTMLPainterEventInfo * This,
            /* [in] */ IHTMLElement **ppElement);
        
        HRESULT ( STDMETHODCALLTYPE *SetCursor )( 
            IHTMLPainterEventInfo * This,
            /* [in] */ LONG lPartID);
        
        HRESULT ( STDMETHODCALLTYPE *StringFromPartID )( 
            IHTMLPainterEventInfo * This,
            /* [in] */ LONG lPartID,
            /* [out] */ BSTR *pbstrPart);
        
        END_INTERFACE
    } IHTMLPainterEventInfoVtbl;

    interface IHTMLPainterEventInfo
    {
        CONST_VTBL struct IHTMLPainterEventInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLPainterEventInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLPainterEventInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLPainterEventInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLPainterEventInfo_GetEventInfoFlags(This,plEventInfoFlags)	\
    (This)->lpVtbl -> GetEventInfoFlags(This,plEventInfoFlags)

#define IHTMLPainterEventInfo_GetEventTarget(This,ppElement)	\
    (This)->lpVtbl -> GetEventTarget(This,ppElement)

#define IHTMLPainterEventInfo_SetCursor(This,lPartID)	\
    (This)->lpVtbl -> SetCursor(This,lPartID)

#define IHTMLPainterEventInfo_StringFromPartID(This,lPartID,pbstrPart)	\
    (This)->lpVtbl -> StringFromPartID(This,lPartID,pbstrPart)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLPainterEventInfo_GetEventInfoFlags_Proxy( 
    IHTMLPainterEventInfo * This,
    /* [out] */ long *plEventInfoFlags);


void __RPC_STUB IHTMLPainterEventInfo_GetEventInfoFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLPainterEventInfo_GetEventTarget_Proxy( 
    IHTMLPainterEventInfo * This,
    /* [in] */ IHTMLElement **ppElement);


void __RPC_STUB IHTMLPainterEventInfo_GetEventTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLPainterEventInfo_SetCursor_Proxy( 
    IHTMLPainterEventInfo * This,
    /* [in] */ LONG lPartID);


void __RPC_STUB IHTMLPainterEventInfo_SetCursor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLPainterEventInfo_StringFromPartID_Proxy( 
    IHTMLPainterEventInfo * This,
    /* [in] */ LONG lPartID,
    /* [out] */ BSTR *pbstrPart);


void __RPC_STUB IHTMLPainterEventInfo_StringFromPartID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLPainterEventInfo_INTERFACE_DEFINED__ */


#ifndef __IHTMLPainterOverlay_INTERFACE_DEFINED__
#define __IHTMLPainterOverlay_INTERFACE_DEFINED__

/* interface IHTMLPainterOverlay */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLPainterOverlay;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f7e3-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLPainterOverlay : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnMove( 
            /* [in] */ RECT rcDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLPainterOverlayVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLPainterOverlay * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLPainterOverlay * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLPainterOverlay * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnMove )( 
            IHTMLPainterOverlay * This,
            /* [in] */ RECT rcDevice);
        
        END_INTERFACE
    } IHTMLPainterOverlayVtbl;

    interface IHTMLPainterOverlay
    {
        CONST_VTBL struct IHTMLPainterOverlayVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLPainterOverlay_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLPainterOverlay_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLPainterOverlay_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLPainterOverlay_OnMove(This,rcDevice)	\
    (This)->lpVtbl -> OnMove(This,rcDevice)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLPainterOverlay_OnMove_Proxy( 
    IHTMLPainterOverlay * This,
    /* [in] */ RECT rcDevice);


void __RPC_STUB IHTMLPainterOverlay_OnMove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLPainterOverlay_INTERFACE_DEFINED__ */


#ifndef __IHTMLIPrintCollection_INTERFACE_DEFINED__
#define __IHTMLIPrintCollection_INTERFACE_DEFINED__

/* interface IHTMLIPrintCollection */
/* [object][uuid][dual][oleautomation] */ 


EXTERN_C const IID IID_IHTMLIPrintCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f6b5-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLIPrintCollection : public IDispatch
    {
    public:
        virtual /* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [out][retval] */ long *p) = 0;
        
        virtual /* [restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get__newEnum( 
            /* [out][retval] */ IUnknown **p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE item( 
            /* [in] */ long index,
            /* [out][retval] */ IUnknown **ppIPrint) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLIPrintCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLIPrintCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLIPrintCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLIPrintCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IHTMLIPrintCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IHTMLIPrintCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IHTMLIPrintCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IHTMLIPrintCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IHTMLIPrintCollection * This,
            /* [out][retval] */ long *p);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__newEnum )( 
            IHTMLIPrintCollection * This,
            /* [out][retval] */ IUnknown **p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *item )( 
            IHTMLIPrintCollection * This,
            /* [in] */ long index,
            /* [out][retval] */ IUnknown **ppIPrint);
        
        END_INTERFACE
    } IHTMLIPrintCollectionVtbl;

    interface IHTMLIPrintCollection
    {
        CONST_VTBL struct IHTMLIPrintCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLIPrintCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLIPrintCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLIPrintCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLIPrintCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHTMLIPrintCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHTMLIPrintCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHTMLIPrintCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHTMLIPrintCollection_get_length(This,p)	\
    (This)->lpVtbl -> get_length(This,p)

#define IHTMLIPrintCollection_get__newEnum(This,p)	\
    (This)->lpVtbl -> get__newEnum(This,p)

#define IHTMLIPrintCollection_item(This,index,ppIPrint)	\
    (This)->lpVtbl -> item(This,index,ppIPrint)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLIPrintCollection_get_length_Proxy( 
    IHTMLIPrintCollection * This,
    /* [out][retval] */ long *p);


void __RPC_STUB IHTMLIPrintCollection_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLIPrintCollection_get__newEnum_Proxy( 
    IHTMLIPrintCollection * This,
    /* [out][retval] */ IUnknown **p);


void __RPC_STUB IHTMLIPrintCollection_get__newEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IHTMLIPrintCollection_item_Proxy( 
    IHTMLIPrintCollection * This,
    /* [in] */ long index,
    /* [out][retval] */ IUnknown **ppIPrint);


void __RPC_STUB IHTMLIPrintCollection_item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLIPrintCollection_INTERFACE_DEFINED__ */


#ifndef __IEnumPrivacyRecords_INTERFACE_DEFINED__
#define __IEnumPrivacyRecords_INTERFACE_DEFINED__

/* interface IEnumPrivacyRecords */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IEnumPrivacyRecords;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f844-98b5-11cf-bb82-00aa00bdce0b")
    IEnumPrivacyRecords : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ ULONG *pSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrivacyImpacted( 
            /* [out] */ BOOL *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [out] */ BSTR *pbstrUrl,
            /* [out] */ BSTR *pbstrPolicyRef,
            /* [out] */ LONG *pdwReserved,
            /* [out] */ DWORD *pdwPrivacyFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumPrivacyRecordsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumPrivacyRecords * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumPrivacyRecords * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumPrivacyRecords * This);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumPrivacyRecords * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            IEnumPrivacyRecords * This,
            /* [out] */ ULONG *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivacyImpacted )( 
            IEnumPrivacyRecords * This,
            /* [out] */ BOOL *pState);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumPrivacyRecords * This,
            /* [out] */ BSTR *pbstrUrl,
            /* [out] */ BSTR *pbstrPolicyRef,
            /* [out] */ LONG *pdwReserved,
            /* [out] */ DWORD *pdwPrivacyFlags);
        
        END_INTERFACE
    } IEnumPrivacyRecordsVtbl;

    interface IEnumPrivacyRecords
    {
        CONST_VTBL struct IEnumPrivacyRecordsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumPrivacyRecords_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumPrivacyRecords_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumPrivacyRecords_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumPrivacyRecords_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumPrivacyRecords_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define IEnumPrivacyRecords_GetPrivacyImpacted(This,pState)	\
    (This)->lpVtbl -> GetPrivacyImpacted(This,pState)

#define IEnumPrivacyRecords_Next(This,pbstrUrl,pbstrPolicyRef,pdwReserved,pdwPrivacyFlags)	\
    (This)->lpVtbl -> Next(This,pbstrUrl,pbstrPolicyRef,pdwReserved,pdwPrivacyFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumPrivacyRecords_Reset_Proxy( 
    IEnumPrivacyRecords * This);


void __RPC_STUB IEnumPrivacyRecords_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPrivacyRecords_GetSize_Proxy( 
    IEnumPrivacyRecords * This,
    /* [out] */ ULONG *pSize);


void __RPC_STUB IEnumPrivacyRecords_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPrivacyRecords_GetPrivacyImpacted_Proxy( 
    IEnumPrivacyRecords * This,
    /* [out] */ BOOL *pState);


void __RPC_STUB IEnumPrivacyRecords_GetPrivacyImpacted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPrivacyRecords_Next_Proxy( 
    IEnumPrivacyRecords * This,
    /* [out] */ BSTR *pbstrUrl,
    /* [out] */ BSTR *pbstrPolicyRef,
    /* [out] */ LONG *pdwReserved,
    /* [out] */ DWORD *pdwPrivacyFlags);


void __RPC_STUB IEnumPrivacyRecords_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumPrivacyRecords_INTERFACE_DEFINED__ */


#ifndef __IHTMLDialog_INTERFACE_DEFINED__
#define __IHTMLDialog_INTERFACE_DEFINED__

/* interface IHTMLDialog */
/* [object][uuid][dual][oleautomation] */ 


EXTERN_C const IID IID_IHTMLDialog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f216-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLDialog : public IDispatch
    {
    public:
        virtual /* [bindable][id][propput] */ HRESULT STDMETHODCALLTYPE put_dialogTop( 
            /* [in] */ VARIANT v) = 0;
        
        virtual /* [bindable][id][propget] */ HRESULT STDMETHODCALLTYPE get_dialogTop( 
            /* [out][retval] */ VARIANT *p) = 0;
        
        virtual /* [bindable][id][propput] */ HRESULT STDMETHODCALLTYPE put_dialogLeft( 
            /* [in] */ VARIANT v) = 0;
        
        virtual /* [bindable][id][propget] */ HRESULT STDMETHODCALLTYPE get_dialogLeft( 
            /* [out][retval] */ VARIANT *p) = 0;
        
        virtual /* [bindable][id][propput] */ HRESULT STDMETHODCALLTYPE put_dialogWidth( 
            /* [in] */ VARIANT v) = 0;
        
        virtual /* [bindable][id][propget] */ HRESULT STDMETHODCALLTYPE get_dialogWidth( 
            /* [out][retval] */ VARIANT *p) = 0;
        
        virtual /* [bindable][id][propput] */ HRESULT STDMETHODCALLTYPE put_dialogHeight( 
            /* [in] */ VARIANT v) = 0;
        
        virtual /* [bindable][id][propget] */ HRESULT STDMETHODCALLTYPE get_dialogHeight( 
            /* [out][retval] */ VARIANT *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_dialogArguments( 
            /* [out][retval] */ VARIANT *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_menuArguments( 
            /* [out][retval] */ VARIANT *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_returnValue( 
            /* [in] */ VARIANT v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_returnValue( 
            /* [out][retval] */ VARIANT *p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE close( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE toString( 
            /* [out][retval] */ BSTR *String) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLDialogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLDialog * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLDialog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLDialog * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IHTMLDialog * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IHTMLDialog * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IHTMLDialog * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IHTMLDialog * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [bindable][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dialogTop )( 
            IHTMLDialog * This,
            /* [in] */ VARIANT v);
        
        /* [bindable][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dialogTop )( 
            IHTMLDialog * This,
            /* [out][retval] */ VARIANT *p);
        
        /* [bindable][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dialogLeft )( 
            IHTMLDialog * This,
            /* [in] */ VARIANT v);
        
        /* [bindable][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dialogLeft )( 
            IHTMLDialog * This,
            /* [out][retval] */ VARIANT *p);
        
        /* [bindable][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dialogWidth )( 
            IHTMLDialog * This,
            /* [in] */ VARIANT v);
        
        /* [bindable][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dialogWidth )( 
            IHTMLDialog * This,
            /* [out][retval] */ VARIANT *p);
        
        /* [bindable][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dialogHeight )( 
            IHTMLDialog * This,
            /* [in] */ VARIANT v);
        
        /* [bindable][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dialogHeight )( 
            IHTMLDialog * This,
            /* [out][retval] */ VARIANT *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dialogArguments )( 
            IHTMLDialog * This,
            /* [out][retval] */ VARIANT *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_menuArguments )( 
            IHTMLDialog * This,
            /* [out][retval] */ VARIANT *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_returnValue )( 
            IHTMLDialog * This,
            /* [in] */ VARIANT v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_returnValue )( 
            IHTMLDialog * This,
            /* [out][retval] */ VARIANT *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *close )( 
            IHTMLDialog * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *toString )( 
            IHTMLDialog * This,
            /* [out][retval] */ BSTR *String);
        
        END_INTERFACE
    } IHTMLDialogVtbl;

    interface IHTMLDialog
    {
        CONST_VTBL struct IHTMLDialogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLDialog_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLDialog_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLDialog_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLDialog_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHTMLDialog_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHTMLDialog_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHTMLDialog_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHTMLDialog_put_dialogTop(This,v)	\
    (This)->lpVtbl -> put_dialogTop(This,v)

#define IHTMLDialog_get_dialogTop(This,p)	\
    (This)->lpVtbl -> get_dialogTop(This,p)

#define IHTMLDialog_put_dialogLeft(This,v)	\
    (This)->lpVtbl -> put_dialogLeft(This,v)

#define IHTMLDialog_get_dialogLeft(This,p)	\
    (This)->lpVtbl -> get_dialogLeft(This,p)

#define IHTMLDialog_put_dialogWidth(This,v)	\
    (This)->lpVtbl -> put_dialogWidth(This,v)

#define IHTMLDialog_get_dialogWidth(This,p)	\
    (This)->lpVtbl -> get_dialogWidth(This,p)

#define IHTMLDialog_put_dialogHeight(This,v)	\
    (This)->lpVtbl -> put_dialogHeight(This,v)

#define IHTMLDialog_get_dialogHeight(This,p)	\
    (This)->lpVtbl -> get_dialogHeight(This,p)

#define IHTMLDialog_get_dialogArguments(This,p)	\
    (This)->lpVtbl -> get_dialogArguments(This,p)

#define IHTMLDialog_get_menuArguments(This,p)	\
    (This)->lpVtbl -> get_menuArguments(This,p)

#define IHTMLDialog_put_returnValue(This,v)	\
    (This)->lpVtbl -> put_returnValue(This,v)

#define IHTMLDialog_get_returnValue(This,p)	\
    (This)->lpVtbl -> get_returnValue(This,p)

#define IHTMLDialog_close(This)	\
    (This)->lpVtbl -> close(This)

#define IHTMLDialog_toString(This,String)	\
    (This)->lpVtbl -> toString(This,String)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][id][propput] */ HRESULT STDMETHODCALLTYPE IHTMLDialog_put_dialogTop_Proxy( 
    IHTMLDialog * This,
    /* [in] */ VARIANT v);


void __RPC_STUB IHTMLDialog_put_dialogTop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLDialog_get_dialogTop_Proxy( 
    IHTMLDialog * This,
    /* [out][retval] */ VARIANT *p);


void __RPC_STUB IHTMLDialog_get_dialogTop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][id][propput] */ HRESULT STDMETHODCALLTYPE IHTMLDialog_put_dialogLeft_Proxy( 
    IHTMLDialog * This,
    /* [in] */ VARIANT v);


void __RPC_STUB IHTMLDialog_put_dialogLeft_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLDialog_get_dialogLeft_Proxy( 
    IHTMLDialog * This,
    /* [out][retval] */ VARIANT *p);


void __RPC_STUB IHTMLDialog_get_dialogLeft_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][id][propput] */ HRESULT STDMETHODCALLTYPE IHTMLDialog_put_dialogWidth_Proxy( 
    IHTMLDialog * This,
    /* [in] */ VARIANT v);


void __RPC_STUB IHTMLDialog_put_dialogWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLDialog_get_dialogWidth_Proxy( 
    IHTMLDialog * This,
    /* [out][retval] */ VARIANT *p);


void __RPC_STUB IHTMLDialog_get_dialogWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][id][propput] */ HRESULT STDMETHODCALLTYPE IHTMLDialog_put_dialogHeight_Proxy( 
    IHTMLDialog * This,
    /* [in] */ VARIANT v);


void __RPC_STUB IHTMLDialog_put_dialogHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLDialog_get_dialogHeight_Proxy( 
    IHTMLDialog * This,
    /* [out][retval] */ VARIANT *p);


void __RPC_STUB IHTMLDialog_get_dialogHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLDialog_get_dialogArguments_Proxy( 
    IHTMLDialog * This,
    /* [out][retval] */ VARIANT *p);


void __RPC_STUB IHTMLDialog_get_dialogArguments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLDialog_get_menuArguments_Proxy( 
    IHTMLDialog * This,
    /* [out][retval] */ VARIANT *p);


void __RPC_STUB IHTMLDialog_get_menuArguments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHTMLDialog_put_returnValue_Proxy( 
    IHTMLDialog * This,
    /* [in] */ VARIANT v);


void __RPC_STUB IHTMLDialog_put_returnValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLDialog_get_returnValue_Proxy( 
    IHTMLDialog * This,
    /* [out][retval] */ VARIANT *p);


void __RPC_STUB IHTMLDialog_get_returnValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IHTMLDialog_close_Proxy( 
    IHTMLDialog * This);


void __RPC_STUB IHTMLDialog_close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IHTMLDialog_toString_Proxy( 
    IHTMLDialog * This,
    /* [out][retval] */ BSTR *String);


void __RPC_STUB IHTMLDialog_toString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLDialog_INTERFACE_DEFINED__ */


#ifndef __IHTMLDialog2_INTERFACE_DEFINED__
#define __IHTMLDialog2_INTERFACE_DEFINED__

/* interface IHTMLDialog2 */
/* [object][uuid][dual][oleautomation] */ 


EXTERN_C const IID IID_IHTMLDialog2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f5e0-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLDialog2 : public IDispatch
    {
    public:
        virtual /* [hidden][id][propput] */ HRESULT STDMETHODCALLTYPE put_status( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get_status( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [hidden][id][propput] */ HRESULT STDMETHODCALLTYPE put_resizable( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get_resizable( 
            /* [out][retval] */ BSTR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLDialog2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLDialog2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLDialog2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLDialog2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IHTMLDialog2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IHTMLDialog2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IHTMLDialog2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IHTMLDialog2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [hidden][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_status )( 
            IHTMLDialog2 * This,
            /* [in] */ BSTR v);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_status )( 
            IHTMLDialog2 * This,
            /* [out][retval] */ BSTR *p);
        
        /* [hidden][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_resizable )( 
            IHTMLDialog2 * This,
            /* [in] */ BSTR v);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_resizable )( 
            IHTMLDialog2 * This,
            /* [out][retval] */ BSTR *p);
        
        END_INTERFACE
    } IHTMLDialog2Vtbl;

    interface IHTMLDialog2
    {
        CONST_VTBL struct IHTMLDialog2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLDialog2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLDialog2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLDialog2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLDialog2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHTMLDialog2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHTMLDialog2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHTMLDialog2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHTMLDialog2_put_status(This,v)	\
    (This)->lpVtbl -> put_status(This,v)

#define IHTMLDialog2_get_status(This,p)	\
    (This)->lpVtbl -> get_status(This,p)

#define IHTMLDialog2_put_resizable(This,v)	\
    (This)->lpVtbl -> put_resizable(This,v)

#define IHTMLDialog2_get_resizable(This,p)	\
    (This)->lpVtbl -> get_resizable(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [hidden][id][propput] */ HRESULT STDMETHODCALLTYPE IHTMLDialog2_put_status_Proxy( 
    IHTMLDialog2 * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHTMLDialog2_put_status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLDialog2_get_status_Proxy( 
    IHTMLDialog2 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IHTMLDialog2_get_status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propput] */ HRESULT STDMETHODCALLTYPE IHTMLDialog2_put_resizable_Proxy( 
    IHTMLDialog2 * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHTMLDialog2_put_resizable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLDialog2_get_resizable_Proxy( 
    IHTMLDialog2 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IHTMLDialog2_get_resizable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLDialog2_INTERFACE_DEFINED__ */


#ifndef __IHTMLDialog3_INTERFACE_DEFINED__
#define __IHTMLDialog3_INTERFACE_DEFINED__

/* interface IHTMLDialog3 */
/* [object][uuid][dual][oleautomation] */ 


EXTERN_C const IID IID_IHTMLDialog3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f388-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLDialog3 : public IDispatch
    {
    public:
        virtual /* [hidden][id][propput] */ HRESULT STDMETHODCALLTYPE put_unadorned( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get_unadorned( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_dialogHide( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_dialogHide( 
            /* [out][retval] */ BSTR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLDialog3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLDialog3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLDialog3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLDialog3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IHTMLDialog3 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IHTMLDialog3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IHTMLDialog3 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IHTMLDialog3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [hidden][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_unadorned )( 
            IHTMLDialog3 * This,
            /* [in] */ BSTR v);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_unadorned )( 
            IHTMLDialog3 * This,
            /* [out][retval] */ BSTR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dialogHide )( 
            IHTMLDialog3 * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dialogHide )( 
            IHTMLDialog3 * This,
            /* [out][retval] */ BSTR *p);
        
        END_INTERFACE
    } IHTMLDialog3Vtbl;

    interface IHTMLDialog3
    {
        CONST_VTBL struct IHTMLDialog3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLDialog3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLDialog3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLDialog3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLDialog3_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHTMLDialog3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHTMLDialog3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHTMLDialog3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHTMLDialog3_put_unadorned(This,v)	\
    (This)->lpVtbl -> put_unadorned(This,v)

#define IHTMLDialog3_get_unadorned(This,p)	\
    (This)->lpVtbl -> get_unadorned(This,p)

#define IHTMLDialog3_put_dialogHide(This,v)	\
    (This)->lpVtbl -> put_dialogHide(This,v)

#define IHTMLDialog3_get_dialogHide(This,p)	\
    (This)->lpVtbl -> get_dialogHide(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [hidden][id][propput] */ HRESULT STDMETHODCALLTYPE IHTMLDialog3_put_unadorned_Proxy( 
    IHTMLDialog3 * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHTMLDialog3_put_unadorned_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLDialog3_get_unadorned_Proxy( 
    IHTMLDialog3 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IHTMLDialog3_get_unadorned_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHTMLDialog3_put_dialogHide_Proxy( 
    IHTMLDialog3 * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHTMLDialog3_put_dialogHide_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLDialog3_get_dialogHide_Proxy( 
    IHTMLDialog3 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IHTMLDialog3_get_dialogHide_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLDialog3_INTERFACE_DEFINED__ */


#ifndef __IHTMLModelessInit_INTERFACE_DEFINED__
#define __IHTMLModelessInit_INTERFACE_DEFINED__

/* interface IHTMLModelessInit */
/* [object][uuid][dual][oleautomation] */ 


EXTERN_C const IID IID_IHTMLModelessInit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f5e4-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLModelessInit : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_parameters( 
            /* [out][retval] */ VARIANT *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_optionString( 
            /* [out][retval] */ VARIANT *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_moniker( 
            /* [out][retval] */ IUnknown **p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_document( 
            /* [out][retval] */ IUnknown **p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLModelessInitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLModelessInit * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLModelessInit * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLModelessInit * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IHTMLModelessInit * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IHTMLModelessInit * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IHTMLModelessInit * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IHTMLModelessInit * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parameters )( 
            IHTMLModelessInit * This,
            /* [out][retval] */ VARIANT *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_optionString )( 
            IHTMLModelessInit * This,
            /* [out][retval] */ VARIANT *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_moniker )( 
            IHTMLModelessInit * This,
            /* [out][retval] */ IUnknown **p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_document )( 
            IHTMLModelessInit * This,
            /* [out][retval] */ IUnknown **p);
        
        END_INTERFACE
    } IHTMLModelessInitVtbl;

    interface IHTMLModelessInit
    {
        CONST_VTBL struct IHTMLModelessInitVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLModelessInit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLModelessInit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLModelessInit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLModelessInit_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHTMLModelessInit_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHTMLModelessInit_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHTMLModelessInit_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHTMLModelessInit_get_parameters(This,p)	\
    (This)->lpVtbl -> get_parameters(This,p)

#define IHTMLModelessInit_get_optionString(This,p)	\
    (This)->lpVtbl -> get_optionString(This,p)

#define IHTMLModelessInit_get_moniker(This,p)	\
    (This)->lpVtbl -> get_moniker(This,p)

#define IHTMLModelessInit_get_document(This,p)	\
    (This)->lpVtbl -> get_document(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLModelessInit_get_parameters_Proxy( 
    IHTMLModelessInit * This,
    /* [out][retval] */ VARIANT *p);


void __RPC_STUB IHTMLModelessInit_get_parameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLModelessInit_get_optionString_Proxy( 
    IHTMLModelessInit * This,
    /* [out][retval] */ VARIANT *p);


void __RPC_STUB IHTMLModelessInit_get_optionString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLModelessInit_get_moniker_Proxy( 
    IHTMLModelessInit * This,
    /* [out][retval] */ IUnknown **p);


void __RPC_STUB IHTMLModelessInit_get_moniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLModelessInit_get_document_Proxy( 
    IHTMLModelessInit * This,
    /* [out][retval] */ IUnknown **p);


void __RPC_STUB IHTMLModelessInit_get_document_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLModelessInit_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ThreadDialogProcParam;

#ifdef __cplusplus

class DECLSPEC_UUID("3050f5eb-98b5-11cf-bb82-00aa00bdce0b")
ThreadDialogProcParam;
#endif

EXTERN_C const CLSID CLSID_HTMLDialog;

#ifdef __cplusplus

class DECLSPEC_UUID("3050f28a-98b5-11cf-bb82-00aa00bdce0b")
HTMLDialog;
#endif

#ifndef __IHTMLPopup_INTERFACE_DEFINED__
#define __IHTMLPopup_INTERFACE_DEFINED__

/* interface IHTMLPopup */
/* [object][uuid][dual][oleautomation] */ 


EXTERN_C const IID IID_IHTMLPopup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f666-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLPopup : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE show( 
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ long w,
            /* [in] */ long h,
            /* [in] */ VARIANT *pElement) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE hide( void) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_document( 
            /* [out][retval] */ IHTMLDocument **p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_isOpen( 
            /* [out][retval] */ VARIANT_BOOL *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLPopupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLPopup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLPopup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLPopup * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IHTMLPopup * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IHTMLPopup * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IHTMLPopup * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IHTMLPopup * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *show )( 
            IHTMLPopup * This,
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ long w,
            /* [in] */ long h,
            /* [in] */ VARIANT *pElement);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *hide )( 
            IHTMLPopup * This);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_document )( 
            IHTMLPopup * This,
            /* [out][retval] */ IHTMLDocument **p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_isOpen )( 
            IHTMLPopup * This,
            /* [out][retval] */ VARIANT_BOOL *p);
        
        END_INTERFACE
    } IHTMLPopupVtbl;

    interface IHTMLPopup
    {
        CONST_VTBL struct IHTMLPopupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLPopup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLPopup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLPopup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLPopup_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHTMLPopup_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHTMLPopup_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHTMLPopup_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHTMLPopup_show(This,x,y,w,h,pElement)	\
    (This)->lpVtbl -> show(This,x,y,w,h,pElement)

#define IHTMLPopup_hide(This)	\
    (This)->lpVtbl -> hide(This)

#define IHTMLPopup_get_document(This,p)	\
    (This)->lpVtbl -> get_document(This,p)

#define IHTMLPopup_get_isOpen(This,p)	\
    (This)->lpVtbl -> get_isOpen(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IHTMLPopup_show_Proxy( 
    IHTMLPopup * This,
    /* [in] */ long x,
    /* [in] */ long y,
    /* [in] */ long w,
    /* [in] */ long h,
    /* [in] */ VARIANT *pElement);


void __RPC_STUB IHTMLPopup_show_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IHTMLPopup_hide_Proxy( 
    IHTMLPopup * This);


void __RPC_STUB IHTMLPopup_hide_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLPopup_get_document_Proxy( 
    IHTMLPopup * This,
    /* [out][retval] */ IHTMLDocument **p);


void __RPC_STUB IHTMLPopup_get_document_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLPopup_get_isOpen_Proxy( 
    IHTMLPopup * This,
    /* [out][retval] */ VARIANT_BOOL *p);


void __RPC_STUB IHTMLPopup_get_isOpen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLPopup_INTERFACE_DEFINED__ */


#ifndef __DispHTMLPopup_DISPINTERFACE_DEFINED__
#define __DispHTMLPopup_DISPINTERFACE_DEFINED__

/* dispinterface DispHTMLPopup */
/* [uuid][hidden] */ 


EXTERN_C const IID DIID_DispHTMLPopup;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("3050f589-98b5-11cf-bb82-00aa00bdce0b")
    DispHTMLPopup : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DispHTMLPopupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            DispHTMLPopup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            DispHTMLPopup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            DispHTMLPopup * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            DispHTMLPopup * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            DispHTMLPopup * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            DispHTMLPopup * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DispHTMLPopup * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } DispHTMLPopupVtbl;

    interface DispHTMLPopup
    {
        CONST_VTBL struct DispHTMLPopupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DispHTMLPopup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DispHTMLPopup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DispHTMLPopup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DispHTMLPopup_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DispHTMLPopup_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DispHTMLPopup_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DispHTMLPopup_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DispHTMLPopup_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_HTMLPopup;

#ifdef __cplusplus

class DECLSPEC_UUID("3050f667-98b5-11cf-bb82-00aa00bdce0b")
HTMLPopup;
#endif

#ifndef __IHTMLAppBehavior_INTERFACE_DEFINED__
#define __IHTMLAppBehavior_INTERFACE_DEFINED__

/* interface IHTMLAppBehavior */
/* [object][uuid][dual][oleautomation] */ 


EXTERN_C const IID IID_IHTMLAppBehavior;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f5ca-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLAppBehavior : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_applicationName( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_applicationName( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_version( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_version( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_icon( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_icon( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_singleInstance( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_singleInstance( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_minimizeButton( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_minimizeButton( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_maximizeButton( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_maximizeButton( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_border( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_border( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_borderStyle( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_borderStyle( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_sysMenu( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_sysMenu( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_caption( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_caption( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_windowState( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_windowState( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_showInTaskBar( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_showInTaskBar( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_commandLine( 
            /* [out][retval] */ BSTR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLAppBehaviorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLAppBehavior * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLAppBehavior * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLAppBehavior * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IHTMLAppBehavior * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IHTMLAppBehavior * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IHTMLAppBehavior * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IHTMLAppBehavior * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_applicationName )( 
            IHTMLAppBehavior * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_applicationName )( 
            IHTMLAppBehavior * This,
            /* [out][retval] */ BSTR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_version )( 
            IHTMLAppBehavior * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_version )( 
            IHTMLAppBehavior * This,
            /* [out][retval] */ BSTR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_icon )( 
            IHTMLAppBehavior * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_icon )( 
            IHTMLAppBehavior * This,
            /* [out][retval] */ BSTR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_singleInstance )( 
            IHTMLAppBehavior * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_singleInstance )( 
            IHTMLAppBehavior * This,
            /* [out][retval] */ BSTR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_minimizeButton )( 
            IHTMLAppBehavior * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_minimizeButton )( 
            IHTMLAppBehavior * This,
            /* [out][retval] */ BSTR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_maximizeButton )( 
            IHTMLAppBehavior * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_maximizeButton )( 
            IHTMLAppBehavior * This,
            /* [out][retval] */ BSTR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_border )( 
            IHTMLAppBehavior * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_border )( 
            IHTMLAppBehavior * This,
            /* [out][retval] */ BSTR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_borderStyle )( 
            IHTMLAppBehavior * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_borderStyle )( 
            IHTMLAppBehavior * This,
            /* [out][retval] */ BSTR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_sysMenu )( 
            IHTMLAppBehavior * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_sysMenu )( 
            IHTMLAppBehavior * This,
            /* [out][retval] */ BSTR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_caption )( 
            IHTMLAppBehavior * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_caption )( 
            IHTMLAppBehavior * This,
            /* [out][retval] */ BSTR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_windowState )( 
            IHTMLAppBehavior * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_windowState )( 
            IHTMLAppBehavior * This,
            /* [out][retval] */ BSTR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_showInTaskBar )( 
            IHTMLAppBehavior * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_showInTaskBar )( 
            IHTMLAppBehavior * This,
            /* [out][retval] */ BSTR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_commandLine )( 
            IHTMLAppBehavior * This,
            /* [out][retval] */ BSTR *p);
        
        END_INTERFACE
    } IHTMLAppBehaviorVtbl;

    interface IHTMLAppBehavior
    {
        CONST_VTBL struct IHTMLAppBehaviorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLAppBehavior_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLAppBehavior_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLAppBehavior_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLAppBehavior_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHTMLAppBehavior_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHTMLAppBehavior_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHTMLAppBehavior_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHTMLAppBehavior_put_applicationName(This,v)	\
    (This)->lpVtbl -> put_applicationName(This,v)

#define IHTMLAppBehavior_get_applicationName(This,p)	\
    (This)->lpVtbl -> get_applicationName(This,p)

#define IHTMLAppBehavior_put_version(This,v)	\
    (This)->lpVtbl -> put_version(This,v)

#define IHTMLAppBehavior_get_version(This,p)	\
    (This)->lpVtbl -> get_version(This,p)

#define IHTMLAppBehavior_put_icon(This,v)	\
    (This)->lpVtbl -> put_icon(This,v)

#define IHTMLAppBehavior_get_icon(This,p)	\
    (This)->lpVtbl -> get_icon(This,p)

#define IHTMLAppBehavior_put_singleInstance(This,v)	\
    (This)->lpVtbl -> put_singleInstance(This,v)

#define IHTMLAppBehavior_get_singleInstance(This,p)	\
    (This)->lpVtbl -> get_singleInstance(This,p)

#define IHTMLAppBehavior_put_minimizeButton(This,v)	\
    (This)->lpVtbl -> put_minimizeButton(This,v)

#define IHTMLAppBehavior_get_minimizeButton(This,p)	\
    (This)->lpVtbl -> get_minimizeButton(This,p)

#define IHTMLAppBehavior_put_maximizeButton(This,v)	\
    (This)->lpVtbl -> put_maximizeButton(This,v)

#define IHTMLAppBehavior_get_maximizeButton(This,p)	\
    (This)->lpVtbl -> get_maximizeButton(This,p)

#define IHTMLAppBehavior_put_border(This,v)	\
    (This)->lpVtbl -> put_border(This,v)

#define IHTMLAppBehavior_get_border(This,p)	\
    (This)->lpVtbl -> get_border(This,p)

#define IHTMLAppBehavior_put_borderStyle(This,v)	\
    (This)->lpVtbl -> put_borderStyle(This,v)

#define IHTMLAppBehavior_get_borderStyle(This,p)	\
    (This)->lpVtbl -> get_borderStyle(This,p)

#define IHTMLAppBehavior_put_sysMenu(This,v)	\
    (This)->lpVtbl -> put_sysMenu(This,v)

#define IHTMLAppBehavior_get_sysMenu(This,p)	\
    (This)->lpVtbl -> get_sysMenu(This,p)

#define IHTMLAppBehavior_put_caption(This,v)	\
    (This)->lpVtbl -> put_caption(This,v)

#define IHTMLAppBehavior_get_caption(This,p)	\
    (This)->lpVtbl -> get_caption(This,p)

#define IHTMLAppBehavior_put_windowState(This,v)	\
    (This)->lpVtbl -> put_windowState(This,v)

#define IHTMLAppBehavior_get_windowState(This,p)	\
    (This)->lpVtbl -> get_windowState(This,p)

#define IHTMLAppBehavior_put_showInTaskBar(This,v)	\
    (This)->lpVtbl -> put_showInTaskBar(This,v)

#define IHTMLAppBehavior_get_showInTaskBar(This,p)	\
    (This)->lpVtbl -> get_showInTaskBar(This,p)

#define IHTMLAppBehavior_get_commandLine(This,p)	\
    (This)->lpVtbl -> get_commandLine(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior_put_applicationName_Proxy( 
    IHTMLAppBehavior * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHTMLAppBehavior_put_applicationName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior_get_applicationName_Proxy( 
    IHTMLAppBehavior * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IHTMLAppBehavior_get_applicationName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior_put_version_Proxy( 
    IHTMLAppBehavior * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHTMLAppBehavior_put_version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior_get_version_Proxy( 
    IHTMLAppBehavior * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IHTMLAppBehavior_get_version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior_put_icon_Proxy( 
    IHTMLAppBehavior * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHTMLAppBehavior_put_icon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior_get_icon_Proxy( 
    IHTMLAppBehavior * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IHTMLAppBehavior_get_icon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior_put_singleInstance_Proxy( 
    IHTMLAppBehavior * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHTMLAppBehavior_put_singleInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior_get_singleInstance_Proxy( 
    IHTMLAppBehavior * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IHTMLAppBehavior_get_singleInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior_put_minimizeButton_Proxy( 
    IHTMLAppBehavior * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHTMLAppBehavior_put_minimizeButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior_get_minimizeButton_Proxy( 
    IHTMLAppBehavior * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IHTMLAppBehavior_get_minimizeButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior_put_maximizeButton_Proxy( 
    IHTMLAppBehavior * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHTMLAppBehavior_put_maximizeButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior_get_maximizeButton_Proxy( 
    IHTMLAppBehavior * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IHTMLAppBehavior_get_maximizeButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior_put_border_Proxy( 
    IHTMLAppBehavior * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHTMLAppBehavior_put_border_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior_get_border_Proxy( 
    IHTMLAppBehavior * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IHTMLAppBehavior_get_border_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior_put_borderStyle_Proxy( 
    IHTMLAppBehavior * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHTMLAppBehavior_put_borderStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior_get_borderStyle_Proxy( 
    IHTMLAppBehavior * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IHTMLAppBehavior_get_borderStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior_put_sysMenu_Proxy( 
    IHTMLAppBehavior * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHTMLAppBehavior_put_sysMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior_get_sysMenu_Proxy( 
    IHTMLAppBehavior * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IHTMLAppBehavior_get_sysMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior_put_caption_Proxy( 
    IHTMLAppBehavior * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHTMLAppBehavior_put_caption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior_get_caption_Proxy( 
    IHTMLAppBehavior * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IHTMLAppBehavior_get_caption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior_put_windowState_Proxy( 
    IHTMLAppBehavior * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHTMLAppBehavior_put_windowState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior_get_windowState_Proxy( 
    IHTMLAppBehavior * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IHTMLAppBehavior_get_windowState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior_put_showInTaskBar_Proxy( 
    IHTMLAppBehavior * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHTMLAppBehavior_put_showInTaskBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior_get_showInTaskBar_Proxy( 
    IHTMLAppBehavior * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IHTMLAppBehavior_get_showInTaskBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior_get_commandLine_Proxy( 
    IHTMLAppBehavior * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IHTMLAppBehavior_get_commandLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLAppBehavior_INTERFACE_DEFINED__ */


#ifndef __IHTMLAppBehavior2_INTERFACE_DEFINED__
#define __IHTMLAppBehavior2_INTERFACE_DEFINED__

/* interface IHTMLAppBehavior2 */
/* [object][uuid][dual][oleautomation] */ 


EXTERN_C const IID IID_IHTMLAppBehavior2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f5c9-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLAppBehavior2 : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_contextMenu( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_contextMenu( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_innerBorder( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_innerBorder( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_scroll( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_scroll( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_scrollFlat( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_scrollFlat( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_selection( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_selection( 
            /* [out][retval] */ BSTR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLAppBehavior2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLAppBehavior2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLAppBehavior2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLAppBehavior2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IHTMLAppBehavior2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IHTMLAppBehavior2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IHTMLAppBehavior2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IHTMLAppBehavior2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_contextMenu )( 
            IHTMLAppBehavior2 * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_contextMenu )( 
            IHTMLAppBehavior2 * This,
            /* [out][retval] */ BSTR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_innerBorder )( 
            IHTMLAppBehavior2 * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_innerBorder )( 
            IHTMLAppBehavior2 * This,
            /* [out][retval] */ BSTR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_scroll )( 
            IHTMLAppBehavior2 * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_scroll )( 
            IHTMLAppBehavior2 * This,
            /* [out][retval] */ BSTR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_scrollFlat )( 
            IHTMLAppBehavior2 * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_scrollFlat )( 
            IHTMLAppBehavior2 * This,
            /* [out][retval] */ BSTR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_selection )( 
            IHTMLAppBehavior2 * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_selection )( 
            IHTMLAppBehavior2 * This,
            /* [out][retval] */ BSTR *p);
        
        END_INTERFACE
    } IHTMLAppBehavior2Vtbl;

    interface IHTMLAppBehavior2
    {
        CONST_VTBL struct IHTMLAppBehavior2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLAppBehavior2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLAppBehavior2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLAppBehavior2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLAppBehavior2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHTMLAppBehavior2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHTMLAppBehavior2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHTMLAppBehavior2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHTMLAppBehavior2_put_contextMenu(This,v)	\
    (This)->lpVtbl -> put_contextMenu(This,v)

#define IHTMLAppBehavior2_get_contextMenu(This,p)	\
    (This)->lpVtbl -> get_contextMenu(This,p)

#define IHTMLAppBehavior2_put_innerBorder(This,v)	\
    (This)->lpVtbl -> put_innerBorder(This,v)

#define IHTMLAppBehavior2_get_innerBorder(This,p)	\
    (This)->lpVtbl -> get_innerBorder(This,p)

#define IHTMLAppBehavior2_put_scroll(This,v)	\
    (This)->lpVtbl -> put_scroll(This,v)

#define IHTMLAppBehavior2_get_scroll(This,p)	\
    (This)->lpVtbl -> get_scroll(This,p)

#define IHTMLAppBehavior2_put_scrollFlat(This,v)	\
    (This)->lpVtbl -> put_scrollFlat(This,v)

#define IHTMLAppBehavior2_get_scrollFlat(This,p)	\
    (This)->lpVtbl -> get_scrollFlat(This,p)

#define IHTMLAppBehavior2_put_selection(This,v)	\
    (This)->lpVtbl -> put_selection(This,v)

#define IHTMLAppBehavior2_get_selection(This,p)	\
    (This)->lpVtbl -> get_selection(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior2_put_contextMenu_Proxy( 
    IHTMLAppBehavior2 * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHTMLAppBehavior2_put_contextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior2_get_contextMenu_Proxy( 
    IHTMLAppBehavior2 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IHTMLAppBehavior2_get_contextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior2_put_innerBorder_Proxy( 
    IHTMLAppBehavior2 * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHTMLAppBehavior2_put_innerBorder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior2_get_innerBorder_Proxy( 
    IHTMLAppBehavior2 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IHTMLAppBehavior2_get_innerBorder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior2_put_scroll_Proxy( 
    IHTMLAppBehavior2 * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHTMLAppBehavior2_put_scroll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior2_get_scroll_Proxy( 
    IHTMLAppBehavior2 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IHTMLAppBehavior2_get_scroll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior2_put_scrollFlat_Proxy( 
    IHTMLAppBehavior2 * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHTMLAppBehavior2_put_scrollFlat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior2_get_scrollFlat_Proxy( 
    IHTMLAppBehavior2 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IHTMLAppBehavior2_get_scrollFlat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior2_put_selection_Proxy( 
    IHTMLAppBehavior2 * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHTMLAppBehavior2_put_selection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior2_get_selection_Proxy( 
    IHTMLAppBehavior2 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IHTMLAppBehavior2_get_selection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLAppBehavior2_INTERFACE_DEFINED__ */


#ifndef __IHTMLAppBehavior3_INTERFACE_DEFINED__
#define __IHTMLAppBehavior3_INTERFACE_DEFINED__

/* interface IHTMLAppBehavior3 */
/* [object][uuid][dual][oleautomation] */ 


EXTERN_C const IID IID_IHTMLAppBehavior3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f5cd-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLAppBehavior3 : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_navigable( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_navigable( 
            /* [out][retval] */ BSTR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLAppBehavior3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLAppBehavior3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLAppBehavior3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLAppBehavior3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IHTMLAppBehavior3 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IHTMLAppBehavior3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IHTMLAppBehavior3 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IHTMLAppBehavior3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_navigable )( 
            IHTMLAppBehavior3 * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_navigable )( 
            IHTMLAppBehavior3 * This,
            /* [out][retval] */ BSTR *p);
        
        END_INTERFACE
    } IHTMLAppBehavior3Vtbl;

    interface IHTMLAppBehavior3
    {
        CONST_VTBL struct IHTMLAppBehavior3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLAppBehavior3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLAppBehavior3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLAppBehavior3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLAppBehavior3_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHTMLAppBehavior3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHTMLAppBehavior3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHTMLAppBehavior3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHTMLAppBehavior3_put_navigable(This,v)	\
    (This)->lpVtbl -> put_navigable(This,v)

#define IHTMLAppBehavior3_get_navigable(This,p)	\
    (This)->lpVtbl -> get_navigable(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior3_put_navigable_Proxy( 
    IHTMLAppBehavior3 * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHTMLAppBehavior3_put_navigable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLAppBehavior3_get_navigable_Proxy( 
    IHTMLAppBehavior3 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IHTMLAppBehavior3_get_navigable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLAppBehavior3_INTERFACE_DEFINED__ */


#ifndef __DispHTMLAppBehavior_DISPINTERFACE_DEFINED__
#define __DispHTMLAppBehavior_DISPINTERFACE_DEFINED__

/* dispinterface DispHTMLAppBehavior */
/* [uuid][hidden] */ 


EXTERN_C const IID DIID_DispHTMLAppBehavior;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("3050f57c-98b5-11cf-bb82-00aa00bdce0b")
    DispHTMLAppBehavior : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DispHTMLAppBehaviorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            DispHTMLAppBehavior * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            DispHTMLAppBehavior * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            DispHTMLAppBehavior * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            DispHTMLAppBehavior * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            DispHTMLAppBehavior * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            DispHTMLAppBehavior * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DispHTMLAppBehavior * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } DispHTMLAppBehaviorVtbl;

    interface DispHTMLAppBehavior
    {
        CONST_VTBL struct DispHTMLAppBehaviorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DispHTMLAppBehavior_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DispHTMLAppBehavior_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DispHTMLAppBehavior_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DispHTMLAppBehavior_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DispHTMLAppBehavior_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DispHTMLAppBehavior_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DispHTMLAppBehavior_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DispHTMLAppBehavior_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_HTMLAppBehavior;

#ifdef __cplusplus

class DECLSPEC_UUID("3050f5cb-98b5-11cf-bb82-00aa00bdce0b")
HTMLAppBehavior;
#endif

EXTERN_C const CLSID CLSID_OldHTMLDocument;

#ifdef __cplusplus

class DECLSPEC_UUID("D48A6EC9-6A4A-11CF-94A7-444553540000")
OldHTMLDocument;
#endif

EXTERN_C const CLSID CLSID_OldHTMLFormElement;

#ifdef __cplusplus

class DECLSPEC_UUID("0D04D285-6BEC-11CF-8B97-00AA00476DA6")
OldHTMLFormElement;
#endif

#ifndef __DispIHTMLInputButtonElement_DISPINTERFACE_DEFINED__
#define __DispIHTMLInputButtonElement_DISPINTERFACE_DEFINED__

/* dispinterface DispIHTMLInputButtonElement */
/* [uuid][hidden] */ 


EXTERN_C const IID DIID_DispIHTMLInputButtonElement;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("3050f51e-98b5-11cf-bb82-00aa00bdce0b")
    DispIHTMLInputButtonElement : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DispIHTMLInputButtonElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            DispIHTMLInputButtonElement * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            DispIHTMLInputButtonElement * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            DispIHTMLInputButtonElement * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            DispIHTMLInputButtonElement * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            DispIHTMLInputButtonElement * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            DispIHTMLInputButtonElement * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DispIHTMLInputButtonElement * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } DispIHTMLInputButtonElementVtbl;

    interface DispIHTMLInputButtonElement
    {
        CONST_VTBL struct DispIHTMLInputButtonElementVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DispIHTMLInputButtonElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DispIHTMLInputButtonElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DispIHTMLInputButtonElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DispIHTMLInputButtonElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DispIHTMLInputButtonElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DispIHTMLInputButtonElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DispIHTMLInputButtonElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DispIHTMLInputButtonElement_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_HTMLInputButtonElement;

#ifdef __cplusplus

class DECLSPEC_UUID("3050f2b4-98b5-11cf-bb82-00aa00bdce0b")
HTMLInputButtonElement;
#endif

#ifndef __DispIHTMLInputTextElement_DISPINTERFACE_DEFINED__
#define __DispIHTMLInputTextElement_DISPINTERFACE_DEFINED__

/* dispinterface DispIHTMLInputTextElement */
/* [uuid][hidden] */ 


EXTERN_C const IID DIID_DispIHTMLInputTextElement;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("3050f520-98b5-11cf-bb82-00aa00bdce0b")
    DispIHTMLInputTextElement : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DispIHTMLInputTextElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            DispIHTMLInputTextElement * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            DispIHTMLInputTextElement * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            DispIHTMLInputTextElement * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            DispIHTMLInputTextElement * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            DispIHTMLInputTextElement * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            DispIHTMLInputTextElement * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DispIHTMLInputTextElement * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } DispIHTMLInputTextElementVtbl;

    interface DispIHTMLInputTextElement
    {
        CONST_VTBL struct DispIHTMLInputTextElementVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DispIHTMLInputTextElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DispIHTMLInputTextElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DispIHTMLInputTextElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DispIHTMLInputTextElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DispIHTMLInputTextElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DispIHTMLInputTextElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DispIHTMLInputTextElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DispIHTMLInputTextElement_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_HTMLInputTextElement;

#ifdef __cplusplus

class DECLSPEC_UUID("3050f2ab-98b5-11cf-bb82-00aa00bdce0b")
HTMLInputTextElement;
#endif

#ifndef __DispIHTMLInputFileElement_DISPINTERFACE_DEFINED__
#define __DispIHTMLInputFileElement_DISPINTERFACE_DEFINED__

/* dispinterface DispIHTMLInputFileElement */
/* [uuid][hidden] */ 


EXTERN_C const IID DIID_DispIHTMLInputFileElement;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("3050f542-98b5-11cf-bb82-00aa00bdce0b")
    DispIHTMLInputFileElement : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DispIHTMLInputFileElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            DispIHTMLInputFileElement * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            DispIHTMLInputFileElement * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            DispIHTMLInputFileElement * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            DispIHTMLInputFileElement * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            DispIHTMLInputFileElement * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            DispIHTMLInputFileElement * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DispIHTMLInputFileElement * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } DispIHTMLInputFileElementVtbl;

    interface DispIHTMLInputFileElement
    {
        CONST_VTBL struct DispIHTMLInputFileElementVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DispIHTMLInputFileElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DispIHTMLInputFileElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DispIHTMLInputFileElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DispIHTMLInputFileElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DispIHTMLInputFileElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DispIHTMLInputFileElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DispIHTMLInputFileElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DispIHTMLInputFileElement_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_HTMLInputFileElement;

#ifdef __cplusplus

class DECLSPEC_UUID("3050f2ae-98b5-11cf-bb82-00aa00bdce0b")
HTMLInputFileElement;
#endif

#ifndef __DispIHTMLOptionButtonElement_DISPINTERFACE_DEFINED__
#define __DispIHTMLOptionButtonElement_DISPINTERFACE_DEFINED__

/* dispinterface DispIHTMLOptionButtonElement */
/* [uuid][hidden] */ 


EXTERN_C const IID DIID_DispIHTMLOptionButtonElement;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("3050f509-98b5-11cf-bb82-00aa00bdce0b")
    DispIHTMLOptionButtonElement : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DispIHTMLOptionButtonElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            DispIHTMLOptionButtonElement * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            DispIHTMLOptionButtonElement * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            DispIHTMLOptionButtonElement * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            DispIHTMLOptionButtonElement * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            DispIHTMLOptionButtonElement * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            DispIHTMLOptionButtonElement * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DispIHTMLOptionButtonElement * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } DispIHTMLOptionButtonElementVtbl;

    interface DispIHTMLOptionButtonElement
    {
        CONST_VTBL struct DispIHTMLOptionButtonElementVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DispIHTMLOptionButtonElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DispIHTMLOptionButtonElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DispIHTMLOptionButtonElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DispIHTMLOptionButtonElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DispIHTMLOptionButtonElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DispIHTMLOptionButtonElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DispIHTMLOptionButtonElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DispIHTMLOptionButtonElement_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_HTMLOptionButtonElement;

#ifdef __cplusplus

class DECLSPEC_UUID("3050f2be-98b5-11cf-bb82-00aa00bdce0b")
HTMLOptionButtonElement;
#endif

#ifndef __DispIHTMLInputImage_DISPINTERFACE_DEFINED__
#define __DispIHTMLInputImage_DISPINTERFACE_DEFINED__

/* dispinterface DispIHTMLInputImage */
/* [uuid][hidden] */ 


EXTERN_C const IID DIID_DispIHTMLInputImage;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("3050f51d-98b5-11cf-bb82-00aa00bdce0b")
    DispIHTMLInputImage : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DispIHTMLInputImageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            DispIHTMLInputImage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            DispIHTMLInputImage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            DispIHTMLInputImage * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            DispIHTMLInputImage * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            DispIHTMLInputImage * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            DispIHTMLInputImage * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DispIHTMLInputImage * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } DispIHTMLInputImageVtbl;

    interface DispIHTMLInputImage
    {
        CONST_VTBL struct DispIHTMLInputImageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DispIHTMLInputImage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DispIHTMLInputImage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DispIHTMLInputImage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DispIHTMLInputImage_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DispIHTMLInputImage_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DispIHTMLInputImage_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DispIHTMLInputImage_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DispIHTMLInputImage_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_HTMLInputImage;

#ifdef __cplusplus

class DECLSPEC_UUID("3050f2c4-98b5-11cf-bb82-00aa00bdce0b")
HTMLInputImage;
#endif

#ifndef __IElementNamespace_INTERFACE_DEFINED__
#define __IElementNamespace_INTERFACE_DEFINED__

/* interface IElementNamespace */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IElementNamespace;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f671-98b5-11cf-bb82-00aa00bdce0b")
    IElementNamespace : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddTag( 
            /* [in] */ BSTR bstrTagName,
            /* [in] */ LONG lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IElementNamespaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IElementNamespace * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IElementNamespace * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IElementNamespace * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddTag )( 
            IElementNamespace * This,
            /* [in] */ BSTR bstrTagName,
            /* [in] */ LONG lFlags);
        
        END_INTERFACE
    } IElementNamespaceVtbl;

    interface IElementNamespace
    {
        CONST_VTBL struct IElementNamespaceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IElementNamespace_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IElementNamespace_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IElementNamespace_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IElementNamespace_AddTag(This,bstrTagName,lFlags)	\
    (This)->lpVtbl -> AddTag(This,bstrTagName,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IElementNamespace_AddTag_Proxy( 
    IElementNamespace * This,
    /* [in] */ BSTR bstrTagName,
    /* [in] */ LONG lFlags);


void __RPC_STUB IElementNamespace_AddTag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IElementNamespace_INTERFACE_DEFINED__ */


#ifndef __IElementNamespaceTable_INTERFACE_DEFINED__
#define __IElementNamespaceTable_INTERFACE_DEFINED__

/* interface IElementNamespaceTable */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IElementNamespaceTable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f670-98b5-11cf-bb82-00aa00bdce0b")
    IElementNamespaceTable : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddNamespace( 
            /* [in] */ BSTR bstrNamespace,
            /* [in] */ BSTR bstrUrn,
            /* [in] */ LONG lFlags,
            /* [in] */ VARIANT *pvarFactory) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IElementNamespaceTableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IElementNamespaceTable * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IElementNamespaceTable * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IElementNamespaceTable * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddNamespace )( 
            IElementNamespaceTable * This,
            /* [in] */ BSTR bstrNamespace,
            /* [in] */ BSTR bstrUrn,
            /* [in] */ LONG lFlags,
            /* [in] */ VARIANT *pvarFactory);
        
        END_INTERFACE
    } IElementNamespaceTableVtbl;

    interface IElementNamespaceTable
    {
        CONST_VTBL struct IElementNamespaceTableVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IElementNamespaceTable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IElementNamespaceTable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IElementNamespaceTable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IElementNamespaceTable_AddNamespace(This,bstrNamespace,bstrUrn,lFlags,pvarFactory)	\
    (This)->lpVtbl -> AddNamespace(This,bstrNamespace,bstrUrn,lFlags,pvarFactory)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IElementNamespaceTable_AddNamespace_Proxy( 
    IElementNamespaceTable * This,
    /* [in] */ BSTR bstrNamespace,
    /* [in] */ BSTR bstrUrn,
    /* [in] */ LONG lFlags,
    /* [in] */ VARIANT *pvarFactory);


void __RPC_STUB IElementNamespaceTable_AddNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IElementNamespaceTable_INTERFACE_DEFINED__ */


#ifndef __IElementNamespaceFactory_INTERFACE_DEFINED__
#define __IElementNamespaceFactory_INTERFACE_DEFINED__

/* interface IElementNamespaceFactory */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IElementNamespaceFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f672-98b5-11cf-bb82-00aa00bdce0b")
    IElementNamespaceFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ IElementNamespace *pNamespace) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IElementNamespaceFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IElementNamespaceFactory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IElementNamespaceFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IElementNamespaceFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            IElementNamespaceFactory * This,
            /* [in] */ IElementNamespace *pNamespace);
        
        END_INTERFACE
    } IElementNamespaceFactoryVtbl;

    interface IElementNamespaceFactory
    {
        CONST_VTBL struct IElementNamespaceFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IElementNamespaceFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IElementNamespaceFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IElementNamespaceFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IElementNamespaceFactory_Create(This,pNamespace)	\
    (This)->lpVtbl -> Create(This,pNamespace)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IElementNamespaceFactory_Create_Proxy( 
    IElementNamespaceFactory * This,
    /* [in] */ IElementNamespace *pNamespace);


void __RPC_STUB IElementNamespaceFactory_Create_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IElementNamespaceFactory_INTERFACE_DEFINED__ */


#ifndef __IElementNamespaceFactory2_INTERFACE_DEFINED__
#define __IElementNamespaceFactory2_INTERFACE_DEFINED__

/* interface IElementNamespaceFactory2 */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IElementNamespaceFactory2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f805-98b5-11cf-bb82-00aa00bdce0b")
    IElementNamespaceFactory2 : public IElementNamespaceFactory
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateWithImplementation( 
            /* [in] */ IElementNamespace *pNamespace,
            /* [in] */ BSTR bstrImplementation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IElementNamespaceFactory2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IElementNamespaceFactory2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IElementNamespaceFactory2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IElementNamespaceFactory2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            IElementNamespaceFactory2 * This,
            /* [in] */ IElementNamespace *pNamespace);
        
        HRESULT ( STDMETHODCALLTYPE *CreateWithImplementation )( 
            IElementNamespaceFactory2 * This,
            /* [in] */ IElementNamespace *pNamespace,
            /* [in] */ BSTR bstrImplementation);
        
        END_INTERFACE
    } IElementNamespaceFactory2Vtbl;

    interface IElementNamespaceFactory2
    {
        CONST_VTBL struct IElementNamespaceFactory2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IElementNamespaceFactory2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IElementNamespaceFactory2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IElementNamespaceFactory2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IElementNamespaceFactory2_Create(This,pNamespace)	\
    (This)->lpVtbl -> Create(This,pNamespace)


#define IElementNamespaceFactory2_CreateWithImplementation(This,pNamespace,bstrImplementation)	\
    (This)->lpVtbl -> CreateWithImplementation(This,pNamespace,bstrImplementation)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IElementNamespaceFactory2_CreateWithImplementation_Proxy( 
    IElementNamespaceFactory2 * This,
    /* [in] */ IElementNamespace *pNamespace,
    /* [in] */ BSTR bstrImplementation);


void __RPC_STUB IElementNamespaceFactory2_CreateWithImplementation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IElementNamespaceFactory2_INTERFACE_DEFINED__ */


#ifndef __IElementNamespaceFactoryCallback_INTERFACE_DEFINED__
#define __IElementNamespaceFactoryCallback_INTERFACE_DEFINED__

/* interface IElementNamespaceFactoryCallback */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IElementNamespaceFactoryCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f7fd-98b5-11cf-bb82-00aa00bdce0b")
    IElementNamespaceFactoryCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Resolve( 
            /* [in] */ BSTR bstrNamespace,
            /* [in] */ BSTR bstrTagName,
            /* [in] */ BSTR bstrAttrs,
            /* [in] */ IElementNamespace *pNamespace) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IElementNamespaceFactoryCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IElementNamespaceFactoryCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IElementNamespaceFactoryCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IElementNamespaceFactoryCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resolve )( 
            IElementNamespaceFactoryCallback * This,
            /* [in] */ BSTR bstrNamespace,
            /* [in] */ BSTR bstrTagName,
            /* [in] */ BSTR bstrAttrs,
            /* [in] */ IElementNamespace *pNamespace);
        
        END_INTERFACE
    } IElementNamespaceFactoryCallbackVtbl;

    interface IElementNamespaceFactoryCallback
    {
        CONST_VTBL struct IElementNamespaceFactoryCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IElementNamespaceFactoryCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IElementNamespaceFactoryCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IElementNamespaceFactoryCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IElementNamespaceFactoryCallback_Resolve(This,bstrNamespace,bstrTagName,bstrAttrs,pNamespace)	\
    (This)->lpVtbl -> Resolve(This,bstrNamespace,bstrTagName,bstrAttrs,pNamespace)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IElementNamespaceFactoryCallback_Resolve_Proxy( 
    IElementNamespaceFactoryCallback * This,
    /* [in] */ BSTR bstrNamespace,
    /* [in] */ BSTR bstrTagName,
    /* [in] */ BSTR bstrAttrs,
    /* [in] */ IElementNamespace *pNamespace);


void __RPC_STUB IElementNamespaceFactoryCallback_Resolve_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IElementNamespaceFactoryCallback_INTERFACE_DEFINED__ */


#ifndef __IElementBehaviorSiteOM2_INTERFACE_DEFINED__
#define __IElementBehaviorSiteOM2_INTERFACE_DEFINED__

/* interface IElementBehaviorSiteOM2 */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IElementBehaviorSiteOM2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f659-98b5-11cf-bb82-00aa00bdce0b")
    IElementBehaviorSiteOM2 : public IElementBehaviorSiteOM
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDefaults( 
            /* [out][retval] */ IHTMLElementDefaults **ppDefaults) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IElementBehaviorSiteOM2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IElementBehaviorSiteOM2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IElementBehaviorSiteOM2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IElementBehaviorSiteOM2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterEvent )( 
            IElementBehaviorSiteOM2 * This,
            /* [in] */ LPOLESTR pchEvent,
            /* [in] */ LONG lFlags,
            /* [out][retval] */ LONG *plCookie);
        
        HRESULT ( STDMETHODCALLTYPE *GetEventCookie )( 
            IElementBehaviorSiteOM2 * This,
            /* [in] */ LPOLESTR pchEvent,
            /* [out][retval] */ LONG *plCookie);
        
        HRESULT ( STDMETHODCALLTYPE *FireEvent )( 
            IElementBehaviorSiteOM2 * This,
            /* [in] */ LONG lCookie,
            /* [in] */ IHTMLEventObj *pEventObject);
        
        HRESULT ( STDMETHODCALLTYPE *CreateEventObject )( 
            IElementBehaviorSiteOM2 * This,
            /* [out][retval] */ IHTMLEventObj **ppEventObject);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterName )( 
            IElementBehaviorSiteOM2 * This,
            /* [in] */ LPOLESTR pchName);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterUrn )( 
            IElementBehaviorSiteOM2 * This,
            /* [in] */ LPOLESTR pchUrn);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaults )( 
            IElementBehaviorSiteOM2 * This,
            /* [out][retval] */ IHTMLElementDefaults **ppDefaults);
        
        END_INTERFACE
    } IElementBehaviorSiteOM2Vtbl;

    interface IElementBehaviorSiteOM2
    {
        CONST_VTBL struct IElementBehaviorSiteOM2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IElementBehaviorSiteOM2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IElementBehaviorSiteOM2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IElementBehaviorSiteOM2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IElementBehaviorSiteOM2_RegisterEvent(This,pchEvent,lFlags,plCookie)	\
    (This)->lpVtbl -> RegisterEvent(This,pchEvent,lFlags,plCookie)

#define IElementBehaviorSiteOM2_GetEventCookie(This,pchEvent,plCookie)	\
    (This)->lpVtbl -> GetEventCookie(This,pchEvent,plCookie)

#define IElementBehaviorSiteOM2_FireEvent(This,lCookie,pEventObject)	\
    (This)->lpVtbl -> FireEvent(This,lCookie,pEventObject)

#define IElementBehaviorSiteOM2_CreateEventObject(This,ppEventObject)	\
    (This)->lpVtbl -> CreateEventObject(This,ppEventObject)

#define IElementBehaviorSiteOM2_RegisterName(This,pchName)	\
    (This)->lpVtbl -> RegisterName(This,pchName)

#define IElementBehaviorSiteOM2_RegisterUrn(This,pchUrn)	\
    (This)->lpVtbl -> RegisterUrn(This,pchUrn)


#define IElementBehaviorSiteOM2_GetDefaults(This,ppDefaults)	\
    (This)->lpVtbl -> GetDefaults(This,ppDefaults)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IElementBehaviorSiteOM2_GetDefaults_Proxy( 
    IElementBehaviorSiteOM2 * This,
    /* [out][retval] */ IHTMLElementDefaults **ppDefaults);


void __RPC_STUB IElementBehaviorSiteOM2_GetDefaults_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IElementBehaviorSiteOM2_INTERFACE_DEFINED__ */


#ifndef __IElementBehaviorCategory_INTERFACE_DEFINED__
#define __IElementBehaviorCategory_INTERFACE_DEFINED__

/* interface IElementBehaviorCategory */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IElementBehaviorCategory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f4ed-98b5-11cf-bb82-00aa00bdce0b")
    IElementBehaviorCategory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCategory( 
            /* [out][retval] */ LPOLESTR *ppchCategory) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IElementBehaviorCategoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IElementBehaviorCategory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IElementBehaviorCategory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IElementBehaviorCategory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCategory )( 
            IElementBehaviorCategory * This,
            /* [out][retval] */ LPOLESTR *ppchCategory);
        
        END_INTERFACE
    } IElementBehaviorCategoryVtbl;

    interface IElementBehaviorCategory
    {
        CONST_VTBL struct IElementBehaviorCategoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IElementBehaviorCategory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IElementBehaviorCategory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IElementBehaviorCategory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IElementBehaviorCategory_GetCategory(This,ppchCategory)	\
    (This)->lpVtbl -> GetCategory(This,ppchCategory)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IElementBehaviorCategory_GetCategory_Proxy( 
    IElementBehaviorCategory * This,
    /* [out][retval] */ LPOLESTR *ppchCategory);


void __RPC_STUB IElementBehaviorCategory_GetCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IElementBehaviorCategory_INTERFACE_DEFINED__ */


#ifndef __IElementBehaviorSiteCategory_INTERFACE_DEFINED__
#define __IElementBehaviorSiteCategory_INTERFACE_DEFINED__

/* interface IElementBehaviorSiteCategory */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IElementBehaviorSiteCategory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f4ee-98b5-11cf-bb82-00aa00bdce0b")
    IElementBehaviorSiteCategory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRelatedBehaviors( 
            /* [in] */ LONG lDirection,
            /* [in] */ LPOLESTR pchCategory,
            /* [out][retval] */ IEnumUnknown **ppEnumerator) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IElementBehaviorSiteCategoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IElementBehaviorSiteCategory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IElementBehaviorSiteCategory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IElementBehaviorSiteCategory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRelatedBehaviors )( 
            IElementBehaviorSiteCategory * This,
            /* [in] */ LONG lDirection,
            /* [in] */ LPOLESTR pchCategory,
            /* [out][retval] */ IEnumUnknown **ppEnumerator);
        
        END_INTERFACE
    } IElementBehaviorSiteCategoryVtbl;

    interface IElementBehaviorSiteCategory
    {
        CONST_VTBL struct IElementBehaviorSiteCategoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IElementBehaviorSiteCategory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IElementBehaviorSiteCategory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IElementBehaviorSiteCategory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IElementBehaviorSiteCategory_GetRelatedBehaviors(This,lDirection,pchCategory,ppEnumerator)	\
    (This)->lpVtbl -> GetRelatedBehaviors(This,lDirection,pchCategory,ppEnumerator)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IElementBehaviorSiteCategory_GetRelatedBehaviors_Proxy( 
    IElementBehaviorSiteCategory * This,
    /* [in] */ LONG lDirection,
    /* [in] */ LPOLESTR pchCategory,
    /* [out][retval] */ IEnumUnknown **ppEnumerator);


void __RPC_STUB IElementBehaviorSiteCategory_GetRelatedBehaviors_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IElementBehaviorSiteCategory_INTERFACE_DEFINED__ */


#ifndef __IElementBehaviorSubmit_INTERFACE_DEFINED__
#define __IElementBehaviorSubmit_INTERFACE_DEFINED__

/* interface IElementBehaviorSubmit */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IElementBehaviorSubmit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f646-98b5-11cf-bb82-00aa00bdce0b")
    IElementBehaviorSubmit : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSubmitInfo( 
            /* [in] */ IHTMLSubmitData *pSubmitData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IElementBehaviorSubmitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IElementBehaviorSubmit * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IElementBehaviorSubmit * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IElementBehaviorSubmit * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubmitInfo )( 
            IElementBehaviorSubmit * This,
            /* [in] */ IHTMLSubmitData *pSubmitData);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IElementBehaviorSubmit * This);
        
        END_INTERFACE
    } IElementBehaviorSubmitVtbl;

    interface IElementBehaviorSubmit
    {
        CONST_VTBL struct IElementBehaviorSubmitVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IElementBehaviorSubmit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IElementBehaviorSubmit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IElementBehaviorSubmit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IElementBehaviorSubmit_GetSubmitInfo(This,pSubmitData)	\
    (This)->lpVtbl -> GetSubmitInfo(This,pSubmitData)

#define IElementBehaviorSubmit_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IElementBehaviorSubmit_GetSubmitInfo_Proxy( 
    IElementBehaviorSubmit * This,
    /* [in] */ IHTMLSubmitData *pSubmitData);


void __RPC_STUB IElementBehaviorSubmit_GetSubmitInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IElementBehaviorSubmit_Reset_Proxy( 
    IElementBehaviorSubmit * This);


void __RPC_STUB IElementBehaviorSubmit_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IElementBehaviorSubmit_INTERFACE_DEFINED__ */


#ifndef __IElementBehaviorFocus_INTERFACE_DEFINED__
#define __IElementBehaviorFocus_INTERFACE_DEFINED__

/* interface IElementBehaviorFocus */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IElementBehaviorFocus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f6b6-98b5-11cf-bb82-00aa00bdce0b")
    IElementBehaviorFocus : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFocusRect( 
            /* [in] */ RECT *pRect) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IElementBehaviorFocusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IElementBehaviorFocus * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IElementBehaviorFocus * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IElementBehaviorFocus * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetFocusRect )( 
            IElementBehaviorFocus * This,
            /* [in] */ RECT *pRect);
        
        END_INTERFACE
    } IElementBehaviorFocusVtbl;

    interface IElementBehaviorFocus
    {
        CONST_VTBL struct IElementBehaviorFocusVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IElementBehaviorFocus_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IElementBehaviorFocus_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IElementBehaviorFocus_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IElementBehaviorFocus_GetFocusRect(This,pRect)	\
    (This)->lpVtbl -> GetFocusRect(This,pRect)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IElementBehaviorFocus_GetFocusRect_Proxy( 
    IElementBehaviorFocus * This,
    /* [in] */ RECT *pRect);


void __RPC_STUB IElementBehaviorFocus_GetFocusRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IElementBehaviorFocus_INTERFACE_DEFINED__ */


#ifndef __IElementBehaviorLayout_INTERFACE_DEFINED__
#define __IElementBehaviorLayout_INTERFACE_DEFINED__

/* interface IElementBehaviorLayout */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IElementBehaviorLayout;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f6ba-98b5-11cf-bb82-00aa00bdce0b")
    IElementBehaviorLayout : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [in] */ LONG dwFlags,
            /* [in] */ SIZE sizeContent,
            /* [out][in] */ POINT *pptTranslateBy,
            /* [out][in] */ POINT *pptTopLeft,
            /* [out][in] */ SIZE *psizeProposed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLayoutInfo( 
            /* [out][retval] */ LONG *plLayoutInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPosition( 
            /* [in] */ LONG lFlags,
            /* [out][in] */ POINT *pptTopLeft) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapSize( 
            /* [in] */ SIZE *psizeIn,
            /* [out] */ RECT *prcOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IElementBehaviorLayoutVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IElementBehaviorLayout * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IElementBehaviorLayout * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IElementBehaviorLayout * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            IElementBehaviorLayout * This,
            /* [in] */ LONG dwFlags,
            /* [in] */ SIZE sizeContent,
            /* [out][in] */ POINT *pptTranslateBy,
            /* [out][in] */ POINT *pptTopLeft,
            /* [out][in] */ SIZE *psizeProposed);
        
        HRESULT ( STDMETHODCALLTYPE *GetLayoutInfo )( 
            IElementBehaviorLayout * This,
            /* [out][retval] */ LONG *plLayoutInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetPosition )( 
            IElementBehaviorLayout * This,
            /* [in] */ LONG lFlags,
            /* [out][in] */ POINT *pptTopLeft);
        
        HRESULT ( STDMETHODCALLTYPE *MapSize )( 
            IElementBehaviorLayout * This,
            /* [in] */ SIZE *psizeIn,
            /* [out] */ RECT *prcOut);
        
        END_INTERFACE
    } IElementBehaviorLayoutVtbl;

    interface IElementBehaviorLayout
    {
        CONST_VTBL struct IElementBehaviorLayoutVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IElementBehaviorLayout_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IElementBehaviorLayout_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IElementBehaviorLayout_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IElementBehaviorLayout_GetSize(This,dwFlags,sizeContent,pptTranslateBy,pptTopLeft,psizeProposed)	\
    (This)->lpVtbl -> GetSize(This,dwFlags,sizeContent,pptTranslateBy,pptTopLeft,psizeProposed)

#define IElementBehaviorLayout_GetLayoutInfo(This,plLayoutInfo)	\
    (This)->lpVtbl -> GetLayoutInfo(This,plLayoutInfo)

#define IElementBehaviorLayout_GetPosition(This,lFlags,pptTopLeft)	\
    (This)->lpVtbl -> GetPosition(This,lFlags,pptTopLeft)

#define IElementBehaviorLayout_MapSize(This,psizeIn,prcOut)	\
    (This)->lpVtbl -> MapSize(This,psizeIn,prcOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IElementBehaviorLayout_GetSize_Proxy( 
    IElementBehaviorLayout * This,
    /* [in] */ LONG dwFlags,
    /* [in] */ SIZE sizeContent,
    /* [out][in] */ POINT *pptTranslateBy,
    /* [out][in] */ POINT *pptTopLeft,
    /* [out][in] */ SIZE *psizeProposed);


void __RPC_STUB IElementBehaviorLayout_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IElementBehaviorLayout_GetLayoutInfo_Proxy( 
    IElementBehaviorLayout * This,
    /* [out][retval] */ LONG *plLayoutInfo);


void __RPC_STUB IElementBehaviorLayout_GetLayoutInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IElementBehaviorLayout_GetPosition_Proxy( 
    IElementBehaviorLayout * This,
    /* [in] */ LONG lFlags,
    /* [out][in] */ POINT *pptTopLeft);


void __RPC_STUB IElementBehaviorLayout_GetPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IElementBehaviorLayout_MapSize_Proxy( 
    IElementBehaviorLayout * This,
    /* [in] */ SIZE *psizeIn,
    /* [out] */ RECT *prcOut);


void __RPC_STUB IElementBehaviorLayout_MapSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IElementBehaviorLayout_INTERFACE_DEFINED__ */


#ifndef __IElementBehaviorLayout2_INTERFACE_DEFINED__
#define __IElementBehaviorLayout2_INTERFACE_DEFINED__

/* interface IElementBehaviorLayout2 */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IElementBehaviorLayout2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f846-98b5-11cf-bb82-00aa00bdce0b")
    IElementBehaviorLayout2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTextDescent( 
            /* [out] */ LONG *plDescent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IElementBehaviorLayout2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IElementBehaviorLayout2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IElementBehaviorLayout2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IElementBehaviorLayout2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTextDescent )( 
            IElementBehaviorLayout2 * This,
            /* [out] */ LONG *plDescent);
        
        END_INTERFACE
    } IElementBehaviorLayout2Vtbl;

    interface IElementBehaviorLayout2
    {
        CONST_VTBL struct IElementBehaviorLayout2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IElementBehaviorLayout2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IElementBehaviorLayout2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IElementBehaviorLayout2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IElementBehaviorLayout2_GetTextDescent(This,plDescent)	\
    (This)->lpVtbl -> GetTextDescent(This,plDescent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IElementBehaviorLayout2_GetTextDescent_Proxy( 
    IElementBehaviorLayout2 * This,
    /* [out] */ LONG *plDescent);


void __RPC_STUB IElementBehaviorLayout2_GetTextDescent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IElementBehaviorLayout2_INTERFACE_DEFINED__ */


#ifndef __IElementBehaviorSiteLayout_INTERFACE_DEFINED__
#define __IElementBehaviorSiteLayout_INTERFACE_DEFINED__

/* interface IElementBehaviorSiteLayout */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IElementBehaviorSiteLayout;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f6b7-98b5-11cf-bb82-00aa00bdce0b")
    IElementBehaviorSiteLayout : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InvalidateLayoutInfo( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvalidateSize( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaResolution( 
            /* [out][retval] */ SIZE *psizeResolution) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IElementBehaviorSiteLayoutVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IElementBehaviorSiteLayout * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IElementBehaviorSiteLayout * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IElementBehaviorSiteLayout * This);
        
        HRESULT ( STDMETHODCALLTYPE *InvalidateLayoutInfo )( 
            IElementBehaviorSiteLayout * This);
        
        HRESULT ( STDMETHODCALLTYPE *InvalidateSize )( 
            IElementBehaviorSiteLayout * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaResolution )( 
            IElementBehaviorSiteLayout * This,
            /* [out][retval] */ SIZE *psizeResolution);
        
        END_INTERFACE
    } IElementBehaviorSiteLayoutVtbl;

    interface IElementBehaviorSiteLayout
    {
        CONST_VTBL struct IElementBehaviorSiteLayoutVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IElementBehaviorSiteLayout_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IElementBehaviorSiteLayout_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IElementBehaviorSiteLayout_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IElementBehaviorSiteLayout_InvalidateLayoutInfo(This)	\
    (This)->lpVtbl -> InvalidateLayoutInfo(This)

#define IElementBehaviorSiteLayout_InvalidateSize(This)	\
    (This)->lpVtbl -> InvalidateSize(This)

#define IElementBehaviorSiteLayout_GetMediaResolution(This,psizeResolution)	\
    (This)->lpVtbl -> GetMediaResolution(This,psizeResolution)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IElementBehaviorSiteLayout_InvalidateLayoutInfo_Proxy( 
    IElementBehaviorSiteLayout * This);


void __RPC_STUB IElementBehaviorSiteLayout_InvalidateLayoutInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IElementBehaviorSiteLayout_InvalidateSize_Proxy( 
    IElementBehaviorSiteLayout * This);


void __RPC_STUB IElementBehaviorSiteLayout_InvalidateSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IElementBehaviorSiteLayout_GetMediaResolution_Proxy( 
    IElementBehaviorSiteLayout * This,
    /* [out][retval] */ SIZE *psizeResolution);


void __RPC_STUB IElementBehaviorSiteLayout_GetMediaResolution_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IElementBehaviorSiteLayout_INTERFACE_DEFINED__ */


#ifndef __IElementBehaviorSiteLayout2_INTERFACE_DEFINED__
#define __IElementBehaviorSiteLayout2_INTERFACE_DEFINED__

/* interface IElementBehaviorSiteLayout2 */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IElementBehaviorSiteLayout2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f847-98b5-11cf-bb82-00aa00bdce0b")
    IElementBehaviorSiteLayout2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFontInfo( 
            /* [out] */ LOGFONTW *plf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IElementBehaviorSiteLayout2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IElementBehaviorSiteLayout2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IElementBehaviorSiteLayout2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IElementBehaviorSiteLayout2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetFontInfo )( 
            IElementBehaviorSiteLayout2 * This,
            /* [out] */ LOGFONTW *plf);
        
        END_INTERFACE
    } IElementBehaviorSiteLayout2Vtbl;

    interface IElementBehaviorSiteLayout2
    {
        CONST_VTBL struct IElementBehaviorSiteLayout2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IElementBehaviorSiteLayout2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IElementBehaviorSiteLayout2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IElementBehaviorSiteLayout2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IElementBehaviorSiteLayout2_GetFontInfo(This,plf)	\
    (This)->lpVtbl -> GetFontInfo(This,plf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IElementBehaviorSiteLayout2_GetFontInfo_Proxy( 
    IElementBehaviorSiteLayout2 * This,
    /* [out] */ LOGFONTW *plf);


void __RPC_STUB IElementBehaviorSiteLayout2_GetFontInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IElementBehaviorSiteLayout2_INTERFACE_DEFINED__ */


#ifndef __IHostBehaviorInit_INTERFACE_DEFINED__
#define __IHostBehaviorInit_INTERFACE_DEFINED__

/* interface IHostBehaviorInit */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHostBehaviorInit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f842-98b5-11cf-bb82-00aa00bdce0b")
    IHostBehaviorInit : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PopulateNamespaceTable( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHostBehaviorInitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHostBehaviorInit * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHostBehaviorInit * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHostBehaviorInit * This);
        
        HRESULT ( STDMETHODCALLTYPE *PopulateNamespaceTable )( 
            IHostBehaviorInit * This);
        
        END_INTERFACE
    } IHostBehaviorInitVtbl;

    interface IHostBehaviorInit
    {
        CONST_VTBL struct IHostBehaviorInitVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHostBehaviorInit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHostBehaviorInit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHostBehaviorInit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHostBehaviorInit_PopulateNamespaceTable(This)	\
    (This)->lpVtbl -> PopulateNamespaceTable(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHostBehaviorInit_PopulateNamespaceTable_Proxy( 
    IHostBehaviorInit * This);


void __RPC_STUB IHostBehaviorInit_PopulateNamespaceTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHostBehaviorInit_INTERFACE_DEFINED__ */

#endif /* __MSHTML_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\ossper.h ===
/*****************************************************************************/
/* Copyright (C) 1989-1999 Open Systems Solutions, Inc.  All rights reserved.*/
/*****************************************************************************/

/* THIS FILE IS PROPRIETARY MATERIAL OF OPEN SYSTEMS SOLUTIONS, INC.
 * AND MAY BE USED ONLY BY DIRECT LICENSEES OF OPEN SYSTEMS SOLUTIONS, INC.
 * THIS FILE MAY NOT BE DISTRIBUTED. */

/*
 *
 * FILE: @(#)ossper.h	5.6  97/06/08
 *
 * function: Define the interfaces to the routines in the OSS PER
 * time-optimized encoder and decoder.
 *
 */

#ifndef ossper_hdr_file
#define ossper_hdr_file

#if _MSC_VER > 1000
#pragma once
#endif

#include <limits.h>
#include "asn1hdr.h"

#define Aligned   1
#define Unaligned 0

#if defined(_MSC_VER) && (defined(_WIN32) || defined(WIN32))
#pragma pack(push, ossPacking, 4)
#elif defined(_MSC_VER) && (defined(_WINDOWS) || defined(_MSDOS))
#pragma pack(1)
#elif defined(__BORLANDC__) && defined(__MSDOS__)
#ifdef _BC31
#pragma option -a-
#else
#pragma option -a1
#endif /* _BC31 */
#elif defined(__BORLANDC__) && defined(__WIN32__)
#pragma option -a4
#elif defined(__IBMC__)
#pragma pack(4)
#elif defined(__WATCOMC__) && defined(__NT__)
#pragma pack(push, 4)
#elif defined(__WATCOMC__) && (defined(__WINDOWS__) || defined(__DOS__))
#pragma pack(push, 1)
#endif /* _MSC_VER && _WIN32 */

#ifdef macintosh
#pragma options align=mac68k
#endif

struct _enum_data {
	int      num;    /* number of enumerations */
	long    *enums;  /* pointer to sorted array of enumerations */
};

struct _char_data {
	int      num;  /* number of characters in PermittedAlphabet */
	void     *pa;  /* pointer to PermittedAlphabet char string */
	void     *ia;  /* pointer to inverted indices string */
};

#if defined(_MSC_VER) && (defined(_WIN32) || defined(WIN32))
#pragma pack(pop, ossPacking)
#elif defined(_MSC_VER) && (defined(_WINDOWS) || defined(_MSDOS))
#pragma pack()
#elif defined(__BORLANDC__) && (defined(__WIN32__) || defined(__MSDOS__))
#pragma option -a.
#elif defined(__IBMC__)
#pragma pack()
#elif defined(__WATCOMC__)
#pragma pack(pop)
#endif /* _MSC_VER && _WIN32 */

#ifdef macintosh
#pragma options align=reset
#endif

#ifdef __cplusplus
extern "C" {
#endif

extern void DLL_ENTRY _oss_append(struct ossGlobal *g, unsigned char *field, unsigned long length,
			int align);

extern void DLL_ENTRY _oss_penc_unconstr_int(struct ossGlobal *g,
	    LONG_LONG value);

extern void DLL_ENTRY _oss_penc_semicon_int(struct ossGlobal *g,
	    LONG_LONG value, LONG_LONG lower_bound);

extern void DLL_ENTRY _oss_penc_semicon_uint(struct ossGlobal *g,
	    ULONG_LONG value, ULONG_LONG lower_bound);

extern void DLL_ENTRY _oss_penc_nonneg_int(struct ossGlobal *g,
	    ULONG_LONG value, ULONG_LONG range);

extern void DLL_ENTRY _oss_penc_indeflen_int(struct ossGlobal *g,
	    ULONG_LONG value, ULONG_LONG range);

extern void DLL_ENTRY _oss_penc_small_int(struct ossGlobal *g, ULONG_LONG value);

extern void DLL_ENTRY _oss_penc_enum(struct ossGlobal *g, long data,
	 struct _enum_data *root,
	 struct _enum_data *extension);

extern void DLL_ENTRY _oss_penc_uenum(struct ossGlobal *g, unsigned long data,
	 struct _enum_data *root,
	 struct _enum_data *extension);

extern void DLL_ENTRY _oss_penc_real(struct ossGlobal *g, double value);
extern void DLL_ENTRY _oss_penc_creal(struct ossGlobal *g, char *value);
extern void DLL_ENTRY _oss_penc_mreal(struct ossGlobal *g, MixedReal value);

extern void DLL_ENTRY _oss_penc_constr_bpbit(struct ossGlobal *g, void *value,
	ULONG_LONG lb, ULONG_LONG ub, _Bool NamedBits,
	_Bool Ext);

extern void DLL_ENTRY _oss_penc_constr_pbit(struct ossGlobal *g, ULONG_LONG value,
	ULONG_LONG size, ULONG_LONG lb, ULONG_LONG ub, _Bool NamedBits,
	_Bool Ext);

extern void DLL_ENTRY _oss_penc_constr_bit(struct ossGlobal *g, unsigned char *value,
	ULONG_LONG length, ULONG_LONG lb, ULONG_LONG ub, _Bool NamedBits,
	_Bool Ext);

extern void DLL_ENTRY _oss_penc_unconstr_bit(struct ossGlobal *g, unsigned char *value,
	ULONG_LONG length, _Bool NamedBits);

extern void DLL_ENTRY _oss_penc_unconstr_pbit(struct ossGlobal *g, ULONG_LONG value,
	ULONG_LONG length, ULONG_LONG size, _Bool NamedBits);

extern unsigned long DLL_ENTRY _oss_penc_length(struct ossGlobal *g, ULONG_LONG length,
		  ULONG_LONG lb, ULONG_LONG ub, _Bool ext);

extern unsigned long DLL_ENTRY _oss_pdec_small_len(struct ossGlobal *g);
extern void          DLL_ENTRY _oss_penc_small_len(struct ossGlobal *g,
							ULONG_LONG length);

extern void DLL_ENTRY _oss_penc_unconstr_oct(struct ossGlobal *g, unsigned char *value,
	 ULONG_LONG length);

extern void DLL_ENTRY _oss_penc_constr_oct(struct ossGlobal *g, unsigned char *value,
	 ULONG_LONG length, ULONG_LONG lb, ULONG_LONG ub);

extern struct ossGlobal *DLL_ENTRY _oss_push_global(struct ossGlobal *g);
extern struct ossGlobal *DLL_ENTRY _oss_pop_global(struct ossGlobal *g);

extern void DLL_ENTRY _oss_penc_objids(struct ossGlobal *g, unsigned short *value,
   unsigned long length);
extern void DLL_ENTRY _oss_penc_objidi(struct ossGlobal *g, unsigned int *value,
   unsigned long length);
extern void DLL_ENTRY _oss_penc_objidl(struct ossGlobal *g, unsigned long *value,
   unsigned long length);
extern void DLL_ENTRY _oss_penc_link_objids(struct ossGlobal *g, void *value);
extern void DLL_ENTRY _oss_penc_link_objidi(struct ossGlobal *g, void *value);
extern void DLL_ENTRY _oss_penc_link_objidl(struct ossGlobal *g, void *value);

extern void DLL_ENTRY _oss_penc_opentype(struct ossGlobal *g, void *value);
extern void DLL_ENTRY _oss_penc_nkmstr(struct ossGlobal *g, char *value, ULONG_LONG length);
extern void DLL_ENTRY _oss_penc_kmstr(struct ossGlobal *g, char *value, ULONG_LONG length,
     ULONG_LONG lb, ULONG_LONG ub, int bits, long index,
     _Bool ext);
extern void DLL_ENTRY _oss_penc_bmpstr(struct ossGlobal *g, unsigned short *value,
     ULONG_LONG length, ULONG_LONG lb, ULONG_LONG ub, int bits, long index,
     _Bool ext);
#if INT_MAX == 2147483647
extern void DLL_ENTRY _oss_penc_unistr(struct ossGlobal *g, int *value,
     ULONG_LONG length, ULONG_LONG lb, ULONG_LONG ub, int bits, long index,
     _Bool ext);
#else
extern void DLL_ENTRY _oss_penc_unistr(struct ossGlobal *g, long *value,
     ULONG_LONG length, ULONG_LONG lb, ULONG_LONG ub, int bits, long index,
     _Bool ext);
#endif

extern void DLL_ENTRY _oss_penc_gtime(struct ossGlobal *g, GeneralizedTime *time);
extern void DLL_ENTRY _oss_penc_utime(struct ossGlobal *g, UTCTime *time);

extern void DLL_ENTRY _oss_penc_uany(struct ossGlobal *g, void *data );

extern void DLL_ENTRY _oss_penc_unconstr_huge(struct ossGlobal *g, void *data );
extern void DLL_ENTRY _oss_penc_semicon_huge(struct ossGlobal *g,
    void *data, LONG_LONG lb );

extern void DLL_ENTRY _oss_penc_eobjid(struct ossGlobal *g, void *data,
    long size_c);

/* decoding functions */

extern unsigned char DLL_ENTRY _oss_get_bit(struct ossGlobal *g, int align);

extern void DLL_ENTRY _oss_get_bits(struct ossGlobal *g, unsigned char *field,
			unsigned long length, int align);

extern unsigned char DLL_ENTRY _oss_get_octet(struct ossGlobal *g, int align);

extern LONG_LONG DLL_ENTRY _oss_pdec_unconstr_int(struct ossGlobal *g);

extern LONG_LONG DLL_ENTRY _oss_pdec_semicon_int(struct ossGlobal *g,
	    LONG_LONG lower_bound);

extern ULONG_LONG DLL_ENTRY _oss_pdec_semicon_uint(struct ossGlobal *g,
	    ULONG_LONG lower_bound);

extern ULONG_LONG DLL_ENTRY _oss_pdec_nonneg_int(struct ossGlobal *g,
	    ULONG_LONG range);

extern ULONG_LONG DLL_ENTRY _oss_pdec_indeflen_int(struct ossGlobal *g,
	    ULONG_LONG range);

extern ULONG_LONG DLL_ENTRY _oss_pdec_small_int(struct ossGlobal *g);

extern long DLL_ENTRY _oss_pdec_enum(struct ossGlobal *g,
	 struct _enum_data *root,
	 struct _enum_data *extension);

extern unsigned long DLL_ENTRY _oss_pdec_uenum(struct ossGlobal *g,
	 struct _enum_data *root,
	 struct _enum_data *extension);


extern double DLL_ENTRY _oss_pdec_binreal(struct ossGlobal *g, unsigned char s, long len);
extern void DLL_ENTRY _oss_pdec_chrreal(struct ossGlobal *g, unsigned char s, long len,
     double *num_out, unsigned char *str_out);

extern float     DLL_ENTRY _oss_pdec_freal(struct ossGlobal *g);
extern double    DLL_ENTRY _oss_pdec_real(struct ossGlobal *g);
extern char *    DLL_ENTRY _oss_pdec_creal(struct ossGlobal *g);
extern MixedReal DLL_ENTRY _oss_pdec_mreal(struct ossGlobal *g);

extern void DLL_ENTRY _oss_pdec_length(struct ossGlobal *g, unsigned long *length,
		  ULONG_LONG lb, ULONG_LONG ub, _Bool *last);

extern void DLL_ENTRY _oss_pdec_unconstr_ubit(struct ossGlobal *g, void *length,
	 unsigned char **value, int lengthsize);

extern void DLL_ENTRY _oss_pdec_unconstr_vbit_ptr(struct ossGlobal *g, void **ptr,
	 int lengthsize);

extern void DLL_ENTRY _oss_pdec_unconstr_vbit(struct ossGlobal *g, void *length,
	 unsigned char *value, int lengthsize, ULONG_LONG datasize);

extern void DLL_ENTRY _oss_pdec_unconstr_pbit(struct ossGlobal *g, void *value,
	int size);

extern void DLL_ENTRY _oss_pdec_unconstr_bpbit(struct ossGlobal *g, unsigned char *value,
	long size);

extern void DLL_ENTRY _oss_pdec_constr_ubit(struct ossGlobal *g, void *length,
	 unsigned char **value, int lengthsize,
	 ULONG_LONG lb, ULONG_LONG ub);

extern void DLL_ENTRY _oss_pdec_constr_vbit(struct ossGlobal *g, void *length,
	unsigned char  *value, int lengthsize,
	ULONG_LONG lb, ULONG_LONG ub);

extern void DLL_ENTRY _oss_pdec_constr_vbit_ptr(struct ossGlobal *g, void **ptr,
	 int lengthsize, ULONG_LONG lb, ULONG_LONG ub);

extern void DLL_ENTRY _oss_pdec_constr_pbit(struct ossGlobal *g, void *value,
	int size, ULONG_LONG lb, ULONG_LONG ub);

extern void DLL_ENTRY _oss_pdec_constr_bpbit(struct ossGlobal *g, unsigned char *value,
	int size, ULONG_LONG lb, ULONG_LONG ub);

extern void DLL_ENTRY _oss_pdec_unconstr_uoct(struct ossGlobal *g, void *length,
	 unsigned char **value, int lengthsize);

extern void DLL_ENTRY _oss_pdec_unconstr_voct_ptr(struct ossGlobal *g, void **ptr,
	 int lengthsize);

extern void DLL_ENTRY _oss_pdec_constr_voct_ptr(struct ossGlobal *g, void **ptr,
	 int lengthsize, ULONG_LONG lb, ULONG_LONG ub);

extern void DLL_ENTRY _oss_pdec_constr_uoct(struct ossGlobal *g, void *length,
	unsigned char **value, int lengthsize, ULONG_LONG lb, ULONG_LONG ub);

extern void DLL_ENTRY _oss_pdec_constr_voct(struct ossGlobal *g, void *length,
	unsigned char  *value, int lengthsize, ULONG_LONG lb, ULONG_LONG ub);

extern void DLL_ENTRY _oss_pdec_unconstr_voct(struct ossGlobal *g, void *length,
	unsigned char  *value, int lengthsize, ULONG_LONG ub);

extern struct ossGlobal * DLL_ENTRY _oss_pdec_push(struct ossGlobal *g);
extern struct ossGlobal * DLL_ENTRY _oss_pdec_pop(struct ossGlobal *g);

extern unsigned long DLL_ENTRY _oss_pdec_eap(struct ossGlobal *g, unsigned char **ext);
extern void DLL_ENTRY _oss_pdec_eas(struct ossGlobal *g, unsigned char *ext,
	 unsigned long count, unsigned long ea_num);

extern void DLL_ENTRY _oss_pdec_lsof(struct ossGlobal *g, unsigned long *count,
    ULONG_LONG lb, ULONG_LONG ub, unsigned char ext,
    _Bool *last);

extern void DLL_ENTRY _oss_pdec_usof(struct ossGlobal *g, unsigned long *count,
    unsigned char **value, int lengthsize, long itemsize,
    ULONG_LONG lb, ULONG_LONG ub, unsigned char ext,
    _Bool *last);

extern void DLL_ENTRY _oss_pdec_asof(struct ossGlobal *g, unsigned long *count,
    int lengthsize,
    ULONG_LONG lb, ULONG_LONG ub, unsigned char ext,
    _Bool *last);

extern void DLL_ENTRY _oss_pdec_asof_ptr(struct ossGlobal *g, void **ptr,
    int lengthsize, long itemsize, long prefixsize,
    _Bool *last);

extern void DLL_ENTRY _oss_pdec_aobjids(struct ossGlobal *g, unsigned short *value,
    unsigned short *count, unsigned short array_size);

extern void DLL_ENTRY _oss_pdec_aobjidi(struct ossGlobal *g, unsigned int   *value,
    unsigned short *count, unsigned short array_size);

extern void DLL_ENTRY _oss_pdec_aobjidl(struct ossGlobal *g, unsigned long  *value,
    unsigned short *count, unsigned short array_size);

extern void DLL_ENTRY _oss_pdec_aobjids_ptr(struct ossGlobal *g, void **ptr);
extern void DLL_ENTRY _oss_pdec_aobjidi_ptr(struct ossGlobal *g, void **ptr);
extern void DLL_ENTRY _oss_pdec_aobjidl_ptr(struct ossGlobal *g, void **ptr);

extern void DLL_ENTRY _oss_pdec_uobjids(struct ossGlobal *g, unsigned short **value,
	 unsigned short *count);
extern void DLL_ENTRY _oss_pdec_uobjidi(struct ossGlobal *g, unsigned int **value,
	 unsigned short *count);
extern void DLL_ENTRY _oss_pdec_uobjidl(struct ossGlobal *g, unsigned long **value,
	 unsigned short *count);

extern void DLL_ENTRY _oss_pdec_link_objids(struct ossGlobal *g, void **ptr);
extern void DLL_ENTRY _oss_pdec_link_objidi(struct ossGlobal *g, void **ptr);
extern void DLL_ENTRY _oss_pdec_link_objidl(struct ossGlobal *g, void **ptr);

extern void DLL_ENTRY _oss_pdec_ntp_kmstr(struct ossGlobal *g, char **ptr,
     ULONG_LONG lb, ULONG_LONG ub, int bits, long index,
     _Bool ext);

extern void DLL_ENTRY _oss_pdec_nt_kmstr(struct ossGlobal *g, void *ptr,
     ULONG_LONG lb, ULONG_LONG ub, int bits, long index,
     _Bool ext);

extern void DLL_ENTRY _oss_pdec_vap_kmstr(struct ossGlobal *g, void **ptr, int lengthsize,
     ULONG_LONG lb, ULONG_LONG ub, int bits, long index,
     _Bool ext);

extern void DLL_ENTRY _oss_pdec_va_kmstr(struct ossGlobal *g, void *length, char *value,
     int lengthsize,
     ULONG_LONG lb, ULONG_LONG ub, int bits, long index,
     _Bool ext);

extern void DLL_ENTRY _oss_pdec_ub_kmstr(struct ossGlobal *g, void *length, char **ptr,
     int lengthsize,
     ULONG_LONG lb, ULONG_LONG ub, int bits, long index,
     _Bool ext);

extern void DLL_ENTRY _oss_pdec_bmpstr(struct ossGlobal *g, void *length, unsigned short **ptr,
     int lengthsize,
     ULONG_LONG lb, ULONG_LONG ub, int bits, long index,
     _Bool ext);

#if INT_MAX == 2147483647
extern void DLL_ENTRY _oss_pdec_unistr(struct ossGlobal *g, void *length, int **ptr,
     int lengthsize,
     ULONG_LONG lb, ULONG_LONG ub, int bits, long index,
     _Bool ext);
#else
extern void DLL_ENTRY _oss_pdec_unistr(struct ossGlobal *g, void *length, long **ptr,
     int lengthsize,
     ULONG_LONG lb, ULONG_LONG ub, int bits, long index,
     _Bool ext);
#endif

extern void DLL_ENTRY _oss_pdec_ntp_nkmstr(struct ossGlobal *g, char **ptr);
extern void DLL_ENTRY _oss_pdec_nt_nkmstr(struct ossGlobal *g, char *value, unsigned long ub);
extern void DLL_ENTRY _oss_pdec_vap_nkmstr(struct ossGlobal *g, void **ptr, int lengthsize);
extern void DLL_ENTRY _oss_pdec_va_nkmstr(struct ossGlobal *g, void *length, char *value,
	 int lengthsize, unsigned long ub);
extern void DLL_ENTRY _oss_pdec_ub_nkmstr(struct ossGlobal *g, void *length, char **ptr,
     int lengthsize);

extern void DLL_ENTRY _oss_pdec_pad_kmstr(struct ossGlobal *g, void *ptr,
     ULONG_LONG lb, ULONG_LONG ub, int bits, long index,
     _Bool ext);

extern void DLL_ENTRY _oss_pdec_pad_kmstr_ptr(struct ossGlobal *g, char **ptr,
     ULONG_LONG lb, ULONG_LONG ub, int bits, long index,
     _Bool ext);

extern void DLL_ENTRY _oss_pdec_opentype(struct ossGlobal *g, void *data );
extern void DLL_ENTRY _oss_pdec_uany(struct ossGlobal *g, void *data );

extern void DLL_ENTRY _oss_pdec_gtime(struct ossGlobal *g, GeneralizedTime *data);
extern void DLL_ENTRY _oss_pdec_utime(struct ossGlobal *g, UTCTime *data);

extern struct _char_data *_oss_get_char_data(struct ossGlobal *g, int index);

extern void DLL_ENTRY _oss_pdec_unconstr_huge(struct ossGlobal *g, void *data );
extern void DLL_ENTRY _oss_pdec_semicon_huge(struct ossGlobal *g,
    void *data, LONG_LONG lb );

extern void DLL_ENTRY _oss_pdec_eobjid(struct ossGlobal *g, void *data,
	 long size_c);

extern void DLL_ENTRY _oss_pdec_sot(struct ossGlobal *g);

#ifdef __cplusplus
}
#endif /* __cplusplus */

	/*
	 * The following macros must be #defined if you compile the ASN.1
	 * compiler generated files (.c files) and link-edit with the import
	 * library ossapit.lib, i.e the OSS DLLs ossapit.dll, apit.dll,
	 * and toedber.dll/toedper.dll are used.  The following must not
	 * be #defined if you link-edit with the static library toedcode.lib.
	 */
#if defined(_DLL) || defined(OS2_DLL) ||\
   (defined(_WINDOWS) && !defined(_WIN32))
#define _oss_penc_unconstr_int   (*_g->ft.perTbl->_oss_penc_unconstr_intp)
#define _oss_pdec_unconstr_int   (*_g->ft.perTbl->_oss_pdec_unconstr_intp)
#define _oss_penc_kmstr          (*_g->ft.perTbl->_oss_penc_kmstrp)
#define _oss_pdec_ub_kmstr       (*_g->ft.perTbl->_oss_pdec_ub_kmstrp)
#define _oss_pdec_ntp_kmstr      (*_g->ft.perTbl->_oss_pdec_ntp_kmstrp)
#define _oss_append              (*_g->ft.perTbl->_oss_appendp)
#define _oss_penc_unconstr_bit   (*_g->ft.perTbl->_oss_penc_unconstr_bitp)
#define _oss_penc_constr_bit     (*_g->ft.perTbl->_oss_penc_constr_bitp)
#define _oss_penc_unconstr_oct   (*_g->ft.perTbl->_oss_penc_unconstr_octp)
#define _oss_penc_constr_oct     (*_g->ft.perTbl->_oss_penc_constr_octp)
#define _oss_penc_link_objids    (*_g->ft.perTbl->_oss_penc_link_objidsp)
#define _oss_penc_objids         (*_g->ft.perTbl->_oss_penc_objidsp)
#define _oss_penc_link_objidl    (*_g->ft.perTbl->_oss_penc_link_objidlp)
#define _oss_penc_objidl         (*_g->ft.perTbl->_oss_penc_objidlp)
#define _oss_penc_link_objidi    (*_g->ft.perTbl->_oss_penc_link_objidip)
#define _oss_penc_objidi         (*_g->ft.perTbl->_oss_penc_objidip)
#define _oss_penc_nkmstr         (*_g->ft.perTbl->_oss_penc_nkmstrp)
#define _oss_penc_opentype       (*_g->ft.perTbl->_oss_penc_opentypep)
#define _oss_penc_nonneg_int     (*_g->ft.perTbl->_oss_penc_nonneg_intp)
#define _oss_penc_real           (*_g->ft.perTbl->_oss_penc_realp)
#define _oss_penc_uenum          (*_g->ft.perTbl->_oss_penc_uenump)
#define _oss_penc_length         (*_g->ft.perTbl->_oss_penc_lengthp)
#define _oss_penc_gtime          (*_g->ft.perTbl->_oss_penc_gtimep)
#define _oss_penc_utime          (*_g->ft.perTbl->_oss_penc_utimep)
#define _oss_get_bit             (*_g->ft.perTbl->_oss_get_bitp)
#define _oss_pdec_unconstr_ubit  (*_g->ft.perTbl->_oss_pdec_unconstr_ubitp)
#define _oss_pdec_constr_ubit    (*_g->ft.perTbl->_oss_pdec_constr_ubitp)
#define _oss_pdec_constr_pbit    (*_g->ft.perTbl->_oss_pdec_constr_pbitp)
#define _oss_pdec_constr_bpbit   (*_g->ft.perTbl->_oss_pdec_constr_bpbitp)
#define _oss_pdec_unconstr_vbit_ptr (*_g->ft.perTbl->_oss_pdec_unconstr_vbit_ptrp)
#define _oss_pdec_unconstr_vbit  (*_g->ft.perTbl->_oss_pdec_unconstr_vbitp)
#define _oss_pdec_unconstr_uoct  (*_g->ft.perTbl->_oss_pdec_unconstr_uoctp)
#define _oss_pdec_constr_voct    (*_g->ft.perTbl->_oss_pdec_constr_voctp)
#define _oss_pdec_constr_voct_ptr (*_g->ft.perTbl->_oss_pdec_constr_voct_ptrp)
#define _oss_pdec_unconstr_voct_ptr (*_g->ft.perTbl->_oss_pdec_unconstr_voct_ptrp)
#define _oss_pdec_constr_uoct    (*_g->ft.perTbl->_oss_pdec_constr_uoctp)
#define _oss_pdec_constr_vbit    (*_g->ft.perTbl->_oss_pdec_constr_vbitp)
#define _oss_pdec_constr_vbit_ptr (*_g->ft.perTbl->_oss_pdec_constr_vbit_ptrp)
#define _oss_pdec_link_objids    (*_g->ft.perTbl->_oss_pdec_link_objidsp)
#define _oss_pdec_link_objidl    (*_g->ft.perTbl->_oss_pdec_link_objidlp)
#define _oss_pdec_link_objidi    (*_g->ft.perTbl->_oss_pdec_link_objidip)
#define _oss_pdec_uobjids        (*_g->ft.perTbl->_oss_pdec_uobjidsp)
#define _oss_pdec_uobjidl        (*_g->ft.perTbl->_oss_pdec_uobjidlp)
#define _oss_pdec_uobjidi        (*_g->ft.perTbl->_oss_pdec_uobjidip)
#define _oss_pdec_aobjids        (*_g->ft.perTbl->_oss_pdec_aobjidsp)
#define _oss_pdec_aobjidl        (*_g->ft.perTbl->_oss_pdec_aobjidlp)
#define _oss_pdec_aobjidi        (*_g->ft.perTbl->_oss_pdec_aobjidip)
#define _oss_pdec_aobjids_ptr    (*_g->ft.perTbl->_oss_pdec_aobjids_ptrp)
#define _oss_pdec_aobjidl_ptr    (*_g->ft.perTbl->_oss_pdec_aobjidl_ptrp)
#define _oss_pdec_aobjidi_ptr    (*_g->ft.perTbl->_oss_pdec_aobjidi_ptrp)
#define _oss_pdec_ntp_nkmstr     (*_g->ft.perTbl->_oss_pdec_ntp_nkmstrp)
#define _oss_pdec_nt_nkmstr      (*_g->ft.perTbl->_oss_pdec_nt_nkmstrp)
#define _oss_pdec_opentype       (*_g->ft.perTbl->_oss_pdec_opentypep)
#define _oss_pdec_nonneg_int     (*_g->ft.perTbl->_oss_pdec_nonneg_intp)
#define _oss_get_bits            (*_g->ft.perTbl->_oss_get_bitsp)
#define _oss_pdec_freal          (*_g->ft.perTbl->_oss_pdec_frealp)
#define _oss_pdec_real           (*_g->ft.perTbl->_oss_pdec_realp)
#define _oss_pdec_uenum          (*_g->ft.perTbl->_oss_pdec_uenump)
#define _oss_pdec_asof           (*_g->ft.perTbl->_oss_pdec_asofp)
#define _oss_pdec_usof           (*_g->ft.perTbl->_oss_pdec_usofp)
#define _oss_pdec_lsof           (*_g->ft.perTbl->_oss_pdec_lsofp)
#define _oss_pdec_utime          (*_g->ft.perTbl->_oss_pdec_utimep)
#define _oss_pdec_gtime          (*_g->ft.perTbl->_oss_pdec_gtimep)
#define _oss_pdec_asof_ptr       (*_g->ft.perTbl->_oss_pdec_asof_ptrp)
#define _oss_pdec_nt_kmstr       (*_g->ft.perTbl->_oss_pdec_nt_kmstrp)
#define _oss_pdec_va_kmstr       (*_g->ft.perTbl->_oss_pdec_va_kmstrp)
#define _oss_pdec_vap_kmstr      (*_g->ft.perTbl->_oss_pdec_vap_kmstrp)
#define _oss_pdec_pad_kmstr      (*_g->ft.perTbl->_oss_pdec_pad_kmstrp)
#define _oss_pdec_pad_kmstr_ptr  (*_g->ft.perTbl->_oss_pdec_pad_kmstr_ptrp)
#define _oss_pdec_binreal        (*_g->ft.perTbl->_oss_pdec_binrealp)
#define _oss_pdec_eap            (*_g->ft.perTbl->_oss_pdec_eapp)
#define _oss_pdec_eas            (*_g->ft.perTbl->_oss_pdec_easp)
#define _oss_pdec_chrreal        (*_g->ft.perTbl->_oss_pdec_chrrealp)
#define _oss_pdec_enum           (*_g->ft.perTbl->_oss_pdec_enump)
#define _oss_pdec_indeflen_int   (*_g->ft.perTbl->_oss_pdec_indeflen_intp)
#define _oss_penc_indeflen_int   (*_g->ft.perTbl->_oss_penc_indeflen_intp)
#define _oss_pdec_bmpstr         (*_g->ft.perTbl->_oss_pdec_bmpstrp)
#define _oss_pdec_creal          (*_g->ft.perTbl->_oss_pdec_crealp)
#define _oss_pdec_mreal          (*_g->ft.perTbl->_oss_pdec_mrealp)
#define _oss_penc_mreal          (*_g->ft.perTbl->_oss_penc_mrealp)
#define _oss_pdec_length         (*_g->ft.perTbl->_oss_pdec_lengthp)
#define _oss_pdec_pop            (*_g->ft.perTbl->_oss_pdec_popp)
#define _oss_pdec_push           (*_g->ft.perTbl->_oss_pdec_pushp)
#define _oss_pdec_uany           (*_g->ft.perTbl->_oss_pdec_uanyp)
#define _oss_penc_uany           (*_g->ft.perTbl->_oss_penc_uanyp)
#define _oss_pdec_unistr         (*_g->ft.perTbl->_oss_pdec_unistrp)
#define _oss_penc_unistr         (*_g->ft.perTbl->_oss_penc_unistrp)
#define _oss_pdec_semicon_int    (*_g->ft.perTbl->_oss_pdec_semicon_intp)
#define _oss_penc_semicon_int    (*_g->ft.perTbl->_oss_penc_semicon_intp)
#define _oss_pdec_semicon_uint   (*_g->ft.perTbl->_oss_pdec_semicon_uintp)
#define _oss_penc_semicon_uint   (*_g->ft.perTbl->_oss_penc_semicon_uintp)
#define _oss_pdec_small_int      (*_g->ft.perTbl->_oss_pdec_small_intp)
#define _oss_penc_small_int      (*_g->ft.perTbl->_oss_penc_small_intp)
#define _oss_pdec_small_len      (*_g->ft.perTbl->_oss_pdec_small_lenp)
#define _oss_penc_small_len      (*_g->ft.perTbl->_oss_penc_small_lenp)
#define _oss_pdec_subid          (*_g->ft.perTbl->_oss_pdec_subidp)
#define _oss_penc_subid          (*_g->ft.perTbl->_oss_penc_subidp)
#define _oss_pdec_ub_nkmstr      (*_g->ft.perTbl->_oss_pdec_ub_nkmstrp)
#define _oss_pdec_unconstr_bpbit (*_g->ft.perTbl->_oss_pdec_unconstr_bpbitp)
#define _oss_pdec_unconstr_pbit  (*_g->ft.perTbl->_oss_pdec_unconstr_pbitp)
#define _oss_penc_unconstr_pbit  (*_g->ft.perTbl->_oss_penc_unconstr_pbitp)
#define _oss_pdec_unconstr_huge  (*_g->ft.perTbl->_oss_pdec_unconstr_hugep)
#define _oss_penc_unconstr_huge  (*_g->ft.perTbl->_oss_penc_unconstr_hugep)
#define _oss_pdec_vap_nkmstr     (*_g->ft.perTbl->_oss_pdec_vap_nkmstrp)
#define _oss_pdec_va_nkmstr      (*_g->ft.perTbl->_oss_pdec_va_nkmstrp)
#define _oss_penc_constr_bpbit   (*_g->ft.perTbl->_oss_penc_constr_bpbitp)
#define _oss_penc_constr_pbit    (*_g->ft.perTbl->_oss_penc_constr_pbitp)
#define _oss_penc_creal          (*_g->ft.perTbl->_oss_penc_crealp)
#define _oss_penc_enum           (*_g->ft.perTbl->_oss_penc_enump)
#define _oss_pop_global          (*_g->ft.perTbl->_oss_pop_globalp)
#define _oss_push_global         (*_g->ft.perTbl->_oss_push_globalp)
#define _oss_get_octet           (*_g->ft.perTbl->_oss_get_octetp)
#define _oss_penc_eobjid         (*_g->ft.perTbl->_oss_penc_eobjidp)
#define _oss_pdec_eobjid         (*_g->ft.perTbl->_oss_pdec_eobjidp)
#define _oss_penc_semicon_huge   (*_g->ft.perTbl->_oss_penc_semicon_hugep)
#define _oss_pdec_semicon_huge   (*_g->ft.perTbl->_oss_pdec_semicon_hugep)
#define _oss_pdec_sot            (*_g->ft.perTbl->_oss_pdec_sot)
#undef _oss_enc_error
#undef _oss_free_creal
#define _oss_enc_error           (*_g->ft.perTbl->_oss_enc_errorp)
#define _oss_free_creal          (*_g->ft.perTbl->_oss_free_crealp)
#endif /* _DLL || OS2_DLL || (_WINDOWS && !_WIN32) */

#endif /* ossper_hdr_file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\ossmmgmt.h ===
/*****************************************************************************/
/* Copyright (C) 1991-1999 Open Systems Solutions, Inc.  All rights reserved.*/
/*****************************************************************************/

/* THIS FILE IS PROPRIETARY MATERIAL OF OPEN SYSTEMS SOLUTIONS, INC.
 * AND MAY ONLY BE USED BY DIRECT LICENSEES OF OPEN SYSTEMS SOLUTIONS, INC.
 * THIS FILE MAY NOT BE DISTRIBUTED. */

/*************************************************************************/
/* FILE: @(#)ossmmgmt.h	5.8.1.2  97/10/20       */
/*************************************************************************/

#if _MSC_VER > 1000
#pragma once
#endif

#include <stddef.h>
#include "ossdll.h"


enum errcode {
    moreInput,          /* input is exhausted and more was requested;
			   context indicates number of bytes requested */
			/* decode returns MORE_INPUT (not a negative
			   error code) */
    moreOutput,         /* requests for output exceed restraint
			   or space provided by user buffer;
			   context indicates bytes allocated so far
			   plus amount requested */
			/* decode returns MORE_BUF */
    zeroBytesRequested, /* memory request for zero bytes.
			   This should not happen; report error to OSS;
			   context ignored */
			/* decode returns FATAL_ERROR */
    sizeTooBig,         /* request to allocate more than 'ossblock' bytes;
			   context indicates number of bytes requested;
			   This should not happen; report error to OSS */
			/* decode returns FATAL_ERROR */
    outOfMemory,        /* memory allocation failure; context indicates
			   number of bytes requested */
			/* decode returns OUT_MEMORY */
    invalidObject,      /* unrecognized memory object passed in argument
			   to function; context 0 means object not recognized,
			   1 means control information within object is flawed */
			/* decode returns FATAL_ERROR */
#ifdef LEAN_STACK
    moreStack,          /* requests for stack storage exceed
			   space provided by user buffer;
			   context indicates bytes allocated so far
			   plus amount requested */
			/* decode returns MORE_BUF */
    hookedStack,        /* request for stack storage cannot be
			   served in the parent context (world) when
			   user-provided buffer is used by the child
			   context */
			/* decode returns MEM_ERROR */
#endif
    memmgrUndefinedErr  /* error OSS has not anticipated; e.g., I/O Error;
			   handlerr prints context.
			   (I cannot print context as a hex value
			   with the current error message code <---) */
			/* decode returns FATAL_ERROR */
};

extern void     handlerr(struct ossGlobal *, enum errcode err, unsigned long context);
extern int      DLL_ENTRY dpduWalk(struct ossGlobal *, int, void *, void *,
			void (DLL_ENTRY_FPTR *_System freer)(struct ossGlobal *, void *));
#if defined(_WINDOWS) || defined(_WIN32) || \
    defined(__OS2__)  || defined(NETWARE_DLL)
extern void     DLL_ENTRY ossFreer(void *, void *);
#else
#ifndef _ICC
static void     DLL_ENTRY freer(struct ossGlobal *, void *);
#endif /* _ICC */
#endif /* _WINDOWS || _WIN32 || __OS2__ || NETWARE_DLL */

int             DLL_ENTRY ossMemMgrId(struct ossGlobal *);

unsigned char  *DLL_ENTRY dopenIn(struct ossGlobal *, void **p_hdl, unsigned long *inlen);
unsigned long   DLL_ENTRY dclosIn(struct ossGlobal *, void **p_hdl, size_t bytes_decoded);
unsigned char  *DLL_ENTRY dswapIn(struct ossGlobal *, void **p_hdl, size_t *inlen);
void            DLL_ENTRY dopenOut(struct ossGlobal *, void *hdl, unsigned long length,
                        unsigned long limit);
unsigned long   DLL_ENTRY dclosOut(struct ossGlobal *, void **p_hdl);
void           *DLL_ENTRY dallcOut(struct ossGlobal *, size_t size, char root);
#ifdef LEAN_STACK
void  	        DLL_ENTRY_FDEF openStack(struct ossGlobal *world, OssBuf *stack);
void  	        DLL_ENTRY_FDEF hookStack(struct ossGlobal *world, struct ossGlobal *root);
void  	        DLL_ENTRY_FDEF unhookStack(struct ossGlobal *world, struct ossGlobal *root);
void           *DLL_ENTRY_FDEF allocStack(struct ossGlobal *world, size_t size);
unsigned char  *DLL_ENTRY_FDEF lockStack(struct ossGlobal *world, void *hdl);
void  	        DLL_ENTRY_FDEF freeStack(struct ossGlobal *world, void *hdl);
void  		DLL_ENTRY_FDEF closeStack(struct ossGlobal *world);
#endif /* LEAN_STACK */
void            DLL_ENTRY openWork(struct ossGlobal *);
void            DLL_ENTRY closWork(struct ossGlobal *);
void           *DLL_ENTRY allcWork(struct ossGlobal *, size_t size);
unsigned char  *DLL_ENTRY lockMem(struct ossGlobal *, void *hdl);
void            DLL_ENTRY unlokMem(struct ossGlobal *, void *hdl, char free);
void            DLL_ENTRY pushHndl(struct ossGlobal *, void *);
unsigned char  *DLL_ENTRY popHndl(struct ossGlobal *, void **handl, size_t length);
void            DLL_ENTRY drcovObj(struct ossGlobal *, int pdu_num, void * hdl, void *ctl_tbl);

unsigned char  *DLL_ENTRY eopenIn(struct ossGlobal *, void *lock, size_t length);	/* Clear encoder input-memory resources */
unsigned char  *DLL_ENTRY eswapIn(struct ossGlobal *, void *unlock, void *lock, size_t length);	/* Swap new data into input memory */
void            DLL_ENTRY eclosIn(struct ossGlobal *, void * unlock); /* Free encoder input-memory resources */

unsigned char  *DLL_ENTRY eopenOut(struct ossGlobal *, void **object, size_t *outlen, char queue);   /* Clear encoder output-memory resources */
unsigned char  *DLL_ENTRY eswapOut(struct ossGlobal *, void **object, size_t used, size_t *outlen);  /* Dispose of output data and get memory */
unsigned char  *DLL_ENTRY exferObj(struct ossGlobal *, void **, void **, unsigned long *, unsigned long);
unsigned char  *DLL_ENTRY dxferObj(struct ossGlobal *world, void **inn, void **out, size_t *tOffset, unsigned long *toLength);
unsigned char  *DLL_ENTRY asideBegin(struct ossGlobal *world, void **objectTo, size_t used, size_t *lengthTo);
unsigned char  *DLL_ENTRY asideSwap(struct ossGlobal *world, void **objectTo, size_t used, size_t *lengthTo);
void           *DLL_ENTRY asideEnd(struct ossGlobal *world, void *object, size_t used);
unsigned char  *DLL_ENTRY setDump(struct ossGlobal *world, void **objectTo, void *set, size_t *lengthTo);
unsigned long   DLL_ENTRY eclosOut(struct ossGlobal *, void **object, size_t used, char low);        /* Free encoder output-memory resources */
void            DLL_ENTRY ercovObj(struct ossGlobal *);	/* Free all encoder memory resources */
void            DLL_ENTRY ossSetSort(struct ossGlobal *, void *, unsigned char ct);	/* Order set by comparing through "ossObjCmp" */
unsigned char   DLL_ENTRY egetByte(struct ossGlobal *world, void *inn, unsigned long offset);
extern int      DLL_ENTRY ossMinit(struct ossGlobal *world);
extern void     DLL_ENTRY ossMterm(struct ossGlobal *world);
void           *DLL_ENTRY _ossMarkObj(struct ossGlobal *world, OssObjType objType, void *object);
void           *DLL_ENTRY _ossUnmarkObj(struct ossGlobal *world, void *objHndl);
void           *DLL_ENTRY _ossGetObj(struct ossGlobal *world, void *objHndl);
#if defined(__arm)
OssObjType      DLL_ENTRY _ossTestObj(struct ossGlobal *world, void *objHndl);
#else
void           *DLL_ENTRY _ossTestObj(struct ossGlobal *world, void *objHndl);
#endif /* __arm */
void            DLL_ENTRY _ossFreeObjectStack(struct ossGlobal *world);
void            DLL_ENTRY _ossSetTimeout(struct ossGlobal *world, long timeout);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\ossber.h ===
/*****************************************************************************/
/* Copyright (C) 1989-1999 Open Systems Solutions, Inc.  All rights reserved.*/
/*****************************************************************************/

/* THIS FILE IS PROPRIETARY MATERIAL OF OPEN SYSTEMS SOLUTIONS, INC.
 * AND MAY BE USED ONLY BY DIRECT LICENSEES OF OPEN SYSTEMS SOLUTIONS, INC.
 * THIS FILE MAY NOT BE DISTRIBUTED. */

/**************************************************************************/
/*
 * FILE: @(#)coderror.h	5.16.1.1  97/10/20
# @(#)errindex.sh	1.5 94/06/22
 */
/* FILE: @(#)ossber.hh	5.32  97/06/17				  */
/*							 		  */
/* function: Define the interfaces to the routines in ossber.a for the    */
/* OSS optimized encoder and decoder.					  */
/*									  */
/*									  */
/* changes:								  */
/*	06/28/90  pet	created 					  */
/*									  */
/**************************************************************************/

#ifndef ossber_hdr_file
#define ossber_hdr_file

#if _MSC_VER > 1000
#pragma once
#endif

#include <setjmp.h>
#include "asn1hdr.h"

#if defined(_MSC_VER) && (defined(_WIN32) || defined(WIN32))
#pragma pack(push, ossPacking, 4)
#elif defined(_MSC_VER) && (defined(_WINDOWS) || defined(_MSDOS))
#pragma pack(1)
#elif defined(__BORLANDC__) && defined(__MSDOS__)
#ifdef _BC31
#pragma option -a-
#else
#pragma option -a1
#endif /* _BC31 */
#elif defined(__BORLANDC__) && defined(__WIN32__)
#pragma option -a4
#elif defined(__IBMC__)
#pragma pack(4)
#elif defined(__WATCOMC__) && defined(__NT__)
#pragma pack(push, 4)
#elif defined(__WATCOMC__) && (defined(__WINDOWS__) || defined(__DOS__))
#pragma pack(push, 1)
#endif /* _MSC_VER && _WIN32 */

#ifdef macintosh
#pragma options align=mac68k
#endif

#define _dstd_parms_def char **_pos, long *_buf_len, long _length
#define _dstd_parms _pos, _buf_len, _length
#define _sdstd_parms_def char **_pos, long *_buf_len
#define _sdstd_parms _pos, _buf_len

#define _std_parms_def char **_pos, long *_max_len, _Bool _userbuf
#define _std_parms _pos, _max_len, _userbuf

#ifndef OSS_BOOL
#define OSS_BOOL
typedef char    _Bool;
#endif

#ifdef __cplusplus
extern "C"
{
#endif

/* Entry Points for the Interface Routines */

#ifndef _OSSNOANSI

typedef    int       (DLL_ENTRY_FPTR *_System _Encode_function)(struct ossGlobal *world, int pdunum,
	                void *inbuf, char **outbuf, long *outlen,
	                void *ctl_tbl, unsigned flags,
	                char errmsg[]);

typedef    int       (DLL_ENTRY_FPTR *_System _Decode_function)(struct ossGlobal *world, int *pduNum,
	                char **inbuf, long *inlen, void **outbuf,
	                long *outlen, void *ctl_tbl, unsigned flags,
	                char errmsg[]);

typedef    int       (DLL_ENTRY_FPTR *_System _FreePDU_function)(struct ossGlobal *world, int pdunum,
                        void *data, void *ctl_tbl);

typedef    void      (DLL_ENTRY_FPTR *_System _Ossinit_function)(struct ossGlobal *);

#else

typedef    int       (*_Encode_function)();

typedef    int       (*_Decode_function)();

typedef    int       (*_FreePDU_function)();

typedef    void      (*_Ossinit_function)();

#endif /* _OSSNOANSI */


typedef struct _entry_point_struct_ {
	_Ossinit_function	_ossinit_function;
	_Encode_function        _ber_encode_function;
	_Decode_function        _ber_decode_function;
	_FreePDU_function	_freePDU_function;
	unsigned short int      _oss_ber_version_number;
	_Encode_function        _per_encode_function;
	_Decode_function        _per_decode_function;
	unsigned short int      _oss_per_version_number;
	unsigned int            _oss_pa_count;
	struct _char_data       *_chars_ptr;
}               _entry_point_struct;





/* Error Handling */


/* The index to the error messages.  NOTE:  The enumerated constants here
   must match those in coderror.h. */

enum _err_index {
_no_msg , _small_buffer , _type_not_impl , _pdu_range ,
_bad_argument , _version_mismatch_toed , _version_mismatch_soed ,
_out_stor , _bad_choice , _stor_error , _int_too_long ,
_uint_too_long , _bit_str_comp , _access_serialization ,
_constrainedBy , _singleValue_integer , _singleValue_uinteger ,
_singleValue_real , _singleValue_string , _singleValue_void ,
_valueRange_integer , _valueRange_uinteger , _valueRange_real ,
_sizeConstraint_length , _sizeConstraint_number , _oPA_constraint
, _absence_constraint , _presence_constraint , _openType_error ,
_tableConstraint , _componentRelation , _not_enumerated ,
_null_tbl , _null_fcn , _corrupted_tbl , _neg_uinteger ,
_typeConstraint , _bit_str_too_long , _pdu_range_recursive ,
_enc_oid_too_long , _more_input , _more_output ,
_zero_bytes_requested , _size_too_big , _out_of_memory ,
_invalid_object , _memmgr_undefined_err , _bad_encrules_err ,
_toed_rules_not_impl_err , _unlinked_encrules_err ,
_table_mismatch , _type_not_supported ,
_type_not_supported_decreal , _real_dll_failed ,
_indef_length_not_supported , _cstrain_dll_failed ,
_cmp_dll_failed , _cmp_code_not_linked , _real_code_not_linked ,
_pdv_code_not_linked , _pdv_dll_failed , _oid_dll_failed ,
_type_not_supported_der_toed , _toed_rules_not_supp_err ,
_bad_objid , _bad_pointer , _bad_time , _bad_der_time , _too_long
, _toom_field , _mandatory_field , _zero_length_ANY ,
_zero_length_OpenType , _inval_dec_real , _inval_mixed_real ,
_tag_long_nec , _tag_too_long , _exp_long_nec , _exp_too_long ,
_int_long_nec , _subid_long_nec , _subid_too_long ,
_length_too_long , _size_too_long , _non_std_eoc , _unknown_size
, _inconsis_len , _tag_mismatch , _pdu_mismatch , _extra_bits ,
_inval_enc , _no_dec_dig , _no_exp_dig , _inval_nr1 , _inval_nr2
, _inval_nr3 , _real_long_zero , _undef_enc , _truncate ,
_null_in_nlltrm , _unknown_field , _field_repeat , _field_omit ,
_expec_eoc , _indef_len_prim , _expec_constr_fnd_prim ,
_expec_prim_fnd_constr , _unknown_type , _end_of_input ,
_cannot_happen , _neg_not_allowed , _expect_tag , _more_value ,
_real_too_large , _too_many_subids , _too_many_optional_fields ,
_too_many_ext_additions , _indef_length_der , _hindmost_error
};



/* typedef's for the context information */

typedef enum _context_type {
    _boolean_type, _integer_type, _enumerated_type, _real_type,
    _bitstring_type, _octetstring_type, _null_type, _sequence_type,
    _sequence_of_type, _set_type, _set_of_type, _choice_type,
    _charstring_type, _object_identifier_type, _time_type, _any_type,
    _opentype
}               _Context_Type;

typedef struct _context_id {
    char           *_element_name;
    char           *_element_type;
    _Context_Type   _type;
}               _Context_Id;


typedef struct _context_element {
    struct _context_element *_parent;
    _Context_Id    *_id;
    long            _occurrence;/* For SET OF or SEQUENCE OF */
}               _Context_Element;

typedef enum _context_state {
    _encoding_tag, _encoding_length, _encoding_data,
    _decoding_tag, _decoding_length, _decoding_data
}               _Context_State;

typedef struct _context_anchor {
    _Context_Element *_last;
    int             _pdu_number;
    _Context_Id    *_pdu_id;
    _Context_State  _state;
}               _Context_Anchor;

typedef  char _Per_Inverted_Index[128];


extern _Context_Anchor _oss_context_anchor;

/* The error routines */

#ifndef _OSSNOANSI

extern void DLL_ENTRY _oss_enc_error(struct ossGlobal *g, _Bool _jump,
                               enum _err_index _error_code, long _data);

#else

extern void     _oss_enc_error();

#endif /* _OSSNOANSI */


#define _oss_dec_error _oss_enc_error



#ifndef _OSSNOANSI

/* Encode Routines */

extern long DLL_ENTRY _oss_encd_length(struct ossGlobal *g, _std_parms_def,
                                 unsigned long _data);
extern void DLL_ENTRY _oss_enci_length(struct ossGlobal *g, _std_parms_def,
                                 unsigned long _data);
extern long DLL_ENTRY _oss_encd_tag(struct ossGlobal *g, _std_parms_def,
                              unsigned short _data, _Bool _constructed);
extern void DLL_ENTRY _oss_enci_tag(struct ossGlobal *g, _std_parms_def,
                              unsigned short _data, _Bool _constructed);
extern long DLL_ENTRY _oss_encd_bool(struct ossGlobal *g, _std_parms_def,
                               ossBoolean _data);
extern void DLL_ENTRY _oss_enci_bool(struct ossGlobal *g, _std_parms_def,
                               ossBoolean _data);
extern long DLL_ENTRY _oss_encd_int(struct ossGlobal *g, _std_parms_def,
				LONG_LONG _data);
extern void DLL_ENTRY _oss_enci_int(struct ossGlobal *g, _std_parms_def,
				LONG_LONG _data);
extern long DLL_ENTRY _oss_encd_uint(struct ossGlobal *g, _std_parms_def,
				ULONG_LONG _data);
extern void DLL_ENTRY _oss_enci_uint(struct ossGlobal *g, _std_parms_def,
				ULONG_LONG _data);
extern long DLL_ENTRY _oss_encd_huge_int(struct ossGlobal *g, _std_parms_def,
			       void *_data);
extern long DLL_ENTRY _oss_encd_uhuge_int(struct ossGlobal *g, _std_parms_def,
			       void *_data);
extern long DLL_ENTRY _oss_encd_real(struct ossGlobal *g, _std_parms_def,
                               double _data);
extern long DLL_ENTRY _oss_encd_creal(struct ossGlobal *g, _std_parms_def,
			       char *_data);
extern long DLL_ENTRY _oss_encd_mreal(struct ossGlobal *g, _std_parms_def,
			       MixedReal *_data);
extern void DLL_ENTRY _oss_enci_real(struct ossGlobal *g, _std_parms_def,
                               double _data);
extern void DLL_ENTRY _oss_enci_creal(struct ossGlobal *g, _std_parms_def,
			       char *_data);
extern void DLL_ENTRY _oss_enci_mreal(struct ossGlobal *g, _std_parms_def,
			       MixedReal *_data);
extern long DLL_ENTRY _oss_encd_alobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, short _array_size);
extern long DLL_ENTRY _oss_encd_asobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, short _array_size);
extern long DLL_ENTRY _oss_encd_aiobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, short _array_size);
extern void DLL_ENTRY _oss_enci_alobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, short _array_size);
extern void DLL_ENTRY _oss_enci_asobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, short _array_size);
extern void DLL_ENTRY _oss_enci_aiobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, short _array_size);
extern long DLL_ENTRY _oss_encd_llobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, long _size_c);
extern long DLL_ENTRY _oss_encd_lsobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, long _size_c);
extern long DLL_ENTRY _oss_encd_liobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, long _size_c);
extern void DLL_ENTRY _oss_enci_llobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, long _size_c);
extern void DLL_ENTRY _oss_enci_lsobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, long _size_c);
extern void DLL_ENTRY _oss_enci_liobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, long _size_c);
extern long DLL_ENTRY _oss_encd_ulobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, long _size_c);
extern long DLL_ENTRY _oss_encd_usobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, long _size_c);
extern long DLL_ENTRY _oss_encd_uiobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, long _size_c);
extern void DLL_ENTRY _oss_enci_ulobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, long _size_c);
extern void DLL_ENTRY _oss_enci_usobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, long _size_c);
extern void DLL_ENTRY _oss_enci_uiobjid(struct ossGlobal *g, _std_parms_def,
                                  void *_data, long _size_c);
extern long DLL_ENTRY _oss_encd_pbit(struct ossGlobal *g, _std_parms_def,
                               void *_data, long _bit_count);
extern void DLL_ENTRY _oss_enci_pbit(struct ossGlobal *g, _std_parms_def,
                               void *_data, long _bit_count);
extern long DLL_ENTRY _oss_encd_ubit(struct ossGlobal *g, _std_parms_def,
                               void *_data, char _lengthsize, long _size_c);
extern void DLL_ENTRY _oss_enci_ubit(struct ossGlobal *g, _std_parms_def,
                               void *_data, char _lengthsize, long _size_c);
extern long DLL_ENTRY _oss_encd_vbit(struct ossGlobal *g, _std_parms_def,
                               void *_data, long _array_size,
                               char _lengthsize);
extern void DLL_ENTRY _oss_enci_vbit(struct ossGlobal *g, _std_parms_def,
                               void *_data, long _array_size,
                               char _lengthsize);
extern long DLL_ENTRY _oss_encd_nstr(struct ossGlobal *g, _std_parms_def,
                               char *_data, long _size_c);
extern void DLL_ENTRY _oss_enci_nstr(struct ossGlobal *g, _std_parms_def,
                               char *_data, long _size_c);
extern long DLL_ENTRY _oss_encd_pstr(struct ossGlobal *g, _std_parms_def,
                               char *_data, long _byte_count);
extern void DLL_ENTRY _oss_enci_pstr(struct ossGlobal *g, _std_parms_def,
                               char *_data, long _byte_count);
extern long DLL_ENTRY _oss_encd_ustr(struct ossGlobal *g, _std_parms_def,
                               void *_data, char _lengthsize, long _size_c);
extern void DLL_ENTRY _oss_enci_ustr(struct ossGlobal *g, _std_parms_def,
                               void *_data, char _lengthsize, long _size_c);
extern long DLL_ENTRY _oss_encd_vstr(struct ossGlobal *g, _std_parms_def,
                               void *_data, char _lengthsize, long _size_c);
extern void DLL_ENTRY _oss_enci_vstr(struct ossGlobal *g, _std_parms_def,
                               void *_data, char _lengthsize, long _size_c);
extern long DLL_ENTRY _oss_encd_uoct(struct ossGlobal *g, _std_parms_def,
                               void *_data, char _lengthsize, long _size_c);
extern void DLL_ENTRY _oss_enci_uoct(struct ossGlobal *g, _std_parms_def,
                               void *_data, char _lengthsize, long _size_c);
extern long DLL_ENTRY _oss_encd_voct(struct ossGlobal *g, _std_parms_def,
                               void *_data, char _lengthsize, long _size_c);
extern void DLL_ENTRY _oss_enci_voct(struct ossGlobal *g, _std_parms_def,
                               void *_data, char _lengthsize, long _size_c);
extern long DLL_ENTRY _oss_encd_gtime(struct ossGlobal *g, _std_parms_def,
                                GeneralizedTime*_data);
extern void DLL_ENTRY _oss_enci_gtime(struct ossGlobal *g, _std_parms_def,
                                GeneralizedTime *_data);
extern long DLL_ENTRY _oss_encd_utime(struct ossGlobal *g, _std_parms_def,
                                UTCTime *_data);
extern void DLL_ENTRY _oss_enci_utime(struct ossGlobal *g, _std_parms_def,
                                UTCTime *_data);
extern long DLL_ENTRY _oss_encd_uany(struct ossGlobal *g, _std_parms_def,
                               void *_data);
extern void DLL_ENTRY _oss_enci_uany(struct ossGlobal *g, _std_parms_def,
                               void *_data);
extern long DLL_ENTRY _oss_encd_opentype(struct ossGlobal *g, _std_parms_def,
                               void *_data);
extern void DLL_ENTRY _oss_enci_opentype(struct ossGlobal *g, _std_parms_def,
                               void *_data);
extern long DLL_ENTRY _oss_encd_bmpstr(struct ossGlobal *g, _std_parms_def,
                    void *data, char lengthsize,
		    long size_c);
extern long DLL_ENTRY _oss_enci_bmpstr(struct ossGlobal *g, _std_parms_def,
                    void *data, char lengthsize,
		    long size_c);
extern long DLL_ENTRY _oss_encd_unistr(struct ossGlobal *g, _std_parms_def,
                    void *data, char lengthsize,
		    long size_c);
extern long DLL_ENTRY _oss_enci_unistr(struct ossGlobal *g, _std_parms_def,
                    void *data, char lengthsize,
		    long size_c);

extern long DLL_ENTRY _oss_encd_eobjid(struct ossGlobal *g, _std_parms_def,
				  void *data, long size_c);

extern long DLL_ENTRY _oss_encd_dubit(struct ossGlobal *g, _std_parms_def,
		  void *data, char lengthsize, long size_c, _Bool named_bits);

extern long DLL_ENTRY _oss_encd_dvbit(struct ossGlobal *g, _std_parms_def,
		    void *data, long array_size,
		  char lengthsize, _Bool named_bits);


/* Decode Routines */
/* these return values */
extern void DLL_ENTRY _oss_dec_tag(struct ossGlobal *g, _sdstd_parms_def,
                             unsigned short *tag, _Bool *con);
extern long DLL_ENTRY _oss_dec_length(struct ossGlobal *g, _sdstd_parms_def);


extern ossBoolean DLL_ENTRY _oss_dec_bool(struct ossGlobal *g, _dstd_parms_def);
extern LONG_LONG DLL_ENTRY _oss_dec_llint(struct ossGlobal *g, _dstd_parms_def);
extern long DLL_ENTRY _oss_dec_lint(struct ossGlobal *g, _dstd_parms_def);
extern int  DLL_ENTRY _oss_dec_iint(struct ossGlobal *g, _dstd_parms_def);
extern short DLL_ENTRY _oss_dec_sint(struct ossGlobal *g, _dstd_parms_def);
extern void DLL_ENTRY _oss_dec_hint(struct ossGlobal *g, _dstd_parms_def,
				_Bool userbuf, void *data);
extern ULONG_LONG DLL_ENTRY _oss_dec_ullint(struct ossGlobal *g, _dstd_parms_def);
extern unsigned long DLL_ENTRY _oss_dec_ulint(struct ossGlobal *g, _dstd_parms_def);
extern unsigned int DLL_ENTRY _oss_dec_uiint(struct ossGlobal *g, _dstd_parms_def);
extern unsigned short DLL_ENTRY _oss_dec_usint(struct ossGlobal *g, _dstd_parms_def);

/* The code for this one is so huge that it would be criminal to
 * repeat it three times.  Caller should cast the returned value
 * to what she wants.
 */
extern void DLL_ENTRY _oss_dec_real(struct ossGlobal *g, _dstd_parms_def,
				double *data);
extern void DLL_ENTRY _oss_dec_freal(struct ossGlobal *g, _dstd_parms_def,
				float *data);
extern void DLL_ENTRY _oss_dec_creal(struct ossGlobal *g, _dstd_parms_def,
				  _Bool _userbuf, char **_data);
extern void DLL_ENTRY _oss_dec_mreal(struct ossGlobal *g, _dstd_parms_def,
				  _Bool _userbuf, MixedReal *_data);

/* Two versions of these functions.  If the type has the pointer
 * directive, then its size is not fixed--the function will allocate
 * the memory.  Otherwise the caller allocates the memory.  (Actually,
 * the type will probably be enclosed in another type, and therefore
 * the memory has already been allocated.)
 */
extern void DLL_ENTRY _oss_dec_alobjid_ptr(struct ossGlobal *g, _dstd_parms_def,
                                     _Bool _userbuf, void **_data,
                                     short _array_size);
extern void DLL_ENTRY _oss_dec_alobjid(struct ossGlobal *g, _dstd_parms_def,
                                 void *_data, short _array_size);

extern void DLL_ENTRY _oss_dec_aiobjid_ptr(struct ossGlobal *g, _dstd_parms_def,
                                     _Bool _userbuf, void **_data,
                                     short _array_size);
extern void DLL_ENTRY _oss_dec_aiobjid(struct ossGlobal *g, _dstd_parms_def,
                                 void *_data, short _array_size);

extern void DLL_ENTRY _oss_dec_asobjid_ptr(struct ossGlobal *g, _dstd_parms_def,
                                     _Bool _userbuf, void **_data,
                                     short _array_size);
extern void DLL_ENTRY _oss_dec_asobjid(struct ossGlobal *g, _dstd_parms_def,
                                 void *_data, short _array_size);

/* These allocate all their own memory.  */
extern void DLL_ENTRY _oss_dec_llobjid(struct ossGlobal *g, _dstd_parms_def,
                                 _Bool _userbuf, void **_data, long _size_c);
extern void DLL_ENTRY _oss_dec_liobjid(struct ossGlobal *g, _dstd_parms_def,
                                 _Bool _userbuf, void **_data, long _size_c);
extern void DLL_ENTRY _oss_dec_lsobjid(struct ossGlobal *g, _dstd_parms_def,
                                 _Bool _userbuf, void **_data, long _size_c);

/*  These are passed the structure containing the count, but allocate
  *  space for the data itself. */
extern void DLL_ENTRY _oss_dec_ulobjid(struct ossGlobal *g, _dstd_parms_def,
                                 _Bool _userbuf, void *_data, short _size_c);
extern void DLL_ENTRY _oss_dec_uiobjid(struct ossGlobal *g, _dstd_parms_def,
                                 _Bool _userbuf, void *_data, short _size_c);
extern void DLL_ENTRY _oss_dec_usobjid(struct ossGlobal *g, _dstd_parms_def,
                                 _Bool _userbuf, void *_data, short _size_c);

/* Caller allocates memory for this one.  Call for both e_pad & e_big_pad. */
extern void DLL_ENTRY _oss_dec_pbit(struct ossGlobal *g, _dstd_parms_def,
                              void *_data, unsigned long _bit_count,
                              _Bool _cons, _Bool _named_bits);

/* See comment before dec_ulobjid. */
extern void DLL_ENTRY _oss_dec_ubit(struct ossGlobal *g, _dstd_parms_def,
                              _Bool _userbuf, void *_data,
                              char _lengthsize, long _size_c, _Bool _cons);

/* Two versions of this one too.  */
extern void DLL_ENTRY _oss_dec_vbit_ptr(struct ossGlobal *g, _dstd_parms_def,
                                  _Bool _userbuf, void **_data,
                                  long _array_size, char _lengthsize,
                                  _Bool _cons);
extern void DLL_ENTRY _oss_dec_vbit(struct ossGlobal *g, _dstd_parms_def,
                              void *_data, long _array_size,
                              char _lengthsize, _Bool _cons);

extern void DLL_ENTRY _oss_dec_nstr_ptr(struct ossGlobal *g, _dstd_parms_def,
                                  _Bool _userbuf, char **_data, long _size_c,
                                  _Bool _cons);
extern void DLL_ENTRY _oss_dec_nstr(struct ossGlobal *g, _dstd_parms_def,
                              char *_data, long _size_c, _Bool _cons);

extern void DLL_ENTRY _oss_dec_pstr(struct ossGlobal *g, _dstd_parms_def,
                              char *_data, long _byte_count, _Bool _cons);
extern void DLL_ENTRY _oss_dec_ustr(struct ossGlobal *g, _dstd_parms_def,
                              _Bool _userbuf, void *_data,
                              char _lengthsize, long _size_c, _Bool _cons);

extern void DLL_ENTRY _oss_dec_vstr_ptr(struct ossGlobal *g, _dstd_parms_def,
                                  _Bool _userbuf, void **_data,
                                  char _lengthsize, long _size_c, _Bool _cons);
extern void DLL_ENTRY _oss_dec_vstr(struct ossGlobal *g, _dstd_parms_def,
                              void *_data, char _lengthsize, long _array_size,
                              _Bool _cons);

extern void DLL_ENTRY _oss_dec_uoct(struct ossGlobal *g, _dstd_parms_def,
                              _Bool _userbuf, void *_data,
                              char _lengthsize, long _size_c, _Bool _cons);

extern void DLL_ENTRY _oss_dec_voct_ptr(struct ossGlobal *g, _dstd_parms_def,
                                  _Bool _userbuf, void **_data,
                                  char _lengthsize, long _size_c, _Bool _cons);
extern void DLL_ENTRY _oss_dec_voct(struct ossGlobal *g, _dstd_parms_def,
                              void *_data, char _lengthsize, long _array_size,
                              _Bool _cons);

extern void DLL_ENTRY _oss_dec_gtime(struct ossGlobal *g, _dstd_parms_def,
                               GeneralizedTime *_data);
extern void DLL_ENTRY _oss_dec_utime(struct ossGlobal *g, _dstd_parms_def,
                               UTCTime *_data);

extern void DLL_ENTRY _oss_dec_uany(struct ossGlobal *g, _dstd_parms_def,
                              _Bool _userbuf, void *_data);

extern void DLL_ENTRY _oss_dec_opentype(struct ossGlobal *g, _dstd_parms_def,
                              _Bool _userbuf, void *_data);

extern void DLL_ENTRY _oss_dec_bmpstr(struct ossGlobal *g, _dstd_parms_def,
                    _Bool userbuf, void *data,
		    char lengthsize, long size_c, _Bool cons);
extern void DLL_ENTRY _oss_dec_unistr(struct ossGlobal *g, _dstd_parms_def,
                    _Bool userbuf, void *data,
		    char lengthsize, long size_c, _Bool cons);

extern void DLL_ENTRY _oss_dec_eobjid(struct ossGlobal *g, _dstd_parms_def,
                    _Bool userbuf, void *data,
		    long size_c);

/* Other functions */

/* called to count the items for set of or sequence of. */
extern long DLL_ENTRY _oss_count_setof_items(struct ossGlobal *g, _dstd_parms_def);

/* called to skip past items for the EXTENSIBLE directive */
extern void _oss_skip_past_item(struct ossGlobal *g, _dstd_parms_def);

extern void DLL_ENTRY _oss_beginBlock(struct ossGlobal *g, long count,
    char **pos, long *max_len);

extern void DLL_ENTRY _oss_nextItem(struct ossGlobal *g, long *max_len);

extern void DLL_ENTRY _oss_endBlock(struct ossGlobal *g, char ** pos, long *max_len,
    unsigned char ct);

/* called to perform limited check for default value */
extern _Bool DLL_ENTRY _oss_not_dflt(struct ossGlobal *g, void *data, void *dflt,
   long totalsize, long max_length, int kind);

#else

/* Encode Routines */

extern long     _oss_encd_length();
extern void     _oss_enci_length();
extern long     _oss_encd_tag();
extern void     _oss_enci_tag();


extern long     _oss_encd_bool();
extern void     _oss_enci_bool();
extern long     _oss_encd_int();
extern void     _oss_enci_int();
extern long     _oss_encd_uint();
extern void     _oss_enci_uint();
extern void     _oss_encd_huge_int();
extern void     _oss_encd_uhuge_int();
extern long     _oss_encd_real();
extern void     _oss_enci_real();
extern long     _oss_encd_alobjid();
extern long     _oss_encd_asobjid();
extern long     _oss_encd_aiobjid();
extern void     _oss_enci_alobjid();
extern void     _oss_enci_asobjid();
extern void     _oss_enci_aiobjid();
extern long     _oss_encd_llobjid();
extern long     _oss_encd_lsobjid();
extern long     _oss_encd_liobjid();
extern void     _oss_enci_llobjid();
extern void     _oss_enci_lsobjid();
extern void     _oss_enci_liobjid();
extern long     _oss_encd_ulobjid();
extern long     _oss_encd_usobjid();
extern long     _oss_encd_uiobjid();
extern void     _oss_enci_ulobjid();
extern void     _oss_enci_usobjid();
extern void     _oss_enci_uiobjid();
extern long     _oss_encd_eobjid();
extern long     _oss_encd_pbit();
extern void     _oss_enci_pbit();
extern long     _oss_encd_ubit();
extern void     _oss_enci_ubit();
extern long     _oss_encd_vbit();
extern void     _oss_enci_vbit();
extern long     _oss_encd_nstr();
extern void     _oss_enci_nstr();
extern long     _oss_encd_pstr();
extern void     _oss_enci_pstr();
extern long     _oss_encd_ustr();
extern void     _oss_enci_ustr();
extern long     _oss_encd_vstr();
extern void     _oss_enci_vstr();
extern long     _oss_encd_uoct();
extern void     _oss_enci_uoct();
extern long     _oss_encd_voct();
extern void     _oss_enci_voct();
extern long     _oss_encd_gtime();
extern void     _oss_enci_gtime();
extern long     _oss_encd_utime();
extern void     _oss_enci_utime();
extern long     _oss_encd_uany();
extern void     _oss_enci_uany();
extern long     _oss_encd_opentype();
extern void     _oss_enci_opentype();
extern long     _oss_encd_bmpstr();
extern long     _oss_enci_bmpstr();
extern long     _oss_encd_unistr();
extern long     _oss_enci_unistr();

/* Decode Routines */
/* these return values */
extern void     _oss_dec_tag();
extern long     _oss_dec_length();


extern ossBoolean _oss_dec_bool();
extern long     _oss_dec_lint();
extern int      _oss_dec_iint();
extern short    _oss_dec_sint();
extern void     _oss_dec_hint();
extern unsigned long _oss_dec_ulint();
extern unsigned int _oss_dec_uiint();
extern unsigned short _oss_dec_usint();

/* The code for this one is so huge that it would be criminal to
 * repeat it three times.  Caller should cast the returned value
 * to what she wants.
 */
extern double   _oss_dec_real();

/* Two versions of these functions.  If the type has the pointer
 * directive, then its size is not fixed--the function will allocate
 * the memory.  Otherwise the caller allocates the memory.  (Actually,
 * the type will probably be enclosed in another type, and therefore
 * the memory has already been allocated.)
 */
extern void     _oss_dec_alobjid_ptr();
extern void     _oss_dec_alobjid();

extern void     _oss_dec_aiobjid_ptr();
extern void     _oss_dec_aiobjid();

extern void     _oss_dec_asobjid_ptr();
extern void     _oss_dec_asobjid();

/* These allocate all their own memory.  */
extern void     _oss_dec_llobjid();
extern void     _oss_dec_liobjid();
extern void     _oss_dec_lsobjid();

/*  These are passed the structure containing the count, but allocate
  *  space for the data itself. */
extern void     _oss_dec_ulobjid();
extern void     _oss_dec_uiobjid();
extern void     _oss_dec_usobjid();

/* Caller allocates memory for this one.  Call for both e_pad & e_big_pad. */
extern void     _oss_dec_pbit();

/* See comment before dec_ulobjid. */
extern void     _oss_dec_ubit();

/* Two versions of this one too.  */
extern void     _oss_dec_vbit_ptr();
extern void     _oss_dec_vbit();

extern void     _oss_dec_nstr_ptr();
extern void     _oss_dec_nstr();

extern void     _oss_dec_pstr();
extern void     _oss_dec_ustr();

extern void     _oss_dec_vstr_ptr();
extern void     _oss_dec_vstr();

extern void     _oss_dec_uoct();

extern void     _oss_dec_voct_ptr();
extern void     _oss_dec_voct();

extern void     _oss_dec_gtime();
extern void     _oss_dec_utime();

extern void     _oss_dec_uany();

extern void     _oss_dec_opentype();

extern void     _oss_dec_bmpstr();
extern void     _oss_dec_unistr();
extern void     _oss_dec_eobjid();


/* Other functions */

/* called to count the items for set of or sequence of. */
extern long     _oss_count_setof_items();

/* called to skip past items for the EXTENSIBLE directive */
extern void     _oss_skip_past_item();

/* called to perform limited check for default value */
extern _Bool _oss_not_dflt();

#endif /* _OSSNOANSI */

typedef struct _EncDecGlobals {

   jmp_buf	  *_oss_err_env;
#ifndef _OSSNOANSI
   void		 (*_old_sigsegv)(int);
   void		 (*_old_sigbus)(int);
#else
   void		 (*_old_sigsegv)();
   void		 (*_old_sigbus)();
#endif
   int		   _oss_asn1err;
   char		  *_oss_err_msg;
  _Bool		   _buffer_provided;
  _Bool		   _tag_decoded;
  _Bool		   _restrain_mode;
   long		   _restrain_size;
  _Context_Anchor  _oss_context_anchor;
   char		  *_oss_outbufpos;
   long		   _oss_outbuflen;
  _mem_array	   _oss_mem;
  _mem_array	  *_oss_mem_tail;
  _mem_array	  *_oss_temp_tail;
  _mem_array	   _oss_temp_mem;
   long		   _oss_mem_alloc;
   long		   _oss_out_alloc;
   unsigned int     relax_ber: 1;
   unsigned int     der: 1;
   unsigned char    man[sizeof(double)];
#if defined(_WINDOWS) || defined(_DLL) || defined(OS2_DLL)
   void (DLL_ENTRY_FPTR *_System _oss_enc_error)(struct ossGlobal *g,
			_Bool _jump, enum _err_index _error_code, long _data);
#endif /* _WINDOWS || _DLL || OS2_DLL */
   _Bool            _aligned;
    int             _bitpos;
    struct ossGlobal *_prev;
    char           *_oss_inbufpos;
    long            _oss_inbuflen;
    void           *_prevbuf;
    long             encoding_length;
    void           *_blockptr;
    struct ossGlobal *_next;
    FILE           *asn1outSaved;
    int		  (*asn1prntSaved)(FILE *stream, const char *format, ...);
} _EncDecGlobals;

#ifdef __cplusplus
}
#endif

#if defined(_MSC_VER) && (defined(_WIN32) || defined(WIN32))
#pragma pack(pop, ossPacking)
#elif defined(_MSC_VER) && (defined(_WINDOWS) || defined(_MSDOS))
#pragma pack()
#elif defined(__BORLANDC__) && (defined(__WIN32__) || defined(__MSDOS__))
#pragma option -a.
#elif defined(__IBMC__)
#pragma pack()
#elif defined(__WATCOMC__)
#pragma pack(pop)
#endif /* _MSC_VER && _WIN32 */

#ifdef macintosh
#pragma options align=reset
#endif

	/*
	 * The following macros must be #defined if you compile the ASN.1
	 * compiler generated files (.c files) and link-edit with the import
	 * library ossapit.lib, i.e the OSS DLLs ossapit.dll, apit.dll,
	 * and toedber.dll/toedper.dll are used.  The following must not
	 * be #defined if you link-edit with the static library toedcode.lib.
	 */
#if defined(_DLL) || defined(OS2_DLL) ||\
   (defined(_WINDOWS) && !defined(_WIN32))
#define _oss_count_setof_items (*_g->ft.berTbl->_oss_count_setof_itemsp)
#define _oss_dec_aiobjid       (*_g->ft.berTbl->_oss_dec_aiobjidp)
#define _oss_dec_aiobjid_ptr   (*_g->ft.berTbl->_oss_dec_aiobjid_ptrp)
#define _oss_dec_alobjid       (*_g->ft.berTbl->_oss_dec_alobjidp)
#define _oss_dec_alobjid_ptr   (*_g->ft.berTbl->_oss_dec_alobjid_ptrp)
#define _oss_dec_asobjid       (*_g->ft.berTbl->_oss_dec_asobjidp)
#define _oss_dec_asobjid_ptr   (*_g->ft.berTbl->_oss_dec_asobjid_ptrp)
#define _oss_dec_bool          (*_g->ft.berTbl->_oss_dec_boolp)
#define _oss_dec_creal         (*_g->ft.berTbl->_oss_dec_crealp)
#define _oss_dec_freal         (*_g->ft.berTbl->_oss_dec_frealp)
#define _oss_dec_getmem        (*_g->ft.apiTbl->_oss_dec_getmemp)
#define _oss_dec_gtime         (*_g->ft.berTbl->_oss_dec_gtimep)
#define _oss_dec_hint          (*_g->ft.berTbl->_oss_dec_hintp)
#define _oss_dec_iint          (*_g->ft.berTbl->_oss_dec_iintp)
#define _oss_dec_length        (*_g->ft.berTbl->_oss_dec_lengthp)
#define _oss_dec_lint          (*_g->ft.berTbl->_oss_dec_lintp)
#define _oss_dec_liobjid       (*_g->ft.berTbl->_oss_dec_liobjidp)
#define _oss_dec_llint         (*_g->ft.berTbl->_oss_dec_llintp)
#define _oss_dec_llobjid       (*_g->ft.berTbl->_oss_dec_llobjidp)
#define _oss_dec_lsobjid       (*_g->ft.berTbl->_oss_dec_lsobjidp)
#define _oss_dec_mreal         (*_g->ft.berTbl->_oss_dec_mrealp)
#define _oss_dec_nstr          (*_g->ft.berTbl->_oss_dec_nstrp)
#define _oss_dec_nstr_ptr      (*_g->ft.berTbl->_oss_dec_nstr_ptrp)
#define _oss_dec_opentype      (*_g->ft.berTbl->_oss_dec_opentypep)
#define _oss_dec_pbit          (*_g->ft.berTbl->_oss_dec_pbitp)
#define _oss_dec_pstr          (*_g->ft.berTbl->_oss_dec_pstrp)
#define _oss_dec_real          (*_g->ft.berTbl->_oss_dec_realp)
#define _oss_dec_sint          (*_g->ft.berTbl->_oss_dec_sintp)
#define _oss_dec_tag           (*_g->ft.berTbl->_oss_dec_tagp)
#define _oss_dec_uany          (*_g->ft.berTbl->_oss_dec_uanyp)
#define _oss_dec_ubit          (*_g->ft.berTbl->_oss_dec_ubitp)
#define _oss_dec_uiint         (*_g->ft.berTbl->_oss_dec_uiintp)
#define _oss_dec_uiobjid       (*_g->ft.berTbl->_oss_dec_uiobjidp)
#define _oss_dec_ulint         (*_g->ft.berTbl->_oss_dec_ulintp)
#define _oss_dec_ullint        (*_g->ft.berTbl->_oss_dec_ullintp)
#define _oss_dec_ulobjid       (*_g->ft.berTbl->_oss_dec_ulobjidp)
#define _oss_dec_uoct          (*_g->ft.berTbl->_oss_dec_uoctp)
#define _oss_dec_usint         (*_g->ft.berTbl->_oss_dec_usintp)
#define _oss_dec_usobjid       (*_g->ft.berTbl->_oss_dec_usobjidp)
#define _oss_dec_ustr          (*_g->ft.berTbl->_oss_dec_ustrp)
#define _oss_dec_utime         (*_g->ft.berTbl->_oss_dec_utimep)
#define _oss_dec_vbit          (*_g->ft.berTbl->_oss_dec_vbitp)
#define _oss_dec_vbit_ptr      (*_g->ft.berTbl->_oss_dec_vbit_ptrp)
#define _oss_dec_voct          (*_g->ft.berTbl->_oss_dec_voctp)
#define _oss_dec_voct_ptr      (*_g->ft.berTbl->_oss_dec_voct_ptrp)
#define _oss_dec_vstr          (*_g->ft.berTbl->_oss_dec_vstrp)
#define _oss_dec_vstr_ptr      (*_g->ft.berTbl->_oss_dec_vstr_ptrp)
#define _oss_enc_error         (*_g->ft.berTbl->_oss_enc_errorp)
#define _oss_enc_pop           (*_g->ft.apiTbl->_oss_enc_popp)
#define _oss_enc_push          (*_g->ft.apiTbl->_oss_enc_pushp)
#define _oss_encd_aiobjid      (*_g->ft.berTbl->_oss_encd_aiobjidp)
#define _oss_encd_alobjid      (*_g->ft.berTbl->_oss_encd_alobjidp)
#define _oss_encd_asobjid      (*_g->ft.berTbl->_oss_encd_asobjidp)
#define _oss_encd_bool         (*_g->ft.berTbl->_oss_encd_boolp)
#define _oss_encd_creal        (*_g->ft.berTbl->_oss_encd_crealp)
#define _oss_encd_gtime        (*_g->ft.berTbl->_oss_encd_gtimep)
#define _oss_encd_huge_int     (*_g->ft.berTbl->_oss_encd_huge_intp)
#define _oss_encd_uhuge_int    (*_g->ft.berTbl->_oss_encd_uhuge_intp)
#define _oss_encd_int          (*_g->ft.berTbl->_oss_encd_intp)
#define _oss_encd_length       (*_g->ft.berTbl->_oss_encd_lengthp)
#define _oss_encd_liobjid      (*_g->ft.berTbl->_oss_encd_liobjidp)
#define _oss_encd_llobjid      (*_g->ft.berTbl->_oss_encd_llobjidp)
#define _oss_encd_lsobjid      (*_g->ft.berTbl->_oss_encd_lsobjidp)
#define _oss_encd_mreal        (*_g->ft.berTbl->_oss_encd_mrealp)
#define _oss_encd_nstr         (*_g->ft.berTbl->_oss_encd_nstrp)
#define _oss_encd_opentype     (*_g->ft.berTbl->_oss_encd_opentypep)
#define _oss_encd_pbit         (*_g->ft.berTbl->_oss_encd_pbitp)
#define _oss_encd_pstr         (*_g->ft.berTbl->_oss_encd_pstrp)
#define _oss_encd_real         (*_g->ft.berTbl->_oss_encd_realp)
#define _oss_encd_tag          (*_g->ft.berTbl->_oss_encd_tagp)
#define _oss_encd_uany         (*_g->ft.berTbl->_oss_encd_uanyp)
#define _oss_encd_ubit         (*_g->ft.berTbl->_oss_encd_ubitp)
#define _oss_encd_uint         (*_g->ft.berTbl->_oss_encd_uintp)
#define _oss_encd_uiobjid      (*_g->ft.berTbl->_oss_encd_uiobjidp)
#define _oss_encd_ulobjid      (*_g->ft.berTbl->_oss_encd_ulobjidp)
#define _oss_encd_uoct         (*_g->ft.berTbl->_oss_encd_uoctp)
#define _oss_encd_usobjid      (*_g->ft.berTbl->_oss_encd_usobjidp)
#define _oss_encd_ustr         (*_g->ft.berTbl->_oss_encd_ustrp)
#define _oss_encd_utime        (*_g->ft.berTbl->_oss_encd_utimep)
#define _oss_encd_vbit         (*_g->ft.berTbl->_oss_encd_vbitp)
#define _oss_encd_voct         (*_g->ft.berTbl->_oss_encd_voctp)
#define _oss_encd_vstr         (*_g->ft.berTbl->_oss_encd_vstrp)
#define _oss_enci_aiobjid      (*_g->ft.berTbl->_oss_enci_aiobjidp)
#define _oss_enci_alobjid      (*_g->ft.berTbl->_oss_enci_alobjidp)
#define _oss_enci_asobjid      (*_g->ft.berTbl->_oss_enci_asobjidp)
#define _oss_enci_bool         (*_g->ft.berTbl->_oss_enci_boolp)
#define _oss_enci_creal        (*_g->ft.berTbl->_oss_enci_crealp)
#define _oss_enci_gtime        (*_g->ft.berTbl->_oss_enci_gtimep)
#define _oss_enci_int          (*_g->ft.berTbl->_oss_enci_intp)
#define _oss_enci_length       (*_g->ft.berTbl->_oss_enci_lengthp)
#define _oss_enci_liobjid      (*_g->ft.berTbl->_oss_enci_liobjidp)
#define _oss_enci_llobjid      (*_g->ft.berTbl->_oss_enci_llobjidp)
#define _oss_enci_lsobjid      (*_g->ft.berTbl->_oss_enci_lsobjidp)
#define _oss_enci_mreal        (*_g->ft.berTbl->_oss_enci_mrealp)
#define _oss_enci_nstr         (*_g->ft.berTbl->_oss_enci_nstrp)
#define _oss_enci_opentype     (*_g->ft.berTbl->_oss_enci_opentypep)
#define _oss_enci_pbit         (*_g->ft.berTbl->_oss_enci_pbitp)
#define _oss_enci_pstr         (*_g->ft.berTbl->_oss_enci_pstrp)
#define _oss_enci_real         (*_g->ft.berTbl->_oss_enci_realp)
#define _oss_enci_tag          (*_g->ft.berTbl->_oss_enci_tagp)
#define _oss_enci_uany         (*_g->ft.berTbl->_oss_enci_uanyp)
#define _oss_enci_ubit         (*_g->ft.berTbl->_oss_enci_ubitp)
#define _oss_enci_uint         (*_g->ft.berTbl->_oss_enci_uintp)
#define _oss_enci_uiobjid      (*_g->ft.berTbl->_oss_enci_uiobjidp)
#define _oss_enci_ulobjid      (*_g->ft.berTbl->_oss_enci_ulobjidp)
#define _oss_enci_uoct         (*_g->ft.berTbl->_oss_enci_uoctp)
#define _oss_enci_usobjid      (*_g->ft.berTbl->_oss_enci_usobjidp)
#define _oss_enci_ustr         (*_g->ft.berTbl->_oss_enci_ustrp)
#define _oss_enci_utime        (*_g->ft.berTbl->_oss_enci_utimep)
#define _oss_enci_vbit         (*_g->ft.berTbl->_oss_enci_vbitp)
#define _oss_enci_voct         (*_g->ft.berTbl->_oss_enci_voctp)
#define _oss_enci_vstr         (*_g->ft.berTbl->_oss_enci_vstrp)
#define _oss_free_creal        (*_g->ft.berTbl->_oss_free_crealp)
#define _oss_releaseMem        (*_g->ft.apiTbl->_oss_releaseMemp)
#define _oss_set_outmem_d      (*_g->ft.apiTbl->_oss_set_outmem_dp)
#define _oss_encd_eobjid       (*_g->ft.berTbl->_oss_encd_eobjidp)
#define _oss_dec_eobjid        (*_g->ft.berTbl->_oss_dec_eobjidp)
#define _oss_encd_dubit        (*_g->ft.berTbl->_oss_encd_dubitp)
#define _oss_encd_dvbit        (*_g->ft.berTbl->_oss_encd_dvbitp)
#define _oss_not_dflt          (*_g->ft.berTbl->_oss_not_dfltp)
#define _oss_beginBlock        (*_g->ft.apiTbl->_oss_beginBlockp)
#define _oss_nextItem          (*_g->ft.apiTbl->_oss_nextItemp)
#define _oss_endBlock          (*_g->ft.apiTbl->_oss_endBlockp)
#endif /* _DLL || OS2_DLL || (_WINDOWS && !_WIN32) */

#endif /* ossber_hdr_file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\osstrace.h ===
/*****************************************************************************/
/* Copyright (C) 1992-1999 Open Systems Solutions, Inc.  All rights reserved.*/
/*****************************************************************************/

/* THIS FILE IS PROPRIETARY MATERIAL OF OPEN SYSTEMS SOLUTIONS, INC. AND
 * MAY BE USED ONLY BY DIRECT LICENSEES OF OPEN SYSTEMS SOLUTIONS, INC.
 * THIS FILE MAY NOT BE DISTRIBUTED. */

/*****************************************************************************/
/*  FILE: @(#)osstrace.h	5.4.1.1  97/06/08              */
/*                                                                           */
/*  When tracing is in effect in the OSS ASN.1 Tools encoder/decoder the     */
/*  user user-replaceable trace routine, osstrace(), is called to trace      */
/*  the value that is being encoded/decoded.  This header file describes     */
/*  the parameters passed to osstrace().                                     */
/*                                                                           */
/*  Detailed descriptions appear after the declarations.                     */
/*****************************************************************************/

#if _MSC_VER > 1000
#pragma once
#endif

#include "ossdll.h"

#if defined(_MSC_VER) && (defined(_WIN32) || defined(WIN32))
#pragma pack(push, ossPacking, 4)
#elif defined(_MSC_VER) && (defined(_WINDOWS) || defined(_MSDOS))
#pragma pack(1)
#elif defined(__BORLANDC__) && defined(__MSDOS__)
#ifdef _BC31
#pragma option -a-
#else
#pragma option -a1
#endif /* _BC31 */
#elif defined(__BORLANDC__) && defined(__WIN32__)
#pragma option -a4
#elif defined(__IBMC__)
#pragma pack(4)
#elif defined(__WATCOMC__) && defined(__NT__)
#pragma pack(push, 4)
#elif defined(__WATCOMC__) && (defined(__WINDOWS__) || defined(__DOS__))
#pragma pack(push, 1)
#endif /* _MSC_VER && _WIN32 */

#ifdef macintosh
#pragma options align=mac68k
#endif

/* traceKind: describes the type of TraceRecord */

enum traceKind
{
	endOfContentsTrace = 0, /* end-of-contents octets */
	valueTrace,             /* traceRecord contains a traced value */
	skippedFieldTrace,      /* a value whose type is not recognized
				 * is being skipped */
	messageTrace            /* error message is in the field "value" */
};


/* fieldKind: describes the contents of "fieldNumber".  "fieldKind" is
 *            meaningful only if "fieldNumber" is not 0
 */

enum fieldKind
{
	setOrSequenceField = 0, /* "fieldNumber" is the position of the
				 * component within a SET or SEQUENCE */
	pduNumber,              /* "fieldNumber" is a PDU number */
	setOrSequenceOfElement, /* "fieldNumber" is the position of the
				 * component within a SET OF or SEQUENCE OF
				 * components */
	stringElement           /* "fieldNumber" is the position of the
				 * substring within a constructed STRING */
};

enum prtType
{
	seqsetType = 0,		/* SEQUENCE and SET uses [fieldcount =  n] */
	seqofType,		/* SEQUENCE OF and SET OF use [length = n] */
	choiceType,		/* CHOICE type uses format [index = n] 	   */
	pseudoType,		/* No length info is printed or [not encoded] */
	primeType,		/* All other types use the format	   */
				/* [length = [(not encoded)] nbytes.nbits] */
				/* fragmentation is printed for OCTET	   */
				/* STRING and BIT STRING.		   */
	closeType		/* Trace message at the end of encoding.   */
};

/* tag_length: specifies the tag and length of a value. */

struct tag_length
{
	unsigned long int length;  /* length of type, if definite */
	unsigned short int tag;    /* 16 bits of the form CCTTTTTTTTTTTTTT,
				    * with "CC" the class number, and "T...T"
				    * the tag. (If tag is 0, then "length",
				    * "primitive" and "definite" are
				    * not significant). */
	unsigned int      definite: 1;  /* 1: definite-length encoding */
};

/* traceRecord: OSS ASN.1 Tools trace record */

struct traceRecord
{
	enum traceKind   kind;          /* kind of trace record */
	void             *p;            /* reserved for OSS */
	char             *identifier,   /* SET/SEQUENCE/CHOICE component name*/
			 *typeReference,/* defined type name                 */
			 *builtinTypeName;  /* ASN.1 builtin type defined in *
					     * ISO 8824 or "Character String"*/

	void             *valueName;    /* reserved for future use */

	unsigned         taggingCount;  /* number of entries in the tag&length
					 * or content-end-octet array */

	union            /* tag&length or end-of-contents-octets array. */
	{
		struct tag_length *tag_length;
		int               *depth;
	}                 tagging;

	enum prtType      prtType;	/* Refer to prtType above for details */
	char           	  lenEncoded;	/* Indicate whether length is encoded */
	long              length;	/* Length in bits for all prime types */
					/* fieldcount for SET and SEQUENCE    */
					/* length of components for SET OF    */
					/* choice index for type CHOICE	      */
	int               fragment;	/* Fragment for OCTET STRING and BIT  */
					/* STRING, PER fragment when too long */

	enum fieldKind    fieldKind;   /* kind of value in "fieldNumber" */
	unsigned int      fieldNumber; /* component number, 0 if not
					*  applicable */

	unsigned int      depth;    /* the depth of this value, from 0 on up */

	unsigned int      primitive: 1; /* indicates structure of encoding */

	char              value[1];     /* the formatted value for simple
					 * type and ANY. If the first byte
					 * is 0, no value is present. */
};


extern void DLL_ENTRY osstrace(struct ossGlobal *g, struct traceRecord *p, size_t traceRecordLen);

/* osstrace(): User-replaceable trace routine.
 *
 * Parameters:
 *   g      - Reserved.  This is always set to NULL for now.
 *   p      - traceRecord, described below.
 *   traceRecordLen - True length of traceRecord, including first \0 in "value"
 *
 * osstrace() is called:
 *
 *      - once for each builtin ASN.1 type, regardless of tagging, with the
 *        field "kind" set to valueTrace.  So given a PDU of value "fooBar":
 *
 *           Sample DEFINITIONS EXPLICIT TAGS ::= BEGIN
 *               fooBar Foo ::= {age 6, living TRUE}
 *               Foo ::= SET {age INTEGER, living [1] [2] Alive}
 *               Alive ::= BOOLEAN
 *           END
 *
 *        it is called called three times with "kind" set to valueTrace - once
 *        for the SET, once for the INTEGER, and once for the BOOLEAN.
 *
 *        When the traceRecord "kind" field is set to valueTrace ...
 *
 *        The field "identifier" contains the component identifier of
 *        the type if one is present in the ASN.1 definition.  So in
 *        the above example, "identifier" will be empty on the call for
 *        the SET, while on the call for the INTEGER it will contain "age",
 *        and "living" on the call for the BOOLEAN.
 *
 *        The field "typeReference" contains the name of the associated ASN.1
 *        typereference, if any.  So in the above example, "typeReference"
 *        will contain "Foo" on the call for the SET, "Alive" on the call
 *        for the BOOLEAN, and will be empty on the call for the INTEGER.
 *
 *        The field "builtinTypeName" contains the name of the ASN.1 builtin
 *        type.  So in the above example, "builtinTypeName" will contain
 *        "SET", "INTEGER", and "BOOLEAN" on the calls as appropriate.
 *        Note that for all character string types "builtinTypeName" is
 *        set to "Character String".  This will be changed in the near future
 *        to reflect the true character string type.
 *
 *        The field "taggingCount" contains the number of entries in the array
 *        of tag_length structs pointed to by tagging.tag_length, and reflects
 *        the number of tags present in the encoding.  Note that an entry
 *        exists in the tag_length array for each ANY and CHOICE value as
 *        though they had tags defined for them in the ASN.1 Standard.  So in
 *        the above example, "taggingCount" is 1 on the calls for the SET and
 *        INTEGER, and on the call for the BOOLEAN "taggingCount" is 3 since
 *        EXPLICIT TAGS is in effect.
 *
 *        The field "tagging.tag_length" points to an array of tag_length
 *        structs.
 *
 *              The field "tagging.tag_length->tag" is the BER tag represented
 *              in the form CCTTTTTTTTTTTTTT with "CC" the class number, and
 *              "TTTTTTTTTTTTTT" the tag number.  Since the ANY and CHOICE
 *              types do not have tags of their own, the last entry in the
 *              tag_length array for these types always has 0 as the value of
 *              the "tag" field.  So in the above example, "tag" is 0x11 on the
 *              call for the the SET.
 *
 *              The field "tagging.tag_length->length" is the length of the
 *              encoded value if the length is of definite form (i.e.,
 *              "definite" is 1).
 *
 *              The field "tagging.tag_length->definite" indicates when the
 *              length is definite or indefinite.  This field is significant
 *              only if "tag" is non-zero.
 *
 *        The field "fieldKind" indicates whether the number in "field" is:
 *        -- the position of a component within a SET or SEQUENCE, or
 *        -- the PDU number assigned by the ASN.1 compiler, or
 *        -- the position of a component within a SET OF or SEQUENCE OF, or
 *        -- the position of a substring within a constructed string.
 *        "fieldKind" is significant only if "field" is non-zero.  So in
 *        the example above, "fieldKind" has a value of pduNumber on the
 *        call for the SET, and a value of setOrSequenceField on the calls for
 *        the INTEGER and BOOLEAN.
 *
 *        The field "fieldNumber" is a ordinal number indicating the position
 *        of a component within a SET, SEQUENCE, SET OF, SEQUENCE OF, or
 *        constructed string, or the PDU number assigned by the ASN.1 compiler.
 *        So in the above example, "fieldNumber" is 1 (the PDU number) on the
 *        call for the SET, 1 (the position of the component "age") on the
 *        call for the INTEGER, and 2 (the position of the component "living"
 *        on the call for the BOOLEAN.
 *
 *        The field "depth" is the level of nesting of the value relative to
 *        the outermost type, which has a "depth" value of 0.  So in the above
 *        example, "depth" is 0 on the call for the SET, and 1 on the calls
 *        for the INTEGER and BOOLEAN.
 *
 *        The field "primitive" is set to 1 if the builtin ASN.1 type is
 *        simple (i.e., the primitive/constructed bit in the identifier
 *        octet is set to 0), so it is 0 for SET, SEQUENCE, SET OF, SEQUENCE
 *        OF, and CHOICE because they are structured. It is also set to 0 if
 *        the type is an ANY.  It is 1 for all other builtin types.
 *
 *        The field "value" contains formatted data if the builtin type
 *        is simple or ANY, regardless of tagging.  Hence, in the above
 *        example the call for SET will not contain any data in "value"
 *        (because the builtin type is a constructed type), while for the
 *        INTEGER and BOOLEAN types "value" will contain formatted data.
 *        The maximum number of bytes of formatted data placed into "value"
 *        is controlled by the external variable "asn1chop".  If "asn1chop"
 *        is set to 0 the maximum length of the traced value is determined
 *        by the maximum internal buffer size variable, "ossblock".
 *
 *      - once for each end-of-contents octets pair that is generated/
 *        encountered while encoding/decoding a constructed value whose
 *        length is of the indefinite-length form.  A call with a "valueTrace"
 *        record is always made to osstrace() before one is made with an
 *        "endOfContentsTrace" record.
 *
 *        A single "endOfContentsTrace" call is made to osstrace() for each
 *        builtin type that is processed if the indefinite-length form of
 *        encoding is used.  If the builtin type is a structured type (CHOICE,
 *        SET, SEQUENCE, SET OF, SEQUENCE OF) then there may be multiple
 *        "valueTrace" and possible "endOfContentsTrace" calls made to
 *        osstrace() before the matching "endOfContentsTrace" call is made.
 *
 *        When the traceRecord "kind" field is set to endOfContentsTrace ...
 *
 *        The field "taggingCount" contains the number of entries in the array
 *        of "depth" indicators pointed to by tagging.depth, and reflects
 *        the nesting of each pair of end-of-contents-octets associated with
 *        the builtin type being encoded/decoded.  So in the above example,
 *        if indefinite-length encoding is being used, "taggingCount" will
 *        be 1 on the call for the SET (since it has a single constructed
 *        tag), and 2 on the call for the BOOLEAN (since it has two explicit
 *        tags, for which the "constructed" bit in the encoding must be set).
 *
 *        The field "tagging.depth" points to an array of "depth" indicators
 *        that reflect the nesting of each pair of end-of-contents-octets
 *        associated with a builtin type.  So in the above example, if
 *        indefinite-length encoding is being used, "tagging.depth" will point
 *        to a single 0 on the call for the SET since it has a single tag for
 *        which the constructed bit is set; while on the call for the BOOLEAN
 *        "tagging.depth" will point to an array whose two entries are 1 and 2
 *        since there are two explicit tags on the BOOLEAN.
 *
 *        All other fields in the traceRecord are insignificant for an
 *        endOfContentsTrace record.
 *
 *      - once for each value that is skipped while decoding, with a "kind"
 *        value of skippedFieldTrace.  The skippedFieldTrace "kind" is just
 *        means of indicating that an unexpected value was encountered in the
 *        message and is being skipped.  This is not an error if the type is
 *        extensible.
 *
 *        When the traceRecord "kind" field is set to skippedFieldTrace ...
 *
 *        The field of the traceRecord are the same as when "kind" is set to
 *        valueTrace, except that:
 *        -- the skipped value is always reported as having one tag, hence
 *        -- there is only one entry in the tag_length array.
 *        -- the content of the field "value" is always "<skipped>", and
 *        -- "typeReference" is always NULL.
 *
 *      - once for each error message issued, in which case the "kind" field
 *        is set to messageTrace.
 *
 *        When the traceRecord "kind" field is set to messageTrace the "value"
 *        field contains the error message, and other fields are
 *        insignificant.
 */


/* tag_length: describes the tag and length of a value.
 *
 *            "tag" is 0 if the value is an ANY or CHOICE value, in which
 *             case "definite" is not significant since ANY and CHOICE do
 *             not have a tag of their own.
 *
 *             If "tag" is not 0, "definite" indicates whether the value
 *             is encoded using definite- or indefinite-length form.
 *
 *             If "definite" is 1, "length" is the length of the value, else
 *             it is not significant (indefinite-length encoding was used).
 */


/* tagging: tag&length or end-of-contents-octets array.
 *
 *      The tag and length array, tag_length, is present if this
 *      is a valueTrace or skippedFieldTrace record.  There is one array
 *      entry for each tag present in the encoding of a given value, so
 *      "[1] EXPLICIT [2] EXPLICIT INTEGER" gets three tag_length
 *      array entries, where each entry describes the tag and length
 *      information that precedes the value.
 *
 *      The depth array, "depth", is present only if this is a
 *      endOfContentsTrace record.  There is one array entry for each
 *      indefinite length present in the encoding of a value, so
 *      "[1] EXPLICIT [2] EXPLICIT INTEGER" gets two "depth" entries
 *      corresponding to the two explicit tags, where the value of each
 *      tag indicates the depth of the tagged value relative to outmost type
 *      that contains the INTEGER (e.g., relative to the containing SET).
 */

/* Odds and ends:
 *
 * - When the value of a field is not significant the field is set to 0.
 */


/* Augmenting for Packed Encoding Rule (PER) tracing.
 *
 * PER does not encode tag for any ASN.1 type. For some types, length
 * may or may not be encoded. PER does not always use octet aligned
 * encoding, therefore, the length should be in unit of bit.
 *
 * We classified ASN.1 types in to the following:
 *
 * (1). For all primitive types (including ANY), the prtType in traceRecord
 * 	is set to primeType, length is the total length of the content
 *	in bits. The file osstrace.c prints length in the format
 *	length = nbytes.nbits, and the total length should be 8*nbytes+nbits.
 *	If the length is not encoded, "(not encoded)" will be added to the
 *	output string. For BIT STRING with length longer than 64K (bits), and
 *	for OCTET STRING longer that 16K (bytes), fragmentation is needed
 *	and this is indicated by the string "fragment = n" after the length.
 *	The fragmentation index is field fragment in traceRecord.
 * (2). For SEQUENCE and SET, prtType is seqsetType. In this case, the length
 *	in traceRecord is the fieldcount of the SEQUENCE or SET.
 * (3). For SEQUENCE OF and SET OF, prtType is seqofType, and the length
 *	in traceRecord is the count of components in the SEQUENCE OF (SET OF).
 * (4). For CHOICE, prtType is choiceType, and the length field in
 *	traceRecord indicates the choice index.
 * (5). Total number of bits for the entire encoding is reported at the end
 *	of encoding and decoding. The prtType for this trace is closeType.
 */

#if defined(_MSC_VER) && (defined(_WIN32) || defined(WIN32))
#pragma pack(pop, ossPacking)
#elif defined(_MSC_VER) && (defined(_WINDOWS) || defined(_MSDOS))
#pragma pack()
#elif defined(__BORLANDC__) && (defined(__WIN32__) || defined(__MSDOS__))
#pragma option -a.
#elif defined(__IBMC__)
#pragma pack()
#elif defined(__WATCOMC__)
#pragma pack(pop)
#endif /* _MSC_VER && _WIN32 */

#ifdef macintosh
#pragma options align=reset
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\ossglobl.h ===
/*
 * Copyright (C) 1992-1999 Open Systems Solutions, Inc.  All rights reserved
 */
/*
 * THIS FILE IS PROPRIETARY MATERIAL OF OPEN SYSTEMS SOLUTIONS, INC. AND
 * MAY BE USED ONLY BY DIRECT LICENSEES OF OPEN SYSTEMS SOLUTIONS, INC.
 * THIS FILE MAY NOT BE DISTRIBUTED.
 */
/*
 * FILE: @(#)ossglobl.h	5.28.1.2  97/09/24
 */

#ifndef OSSGLOBL_H
#define OSSGLOBL_H

#if _MSC_VER > 1000
#pragma once
#endif

#include "ossdll.h"

#ifndef OSS_TOED
#define _EncDecGlobals soedData
#endif
#ifndef ossMemMgrVarLen
#ifdef __OS400__
#define ossMemMgrVarLen 100
#define ossEncDecVarLen 500    /* The size of the
				  encDecVar array shouldn't be less than
				  the sizeof(world->c) since the latter
				  structure overlays encDecVar */
#else
#define ossMemMgrVarLen 48
#define ossEncDecVarLen 192    /* The size of the
				  encDecVar array shouldn't be less than
				  the sizeof(world->c) since the latter
				  structure overlays encDecVar */
#endif /* __OS400__ */
#if !defined(EOF) && !defined(_FILE_DEFINED)
typedef char FILE;
#endif /* !EOF && !_FILE_DEFINED */

#ifndef ERR_MSG_LENGTH
#define ERR_MSG_LENGTH 512      /* length of error messages to be output */
#endif

#ifdef __cplusplus
extern "C"
{
#endif

typedef enum  {
    OSS_BASIC = 0,
    OSS_SPARTAN
} OssAPI;

typedef enum  {
    OSS_BER = 0,
    OSS_PER_ALIGNED,
    OSS_PER_UNALIGNED,
    OSS_DER
} ossEncodingRules;

	/*
	 * List of supported compatibility modes
	 */
typedef enum {
    OSS_CUSTOM_COMPATIBILITY = -2, /* Any combination of compatibility
                                    * flags set by a call to the function
                                    * ossSetCompatibilityFlags() */
    OSS_CURRENT_VERSION = 0,       /* Current version */
    OSS_VERSION_412,         /* Includes the following compatibility flags:
                              * OSS_V412_TIME_AND_WIDE_CHAR_STRINGS,
                              * OSS_TRUNCATE_0_SECONDS_FROM_GENERALIZED_TIME,
                              * OSS_TRUNCATE_0_SECONDS_FROM_UTC_TIME and
                              * OSS_EXTENDED_UNRESTRICTED_CHAR_STRINGS
			      * OSS_ALLOW_ZERO_LENGTH_OPENTYPE_STRINGS
			      */
    OSS_VERSION_419          /* Includes the following compatibiity flags:
                              * OSS_TRUNCATE_0_SECONDS_FROM_GENERALIZED_TIME,
                                OSS_TRUNCATE_0_SECONDS_FROM_UTC_TIME and
                                OSS_EXTENDED_UNRESTRICTED_CHAR_STRINGS
			      * OSS_ALLOW_ZERO_LENGTH_OPENTYPE_STRINGS
			      */
} OssRuntimeVersion;

#if defined(_MSC_VER) && (defined(_WIN32) || defined(WIN32))
#pragma pack(push, ossPacking, 4)
#elif defined(_MSC_VER) && (defined(_WINDOWS) || defined(_MSDOS))
#pragma pack(1)
#elif defined(__BORLANDC__) && defined(__MSDOS__)
#ifdef _BC31
#pragma option -a-
#else
#pragma option -a1
#endif /* _BC31 */
#elif defined(__BORLANDC__) && defined(__WIN32__)
#pragma option -a4
#elif defined(__IBMC__)
#pragma pack(4)
#elif defined(__WATCOMC__) && defined(__NT__)
#pragma pack(push, 4)
#elif defined(__WATCOMC__) && (defined(__WINDOWS__) || defined(__DOS__))
#pragma pack(push, 1)
#endif /* _MSC_VER && _WIN32 */

#ifdef macintosh
#pragma options align=mac68k
#endif

typedef struct ossGlobal {
    /*
     * used for communicating with the memory manager and the tracing-routine
     */
				/* low-level memory allocator */
    void       *(DLL_ENTRY_FPTR *_System mallocp)(size_t p);
				/* memory re-allocator */
    void       *(DLL_ENTRY_FPTR *_System reallocp)(void *p, size_t s);
				/* low-level memory freer */
    void        (DLL_ENTRY_FPTR *_System freep)(void *p);
    size_t      asn1chop;       /* 0 means do not truncate strings; greater
				 * value means truncate long output strings
				 * (OCTET STRING, BIT STRING, Character String)
				 * to be "asn1chop" bytes long.  Read by
				 * encoder&decoder tracing and "printPDU"
				 */
    size_t      ossblock;       /* if not 0, size of largest block
				 * to allocate */
    size_t      ossprefx;       /* # bytes to leave before OSAK data buffer */

    FILE        *asn1out;       /* tracing output file */

    /* low-level tracing-output function; default is fprintf() */
    int (*asn1prnt)(FILE *stream, const char *format, ...);

	/*
	 * available for use by user application
	 */
    void        *userVar;

	/*
	 * used for storing DLL- & library NLMs-related parameters
	 */
#if defined(_WINDOWS) || defined(_WIN32) || \
    defined(__OS2__)  || defined(NETWARE_DLL)
    FunctionTables    ft;
#endif /* _WINDOWS || _DLL || __OS2__ || NETWARE_DLL */

	/*
	 * related to the new API; not for direct reference by user code
	 */
    void             *ctlTbl;
    OssAPI            api;
    ossEncodingRules  encRules;
    unsigned long     encodingFlags;
    unsigned long     decodingFlags;
    long              decodingLength;
    char              errMsg[ERR_MSG_LENGTH];

	/*
	 * reserved for use by the encoder/decoder
	 */
    double            reserved[4];

	/*
	 * reserved for use by the memory manager and the tracing-routine
	 */
#ifdef storing
    struct storHandling t;
#else /* not storing */
    long int    memMgrVar[ossMemMgrVarLen];
#endif

#if defined(OSS_TOED)
    struct _EncDecGlobals c;
#elif defined(coding)
    struct _EncDecGlobals c;
#else
    long int encDecVar[ossEncDecVarLen];
#endif
} OssGlobal;

#if defined(_MSC_VER) && (defined(_WIN32) || defined(WIN32))
#pragma pack(pop, ossPacking)
#elif defined(_MSC_VER) && (defined(_WINDOWS) || defined(_MSDOS))
#pragma pack()
#elif defined(__BORLANDC__) && (defined(__WIN32__) || defined(__MSDOS__))
#pragma option -a.
#elif defined(__IBMC__)
#pragma pack()
#elif defined(__WATCOMC__)
#pragma pack(pop)
#endif /* _MSC_VER && _WIN32 */

#ifdef macintosh
#pragma options align=reset
#endif

PUBLIC int              DLL_ENTRY ossSetEncodingRules(struct ossGlobal *world,
						ossEncodingRules rules);
PUBLIC ossEncodingRules DLL_ENTRY ossGetEncodingRules(struct ossGlobal *world);
PUBLIC int              DLL_ENTRY ossSetDecodingLength(struct ossGlobal *world,
							long bufferLength);
PUBLIC long             DLL_ENTRY ossGetDecodingLength(struct ossGlobal *world);
PUBLIC int              DLL_ENTRY ossSetEncodingFlags(struct ossGlobal *world,
							unsigned long flags);
PUBLIC unsigned long    DLL_ENTRY ossGetEncodingFlags(struct ossGlobal *world);
PUBLIC int              DLL_ENTRY ossSetDecodingFlags(struct ossGlobal *world,
							unsigned long flags);
PUBLIC unsigned long    DLL_ENTRY ossGetDecodingFlags(struct ossGlobal *world);
PUBLIC char            *DLL_ENTRY ossGetErrMsg(struct ossGlobal *world);
PUBLIC int              DLL_ENTRY ossCallerIsDecoder(struct ossGlobal *world);
PUBLIC int              DLL_ENTRY ossSetFlags(struct ossGlobal *world,
							unsigned long flags);
PUBLIC int              DLL_ENTRY ossSetRuntimeVersion(struct ossGlobal *world,
						OssRuntimeVersion version);
PUBLIC OssRuntimeVersion DLL_ENTRY ossGetRuntimeVersion(struct ossGlobal *world);
PUBLIC int              DLL_ENTRY ossSetCompatibilityFlags(struct ossGlobal *world,
							unsigned long flag);
PUBLIC unsigned long    DLL_ENTRY ossGetCompatibilityFlags(struct ossGlobal *world);
PUBLIC int              DLL_ENTRY ossGetOssGlobalSize(void);
			/*
			 * The following are declarations for link routines
			 * needed to link the encoding rule or rules specified
			 * on the compiler command line.  The function calls
			 * are generated by the compiler into _ossinit_...()
			 * in the control table.  These functions are not
			 * meant to be referenced by user code.
			 */
PUBLIC void DLL_ENTRY ossLinkAPI(OssGlobal *);
PUBLIC void DLL_ENTRY ossLinkBer(OssGlobal *);
PUBLIC void DLL_ENTRY ossLinkPer(OssGlobal *);
PUBLIC void DLL_ENTRY ossLinkDer(OssGlobal *);
PUBLIC void DLL_ENTRY ossLinkConstraint(OssGlobal *);
PUBLIC void DLL_ENTRY ossLinkUserConstraint(OssGlobal *);
PUBLIC void DLL_ENTRY ossLinkBerReal(OssGlobal *);
PUBLIC void DLL_ENTRY ossLinkPerReal(OssGlobal *);
PUBLIC void DLL_ENTRY ossLinkCmpValue(OssGlobal *);
PUBLIC void DLL_ENTRY ossLinkCpyValue(OssGlobal *);
PUBLIC void DLL_ENTRY ossLinkPerPDV(OssGlobal *);
PUBLIC void DLL_ENTRY ossLinkOid(OssGlobal *);

#ifdef __cplusplus
}
#endif
#endif /* ossMemMgrVarLen */
#endif /* OSSGLOBL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\ossdll.h ===
/*
 * Copyright (C) 1993-1999 Open Systems Solutions, Inc.  All rights reserved.
 *
 * THIS FILE IS PROPRIETARY MATERIAL OF OPEN SYSTEMS SOLUTIONS, INC.
 * AND MAY ONLY BE USED BY DIRECT LICENSEES OF OPEN SYSTEMS SOLUTIONS, INC.
 * THIS FILE MAY NOT BE DISTRIBUTED.
 *
 * FILE: @(#)ossdll.h	5.57.1.1  97/06/08
 */


#ifndef OSSDLL_H
#define OSSDLL_H

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if defined(_MSC_VER) && (defined(_WIN32) || defined(WIN32))
#pragma pack(push, ossPacking, 4)
#elif defined(_MSC_VER) && (defined(_WINDOWS) || defined(_MSDOS))
#pragma pack(1)
#elif defined(__BORLANDC__) && defined(__MSDOS__)
#ifdef _BC31
#pragma option -a-
#else
#pragma option -a1
#endif /* _BC31 */
#elif defined(__BORLANDC__) && defined(__WIN32__)
#pragma option -a4
#elif defined(__IBMC__)
#pragma pack(4)
#elif defined(__WATCOMC__) && defined(__NT__)
#pragma pack(push, 4)
#elif defined(__WATCOMC__) && (defined(__WINDOWS__) || defined(__DOS__))
#pragma pack(push, 1)
#endif /* _MSC_VER && _WIN32 */

#if defined(_WINDOWS) || defined(_WIN32) || defined(WIN32) || \
    defined(__WIN32__) || defined(__OS2__)  || defined(NETWARE_DLL)
#include <stdio.h>
#include <limits.h>
#include <stdarg.h>
#if !defined(__OS2__) && !defined(NETWARE_DLL) && !defined(_NTSDK)
#include <windows.h>
#endif /* !__OS2__ && !NETWARE_DLL && !_NTSDK */
#include "asn1hdr.h"
#ifndef DLL_ENTRY
#if defined(_WIN32) || defined(WIN32) || defined(__WIN32__)
#ifdef __BORLANDC__
#define PUBLIC
#define DLL_ENTRY      __stdcall __export
#define DLL_ENTRY_FDEF __stdcall __export
#define DLL_ENTRY_FPTR __stdcall __export
#elif defined(__IBMC__)
#define PUBLIC
#define DLL_ENTRY      WINAPI
#define DLL_ENTRY_FDEF WINAPI __export
#define DLL_ENTRY_FPTR WINAPI
#elif defined(__WATCOMC__)
#define PUBLIC
#define DLL_ENTRY      WINAPI __export
#define DLL_ENTRY_FDEF WINAPI __export
#define DLL_ENTRY_FPTR WINAPI __export
#elif defined(_NTSDK)
typedef void *         HINSTANCE;
typedef void *         HWND;
typedef char           BOOL;
typedef long           LONG;
#define PUBLIC         __declspec(dllexport)
#define DLL_ENTRY
#define DLL_ENTRY_FDEF
#define DLL_ENTRY_FPTR
#else
#define PUBLIC
#define DLL_ENTRY      WINAPI
#define DLL_ENTRY_FDEF WINAPI
#define DLL_ENTRY_FPTR WINAPI
#endif /* __BORLANDC__ */
#define _System
#elif defined(_WINDOWS)
#define PUBLIC
#ifdef DPMI_DLL
#define DLL_ENTRY      FAR PASCAL __export
#define DLL_ENTRY_FDEF FAR PASCAL __export
#define DLL_ENTRY_FPTR FAR PASCAL __export
#else
#define DLL_ENTRY      far pascal _export
#define DLL_ENTRY_FDEF far pascal _export
#define DLL_ENTRY_FPTR far pascal _export
#endif /* DPMI_DLL */
#define _System
#elif defined(__OS2__)
#define PUBLIC
#define DLL_ENTRY      _System
#define DLL_ENTRY_FDEF _Export _System
#define DLL_ENTRY_FPTR
#define HWND int
#define LONG long
#define BOOL char
#define DWORD unsigned long
#define HINSTANCE unsigned long
#elif defined(NETWARE_DLL)
#define PUBLIC
#define DLL_ENTRY
#define DLL_ENTRY_FDEF
#define DLL_ENTRY_FPTR
#define _Export
#undef _System
#define _System
#define LONG unsigned long
#define HWND int
#define DWORD LONG
#define BOOL char
#define HINSTANCE LONG
#endif /* _WIN32 || WIN32 || __WIN32__ */
#endif /* DLL_ENTRY */

#define BUFFERSIZE 1024
			/*
			 * NUMBER_OF_LINES_IN_BLOCK is the number of
			 * 4-byte offsets in a block of memory allocated
			 * at a time.  Each offset corresponds to a line
			 * of a text file to be displayed in a window.
			 */
#define NUMBER_OF_LINES_IN_BLOCK 200

typedef struct memblock {
    struct memblock     *prev;
    struct memblock     *next;
    LONG                *fileOffset;
    short               *lineLength;
    short                blockNumber;
} MEMBLOCK;

#ifdef __alpha
#define ossArg LONG_LONG
#else
#define ossArg int
#endif /* __alpha */

typedef struct memManagerTbl {
    int			 (DLL_ENTRY_FPTR *_System ossMinitp)(void *);
    unsigned char	*(DLL_ENTRY_FPTR *_System dopenInp)(void *,
						void **, unsigned long *);
    unsigned long	 (DLL_ENTRY_FPTR *_System dclosInp)(void *,
						void **, size_t);
    unsigned char	*(DLL_ENTRY_FPTR *_System dswapInp)(void *,
						void **, size_t *);
    void		 (DLL_ENTRY_FPTR *_System dopenOutp)(void *, void *,
						unsigned long, unsigned long);
    unsigned char	*(DLL_ENTRY_FPTR *_System dxferObjp)(void *,
						void **inn, void **out,
						size_t *, unsigned long *);
    unsigned long	 (DLL_ENTRY_FPTR *_System dclosOutp)(void *, void **);
    void		*(DLL_ENTRY_FPTR *_System dallcOutp)(void *, size_t,
								char root);
    void		 (DLL_ENTRY_FPTR *_System openWorkp)(void *);
    void		 (DLL_ENTRY_FPTR *_System pushHndlp)(void *, void *);
    unsigned char	*(DLL_ENTRY_FPTR *_System popHndlp)(void *,
							void **, size_t);
    void		 (DLL_ENTRY_FPTR *_System closWorkp)(void *);
    void		*(DLL_ENTRY_FPTR *_System allcWorkp)(void *, size_t);
    unsigned char	*(DLL_ENTRY_FPTR *_System lockMemp)(void *, void *);
    void		 (DLL_ENTRY_FPTR *_System unlokMemp)(void *, void *,
								char);
    void		 (DLL_ENTRY_FPTR *_System ossFreerp)(void *, void *);
    int			 (DLL_ENTRY_FPTR *_System freePDUp)(void *, int,
							void *, void *);
    void		 (DLL_ENTRY_FPTR *_System drcovObjp)(void *, int,
							void *, void *);
    unsigned char	*(DLL_ENTRY_FPTR *_System eopenInp)(void *, void *,
								size_t);
    unsigned char	*(DLL_ENTRY_FPTR *_System eswapInp)(void *, void *,
							void *, size_t);
    void		 (DLL_ENTRY_FPTR *_System eclosInp)(void *, void *);
    unsigned char	*(DLL_ENTRY_FPTR *_System eopenOutp)(void *, void **,
							size_t *, char);
    unsigned char	*(DLL_ENTRY_FPTR *_System eswapOutp)(void *, void **,
							size_t, size_t *);
    unsigned char	*(DLL_ENTRY_FPTR *_System exferObjp)(void *, void **,
				void **, unsigned long *, unsigned long);
    unsigned long	 (DLL_ENTRY_FPTR *_System eclosOutp)(void *, void **,
							size_t, char);
    void		 (DLL_ENTRY_FPTR *_System ercovObjp)(void *);
    unsigned char	*(DLL_ENTRY_FPTR *_System asideBeginp)(void *,
						void **, size_t, size_t *);
    unsigned char	*(DLL_ENTRY_FPTR *_System asideSwapp)(void *,
						void **, size_t, size_t *);
    void		*(DLL_ENTRY_FPTR *_System asideEndp)(void *,
							void *, size_t);
    unsigned char	*(DLL_ENTRY_FPTR *_System setDumpp)(void *, void **,
							void *, size_t *);
    void		 (DLL_ENTRY_FPTR *_System ossSetSortp)(void *, void *,
							unsigned char);
    void		 (DLL_ENTRY_FPTR *_System freeBUFp)(void *, void *);
    unsigned char	 (DLL_ENTRY_FPTR *_System egetBytep)(void *, void *,
							unsigned long);
    void		*(DLL_ENTRY_FPTR *_System _ossMarkObjp)(void *,
								int, void *);
    void		*(DLL_ENTRY_FPTR *_System _ossUnmarkObjp)(void *,
								void *);
    void		*(DLL_ENTRY_FPTR *_System _ossGetObjp)(void *,
								void *);
    void		*(DLL_ENTRY_FPTR *_System _ossTestObjp)(void *,
								void *);
    void		(DLL_ENTRY_FPTR *_System _ossFreeObjectStackp)(void *);
    void		(DLL_ENTRY_FPTR *_System ossMtermp)(void *);
    void		(DLL_ENTRY_FPTR *_System _ossSetTimeoutp)(void *, long);
    int			memMgrType;
} MemManagerTbl;

#define osswinit ossWinit
#ifndef __IBMC__
PUBLIC int       DLL_ENTRY ossOpenTraceWindow(struct ossGlobal *);
void                      *getStartAddress(struct ossGlobal *, char *);
void            *DLL_ENTRY ossGetHeader(void);
PUBLIC HINSTANCE DLL_ENTRY ossLoadDll(struct ossGlobal *, char *);
PUBLIC int       DLL_ENTRY ossFreeDll(struct ossGlobal *, char *);
int                        ossWriteWindow(struct ossGlobal *, HWND);
PUBLIC int       DLL_ENTRY ossPrintWin(struct ossGlobal *, const char *,
			ossArg, ossArg, ossArg, ossArg, ossArg, ossArg,
					ossArg, ossArg, ossArg, ossArg);
PUBLIC int       DLL_ENTRY ossReadLine(struct ossGlobal *, HWND, FILE *,
						char *, MEMBLOCK *, LONG);
PUBLIC void      DLL_ENTRY ossFreeList(struct ossGlobal *);
PUBLIC void      DLL_ENTRY ossSaveTraceInfo(struct ossGlobal *, HWND, char *);
PUBLIC void      DLL_ENTRY ossWterm(struct ossGlobal *);
PUBLIC HINSTANCE DLL_ENTRY ossLoadMemoryManager(struct ossGlobal *, int, char *);
PUBLIC int       DLL_ENTRY ossWinit(struct ossGlobal *, void *, char *, HWND);
int              DLL_ENTRY oss_test(struct ossGlobal *);
int                        ossGeneric(struct ossGlobal *, HWND);
extern const int           ossEncoderDecoderType;
	/*
	 * The following two functions are used by the memory manager &
	 * tracing routine DLL as low level memory allocator and freer
	 * replacing the default--which is malloc() and free()--in the
	 * sample tests.  See ossgnrc.c for more information.
	 */
extern void *DLL_ENTRY getmem(size_t);
extern void  DLL_ENTRY rlsmem(void *);
extern HINSTANCE hInst;
#endif /* !__IBMC__ */
#endif /* _WINDOWS ||_WIN32 || WIN32 || __WIN32__ || __OS2__ || NETWARE_DLL */


#if defined(_WINDOWS) || defined(_WIN32) || \
    defined(__OS2__)  || defined(NETWARE_DLL)

#if defined(_WINDOWS) || defined(_DLL) || \
    defined(OS2_DLL)  || defined(NETWARE_DLL)
#define OSS_PLUS_INFINITY  "PLUS_INFINITY"
#define OSS_MINUS_INFINITY "MINUS_INFINITY"
#define ossNaN             "NOT_A_NUMBER"
#endif /* _WINDOWS || _DLL || OS2_DLL || NETWARE_DLL */


typedef struct cstrainTbl {
    int  (DLL_ENTRY_FPTR *_System ossConstrainp)(void *, int, void *, void *);
} CstrainTbl;

typedef struct berTbl {
    int   (DLL_ENTRY_FPTR *_System ossBerEncodep)(void *, int, void *,
				char **, long *, void *, unsigned, char *);
    int   (DLL_ENTRY_FPTR *_System ossBerDecodep)(void *, int *, char **,
			long *, void **, long *, void *, unsigned, char *);
#ifdef SOED
    int   (DLL_ENTRY_FPTR *_System berEncodeOpenTypep)(void *, int,
				void *, void **, long *, void *, unsigned);
    int   (DLL_ENTRY_FPTR *_System berDecodeOpenTypep)(void  *, int *, void **,
				long  *, void **, long *, void *, unsigned);
    void  (DLL_ENTRY_FPTR *_System enc_errorp)(void *, int, void *);
    void  (DLL_ENTRY_FPTR *_System dec_errorp)(void *, int, void *);
    long  (DLL_ENTRY_FPTR *_System writetobufferp)(void *, unsigned char c);
    long  (DLL_ENTRY_FPTR *_System write_intp)(void *, char length, LONG_LONG);
    long  (DLL_ENTRY_FPTR *_System write_valuep)(void *, unsigned long,
							unsigned char *, char);
    int   (DLL_ENTRY_FPTR *_System numbitsp)(long);
    void  (DLL_ENTRY_FPTR *_System fpeHandlerp)(int);
    void *(DLL_ENTRY_FPTR *_System new_perm_pointed_top)(void *, void *,
							size_t, size_t);
    void  (DLL_ENTRY_FPTR *_System release_work_spacep)(void *, void *, size_t);
    void *(DLL_ENTRY_FPTR *_System copy_from_work_spacep)(void *, size_t,
					size_t suffix, void *, size_t, char);
    unsigned char (DLL_ENTRY_FPTR *_System get_bytep)(void *);
    void  (DLL_ENTRY_FPTR *_System set_intp)(void *, unsigned char *,
			unsigned int, LONG_LONG value, int);
    void *(DLL_ENTRY_FPTR *_System reserve_work_spacep)(void *, size_t, size_t *);
    long  (DLL_ENTRY_FPTR *_System encode_lengthp)(void *, long);
    void  (DLL_ENTRY_FPTR *_System debug_realp)(void *, char, unsigned char *, int, long);
    void  (DLL_ENTRY_FPTR *_System debug_strp)(void *, unsigned char *, size_t);
#else
#define   _dstd_parms_defx char **, long *, long
#define   _sdstd_parms_defx char **, long *
#define   _std_parms_defx char **, long *, char
    LONG_LONG (DLL_ENTRY_FPTR *_System _oss_dec_llintp)     (void *, _dstd_parms_defx);
    ULONG_LONG (DLL_ENTRY_FPTR *_System _oss_dec_ullintp)   (void *, _dstd_parms_defx);
    char (DLL_ENTRY_FPTR *_System _oss_dec_boolp)           (void *, _dstd_parms_defx);
    int  (DLL_ENTRY_FPTR *_System _oss_dec_iintp)           (void *, _dstd_parms_defx);
    long (DLL_ENTRY_FPTR *_System _oss_count_setof_itemsp)  (void *, _dstd_parms_defx);
    long (DLL_ENTRY_FPTR *_System _oss_dec_lengthp)         (void *, _sdstd_parms_defx);
    long (DLL_ENTRY_FPTR *_System _oss_dec_lintp)           (void *, _dstd_parms_defx);
    long (DLL_ENTRY_FPTR *_System _oss_encd_aiobjidp)       (void *, _std_parms_defx, void *, short);
    long (DLL_ENTRY_FPTR *_System _oss_encd_alobjidp)       (void *, _std_parms_defx, void *, short);
    long (DLL_ENTRY_FPTR *_System _oss_encd_asobjidp)       (void *, _std_parms_defx, void *, short);
    long (DLL_ENTRY_FPTR *_System _oss_encd_boolp)          (void *, _std_parms_defx, char);
    long (DLL_ENTRY_FPTR *_System _oss_encd_crealp)         (void *, _std_parms_defx, char *);
    long (DLL_ENTRY_FPTR *_System _oss_encd_gtimep)         (void *, _std_parms_defx, void *);
    long (DLL_ENTRY_FPTR *_System _oss_encd_huge_intp)      (void *, _std_parms_defx, void *);
    long (DLL_ENTRY_FPTR *_System _oss_encd_uhuge_intp)     (void *, _std_parms_defx, void *);
    long (DLL_ENTRY_FPTR *_System _oss_encd_intp)           (void *, _std_parms_defx, LONG_LONG _data);
    long (DLL_ENTRY_FPTR *_System _oss_encd_lengthp)        (void *, _std_parms_defx, unsigned long);
    long (DLL_ENTRY_FPTR *_System _oss_encd_liobjidp)       (void *, _std_parms_defx, void *, long);
    long (DLL_ENTRY_FPTR *_System _oss_encd_llobjidp)       (void *, _std_parms_defx, void *, long);
    long (DLL_ENTRY_FPTR *_System _oss_encd_lsobjidp)       (void *, _std_parms_defx, void *, long);
    long (DLL_ENTRY_FPTR *_System _oss_encd_mrealp)         (void *, _std_parms_defx, void *);
    long (DLL_ENTRY_FPTR *_System _oss_encd_nstrp)          (void *, _std_parms_defx, char *, long);
    long (DLL_ENTRY_FPTR *_System _oss_encd_opentypep)      (void *, _std_parms_defx, void *);
    long (DLL_ENTRY_FPTR *_System _oss_encd_pbitp)          (void *, _std_parms_defx, void *, long);
    long (DLL_ENTRY_FPTR *_System _oss_encd_pstrp)          (void *, _std_parms_defx, char *, long);
    long (DLL_ENTRY_FPTR *_System _oss_encd_realp)          (void *, _std_parms_defx, double);
    long (DLL_ENTRY_FPTR *_System _oss_encd_tagp)           (void *, _std_parms_defx, unsigned short, char);
    long (DLL_ENTRY_FPTR *_System _oss_encd_uanyp)          (void *, _std_parms_defx, void *);
    long (DLL_ENTRY_FPTR *_System _oss_encd_ubitp)          (void *, _std_parms_defx, void *, char, long);
    long (DLL_ENTRY_FPTR *_System _oss_encd_uintp)          (void *, _std_parms_defx, ULONG_LONG);
    long (DLL_ENTRY_FPTR *_System _oss_encd_uiobjidp)       (void *, _std_parms_defx, void *, long);
    long (DLL_ENTRY_FPTR *_System _oss_encd_ulobjidp)       (void *, _std_parms_defx, void *, long);
    long (DLL_ENTRY_FPTR *_System _oss_encd_uoctp)          (void *, _std_parms_defx, void *, char, long);
    long (DLL_ENTRY_FPTR *_System _oss_encd_usobjidp)       (void *, _std_parms_defx, void *, long);
    long (DLL_ENTRY_FPTR *_System _oss_encd_ustrp)          (void *, _std_parms_defx, void *, char, long);
    long (DLL_ENTRY_FPTR *_System _oss_encd_utimep)         (void *, _std_parms_defx, void *);
    long (DLL_ENTRY_FPTR *_System _oss_encd_vbitp)          (void *, _std_parms_defx, void *, long, char);
    long (DLL_ENTRY_FPTR *_System _oss_encd_voctp)          (void *, _std_parms_defx, void *, char, long);
    long (DLL_ENTRY_FPTR *_System _oss_encd_vstrp)          (void *, _std_parms_defx, void *, char, long);
    short (DLL_ENTRY_FPTR *_System _oss_dec_sintp)          (void *, _dstd_parms_defx);
    unsigned int (DLL_ENTRY_FPTR *_System _oss_dec_uiintp)  (void *, _dstd_parms_defx);
    unsigned long (DLL_ENTRY_FPTR *_System _oss_dec_ulintp) (void *, _dstd_parms_defx);
    unsigned short (DLL_ENTRY_FPTR *_System _oss_dec_usintp)(void *, _dstd_parms_defx);
    void (DLL_ENTRY_FPTR *_System _oss_dec_aiobjid_ptrp)    (void *, _dstd_parms_defx, char, void **, short);
    void (DLL_ENTRY_FPTR *_System _oss_dec_aiobjidp)        (void *, _dstd_parms_defx, void *, short);
    void (DLL_ENTRY_FPTR *_System _oss_dec_alobjid_ptrp)    (void *, _dstd_parms_defx, char, void **, short);
    void (DLL_ENTRY_FPTR *_System _oss_dec_alobjidp)        (void *, _dstd_parms_defx, void *, short);
    void (DLL_ENTRY_FPTR *_System _oss_dec_asobjid_ptrp)    (void *, _dstd_parms_defx, char, void **, short);
    void (DLL_ENTRY_FPTR *_System _oss_dec_asobjidp)        (void *, _dstd_parms_defx, void *, short);
    void (DLL_ENTRY_FPTR *_System _oss_dec_crealp)          (void *, _dstd_parms_defx, char, char **);
    void (DLL_ENTRY_FPTR *_System _oss_dec_frealp)          (void *, _dstd_parms_defx, float *);
    void (DLL_ENTRY_FPTR *_System _oss_dec_gtimep)          (void *, _dstd_parms_defx, void *);
    void (DLL_ENTRY_FPTR *_System _oss_dec_hintp)           (void *, _dstd_parms_defx, char, void *);
    void (DLL_ENTRY_FPTR *_System _oss_dec_liobjidp)        (void *, _dstd_parms_defx, char, void **, long);
    void (DLL_ENTRY_FPTR *_System _oss_dec_llobjidp)        (void *, _dstd_parms_defx, char, void **, long);
    void (DLL_ENTRY_FPTR *_System _oss_dec_lsobjidp)        (void *, _dstd_parms_defx, char, void **, long);
    void (DLL_ENTRY_FPTR *_System _oss_dec_mrealp)          (void *, _dstd_parms_defx, char, void *);
    void (DLL_ENTRY_FPTR *_System _oss_dec_nstr_ptrp)       (void *, _dstd_parms_defx, char, char **, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_dec_nstrp)           (void *, _dstd_parms_defx, char *, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_dec_opentypep)       (void *, _dstd_parms_defx, char, void *);
    void (DLL_ENTRY_FPTR *_System _oss_dec_pbitp)           (void *, _dstd_parms_defx, void *, unsigned long, char, char);
    void (DLL_ENTRY_FPTR *_System _oss_dec_pstrp)           (void *, _dstd_parms_defx, char *, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_dec_realp)           (void *, _dstd_parms_defx, double *);
    void (DLL_ENTRY_FPTR *_System _oss_dec_tagp)            (void *, _sdstd_parms_defx, unsigned short *, char *);
    void (DLL_ENTRY_FPTR *_System _oss_dec_uanyp)           (void *, _dstd_parms_defx, char, void *);
    void (DLL_ENTRY_FPTR *_System _oss_dec_ubitp)           (void *, _dstd_parms_defx, char, void *, char, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_dec_uiobjidp)        (void *, _dstd_parms_defx, char, void *, short);
    void (DLL_ENTRY_FPTR *_System _oss_dec_ulobjidp)        (void *, _dstd_parms_defx, char, void *, short);
    void (DLL_ENTRY_FPTR *_System _oss_dec_uoctp)           (void *, _dstd_parms_defx, char, void *, char, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_dec_usobjidp)        (void *, _dstd_parms_defx, char, void *, short);
    void (DLL_ENTRY_FPTR *_System _oss_dec_ustrp)           (void *, _dstd_parms_defx, char, void *, char, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_dec_utimep)          (void *, _dstd_parms_defx, void *);
    void (DLL_ENTRY_FPTR *_System _oss_dec_vbit_ptrp)       (void *, _dstd_parms_defx, char, void **, long, char, char);
    void (DLL_ENTRY_FPTR *_System _oss_dec_vbitp)           (void *, _dstd_parms_defx, void *, long, char, char);
    void (DLL_ENTRY_FPTR *_System _oss_dec_voct_ptrp)       (void *, _dstd_parms_defx, char, void **, char, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_dec_voctp)           (void *, _dstd_parms_defx, void *, char, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_dec_vstr_ptrp)       (void *, _dstd_parms_defx, char, void **, char, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_dec_vstrp)           (void *, _dstd_parms_defx, void *, char, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_enc_errorp)          (void *, char, int, long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_aiobjidp)       (void *, _std_parms_defx, void *, short);
    void (DLL_ENTRY_FPTR *_System _oss_enci_alobjidp)       (void *, _std_parms_defx, void *, short);
    void (DLL_ENTRY_FPTR *_System _oss_enci_asobjidp)       (void *, _std_parms_defx, void *, short);
    void (DLL_ENTRY_FPTR *_System _oss_enci_boolp)          (void *, _std_parms_defx, char);
    void (DLL_ENTRY_FPTR *_System _oss_enci_crealp)         (void *, _std_parms_defx, char *);
    void (DLL_ENTRY_FPTR *_System _oss_enci_gtimep)         (void *, _std_parms_defx, void *);
    void (DLL_ENTRY_FPTR *_System _oss_enci_intp)           (void *, _std_parms_defx, LONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_enci_lengthp)        (void *, _std_parms_defx, unsigned long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_liobjidp)       (void *, _std_parms_defx, void *, long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_llobjidp)       (void *, _std_parms_defx, void *, long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_lsobjidp)       (void *, _std_parms_defx, void *, long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_mrealp)         (void *, _std_parms_defx, void *);
    void (DLL_ENTRY_FPTR *_System _oss_enci_nstrp)          (void *, _std_parms_defx, char *, long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_opentypep)      (void *, _std_parms_defx, void *);
    void (DLL_ENTRY_FPTR *_System _oss_enci_pbitp)          (void *, _std_parms_defx, void *, long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_pstrp)          (void *, _std_parms_defx, char *, long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_realp)          (void *, _std_parms_defx, double);
    void (DLL_ENTRY_FPTR *_System _oss_enci_tagp)           (void *, _std_parms_defx, unsigned short, char);
    void (DLL_ENTRY_FPTR *_System _oss_enci_uanyp)          (void *, _std_parms_defx, void *);
    void (DLL_ENTRY_FPTR *_System _oss_enci_ubitp)          (void *, _std_parms_defx, void *, char, long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_uintp)          (void *, _std_parms_defx, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_enci_uiobjidp)       (void *, _std_parms_defx, void *, long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_ulobjidp)       (void *, _std_parms_defx, void *, long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_uoctp)          (void *, _std_parms_defx, void *, char, long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_usobjidp)       (void *, _std_parms_defx, void *, long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_ustrp)          (void *, _std_parms_defx, void *, char, long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_utimep)         (void *, _std_parms_defx, void *);
    void (DLL_ENTRY_FPTR *_System _oss_enci_vbitp)          (void *, _std_parms_defx, void *, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_enci_voctp)          (void *, _std_parms_defx, void *, char, long);
    void (DLL_ENTRY_FPTR *_System _oss_enci_vstrp)          (void *, _std_parms_defx, void *, char, long);
    void (DLL_ENTRY_FPTR *_System _oss_free_crealp)         (void *, char *);
    long (DLL_ENTRY_FPTR *_System _oss_encd_eobjidp)        (void *, _std_parms_defx, void *, long);
    void (DLL_ENTRY_FPTR *_System _oss_dec_eobjidp)         (void *, _dstd_parms_defx, char, void *, long);
    long (DLL_ENTRY_FPTR *_System _oss_write_bytes_dp)      (void *, _std_parms_defx, unsigned char *, long);
    char (DLL_ENTRY_FPTR *_System _oss_not_dfltp)           (void *, void *, void *, long, long, int);
    long (DLL_ENTRY_FPTR *_System _oss_encd_dubitp)         (void *, _std_parms_defx, void *, char, long, char);
    long (DLL_ENTRY_FPTR *_System _oss_encd_dvbitp)         (void *, _std_parms_defx, void *, long, char, char);
#endif /* SOED */
} BERTbl;

typedef struct perTbl {
    int  (DLL_ENTRY_FPTR *_System ossPerEncodep)(void *, int, void *, char **, long *, void *, unsigned, char *);
    int  (DLL_ENTRY_FPTR *_System ossPerDecodep)(void *, int *, char **, long *, void **, long *, void *, unsigned, char *);
#ifdef SOED
    int  (DLL_ENTRY_FPTR *_System perEncodeOpenTypep)(void *, int,
				void *, void **, long *, void *, unsigned);
    int  (DLL_ENTRY_FPTR *_System perDecodeOpenTypep)(void  *, int *, void **,
				long  *, void **, long *, void *, unsigned);
    void (DLL_ENTRY_FPTR *_System encode_PDUp)(void *, void *);
    void (DLL_ENTRY_FPTR *_System decode_PDUp)(void *, void *);
    void (DLL_ENTRY_FPTR *_System den_errorp)(void *, int, void *);
    void (DLL_ENTRY_FPTR *_System encode_lengthp)(void *, long, LONG_LONG, LONG_LONG);
    void (DLL_ENTRY_FPTR *_System debug_realp)(void *, char, unsigned char *, int, long);
    void (DLL_ENTRY_FPTR *_System debug_strp)(void *, unsigned char *, size_t);
    void (DLL_ENTRY_FPTR *_System append_to_field_listp)(void *, unsigned char *, LONG_LONG, int);
    int  (DLL_ENTRY_FPTR *_System numbitsp)(long);
    void (DLL_ENTRY_FPTR *_System decode_lengthp)(void *, unsigned long *, unsigned long, unsigned long, unsigned short *);
    unsigned char (DLL_ENTRY_FPTR *_System get_octetp)(void *, unsigned short, char);
    void (DLL_ENTRY_FPTR *_System set_intp)(void *, unsigned char *, unsigned int, LONG_LONG, int);
    void (DLL_ENTRY_FPTR *_System set_uintp)(void *, unsigned char *, unsigned int, ULONG_LONG, int);
    LONG_LONG (DLL_ENTRY_FPTR *_System twos_comp_intp)(unsigned char *, int);
    void (DLL_ENTRY_FPTR *_System get_octetsp)(void *, unsigned char *, LONG_LONG, unsigned short, char);
    void (DLL_ENTRY_FPTR *_System encode_normally_small_numberp)(void *, ULONG_LONG, char);
    void (DLL_ENTRY_FPTR *_System decode_normally_small_numberp)(void *, LONG_LONG *, char);
    void (DLL_ENTRY_FPTR *_System add_fieldp)(void *, char *, int, int);
    void (DLL_ENTRY_FPTR *_System output_linep)(void *);
    unsigned char (DLL_ENTRY_FPTR *_System get_bitp)(void *, unsigned short, char);
    unsigned char *(DLL_ENTRY_FPTR *_System dswapOutp)(void *, void *, void **, size_t, char, char);
    void (DLL_ENTRY_FPTR *_System debug_objidp)(void *, unsigned char *, int, int, int);
#else
    void (DLL_ENTRY_FPTR *_System _oss_penc_unconstr_intp)(void *, LONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_penc_kmstrp)       (void *, char *, ULONG_LONG, ULONG_LONG, ULONG_LONG, int, long, char);
    LONG_LONG (DLL_ENTRY_FPTR *_System _oss_pdec_unconstr_intp)(void *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_ub_kmstrp)    (void *, void *, char **, int, ULONG_LONG, ULONG_LONG, int, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_ntp_kmstrp)   (void *, char **, ULONG_LONG, ULONG_LONG, int, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_appendp)           (void *, unsigned char *, unsigned long, int);
    void (DLL_ENTRY_FPTR *_System _oss_penc_unconstr_bitp)(void *, unsigned char *, ULONG_LONG, char);
    void (DLL_ENTRY_FPTR *_System _oss_penc_constr_bitp)  (void *, unsigned char *, ULONG_LONG, ULONG_LONG, ULONG_LONG, char, char);
    void (DLL_ENTRY_FPTR *_System _oss_penc_unconstr_octp)(void *, unsigned char *, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_penc_constr_octp)  (void *, unsigned char *, ULONG_LONG, ULONG_LONG, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_penc_link_objidsp) (void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_penc_objidsp)      (void *, unsigned short *, unsigned long);
    void (DLL_ENTRY_FPTR *_System _oss_penc_link_objidlp) (void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_penc_objidlp)      (void *, unsigned long *, unsigned long);
    void (DLL_ENTRY_FPTR *_System _oss_penc_link_objidip) (void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_penc_objidip)      (void *, unsigned int *, unsigned long);
    void (DLL_ENTRY_FPTR *_System _oss_penc_nkmstrp)      (void *, char *, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_penc_opentypep)    (void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_penc_nonneg_intp)  (void *, ULONG_LONG, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_penc_realp)        (void *, double);
    void (DLL_ENTRY_FPTR *_System _oss_penc_uenump)       (void *, unsigned long, void *, void *);
    unsigned long (DLL_ENTRY_FPTR *_System _oss_penc_lengthp)(void *, ULONG_LONG, ULONG_LONG, ULONG_LONG, char);
    void (DLL_ENTRY_FPTR *_System _oss_penc_gtimep)       (void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_penc_utimep)       (void *, void *);
    unsigned char (DLL_ENTRY_FPTR *_System _oss_get_bitp) (void *, int);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_unconstr_ubitp)(void *, void *, unsigned char **, int);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_constr_ubitp) (void *, void *, unsigned char **, int, ULONG_LONG, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_unconstr_vbit_ptrp)(void *, void **, int);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_unconstr_vbitp)(void *, void *, unsigned char *, int, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_constr_voctp) (void *, void *, unsigned char  *, int, ULONG_LONG, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_unconstr_uoctp)(void *, void *, unsigned char **, int);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_unconstr_voct_ptrp)(void *, void **, int);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_constr_uoctp) (void *, void *, unsigned char **value, int, ULONG_LONG, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_constr_vbitp) (void *, void *, unsigned char *, int, ULONG_LONG, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_link_objidsp) (void *, void **);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_link_objidip) (void *, void **);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_link_objidlp) (void *, void **);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_uobjidsp)     (void *, unsigned short **, unsigned short *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_uobjidip)     (void *, unsigned int **, unsigned short *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_uobjidlp)     (void *, unsigned long **, unsigned short *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_aobjidsp)     (void *, unsigned short *, unsigned short *, unsigned short);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_aobjidip)     (void *, unsigned int *, unsigned short *, unsigned short);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_aobjidlp)     (void *, unsigned long *, unsigned short *, unsigned short);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_aobjids_ptrp) (void *, void **);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_aobjidi_ptrp) (void *, void **);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_aobjidl_ptrp) (void *, void **);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_ntp_nkmstrp)  (void *, char **);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_opentypep)    (void *, void *);
    ULONG_LONG (DLL_ENTRY_FPTR *_System _oss_pdec_nonneg_intp)(void *, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_get_bitsp)         (void *, unsigned char *, unsigned long, int);
    float  (DLL_ENTRY_FPTR *_System _oss_pdec_frealp)     (void *);
    double (DLL_ENTRY_FPTR *_System _oss_pdec_realp)      (void *);
    unsigned long (DLL_ENTRY_FPTR *_System _oss_pdec_uenump)(void *, void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_lsofp)        (void *, unsigned long *, ULONG_LONG, ULONG_LONG, unsigned char, char *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_usofp)        (void *, unsigned long *, unsigned char **, int, long, ULONG_LONG, ULONG_LONG, unsigned char, char *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_asofp)        (void *, unsigned long *, int, ULONG_LONG, ULONG_LONG, unsigned char, char *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_gtimep)       (void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_utimep)       (void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_asof_ptrp)    (void *, void **, int, long, long, char *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_nt_kmstrp)    (void *, void *, ULONG_LONG, ULONG_LONG, int, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_va_kmstrp)    (void *, void *, char *, int, ULONG_LONG, ULONG_LONG, int, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_vap_kmstrp)   (void *, void **, int, ULONG_LONG, ULONG_LONG, int, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_pad_kmstrp)   (void *, void *, ULONG_LONG, ULONG_LONG, int, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_enc_errorp)        (void *, char, int, long);
    double (DLL_ENTRY_FPTR *_System _oss_pdec_binrealp)   (void *, unsigned char, long);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_constr_bpbitp)(void *, unsigned char *, int, ULONG_LONG, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_constr_pbitp) (void *, void *, int, ULONG_LONG, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_constr_vbit_ptrp)(void *, void **, int, ULONG_LONG, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_constr_voct_ptrp)(void *, void **, int, ULONG_LONG, ULONG_LONG);
    unsigned long (DLL_ENTRY_FPTR *_System _oss_pdec_eapp)(void *, unsigned char **);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_easp)         (void *, unsigned char *, unsigned long, unsigned long);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_chrrealp)     (void *, unsigned char, long, double *, unsigned char *);
    long (DLL_ENTRY_FPTR *_System _oss_pdec_enump)        (void *, void *, void *);
    ULONG_LONG (DLL_ENTRY_FPTR *_System _oss_pdec_indeflen_intp)(void *, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_nt_nkmstrp)   (void *, char *, unsigned long);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_bmpstrp)      (void *, void *, unsigned short **, int, ULONG_LONG, ULONG_LONG, int, long, char);
    char *(DLL_ENTRY_FPTR *_System _oss_pdec_crealp)      (void *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_pad_kmstr_ptrp)(void *, char **, ULONG_LONG, ULONG_LONG, int, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_lengthp)      (void *, unsigned long *, ULONG_LONG, ULONG_LONG, char *);
    MixedReal (DLL_ENTRY_FPTR *_System _oss_pdec_mrealp)  (void *);
    void *(DLL_ENTRY_FPTR *_System _oss_pdec_popp)        (void *);
    void *(DLL_ENTRY_FPTR *_System _oss_pdec_pushp)       (void *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_uanyp)        (void *, void *);
#if INT_MAX == 2147483647
    void (DLL_ENTRY_FPTR *_System _oss_pdec_unistrp)      (void *, void *, int **, int, ULONG_LONG, ULONG_LONG, int, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_penc_unistrp)      (void *, int *, ULONG_LONG, ULONG_LONG, ULONG_LONG, int, long, char);
#else
    void (DLL_ENTRY_FPTR *_System _oss_pdec_unistrp)      (void *, void *, long **, int, ULONG_LONG, ULONG_LONG, int, long, char);
    void (DLL_ENTRY_FPTR *_System _oss_penc_unistrp)      (void *, long *, ULONG_LONG, ULONG_LONG, ULONG_LONG, int, long, char);
#endif
    LONG_LONG  (DLL_ENTRY_FPTR *_System _oss_pdec_semicon_intp)(void *, LONG_LONG);
    ULONG_LONG (DLL_ENTRY_FPTR *_System _oss_pdec_semicon_uintp)(void *, ULONG_LONG);
    ULONG_LONG (DLL_ENTRY_FPTR *_System _oss_pdec_small_intp)(void *);
    unsigned long (DLL_ENTRY_FPTR *_System _oss_pdec_small_lenp)(void *);
    long (DLL_ENTRY_FPTR *_System _oss_pdec_subidp)       (void *, long, long, long *, long *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_ub_nkmstrp)   (void *, void *, char **, int);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_unconstr_bpbitp)(void *, unsigned char *, long);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_unconstr_pbitp)(void *, void *, int);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_unconstr_hugep)(void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_vap_nkmstrp)   (void *, void **, int);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_va_nkmstrp)    (void *, void *, char *, int, unsigned long);
    void (DLL_ENTRY_FPTR *_System _oss_penc_constr_bpbitp) (void *, void *, ULONG_LONG, ULONG_LONG, char, char);
    void (DLL_ENTRY_FPTR *_System _oss_penc_constr_pbitp)  (void *, ULONG_LONG, ULONG_LONG, ULONG_LONG, ULONG_LONG, char, char);
    void (DLL_ENTRY_FPTR *_System _oss_penc_crealp)        (void *, char *);
    void (DLL_ENTRY_FPTR *_System _oss_penc_enump)         (void *, long, void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_penc_indeflen_intp) (void *, ULONG_LONG, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_penc_mrealp)        (void *, MixedReal);
    void *(DLL_ENTRY_FPTR *_System _oss_pop_globalp)       (void *);
    void *(DLL_ENTRY_FPTR *_System _oss_push_globalp)      (void *);
    void (DLL_ENTRY_FPTR *_System _oss_penc_semicon_intp)  (void *, LONG_LONG, LONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_penc_semicon_uintp) (void *, ULONG_LONG, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_penc_small_intp)    (void *, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_penc_small_lenp)    (void *, ULONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_penc_subidp)        (void *, int, unsigned long, unsigned long *);
    void (DLL_ENTRY_FPTR *_System _oss_penc_uanyp)         (void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_penc_unconstr_hugep)(void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_penc_unconstr_pbitp)(void *, ULONG_LONG, ULONG_LONG, ULONG_LONG, char);
    void (DLL_ENTRY_FPTR *_System _oss_penc_semicon_hugep) (void *, void *, LONG_LONG);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_semicon_hugep) (void *, void *, LONG_LONG);
    unsigned char (DLL_ENTRY_FPTR *_System _oss_get_octetp)(void *, int);
    void (DLL_ENTRY_FPTR *_System _oss_penc_eobjidp)       (void *, void *, long);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_eobjidp)       (void *, void *, long);
    void (DLL_ENTRY_FPTR *_System _oss_free_crealp)        (void *, char *);
    void (DLL_ENTRY_FPTR *_System _oss_pdec_sotp)          (void *);
#endif /* SOED */
} PERTbl;

typedef struct apiTbl {
    int (DLL_ENTRY_FPTR *_System ossSetEncodingRulesp)(void *, int);
    int (DLL_ENTRY_FPTR *_System ossGetEncodingRulesp)(void *);
    int (DLL_ENTRY_FPTR *_System ossSetRuntimeVersionp)(void *, int);
    int (DLL_ENTRY_FPTR *_System ossGetRuntimeVersionp)(void *);
    int (DLL_ENTRY_FPTR *_System ossSetCompatibilityFlagsp)(void *, unsigned long);
    unsigned long (DLL_ENTRY_FPTR *_System ossGetCompatibilityFlagsp)(void *);
    int (DLL_ENTRY_FPTR *_System encodep)(void *, int, void *, char **,
					long *, void *, unsigned, char *);
    int (DLL_ENTRY_FPTR *_System decodep)(void *, int *, char **, long *,
				void **, long *, void *, unsigned, char *);
    int (DLL_ENTRY_FPTR *_System ossSetDecodingLengthp)(void *, long);
    long (DLL_ENTRY_FPTR *_System ossGetDecodingLengthp)(void *);
    int (DLL_ENTRY_FPTR *_System ossSetEncodingFlagsp)(void *, unsigned long);
    int (DLL_ENTRY_FPTR *_System ossSetFlagsp)(void *, unsigned long);
    unsigned long (DLL_ENTRY_FPTR *_System ossGetEncodingFlagsp)(void *);
    int (DLL_ENTRY_FPTR *_System ossSetDecodingFlagsp)(void *, unsigned long);
    unsigned long (DLL_ENTRY_FPTR *_System ossGetDecodingFlagsp)(void *);
    char *(DLL_ENTRY_FPTR *_System ossGetErrMsgp)(void *world);
    void (DLL_ENTRY_FPTR *_System ossPrintHexp)(void *, char *, long);
    int (DLL_ENTRY_FPTR *_System ossEncodep)(void *, int, void *, void *);
    int (DLL_ENTRY_FPTR *_System ossDecodep)(void *, int *, void *, void **);
    int (DLL_ENTRY_FPTR *_System ossPrintPDUp)(void *, int, void *);
    int (DLL_ENTRY_FPTR *_System ossFreePDUp)(void *, int, void *);
    void (DLL_ENTRY_FPTR *_System ossFreeBufp)(void *, void *);
    int  (DLL_ENTRY_FPTR *ossPrintWinp)(void *, const char *,
				ossArg, ossArg, ossArg, ossArg, ossArg,
					ossArg, ossArg, ossArg, ossArg, ossArg);
    int  (DLL_ENTRY_FPTR *_System ossReadLinep)(void *, HWND, FILE *,
						char *, MEMBLOCK *, LONG);
    void (DLL_ENTRY_FPTR *_System ossFreeListp)(void *);
    void (DLL_ENTRY_FPTR *_System ossSaveTraceInfop)(void *, HWND, char *);
    void (DLL_ENTRY_FPTR *_System osstracep)(void *, void *p, size_t);
    int  (DLL_ENTRY_FPTR *_System ossOpenTraceWindowp)(void *);
    int  (DLL_ENTRY_FPTR *_System ossOpenTraceFilep)(void *, char *);
    int  (DLL_ENTRY_FPTR *_System ossCloseTraceFilep)(void *);
    long (DLL_ENTRY_FPTR *_System ossDetermineEncodingLengthp)(void *,
								int, void *);
    int  (DLL_ENTRY_FPTR *_System ossCallerIsDecoderp)(void *);
    void *(DLL_ENTRY_FPTR *_System ossMarkObjp)(void *, int, void *);
    void *(DLL_ENTRY_FPTR *_System ossUnmarkObjp)(void *, void *);
    void *(DLL_ENTRY_FPTR *_System ossGetObjp)(void *, void *);
    void *(DLL_ENTRY_FPTR *_System ossTestObjp)(void *, void *);
    void (DLL_ENTRY_FPTR *_System ossFreeObjectStackp)(void *);
    void (DLL_ENTRY_FPTR *_System ossSetTimeoutp)(void *, long);
#ifndef SOED
    void (DLL_ENTRY_FPTR *_System ossMinitp)(void *);
    void *(DLL_ENTRY_FPTR *_System _oss_dec_getmemp)(void *, long, char);
    void *(DLL_ENTRY_FPTR *_System _oss_enc_getmemp)(void *, char);
    void *(DLL_ENTRY_FPTR *_System _oss_enc_popp)(void *);
    void (DLL_ENTRY_FPTR *_System _oss_enc_pushp)(void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_releaseMemp)(void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_freeMemp)(void *, void *);
    void (DLL_ENTRY_FPTR *_System _oss_freeGlobalsp)(void *);
    void (DLL_ENTRY_FPTR *_System _oss_freeDerBlocksp)(void *);
    void (DLL_ENTRY_FPTR *_System _oss_set_outmem_ip)(void *, long,
							long *, char **);
    void (DLL_ENTRY_FPTR *_System _oss_set_outmem_dp)(void *, long,
							long *, char **);
    void (DLL_ENTRY_FPTR *_System _oss_set_outmem_pp)(void *, long *, char **);
    void (DLL_ENTRY_FPTR *_System _oss_set_outmem_pbp)(void *, long *, char **, unsigned);
    void (DLL_ENTRY_FPTR *_System _oss_beginBlockp)(void *, long, char **, long *);
    void (DLL_ENTRY_FPTR *_System _oss_nextItemp)(void *, long *);
    void (DLL_ENTRY_FPTR *_System _oss_endBlockp)(void *, char **, long *, unsigned char);
#endif /* !SOED */
    int  api;
} ApiTbl;

typedef struct cpyvalTbl {
    int (DLL_ENTRY_FPTR *_System ossCpyValuep)(void *, int, void *, void **);
} CpyValTbl;

typedef struct cmpvalTbl {
    int (DLL_ENTRY_FPTR *_System ossCmpValuep)(void *, int, void *, void *);
} CmpValTbl;

typedef struct berrealTbl {
    long (DLL_ENTRY_FPTR *_System ossBerEncodeRealp)(void *, void *,
							unsigned char *);
    long (DLL_ENTRY_FPTR *_System ossBerDecodeRealp)(void *, void *,
								long, char);
    void (DLL_ENTRY_FPTR *_System ossPrintRealp)(void *, void *,
							unsigned char *);
} BerRealTbl;

typedef struct perrealTbl {
    void (DLL_ENTRY_FPTR *_System ossPerEncodeRealp)(void *, void *);
    void (DLL_ENTRY_FPTR *_System ossPerDecodeRealp)(void *, void *);
    void (DLL_ENTRY_FPTR *_System ossPrintRealp)(void *, void *,
							unsigned char *);
} PerRealTbl;

typedef struct perpdvTbl {
    void (DLL_ENTRY_FPTR *_System ossPerEncodePDVp)(void *, void *);
    void (DLL_ENTRY_FPTR *_System ossPerDecodePDVp)(void *, void *);
} PerPDVTbl;

typedef struct berpdvTbl {
    void (DLL_ENTRY_FPTR *_System ossBerEncodePDVp)(void *, void *);
    void (DLL_ENTRY_FPTR *_System ossBerDecodePDVp)(void *, void *);
} BerPDVTbl;

typedef struct oidTbl {
int (DLL_ENTRY_FPTR *_System ossEncodedOidToAsnValp)(void *,
						const void *, void *);
int (DLL_ENTRY_FPTR *_System ossEncodedOidToDotValp)(void *,
						const void *, void *);
int (DLL_ENTRY_FPTR *_System ossAsnValToEncodedOidp)(void *,
						const char *, void *);
int (DLL_ENTRY_FPTR *_System ossDotValToEncodedOidp)(void *,
						const char *, void *);
} OidTbl;

/*
 * The structure "WinParm" is used to store DLL-related information.
 */
typedef struct functionTables {
    HWND        hWnd;           /* Handle of the window */
    LONG        index;          /* Current index into the file pointer array;
                                 * it indicates the number of lines written */
    MEMBLOCK   *memBlock;       /* Pointer to a current node of a memory
                                 * handling linked list of MEMBLOCKs */
    MEMBLOCK   *startBlock;     /* Pointer to the first node of a memory
                                 * handling linked list of MEMBLOCKs */
    short       length;         /* Length of a line that is written only
                                 * in part and no '\n' symbol was reached yet */
    short       blockNumber;    /* Current MEMBLOCK number */
    FILE       *tmpfp;          /* Temporary output file with tracing info */
    char        tmpfn[16];      /* Temporary output file name */
    BOOL        endSwitch;      /* Indicates if a '\n' symbol was reached or
                                 * not when writing a tracing info file to
                                 * a window */
    BOOL        conSwitch;      /* If FALSE, the output goes to a console,
                                 * otherwise to a window */
    BOOL	ossEncoderDecoderType; /* SOED vs. TOED */
    BOOL	cstrainNeeded;  /* If TRUE, constraint checking is needed */
    CstrainTbl *cstrainTbl;     /* Constraint checker DLL function table */
    BERTbl     *berTbl;         /* BER & DER DLL function table */
    PERTbl     *perTbl;         /* PER DLL function table */
    ApiTbl     *apiTbl;         /* Spartan/basic API DLL function table */
    CpyValTbl  *cpyvalTbl;      /* Value copier DLL function table */
    CmpValTbl  *cmpvalTbl;      /* Value comparator DLL function table */
    BerRealTbl *berrealTbl;     /* BER/DER encoder/decoder real DLL function
                                 * table */
    BerPDVTbl  *berpdvTbl;      /* PER encoder/decoder EMBEDDED PDV DLL
                                 * function table */
    PerRealTbl *perrealTbl;     /* PER encoder/decoder real DLL function table */
    PerPDVTbl  *perpdvTbl;      /* BER encoder/decoder EMBEDDED PDV DLL
                                 * function table */
    OidTbl     *oidTbl;         /* OBJECT IDENTIFIER converter DLL
                                 * function table */
    HINSTANCE   hBerDLL;        /* Handle of BER/DER encoder/decoder DLL */
    HINSTANCE   hPerDLL;        /* Handle of PER DLL */
    HINSTANCE   hCtlDLL;        /* Handle of control table/code file DLL */
    HINSTANCE   hMemDLL;        /* Handle of memory manager DLL */
    HINSTANCE   hCstrainDLL;    /* Handle of constraint checker DLL */
    HINSTANCE   hApiDLL;        /* Handle of Spartan/basic API DLL */
    HINSTANCE   hCpyvalDLL;     /* Handle of value copier DLL */
    HINSTANCE   hCmpvalDLL;     /* Handle of value comparator DLL */
    HINSTANCE   hBerrealDLL;    /* Handle of BER/DER encoder/decoder real DLL */
    HINSTANCE   hBerpdvDLL;     /* Handle of BER encoder/decoder EMBEDDED PDV
                                 * DLL */
    HINSTANCE   hPerrealDLL;    /* Handle of PER encoder/decoder real DLL */
    HINSTANCE   hPerpdvDLL;     /* Handle of PER encoder/decoder EMBEDDED PDV
                                 * DLL */
    HINSTANCE   hOidDLL;        /* Handle of OBJID converter DLL */
    MemManagerTbl *memMgrTbl;   /* Memory manager DLL function table */
    void       *reserved[10];   /* Reserved for possible future use */
} FunctionTables;

#if defined(_WINDOWS) && !defined(_WIN32) && !defined(WIN32)
#define GWL_USERDATA 0
#endif /* _WINDOWS && !_WIN32 && !WIN32 */
extern void *ctl_tbl;
#elif !defined(DLL_ENTRY)
#include <stdarg.h>
#if defined(_WIN32) || defined(WIN32)
#include <windows.h>
#define DLL_ENTRY      WINAPI
#define DLL_ENTRY_FDEF WINAPI
#define DLL_ENTRY_FPTR WINAPI
#else
#define DLL_ENTRY
#define DLL_ENTRY_FDEF
#define DLL_ENTRY_FPTR
#define PUBLIC
#endif /* _WIN32 || WIN32 */
#undef  _System
#define _System
#endif /* _WINDOWS || _WIN32 || __OS2__ || NETWARE_DLL */
#if defined(_MSC_VER) && (defined(_WIN32) || defined(WIN32))
#pragma pack(pop, ossPacking)
#elif defined(_MSC_VER) && (defined(_WINDOWS) || defined(_MSDOS))
#pragma pack()
#elif defined(__BORLANDC__) && (defined(__WIN32__) || defined(__MSDOS__))
#pragma option -a.
#elif defined(__IBMC__)
#pragma pack()
#elif defined(__WATCOMC__)
#pragma pack(pop)
#endif /* _MSC_VER && _WIN32 */
#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* OSSDLL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\oledbvbs.inc ===
<%
'----------------------------------------------------------
' Microsoft OLE DB
' Copyright (C), 1999 Microsoft Corporation.
'
' OLE DB error constant include file for VBScript
'
'----------------------------------------------------------

Const DB_E_BADACCESSORHANDLE           	= &H80040E00
Const DB_E_ROWLIMITEXCEEDED            	= &H80040E01
Const DB_E_READONLYACCESSOR            	= &H80040E02
Const DB_E_SCHEMAVIOLATION             	= &H80040E03
Const DB_E_BADROWHANDLE                	= &H80040E04
Const DB_E_OBJECTOPEN                  	= &H80040E05
Const DB_E_BADCHAPTER                  	= &H80040E06
Const DB_E_CANTCONVERTVALUE            	= &H80040E07
Const DB_E_BADBINDINFO                 	= &H80040E08
Const DB_SEC_E_PERMISSIONDENIED        	= &H80040E09
Const DB_E_NOTAREFERENCECOLUMN         	= &H80040E0A
Const DB_E_LIMITREJECTED               	= &H80040E0B
Const DB_E_NOCOMMAND                   	= &H80040E0C
Const DB_E_COSTLIMIT                   	= &H80040E0D
Const DB_E_BADBOOKMARK                 	= &H80040E0E
Const DB_E_BADLOCKMODE                 	= &H80040E0F
Const DB_E_PARAMNOTOPTIONAL            	= &H80040E10
Const DB_E_BADCOLUMNID                 	= &H80040E11
Const DB_E_BADRATIO                    	= &H80040E12
Const DB_E_BADVALUES                   	= &H80040E13
Const DB_E_ERRORSINCOMMAND             	= &H80040E14
Const DB_E_CANTCANCEL                  	= &H80040E15
Const DB_E_DIALECTNOTSUPPORTED         	= &H80040E16
Const DB_E_DUPLICATEDATASOURCE         	= &H80040E17
Const DB_E_CANNOTRESTART               	= &H80040E18
Const DB_E_NOTFOUND                    	= &H80040E19
Const DB_E_NEWLYINSERTED               	= &H80040E1B
Const DB_E_CANNOTFREE                  	= &H80040E1A
Const DB_E_GOALREJECTED                	= &H80040E1C
Const DB_E_UNSUPPORTEDCONVERSION       	= &H80040E1D
Const DB_E_BADSTARTPOSITION            	= &H80040E1E
Const DB_E_NOQUERY                     	= &H80040E1F
Const DB_E_NOTREENTRANT                	= &H80040E20
Const DB_E_ERRORSOCCURRED              	= &H80040E21
Const DB_E_NOAGGREGATION               	= &H80040E22
Const DB_E_DELETEDROW                  	= &H80040E23
Const DB_E_CANTFETCHBACKWARDS          	= &H80040E24
Const DB_E_ROWSNOTRELEASED             	= &H80040E25
Const DB_E_BADSTORAGEFLAG              	= &H80040E26
Const DB_E_BADCOMPAREOP                	= &H80040E27
Const DB_E_BADSTATUSVALUE              	= &H80040E28
Const DB_E_CANTSCROLLBACKWARDS         	= &H80040E29
Const DB_E_BADREGIONHANDLE             	= &H80040E2A
Const DB_E_NONCONTIGUOUSRANGE          	= &H80040E2B
Const DB_E_INVALIDTRANSITION           	= &H80040E2C
Const DB_E_NOTASUBREGION               	= &H80040E2D
Const DB_E_MULTIPLESTATEMENTS          	= &H80040E2E
Const DB_E_INTEGRITYVIOLATION          	= &H80040E2F
Const DB_E_BADTYPENAME                 	= &H80040E30
Const DB_E_ABORTLIMITREACHED           	= &H80040E31
Const DB_E_ROWSETINCOMMAND             	= &H80040E32
Const DB_E_CANTTRANSLATE               	= &H80040E33
Const DB_E_DUPLICATEINDEXID            	= &H80040E34
Const DB_E_NOINDEX                     	= &H80040E35
Const DB_E_INDEXINUSE                  	= &H80040E36
Const DB_E_NOTABLE                     	= &H80040E37
Const DB_E_CONCURRENCYVIOLATION        	= &H80040E38
Const DB_E_BADCOPY                     	= &H80040E39
Const DB_E_BADPRECISION                	= &H80040E3A
Const DB_E_BADSCALE                    	= &H80040E3B
Const DB_E_BADTABLEID                  	= &H80040E3C
Const DB_E_BADTYPE                     	= &H80040E3D
Const DB_E_DUPLICATECOLUMNID           	= &H80040E3E
Const DB_E_DUPLICATETABLEID            	= &H80040E3F
Const DB_E_TABLEINUSE                  	= &H80040E40
Const DB_E_NOLOCALE                    	= &H80040E41
Const DB_E_BADRECORDNUM                	= &H80040E42
Const DB_E_BOOKMARKSKIPPED             	= &H80040E43
Const DB_E_BADPROPERTYVALUE            	= &H80040E44
Const DB_E_INVALID                     	= &H80040E45
Const DB_E_BADACCESSORFLAGS            	= &H80040E46
Const DB_E_BADSTORAGEFLAGS             	= &H80040E47
Const DB_E_BYREFACCESSORNOTSUPPORTED   	= &H80040E48
Const DB_E_NULLACCESSORNOTSUPPORTED    	= &H80040E49
Const DB_E_NOTPREPARED                 	= &H80040E4A
Const DB_E_BADACCESSORTYPE             	= &H80040E4B
Const DB_E_WRITEONLYACCESSOR           	= &H80040E4C
Const DB_SEC_E_AUTH_FAILED             	= &H80040E4D
Const DB_E_CANCELED                    	= &H80040E4E
Const DB_E_CHAPTERNOTRELEASED          	= &H80040E4F
Const DB_E_BADSOURCEHANDLE             	= &H80040E50
Const DB_E_PARAMUNAVAILABLE            	= &H80040E51
Const DB_E_ALREADYINITIALIZED          	= &H80040E52
Const DB_E_NOTSUPPORTED                	= &H80040E53
Const DB_E_MAXPENDCHANGESEXCEEDED      	= &H80040E54
Const DB_E_BADORDINAL                  	= &H80040E55
Const DB_E_PENDINGCHANGES              	= &H80040E56
Const DB_E_DATAOVERFLOW                	= &H80040E57
Const DB_E_BADHRESULT                  	= &H80040E58
Const DB_E_BADLOOKUPID                 	= &H80040E59
Const DB_E_BADDYNAMICERRORID           	= &H80040E5A
Const DB_E_PENDINGINSERT               	= &H80040E5B
Const DB_E_BADCONVERTFLAG              	= &H80040E5C
Const DB_E_BADPARAMETERNAME            	= &H80040E5D
Const DB_E_MULTIPLESTORAGE             	= &H80040E5E
Const DB_E_CANTFILTER                  	= &H80040E5F
Const DB_E_CANTORDER                   	= &H80040E60
Const DB_E_NOCOLUMN                    	= &H80040E65
Const DB_E_COMMANDNOTPERSISTED         	= &H80040E67
Const DB_E_DUPLICATEID                 	= &H80040E68
Const DB_E_OBJECTCREATIONLIMITREACHED  	= &H80040E69
Const DB_E_BADINDEXID                  	= &H80040E72
Const DB_E_BADINITSTRING               	= &H80040E73
Const DB_E_NOPROVIDERSREGISTERED       	= &H80040E74
Const DB_E_MISMATCHEDPROVIDER          	= &H80040E75
Const DB_E_BADCOMMANDID                	= &H80040E76
Const DB_E_BADCONSTRAINTTYPE           	= &H80040E77
Const DB_E_BADCONSTRAINTFORM           	= &H80040E78
Const DB_E_BADDEFERRABILITY            	= &H80040E79
Const DB_E_BADMATCHTYPE                	= &H80040E80
Const DB_E_BADUPDATEDELETERULE         	= &H80040E8A
Const DB_E_BADCONSTRAINTID             	= &H80040E8B
Const DB_E_BADCOMMANDFLAGS             	= &H80040E8C
Const DB_E_OBJECTMISMATCH              	= &H80040E8D
Const DB_E_NOSOURCEOBJECT              	= &H80040E91
Const DB_E_RESOURCELOCKED              	= &H80040E92
Const DB_E_NOTCOLLECTION               	= &H80040E93
Const DB_E_READONLY                    	= &H80040E94
Const DB_E_ASYNCNOTSUPPORTED           	= &H80040E95
Const DB_E_CANNOTCONNECT               	= &H80040E96
Const DB_E_TIMEOUT                     	= &H80040E97
Const DB_E_RESOURCEEXISTS              	= &H80040E98
Const DB_E_RESOURCEOUTOFSCOPE          	= &H80040E8E
Const DB_E_DROPRESTRICTED              	= &H80040E90
Const DB_E_DUPLICATECONSTRAINTID       	= &H80040E99
Const DB_E_OUTOFSPACE                  	= &H80040E9A
Const DB_SEC_E_SAFEMODE_DENIED         	= &H80040E9B
Const DB_E_NOSTATISTIC                 	= &H80040E9C
Const DB_E_ALTERRESTRICTED             	= &H80040E9D
Const DB_E_RESOURCENOTSUPPORTED        	= &H80040E9E
Const DB_E_NOCONSTRAINT                	= &H80040E9F
Const DB_E_COLUMNUNAVAILABLE           	= &H80040EA0
Const DB_S_ROWLIMITEXCEEDED            	= &H00040EC0
Const DB_S_COLUMNTYPEMISMATCH          	= &H00040EC1
Const DB_S_TYPEINFOOVERRIDDEN          	= &H00040EC2
Const DB_S_BOOKMARKSKIPPED             	= &H00040EC3
Const DB_S_NONEXTROWSET                	= &H00040EC5
Const DB_S_ENDOFROWSET                 	= &H00040EC6
Const DB_S_COMMANDREEXECUTED           	= &H00040EC7
Const DB_S_BUFFERFULL                  	= &H00040EC8
Const DB_S_NORESULT                    	= &H00040EC9
Const DB_S_CANTRELEASE                 	= &H00040ECA
Const DB_S_GOALCHANGED                 	= &H00040ECB
Const DB_S_UNWANTEDOPERATION           	= &H00040ECC
Const DB_S_DIALECTIGNORED              	= &H00040ECD
Const DB_S_UNWANTEDPHASE               	= &H00040ECE
Const DB_S_UNWANTEDREASON              	= &H00040ECF
Const DB_S_ASYNCHRONOUS                	= &H00040ED0
Const DB_S_COLUMNSCHANGED              	= &H00040ED1
Const DB_S_ERRORSRETURNED              	= &H00040ED2
Const DB_S_BADROWHANDLE                	= &H00040ED3
Const DB_S_DELETEDROW                  	= &H00040ED4
Const DB_S_TOOMANYCHANGES              	= &H00040ED5
Const DB_S_STOPLIMITREACHED            	= &H00040ED6
Const DB_S_LOCKUPGRADED                	= &H00040ED8
Const DB_S_PROPERTIESCHANGED           	= &H00040ED9
Const DB_S_ERRORSOCCURRED              	= &H00040EDA
Const DB_S_PARAMUNAVAILABLE            	= &H00040EDB
Const DB_S_MULTIPLECHANGES             	= &H00040EDC
Const DB_S_NOTSINGLETON                	= &H00040ED7
Const DB_S_NOROWSPECIFICCOLUMNS        	= &H00040EDD
Const XACT_S_ASYNC                     	= &H0004D000
Const XACT_S_ABORTING                  	= &H0004D008
Const XACT_E_CANTRETAIN                	= &H8004D001
Const XACT_E_COMMITFAILED              	= &H8004D002
Const XACT_E_ISOLATIONLEVEL            	= &H8004D008
Const XACT_E_NOENLIST                  	= &H8004D00A
Const XACT_E_NOISORETAIN               	= &H8004D00B
Const XACT_E_NOTRANSACTION             	= &H8004D00E
Const XACT_E_NOTSUPPORTED              	= &H8004D00F
Const XACT_E_XTIONEXISTS               	= &H8004D013
Const XACT_E_INDOUBT                   	= &H8004D016
Const XACT_E_NOTIMEOUT                 	= &H8004D017
Const XACT_E_ALREADYINPROGRESS         	= &H8004D018
Const XACT_E_ABORTED                   	= &H8004D019
Const XACT_E_LOGFULL                   	= &H8004D01A
Const XACT_E_TMNOTAVAILABLE            	= &H8004D01B
Const XACT_E_CONNECTION_DOWN           	= &H8004D01C
Const XACT_E_CONNECTION_DENIED         	= &H8004D01D
Const XACT_E_CONNECTION_REQUEST_DENIED 	= &H8004D100
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\packoff.h ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    packoff.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    packoff.h is the complement to packon.h.  An inclusion of packoff.h
    MUST ALWAYS be preceded by an inclusion of packon.h, in one-to-one
    correspondence.

Author:

    Chuck Lenzmeier (chuckl) 4-Mar-1990

Revision History:

    15-Apr-1991 JohnRo
        Created lint-able variant.
--*/

#if ! (defined(lint) || defined(_lint))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#endif
#pragma pack()
#endif // ! (defined(lint) || defined(_lint))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\packon.h ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    packon.h

Abstract:

    This file turns packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    The file packoff.h is the complement to this file.

Author:

    Chuck Lenzmeier (chuckl) 4-Mar-1990

Revision History:

    15-Apr-1991 JohnRo
        Created lint-able variant.
--*/

#if ! (defined(lint) || defined(_lint))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#endif
#pragma pack(1)                 // x86, MS compiler; MIPS, MIPS compiler
#endif // ! (defined(lint) || defined(_lint))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\pcrt32.h ===
/*
 * porting macros for c runtimes - use these to let 16 bit crt calls work
 * properly on 32 bit code.
 */

#if _MSC_VER > 1000
#pragma once
#endif

#define _ffree free
#define _fmalloc malloc
#define _fmemccpy memccpy
#define _fmemchr memchr
#define _fmemcmp memcmp
#define _fmemcpy memcpy
#define _fmemicmp _memicmp
#define _fmemmove memmove
#define _fmemset memset
#define _frealloc realloc
#define _fstrcat strcat
#define _fstrchr strchr
#define _fstrcmp strcmp
#define _fstrcpy strcpy
#define _fstrcspn strcspn
#define _fstrdup _strdup
#define _fstricmp _stricmp
#define _fstrlen strlen
#define _fstrlwr _strlwr
#define _fstrncat strncat
#define _fstrncmp strncmp
#define _fstrncpy strncpy
#define _fstrnicmp _strnicmp
#define _fstrnset strnset
#define _fstrpbrk strpbrk
#define _fstrrchr strrchr
#define _fstrrev strrev
#define _fstrset strset
#define _fstrspn strspn
#define _fstrstr strstr
#define _fstrtok strtok
#define _fstrupr _strupr
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\patchbc.h ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    Patchbc.h

Abstract:

    Public header file for a module used to patch translated messages
    into arrays that constitute Windows NT file system and master boot code.

Author:

    Ted Miller (tedm) 6 May 1997

Revision History:

--*/

#if _MSC_VER > 1000
#pragma once
#endif


/*

    Various modules in the Windows NT need to lay the mbr or file system
    boot records, such as format, setup, etc. Boot code for fat, fat32,
    ntfs, and the mbr is each built into a corresponding header file
    in sdk\inc. Each header file has an array of bytes that constitute
    the boot code itself. The code has no text in it, but instead has some
    placeholders for text that need to be patched in at run-time by
    users of those header files. This allows localization of the
    boot messages without recompiles.

    As built, each boot code array has a WORD in a known place that
    indicates where in the array the messages are supposed to start.
    In addition the boot code expects to look in that same place to
    find the offset of any message it needs. Thus code in this
    module reads the value that was built into the array and replaces
    it with values of the latter type.

    For the file system boot code, the message offset table is located
    immediately before the 2-byte 55aa sig (for fat) or the 4-byte 000055aa
    sig (for fat32 and ntfs).

    Fat/Fat32 share 3 messages, whose offsets are expected to be in the
    following order in the offset table:

        NTLDR is missing
        Disk error
        Press any key to restart

    NTFS has 4 messages, whose offsets are expected to be in the following
    order in the offset table:

        A disk read error occurred
        NTLDR is missing
        NTLDR is compressed
        Press Ctrl+Alt+Del to restart

    For the master boot code, the message offset table is immediately before
    the NTFT signature and has 3 messages (thus it starts at offset 0x1b5).
    The offsets are expected to be in the following order:

        Invalid partition table
        Error loading operating system
        Missing operating system

    Finally note that to allow one-byte values to be stored in the message
    offset tables we store the offset - 256.

    The routines below return FALSE if the text is too long to fit in the
    available space.
*/

#ifdef __cplusplus
extern "C" {
#endif
BOOLEAN
PatchMessagesIntoFatBootCode(
    IN OUT PUCHAR  BootCode,
    IN     BOOLEAN IsFat32,
    IN     LPCSTR  MsgNtldrMissing,
    IN     LPCSTR  MsgDiskError,
    IN     LPCSTR  MsgPressKey
    );

BOOLEAN
PatchMessagesIntoNtfsBootCode(
    IN OUT PUCHAR  BootCode,
    IN     LPCSTR  MsgNtldrMissing,
    IN     LPCSTR  MsgNtldrCompressed,
    IN     LPCSTR  MsgDiskError,
    IN     LPCSTR  MsgPressKey
    );

BOOLEAN
PatchMessagesIntoMasterBootCode(
    IN OUT PUCHAR  BootCode,
    IN     LPCSTR  MsgInvalidTable,
    IN     LPCSTR  MsgIoError,
    IN     LPCSTR  MsgMissingOs
    );
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\pdhmsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    pdhmsg.h
       (generated from pdhmsg.mc)

Abstract:

   Event message definitions used by routines by PDH.DLL

Created:

    6-Feb-96   Bob Watson (a-robw)

Revision History:

--*/
#ifndef _PDH_MSG_H_
#define _PDH_MSG_H_
#if _MSC_VER > 1000
#pragma once
#endif

//
//     PDH DLL messages
//
//
//      Success Messages
//
//         the Win32 error value ERROR_SUCCESS is used for success returns
//
//      MESSAGE NAME FORMAT
//
//          PDH_CSTATUS_...   messages are data item status message and
//                     are returned in reference to the status of a data 
//                     item
//          PDH_...           messages are returned by FUNCTIONS only and
//                     not used as data item status values
//
//      Success Messages
//         These messages are normally returned when the operation completed
//         successfully.
//
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: PDH_CSTATUS_VALID_DATA
//
// MessageText:
//
//  The returned data is valid.
//
#define PDH_CSTATUS_VALID_DATA           ((DWORD)0x00000000L)

//
// MessageId: PDH_CSTATUS_NEW_DATA
//
// MessageText:
//
//  The return data value is valid and different from the last sample.
//
#define PDH_CSTATUS_NEW_DATA             ((DWORD)0x00000001L)

//
//        Informational messages
//
//  None
//
//      Warning Messages
//         These messages are returned when the function has completed 
//         successfully but the results may be different than expected.
//
//
// MessageId: PDH_CSTATUS_NO_MACHINE
//
// MessageText:
//
//  Unable to connect to specified machine or machine is off line.
//
#define PDH_CSTATUS_NO_MACHINE           ((DWORD)0x800007D0L)

//
// MessageId: PDH_CSTATUS_NO_INSTANCE
//
// MessageText:
//
//  The specified instance is not present.
//
#define PDH_CSTATUS_NO_INSTANCE          ((DWORD)0x800007D1L)

//
// MessageId: PDH_MORE_DATA
//
// MessageText:
//
//  There is more data to return than would fit in the supplied buffer. Allocate
//  a larger buffer and call the function again.
//
#define PDH_MORE_DATA                    ((DWORD)0x800007D2L)

//
// MessageId: PDH_CSTATUS_ITEM_NOT_VALIDATED
//
// MessageText:
//
//  The data item has been added to the query, but has not been validated nor 
//  accessed. No other status information on this data item is available.
//
#define PDH_CSTATUS_ITEM_NOT_VALIDATED   ((DWORD)0x800007D3L)

//
// MessageId: PDH_RETRY
//
// MessageText:
//
//  The selected operation should be retried.
//
#define PDH_RETRY                        ((DWORD)0x800007D4L)

//
// MessageId: PDH_NO_DATA
//
// MessageText:
//
//  No data to return.
//
#define PDH_NO_DATA                      ((DWORD)0x800007D5L)

//
// MessageId: PDH_CALC_NEGATIVE_DENOMINATOR
//
// MessageText:
//
//  A counter with a negative denominator value was detected.
//
#define PDH_CALC_NEGATIVE_DENOMINATOR    ((DWORD)0x800007D6L)

//
// MessageId: PDH_CALC_NEGATIVE_TIMEBASE
//
// MessageText:
//
//  A counter with a negative timebase value was detected.
//
#define PDH_CALC_NEGATIVE_TIMEBASE       ((DWORD)0x800007D7L)

//
// MessageId: PDH_CALC_NEGATIVE_VALUE
//
// MessageText:
//
//  A counter with a negative value was detected.
//
#define PDH_CALC_NEGATIVE_VALUE          ((DWORD)0x800007D8L)

//
// MessageId: PDH_DIALOG_CANCELLED
//
// MessageText:
//
//  The user cancelled the dialog box.
//
#define PDH_DIALOG_CANCELLED             ((DWORD)0x800007D9L)

//
// MessageId: PDH_END_OF_LOG_FILE
//
// MessageText:
//
//  The end of the log file was reached.
//
#define PDH_END_OF_LOG_FILE              ((DWORD)0x800007DAL)

//
// MessageId: PDH_ASYNC_QUERY_TIMEOUT
//
// MessageText:
//
//  Time out while waiting for asynchronous counter collection thread to end.
//
#define PDH_ASYNC_QUERY_TIMEOUT          ((DWORD)0x800007DBL)

//
// MessageId: PDH_CANNOT_SET_DEFAULT_REALTIME_DATASOURCE
//
// MessageText:
//
//  Cannot change default real-time data source. There are real-time query
//  sessions collecting counter data.
//
#define PDH_CANNOT_SET_DEFAULT_REALTIME_DATASOURCE ((DWORD)0x800007DCL)

//
//     Error Messages
//        These messages are returned when the function could not complete
//        as requested and some corrective action may be required by the
//        the caller or the user.
//
//
// MessageId: PDH_CSTATUS_NO_OBJECT
//
// MessageText:
//
//  The specified object is not found on the system.
//
#define PDH_CSTATUS_NO_OBJECT            ((DWORD)0xC0000BB8L)

//
// MessageId: PDH_CSTATUS_NO_COUNTER
//
// MessageText:
//
//  The specified counter could not be found.
//
#define PDH_CSTATUS_NO_COUNTER           ((DWORD)0xC0000BB9L)

//
// MessageId: PDH_CSTATUS_INVALID_DATA
//
// MessageText:
//
//  The returned data is not valid.
//
#define PDH_CSTATUS_INVALID_DATA         ((DWORD)0xC0000BBAL)

//
// MessageId: PDH_MEMORY_ALLOCATION_FAILURE
//
// MessageText:
//
//  A PDH function could not allocate enough temporary memory to complete the
//  operation. Close some applications or extend the pagefile and retry the 
//  function.
//
#define PDH_MEMORY_ALLOCATION_FAILURE    ((DWORD)0xC0000BBBL)

//
// MessageId: PDH_INVALID_HANDLE
//
// MessageText:
//
//  The handle is not a valid PDH object.
//
#define PDH_INVALID_HANDLE               ((DWORD)0xC0000BBCL)

//
// MessageId: PDH_INVALID_ARGUMENT
//
// MessageText:
//
//  A required argument is missing or incorrect.
//
#define PDH_INVALID_ARGUMENT             ((DWORD)0xC0000BBDL)

//
// MessageId: PDH_FUNCTION_NOT_FOUND
//
// MessageText:
//
//  Unable to find the specified function.
//
#define PDH_FUNCTION_NOT_FOUND           ((DWORD)0xC0000BBEL)

//
// MessageId: PDH_CSTATUS_NO_COUNTERNAME
//
// MessageText:
//
//  No counter was specified.
//
#define PDH_CSTATUS_NO_COUNTERNAME       ((DWORD)0xC0000BBFL)

//
// MessageId: PDH_CSTATUS_BAD_COUNTERNAME
//
// MessageText:
//
//  Unable to parse the counter path. Check the format and syntax of the 
//  specified path.
//
#define PDH_CSTATUS_BAD_COUNTERNAME      ((DWORD)0xC0000BC0L)

//
// MessageId: PDH_INVALID_BUFFER
//
// MessageText:
//
//  The buffer passed by the caller is invalid.
//
#define PDH_INVALID_BUFFER               ((DWORD)0xC0000BC1L)

//
// MessageId: PDH_INSUFFICIENT_BUFFER
//
// MessageText:
//
//  The requested data is larger than the buffer supplied. Unable to return the
//  requested data.
//
#define PDH_INSUFFICIENT_BUFFER          ((DWORD)0xC0000BC2L)

//
// MessageId: PDH_CANNOT_CONNECT_MACHINE
//
// MessageText:
//
//  Unable to connect to the requested machine.
//
#define PDH_CANNOT_CONNECT_MACHINE       ((DWORD)0xC0000BC3L)

//
// MessageId: PDH_INVALID_PATH
//
// MessageText:
//
//  The specified counter path could not be interpreted.
//
#define PDH_INVALID_PATH                 ((DWORD)0xC0000BC4L)

//
// MessageId: PDH_INVALID_INSTANCE
//
// MessageText:
//
//  The instance name could not be read from the specified counter path.
//
#define PDH_INVALID_INSTANCE             ((DWORD)0xC0000BC5L)

//
// MessageId: PDH_INVALID_DATA
//
// MessageText:
//
//  The data is not valid.
//
#define PDH_INVALID_DATA                 ((DWORD)0xC0000BC6L)

//
// MessageId: PDH_NO_DIALOG_DATA
//
// MessageText:
//
//  The dialog box data block was missing or invalid.
//
#define PDH_NO_DIALOG_DATA               ((DWORD)0xC0000BC7L)

//
// MessageId: PDH_CANNOT_READ_NAME_STRINGS
//
// MessageText:
//
//  Unable to read the counter and/or explain text from the specified machine.
//
#define PDH_CANNOT_READ_NAME_STRINGS     ((DWORD)0xC0000BC8L)

//
// MessageId: PDH_LOG_FILE_CREATE_ERROR
//
// MessageText:
//
//  Unable to create the specified log file.
//
#define PDH_LOG_FILE_CREATE_ERROR        ((DWORD)0xC0000BC9L)

//
// MessageId: PDH_LOG_FILE_OPEN_ERROR
//
// MessageText:
//
//  Unable to open the specified log file.
//
#define PDH_LOG_FILE_OPEN_ERROR          ((DWORD)0xC0000BCAL)

//
// MessageId: PDH_LOG_TYPE_NOT_FOUND
//
// MessageText:
//
//  The specified log file type has not been installed on this system.
//
#define PDH_LOG_TYPE_NOT_FOUND           ((DWORD)0xC0000BCBL)

//
// MessageId: PDH_NO_MORE_DATA
//
// MessageText:
//
//  No more data is available.
//
#define PDH_NO_MORE_DATA                 ((DWORD)0xC0000BCCL)

//
// MessageId: PDH_ENTRY_NOT_IN_LOG_FILE
//
// MessageText:
//
//  The specified record was not found in the log file.
//
#define PDH_ENTRY_NOT_IN_LOG_FILE        ((DWORD)0xC0000BCDL)

//
// MessageId: PDH_DATA_SOURCE_IS_LOG_FILE
//
// MessageText:
//
//  The specified data source is a log file.
//
#define PDH_DATA_SOURCE_IS_LOG_FILE      ((DWORD)0xC0000BCEL)

//
// MessageId: PDH_DATA_SOURCE_IS_REAL_TIME
//
// MessageText:
//
//  The specified data source is the current activity.
//
#define PDH_DATA_SOURCE_IS_REAL_TIME     ((DWORD)0xC0000BCFL)

//
// MessageId: PDH_UNABLE_READ_LOG_HEADER
//
// MessageText:
//
//  The log file header could not be read.
//
#define PDH_UNABLE_READ_LOG_HEADER       ((DWORD)0xC0000BD0L)

//
// MessageId: PDH_FILE_NOT_FOUND
//
// MessageText:
//
//  Unable to find the specified file.
//
#define PDH_FILE_NOT_FOUND               ((DWORD)0xC0000BD1L)

//
// MessageId: PDH_FILE_ALREADY_EXISTS
//
// MessageText:
//
//  There is already a file with the specified file name.
//
#define PDH_FILE_ALREADY_EXISTS          ((DWORD)0xC0000BD2L)

//
// MessageId: PDH_NOT_IMPLEMENTED
//
// MessageText:
//
//  The function referenced has not been implemented.
//
#define PDH_NOT_IMPLEMENTED              ((DWORD)0xC0000BD3L)

//
// MessageId: PDH_STRING_NOT_FOUND
//
// MessageText:
//
//  Unable to find the specified string in the list of performance name and 
//  explain text strings.
//
#define PDH_STRING_NOT_FOUND             ((DWORD)0xC0000BD4L)

//
// MessageId: PDH_UNABLE_MAP_NAME_FILES
//
// MessageText:
//
//  Unable to map to the performance counter name data files. The data 
//  will be read from the registry and stored locally.
//
#define PDH_UNABLE_MAP_NAME_FILES        ((DWORD)0x80000BD5L)

//
// MessageId: PDH_UNKNOWN_LOG_FORMAT
//
// MessageText:
//
//  The format of the specified log file is not recognized by the PDH DLL.
//
#define PDH_UNKNOWN_LOG_FORMAT           ((DWORD)0xC0000BD6L)

//
// MessageId: PDH_UNKNOWN_LOGSVC_COMMAND
//
// MessageText:
//
//  The specified Log Service command value is not recognized.
//
#define PDH_UNKNOWN_LOGSVC_COMMAND       ((DWORD)0xC0000BD7L)

//
// MessageId: PDH_LOGSVC_QUERY_NOT_FOUND
//
// MessageText:
//
//  The specified Query from the Log Service could not be found or could not
//  be opened.
//
#define PDH_LOGSVC_QUERY_NOT_FOUND       ((DWORD)0xC0000BD8L)

//
// MessageId: PDH_LOGSVC_NOT_OPENED
//
// MessageText:
//
//  The Performance Data Log Service key could not be opened. This may be due
//  to insufficient privilege or because the service has not been installed.
//
#define PDH_LOGSVC_NOT_OPENED            ((DWORD)0xC0000BD9L)

//
// MessageId: PDH_WBEM_ERROR
//
// MessageText:
//
//  An error occurred while accessing the WBEM data store.
//
#define PDH_WBEM_ERROR                   ((DWORD)0xC0000BDAL)

//
// MessageId: PDH_ACCESS_DENIED
//
// MessageText:
//
//  Unable to access the desired machine or service. Check the permissions and 
//  authentication of the log service or the interactive user session against 
//  those on the machine or service being monitored.
//
#define PDH_ACCESS_DENIED                ((DWORD)0xC0000BDBL)

//
// MessageId: PDH_LOG_FILE_TOO_SMALL
//
// MessageText:
//
//  The maximum log file size specified is too small to log the selected counters.
//  No data will be recorded in this log file. Specify a smaller set of counters
//  to log or a larger file size and retry this call.
//
#define PDH_LOG_FILE_TOO_SMALL           ((DWORD)0xC0000BDCL)

//
// MessageId: PDH_INVALID_DATASOURCE
//
// MessageText:
//
//  Cannot connect to ODBC DataSource Name.
//
#define PDH_INVALID_DATASOURCE           ((DWORD)0xC0000BDDL)

//
// MessageId: PDH_INVALID_SQLDB
//
// MessageText:
//
//  SQL Database does not contain a valid set of tables for Perfmon, use PdhCreateSQLTables.
//
#define PDH_INVALID_SQLDB                ((DWORD)0xC0000BDEL)

//
// MessageId: PDH_NO_COUNTERS
//
// MessageText:
//
//  No counters were found for this Perfmon SQL Log Set.
//
#define PDH_NO_COUNTERS                  ((DWORD)0xC0000BDFL)

//
// MessageId: PDH_SQL_ALLOC_FAILED
//
// MessageText:
//
//  Call to SQLAllocStmt failed with %1.
//
#define PDH_SQL_ALLOC_FAILED             ((DWORD)0xC0000BE0L)

//
// MessageId: PDH_SQL_ALLOCCON_FAILED
//
// MessageText:
//
//  Call to SQLAllocConnect failed with %1.
//
#define PDH_SQL_ALLOCCON_FAILED          ((DWORD)0xC0000BE1L)

//
// MessageId: PDH_SQL_EXEC_DIRECT_FAILED
//
// MessageText:
//
//  Call to SQLExecDirect failed with %1.
//
#define PDH_SQL_EXEC_DIRECT_FAILED       ((DWORD)0xC0000BE2L)

//
// MessageId: PDH_SQL_FETCH_FAILED
//
// MessageText:
//
//  Call to SQLFetch failed with %1.
//
#define PDH_SQL_FETCH_FAILED             ((DWORD)0xC0000BE3L)

//
// MessageId: PDH_SQL_ROWCOUNT_FAILED
//
// MessageText:
//
//  Call to SQLRowCount failed with %1.
//
#define PDH_SQL_ROWCOUNT_FAILED          ((DWORD)0xC0000BE4L)

//
// MessageId: PDH_SQL_MORE_RESULTS_FAILED
//
// MessageText:
//
//  Call to SQLMoreResults failed with %1.
//
#define PDH_SQL_MORE_RESULTS_FAILED      ((DWORD)0xC0000BE5L)

//
// MessageId: PDH_SQL_CONNECT_FAILED
//
// MessageText:
//
//  Call to SQLConnect failed with %1.
//
#define PDH_SQL_CONNECT_FAILED           ((DWORD)0xC0000BE6L)

//
// MessageId: PDH_SQL_BIND_FAILED
//
// MessageText:
//
//  Call to SQLBindCol failed with %1.
//
#define PDH_SQL_BIND_FAILED              ((DWORD)0xC0000BE7L)

//
// MessageId: PDH_CANNOT_CONNECT_WMI_SERVER
//
// MessageText:
//
//  Unable to connect to the WMI server on requested machine.
//
#define PDH_CANNOT_CONNECT_WMI_SERVER    ((DWORD)0xC0000BE8L)

//
// MessageId: PDH_PLA_COLLECTION_ALREADY_RUNNING
//
// MessageText:
//
//  Collection "%1!s!" is already running.
//
#define PDH_PLA_COLLECTION_ALREADY_RUNNING ((DWORD)0xC0000BE9L)

//
// MessageId: PDH_PLA_ERROR_SCHEDULE_OVERLAP
//
// MessageText:
//
//  The specified start time is after the end time.
//
#define PDH_PLA_ERROR_SCHEDULE_OVERLAP   ((DWORD)0xC0000BEAL)

//
// MessageId: PDH_PLA_COLLECTION_NOT_FOUND
//
// MessageText:
//
//  Collection "%1!s!" does not exist.
//
#define PDH_PLA_COLLECTION_NOT_FOUND     ((DWORD)0xC0000BEBL)

//
// MessageId: PDH_PLA_ERROR_SCHEDULE_ELAPSED
//
// MessageText:
//
//  The specified end time has already elapsed.
//
#define PDH_PLA_ERROR_SCHEDULE_ELAPSED   ((DWORD)0xC0000BECL)

//
// MessageId: PDH_PLA_ERROR_NOSTART
//
// MessageText:
//
//  Collection "%1!s!" did not start, check the application event log for any errors.
//
#define PDH_PLA_ERROR_NOSTART            ((DWORD)0xC0000BEDL)

//
// MessageId: PDH_PLA_ERROR_ALREADY_EXISTS
//
// MessageText:
//
//  Collection "%1!s!" already exists.
//
#define PDH_PLA_ERROR_ALREADY_EXISTS     ((DWORD)0xC0000BEEL)

//
// MessageId: PDH_PLA_ERROR_TYPE_MISMATCH
//
// MessageText:
//
//  There is a mismatch in the settings type.
//
#define PDH_PLA_ERROR_TYPE_MISMATCH      ((DWORD)0xC0000BEFL)

//
// MessageId: PDH_PLA_ERROR_FILEPATH
//
// MessageText:
//
//  The information specified does not resolve to a valid path name.
//
#define PDH_PLA_ERROR_FILEPATH           ((DWORD)0xC0000BF0L)

//
// MessageId: PDH_PLA_SERVICE_ERROR
//
// MessageText:
//
//  The "Performance Logs & Alerts" service did not respond.
//
#define PDH_PLA_SERVICE_ERROR            ((DWORD)0xC0000BF1L)

//
// MessageId: PDH_PLA_VALIDATION_ERROR
//
// MessageText:
//
//  The information passed is not valid.
//
#define PDH_PLA_VALIDATION_ERROR         ((DWORD)0xC0000BF2L)

//
// MessageId: PDH_PLA_VALIDATION_WARNING
//
// MessageText:
//
//  The information passed is not valid.
//
#define PDH_PLA_VALIDATION_WARNING       ((DWORD)0x80000BF3L)

//
// MessageId: PDH_PLA_ERROR_NAME_TOO_LONG
//
// MessageText:
//
//  The name supplied is too long.
//
#define PDH_PLA_ERROR_NAME_TOO_LONG      ((DWORD)0xC0000BF4L)

//
// MessageId: PDH_INVALID_SQL_LOG_FORMAT
//
// MessageText:
//
//  SQL log format is incorrect. Correct format is "SQL:<DSN-name>!<LogSet-Name>".
//
#define PDH_INVALID_SQL_LOG_FORMAT       ((DWORD)0xC0000BF5L)

//
// MessageId: PDH_COUNTER_ALREADY_IN_QUERY
//
// MessageText:
//
//  Performance counter in PdhAddCounter() call has already been added
//  in the performance query. This counter is ignored.
//
#define PDH_COUNTER_ALREADY_IN_QUERY     ((DWORD)0xC0000BF6L)

//
// MessageId: PDH_BINARY_LOG_CORRUPT
//
// MessageText:
//
//  Unable to read counter information and data from input binary log files.
//
#define PDH_BINARY_LOG_CORRUPT           ((DWORD)0xC0000BF7L)

//
// MessageId: PDH_LOG_SAMPLE_TOO_SMALL
//
// MessageText:
//
//  At least one of the input binary log files contain fewer than two data samples.
//
#define PDH_LOG_SAMPLE_TOO_SMALL         ((DWORD)0xC0000BF8L)

//
// MessageId: PDH_OS_LATER_VERSION
//
// MessageText:
//
//  The version of the operating system on the computer named %1 is later than that on the local computer. This operation is not available from the local computer.
//
#define PDH_OS_LATER_VERSION             ((DWORD)0xC0000BF9L)

//
// MessageId: PDH_OS_EARLIER_VERSION
//
// MessageText:
//
//  %1 supports %2 or later. Check the operating system version on the computer named %3.
//
#define PDH_OS_EARLIER_VERSION           ((DWORD)0xC0000BFAL)

//
// MessageId: PDH_INCORRECT_APPEND_TIME
//
// MessageText:
//
//  The output file must contain earlier data than the file to be appended.
//
#define PDH_INCORRECT_APPEND_TIME        ((DWORD)0xC0000BFBL)

//
// MessageId: PDH_UNMATCHED_APPEND_COUNTER
//
// MessageText:
//
//  Both files must have identical counters in order to append.
//
#define PDH_UNMATCHED_APPEND_COUNTER     ((DWORD)0xC0000BFCL)

//
// MessageId: PDH_SQL_ALTER_DETAIL_FAILED
//
// MessageText:
//
//  Cannot alter CounterDetail table layout in SQL database.
//
#define PDH_SQL_ALTER_DETAIL_FAILED      ((DWORD)0xC0000BFDL)

//
// MessageId: PDH_QUERY_PERF_DATA_TIMEOUT
//
// MessageText:
//
//  System is busy. Timeout when collecting counter data. Please retry later or increase "CollectTime" registry value.
//
#define PDH_QUERY_PERF_DATA_TIMEOUT      ((DWORD)0xC0000BFEL)

#endif //_PDH_MSG_H_
// end of generated file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\pdh.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PDH.H

Abstract:

    Header file for the Performance Data Helper (PDH) DLL functions.

--*/
#ifndef _PDH_H_
#define _PDH_H_

#if _MSC_VER > 1000
#pragma once
#endif

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning ( disable : 4201)

// system include files required for datatype and constant definitions
#include <windows.h>    // necessary for data types used in this file
#include <winperf.h>    // necessary for the Detail Level definitions

#ifdef __cplusplus
extern "C" {
#endif

typedef LONG            PDH_STATUS;

#define PDH_FUNCTION    PDH_STATUS __stdcall

// version info
#define PDH_CVERSION_WIN40  ((DWORD)(0x0400))
#define PDH_CVERSION_WIN50  ((DWORD)(0x0500))
// v1.1 revision of PDH -- basic log functions
// v1.2 of the PDH -- adds variable instance counters
// v1.3 of the PDH -- adds log service control & stubs for NT5/PDH v2 fn's
// v2.0 of the PDH -- is the NT v 5.0 B2 version
#define PDH_VERSION         ((DWORD)((PDH_CVERSION_WIN50) + 0x0003))

// define severity masks
#define IsSuccessSeverity(ErrorCode)       ((((DWORD)(ErrorCode) & (0xC0000000L)) == 0x00000000L) ? TRUE : FALSE)
#define IsInformationalSeverity(ErrorCode) ((((DWORD)(ErrorCode) & (0xC0000000L)) == 0x40000000L) ? TRUE : FALSE)
#define IsWarningSeverity(ErrorCode)       ((((DWORD)(ErrorCode) & (0xC0000000L)) == 0x80000000L) ? TRUE : FALSE)
#define IsErrorSeverity(ErrorCode)         ((((DWORD)(ErrorCode) & (0xC0000000L)) == 0xC0000000L) ? TRUE : FALSE)

#define MAX_COUNTER_PATH       256  // Maximum counter path length. This is an obsolute constance.

#define PDH_MAX_COUNTER_NAME    1024  // Maximum counter name length.
#define PDH_MAX_INSTANCE_NAME   1024  // Maximum counter instance name length.
#define PDH_MAX_COUNTER_PATH    2048  // Maximum full counter path length.
#define PDH_MAX_DATASOURCE_PATH 1024  // MAximum full counter log name length.

// data type definitions

typedef HANDLE       PDH_HCOUNTER;
typedef HANDLE       PDH_HQUERY;
typedef HANDLE       PDH_HLOG;

typedef PDH_HCOUNTER HCOUNTER;
typedef PDH_HQUERY   HQUERY;
#ifndef _LMHLOGDEFINED_
typedef PDH_HLOG     HLOG;
#endif

#ifdef INVALID_HANDLE_VALUE
#undef INVALID_HANDLE_VALUE
#define INVALID_HANDLE_VALUE  ((HANDLE)((LONG_PTR)-1))
#endif

#define H_REALTIME_DATASOURCE NULL
#define H_WBEM_DATASOURCE     INVALID_HANDLE_VALUE

typedef struct _PDH_RAW_COUNTER {
    DWORD       CStatus;
    FILETIME    TimeStamp;
    LONGLONG    FirstValue;
    LONGLONG    SecondValue;
    DWORD       MultiCount;
} PDH_RAW_COUNTER, * PPDH_RAW_COUNTER;

typedef struct _PDH_RAW_COUNTER_ITEM_A {
    LPSTR           szName;
    PDH_RAW_COUNTER RawValue;
} PDH_RAW_COUNTER_ITEM_A, * PPDH_RAW_COUNTER_ITEM_A;

typedef struct _PDH_RAW_COUNTER_ITEM_W {
    LPWSTR          szName;
    PDH_RAW_COUNTER RawValue;
} PDH_RAW_COUNTER_ITEM_W, * PPDH_RAW_COUNTER_ITEM_W;

typedef struct _PDH_FMT_COUNTERVALUE {
    DWORD    CStatus;
    union {
        LONG        longValue;
        double      doubleValue;
        LONGLONG    largeValue;
        LPCSTR      AnsiStringValue;
        LPCWSTR     WideStringValue;
    };
} PDH_FMT_COUNTERVALUE, * PPDH_FMT_COUNTERVALUE;

typedef struct _PDH_FMT_COUNTERVALUE_ITEM_A {
    LPSTR                   szName;
    PDH_FMT_COUNTERVALUE    FmtValue;
} PDH_FMT_COUNTERVALUE_ITEM_A, * PPDH_FMT_COUNTERVALUE_ITEM_A;

typedef struct _PDH_FMT_COUNTERVALUE_ITEM_W {
    LPWSTR                  szName;
    PDH_FMT_COUNTERVALUE    FmtValue;
} PDH_FMT_COUNTERVALUE_ITEM_W, * PPDH_FMT_COUNTERVALUE_ITEM_W;

typedef struct _PDH_STATISTICS {
    DWORD                   dwFormat;
    DWORD                   count;
    PDH_FMT_COUNTERVALUE    min;
    PDH_FMT_COUNTERVALUE    max;
    PDH_FMT_COUNTERVALUE    mean;
} PDH_STATISTICS, * PPDH_STATISTICS;

typedef struct _PDH_COUNTER_PATH_ELEMENTS_A {
    LPSTR   szMachineName;
    LPSTR   szObjectName;
    LPSTR   szInstanceName;
    LPSTR   szParentInstance;
    DWORD   dwInstanceIndex;
    LPSTR   szCounterName;
} PDH_COUNTER_PATH_ELEMENTS_A, * PPDH_COUNTER_PATH_ELEMENTS_A;

typedef struct _PDH_COUNTER_PATH_ELEMENTS_W {
    LPWSTR  szMachineName;
    LPWSTR  szObjectName;
    LPWSTR  szInstanceName;
    LPWSTR  szParentInstance;
    DWORD   dwInstanceIndex;
    LPWSTR  szCounterName;
} PDH_COUNTER_PATH_ELEMENTS_W, * PPDH_COUNTER_PATH_ELEMENTS_W;

typedef struct _PDH_DATA_ITEM_PATH_ELEMENTS_A {
    LPSTR   szMachineName;
    GUID    ObjectGUID;
    DWORD   dwItemId;
    LPSTR   szInstanceName;
} PDH_DATA_ITEM_PATH_ELEMENTS_A, * PPDH_DATA_ITEM_PATH_ELEMENTS_A;

typedef struct _PDH_DATA_ITEM_PATH_ELEMENTS_W {
    LPWSTR  szMachineName;
    GUID    ObjectGUID;
    DWORD   dwItemId;
    LPWSTR  szInstanceName;
} PDH_DATA_ITEM_PATH_ELEMENTS_W, * PPDH_DATA_ITEM_PATH_ELEMENTS_W;

typedef struct _PDH_COUNTER_INFO_A {
    DWORD   dwLength;
    DWORD   dwType;
    DWORD   CVersion;
    DWORD   CStatus;
    LONG    lScale;
    LONG    lDefaultScale;
    DWORD_PTR   dwUserData;
    DWORD_PTR   dwQueryUserData;
    LPSTR   szFullPath;
    union   {
        PDH_DATA_ITEM_PATH_ELEMENTS_A DataItemPath;
        PDH_COUNTER_PATH_ELEMENTS_A CounterPath;
        struct {
            LPSTR   szMachineName;
            LPSTR   szObjectName;
            LPSTR   szInstanceName;
            LPSTR   szParentInstance;
            DWORD   dwInstanceIndex;
            LPSTR   szCounterName;
        };
    };
    LPSTR   szExplainText;
    DWORD   DataBuffer[1];
} PDH_COUNTER_INFO_A, * PPDH_COUNTER_INFO_A;

typedef struct _PDH_COUNTER_INFO_W {
    DWORD   dwLength;
    DWORD   dwType;
    DWORD   CVersion;
    DWORD   CStatus;
    LONG    lScale;
    LONG    lDefaultScale;
    DWORD_PTR   dwUserData;
    DWORD_PTR   dwQueryUserData;
    LPWSTR  szFullPath;
    union   {
        PDH_DATA_ITEM_PATH_ELEMENTS_W DataItemPath;
        PDH_COUNTER_PATH_ELEMENTS_W CounterPath;
        struct {
            LPWSTR   szMachineName;
            LPWSTR   szObjectName;
            LPWSTR   szInstanceName;
            LPWSTR   szParentInstance;
            DWORD    dwInstanceIndex;
            LPWSTR   szCounterName;
        };
    };
    LPWSTR  szExplainText;
    DWORD   DataBuffer[1];
} PDH_COUNTER_INFO_W, * PPDH_COUNTER_INFO_W;

typedef struct _PDH_TIME_INFO {
    LONGLONG    StartTime;
    LONGLONG    EndTime;
    DWORD       SampleCount;
} PDH_TIME_INFO, * PPDH_TIME_INFO;

typedef struct _PDH_RAW_LOG_RECORD {
    DWORD       dwStructureSize;
    DWORD       dwRecordType;
    DWORD       dwItems;
    UCHAR       RawBytes[1];
} PDH_RAW_LOG_RECORD, * PPDH_RAW_LOG_RECORD;

typedef struct _PDH_LOG_SERVICE_QUERY_INFO_A {
    DWORD   dwSize;
    DWORD   dwFlags;
    DWORD   dwLogQuota;
    LPSTR   szLogFileCaption;
    LPSTR   szDefaultDir;
    LPSTR   szBaseFileName;
    DWORD   dwFileType;
    DWORD   dwReserved;
    union {
        struct {
            DWORD   PdlAutoNameInterval;
            DWORD   PdlAutoNameUnits;
            LPSTR   PdlCommandFilename;
            LPSTR   PdlCounterList;
            DWORD   PdlAutoNameFormat;
            DWORD   PdlSampleInterval;
            FILETIME    PdlLogStartTime;
            FILETIME    PdlLogEndTime;
        };
        struct {
            DWORD   TlNumberOfBuffers;
            DWORD   TlMinimumBuffers;
            DWORD   TlMaximumBuffers;
            DWORD   TlFreeBuffers;
            DWORD   TlBufferSize;
            DWORD   TlEventsLost;
            DWORD   TlLoggerThreadId;
            DWORD   TlBuffersWritten;
            DWORD   TlLogHandle;
            LPSTR   TlLogFileName;
        };
    };
} PDH_LOG_SERVICE_QUERY_INFO_A, * PPDH_LOG_SERVICE_QUERY_INFO_A;

typedef struct _PDH_LOG_SERVICE_QUERY_INFO_W {
    DWORD   dwSize;
    DWORD   dwFlags;
    DWORD   dwLogQuota;
    LPWSTR  szLogFileCaption;
    LPWSTR  szDefaultDir;
    LPWSTR  szBaseFileName;
    DWORD   dwFileType;
    DWORD   dwReserved;
    union {
        struct {
            DWORD   PdlAutoNameInterval;
            DWORD   PdlAutoNameUnits;
            LPWSTR  PdlCommandFilename;
            LPWSTR  PdlCounterList;
            DWORD   PdlAutoNameFormat;
            DWORD   PdlSampleInterval;
            FILETIME    PdlLogStartTime;
            FILETIME    PdlLogEndTime;
        };
        struct {
            DWORD   TlNumberOfBuffers;
            DWORD   TlMinimumBuffers;
            DWORD   TlMaximumBuffers;
            DWORD   TlFreeBuffers;
            DWORD   TlBufferSize;
            DWORD   TlEventsLost;
            DWORD   TlLoggerThreadId;
            DWORD   TlBuffersWritten;
            DWORD   TlLogHandle;
            LPWSTR  TlLogFileName;
        };
    };
} PDH_LOG_SERVICE_QUERY_INFO_W, * PPDH_LOG_SERVICE_QUERY_INFO_W;

//
//  Time value constants
//
#define MAX_TIME_VALUE ((LONGLONG) 0x7FFFFFFFFFFFFFFF)
#define MIN_TIME_VALUE ((LONGLONG) 0)

// function definitions

PDH_FUNCTION
PdhGetDllVersion(
    IN  LPDWORD lpdwVersion
);

//
//  Query Functions
//

PDH_FUNCTION
PdhOpenQueryW(
    IN  LPCWSTR      szDataSource,
    IN  DWORD_PTR    dwUserData,
    IN  PDH_HQUERY * phQuery
);

PDH_FUNCTION
PdhOpenQueryA(
    IN  LPCSTR       szDataSource,
    IN  DWORD_PTR    dwUserData,
    IN  PDH_HQUERY * phQuery
);

PDH_FUNCTION
PdhAddCounterW(
    IN  PDH_HQUERY     hQuery,
    IN  LPCWSTR        szFullCounterPath,
    IN  DWORD_PTR      dwUserData,
    IN  PDH_HCOUNTER * phCounter
);

PDH_FUNCTION
PdhAddCounterA(
    IN  PDH_HQUERY     hQuery,
    IN  LPCSTR         szFullCounterPath,
    IN  DWORD_PTR      dwUserData,
    IN  PDH_HCOUNTER * phCounter
);

PDH_FUNCTION
PdhRemoveCounter(
    IN  PDH_HCOUNTER hCounter
);

PDH_FUNCTION
PdhCollectQueryData(
    IN  PDH_HQUERY hQuery
);

PDH_FUNCTION
PdhCloseQuery(
    IN  PDH_HQUERY hQuery
);

//
//  Counter Functions
//

PDH_FUNCTION
PdhGetFormattedCounterValue(
    IN  PDH_HCOUNTER          hCounter,
    IN  DWORD                 dwFormat,
    IN  LPDWORD               lpdwType,
    IN  PPDH_FMT_COUNTERVALUE pValue
);

PDH_FUNCTION
PdhGetFormattedCounterArrayA(
    IN  PDH_HCOUNTER                 hCounter,
    IN  DWORD                        dwFormat,
    IN  LPDWORD                      lpdwBufferSize,
    IN  LPDWORD                      lpdwItemCount,
    IN  PPDH_FMT_COUNTERVALUE_ITEM_A ItemBuffer
);

PDH_FUNCTION
PdhGetFormattedCounterArrayW(
    IN  PDH_HCOUNTER                 hCounter,
    IN  DWORD                        dwFormat,
    IN  LPDWORD                      lpdwBufferSize,
    IN  LPDWORD                      lpdwItemCount,
    IN  PPDH_FMT_COUNTERVALUE_ITEM_W ItemBuffer
);

// dwFormat flag values
//
#define PDH_FMT_RAW          ((DWORD) 0x00000010)
#define PDH_FMT_ANSI         ((DWORD) 0x00000020)
#define PDH_FMT_UNICODE      ((DWORD) 0x00000040)
#define PDH_FMT_LONG         ((DWORD) 0x00000100)
#define PDH_FMT_DOUBLE       ((DWORD) 0x00000200)
#define PDH_FMT_LARGE        ((DWORD) 0x00000400)
#define PDH_FMT_NOSCALE      ((DWORD) 0x00001000)
#define PDH_FMT_1000         ((DWORD) 0x00002000)
#define PDH_FMT_NODATA       ((DWORD) 0x00004000)
#define PDH_FMT_NOCAP100     ((DWORD) 0x00008000)
#define PERF_DETAIL_COSTLY   ((DWORD) 0x00010000)
#define PERF_DETAIL_STANDARD ((DWORD) 0x0000FFFF)

PDH_FUNCTION
PdhGetRawCounterValue(
    IN  PDH_HCOUNTER      hCounter,
    IN  LPDWORD           lpdwType,
    IN  PPDH_RAW_COUNTER  pValue
);

PDH_FUNCTION
PdhGetRawCounterArrayA(
    IN  PDH_HCOUNTER            hCounter,
    IN  LPDWORD                 lpdwBufferSize,
    IN  LPDWORD                 lpdwItemCount,
    IN  PPDH_RAW_COUNTER_ITEM_A ItemBuffer
);

PDH_FUNCTION
PdhGetRawCounterArrayW(
    IN  PDH_HCOUNTER            hCounter,
    IN  LPDWORD                 lpdwBufferSize,
    IN  LPDWORD                 lpdwItemCount,
    IN  PPDH_RAW_COUNTER_ITEM_W ItemBuffer
);

PDH_FUNCTION
PdhCalculateCounterFromRawValue(
    IN  PDH_HCOUNTER          hCounter,
    IN  DWORD                 dwFormat,
    IN  PPDH_RAW_COUNTER      rawValue1,
    IN  PPDH_RAW_COUNTER      rawValue2,
    IN  PPDH_FMT_COUNTERVALUE fmtValue
);

PDH_FUNCTION
PdhComputeCounterStatistics(
    IN  PDH_HCOUNTER     hCounter,
    IN  DWORD            dwFormat,
    IN  DWORD            dwFirstEntry,
    IN  DWORD            dwNumEntries,
    IN  PPDH_RAW_COUNTER lpRawValueArray,
    IN  PPDH_STATISTICS  data
);

PDH_FUNCTION
PdhGetCounterInfoW(
    IN  PDH_HCOUNTER        hCounter,
    IN  BOOLEAN             bRetrieveExplainText,
    IN  LPDWORD             pdwBufferSize,
    IN  PPDH_COUNTER_INFO_W lpBuffer
);

PDH_FUNCTION
PdhGetCounterInfoA(
    IN  PDH_HCOUNTER        hCounter,
    IN  BOOLEAN             bRetrieveExplainText,
    IN  LPDWORD             pdwBufferSize,
    IN  PPDH_COUNTER_INFO_A lpBuffer
);

#define PDH_MAX_SCALE  (7L)
#define PDH_MIN_SCALE (-7L)

PDH_FUNCTION
PdhSetCounterScaleFactor(
    IN  PDH_HCOUNTER hCounter,
    IN  LONG         lFactor
);
//
//   Browsing and enumeration functions
//
PDH_FUNCTION
PdhConnectMachineW(
    IN  LPCWSTR szMachineName
);

PDH_FUNCTION
PdhConnectMachineA(
    IN  LPCSTR szMachineName
);

PDH_FUNCTION
PdhEnumMachinesW(
    IN  LPCWSTR szDataSource,
    IN  LPWSTR  mszMachineList,
    IN  LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhEnumMachinesA(
    IN  LPCSTR  szDataSource,
    IN  LPSTR   mszMachineList,
    IN  LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhEnumObjectsW(
    IN  LPCWSTR szDataSource,
    IN  LPCWSTR szMachineName,
    IN  LPWSTR  mszObjectList,
    IN  LPDWORD pcchBufferSize,
    IN  DWORD   dwDetailLevel,
    IN  BOOL    bRefresh
);

PDH_FUNCTION
PdhEnumObjectsA(
    IN  LPCSTR  szDataSource,
    IN  LPCSTR  szMachineName,
    IN  LPSTR   mszObjectList,
    IN  LPDWORD pcchBufferSize,
    IN  DWORD   dwDetailLevel,
    IN  BOOL    bRefresh
);

PDH_FUNCTION
PdhEnumObjectItemsW(
    IN  LPCWSTR szDataSource,
    IN  LPCWSTR szMachineName,
    IN  LPCWSTR szObjectName,
    IN  LPWSTR  mszCounterList,
    IN  LPDWORD pcchCounterListLength,
    IN  LPWSTR  mszInstanceList,
    IN  LPDWORD pcchInstanceListLength,
    IN  DWORD   dwDetailLevel,
    IN  DWORD   dwFlags
);

PDH_FUNCTION
PdhEnumObjectItemsA(
    IN  LPCSTR  szDataSource,
    IN  LPCSTR  szMachineName,
    IN  LPCSTR  szObjectName,
    IN  LPSTR   mszCounterList,
    IN  LPDWORD pcchCounterListLength,
    IN  LPSTR   mszInstanceList,
    IN  LPDWORD pcchInstanceListLength,
    IN  DWORD   dwDetailLevel,
    IN  DWORD   dwFlags
);

#define PDH_OBJECT_HAS_INSTANCES    ((DWORD) 0x00000001)

PDH_FUNCTION
PdhMakeCounterPathW(
    IN  PPDH_COUNTER_PATH_ELEMENTS_W pCounterPathElements,
    IN  LPWSTR                       szFullPathBuffer,
    IN  LPDWORD                      pcchBufferSize,
    IN  DWORD                        dwFlags
);

PDH_FUNCTION
PdhMakeCounterPathA(
    IN  PPDH_COUNTER_PATH_ELEMENTS_A pCounterPathElements,
    IN  LPSTR                        szFullPathBuffer,
    IN  LPDWORD                      pcchBufferSize,
    IN  DWORD                        dwFlags
);

PDH_FUNCTION
PdhParseCounterPathW(
    IN  LPCWSTR                      szFullPathBuffer,
    IN  PPDH_COUNTER_PATH_ELEMENTS_W pCounterPathElements,
    IN  LPDWORD                      pdwBufferSize,
    IN  DWORD                        dwFlags
);

PDH_FUNCTION
PdhParseCounterPathA(
    IN  LPCSTR                       szFullPathBuffer,
    IN  PPDH_COUNTER_PATH_ELEMENTS_A pCounterPathElements,
    IN  LPDWORD                      pdwBufferSize,
    IN  DWORD                        dwFlags
);

#define PDH_PATH_WBEM_RESULT ((DWORD) 0x00000001)
#define PDH_PATH_WBEM_INPUT  ((DWORD) 0x00000002)

#define PDH_PATH_LANG_FLAGS(LangId, Flags)  ((DWORD)(((LangId & 0x0000FFFF) << 16) | (Flags & 0x0000FFFF)))

PDH_FUNCTION
PdhParseInstanceNameW(
    IN  LPCWSTR szInstanceString,
    IN  LPWSTR  szInstanceName,
    IN  LPDWORD pcchInstanceNameLength,
    IN  LPWSTR  szParentName,
    IN  LPDWORD pcchParentNameLength,
    IN  LPDWORD lpIndex
);

PDH_FUNCTION
PdhParseInstanceNameA(
    IN  LPCSTR  szInstanceString,
    IN  LPSTR   szInstanceName,
    IN  LPDWORD pcchInstanceNameLength,
    IN  LPSTR   szParentName,
    IN  LPDWORD pcchParentNameLength,
    IN  LPDWORD lpIndex
);

PDH_FUNCTION
PdhValidatePathW(
    IN  LPCWSTR szFullPathBuffer
);

PDH_FUNCTION
PdhValidatePathA(
    IN  LPCSTR szFullPathBuffer
);

PDH_FUNCTION
PdhGetDefaultPerfObjectW(
    IN  LPCWSTR szDataSource,
    IN  LPCWSTR szMachineName,
    IN  LPWSTR  szDefaultObjectName,
    IN  LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfObjectA(
    IN  LPCSTR  szDataSource,
    IN  LPCSTR  szMachineName,
    IN  LPSTR   szDefaultObjectName,
    IN  LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfCounterW(
    IN  LPCWSTR szDataSource,
    IN  LPCWSTR szMachineName,
    IN  LPCWSTR szObjectName,
    IN  LPWSTR  szDefaultCounterName,
    IN  LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfCounterA(
    IN  LPCSTR  szDataSource,
    IN  LPCSTR  szMachineName,
    IN  LPCSTR  szObjectName,
    IN  LPSTR   szDefaultCounterName,
    IN  LPDWORD pcchBufferSize
);

typedef PDH_STATUS (__stdcall * CounterPathCallBack)(DWORD_PTR);

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning ( disable : 4214 )  // Disable warning messages
typedef struct _BrowseDlgConfig_HW {
    // Configuration flags
    DWORD   bIncludeInstanceIndex:1,
            bSingleCounterPerAdd:1,
            bSingleCounterPerDialog:1,
            bLocalCountersOnly:1,
            bWildCardInstances:1,
            bHideDetailBox:1,
            bInitializePath:1,
            bDisableMachineSelection:1,
            bIncludeCostlyObjects:1,
            bShowObjectBrowser:1,
            bReserved:22;

    HWND                hWndOwner;
    PDH_HLOG            hDataSource;
    LPWSTR              szReturnPathBuffer;
    DWORD               cchReturnPathLength;
    CounterPathCallBack pCallBack;
    DWORD_PTR           dwCallBackArg;
    PDH_STATUS          CallBackStatus;
    DWORD               dwDefaultDetailLevel;
    LPWSTR              szDialogBoxCaption;
} PDH_BROWSE_DLG_CONFIG_HW, * PPDH_BROWSE_DLG_CONFIG_HW;

typedef struct _BrowseDlgConfig_HA {
    // Configuration flags
    DWORD   bIncludeInstanceIndex:1,
            bSingleCounterPerAdd:1,
            bSingleCounterPerDialog:1,
            bLocalCountersOnly:1,
            bWildCardInstances:1,
            bHideDetailBox:1,
            bInitializePath:1,
            bDisableMachineSelection:1,
            bIncludeCostlyObjects:1,
            bShowObjectBrowser:1,
            bReserved:22;

    HWND                hWndOwner;
    PDH_HLOG            hDataSource;
    LPSTR               szReturnPathBuffer;
    DWORD               cchReturnPathLength;
    CounterPathCallBack pCallBack;
    DWORD_PTR           dwCallBackArg;
    PDH_STATUS          CallBackStatus;
    DWORD               dwDefaultDetailLevel;
    LPSTR               szDialogBoxCaption;
} PDH_BROWSE_DLG_CONFIG_HA, * PPDH_BROWSE_DLG_CONFIG_HA;

typedef struct _BrowseDlgConfig_W {
    // Configuration flags
    DWORD   bIncludeInstanceIndex:1,
            bSingleCounterPerAdd:1,
            bSingleCounterPerDialog:1,
            bLocalCountersOnly:1,
            bWildCardInstances:1,
            bHideDetailBox:1,
            bInitializePath:1,
            bDisableMachineSelection:1,
            bIncludeCostlyObjects:1,
            bShowObjectBrowser:1,
            bReserved:22;

    HWND                hWndOwner;
    LPWSTR              szDataSource;
    LPWSTR              szReturnPathBuffer;
    DWORD               cchReturnPathLength;
    CounterPathCallBack pCallBack;
    DWORD_PTR           dwCallBackArg;
    PDH_STATUS          CallBackStatus;
    DWORD               dwDefaultDetailLevel;
    LPWSTR              szDialogBoxCaption;
} PDH_BROWSE_DLG_CONFIG_W, * PPDH_BROWSE_DLG_CONFIG_W;

typedef struct _BrowseDlgConfig_A {
    // Configuration flags
    DWORD   bIncludeInstanceIndex:1,
            bSingleCounterPerAdd:1,
            bSingleCounterPerDialog:1,
            bLocalCountersOnly:1,
            bWildCardInstances:1,
            bHideDetailBox:1,
            bInitializePath:1,
            bDisableMachineSelection:1,
            bIncludeCostlyObjects:1,
            bShowObjectBrowser:1,
            bReserved:22;

    HWND                hWndOwner;
    LPSTR               szDataSource;
    LPSTR               szReturnPathBuffer;
    DWORD               cchReturnPathLength;
    CounterPathCallBack pCallBack;
    DWORD_PTR           dwCallBackArg;
    PDH_STATUS          CallBackStatus;
    DWORD               dwDefaultDetailLevel;
    LPSTR               szDialogBoxCaption;
} PDH_BROWSE_DLG_CONFIG_A, * PPDH_BROWSE_DLG_CONFIG_A;
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning ( default : 4214 )
#endif

PDH_FUNCTION
PdhBrowseCountersW(
    IN  PPDH_BROWSE_DLG_CONFIG_W pBrowseDlgData
);

PDH_FUNCTION
PdhBrowseCountersA(
    IN  PPDH_BROWSE_DLG_CONFIG_A pBrowseDlgData
);

PDH_FUNCTION
PdhExpandCounterPathW(
    IN  LPCWSTR szWildCardPath,
    IN  LPWSTR  mszExpandedPathList,
    IN  LPDWORD pcchPathListLength
);

PDH_FUNCTION
PdhExpandCounterPathA(
    IN  LPCSTR  szWildCardPath,
    IN  LPSTR   mszExpandedPathList,
    IN  LPDWORD pcchPathListLength
);

//
//  v2.0 functions
//
PDH_FUNCTION
PdhLookupPerfNameByIndexW(
    IN  LPCWSTR szMachineName,
    IN  DWORD   dwNameIndex,
    IN  LPWSTR  szNameBuffer,
    IN  LPDWORD pcchNameBufferSize
);

PDH_FUNCTION
PdhLookupPerfNameByIndexA(
    IN  LPCSTR  szMachineName,
    IN  DWORD   dwNameIndex,
    IN  LPSTR   szNameBuffer,
    IN  LPDWORD pcchNameBufferSize
);

PDH_FUNCTION
PdhLookupPerfIndexByNameW(
    IN  LPCWSTR szMachineName,
    IN  LPCWSTR szNameBuffer,
    IN  LPDWORD pdwIndex
);

PDH_FUNCTION
PdhLookupPerfIndexByNameA(
    IN  LPCSTR  szMachineName,
    IN  LPCSTR  szNameBuffer,
    IN  LPDWORD pdwIndex
);

#define PDH_NOEXPANDCOUNTERS    1
#define PDH_NOEXPANDINSTANCES   2
#define PDH_REFRESHCOUNTERS     4

PDH_FUNCTION
PdhExpandWildCardPathA(
    IN  LPCSTR  szDataSource,
    IN  LPCSTR  szWildCardPath,
    IN  LPSTR   mszExpandedPathList,
    IN  LPDWORD pcchPathListLength,
    IN  DWORD   dwFlags
);

PDH_FUNCTION
PdhExpandWildCardPathW(
    IN  LPCWSTR szDataSource,
    IN  LPCWSTR szWildCardPath,
    IN  LPWSTR  mszExpandedPathList,
    IN  LPDWORD pcchPathListLength,
    IN  DWORD   dwFlags
);

//
//   Logging Functions
//

#define PDH_LOG_READ_ACCESS      ((DWORD) 0x00010000)
#define PDH_LOG_WRITE_ACCESS     ((DWORD) 0x00020000)
#define PDH_LOG_UPDATE_ACCESS    ((DWORD) 0x00040000)
#define PDH_LOG_ACCESS_MASK      ((DWORD) 0x000F0000)

#define PDH_LOG_CREATE_NEW       ((DWORD) 0x00000001)
#define PDH_LOG_CREATE_ALWAYS    ((DWORD) 0x00000002)
#define PDH_LOG_OPEN_ALWAYS      ((DWORD) 0x00000003)
#define PDH_LOG_OPEN_EXISTING    ((DWORD) 0x00000004)
#define PDH_LOG_CREATE_MASK      ((DWORD) 0x0000000F)

#define PDH_LOG_OPT_USER_STRING  ((DWORD) 0x01000000)
#define PDH_LOG_OPT_CIRCULAR     ((DWORD) 0x02000000)
#define PDH_LOG_OPT_MAX_IS_BYTES ((DWORD) 0x04000000)
#define PDH_LOG_OPT_APPEND       ((DWORD) 0x08000000)
#define PDH_LOG_OPT_MASK         ((DWORD) 0x0F000000)

#define PDH_LOG_TYPE_UNDEFINED      0
#define PDH_LOG_TYPE_CSV            1
#define PDH_LOG_TYPE_TSV            2
//#define PDH_LOG_TYPE_BINARY         3 // this is the retired binary format
#define PDH_LOG_TYPE_TRACE_KERNEL   4
#define PDH_LOG_TYPE_TRACE_GENERIC  5
#define PDH_LOG_TYPE_PERFMON        6
#define PDH_LOG_TYPE_SQL            7
#define PDH_LOG_TYPE_BINARY         8

PDH_FUNCTION
PdhOpenLogW(
    IN  LPCWSTR     szLogFileName,
    IN  DWORD       dwAccessFlags,
    IN  LPDWORD     lpdwLogType,
    IN  PDH_HQUERY  hQuery,
    IN  DWORD       dwMaxSize,
    IN  LPCWSTR     szUserCaption,
    IN  PDH_HLOG  * phLog
);

PDH_FUNCTION
PdhOpenLogA(
    IN  LPCSTR       szLogFileName,
    IN  DWORD        dwAccessFlags,
    IN  LPDWORD      lpdwLogType,
    IN  PDH_HQUERY   hQuery,
    IN  DWORD        dwMaxSize,
    IN  LPCSTR       szUserCaption,
    IN  PDH_HLOG   * phLog
);

PDH_FUNCTION
PdhUpdateLogW(
    IN  PDH_HLOG hLog,
    IN  LPCWSTR  szUserString
);

PDH_FUNCTION
PdhUpdateLogA(
    IN  PDH_HLOG hLog,
    IN  LPCSTR   szUserString
);

PDH_FUNCTION
PdhUpdateLogFileCatalog(
    IN  PDH_HLOG hLog
);

PDH_FUNCTION
PdhGetLogFileSize(
    IN  PDH_HLOG   hLog,
    IN  LONGLONG * llSize
);

PDH_FUNCTION
PdhCloseLog(
    IN  PDH_HLOG hLog,
    IN  DWORD    dwFlags
);

#define PDH_FLAGS_CLOSE_QUERY   ((DWORD) 0x00000001)
//
//  Data source selection dialog
//
#define PDH_FLAGS_FILE_BROWSER_ONLY ((DWORD) 0x00000001)

PDH_FUNCTION
PdhSelectDataSourceW(
    IN  HWND    hWndOwner,
    IN  DWORD   dwFlags,
    IN  LPWSTR  szDataSource,
    IN  LPDWORD pcchBufferLength
);

PDH_FUNCTION
PdhSelectDataSourceA(
    IN  HWND    hWndOwner,
    IN  DWORD   dwFlags,
    IN  LPSTR   szDataSource,
    IN  LPDWORD pcchBufferLength
);

BOOL
PdhIsRealTimeQuery(
    IN  PDH_HQUERY hQuery
);

PDH_FUNCTION
PdhSetQueryTimeRange(
    IN  PDH_HQUERY     hQuery,
    IN  PPDH_TIME_INFO pInfo
);

PDH_FUNCTION
PdhGetDataSourceTimeRangeW(
    IN  LPCWSTR        szDataSource,
    IN  LPDWORD        pdwNumEntries,
    IN  PPDH_TIME_INFO pInfo,
    IN  LPDWORD        pdwBufferSize
);

PDH_FUNCTION
PdhGetDataSourceTimeRangeA(
    IN  LPCSTR         szDataSource,
    IN  LPDWORD        pdwNumEntries,
    IN  PPDH_TIME_INFO pInfo,
    IN  LPDWORD        dwBufferSize
);

PDH_FUNCTION
PdhCollectQueryDataEx(
    IN  PDH_HQUERY hQuery,
    IN  DWORD      dwIntervalTime,
    IN  HANDLE     hNewDataEvent
);

PDH_FUNCTION
PdhFormatFromRawValue(
    IN  DWORD                   dwCounterType,
    IN  DWORD                   dwFormat,
    IN  LONGLONG              * pTimeBase,
    IN  PPDH_RAW_COUNTER        pRawValue1,
    IN  PPDH_RAW_COUNTER        pRawValue2,
    IN  PPDH_FMT_COUNTERVALUE   pFmtValue
);

PDH_FUNCTION
PdhGetCounterTimeBase(
    IN  PDH_HCOUNTER   hCounter,
    IN  LONGLONG     * pTimeBase
);

PDH_FUNCTION
PdhReadRawLogRecord(
    IN  PDH_HLOG            hLog,
    IN  FILETIME            ftRecord,
    IN  PPDH_RAW_LOG_RECORD pRawLogRecord,
    IN  LPDWORD             pdwBufferLength
);


#define DATA_SOURCE_REGISTRY ((DWORD) 0x00000001)
#define DATA_SOURCE_LOGFILE  ((DWORD) 0x00000002)
#define DATA_SOURCE_WBEM     ((DWORD) 0x00000004)

PDH_FUNCTION
PdhSetDefaultRealTimeDataSource(
    IN  DWORD dwDataSourceId
);

// Extended API for WMI event trace logfile format
//
PDH_FUNCTION
PdhBindInputDataSourceW(
    IN  PDH_HLOG * phDataSource,
    IN  LPCWSTR    LogFileNameList
);

PDH_FUNCTION
PdhBindInputDataSourceA(
    IN  PDH_HLOG * phDataSource,
    IN  LPCSTR     LogFileNameList
);

PDH_FUNCTION
PdhOpenQueryH(
    IN  PDH_HLOG     hDataSource,
    IN  DWORD_PTR    dwUserData,
    IN  PDH_HQUERY * phQuery
);

PDH_FUNCTION
PdhEnumMachinesHW(
    IN  PDH_HLOG hDataSource,
    IN  LPWSTR   mszMachineList,
    IN  LPDWORD  pcchBufferSize
);

PDH_FUNCTION
PdhEnumMachinesHA(
    IN  PDH_HLOG hDataSource,
    IN  LPSTR    mszMachineList,
    IN  LPDWORD  pcchBufferSize
);

PDH_FUNCTION
PdhEnumObjectsHW(
    IN  PDH_HLOG hDataSource,
    IN  LPCWSTR  szMachineName,
    IN  LPWSTR   mszObjectList,
    IN  LPDWORD  pcchBufferSize,
    IN  DWORD    dwDetailLevel,
    IN  BOOL     bRefresh
) ;

PDH_FUNCTION
PdhEnumObjectsHA(
    IN  PDH_HLOG hDataSource,
    IN  LPCSTR   szMachineName,
    IN  LPSTR    mszObjectList,
    IN  LPDWORD  pcchBufferSize,
    IN  DWORD    dwDetailLevel,
    IN  BOOL     bRefresh
);

PDH_FUNCTION
PdhEnumObjectItemsHW(
    IN  PDH_HLOG hDataSource,
    IN  LPCWSTR  szMachineName,
    IN  LPCWSTR  szObjectName,
    IN  LPWSTR   mszCounterList,
    IN  LPDWORD  pcchCounterListLength,
    IN  LPWSTR   mszInstanceList,
    IN  LPDWORD  pcchInstanceListLength,
    IN  DWORD    dwDetailLevel,
    IN  DWORD    dwFlags
);

PDH_FUNCTION
PdhEnumObjectItemsHA(
    IN  PDH_HLOG hDataSource,
    IN  LPCSTR   szMachineName,
    IN  LPCSTR   szObjectName,
    IN  LPSTR    mszCounterList,
    IN  LPDWORD  pcchCounterListLength,
    IN  LPSTR    mszInstanceList,
    IN  LPDWORD  pcchInstanceListLength,
    IN  DWORD    dwDetailLevel,
    IN  DWORD    dwFlags
);

PDH_FUNCTION
PdhExpandWildCardPathHW(
    IN  PDH_HLOG hDataSource,
    IN  LPCWSTR  szWildCardPath,
    IN  LPWSTR   mszExpandedPathList,
    IN  LPDWORD  pcchPathListLength,
    IN  DWORD    dwFlags
);

PDH_FUNCTION
PdhExpandWildCardPathHA(
    IN  PDH_HLOG hDataSource,
    IN  LPCSTR   szWildCardPath,
    IN  LPSTR    mszExpandedPathList,
    IN  LPDWORD  pcchPathListLength,
    IN  DWORD    dwFlags
);

PDH_FUNCTION
PdhGetDataSourceTimeRangeH(
    IN  PDH_HLOG       hDataSource,
    IN  LPDWORD        pdwNumEntries,
    IN  PPDH_TIME_INFO pInfo,
    IN  LPDWORD        pdwBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfObjectHW(
    IN  PDH_HLOG hDataSource,
    IN  LPCWSTR  szMachineName,
    IN  LPWSTR   szDefaultObjectName,
    IN  LPDWORD  pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfObjectHA(
    IN  PDH_HLOG hDataSource,
    IN  LPCSTR   szMachineName,
    IN  LPSTR    szDefaultObjectName,
    IN  LPDWORD  pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfCounterHW(
    IN  PDH_HLOG hDataSource,
    IN  LPCWSTR  szMachineName,
    IN  LPCWSTR  szObjectName,
    IN  LPWSTR   szDefaultCounterName,
    IN  LPDWORD  pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfCounterHA(
    IN  PDH_HLOG hDataSource,
    IN  LPCSTR   szMachineName,
    IN  LPCSTR   szObjectName,
    IN  LPSTR    szDefaultCounterName,
    IN  LPDWORD  pcchBufferSize
);

PDH_FUNCTION
PdhBrowseCountersHW(
    IN  PPDH_BROWSE_DLG_CONFIG_HW pBrowseDlgData
);

PDH_FUNCTION
PdhBrowseCountersHA(
    IN  PPDH_BROWSE_DLG_CONFIG_HA pBrowseDlgData
);

//Check that a DSN points to a database that contains the correct Perfmon tables.
PDH_FUNCTION
PdhVerifySQLDBW(
    IN  LPCWSTR szDataSource
);

PDH_FUNCTION
PdhVerifySQLDBA(
    IN  LPCSTR szDataSource
);


//Create the correct perfmon tables in the database pointed to by a DSN.
PDH_FUNCTION
PdhCreateSQLTablesW(
    IN  LPCWSTR szDataSource
);  

PDH_FUNCTION
PdhCreateSQLTablesA(
    IN  LPCSTR szDataSource
);     

//Return the list of Log set names in the database pointed to by the DSN.
PDH_FUNCTION
PdhEnumLogSetNamesW(
    IN  LPCWSTR szDataSource,
    IN  LPWSTR  mszDataSetNameList,
    IN  LPDWORD pcchBufferLength
);

PDH_FUNCTION
PdhEnumLogSetNamesA(
    IN  LPCSTR  szDataSource,
    IN  LPSTR   mszDataSetNameList,
    IN  LPDWORD pcchBufferLength
);

//Retrieve the GUID for an open Log Set
PDH_FUNCTION
PdhGetLogSetGUID(
    IN  PDH_HLOG   hLog,             
    IN  GUID     * pGuid,
    IN  int      * pRunId
);

//Set the RunID for an open Log Set
PDH_FUNCTION
PdhSetLogSetRunID(
    IN  PDH_HLOG hLog,             
    IN  int      RunId
);

//
//   Unicode/ANSI compatibility section
//
#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE
#endif
#endif

#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE
#endif
#endif

#ifdef UNICODE
// start of UNICODE definitions
#define PdhOpenQuery                PdhOpenQueryW
#define PdhAddCounter               PdhAddCounterW
#define PdhGetCounterInfo           PdhGetCounterInfoW
#define PDH_COUNTER_INFO            PDH_COUNTER_INFO_W
#define PPDH_COUNTER_INFO           PPDH_COUNTER_INFO_W
#define PdhConnectMachine           PdhConnectMachineW
#define PdhEnumMachines             PdhEnumMachinesW
#define PdhEnumObjects              PdhEnumObjectsW
#define PdhEnumObjectItems          PdhEnumObjectItemsW
#define PdhMakeCounterPath          PdhMakeCounterPathW
#define PDH_COUNTER_PATH_ELEMENTS   PDH_COUNTER_PATH_ELEMENTS_W
#define PPDH_COUNTER_PATH_ELEMENTS  PPDH_COUNTER_PATH_ELEMENTS_W
#define PdhParseCounterPath         PdhParseCounterPathW
#define PdhParseInstanceName        PdhParseInstanceNameW
#define PdhValidatePath             PdhValidatePathW
#define PdhGetDefaultPerfObject     PdhGetDefaultPerfObjectW
#define PdhGetDefaultPerfCounter    PdhGetDefaultPerfCounterW
#define PdhBrowseCounters           PdhBrowseCountersW
#define PdhBrowseCountersH          PdhBrowseCountersHW
#define PDH_BROWSE_DLG_CONFIG       PDH_BROWSE_DLG_CONFIG_W
#define PPDH_BROWSE_DLG_CONFIG      PPDH_BROWSE_DLG_CONFIG_W
#define PDH_BROWSE_DLG_CONFIG_H     PDH_BROWSE_DLG_CONFIG_HW
#define PPDH_BROWSE_DLG_CONFIG_H    PPDH_BROWSE_DLG_CONFIG_HW
#define PdhExpandCounterPath        PdhExpandCounterPathW
// v2.0 functions
#define PDH_FMT_COUNTERVALUE_ITEM   PDH_FMT_COUNTERVALUE_ITEM_W
#define PPDH_FMT_COUNTERVALUE_ITEM  PPDH_FMT_COUNTERVALUE_ITEM_W
#define PDH_RAW_COUNTER_ITEM        PDH_RAW_COUNTER_ITEM_W
#define PPDH_RAW_COUNTER_ITEM       PPDH_RAW_COUNTER_ITEM_W
#define PdhGetFormattedCounterArray PdhGetFormattedCounterArrayW
#define PdhGetRawCounterArray       PdhGetRawCounterArrayW
#define PdhLookupPerfNameByIndex    PdhLookupPerfNameByIndexW
#define PdhLookupPerfIndexByName    PdhLookupPerfIndexByNameW
#define PdhOpenLog                  PdhOpenLogW
#define PdhUpdateLog                PdhUpdateLogW
#define PdhSelectDataSource         PdhSelectDataSourceW
#define PdhGetDataSourceTimeRange   PdhGetDataSourceTimeRangeW
#define PDH_LOG_SERVICE_QUERY_INFO  PDH_LOG_SERVICE_QUERY_INFO_W
#define PPDH_LOG_SERVICE_QUERY_INFO PPDH_LOG_SERVICE_QUERY_INFO_W
#define PdhLogServiceControl        PdhLogServiceControlW
#define PdhLogServiceQuery          PdhLogServiceQueryW
#define PdhExpandWildCardPath       PdhExpandWildCardPathW
#define PdhBindInputDataSource      PdhBindInputDataSourceW
#define PdhEnumMachinesH            PdhEnumMachinesHW
#define PdhEnumObjectsH             PdhEnumObjectsHW
#define PdhEnumObjectItemsH         PdhEnumObjectItemsHW
#define PdhExpandWildCardPathH      PdhExpandWildCardPathHW
#define PdhGetDefaultPerfObjectH    PdhGetDefaultPerfObjectHW
#define PdhGetDefaultPerfCounterH   PdhGetDefaultPerfCounterHW
#define PdhEnumLogSetNames          PdhEnumLogSetNamesW
#define PdhCreateSQLTables          PdhCreateSQLTablesW
#define PdhVerifySQLDB              PdhVerifySQLDBW

// end of UNICODE definitions
#else
// start of ANSI definitions
#define PdhOpenQuery                PdhOpenQueryA
#define PdhAddCounter               PdhAddCounterA
#define PdhGetCounterInfo           PdhGetCounterInfoA
#define PDH_COUNTER_INFO            PDH_COUNTER_INFO_A
#define PPDH_COUNTER_INFO           PPDH_COUNTER_INFO_A
#define PdhConnectMachine           PdhConnectMachineA
#define PdhEnumMachines             PdhEnumMachinesA
#define PdhEnumObjects              PdhEnumObjectsA
#define PdhEnumObjectItems          PdhEnumObjectItemsA
#define PdhMakeCounterPath          PdhMakeCounterPathA
#define PDH_COUNTER_PATH_ELEMENTS   PDH_COUNTER_PATH_ELEMENTS_A
#define PPDH_COUNTER_PATH_ELEMENTS  PPDH_COUNTER_PATH_ELEMENTS_A
#define PdhParseCounterPath         PdhParseCounterPathA
#define PdhParseInstanceName        PdhParseInstanceNameA
#define PdhValidatePath             PdhValidatePathA
#define PdhGetDefaultPerfObject     PdhGetDefaultPerfObjectA
#define PdhGetDefaultPerfCounter    PdhGetDefaultPerfCounterA
#define PdhBrowseCounters           PdhBrowseCountersA
#define PdhBrowseCountersH          PdhBrowseCountersHA
#define PDH_BROWSE_DLG_CONFIG       PDH_BROWSE_DLG_CONFIG_A
#define PPDH_BROWSE_DLG_CONFIG      PPDH_BROWSE_DLG_CONFIG_A
#define PDH_BROWSE_DLG_CONFIG_H     PDH_BROWSE_DLG_CONFIG_HA
#define PPDH_BROWSE_DLG_CONFIG_H    PPDH_BROWSE_DLG_CONFIG_HA
#define PdhExpandCounterPath        PdhExpandCounterPathA
// v2.0 functions
#define PDH_FMT_COUNTERVALUE_ITEM   PDH_FMT_COUNTERVALUE_ITEM_A
#define PPDH_FMT_COUNTERVALUE_ITEM  PPDH_FMT_COUNTERVALUE_ITEM_A
#define PDH_RAW_COUNTER_ITEM        PDH_RAW_COUNTER_ITEM_A
#define PPDH_RAW_COUNTER_ITEM       PPDH_RAW_COUNTER_ITEM_A
#define PdhGetFormattedCounterArray PdhGetFormattedCounterArrayA
#define PdhGetRawCounterArray       PdhGetRawCounterArrayA
#define PdhLookupPerfNameByIndex    PdhLookupPerfNameByIndexA
#define PdhLookupPerfIndexByName    PdhLookupPerfIndexByNameA
#define PdhOpenLog                  PdhOpenLogA
#define PdhUpdateLog                PdhUpdateLogA
#define PdhSelectDataSource         PdhSelectDataSourceA
#define PdhGetDataSourceTimeRange   PdhGetDataSourceTimeRangeA
#define PDH_LOG_SERVICE_QUERY_INFO  PDH_LOG_SERVICE_QUERY_INFO_A
#define PPDH_LOG_SERVICE_QUERY_INFO PPDH_LOG_SERVICE_QUERY_INFO_A
#define PdhLogServiceControl        PdhLogServiceControlA
#define PdhLogServiceQuery          PdhLogServiceQueryA
#define PdhExpandWildCardPath       PdhExpandWildCardPathA
#define PdhBindInputDataSource      PdhBindInputDataSourceA
#define PdhEnumMachinesH            PdhEnumMachinesHA
#define PdhEnumObjectsH             PdhEnumObjectsHA
#define PdhEnumObjectItemsH         PdhEnumObjectItemsHA
#define PdhExpandWildCardPathH      PdhExpandWildCardPathHA
#define PdhGetDefaultPerfObjectH    PdhGetDefaultPerfObjectHA
#define PdhGetDefaultPerfCounterH   PdhGetDefaultPerfCounterHA
#define PdhEnumLogSetNames          PdhEnumLogSetNamesA
#define PdhCreateSQLTables          PdhCreateSQLTablesA
#define PdhVerifySQLDB              PdhVerifySQLDBA

// end of ANSI definitions
#endif  // UNICODE

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning ( default : 4201 )
#endif


#ifdef __cplusplus
}
#endif

#endif //_PDH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\pbagex.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for pbagex.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __pbagex_h__
#define __pbagex_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IPropertyBagEx_FWD_DEFINED__
#define __IPropertyBagEx_FWD_DEFINED__
typedef interface IPropertyBagEx IPropertyBagEx;
#endif 	/* __IPropertyBagEx_FWD_DEFINED__ */


#ifndef __IEnumSTATPROPBAG_FWD_DEFINED__
#define __IEnumSTATPROPBAG_FWD_DEFINED__
typedef interface IEnumSTATPROPBAG IEnumSTATPROPBAG;
#endif 	/* __IEnumSTATPROPBAG_FWD_DEFINED__ */


/* header files for imported files */
#include "propidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_pbagex_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------
#if ( _MSC_VER >= 1020 )
#pragma once
#endif
#include <pshpack8.h>

EXTERN_C const FMTID FMTID_PropertyBag;


extern RPC_IF_HANDLE __MIDL_itf_pbagex_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_pbagex_0000_v0_0_s_ifspec;

#ifndef __IPropertyBagEx_INTERFACE_DEFINED__
#define __IPropertyBagEx_INTERFACE_DEFINED__

/* interface IPropertyBagEx */
/* [unique][uuid][object] */ 

typedef IPropertyBagEx *LPPROPERTYBAGEX;

#define	OPENPROPERTY_OVERWRITE	( 1 )


EXTERN_C const IID IID_IPropertyBagEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("20011801-5DE6-11D1-8E38-00C04FB9386D")
    IPropertyBagEx : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReadMultiple( 
            /* [in] */ ULONG cprops,
            /* [size_is][in] */ const LPCOLESTR rgwszPropNames[  ],
            /* [size_is][out][in] */ PROPVARIANT rgvar[  ],
            /* [in] */ IErrorLog *pErrorLog) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteMultiple( 
            /* [in] */ ULONG cprops,
            /* [size_is][in] */ const LPCOLESTR rgwszPropNames[  ],
            /* [size_is][in] */ const PROPVARIANT rgvar[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteMultiple( 
            /* [in] */ ULONG cprops,
            /* [size_is][in] */ const LPCOLESTR rgwszPropNames[  ],
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ IUnknown *pUnkOuter,
            /* [in] */ LPCOLESTR wszPropName,
            /* [in] */ GUID guidPropertyType,
            /* [in] */ DWORD dwFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enum( 
            /* [in] */ LPCOLESTR wszPropNameMask,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IEnumSTATPROPBAG **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyBagExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyBagEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyBagEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyBagEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReadMultiple )( 
            IPropertyBagEx * This,
            /* [in] */ ULONG cprops,
            /* [size_is][in] */ const LPCOLESTR rgwszPropNames[  ],
            /* [size_is][out][in] */ PROPVARIANT rgvar[  ],
            /* [in] */ IErrorLog *pErrorLog);
        
        HRESULT ( STDMETHODCALLTYPE *WriteMultiple )( 
            IPropertyBagEx * This,
            /* [in] */ ULONG cprops,
            /* [size_is][in] */ const LPCOLESTR rgwszPropNames[  ],
            /* [size_is][in] */ const PROPVARIANT rgvar[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteMultiple )( 
            IPropertyBagEx * This,
            /* [in] */ ULONG cprops,
            /* [size_is][in] */ const LPCOLESTR rgwszPropNames[  ],
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Open )( 
            IPropertyBagEx * This,
            /* [in] */ IUnknown *pUnkOuter,
            /* [in] */ LPCOLESTR wszPropName,
            /* [in] */ GUID guidPropertyType,
            /* [in] */ DWORD dwFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *Enum )( 
            IPropertyBagEx * This,
            /* [in] */ LPCOLESTR wszPropNameMask,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IEnumSTATPROPBAG **ppenum);
        
        END_INTERFACE
    } IPropertyBagExVtbl;

    interface IPropertyBagEx
    {
        CONST_VTBL struct IPropertyBagExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyBagEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertyBagEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropertyBagEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropertyBagEx_ReadMultiple(This,cprops,rgwszPropNames,rgvar,pErrorLog)	\
    (This)->lpVtbl -> ReadMultiple(This,cprops,rgwszPropNames,rgvar,pErrorLog)

#define IPropertyBagEx_WriteMultiple(This,cprops,rgwszPropNames,rgvar)	\
    (This)->lpVtbl -> WriteMultiple(This,cprops,rgwszPropNames,rgvar)

#define IPropertyBagEx_DeleteMultiple(This,cprops,rgwszPropNames,dwReserved)	\
    (This)->lpVtbl -> DeleteMultiple(This,cprops,rgwszPropNames,dwReserved)

#define IPropertyBagEx_Open(This,pUnkOuter,wszPropName,guidPropertyType,dwFlags,riid,ppUnk)	\
    (This)->lpVtbl -> Open(This,pUnkOuter,wszPropName,guidPropertyType,dwFlags,riid,ppUnk)

#define IPropertyBagEx_Enum(This,wszPropNameMask,dwFlags,ppenum)	\
    (This)->lpVtbl -> Enum(This,wszPropNameMask,dwFlags,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPropertyBagEx_ReadMultiple_Proxy( 
    IPropertyBagEx * This,
    /* [in] */ ULONG cprops,
    /* [size_is][in] */ const LPCOLESTR rgwszPropNames[  ],
    /* [size_is][out][in] */ PROPVARIANT rgvar[  ],
    /* [in] */ IErrorLog *pErrorLog);


void __RPC_STUB IPropertyBagEx_ReadMultiple_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyBagEx_WriteMultiple_Proxy( 
    IPropertyBagEx * This,
    /* [in] */ ULONG cprops,
    /* [size_is][in] */ const LPCOLESTR rgwszPropNames[  ],
    /* [size_is][in] */ const PROPVARIANT rgvar[  ]);


void __RPC_STUB IPropertyBagEx_WriteMultiple_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyBagEx_DeleteMultiple_Proxy( 
    IPropertyBagEx * This,
    /* [in] */ ULONG cprops,
    /* [size_is][in] */ const LPCOLESTR rgwszPropNames[  ],
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IPropertyBagEx_DeleteMultiple_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyBagEx_Open_Proxy( 
    IPropertyBagEx * This,
    /* [in] */ IUnknown *pUnkOuter,
    /* [in] */ LPCOLESTR wszPropName,
    /* [in] */ GUID guidPropertyType,
    /* [in] */ DWORD dwFlags,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppUnk);


void __RPC_STUB IPropertyBagEx_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyBagEx_Enum_Proxy( 
    IPropertyBagEx * This,
    /* [in] */ LPCOLESTR wszPropNameMask,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IEnumSTATPROPBAG **ppenum);


void __RPC_STUB IPropertyBagEx_Enum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertyBagEx_INTERFACE_DEFINED__ */


#ifndef __IEnumSTATPROPBAG_INTERFACE_DEFINED__
#define __IEnumSTATPROPBAG_INTERFACE_DEFINED__

/* interface IEnumSTATPROPBAG */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IEnumSTATPROPBAG *LPENUMSTATPROPBAG;

typedef struct tagSTATPROPBAG
    {
    LPOLESTR lpwstrName;
    VARTYPE vt;
    GUID guidPropertyType;
    } 	STATPROPBAG;


EXTERN_C const IID IID_IEnumSTATPROPBAG;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("20021801-5DE6-11D1-8E38-00C04FB9386D")
    IEnumSTATPROPBAG : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ STATPROPBAG *rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumSTATPROPBAG **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumSTATPROPBAGVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumSTATPROPBAG * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumSTATPROPBAG * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumSTATPROPBAG * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumSTATPROPBAG * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ STATPROPBAG *rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumSTATPROPBAG * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumSTATPROPBAG * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumSTATPROPBAG * This,
            /* [out] */ IEnumSTATPROPBAG **ppenum);
        
        END_INTERFACE
    } IEnumSTATPROPBAGVtbl;

    interface IEnumSTATPROPBAG
    {
        CONST_VTBL struct IEnumSTATPROPBAGVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumSTATPROPBAG_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumSTATPROPBAG_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumSTATPROPBAG_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumSTATPROPBAG_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumSTATPROPBAG_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumSTATPROPBAG_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumSTATPROPBAG_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumSTATPROPBAG_Next_Proxy( 
    IEnumSTATPROPBAG * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATPROPBAG *rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IEnumSTATPROPBAG_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumSTATPROPBAG_Skip_Proxy( 
    IEnumSTATPROPBAG * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumSTATPROPBAG_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumSTATPROPBAG_Reset_Proxy( 
    IEnumSTATPROPBAG * This);


void __RPC_STUB IEnumSTATPROPBAG_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumSTATPROPBAG_Clone_Proxy( 
    IEnumSTATPROPBAG * This,
    /* [out] */ IEnumSTATPROPBAG **ppenum);


void __RPC_STUB IEnumSTATPROPBAG_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumSTATPROPBAG_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_pbagex_0123 */
/* [local] */ 

#include <poppack.h>


extern RPC_IF_HANDLE __MIDL_itf_pbagex_0123_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_pbagex_0123_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\parser.h ===
//**************************************************************************************************
//
//  Purpose: Defines classes to support parsing tokens from a xml file

#ifndef _PARSER_H
#define _PARSER_H

#include <stdio.h>

#undef CLASS_IMPORT_EXPORT
#ifdef HHCTRL // define this only when building the HHCtrl DLL
  #define CLASS_IMPORT_EXPORT /**/
#else
 #ifdef HHSETUP // define this only when building the HHSetup DLL
  #define CLASS_IMPORT_EXPORT __declspec( dllexport )
 #else
  #define CLASS_IMPORT_EXPORT __declspec( dllimport )
 #endif
#endif

#define MAX_LINE_LEN 1024

#define F_OK 0
#define F_NOFILE 1
#define F_READ 2
#define F_WRITE 3
#define F_MEMORY 4
#define F_EOF 5
#define F_END 6
#define F_TAGMISSMATCH 7
#define F_MISSINGENDTAG 8
#define F_NOTFOUND 9
#define F_NOPARENT 10
#define F_NULL 11
#define F_NOTITLE 12
#define F_LOCATION 13
#define F_REFERENCED 14
#define F_DUPLICATE 15
#define F_DELETE 16
#define F_CLOSE 17
#define F_EXISTCHECK 19

class CParseXML {
private: // data

	CHAR m_cCurToken[MAX_LINE_LEN];
	CHAR m_cCurWord[MAX_LINE_LEN];
	CHAR m_cCurBuffer[MAX_LINE_LEN];
	FILE *m_fh;
	CHAR * m_pCurrentIndex;
	DWORD m_dwError;

private: // functions
	DWORD Read();
	DWORD SetError(DWORD dw) { m_dwError = dw; return m_dwError; }
public:

	CParseXML() {
		m_fh = NULL;
		m_cCurBuffer[0] = '\0';
		m_pCurrentIndex = NULL;
		m_dwError = F_OK;
	}

	~CParseXML() {
		End();
	}

	CHAR * GetFirstWord(CHAR *);
	CHAR * GetValue(CHAR *);

	DWORD Start(const CHAR *szFile);
	void End();
	CHAR *GetToken();
	DWORD GetError() { return m_dwError; }
};

// class to support a FIFO queue of strings
typedef struct  fifo {
	CHAR *string;
	fifo *prev;
} FIFO;

class CLASS_IMPORT_EXPORT  CFIFOString {
private:

	FIFO *m_fifoTail;

public:

	CFIFOString() { m_fifoTail = NULL; }
	~CFIFOString();
	void RemoveAll();

	DWORD AddTail(CHAR *sz);
	DWORD GetTail(CHAR **sz);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\parttype.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    parttype.h

Abstract:

    Header file for routines used to determine the correct
    partition type to use for a partition.

Author:

    Ted Miller (tedm) 5 Feb 1997

Revision History:

--*/

#if _MSC_VER > 1000
#pragma once
#endif


//
// Define classes of partitions meaningful to partition type APIs.
//
typedef enum {
    GenPartitionClassExtended,      // container partition (type 5 or f)
    GenPartitionClassFat12Or16,     // fat (types 1,4,6,e)
    GenPartitionClassFat32,         // fat32 (types b,c)
    GenPartitionClassNonFat,        // type 7
    GenPartitionClassMax
} GenPartitionClass;

//
// Flags for partition type APIs.
//
#define GENPARTTYPE_DISALLOW_XINT13     0x00000002
#define GENPARTTYPE_FORCE_XINT13        0x00000004


#ifdef __cplusplus
extern "C" {
#endif

//
// Routines.
//
NTSTATUS
GeneratePartitionType(
    IN  LPCWSTR NtDevicePath,               OPTIONAL
    IN  HANDLE DeviceHandle,                OPTIONAL
    IN  ULONGLONG StartSector,
    IN  ULONGLONG SectorCount,
    IN  GenPartitionClass PartitionClass,
    IN  ULONG Flags,
    IN  ULONG Reserved,
    OUT PUCHAR Type
    );


//
// Helper macros.
//
// (TedM) The mechanism for determining whether extended int13 is actually
// available on a drive is TBD. It is believed that the DISK_GEOMETRY structure
// will change to add an extra field or two to provide this information.
// Also, currently the disk drivers will increase the cylinder count if
// the drive reports more sectors than int13 function 8 reported. So for now
// we just see whether the partition ends on a cylinder > 1023. Both of these
// macros will need to be changed when the code to detect and report xint13 stuff
// becomes available in the system.

// (NorbertK) The right way to determine whether or not to use XINT13 is to just
// check where the partition lies.  We should continue to use the old int13 for
// partitions that are contained in the first 1024 cylinders.
//
#define XINT13_DESIRED(geom,endsect)                                                \
                                                                                    \
    (((endsect) / ((geom)->TracksPerCylinder * (geom)->SectorsPerTrack)) > 1023)

#define XINT13_AVAILABLE(geom)  TRUE

__inline
NTSTATUS
GeneratePartitionTypeWorker(
    IN  ULONGLONG StartSector,
    IN  ULONGLONG SectorCount,
    IN  GenPartitionClass PartitionClass,
    IN  ULONG Flags,
    IN  PDISK_GEOMETRY Geometry,
    OUT PUCHAR Type
    )

/*++

Routine Description:

    Worker routine for GeneratePartitionType and RegeneratePartitionType.

Arguments:

    StartSector - supplies start sector for partition

    SectorCount - supplies number of sectors in the partition

    PartitionClass - supplies class indicating intended use for the
        partition.

    Flags - supplies flags controlling operation.

    Geometry - supplies disk geometry information for the disk.

    Type - if successful, receives the type to be used.

Return Value:

    NT Status code indicating outcome.

--*/

{
    BOOLEAN UseXInt13;

    if(!StartSector || !SectorCount) {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Figure out whether extended int13 is desired for this drive.
    //
    if(Flags & GENPARTTYPE_DISALLOW_XINT13) {
        UseXInt13 = FALSE;
    } else {
        if(Flags & GENPARTTYPE_FORCE_XINT13) {
            UseXInt13 = TRUE;
        } else {
            //
            // Need to figure it out.
            //
            UseXInt13 = FALSE;
            if(XINT13_DESIRED(Geometry,StartSector+SectorCount-1) && XINT13_AVAILABLE(Geometry)) {
                UseXInt13 = TRUE;
            }
        }
    }

    switch(PartitionClass) {

    case GenPartitionClassExtended:

        *Type = UseXInt13 ? PARTITION_XINT13_EXTENDED : PARTITION_EXTENDED;
        break;

    case GenPartitionClassFat12Or16:

        if(UseXInt13) {
            *Type = PARTITION_XINT13;
        } else {
            //
            // Need to figure out which of the 3 FAT types to use.
            //
            if(SectorCount < 32680) {
                *Type = PARTITION_FAT_12;
            } else {
                *Type = (SectorCount < 65536) ? PARTITION_FAT_16 : PARTITION_HUGE;
            }
        }
        break;

    case GenPartitionClassFat32:

        *Type = UseXInt13 ? PARTITION_FAT32_XINT13 : PARTITION_FAT32;
        break;

    case GenPartitionClassNonFat:

        *Type = PARTITION_IFS;
        break;

    default:
        return(STATUS_INVALID_PARAMETER);
    }

    return(STATUS_SUCCESS);
}

__inline
NTSTATUS
pOpenDevice(
    IN  LPCWSTR NtPath,
    OUT PHANDLE DeviceHandle
    )

/*++

Routine Description:

    Open an NT-style path, which is assumed to be for a disk device
    or a partition. The open is share read/share write, for synch i/o
    and read access.

Arguments:

    NtPath - supplies nt-style pathname to open.

    DeviceHandle - if successful, receives NT handle of open device.

Return Value:

    NT Status code indicating outcome.

--*/

{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    RtlInitUnicodeString(&UnicodeString,NtPath);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtCreateFile(
                DeviceHandle,
                STANDARD_RIGHTS_READ | FILE_READ_DATA | FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_ALERT,
                NULL,
                0
                );

    return(Status);
}

__inline
NTSTATUS
RegeneratePartitionType(
    IN  LPCWSTR NtPartitionPath,            OPTIONAL
    IN  HANDLE PartitionHandle,             OPTIONAL
    IN  GenPartitionClass PartitionClass,
    IN  ULONG Flags,
    IN  ULONG Reserved,
    OUT PUCHAR Type
    )

/*++

Routine Description:

    This routine determines the proper partition type to be used for an
    existing partition, for example if the partition is being reformatted.

Arguments:

    NtPartitionPath - supplies the NT-style path of the partition
        whose type is to be recalculated, such as \Device\Harddisk1\Partition2.
        This routine should not be called for partition0. If not specified,
        PartitionHandle must be.

    PartitionHandle - Supplies a handle to the partition whose type is to be
        recalculated. The caller should have opened the partition for at least
        FILE_READ_DATA and FILE_READ_ATTRIBUTES access. Ignored if
        NtPartitionPath is specified.

    PartitionClass - supplies a value indicating the intended use of the
        partition.

        GenPartitionClassExtended - inavalid with this routine.

        GenPartitionClassFat12Or16 - indicates that the partition will be
            used for a 12 or 16 bit FAT volume. The returned type will be
            PARTITION_FAT_12 (1), PARTITION_FAT_16 (4), PARTITION_HUGE (6),
            or PARTITION_XINT13 (e), depending on size and placement of the
            partition, availability of extended int13 for the drive,
            and the Flags parameter.

        GenPartitionClassFat32 - indicates that the partition will be used
            for a FAT32 volume. The returned type will be PARTITION_FAT32 (b)
            or PARTITION_FAT32_XINT13 (c), depending on placement of the
            partition, availability of extended int13 for the drive,
            and the Flags parameter.

        GenPartitionNonFat - indicates that the partition will be used for
            a non-FAT volume. The returned type will be PARTITION_IFS (7).
            It is advisable to call this routine even for type 7 partitions
            since in the future additional partition types could be returned
            in this case.

    Flags - Supplies flags that further control operation of this routine.

        GENPARTTYPE_DISALLOW_XINT13 - disallow extended int13 partition types.
            If this flag is set, PARTITION_FAT32_XINT13 (c),
            PARTITION_XINT13 (e), and PARTITION_XINT13_EXTENDED (f) will not
            be returned as the partition type to be used. Not valid with
            GENPARTTYPE_FORCE_XINT13.

        GENPARTTYPE_FORCE_XINT13 - forces use of extended int13 partition types
            even if not necessary for the partition being created. Not valid
            with GENPARTTYPE_DISALLOW_XINT13.

    Reserved - reserved, must be 0.

    Type - if this routine succeeds, this value receives the partition type
        to be used for the partition.

Return Value:

    NT Status code indicating outcome. If NO_ERROR, Type is filled in with
    the resulting partition type to be used.

--*/

{
    NTSTATUS Status;
    HANDLE DeviceHandle;
    DISK_GEOMETRY Geometry;
    IO_STATUS_BLOCK IoStatusBlock;
    PARTITION_INFORMATION_EX PartitionInfo;

    //
    // Validate parameters.
    //
    if((Flags & GENPARTTYPE_DISALLOW_XINT13) && (Flags & GENPARTTYPE_FORCE_XINT13)) {
        return(STATUS_INVALID_PARAMETER_3);
    }

    if((PartitionClass >= GenPartitionClassMax) || (PartitionClass == GenPartitionClassExtended)) {
        return(STATUS_INVALID_PARAMETER_2);
    }

    if(Reserved) {
        return(STATUS_INVALID_PARAMETER_4);
    }

    //
    // Open the device if the caller specified a name. Otherwise use
    // the handle the caller passed in.
    //
    if(NtPartitionPath) {
        Status = pOpenDevice(NtPartitionPath,&DeviceHandle);
        if(!NT_SUCCESS(Status)) {
            return(Status);
        }
    } else {
        DeviceHandle = PartitionHandle;
    }

    //
    // Get drive geometry for the device.
    //
    Status = NtDeviceIoControlFile(
                DeviceHandle,
                NULL,NULL,NULL,     // synchronous io
                &IoStatusBlock,
                IOCTL_DISK_GET_DRIVE_GEOMETRY,
                NULL,0,             // no input buffer
                &Geometry,
                sizeof(DISK_GEOMETRY)
                );

    if(NT_SUCCESS(Status)) {
        //
        // Get partition info. We care about the start offset and size
        // of the partition.
        //
        Status = NtDeviceIoControlFile(
                    DeviceHandle,
                    NULL,NULL,NULL,     // synchronous io
                    &IoStatusBlock,
                    IOCTL_DISK_GET_PARTITION_INFO_EX,
                    NULL,0,             // no input buffer
                    &PartitionInfo,
                    sizeof(PartitionInfo)
                    );

        if (!NT_SUCCESS(Status)) {

            if (Status == STATUS_INVALID_DEVICE_REQUEST) {

                GET_LENGTH_INFORMATION  LengthInfo;

                Status = NtDeviceIoControlFile(DeviceHandle, 0, NULL, NULL,
                                               &IoStatusBlock,
                                               IOCTL_DISK_GET_LENGTH_INFO,
                                               NULL, 0, &LengthInfo,
                                               sizeof(GET_LENGTH_INFORMATION));

                if (NT_SUCCESS(Status)) {
                    //
                    // GET_PARTITION_INFO_EX will fail outright on an EFI Dynamic
                    // Volume.  In this case, just make up the starting offset
                    // so that FORMAT can proceed normally.
                    //

                    PartitionInfo.StartingOffset.QuadPart = 0x7E00;
                    PartitionInfo.PartitionLength.QuadPart = LengthInfo.Length.QuadPart;
                }
            }
        }

        if(NT_SUCCESS(Status)) {
            //
            // Call the worker routine to do the work.
            //
            Status = GeneratePartitionTypeWorker(
                        PartitionInfo.StartingOffset.QuadPart / Geometry.BytesPerSector,
                        PartitionInfo.PartitionLength.QuadPart / Geometry.BytesPerSector,
                        PartitionClass,
                        Flags,
                        &Geometry,
                        Type
                        );
        }
    }

    if(NtPartitionPath) {
        NtClose(DeviceHandle);
    }
    return(Status);
}



#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\patchapi.h ===
//
//  patchapi.h
//
//  Interface for creating and applying patches to files.
//
//  Copyright (C) Microsoft, 1997-2000.
//

#ifndef _PATCHAPI_H_
#define _PATCHAPI_H_

#ifdef __cplusplus
extern "C" {
#endif

//
//  The following constants can be combined and used as the OptionFlags
//  parameter in the patch creation apis.
//

#define PATCH_OPTION_USE_BEST           0x00000000  // auto choose best (slower)

#define PATCH_OPTION_USE_LZX_BEST       0x00000003  // auto choose best of LZX
#define PATCH_OPTION_USE_LZX_A          0x00000001  // normal
#define PATCH_OPTION_USE_LZX_B          0x00000002  // better on some x86 binaries
#define PATCH_OPTION_USE_LZX_LARGE      0x00000004  // better support for files >8MB

#define PATCH_OPTION_NO_BINDFIX         0x00010000  // PE bound imports
#define PATCH_OPTION_NO_LOCKFIX         0x00020000  // PE smashed locks
#define PATCH_OPTION_NO_REBASE          0x00040000  // PE rebased image
#define PATCH_OPTION_FAIL_IF_SAME_FILE  0x00080000  // don't create if same
#define PATCH_OPTION_FAIL_IF_BIGGER     0x00100000  // fail if patch is larger than simply compressing new file (slower)
#define PATCH_OPTION_NO_CHECKSUM        0x00200000  // PE checksum zero
#define PATCH_OPTION_NO_RESTIMEFIX      0x00400000  // PE resource timestamps
#define PATCH_OPTION_NO_TIMESTAMP       0x00800000  // don't store new file timestamp in patch
#define PATCH_OPTION_SIGNATURE_MD5      0x01000000  // use MD5 instead of CRC32
#define PATCH_OPTION_RESERVED1          0x80000000  // (used internally)

#define PATCH_OPTION_VALID_FLAGS        0x80FF0007

#define PATCH_SYMBOL_NO_IMAGEHLP        0x00000001  // don't use imagehlp.dll
#define PATCH_SYMBOL_NO_FAILURES        0x00000002  // don't fail patch due to imagehlp failures
#define PATCH_SYMBOL_UNDECORATED_TOO    0x00000004  // after matching decorated symbols, try to match remaining by undecorated names
#define PATCH_SYMBOL_RESERVED1          0x80000000  // (used internally)


//
//  The following constants can be combined and used as the ApplyOptionFlags
//  parameter in the patch apply and test apis.
//

#define APPLY_OPTION_FAIL_IF_EXACT      0x00000001  // don't copy new file
#define APPLY_OPTION_FAIL_IF_CLOSE      0x00000002  // differ by rebase, bind
#define APPLY_OPTION_TEST_ONLY          0x00000004  // don't create new file
#define APPLY_OPTION_VALID_FLAGS        0x00000007

//
//  In addition to standard Win32 error codes, the following error codes may
//  be returned via GetLastError() when one of the patch APIs fails.
//

#define ERROR_PATCH_ENCODE_FAILURE          0xC00E3101  // create
#define ERROR_PATCH_INVALID_OPTIONS         0xC00E3102  // create
#define ERROR_PATCH_SAME_FILE               0xC00E3103  // create
#define ERROR_PATCH_RETAIN_RANGES_DIFFER    0xC00E3104  // create
#define ERROR_PATCH_BIGGER_THAN_COMPRESSED  0xC00E3105  // create
#define ERROR_PATCH_IMAGEHLP_FAILURE        0xC00E3106  // create

#define ERROR_PATCH_DECODE_FAILURE          0xC00E4101  // apply
#define ERROR_PATCH_CORRUPT                 0xC00E4102  // apply
#define ERROR_PATCH_NEWER_FORMAT            0xC00E4103  // apply
#define ERROR_PATCH_WRONG_FILE              0xC00E4104  // apply
#define ERROR_PATCH_NOT_NECESSARY           0xC00E4105  // apply
#define ERROR_PATCH_NOT_AVAILABLE           0xC00E4106  // apply

typedef BOOL (CALLBACK PATCH_PROGRESS_CALLBACK)(
    PVOID CallbackContext,
    ULONG CurrentPosition,
    ULONG MaximumPosition
    );

typedef PATCH_PROGRESS_CALLBACK *PPATCH_PROGRESS_CALLBACK;

typedef BOOL (CALLBACK PATCH_SYMLOAD_CALLBACK)(
    IN ULONG  WhichFile,          // 0 for new file, 1 for first old file, etc
    IN LPCSTR SymbolFileName,
    IN ULONG  SymType,            // see SYM_TYPE in imagehlp.h
    IN ULONG  SymbolFileCheckSum,
    IN ULONG  SymbolFileTimeDate,
    IN ULONG  ImageFileCheckSum,
    IN ULONG  ImageFileTimeDate,
    IN PVOID  CallbackContext
    );

typedef PATCH_SYMLOAD_CALLBACK *PPATCH_SYMLOAD_CALLBACK;

typedef struct _PATCH_IGNORE_RANGE {
    ULONG OffsetInOldFile;
    ULONG LengthInBytes;
    } PATCH_IGNORE_RANGE, *PPATCH_IGNORE_RANGE;

typedef struct _PATCH_RETAIN_RANGE {
    ULONG OffsetInOldFile;
    ULONG LengthInBytes;
    ULONG OffsetInNewFile;
    } PATCH_RETAIN_RANGE, *PPATCH_RETAIN_RANGE;

typedef struct _PATCH_OLD_FILE_INFO_A {
    ULONG               SizeOfThisStruct;
    LPCSTR              OldFileName;
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO_A, *PPATCH_OLD_FILE_INFO_A;

typedef struct _PATCH_OLD_FILE_INFO_W {
    ULONG               SizeOfThisStruct;
    LPCWSTR             OldFileName;
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO_W, *PPATCH_OLD_FILE_INFO_W;

typedef struct _PATCH_OLD_FILE_INFO_H {
    ULONG               SizeOfThisStruct;
    HANDLE              OldFileHandle;
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO_H, *PPATCH_OLD_FILE_INFO_H;

typedef struct _PATCH_OLD_FILE_INFO {
    ULONG               SizeOfThisStruct;
    union {
        LPCSTR          OldFileNameA;
        LPCWSTR         OldFileNameW;
        HANDLE          OldFileHandle;
        };
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO, *PPATCH_OLD_FILE_INFO;

typedef struct _PATCH_OPTION_DATA {
    ULONG                   SizeOfThisStruct;
    ULONG                   SymbolOptionFlags;      // PATCH_SYMBOL_xxx flags
    LPCSTR                  NewFileSymbolPath;      // always ANSI, never Unicode
    LPCSTR                 *OldFileSymbolPathArray; // array[ OldFileCount ]
    ULONG                   ExtendedOptionFlags;
    PPATCH_SYMLOAD_CALLBACK SymLoadCallback;
    PVOID                   SymLoadContext;
    } PATCH_OPTION_DATA, *PPATCH_OPTION_DATA;

//
//  Note that PATCH_OPTION_DATA contains LPCSTR paths, and no LPCWSTR (Unicode)
//  path argument is available, even when used with one of the Unicode APIs
//  such as CreatePatchFileW.  This is because the underlying system services
//  for symbol file handling (IMAGEHLP.DLL) only support ANSI file/path names.
//

//
//  A note about PATCH_RETAIN_RANGE specifiers with multiple old files:
//
//  Each old version file must have the same RetainRangeCount, and the same
//  retain range LengthInBytes and OffsetInNewFile values in the same order.
//  Only the OffsetInOldFile values can differ between old files for retain
//  ranges.
//

#ifdef IMPORTING_PATCHAPI_DLL
#define PATCHAPI WINAPI __declspec( dllimport )
#else
#define PATCHAPI WINAPI
#endif


//
//  The following prototypes are interface for creating patches from files.
//

BOOL
PATCHAPI
CreatePatchFileA(
    IN  LPCSTR OldFileName,
    IN  LPCSTR NewFileName,
    OUT LPCSTR PatchFileName,
    IN  ULONG  OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData       // optional
    );

BOOL
PATCHAPI
CreatePatchFileW(
    IN  LPCWSTR OldFileName,
    IN  LPCWSTR NewFileName,
    OUT LPCWSTR PatchFileName,
    IN  ULONG   OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData       // optional
    );

BOOL
PATCHAPI
CreatePatchFileByHandles(
    IN  HANDLE OldFileHandle,
    IN  HANDLE NewFileHandle,
    OUT HANDLE PatchFileHandle,
    IN  ULONG  OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData       // optional
    );

BOOL
PATCHAPI
CreatePatchFileExA(
    IN  ULONG                    OldFileCount,          // maximum 255
    IN  PPATCH_OLD_FILE_INFO_A   OldFileInfoArray,
    IN  LPCSTR                   NewFileName,
    OUT LPCSTR                   PatchFileName,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
CreatePatchFileExW(
    IN  ULONG                    OldFileCount,          // maximum 255
    IN  PPATCH_OLD_FILE_INFO_W   OldFileInfoArray,
    IN  LPCWSTR                  NewFileName,
    OUT LPCWSTR                  PatchFileName,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
CreatePatchFileByHandlesEx(
    IN  ULONG                    OldFileCount,          // maximum 255
    IN  PPATCH_OLD_FILE_INFO_H   OldFileInfoArray,
    IN  HANDLE                   NewFileHandle,
    OUT HANDLE                   PatchFileHandle,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
ExtractPatchHeaderToFileA(
    IN  LPCSTR PatchFileName,
    OUT LPCSTR PatchHeaderFileName
    );

BOOL
PATCHAPI
ExtractPatchHeaderToFileW(
    IN  LPCWSTR PatchFileName,
    OUT LPCWSTR PatchHeaderFileName
    );

BOOL
PATCHAPI
ExtractPatchHeaderToFileByHandles(
    IN  HANDLE PatchFileHandle,
    OUT HANDLE PatchHeaderFileHandle
    );

//
//  The following prototypes are interface for creating new file from old file
//  and patch file.  Note that it is possible for the TestApply API to succeed
//  but the actual Apply to fail since the TestApply only verifies that the
//  old file has the correct CRC without actually applying the patch.  The
//  TestApply API only requires the patch header portion of the patch file,
//  but its CRC must be fixed up.
//

BOOL
PATCHAPI
TestApplyPatchToFileA(
    IN LPCSTR PatchFileName,
    IN LPCSTR OldFileName,
    IN ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
TestApplyPatchToFileW(
    IN LPCWSTR PatchFileName,
    IN LPCWSTR OldFileName,
    IN ULONG   ApplyOptionFlags
    );

BOOL
PATCHAPI
TestApplyPatchToFileByHandles(
    IN HANDLE PatchFileHandle,      // requires GENERIC_READ access
    IN HANDLE OldFileHandle,        // requires GENERIC_READ access
    IN ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileA(
    IN  LPCSTR PatchFileName,
    IN  LPCSTR OldFileName,
    OUT LPCSTR NewFileName,
    IN  ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileW(
    IN  LPCWSTR PatchFileName,
    IN  LPCWSTR OldFileName,
    OUT LPCWSTR NewFileName,
    IN  ULONG   ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileByHandles(
    IN  HANDLE PatchFileHandle,     // requires GENERIC_READ access
    IN  HANDLE OldFileHandle,       // requires GENERIC_READ access
    OUT HANDLE NewFileHandle,       // requires GENERIC_READ | GENERIC_WRITE
    IN  ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileExA(
    IN  LPCSTR                   PatchFileName,
    IN  LPCSTR                   OldFileName,
    OUT LPCSTR                   NewFileName,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
ApplyPatchToFileExW(
    IN  LPCWSTR                  PatchFileName,
    IN  LPCWSTR                  OldFileName,
    OUT LPCWSTR                  NewFileName,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
ApplyPatchToFileByHandlesEx(
    IN  HANDLE                   PatchFileHandle,
    IN  HANDLE                   OldFileHandle,
    OUT HANDLE                   NewFileHandle,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

//
//  The following prototypes provide a unique patch "signature" for a given
//  file.  Consider the case where you have a new foo.dll and the machines
//  to be updated with the new foo.dll may have one of three different old
//  foo.dll files.  Rather than creating a single large patch file that can
//  update any of the three older foo.dll files, three separate smaller patch
//  files can be created and "named" according to the patch signature of the
//  old file.  Then the patch applyer application can determine at runtime
//  which of the three foo.dll patch files is necessary given the specific
//  foo.dll to be updated.  If patch files are being downloaded over a slow
//  network connection (Internet over a modem), this signature scheme provides
//  a mechanism for choosing the correct single patch file to download at
//  application time thus decreasing total bytes necessary to download.
//

BOOL
PATCHAPI
GetFilePatchSignatureA(
    IN  LPCSTR FileName,
    IN  ULONG  OptionFlags,
    IN  PVOID  OptionData,
    IN  ULONG  IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG  RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG  SignatureBufferSize,
    OUT PVOID  SignatureBuffer
    );

BOOL
PATCHAPI
GetFilePatchSignatureW(
    IN  LPCWSTR FileName,
    IN  ULONG   OptionFlags,
    IN  PVOID   OptionData,
    IN  ULONG   IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG   RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG   SignatureBufferSizeInBytes,
    OUT PVOID   SignatureBuffer
    );

BOOL
PATCHAPI
GetFilePatchSignatureByHandle(
    IN  HANDLE  FileHandle,
    IN  ULONG   OptionFlags,
    IN  PVOID   OptionData,
    IN  ULONG   IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG   RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG   SignatureBufferSize,
    OUT PVOID   SignatureBuffer
    );


//
//  Depending on whether UNICODE is defined, map the generic API names to the
//  appropriate Unicode or Ansi APIs.
//

#ifdef UNICODE

    #define CreatePatchFile          CreatePatchFileW
    #define CreatePatchFileEx        CreatePatchFileExW
    #define TestApplyPatchToFile     TestApplyPatchToFileW
    #define ApplyPatchToFile         ApplyPatchToFileW
    #define ApplyPatchToFileEx       ApplyPatchToFileExW
    #define ExtractPatchHeaderToFile ExtractPatchHeaderToFileW
    #define GetFilePatchSignature    GetFilePatchSignatureW

#else

    #define CreatePatchFile          CreatePatchFileA
    #define CreatePatchFileEx        CreatePatchFileExA
    #define TestApplyPatchToFile     TestApplyPatchToFileA
    #define ApplyPatchToFile         ApplyPatchToFileA
    #define ApplyPatchToFileEx       ApplyPatchToFileExA
    #define ExtractPatchHeaderToFile ExtractPatchHeaderToFileA
    #define GetFilePatchSignature    GetFilePatchSignatureA

#endif // UNICODE

#ifdef __cplusplus
}
#endif

#endif // _PATCHAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\pdlgguid.h ===
// pdlgguid.h
//
// Created 05/15/97
//
// (C)Copyright 1997 Microsoft Corporation, All rights reserved.
//

#ifndef __PDLGGUID_H__
#define __PDLGGUID_H__


DEFINE_GUID(IID_IJavaZonePermissionEditor,
0x85347F8A,0xC8B7,0x11d0,0x88,0x23,0x00,0xC0,0x4F,0xB6,0x7C,0x84);

DEFINE_GUID(CLSID_JavaRuntimeConfiguration,
0x004CE610,0xCCD1,0x11d0,0xA9,0xBA,0x00,0xA0,0xC9,0x08,0xDB,0x5E);


#endif /* __PDLGGUID_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\perftags.h ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       perftags.h
//
//  Contents:   External include file for perftags.dll
//
//-------------------------------------------------------------------------

#ifdef PERFTAGS

typedef int  PERFTAG;
int          PerfRegister(char * szTag, char * szOwner, char * szDescrip);
void __cdecl PerfLogFn(int tag, void * pvObj, const char * pchFmt, ...);
void         PerfDump();
void         PerfClear();
void         PerfTags();
#define      IsPerfEnabled(tag) (*(BOOL *)tag)
#define      PerfTag(tag, szOwner, szDescrip) PERFTAG tag(PerfRegister(#tag, szOwner, szDescrip));
#define      PerfExtern(tag) extern PERFTAG tag;
#define      PerfLog(tag,pv,f) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f) : 0
#define      PerfLog1(tag,pv,f,a1) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f,a1) : 0
#define      PerfLog2(tag,pv,f,a1,a2) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f,a1,a2) : 0
#define      PerfLog3(tag,pv,f,a1,a2,a3) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f,a1,a2,a3) : 0
#define      PerfLog4(tag,pv,f,a1,a2,a3,a4) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f,a1,a2,a3,a4) : 0
#define      PerfLog5(tag,pv,f,a1,a2,a3,a4,a5) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f,a1,a2,a3,a4,a5) : 0
#define      PerfLog6(tag,pv,f,a1,a2,a3,a4,a5,a6) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6) : 0
#define      PerfLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) : 0
#define      PerfLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) : 0
#define      PerfLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) : 0

#else

#define      PerfTags()
#define      PerfTag(tag, szOwner, szDescrip)
#define      PerfExtern(tag)
#define      PerfDump()
#define      PerfClear()
#define      IsPerfEnabled(tag) FALSE
#define      PerfLog(tag,pv,f)
#define      PerfLog1(tag,pv,f,a1)
#define      PerfLog2(tag,pv,f,a1,a2)
#define      PerfLog3(tag,pv,f,a1,a2,a3)
#define      PerfLog4(tag,pv,f,a1,a2,a3,a4)
#define      PerfLog5(tag,pv,f,a1,a2,a3,a4,a5)
#define      PerfLog6(tag,pv,f,a1,a2,a3,a4,a5,a6)
#define      PerfLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7)
#define      PerfLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8)
#define      PerfLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\pebteb.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 2001  Microsoft Corporation

Module Name:

    pebteb.w

Abstract:

    Declarations of PEB and TEB, and some types contained in them.

    Address the maintenance problem that resulted from PEB and TEB being
    defined three times, once "native" in ntpsapi.w, and twice, 32bit and 64bit
    in wow64t.w.

Author:

    Jay Krell (JayKrell) April 2001

Revision History:

--*/

//
// This file deliberately lacks #pragma once or #ifndef guards.
// It is only included by ntpsapi.h and wow64t.h, never directly.
//

//
// This file is #included three times.
//
// 1) by ntpsapi.h, with no "unusual" macros defined, to declare
//    PEB and TEB, and some types contained in them
// 2) by wow64t.h to declare PEB32 and TEB32, and some types contained in them
// 3) by wow64t.h to declare PEB64 and TEB64, and some types contained in them
//
// wow64t.h #defines the macro PEBTEB_BITS to guide the declarations.
//


#define PEBTEB_PRIVATE_PASTE(x,y)       x##y
#define PEBTEB_PASTE(x,y)               PEBTEB_PRIVATE_PASTE(x,y)

#if defined(PEBTEB_BITS) /* This is defined by wow64t.h. */

#if PEBTEB_BITS == 32

#define PEBTEB_STRUCT(x)    PEBTEB_PASTE(x, 32) /* FOO32 */
#define PEBTEB_POINTER(x)   TYPE32(x) /* ULONG, defined in wow64t.h */

#elif PEBTEB_BITS == 64

#define PEBTEB_STRUCT(x)    PEBTEB_PASTE(x, 64) /* FOO64 */
#define PEBTEB_POINTER(x)   TYPE64(x) /* ULONGLONG, defined in wow64t.h */

#else

#error Unknown value for pebteb_bits (PEBTEB_BITS).

#endif

#else

//
// Declare and use regular native types.
//
#define PEBTEB_POINTER(x) x
#define PEBTEB_STRUCT(x)  x

#endif

/* for searching
typedef struct _PEB
typedef struct _PEB32
typedef struct _PEB64
*/
typedef struct PEBTEB_STRUCT(_PEB) {
    BOOLEAN InheritedAddressSpace;      // These four fields cannot change unless the
    BOOLEAN ReadImageFileExecOptions;   //
    BOOLEAN BeingDebugged;              //
    BOOLEAN SpareBool;                  //
    PEBTEB_POINTER(HANDLE) Mutant;      // INITIAL_PEB structure is also updated.

    PEBTEB_POINTER(PVOID) ImageBaseAddress;
    PEBTEB_POINTER(PPEB_LDR_DATA) Ldr;
    PEBTEB_POINTER(struct _RTL_USER_PROCESS_PARAMETERS*) ProcessParameters;
    PEBTEB_POINTER(PVOID) SubSystemData;
    PEBTEB_POINTER(PVOID) ProcessHeap;
    PEBTEB_POINTER(struct _RTL_CRITICAL_SECTION*) FastPebLock;
    PEBTEB_POINTER(PVOID) SparePtr1;
    PEBTEB_POINTER(PVOID) SparePtr2;
    ULONG EnvironmentUpdateCount;
    PEBTEB_POINTER(PVOID) KernelCallbackTable;
    ULONG SystemReserved[1];

    struct {
        ULONG ExecuteOptions : 2;
        ULONG SpareBits : 30;
    };    


    PEBTEB_POINTER(PPEB_FREE_BLOCK) FreeList;
    ULONG TlsExpansionCounter;
    PEBTEB_POINTER(PVOID) TlsBitmap;
    ULONG TlsBitmapBits[2];         // TLS_MINIMUM_AVAILABLE bits
    PEBTEB_POINTER(PVOID) ReadOnlySharedMemoryBase;
    PEBTEB_POINTER(PVOID) ReadOnlySharedMemoryHeap;
    PEBTEB_POINTER(PPVOID) ReadOnlyStaticServerData;
    PEBTEB_POINTER(PVOID) AnsiCodePageData;
    PEBTEB_POINTER(PVOID) OemCodePageData;
    PEBTEB_POINTER(PVOID) UnicodeCaseTableData;

    //
    // Useful information for LdrpInitialize
    ULONG NumberOfProcessors;
    ULONG NtGlobalFlag;

    //
    // Passed up from MmCreatePeb from Session Manager registry key
    //

    LARGE_INTEGER CriticalSectionTimeout;
    PEBTEB_POINTER(SIZE_T) HeapSegmentReserve;
    PEBTEB_POINTER(SIZE_T) HeapSegmentCommit;
    PEBTEB_POINTER(SIZE_T) HeapDeCommitTotalFreeThreshold;
    PEBTEB_POINTER(SIZE_T) HeapDeCommitFreeBlockThreshold;

    //
    // Where heap manager keeps track of all heaps created for a process
    // Fields initialized by MmCreatePeb.  ProcessHeaps is initialized
    // to point to the first free byte after the PEB and MaximumNumberOfHeaps
    // is computed from the page size used to hold the PEB, less the fixed
    // size of this data structure.
    //

    ULONG NumberOfHeaps;
    ULONG MaximumNumberOfHeaps;
    PEBTEB_POINTER(PPVOID) ProcessHeaps;

    //
    //
    PEBTEB_POINTER(PVOID) GdiSharedHandleTable;
    PEBTEB_POINTER(PVOID) ProcessStarterHelper;
    ULONG GdiDCAttributeList;
    PEBTEB_POINTER(struct _RTL_CRITICAL_SECTION*) LoaderLock;

    //
    // Following fields filled in by MmCreatePeb from system values and/or
    // image header.
    //

    ULONG OSMajorVersion;
    ULONG OSMinorVersion;
    USHORT OSBuildNumber;
    USHORT OSCSDVersion;
    ULONG OSPlatformId;
    ULONG ImageSubsystem;
    ULONG ImageSubsystemMajorVersion;
    ULONG ImageSubsystemMinorVersion;
    PEBTEB_POINTER(ULONG_PTR) ImageProcessAffinityMask;
    PEBTEB_STRUCT(GDI_HANDLE_BUFFER) GdiHandleBuffer;
    PEBTEB_POINTER(PPS_POST_PROCESS_INIT_ROUTINE) PostProcessInitRoutine;

    PEBTEB_POINTER(PVOID) TlsExpansionBitmap;
    ULONG TlsExpansionBitmapBits[32];   // TLS_EXPANSION_SLOTS bits

    //
    // Id of the Hydra session in which this process is running
    //
    ULONG SessionId;

    //
    // Filled in by LdrpInstallAppcompatBackend
    //
    ULARGE_INTEGER AppCompatFlags;

    //
    // ntuser appcompat flags
    //
    ULARGE_INTEGER AppCompatFlagsUser;

    //
    // Filled in by LdrpInstallAppcompatBackend
    //
    PEBTEB_POINTER(PVOID) pShimData;

    //
    // Filled in by LdrQueryImageFileExecutionOptions
    //
    PEBTEB_POINTER(PVOID) AppCompatInfo;

    //
    // Used by GetVersionExW as the szCSDVersion string
    //
    PEBTEB_STRUCT(UNICODE_STRING) CSDVersion;

    //
    // Fusion stuff
    //
    PEBTEB_POINTER(const struct _ACTIVATION_CONTEXT_DATA *) ActivationContextData;
    PEBTEB_POINTER(struct _ASSEMBLY_STORAGE_MAP *) ProcessAssemblyStorageMap;
    PEBTEB_POINTER(const struct _ACTIVATION_CONTEXT_DATA *) SystemDefaultActivationContextData;
    PEBTEB_POINTER(struct _ASSEMBLY_STORAGE_MAP *) SystemAssemblyStorageMap;
    
    //
    // Enforced minimum initial commit stack
    //
    PEBTEB_POINTER(SIZE_T) MinimumStackCommit;

    //
    // Fiber local storage.
    //

    PEBTEB_POINTER(PPVOID) FlsCallback;
    PEBTEB_STRUCT(LIST_ENTRY) FlsListHead;
    PEBTEB_POINTER(PVOID) FlsBitmap;
    ULONG FlsBitmapBits[FLS_MAXIMUM_AVAILABLE / (sizeof(ULONG) * 8)];
    ULONG FlsHighIndex;
} PEBTEB_STRUCT(PEB), * PEBTEB_STRUCT(PPEB);

//
//  Fusion/sxs thread state information
//

#define ACTIVATION_CONTEXT_STACK_FLAG_QUERIES_DISABLED (0x00000001)

typedef struct PEBTEB_STRUCT(_ACTIVATION_CONTEXT_STACK) {
    ULONG Flags;
    ULONG NextCookieSequenceNumber;
    PEBTEB_POINTER(struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME *) ActiveFrame;
    PEBTEB_STRUCT(LIST_ENTRY) FrameListCache;
} PEBTEB_STRUCT(ACTIVATION_CONTEXT_STACK), * PEBTEB_STRUCT(PACTIVATION_CONTEXT_STACK);

typedef const PEBTEB_STRUCT(ACTIVATION_CONTEXT_STACK) * PEBTEB_STRUCT(PCACTIVATION_CONTEXT_STACK);

#define TEB_ACTIVE_FRAME_CONTEXT_FLAG_EXTENDED (0x00000001)

typedef struct PEBTEB_STRUCT(_TEB_ACTIVE_FRAME_CONTEXT) {
    ULONG Flags;
    PEBTEB_POINTER(PCSTR) FrameName;
} PEBTEB_STRUCT(TEB_ACTIVE_FRAME_CONTEXT), *PEBTEB_STRUCT(PTEB_ACTIVE_FRAME_CONTEXT);

typedef const PEBTEB_STRUCT(TEB_ACTIVE_FRAME_CONTEXT) *PEBTEB_STRUCT(PCTEB_ACTIVE_FRAME_CONTEXT);

typedef struct PEBTEB_STRUCT(_TEB_ACTIVE_FRAME_CONTEXT_EX) {
    PEBTEB_STRUCT(TEB_ACTIVE_FRAME_CONTEXT) BasicContext;
    PEBTEB_POINTER(PCSTR) SourceLocation; // e.g. "Z:\foo\bar\baz.c"
} PEBTEB_STRUCT(TEB_ACTIVE_FRAME_CONTEXT_EX), *PEBTEB_STRUCT(PTEB_ACTIVE_FRAME_CONTEXT_EX);

typedef const PEBTEB_STRUCT(TEB_ACTIVE_FRAME_CONTEXT_EX) *PEBTEB_STRUCT(PCTEB_ACTIVE_FRAME_CONTEXT_EX);

#define TEB_ACTIVE_FRAME_FLAG_EXTENDED (0x00000001)

typedef struct PEBTEB_STRUCT(_TEB_ACTIVE_FRAME) {
    ULONG Flags;
    PEBTEB_POINTER(struct _TEB_ACTIVE_FRAME*) Previous;
    PEBTEB_POINTER(PCTEB_ACTIVE_FRAME_CONTEXT) Context;
} PEBTEB_STRUCT(TEB_ACTIVE_FRAME), *PEBTEB_STRUCT(PTEB_ACTIVE_FRAME);

typedef const PEBTEB_STRUCT(TEB_ACTIVE_FRAME) *PEBTEB_STRUCT(PCTEB_ACTIVE_FRAME);

typedef struct PEBTEB_STRUCT(_TEB_ACTIVE_FRAME_EX) {
    PEBTEB_STRUCT(TEB_ACTIVE_FRAME) BasicFrame;
    PEBTEB_POINTER(PVOID) ExtensionIdentifier; // use address of your DLL Main or something unique to your mapping in the address space
} PEBTEB_STRUCT(TEB_ACTIVE_FRAME_EX), *PEBTEB_STRUCT(PTEB_ACTIVE_FRAME_EX);

typedef const PEBTEB_STRUCT(TEB_ACTIVE_FRAME_EX) *PEBTEB_STRUCT(PCTEB_ACTIVE_FRAME_EX);

/* for searching
typedef struct _TEB
typedef struct _TEB32
typedef struct _TEB64
*/
typedef struct PEBTEB_STRUCT(_TEB) {
    PEBTEB_STRUCT(NT_TIB) NtTib;
    PEBTEB_POINTER(PVOID) EnvironmentPointer;
    PEBTEB_STRUCT(CLIENT_ID) ClientId;
    PEBTEB_POINTER(PVOID) ActiveRpcHandle;
    PEBTEB_POINTER(PVOID) ThreadLocalStoragePointer;
    PEBTEB_POINTER(PPEB) ProcessEnvironmentBlock;
    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    PEBTEB_POINTER(PVOID) CsrClientThread;
    PEBTEB_POINTER(PVOID) Win32ThreadInfo;          // PtiCurrent
    ULONG User32Reserved[26];       // user32.dll items
    ULONG UserReserved[5];          // Winsrv SwitchStack
    PEBTEB_POINTER(PVOID) WOW32Reserved;            // used by WOW
    LCID CurrentLocale;
    ULONG FpSoftwareStatusRegister; // offset known by outsiders!
    PEBTEB_POINTER(PVOID) SystemReserved1[54];      // Used by FP emulator
    NTSTATUS ExceptionCode;         // for RaiseUserException
    PEBTEB_STRUCT(ACTIVATION_CONTEXT_STACK) ActivationContextStack;   // Fusion activation stack
    // sizeof(PEBTEB_POINTER(PVOID)) is a way to express processor-dependence, more generally than #ifdef _WIN64
    UCHAR SpareBytes1[48 - sizeof(PEBTEB_POINTER(PVOID)) - sizeof(PEBTEB_STRUCT(ACTIVATION_CONTEXT_STACK))];
    PEBTEB_STRUCT(GDI_TEB_BATCH) GdiTebBatch;      // Gdi batching
    PEBTEB_STRUCT(CLIENT_ID) RealClientId;
    PEBTEB_POINTER(HANDLE) GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    PEBTEB_POINTER(PVOID) GdiThreadLocalInfo;
    PEBTEB_POINTER(ULONG_PTR) Win32ClientInfo[WIN32_CLIENT_INFO_LENGTH]; // User32 Client Info
    PEBTEB_POINTER(PVOID) glDispatchTable[233];     // OpenGL
    PEBTEB_POINTER(ULONG_PTR) glReserved1[29];      // OpenGL
    PEBTEB_POINTER(PVOID) glReserved2;              // OpenGL
    PEBTEB_POINTER(PVOID) glSectionInfo;            // OpenGL
    PEBTEB_POINTER(PVOID) glSection;                // OpenGL
    PEBTEB_POINTER(PVOID) glTable;                  // OpenGL
    PEBTEB_POINTER(PVOID) glCurrentRC;              // OpenGL
    PEBTEB_POINTER(PVOID) glContext;                // OpenGL
    ULONG LastStatusValue;
    PEBTEB_STRUCT(UNICODE_STRING) StaticUnicodeString;
    WCHAR StaticUnicodeBuffer[STATIC_UNICODE_BUFFER_LENGTH];
    PEBTEB_POINTER(PVOID) DeallocationStack;
    PEBTEB_POINTER(PVOID) TlsSlots[TLS_MINIMUM_AVAILABLE];
    PEBTEB_STRUCT(LIST_ENTRY) TlsLinks;
    PEBTEB_POINTER(PVOID) Vdm;
    PEBTEB_POINTER(PVOID) ReservedForNtRpc;
    PEBTEB_POINTER(PVOID) DbgSsReserved[2];
    ULONG HardErrorMode;
    PEBTEB_POINTER(PVOID) Instrumentation[16];
    PEBTEB_POINTER(PVOID) WinSockData;              // WinSock
    ULONG GdiBatchCount;
    BOOLEAN InDbgPrint;
    BOOLEAN FreeStackOnTermination;
    BOOLEAN HasFiberData;
    BOOLEAN IdealProcessor;
    ULONG Spare3;
    PEBTEB_POINTER(PVOID) ReservedForPerf;
    PEBTEB_POINTER(PVOID) ReservedForOle;
    ULONG WaitingOnLoaderLock;
    PEBTEB_STRUCT(WX86THREAD) Wx86Thread;
    PEBTEB_POINTER(PPVOID) TlsExpansionSlots;
#if (defined(_WIN64) && !defined(PEBTEB_BITS)) \
    || ((defined(_WIN64) || defined(_X86_)) && defined(PEBTEB_BITS) && PEBTEB_BITS == 64)
    //
    // These are in native Win64 TEB, Win64 TEB64, and x86 TEB64.
    //
    PEBTEB_POINTER(PVOID) DeallocationBStore;
    PEBTEB_POINTER(PVOID) BStoreLimit;
#endif    
    LCID ImpersonationLocale;       // Current locale of impersonated user
    ULONG IsImpersonating;          // Thread impersonation status
    PEBTEB_POINTER(PVOID) NlsCache;                 // NLS thread cache
    PEBTEB_POINTER(PVOID) pShimData;                // Per thread data used in the shim
    ULONG HeapVirtualAffinity;
    PEBTEB_POINTER(HANDLE) CurrentTransactionHandle;// reserved for TxF transaction context
    PEBTEB_POINTER(PTEB_ACTIVE_FRAME) ActiveFrame;
    PEBTEB_POINTER(PVOID) FlsData;
    
} PEBTEB_STRUCT(TEB), *PEBTEB_STRUCT(PTEB);

#undef PEBTEB_POINTER
#undef PEBTEB_STRUCT
#undef PEBTEB_PRIVATE_PASTE
#undef PEBTEB_PASTE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\penwin.h ===
/****************************************************************************\
*                                                                            *
* PENWIN.H -  Pen Windows functions, types, and definitions                  *
*                                                                            *
*             Version 2.0                                                    *
*                                                                            *
*             Copyright (c) 1992-1999 Microsoft Corp. All rights reserved.   *
*                                                                            *
*******************************************************************************
*
* The following symbols control inclusion of various parts of this file;
* (indented identifiers are included by the previous main identifier):
*
* #define:         To prevent inclusion of:
*
* PENVER           Pen Windows version number (0x0200).  To exclude
*                   definitions introduced in version 2.0 (or above)
*                   #define PENVER 0x0100 before #including <penwin.h>
*
* NOJAPAN          JAPAN-specific code
* NOPENALC         Alphabet Code definitions and macros
* NOPENAPPS        Pen Applications: Screen Keyboard
* NOPENCTL         H/BEDIT, IEDIT, and pen-enabled USER controls, including:
*   NOPENBEDIT      : Boxed Edit Control
*   NOPENIEDIT      : Ink Edit Control
*   NOPENHEDIT      : (H)Edit control
* NOPENDATA        PenData APIs and definitions
* NOPENDICT        Dictionary support
* NOPENDRIVER      Pen Driver definitions, incl OEM
* NOPENHRC         Handwriting Recognizer APIs and definitions
* NOPENINKPUT      Inking and Input APIs and definitions
* NOPENMISC        Miscellaneous Info and Utility APIs and definitions
* NOPENMSGS        Pen Messages and definitions
* NOPENNLS         National Language Support
* NOPENRC1         Recognition Context APIs and definitions (1.0)
* NOPENRES         Pen resources, including:
*   NOPENBMP        : Pen-related bitmaps
*   NOPENCURS       : Pen-related cursors
* NOPENTARGET      Targeting APIs and definitions
* NOPENVIRTEVENT   Virtual Event layer APIs
*
* _WIN32           non-Win32 components, subincludes:
*                   : NOPENAPPS, NOPENDICT, NOPENRC1, NOPENVIRTEVENT
*
* "FBC" in the comments means that the feature exists only for
* backward compatibility. It should not be used by new applications.
\****************************************************************************/

#ifndef _INC_PENWIN
#define _INC_PENWIN

#if _MSC_VER > 1000
#pragma once
#endif

///////////////////////////////////////////////////
#ifndef NOJAPAN   // unless expressly overridden...
#ifndef JAPAN
#define JAPAN     // This is the Japanese version!
#endif //!JAPAN
#endif //!NOJAPAN
///////////////////////////////////////////////////

#include <windows.h>

#ifndef _WIN32
#ifndef RC_INVOKED
#pragma pack(1)
#endif /* RC_INVOKED */
#endif //!_WIN32

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#ifndef PENVER      /* may be pre-defined; otherwise assume version 2.0 */
    #define PENVER  0x0200
#endif //!PENVER

#ifdef _WIN32
    #define NOPENAPPS
    #define NOPENDICT
    #define NOPENRC1
    #define NOPENVIRTEVENT
    #define NOPENAPIFUN
#endif //_WIN32

#ifndef NOPENAPPS   // not available in WIN32
#ifndef RC_INVOKED
    #include <skbapi.h>
#endif /* !RC_INVOKED */
#endif /*!NOPENAPPS */

// other subsets:

#ifdef NOPENCTL
    #define NOPENBEDIT
    #define NOPENIEDIT
#endif /* NOPENCTL */

#ifdef NOPENRES
    #define NOPENBMP
    #define NOPENCURS
#endif /* NOPENRES */

//////////////////////////////////////////////////////////////////////////////
/****** Definitions 1: for everything including RC compiler *****************/

//---------------------------------------------------------------------------
#ifndef NOPENALC

// Enabled Alphabet:
#define ALC_DEFAULT          0x00000000L // nothing
#define ALC_LCALPHA          0x00000001L // a..z
#define ALC_UCALPHA          0x00000002L // A..Z
#define ALC_NUMERIC          0x00000004L // 0..9
#define ALC_PUNC             0x00000008L // !-;`"?()&.,; and backslash
#define ALC_MATH             0x00000010L // %^*()-+={}<>,/.
#define ALC_MONETARY         0x00000020L // ,.$ or local
#define ALC_OTHER            0x00000040L // @#|_~[]
#define ALC_ASCII            0x00000080L // restrict to 7-bit chars 20..7f
#define ALC_WHITE            0x00000100L // white space
#define ALC_NONPRINT         0x00000200L // sp tab ret ctrl glyphs
#define ALC_DBCS             0x00000400L // allow DBCS variety of SBCS
#define ALC_JIS1             0x00000800L // kanji JPN, ShiftJIS 1 only
#define ALC_GESTURE          0x00004000L // gestures
#define ALC_USEBITMAP        0x00008000L // use rc.rgbfAlc to enable chars
#define ALC_HIRAGANA         0x00010000L // hiragana JPN
#define ALC_KATAKANA         0x00020000L // katakana JPN
#define ALC_KANJI            0x00040000L // kanji JPN, ShiftJIS 1+2+3
#define ALC_GLOBALPRIORITY   0x10000000L
#define ALC_OEM              0x0FF80000L // OEM recognizer-specific
#define ALC_RESERVED         0xE0003000L // avail for future use
#define ALC_NOPRIORITY       0x00000000L // for alcPriority == none

#define ALC_ALPHA\
    (ALC_LCALPHA | ALC_UCALPHA)                                // 0x00000003L

#define ALC_ALPHANUMERIC\
    (ALC_ALPHA | ALC_NUMERIC)                                  // 0x00000007L

#define ALC_SYSMINIMUM\
    (ALC_ALPHANUMERIC | ALC_PUNC | ALC_WHITE | ALC_GESTURE)    // 0x0000410FL

#define ALC_ALL\
    (ALC_SYSMINIMUM | ALC_MATH | ALC_MONETARY\
    | ALC_OTHER | ALC_NONPRINT)                                // 0x0000437FL

#define ALC_KANJISYSMINIMUM\
    (ALC_SYSMINIMUM | ALC_HIRAGANA | ALC_KATAKANA | ALC_JIS1)  // 0x0003490FL

#define ALC_KANJIALL\
    (ALC_ALL | ALC_HIRAGANA | ALC_KATAKANA | ALC_KANJI)        // 0x0007437FL

#endif /*!NOPENALC */

//---------------------------------------------------------------------------
#ifndef NOPENBEDIT
// box edit styles:
#define BXS_NONE             0x0000U // none
#define BXS_RECT             0x0001U // use rectangle instead of cusp
#define BXS_BOXCROSS         0x0004U // use cross at box center
#ifdef JAPAN
#define BXS_NOWRITING        0x0008U // no pen input into control
#else
#endif //JAPAN

#endif /*!NOPENBEDIT */

//---------------------------------------------------------------------------
#ifndef NOPENBMP

// Public Bitmaps :
#define OBM_SKBBTNUP            32767
#define OBM_SKBBTNDOWN          32766
#define OBM_SKBBTNDISABLED      32765

#define OBM_ZENBTNUP            32764
#define OBM_ZENBTNDOWN          32763
#define OBM_ZENBTNDISABLED      32762

#define OBM_HANBTNUP            32761
#define OBM_HANBTNDOWN          32760
#define OBM_HANBTNDISABLED      32759

#define OBM_KKCBTNUP            32758
#define OBM_KKCBTNDOWN          32757
#define OBM_KKCBTNDISABLED      32756

#define OBM_SIPBTNUP            32755
#define OBM_SIPBTNDOWN          32754
#define OBM_SIPBTNDISABLED      32753

#define OBM_PTYBTNUP            32752
#define OBM_PTYBTNDOWN          32751
#define OBM_PTYBTNDISABLED      32750

#endif /*!NOPENBMP */

//---------------------------------------------------------------------------
#ifndef NOPENCURS
// Default pen cursor to indicate writing, points northwest
#define IDC_PEN         MAKEINTRESOURCE(32631)

// alternate select cursor: upsidedown standard arrow, points southeast
#define IDC_ALTSELECT   MAKEINTRESOURCE(32501)

#endif /*!NOPENCURS */

//---------------------------------------------------------------------------
#ifndef NOPENHRC
// special SYV values:
#define SYV_NULL                0x00000000L
#define SYV_UNKNOWN             0x00000001L
#define SYV_EMPTY               0x00000003L
#define SYV_BEGINOR             0x00000010L
#define SYV_ENDOR               0x00000011L
#define SYV_OR                  0x00000012L
#define SYV_SOFTNEWLINE         0x00000020L
#define SYV_SPACENULL           0x00010000L   // SyvCharacterToSymbol('\0')

// SYV values for gestures:
#define SYV_SELECTFIRST         0x0002FFC0L   // . means circle in following
#define SYV_LASSO               0x0002FFC1L   // lasso o-tap
#define SYV_SELECTLEFT          0x0002FFC2L   // no glyph
#define SYV_SELECTRIGHT         0x0002FFC3L   // no glyph
#define SYV_SELECTLAST          0x0002FFCFL   // 16 SYVs reserved for selection

#define SYV_CLEARCHAR           0x0002FFD2L   // d.
#define SYV_HELP                0x0002FFD3L   // no glyph
#define SYV_KKCONVERT           0x0002FFD4L   // k.
#define SYV_CLEAR               0x0002FFD5L   // d.
#define SYV_INSERT              0x0002FFD6L   // ^.
#define SYV_CONTEXT             0x0002FFD7L   // m.
#define SYV_EXTENDSELECT        0x0002FFD8L   // no glyph
#define SYV_UNDO                0x0002FFD9L   // u.
#define SYV_COPY                0x0002FFDAL   // c.
#define SYV_CUT                 0x0002FFDBL   // x.
#define SYV_PASTE               0x0002FFDCL   // p.
#define SYV_CLEARWORD           0x0002FFDDL   // no glyph
#define SYV_USER                0x0002FFDEL   // reserved
#define SYV_CORRECT             0x0002FFDFL   // check.

#define SYV_BACKSPACE           0x00020008L   // no glyph
#define SYV_TAB                 0x00020009L   // t.
#define SYV_RETURN              0x0002000DL   // n.
#define SYV_SPACE               0x00020020L   // s.

// Application specific gestures, Circle a-z and Circle A-Z:
#define SYV_APPGESTUREMASK      0x00020000L
#define SYV_CIRCLEUPA           0x000224B6L   // map into Unicode space
#define SYV_CIRCLEUPZ           0x000224CFL   //  for circled letters
#define SYV_CIRCLELOA           0x000224D0L
#define SYV_CIRCLELOZ           0x000224E9L

// SYV definitions for shapes:
#define SYV_SHAPELINE           0x00040001L
#define SYV_SHAPEELLIPSE        0x00040002L
#define SYV_SHAPERECT           0x00040003L
#define SYV_SHAPEMIN            SYV_SHAPELINE // alias
#define SYV_SHAPEMAX            SYV_SHAPERECT // alias

// SYV classes:
#define SYVHI_SPECIAL           0
#define SYVHI_ANSI              1
#define SYVHI_GESTURE           2
#define SYVHI_KANJI             3
#define SYVHI_SHAPE             4
#define SYVHI_UNICODE           5
#define SYVHI_VKEY              6
#endif //!NOPENHRC

//---------------------------------------------------------------------------
#ifndef NOPENIEDIT

// IEdit Pop-up Menu Command Items
#define IEM_UNDO                1          // Undo
#define IEM_CUT                 2          // Cut
#define IEM_COPY                3          // Copy
#define IEM_PASTE               4          // Paste
#define IEM_CLEAR               5          // Clear
#define IEM_SELECTALL           6          // Select All Strokes
#define IEM_ERASE               7          // Use Eraser
#define IEM_PROPERTIES          8          // DoProperties
#define IEM_LASSO               9          // Use Lasso
#define IEM_RESIZE              10         // Resize

#define IEM_USER                    100    // first menu item# available to app

// IEdit Style Attributes
#define IES_BORDER              0x0001   // ctl has a border
#define IES_HSCROLL             0x0002   // ctl is horizontally scrollable
#define IES_VSCROLL             0x0004   // ctl is vertically scrollable
#define IES_OWNERDRAW           0x0008   // ctl will be drawn by parent window

#endif /*!NOPENIEDIT */

#ifndef RC_INVOKED  // ... rest of file of no interest to rc compiler
//////////////////////////////////////////////////////////////////////////////

/****** Definitions 2: RC compiler excluded ********************************/

//---------------------------------------------------------------------------
#ifndef NOPENDATA

// PenData API constants:

// ANIMATEINFO callback options:
#define AI_CBSTROKE             0xFFFF  // Animate callback after every stroke

// ANIMATEINFO options:
#define AI_SKIPUPSTROKES        0x0001  // ignore upstrokes in animation

// CompressPenData() API options:
#define CMPD_COMPRESS           0x0001
#define CMPD_DECOMPRESS         0x0002

// CreatePenDataRegion types:
#define CPDR_BOX                1       // bounding box
#define CPDR_LASSO              2       // lasso

// CreatePenData (CPD) and Pen Hardware (PHW) Flags;
// The order of PHW flags is important:
#define CPD_DEFAULT             0x047F  // CPD_TIME | PHW_ALL
#define CPD_USERBYTE            0x0100  // alloc 8 bits/stroke
#define CPD_USERWORD            0x0200  // alloc 16 bits/stroke
#define CPD_USERDWORD           0x0300  // alloc 32 bits/stroke
#define CPD_TIME                0x0400  // maintain abs time info per stroke

// DrawPenDataEx() flags/options:
#define DPD_HDCPEN              0x0001  // use pen selected in HDC
#define DPD_DRAWSEL             0x0002  // draw the selection

// ExtractPenDataPoints options (EPDP_xx):
#define EPDP_REMOVE             0x0001  // Remove points from the pendata

// ExtractPenDataStrokes options and modifiers (EPDS_xx):
#define EPDS_SELECT             1       // selected strokes
#define EPDS_STROKEINDEX        2       // index
#define EPDS_USER               3       // user-specific value
#define EPDS_PENTIP             4       // complete pentip
#define EPDS_TIPCOLOR           5       // pentip color
#define EPDS_TIPWIDTH           6       // pentip width
#define EPDS_TIPNIB             7       // pentip nib style
#define EPDS_INKSET             8       // inkset match

#define EPDS_EQ                 0x0000  // default: same as
#define EPDS_LT                 0x0010  // all strokes less than
#define EPDS_GT                 0x0020  // all strokes greater than
#define EPDS_NOT                0x0040  // all strokes not matching
#define EPDS_NE                 0x0040  // alias
#define EPDS_GTE                0x0050  // alias for NOT LT
#define EPDS_LTE                0x0060  // alias for NOT GT

#define EPDS_REMOVE             0x8000  // remove matching strokes from source

// GetPenDataAttributes options (GPA_xx):
#define GPA_MAXLEN              1   // length of longest stroke
#define GPA_POINTS              2   // total number of points
#define GPA_PDTS                3   // PDTS_xx bits
#define GPA_RATE                4   // get sampling rate
#define GPA_RECTBOUND           5   // bounding rect of all points
#define GPA_RECTBOUNDINK        6   // ditto, adj for fat ink
#define GPA_SIZE                7   // size of pendata in bytes
#define GPA_STROKES             8   // total number of strokes
#define GPA_TIME                9   // absolute time at creation of pendata
#define GPA_USER                10  // number of user bytes available: 0, 1, 2, 4
#define GPA_VERSION             11  // version number of pendata

// GetStrokeAttributes options (GSA_xx):
#define GSA_PENTIP              1   // get stroke pentip (color, width, nib)
#define GSA_PENTIPCLASS         2   // same as GSA_PENTIP
#define GSA_USER                3   // get stroke user value
#define GSA_USERCLASS           4   // get stroke's class user value
#define GSA_TIME                5   // get time of stroke
#define GSA_SIZE                6   // get size of stroke in points and bytes
#define GSA_SELECT              7   // get selection status of stroke
#define GSA_DOWN                8   // get up/down state of stroke
#define GSA_RECTBOUND           9   // get the bounding rectangle of the stroke

// GetStrokeTableAttributes options (GSA_xx):
#define GSA_PENTIPTABLE         10  // get table-indexed pentip
#define GSA_SIZETABLE           11  // get count of Stroke Class Table entries
#define GSA_USERTABLE           12  // get table-indexed user value

#ifndef IX_END
#define IX_END                  0xFFFF  // to or past last available index
#endif //!IX_END

// PenTip:
#define PENTIP_NIBDEFAULT       ((BYTE)0)       // default pen tip nib style
#define PENTIP_HEIGHTDEFAULT    ((BYTE)0)       // default pen tip nib height
#define PENTIP_OPAQUE           ((BYTE)0xFF)    // default opaque ink
#define PENTIP_HILITE           ((BYTE)0x80)
#define PENTIP_TRANSPARENT      ((BYTE)0)

// General PenData API return values (PDR_xx):
#define PDR_NOHIT               3       // hit test failed
#define PDR_HIT                 2       // hit test succeeded
#define PDR_OK                  1       // success
#define PDR_CANCEL              0       // callback cancel or impasse

#define PDR_ERROR               (-1)    // parameter or unspecified error
#define PDR_PNDTERR             (-2)    // bad pendata
#define PDR_VERSIONERR          (-3)    // pendata version error
#define PDR_COMPRESSED          (-4)    // pendata is compressed
#define PDR_STRKINDEXERR        (-5)    // stroke index error
#define PDR_PNTINDEXERR         (-6)    // point index error
#define PDR_MEMERR              (-7)    // memory error
#define PDR_INKSETERR           (-8)    // bad inkset
#define PDR_ABORT               (-9)    // pendata has become invalid, e.g.
#define PDR_NA                  (-10)   // option not available (pw kernel)

#define PDR_USERDATAERR         (-16)   // user data error
#define PDR_SCALINGERR          (-17)   // scale error
#define PDR_TIMESTAMPERR        (-18)   // timestamp error
#define PDR_OEMDATAERR          (-19)   // OEM data error
#define PDR_SCTERR              (-20)   // SCT error (full)

// PenData Scaling (PDTS):
#define PDTS_LOMETRIC           0       // 0.01mm
#define PDTS_HIMETRIC           1       // 0.001mm
#define PDTS_HIENGLISH          2       // 0.001"
#define PDTS_STANDARDSCALE      2       // PDTS_HIENGLISH   alias
#define PDTS_DISPLAY            3       // display pixel
#define PDTS_ARBITRARY          4       // app-specific scaling
#define PDTS_SCALEMASK          0x000F  // scaling values in low nibble

// CompactPenData() API trim options:
#define PDTT_DEFAULT            0x0000
#define PDTT_PENINFO            0x0100
#define PDTT_UPPOINTS           0x0200
#define PDTT_OEMDATA            0x0400
#define PDTT_COLLINEAR          0x0800
#define PDTT_COLINEAR           0x0800  // alt sp alias
#define PDTT_DECOMPRESS         0x4000  // decompress the data
#define PDTT_COMPRESS           0x8000
#define PDTT_ALL                0x0F00  // PENINFO|UPPOINTS|OEMDATA|COLLINEAR

#define PHW_NONE                0x0000  // no OEMdata
#define PHW_PRESSURE            0x0001  // report pressure in OEMdata if avail
#define PHW_HEIGHT              0x0002  // ditto height
#define PHW_ANGLEXY             0x0004  // ditto xy angle
#define PHW_ANGLEZ              0x0008  // ditto z angle
#define PHW_BARRELROTATION      0x0010  // ditto barrel rotation
#define PHW_OEMSPECIFIC         0x0020  // ditto OEM-specific value
#define PHW_PDK                 0x0040  // report per-point PDK_xx in OEM data
#define PHW_ALL                 0x007F  // report everything

// compact pen data trim options: matches PDTT_values (see above)
#define PDTS_COMPRESS2NDDERIV   0x0010  // compress using 2nd deriv
#define PDTS_COMPRESSMETHOD     0x00F0  // sum of compress method flags
#define PDTS_NOPENINFO          0x0100  // removes PENINFO struct from header
#define PDTS_NOUPPOINTS         0x0200  // remove up pts
#define PDTS_NOOEMDATA          0x0400  // remove OEM data
#define PDTS_NOCOLLINEAR        0x0800  // remove successive identical pts
#define PDTS_NOCOLINEAR         0x0800  // alt sp alias
#define PDTS_NOTICK             0x1000  // remove timing info (2.0)
#define PDTS_NOUSER             0x2000  // remove user info (2.0)
#define PDTS_NOEMPTYSTROKES     0x4000  // remove empty strokes (2.0)
#define PDTS_COMPRESSED         0x8000  // perform lossless compression

// SetStrokeAttributes options (SSA_xx):
#define SSA_PENTIP              1       // set stroke tip (color, width, nib)
#define SSA_PENTIPCLASS         2       // set stroke's class pentip
#define SSA_USER                3       // set stroke user value
#define SSA_USERCLASS           4       // set stroke's class user value
#define SSA_TIME                5       // set time of stroke
#define SSA_SELECT              6       // set selection status of stroke
#define SSA_DOWN                7       // set up/down state of stroke

// SetStrokeTableAttributes options (SSA_xx):
#define SSA_PENTIPTABLE         8       // set table-indexed pentip
#define SSA_USERTABLE           9       // set table-indexed user value

// PenTip flag bits:
#define TIP_ERASECOLOR          1       // erase specific color pentip.rgb

// TrimPenData() API options:
#define TPD_RECALCSIZE          0x0000  // no trim, used for resize calc
#define TPD_USER                0x0080  // per-stroke user info
#define TPD_TIME                0x0100  // per-stroke timing info
#define TPD_UPPOINTS            0x0200  // x-y data up points
#define TPD_COLLINEAR           0x0400  // colinear and coincident points
#define TPD_COLINEAR            0x0400  // alt sp alias
#define TPD_PENINFO             0x0800  // PenInfo struct and all OEM
#define TPD_PHW                 0x1000  // OEM & pdk except stroke tick or user
#define TPD_OEMDATA             0x1000  // ditto
#define TPD_EMPTYSTROKES        0x2000  // strokes with zero points
#define TPD_EVERYTHING          0x3FFF  // everything (incl PHW_xx) except down pts

#endif /*!NOPENDATA */

//---------------------------------------------------------------------------
#ifndef NOPENDICT   // not available in WIN32

// Dictionary:
#define cbDictPathMax           255
#define DIRQ_QUERY              1
#define DIRQ_DESCRIPTION        2
#define DIRQ_CONFIGURE          3
#define DIRQ_OPEN               4
#define DIRQ_CLOSE              5
#define DIRQ_SETWORDLISTS       6
#define DIRQ_STRING             7
#define DIRQ_SUGGEST            8
#define DIRQ_ADD                9
#define DIRQ_DELETE             10
#define DIRQ_FLUSH              11
#define DIRQ_RCCHANGE           12
#define DIRQ_SYMBOLGRAPH        13
#define DIRQ_INIT               14
#define DIRQ_CLEANUP            15
#define DIRQ_COPYRIGHT          16
#define DIRQ_USER               4096
#endif /*!NOPENDICT */

//---------------------------------------------------------------------------
#ifndef NOPENDRIVER

// Pen driver:
#define BITPENUP                0x8000

// Pen Driver messages:
#define DRV_SetPenDriverEntryPoints     DRV_RESERVED+1
#define DRV_SetEntryPoints              DRV_RESERVED+1  // alias
#define DRV_RemovePenDriverEntryPoints  DRV_RESERVED+2
#define DRV_RemoveEntryPoints           DRV_RESERVED+2  // alias
#define DRV_SetPenSamplingRate          DRV_RESERVED+3
#define DRV_SetPenSamplingDist          DRV_RESERVED+4
#define DRV_GetName                     DRV_RESERVED+5
#define DRV_GetVersion                  DRV_RESERVED+6
#define DRV_GetPenInfo                  DRV_RESERVED+7
#define DRV_PenPlayStart                DRV_RESERVED+8
#define DRV_PenPlayBack                 DRV_RESERVED+9
#define DRV_PenPlayStop                 DRV_RESERVED+10
#define DRV_GetCalibration              DRV_RESERVED+11
#define DRV_SetCalibration              DRV_RESERVED+12
#define DRV_Reserved1                   DRV_RESERVED+13
#define DRV_Reserved2                   DRV_RESERVED+14
#define DRV_Query                       DRV_RESERVED+15
#define DRV_GetPenSamplingRate          DRV_RESERVED+16
#define DRV_Calibrate                   DRV_RESERVED+17

// Pen Driver Playback constants:
#define PLAY_VERSION_10_DATA 0
#define PLAY_VERSION_20_DATA 1

// Pen Driver return values:
#define DRV_FAILURE             0x00000000
#define DRV_SUCCESS             0x00000001
#define DRV_BADPARAM1           0xFFFFFFFF
#define DRV_BADPARAM2           0xFFFFFFFE
#define DRV_BADSTRUCT           0xFFFFFFFD

// Pen Driver register messages flags:
#define PENREG_DEFAULT          0x00000002
#define PENREG_WILLHANDLEMOUSE  0x00000001

#define MAXOEMDATAWORDS         6             // rgwOemData[MAXOEMDATAWORDS]

// Pen Collection Mode termination conditions:
// (note update doc for PCMINFO struct if change these)
#define PCM_PENUP               0x00000001L   // stop on penup
#define PCM_RANGE               0x00000002L   // stop on leaving range
#define PCM_INVERT              0x00000020L   // stop on tap of opposite end
#define PCM_RECTEXCLUDE         0x00002000L   // click in exclude rect
#define PCM_RECTBOUND           0x00004000L   // click outside bounds rect
#define PCM_TIMEOUT             0x00008000L   // no activity for timeout ms
// new for 2.0:
#define PCM_RGNBOUND            0x00010000L   // click outside bounding region
#define PCM_RGNEXCLUDE          0x00020000L   // click in exclude region
#define PCM_DOPOLLING           0x00040000L   // polling mode
#define PCM_TAPNHOLD            0x00080000L   // check for Tap And Hold
#define PCM_ADDDEFAULTS         RC_LDEFAULTFLAGS /* 0x80000000L */

// Pen Device Capabilities:
#define PDC_INTEGRATED          0x00000001L   // display==digitizer
#define PDC_PROXIMITY           0x00000002L   // detect non-contacting pen
#define PDC_RANGE               0x00000004L   // event on out-of-range
#define PDC_INVERT              0x00000008L   // pen opposite end detect
#define PDC_RELATIVE            0x00000010L   // pen driver coords
#define PDC_BARREL1             0x00000020L   // barrel button 1 present
#define PDC_BARREL2             0x00000040L   // ditto 2
#define PDC_BARREL3             0x00000080L   // ditto 3

// Pen Driver Kit states:
#define PDK_NULL                0x0000  // default to no flags set
#define PDK_UP                  0x0000  // PDK_NULL alias
#define PDK_DOWN                0x0001  // pentip switch ON due to contact
#define PDK_BARREL1             0x0002  // barrel1 switch depressed
#define PDK_BARREL2             0x0004  // ditto 2
#define PDK_BARREL3             0x0008  // ditto 3
#define PDK_SWITCHES            0x000f  // sum of down + barrels 1,2,3
#define PDK_TRANSITION          0x0010  // set by GetPenHwData
#define PDK_UNUSED10            0x0020
#define PDK_UNUSED20            0x0040
#define PDK_INVERTED            0x0080  // other end of pen used as tip
#define PDK_PENIDMASK           0x0F00  // bits 8..11 physical pen id (0..15)
#define PDK_UNUSED1000          0x1000
#define PDK_INKSTOPPED          0x2000  // Inking stopped
#define PDK_OUTOFRANGE          0x4000  // pen left range (OEM data invalid)
#define PDK_DRIVER              0x8000  // pen (not mouse) event

#define PDK_TIPMASK             0x0001  // mask for testing PDK_DOWN

// OEM-specific values for Pen Driver:
#define PDT_NULL                0
#define PDT_PRESSURE            1       // pressure supported
#define PDT_HEIGHT              2       // height above tablet
#define PDT_ANGLEXY             3       // xy (horiz) angle supported
#define PDT_ANGLEZ              4       // z (vert) angle supported
#define PDT_BARRELROTATION      5       // barrel is rotated
#define PDT_OEMSPECIFIC         16      // max

// Denotes the ID of the current packet
#define PID_CURRENT             (UINT)(-1)

// Recognition and GetPenHwData Returns:
#define REC_OEM                 (-1024) // first recognizer-specific debug val
#define REC_LANGUAGE            (-48)   // unsupported language field
#define REC_GUIDE               (-47)   // invalid GUIDE struct
#define REC_PARAMERROR          (-46)   // bad param
#define REC_INVALIDREF          (-45)   // invalid data ref param
#define REC_RECTEXCLUDE         (-44)   // invalid rect
#define REC_RECTBOUND           (-43)   // invalid rect
#define REC_PCM                 (-42)   // invalid lPcm parameter
#define REC_RESULTMODE          (-41)
#define REC_HWND                (-40)   // invalid window to send results to
#define REC_ALC                 (-39)   // invalid enabled alphabet
#define REC_ERRORLEVEL          (-38)   // invalid errorlevel
#define REC_CLVERIFY            (-37)   // invalid verification level
#define REC_DICT                (-36)   // invalid dict params
#define REC_HREC                (-35)   // invalid recognition handle
#define REC_BADEVENTREF         (-33)   // invalid wEventRef
#define REC_NOCOLLECTION        (-32)   // collection mode not set
#define REC_DEBUG               (-32)   // beginning of debug values
#define REC_POINTEREVENT        (-31)   // tap or tap&hold event
#define REC_BADHPENDATA         (-9)    // invalid hpendata header or locking
#define REC_OOM                 (-8)    // out of memory error
#define REC_NOINPUT             (-7)    // no data collected before termination
#define REC_NOTABLET            (-6)    // tablet not physically present
#define REC_BUSY                (-5)    // another task is using recognizer
#define REC_BUFFERTOOSMALL      (-4)    // ret by GetPenHwEventData()
#define REC_ABORT               (-3)    // recog stopped by EndPenCollection()
#define REC_NA                  (-2)    // function not available
#define REC_OVERFLOW            (-1)    // data overflow
#define REC_OK                  0       // interrim completion
#define REC_TERMBOUND           1       // hit outside bounding rect
#define REC_TERMEX              2       // hit inside exclusion rect
#define REC_TERMPENUP           3       // pen up
#define REC_TERMRANGE           4       // pen left proximity
#define REC_TERMTIMEOUT         5       // no writing for timeout ms
#define REC_DONE                6       // normal completion
#define REC_TERMOEM             512     // first recognizer-specific retval

#endif /*!NOPENDRIVER */

//---------------------------------------------------------------------------
#ifndef NOPENHRC

// Handwriting Recognizer:

// GetResultsHRC options:
#define GRH_ALL                 0       // get all results
#define GRH_GESTURE             1       // get only gesture results
#define GRH_NONGESTURE          2       // get all but gesture results

// Gesture sets for EnableGestureSetHRC (bit flags):
#ifdef JAPAN
#define GST_SEL                 0x00000001L   // sel & lasso
#define GST_CLIP                0x00000002L   // cut copy paste
#define GST_WHITE               0x00000004L   // sp tab ret
#define GST_KKCONVERT           0x00000008L   // kkconvert
#define GST_EDIT                0x00000010L   // insert correct undo clear
#define GST_SYS                 0x0000001FL   // all of the above
#define GST_CIRCLELO            0x00000100L   // lowercase circle
#define GST_CIRCLEUP            0x00000200L   // uppercase circle
#define GST_CIRCLE              0x00000300L   // all circle
#define GST_ALL                 0x0000031FL   // all of the above
#else
#define GST_SEL                 0x00000001L   // sel & lasso
#define GST_CLIP                0x00000002L   // cut copy paste
#define GST_WHITE               0x00000004L   // sp tab ret
#define GST_EDIT                0x00000010L   // insert correct undo clear
#define GST_SYS                 0x00000017L   // all of the above
#define GST_CIRCLELO            0x00000100L   // lowercase circle
#define GST_CIRCLEUP            0x00000200L   // uppercase circle
#define GST_CIRCLE              0x00000300L   // all circle
#define GST_ALL                 0x00000317L   // all of the above
#endif

// General HRC API return values (HRCR_xx):
#define HRCR_NORESULTS          4       // No possible results  to be found
#define HRCR_COMPLETE           3       // finished recognition
#define HRCR_GESTURE            2       // recognized gesture
#define HRCR_OK                 1       // success
#define HRCR_INCOMPLETE         0       // recognizer is processing input
#define HRCR_ERROR              (-1)    // invalid param or unspecified error
#define HRCR_MEMERR             (-2)    // memory error
#define HRCR_INVALIDGUIDE       (-3)    // invalid GUIDE struct
#define HRCR_INVALIDPNDT        (-4)    // invalid pendata
#define HRCR_UNSUPPORTED        (-5)    // recognizer does not support feature
#define HRCR_CONFLICT           (-6)    // training conflict
#define HRCR_HOOKED             (-8)    // hookasaurus ate the result

// system wordlist for AddWordsHWL:
#define HWL_SYSTEM              ((HWL)1)   // magic value means system wordlist

// inkset returns:
#define ISR_ERROR               (-1)    // Memory or other error
#define ISR_BADINKSET           (-2)    // bad source inkset
#define ISR_BADINDEX            (-3)    // bad inkset index

#ifndef IX_END
#define IX_END                  0xFFFF  // to or past last available index
#endif //!IX_END

#define MAXHOTSPOT              8       // max number of hotspots possible

// ProcessHRC time constants:
#define PH_MAX                  0xFFFFFFFFL   // recognize rest of ink
#define PH_DEFAULT              0xFFFFFFFEL   // reasonable time
#define PH_MIN                  0xFFFFFFFDL   // minimum time

// ResultsHookHRC options:
#define RHH_STD                 0       // GetResultsHRC
#define RHH_BOX                 1       // GetBoxResultsHRC

// SetWordlistCoercionHRC options:
#define SCH_NONE                0       // turn off coercion
#define SCH_ADVISE              1       // macro is hint only
#define SCH_FORCE               2       // some result is forced from macro

// Symbol Context Insert Modes
#define SCIM_INSERT             0       // insert
#define SCIM_OVERWRITE          1       // overwrite

// SetResultsHookHREC options:
#define SRH_HOOKALL             (HREC)1 // hook all recognizers

// SetInternationalHRC options:
#define SSH_RD                  1       // to right and down (English)
#define SSH_RU                  2       // to right and up
#define SSH_LD                  3       // to left and down (Hebrew)
#define SSH_LU                  4       // to left and up
#define SSH_DL                  5       // down and to the left (Chinese)
#define SSH_DR                  6       // down and to the right (Chinese)
#define SSH_UL                  7       // up and to the left
#define SSH_UR                  8       // up and to the right

#define SIH_ALLANSICHAR         1       // use all ANSI

// TrainHREC options:
#define TH_QUERY                0       // query the user if conflict
#define TH_FORCE                1       // ditto no query
#define TH_SUGGEST              2       // abandon training if conflict

// Return values for WCR_TRAIN Function
#define TRAIN_NONE              0x0000
#define TRAIN_DEFAULT           0x0001
#define TRAIN_CUSTOM            0x0002
#define TRAIN_BOTH              (TRAIN_DEFAULT | TRAIN_CUSTOM)

// Control values for TRAINSAVE
#define TRAIN_SAVE              0       // save changes that have been made
#define TRAIN_REVERT            1       // discard changes that have been made
#define TRAIN_RESET             2       // use factory settings

// ConfigRecognizer and ConfigHREC options:
#define WCR_RECOGNAME           0       // ConfigRecognizer 1.0
#define WCR_QUERY               1
#define WCR_CONFIGDIALOG        2
#define WCR_DEFAULT             3
#define WCR_RCCHANGE            4
#define WCR_VERSION             5
#define WCR_TRAIN               6
#define WCR_TRAINSAVE           7
#define WCR_TRAINMAX            8
#define WCR_TRAINDIRTY          9
#define WCR_TRAINCUSTOM         10
#define WCR_QUERYLANGUAGE       11
#define WCR_USERCHANGE          12

// ConfigHREC options:
#define WCR_PWVERSION           13      // ver of PenWin recognizer supports
#define WCR_GETALCPRIORITY      14      // get recognizer's ALC priority
#define WCR_SETALCPRIORITY      15      // set recognizer's ALC priority
#define WCR_GETANSISTATE        16      // get ALLANSICHAR state
#define WCR_SETANSISTATE        17      // set ALLANSICHAR if T
#define WCR_GETHAND             18      // get writing hand
#define WCR_SETHAND             19      // set writing hand
#define WCR_GETDIRECTION        20      // get writing direction
#define WCR_SETDIRECTION        21      // set writing direction
#define WCR_INITRECOGNIZER      22      // init recognizer and set user name
#define WCR_CLOSERECOGNIZER     23      // close recognizer

#define WCR_PRIVATE             1024

// sub-functions of WCR_USERCHANGE
#define CRUC_NOTIFY             0       // user name change
#define CRUC_REMOVE             1       // user name deleted

// Word List Types:
#define WLT_STRING              0       // one string
#define WLT_STRINGTABLE         1       // array of strings
#define WLT_EMPTY               2       // empty wordlist
#define WLT_WORDLIST            3       // handle to a wordlist

#endif /*!NOPENHRC */

//---------------------------------------------------------------------------
#ifndef NOPENIEDIT

// IEdit Background Options
#define IEB_DEFAULT             0       // default (use COLOR_WINDOW)
#define IEB_BRUSH               1       // paint background with brush
#define IEB_BIT_UL              2       // bitmap, upper-left aligned
#define IEB_BIT_CENTER          3       // bitmap, centered in control
#define IEB_BIT_TILE            4       // bitmap, tiled repeatedly in ctl
#define IEB_BIT_STRETCH         5       // bitmap, stretched to fit ctl
#define IEB_OWNERDRAW           6       // parent window will draw background

// IEdit Drawing Options
#define IEDO_NONE               0x0000  // no drawing
#define IEDO_FAST               0x0001  // ink drawn as fast as possible (def)
#define IEDO_SAVEUPSTROKES      0x0002  // save upstrokes
#define IEDO_RESERVED           0xFFFC  // reserved bits

// IEdit Input Options
#define IEI_MOVE                0x0001  // move ink into ctl
#define IEI_RESIZE              0x0002  // resize ink to fit within ctl
#define IEI_CROP                0x0004  // discard ink outside of ctl
#define IEI_DISCARD             0x0008  // discard all ink if any outside ctl
#define IEI_RESERVED            0xFFF0  // reserved

// IEdit IE_GETINK options
#define IEGI_ALL                0x0000  // get all ink from control
#define IEGI_SELECTION          0x0001  // get selected ink from control

// IEdit IE_SETMODE/IE_GETMODE (mode) options
#define IEMODE_READY            0       // default inking, moving, sizing mode
#define IEMODE_ERASE            1       // erasing Mode
#define IEMODE_LASSO            2       // lasso selection mode

// IEdit    Notification Bits
#define IEN_NULL                0x0000  // null notification
#define IEN_PDEVENT             0x0001  // notify about pointing device events
#define IEN_PAINT               0x0002  // send painting-related notifications
#define IEN_FOCUS               0x0004  // send focus-related notifications
#define IEN_SCROLL              0x0008  // send scrolling notifications
#define IEN_EDIT                0x0010  // send editing/change notifications
#define IEN_PROPERTIES          0x0020  // send properties dialog notification
#define IEN_RESERVED            0xFF80  // reserved

// IEdit Return Values
#define IER_OK                  0       // success
#define IER_NO                  0       // ctl cannot do request
#define IER_YES                 1       // ctl can do request
#define IER_ERROR               (-1)    // unspecified error; operation failed
#define IER_PARAMERR            (-2)    // bogus lParam value, bad handle, etc
#define IER_OWNERDRAW           (-3)    // can't set drawopts in ownerdraw ctl
#define IER_SECURITY            (-4)    // security protection disallows action
#define IER_SELECTION           (-5)    // nothing selected in control
#define IER_SCALE               (-6)    // merge:  incompatible scaling factors
#define IER_MEMERR              (-7)    // memory error
#define IER_NOCOMMAND           (-8)    // tried IE_GETCOMMAND w/no command
#define IER_NOGESTURE           (-9)    // tried IE_GETGESTURE w/no gesture
#define IER_NOPDEVENT           (-10)   // tried IE_GETPDEVENT but no event
#define IER_NOTINPAINT          (-11)   // tried IE_GETPAINTSTRUCT but no paint
#define IER_PENDATA             (-12)   // can't do request with NULL hpd in ctl

// IEdit Recognition Options
#define IEREC_NONE              0x0000  // No recognition
#define IEREC_GESTURE           0x0001  // Gesture recognition
#define IEREC_ALL               (IEREC_GESTURE)
#define IEREC_RESERVED          0xFFFE  // Reserved

// IEdit Security Options
#define IESEC_NOCOPY            0x0001  // copying disallowed
#define IESEC_NOCUT             0x0002  // cutting disallowed
#define IESEC_NOPASTE           0x0004  // pasting disallowed
#define IESEC_NOUNDO            0x0008  // undoing disallowed
#define IESEC_NOINK             0x0010  // inking  disallowed
#define IESEC_NOERASE           0x0020  // erasing disallowed
#define IESEC_NOGET             0x0040  // IE_GETINK message verboten
#define IESEC_NOSET             0x0080  // IE_SETINK message verboten
#define IESEC_RESERVED          0xFF00  // reserved

// IEdit IE_SETFORMAT/IE_GETFORMAT options
#define IESF_ALL                0x0001  // set/get stk fmt of all ink
#define IESF_SELECTION          0x0002  // set/get stk fmt of selected ink
#define IESF_STROKE             0x0004  // set/get stk fmt of specified stroke
//
#define IESF_TIPCOLOR           0x0008  // set color
#define IESF_TIPWIDTH           0x0010  // set width
#define IESF_PENTIP             (IESF_TIPCOLOR|IESF_TIPWIDTH)
//

// IEdit IE_SETINK options
#define IESI_REPLACE            0x0000  // replace ink in control
#define IESI_APPEND             0x0001  // append ink to existing control ink

// Ink Edit Control (IEdit) definitions
// IEdit Notifications
#define IN_PDEVENT      ((IEN_PDEVENT<<8)|0)   // pointing device event occurred
#define IN_ERASEBKGND   ((IEN_NULL<<8)|1)      // control needs bkgnd erased
#define IN_PREPAINT     ((IEN_PAINT<<8)|2)     // before control paints its ink
#define IN_PAINT        ((IEN_NULL<<8)|3)      // control needs to be painted
#define IN_POSTPAINT    ((IEN_PAINT<<8)|4)     // after control has painted
#define IN_MODECHANGED  ((IEN_EDIT<<8)|5)      // mode changed
#define IN_CHANGE       ((IEN_EDIT<<8)|6)      // contents changed & painted
#define IN_UPDATE       ((IEN_EDIT<<8)|7)      // contents changed & !painted
#define IN_SETFOCUS     ((IEN_FOCUS<<8)|8)     // IEdit is getting focus
#define IN_KILLFOCUS    ((IEN_FOCUS<<8)|9)     // IEdit is losing focus
#define IN_MEMERR       ((IEN_NULL<<8)|10)     // memory error
#define IN_HSCROLL      ((IEN_SCROLL<<8)|11)   // horz scrolled, not painted
#define IN_VSCROLL      ((IEN_SCROLL<<8)|12)   // vert scrolled, not painted
#define IN_GESTURE      ((IEN_EDIT<<8)|13)     // user has gestured on control
#define IN_COMMAND      ((IEN_EDIT<<8)|14)     // command selected from menu
#define IN_CLOSE        ((IEN_NULL<<8)|15)     // I-Edit is being closed
#define IN_PROPERTIES   ((IEN_PROPERTIES<<8)|16) // properties dialog

#endif /*!NOPENIEDIT */

//---------------------------------------------------------------------------
#ifndef NOPENINKPUT

// PenIn[k]put API constants

// Default Processing
#define LRET_DONE               1L
#define LRET_ABORT              (-1L)
#define LRET_HRC                (-2L)
#define LRET_HPENDATA           (-3L)
#define LRET_PRIVATE            (-4L)

// Inkput:
#define PCMR_OK                 0
#define PCMR_ALREADYCOLLECTING  (-1)
#define PCMR_INVALIDCOLLECTION  (-2)
#define PCMR_EVENTLOCK          (-3)
#define PCMR_INVALID_PACKETID   (-4)
#define PCMR_TERMTIMEOUT        (-5)
#define PCMR_TERMRANGE          (-6)
#define PCMR_TERMPENUP          (-7)
#define PCMR_TERMEX             (-8)
#define PCMR_TERMBOUND          (-9)
#define PCMR_APPTERMINATED      (-10)
#define PCMR_TAP                (-11)   // alias PCMR_TAPNHOLD_LAST
#define PCMR_SELECT             (-12)   // ret because of tap & hold
#define PCMR_OVERFLOW           (-13)
#define PCMR_ERROR              (-14)   // parameter or unspecified error
#define PCMR_DISPLAYERR         (-15)   // inking only
#define PCMR_TERMINVERT         (-16)   // termination due to tapping opposite end of pen

#define PII_INKCLIPRECT         0x0001
#define PII_INKSTOPRECT         0x0002
#define PII_INKCLIPRGN          0x0004
#define PII_INKSTOPRGN          0x0008
#define PII_INKPENTIP           0x0010
#define PII_SAVEBACKGROUND      0x0020
#define PII_CLIPSTOP            0x0040

#define PIT_RGNBOUND            0x0001
#define PIT_RGNEXCLUDE          0x0002
#define PIT_TIMEOUT             0x0004
#define PIT_TAPNHOLD            0x0008

#endif /*!NOPENINKPUT */

//---------------------------------------------------------------------------
#ifndef NOPENMISC

// Misc RC Definitions:
#define CL_NULL                 0
#define CL_MINIMUM              1       // minimum confidence level
#define CL_MAXIMUM              100     // max (require perfect recog)
#define cwRcReservedMax         8       // rc.rgwReserved[cwRcReservedMax]
#define ENUM_MINIMUM            1
#define ENUM_MAXIMUM            4096

#define HKP_SETHOOK             0       // SetRecogHook()
#define HKP_UNHOOK              0xFFFF

#define HWR_RESULTS             0
#define HWR_APPWIDE             1

#define iSycNull                (-1)
#define LPDFNULL                ((LPDF)NULL)
#define MAXDICTIONARIES         16      // rc.rglpdf[MAXDICTIONARIES]
#define wPntAll                 (UINT)0xFFFF
#define cbRcLanguageMax         44      // rc.lpLanguage[cbRcLanguageMax]
#define cbRcUserMax             32      // rc.lpUser[cbRcUserMax]
#define cbRcrgbfAlcMax          32      // rc.rgbfAlc[cbRcrgbfAlcMax]
#define RC_WDEFAULT             0xffff
#define RC_LDEFAULT             0xffffffffL
#define RC_WDEFAULTFLAGS        0x8000
#define RC_LDEFAULTFLAGS        0x80000000L

// CorrectWriting() API constants:
// LOWORD values:
#define CWR_REPLACECR           0x0001  // replace carriage ret (\r) with space
#define CWR_STRIPCR             CWR_REPLACECR  // alias for backward compatibility
#define CWR_STRIPLF             0x0002  // strip linefeed (\n)
#define CWR_REPLACETAB          0x0004  // replace tab with space (\t)
#define CWR_STRIPTAB            CWR_REPLACETAB // alias for backward compatibility
#define CWR_SINGLELINEEDIT      (CWR_REPLACECR|CWR_STRIPLF|CWR_REPLACETAB)  // all of the above
#define CWR_INSERT              0x0008  // use "Insert Text" instead of "Edit Text" in the title
#define CWR_TITLE               0x0010  // interpret dwParam as title string
#define CWR_SIMPLE              0x0040  // simple dialog (lens)
#define CWR_HEDIT               0x0080  // HEDIT CorrectWriting
#define CWR_KEYBOARD            0x0100  // keyboard lens
#define CWR_BOXES               0x0200  // bedit lens

// HIWORD values: keyboard types
#define CWRK_DEFAULT            0       // default keyboard type
#define CWRK_BASIC              1       // basic keyboard
#define CWRK_FULL               2       // full keyboard
#define CWRK_NUMPAD             3       // numeric keyboard
#define CWRK_TELPAD             4       // Telephone type keyboard

#ifdef JAPAN
// CorrectWritingEx constants:
#define CBCAPTIONCWX            256 // size of caption buffer
#define CKBCWX                  6   // number of keyboards
#define XCWX                    20  // default position and size
#define YCWX                    20
#define CXCWX                   300
#define CYCWX                   200

// CorrectWritingEx flags:
#define CWX_TOPMOST             0x00000001L
#define CWX_NOTOOLTIPS          0x00000002L
#define CWX_EPERIOD             0x00000004L
#define CWX_ECOMMA              0x00000008L
#define CWX_DEFAULT             0x00000000L

// CorrectWritingEx apply flags - if these bits are set, corresp field used:
#define CWXA_CONTEXT            0x0001 // use cwx.dwFlags
#define CWXA_KBD                0x0002 // use cwx.ixkb
#define CWXA_STATE              0x0004 // use cwx.rgState[]
#define CWXA_PTUL               0x0008 // use cwx.ptUL
#define CWXA_SIZE               0x0010 // use cwx.sizeHW
#define CWXA_NOUPDATEMRU        0x0020 // do not update Most Recently Used

// CorrectWritingEx keyboards:
#define CWXK_HW                 0 // handwriting input
#define CWXK_FIRST              0x0100 // First keyboard, for ordinality
#define CWXK_50                 0x0100 // 50-On kbd
#define CWXK_QWERTY             0x0101 // QWERTY kbd
#define CWXK_NUM                0x0102 // Tel/Num kbd
#define CWXK_KANJI              0x0103 // Kanji kbd
#define CWXK_CODE               0x0104 // Code finder kbd
#define CWXK_YOMI               0x0105 // Yomi ("reading") kbd

// CorrectWritingEx keyboard states:
#define CWXKS_DEFAULT           0xffff   // use existing kbd state
#define CWXKS_ZEN               0
#define CWXKS_HAN               1
#define CWXKS_ROMAZEN           2
#define CWXKS_ROMAHAN           3
#define CWXKS_HIRAZEN           4
#define CWXKS_KATAZEN           5
#define CWXKS_KATAHAN           6

// CorrectWritingEx returns:
#define CWXR_ERROR              -1 // error return
#define CWXR_UNMODIFIED         0  // user pressed cancel button or no change
#define CWXR_MODIFIED           1  // user pressed changed text and OK button
#endif //JAPAN

#ifdef JAPAN
#define GPMI_OK                 0L
#define GPMI_INVALIDPMI         0x8000L
#endif // JAPAN

// inkwidth limits
#define INKWIDTH_MINIMUM        0           // 0 invisible, 1..15 pixel widths
#define INKWIDTH_MAXIMUM        15          // max width in pixels

// Get/SetPenMiscInfo:
// PMI_RCCHANGE is for WM_GLOBALRCCHANGE compatability only:
#define PMI_RCCHANGE            0       // invalid for Get/SetPenMiscInfo

#define PMI_BEDIT               1       // boxed edit info
#ifdef JAPAN
#endif //JAPAN
#define PMI_CXTABLET            3       // tablet width
#define PMI_CYTABLET            4       // tablet height
#define PMI_PENTIP              6       // pen tip: color, width, nib
#define PMI_ENABLEFLAGS         7       // PWE_xx enablements
#define PMI_TIMEOUT             8       // handwriting timeout
#define PMI_TIMEOUTGEST         9       // gesture timeout
#define PMI_TIMEOUTSEL          10      // select (press&hold) timeout
#define PMI_SYSFLAGS            11      // component load configuration
#define PMI_INDEXFROMRGB        12      // color table index from RGB
#define PMI_RGBFROMINDEX        13      // RGB from color table index
#define PMI_SYSREC              14      // handle to system recognizer
#define PMI_TICKREF             15      // reference absolute time

#define PMI_SAVE                0x1000  // save setting to file

#ifdef JAPAN
// GetPenResource options:
#define GPR_CURSPEN             1       // standard pen cursor
#define GPR_CURSCOPY            2       // copy cursor
#define GPR_CURSUNKNOWN         3       // unknown cursor
#define GPR_CURSERASE           4       // erase cursor

#define GPR_BMCRMONO            5       // monochrome Return bitmap
#define GPR_BMLFMONO            6       // monochrome LineFeed bitmap
#define GPR_BMTABMONO           7       // monochrome Tab bitmap
#define GPR_BMDELETE            8       // delete bitmap
#define GPR_BMLENSBTN           9       // lens buttonface bitmap

#ifdef JAPAN
#define GPR_BMHSPMONO           10      // hankaku space bitmap
#define GPR_BMZSPMONO           11      // zenkaku space bitmap
#endif //JAPAN

#endif //JAPAN

// Set/GetPenMiscInfo/PMI_ENABLEFLAGS flags:
#define PWE_AUTOWRITE           0x0001  // pen functionality where IBeam
#define PWE_ACTIONHANDLES       0x0002  // action handles in controls
#define PWE_INPUTCURSOR         0x0004  // show cursor while writing
#define PWE_LENS                0x0008  // allow lens popup

// GetPenMiscInfo/PMI_SYSFLAGS flags:
#define PWF_RC1                 0x0001  // Windows for Pen 1.0 RC support
#define PWF_PEN                 0x0004  // pen drv loaded & hdwe init'd
#define PWF_INKDISPLAY          0x0008  // ink-compatible display drv loaded
#define PWF_RECOGNIZER          0x0010  // system recognizer installed
#define PWF_BEDIT               0x0100  // boxed edit support
#define PWF_HEDIT               0x0200  // free input edit support
#define PWF_IEDIT               0x0400  // ink edit support
#define PWF_ENHANCED            0x1000  // enh features (gest, 1ms timing)
#define PWF_FULL\
	PWF_RC1|PWF_PEN|PWF_INKDISPLAY|PWF_RECOGNIZER|\
	PWF_BEDIT|PWF_HEDIT |PWF_IEDIT|PWF_ENHANCED

// SetPenAppFlags() / RegisterPenApp() API constants:
#define RPA_DEFAULT             0x0001  // == RPA_HEDIT
#define RPA_HEDIT               0x0001  // convert EDIT to HEDIT
#define RPA_KANJIFIXEDBEDIT     0x0002
#define RPA_DBCSPRIORITY        0x0004  // assume DBCS has priority (Japan)
#define RPA_SBCSPRIORITY        0x0008  // assume SBCS has priority (Japan)

#define PMIR_OK                 0L
#define PMIR_INDEX              (-1L)
#define PMIR_VALUE              (-2L)
#define PMIR_INVALIDBOXEDITINFO (-3L)
#define PMIR_INIERROR           (-4L)
#define PMIR_ERROR              (-5L)
#define PMIR_NA                 (-6L)

#ifdef JAPAN
#define SPMI_OK                 0L
#define SPMI_INVALIDBOXEDITINFO 1L
#define SPMI_INIERROR           2L
#define SPMI_INVALIDPMI         0x8000L
#endif //JAPAN

#endif /*!NOPENMISC */

//---------------------------------------------------------------------------
#ifndef NOPENRC1    // not available in WIN32

// RC Options and Flags:
// GetGlobalRC() API return codes:
#define GGRC_OK                 0       // no err
#define GGRC_DICTBUFTOOSMALL    1       // lpDefDict buffer too small for path
#define GGRC_PARAMERROR         2       // invalid params: call ignored
#define GGRC_NA                 3       // function not available

// RC Direction:
#define RCD_DEFAULT             0       // def none
#define RCD_LR                  1       // left to right like English
#define RCD_RL                  2       // right to left like Arabic
#define RCD_TB                  3       // top to bottom like Japanese
#define RCD_BT                  4       // bottom to top like some Chinese

// RC International Preferences:
#define RCIP_ALLANSICHAR        0x0001  // all ANSI chars
#define RCIP_MASK               0x0001

// RC Options:
#define RCO_NOPOINTEREVENT      0x00000001L   // no recog tap, tap/hold
#define RCO_SAVEALLDATA         0x00000002L   // save pen data like upstrokes
#define RCO_SAVEHPENDATA        0x00000004L   // save pen data for app
#define RCO_NOFLASHUNKNOWN      0x00000008L   // no ? cursor on unknown
#define RCO_TABLETCOORD         0x00000010L   // tablet coords used in RC
#define RCO_NOSPACEBREAK        0x00000020L   // no space break recog -> dict
#define RCO_NOHIDECURSOR        0x00000040L   // display cursor during inking
#define RCO_NOHOOK              0x00000080L   // disallow ink hook (passwords)
#define RCO_BOXED               0x00000100L   // valid rc.guide provided
#define RCO_SUGGEST             0x00000200L   // for dict suggest
#define RCO_DISABLEGESMAP       0x00000400L   // disable gesture mapping
#define RCO_NOFLASHCURSOR       0x00000800L   // no cursor feedback
#define RCO_BOXCROSS            0x00001000L   // show + at boxedit center
#define RCO_COLDRECOG           0x00008000L   // result is from cold recog
#define RCO_SAVEBACKGROUND      0x00010000L   // Save background from ink
#define RCO_DODEFAULT           0x00020000L   // do default gesture processing

// RC Orientation of Tablet:
#define RCOR_NORMAL             1       // tablet not rotated
#define RCOR_RIGHT              2       // rotated 90 deg anticlockwise
#define RCOR_UPSIDEDOWN         3       // rotated 180 deg
#define RCOR_LEFT               4       // rotated 90 deg clockwise

// RC Preferences:
#define RCP_LEFTHAND            0x0001  // left handed input
#define RCP_MAPCHAR             0x0004  // fill in syg.lpsyc (ink) for training

// RCRESULT wResultsType values:
#define RCRT_DEFAULT            0x0000  // normal ret
#define RCRT_UNIDENTIFIED       0x0001  // result contains unidentified results
#define RCRT_GESTURE            0x0002  // result is a gesture
#define RCRT_NOSYMBOLMATCH      0x0004  // nothing recognized (no ink match)
#define RCRT_PRIVATE            0x4000  // recognizer-specific symbol
#define RCRT_NORECOG            0x8000  // no recog attempted, only data ret
#define RCRT_ALREADYPROCESSED   0x0008  // GestMgr hooked it
#define RCRT_GESTURETRANSLATED  0x0010  // GestMgr translated it to ANSI value
#define RCRT_GESTURETOKEYS      0x0020  // ditto to set of virtual keys

// RC Result Return Mode specification:
#define RRM_STROKE              0       // return results after each stroke
#define RRM_SYMBOL              1       // per symbol (e.g. boxed edits)
#define RRM_WORD                2       // on recog of a word
#define RRM_NEWLINE             3       // on recog of a line break
#define RRM_COMPLETE            16      // on PCM_xx specified completion

// SetGlobalRC() API return code flags:
#define SGRC_OK                 0x0000  // no err
#define SGRC_USER               0x0001  // invalid User name
#define SGRC_PARAMERROR         0x0002  // param error: call ignored
#define SGRC_RC                 0x0004  // supplied RC has errors
#define SGRC_RECOGNIZER         0x0008  // DefRecog name invalid
#define SGRC_DICTIONARY         0x0010  // lpDefDict path invalid
#define SGRC_INIFILE            0x0020  // error saving to penwin.ini
#define SGRC_NA                 0x8000  // function not available

#endif /*!NOPENRC1 */

//---------------------------------------------------------------------------

#ifndef NOPENTARGET

#define TPT_CLOSEST             0x0001   // Assign to the closest target
#define TPT_INTERSECTINK        0x0002   // target with intersecting ink
#define TPT_TEXTUAL             0x0004   // apply textual heuristics
#define TPT_DEFAULT             (TPT_TEXTUAL | TPT_INTERSECTINK | TPT_CLOSEST)

#endif /*!NOPENTARGET */

//---------------------------------------------------------------------------
#ifndef NOPENVIRTEVENT

// Virtual Event Layer:
#define VWM_MOUSEMOVE           0x0001
#define VWM_MOUSELEFTDOWN       0x0002
#define VWM_MOUSELEFTUP         0x0004
#define VWM_MOUSERIGHTDOWN      0x0008
#define VWM_MOUSERIGHTUP        0x0010
#endif /*!NOPENVIRTEVENT */

#endif /* RC_INVOKED */  // ... all the way back from definitions:2

/****** Messages and Defines ************************************************/

// Windows Messages WM_PENWINFIRST (0x0380) and WM_PENWINLAST (0x038F)
// are defined in WINDOWS.H and WINMIN.H

//---------------------------------------------------------------------------
#ifndef NOPENMSGS

#ifndef NOPENRC1    // not available in WIN32
#define WM_RCRESULT             (WM_PENWINFIRST+1)  // 0x381
#define WM_HOOKRCRESULT         (WM_PENWINFIRST+2)  // 0x382
#endif /*!NOPENRC1*/

#define WM_PENMISCINFO          (WM_PENWINFIRST+3)  // 0x383
#define WM_GLOBALRCCHANGE       (WM_PENWINFIRST+3)  // alias

#ifndef NOPENAPPS   // not available in WIN32
#define WM_SKB                  (WM_PENWINFIRST+4)  // 0x384
#endif /*!NOPENAPPS */

#define WM_PENCTL               (WM_PENWINFIRST+5)  // 0x385
#define WM_HEDITCTL             (WM_PENWINFIRST+5)  // FBC: alias

// WM_HEDITCTL (WM_PENCTL) wParam options:
#ifndef _WIN32
#define HE_GETRC                3       // FBC: get RC from HEDIT/BEDIT control
#define HE_SETRC                4       // FBC: ditto set
#define HE_GETINFLATE           5       // FBC: get inflate rect
#define HE_SETINFLATE           6       // FBC: ditto set
#endif //!_WIN32
#define HE_GETUNDERLINE         7       // get underline mode
#define HE_SETUNDERLINE         8       // ditto set
#define HE_GETINKHANDLE         9       // get handle to captured ink
#define HE_SETINKMODE           10      // begin HEDIT cold recog mode
#define HE_STOPINKMODE          11      // end cold recog mode
#ifndef _WIN32
#define HE_GETRCRESULTCODE      12      // FBC: result of recog after HN_ENDREC
#endif //!_WIN32
#define HE_DEFAULTFONT          13      // switch BEDIT to def font
#define HE_CHARPOSITION         14      // BEDIT byte offset -> char position
#define HE_CHAROFFSET           15      // BEDIT char position -> byte offset
#define HE_GETBOXLAYOUT         20      // get BEDIT layout
#define HE_SETBOXLAYOUT         21      // ditto set
#ifndef _WIN32
#define HE_GETRCRESULT          22      // FBC: get RCRESULT after HN_RCRESULT
#endif //!_WIN32
#ifdef JAPAN
#define HE_KKCONVERT            30      // JPN start kana-kanji conversion
#define HE_GETKKCONVERT         31      // JPN get KK state
#define HE_CANCELKKCONVERT      32      // JPN cancel KK conversion
#define HE_FIXKKCONVERT         33      // JPN force KK result
#define HE_GETKKSTATUS          34      // JPN get KK UI state
#define HE_SETCONVERTRANGE      35      // JPN set a range of DCS
#define HE_GETCONVERTRANGE      36      // JPN get a range of DCS
#define HE_PUTCONVERTCHAR       37      // JPN put a char of DCS
#endif //JAPAN
#define HE_ENABLEALTLIST        40      // en/disable dropdown recog alt's
#define HE_SHOWALTLIST          41      // show dropdown (assume enabled)
#define HE_HIDEALTLIST          42      // hide dropdown alternatives
#ifndef JAPAN
#define HE_GETLENSTYPE          43      // get lens type: CWR_ and CWRK_ flags
#define HE_SETLENSTYPE          44      // set lens type: CWR_ and CWRK_ flags
#endif //!JAPAN

#ifdef JAPAN
//------------------------------
// JPN Kana-to-Kanji conversion subfunctions:
#define HEKK_DEFAULT            0       // def
#define HEKK_CONVERT            1       // convert in place
#define HEKK_CANDIDATE          2       // start conversion dialog
#define HEKK_DBCSCHAR           3       // convert to DBCS
#define HEKK_SBCSCHAR           4       // convert to SBCS
#define HEKK_HIRAGANA           5       // convert to hiragana
#define HEKK_KATAKANA           6       // convert to katakana

//------------------------------
// JPN Return value of HE_GETKKSTATUS
#define HEKKR_NOCONVERT         0       // in no  conversion mode
#define HEKKR_PRECONVERT        1       // in pre conversion mode
#define HEKKR_CONVERT           2       // in mid conversion mode
#endif //JAPAN

// HE_STOPINKMODE (stop cold recog) options:
#define HEP_NORECOG             0       // don't recog ink
#define HEP_RECOG               1       // recog ink
#define HEP_WAITFORTAP          2       // recog after tap in window

// WM_PENCTL notifications:
#define HN_ENDREC               4       // recog complete
#define HN_DELAYEDRECOGFAIL     5       // HE_STOPINKMODE (cold recog) failed
#define HN_RESULT               20      // HEDIT/BEDIT has received new ink/recognition result
#ifndef _WIN32
#define HN_RCRESULT             HN_RESULT
#endif //!_WIN32
#ifdef JAPAN
#define HN_ENDKKCONVERT         30      // JPN KK conversion complete
#endif //JAPAN
#define HN_BEGINDIALOG          40      // Lens/EditText/garbage detection dialog
					//  is about to come up on this hedit/bedit
#define HN_ENDDIALOG            41      // Lens/EditText/garbage detection dialog
					//  has just been destroyed

//------------------------------
#ifndef NOPENIEDIT

// Messages common with other controls:
#define IE_GETMODIFY          (EM_GETMODIFY)    // gets the mod'n (dirty) bit
#define IE_SETMODIFY          (EM_SETMODIFY)    // sets the mod'n (dirty) bit
#define IE_CANUNDO            (EM_CANUNDO)      // queries whether can undo
#define IE_UNDO               (EM_UNDO)         // undo
#define IE_EMPTYUNDOBUFFER    (EM_EMPTYUNDOBUFFER) // clears IEDIT undo buffer

#define IE_MSGFIRST           (WM_USER+150)     // 0x496 == 1174

// IEdit common messages:
#define IE_GETINK             (IE_MSGFIRST+0)   // gets ink from the control
#define IE_SETINK             (IE_MSGFIRST+1)   // sets ink into the control
#define IE_GETPENTIP          (IE_MSGFIRST+2)   // gets the cur def ink pentip
#define IE_SETPENTIP          (IE_MSGFIRST+3)   // sets the cur def ink pentip
#define IE_GETERASERTIP       (IE_MSGFIRST+4)   // gets the cur eraser pentip
#define IE_SETERASERTIP       (IE_MSGFIRST+5)   // sets the cur eraser pentip
#define IE_GETBKGND           (IE_MSGFIRST+6)   // gets the bkgnd options
#define IE_SETBKGND           (IE_MSGFIRST+7)   // sets the bkgnd options
#define IE_GETGRIDORIGIN      (IE_MSGFIRST+8)   // gets the bkgnd grid origin
#define IE_SETGRIDORIGIN      (IE_MSGFIRST+9)   // sets the bkgnd grid origin
#define IE_GETGRIDPEN         (IE_MSGFIRST+10)  // gets the bkgnd grid pen
#define IE_SETGRIDPEN         (IE_MSGFIRST+11)  // sets the bkgnd grid pen
#define IE_GETGRIDSIZE        (IE_MSGFIRST+12)  // gets the bkgnd grid size
#define IE_SETGRIDSIZE        (IE_MSGFIRST+13)  // sets the bkgnd grid size
#define IE_GETMODE            (IE_MSGFIRST+14)  // gets the current pen mode
#define IE_SETMODE            (IE_MSGFIRST+15)  // sets the current pen mode
#define IE_GETINKRECT         (IE_MSGFIRST+16)  // gets the rectbound of the ink

// IEdit-specific messages:
#define IE_GETAPPDATA         (IE_MSGFIRST+34)  // gets the user-defined datum
#define IE_SETAPPDATA         (IE_MSGFIRST+35)  // sets the user-defined data
#define IE_GETDRAWOPTS        (IE_MSGFIRST+36)  // gets the ink draw options
#define IE_SETDRAWOPTS        (IE_MSGFIRST+37)  // sets the ink options
#define IE_GETFORMAT          (IE_MSGFIRST+38)  // gets format of stroke(s)
#define IE_SETFORMAT          (IE_MSGFIRST+39)  // sets format of stroke(s)
#define IE_GETINKINPUT        (IE_MSGFIRST+40)  // gets the ink input option
#define IE_SETINKINPUT        (IE_MSGFIRST+41)  // sets the ink input option
#define IE_GETNOTIFY          (IE_MSGFIRST+42)  // gets the notification bits
#define IE_SETNOTIFY          (IE_MSGFIRST+43)  // sets the notification bits
#define IE_GETRECOG           (IE_MSGFIRST+44)  // gets recognition options
#define IE_SETRECOG           (IE_MSGFIRST+45)  // sets recognition options
#define IE_GETSECURITY        (IE_MSGFIRST+46)  // gets the security options
#define IE_SETSECURITY        (IE_MSGFIRST+47)  // sets the security options
#define IE_GETSEL             (IE_MSGFIRST+48)  // gets sel status of a stroke
#define IE_SETSEL             (IE_MSGFIRST+49)  // sets sel status of a stroke
#define IE_DOCOMMAND          (IE_MSGFIRST+50)  // send command to IEdit
#define IE_GETCOMMAND         (IE_MSGFIRST+51)  // gets user command
#define IE_GETCOUNT           (IE_MSGFIRST+52)  // gets count of strks in I-Edit
#define IE_GETGESTURE         (IE_MSGFIRST+53)  // gets details on user gesture
#define IE_GETMENU            (IE_MSGFIRST+54)  // gets handle to pop-up menu
#define IE_GETPAINTDC         (IE_MSGFIRST+55)  // gets the HDC for painting
#define IE_GETPDEVENT         (IE_MSGFIRST+56)  // gets details of last pd event
#define IE_GETSELCOUNT        (IE_MSGFIRST+57)  // gets count of selected strks
#define IE_GETSELITEMS        (IE_MSGFIRST+58)  // gets indices of all sel strks
#define IE_GETSTYLE           (IE_MSGFIRST+59)  // gets IEdit control styles

#endif /*!NOPENIEDIT */

//------------------------------
#ifndef NOPENHEDIT

// (H)Edit Control:
// CTLINITHEDIT.dwFlags values
#define CIH_NOGDMSG           0x0001  // disable garbage detection message box for this edit
#define CIH_NOACTIONHANDLE    0x0002  // disable action handles for this edit
#define CIH_NOEDITTEXT        0x0004  // disable Lens/Edit/Insert text for this edit
#define CIH_NOFLASHCURSOR     0x0008  // don't flash cursor on tap-n-hold in this (h)edit

#endif /* !NOPENHEDIT */

//------------------------------
#ifndef NOPENBEDIT

// Boxed Edit Control:
// box edit alternative list:
#define HEAL_DEFAULT            -1L     // AltList def value for lParam

// box edit Info:
#define BEI_FACESIZE            32      // max size of font name, = LF_FACESIZE
#define BEIF_BOXCROSS           0x0001

// box edit size:
#define BESC_DEFAULT            0
#define BESC_ROMANFIXED         1
#define BESC_KANJIFIXED         2
#define BESC_USERDEFINED        3

// CTLINITBEDIT.wFlags values
#define CIB_NOGDMSG           0x0001  // disable garbage detection message box for this bedit
#define CIB_NOACTIONHANDLE    0x0002  // disable action handles for this bedit
#define CIB_NOFLASHCURSOR     0x0004  // don't flash cursor on tap-n-hold in this bedit
#ifdef JAPAN
#define CIB_NOWRITING         0x0010  // disallow pen input into control
#endif // JAPAN

#define BXD_CELLWIDTH           12
#define BXD_CELLHEIGHT          16
#define BXD_BASEHEIGHT          13
#define BXD_BASEHORZ            0
#define BXD_MIDFROMBASE         0
#define BXD_CUSPHEIGHT          2
#define BXD_ENDCUSPHEIGHT       4

#define BXDK_CELLWIDTH          32
#define BXDK_CELLHEIGHT         32
#define BXDK_BASEHEIGHT         28
#define BXDK_BASEHORZ           0
#define BXDK_MIDFROMBASE        0
#define BXDK_CUSPHEIGHT         28
#define BXDK_ENDCUSPHEIGHT      10

#endif /*!NOPENBEDIT */

#define WM_PENMISC              (WM_PENWINFIRST+6)  // 0x386

// WM_PENMISC message constants:
#define PMSC_BEDITCHANGE        1       // broadcast when BEDIT changes
#ifndef _WIN32
//#define PMSC_PENUICHANGE      2       // JPN broadcast when PENUI changes
//#define PMSC_SUBINPCHANGE     3       // JPN broadcast when SUBINPUT changes
//#define PMSC_KKCTLENABLE      4       // JPN
#endif //!_WIN32
#define PMSC_GETPCMINFO         5       // query the window's PCMINFO
#define PMSC_SETPCMINFO         6       // set the window's PCMINFO
#define PMSC_GETINKINGINFO      7       // query the window's INKINGINFO
#define PMSC_SETINKINGINFO      8       // set the window's INKINGINFO
#define PMSC_GETHRC             9       // query the window's HRC
#define PMSC_SETHRC             10      // set the window's HRC
#define PMSC_GETSYMBOLCOUNT     11      // count of symbols in result recd by window
#define PMSC_GETSYMBOLS         12      // ditto symbols
#define PMSC_SETSYMBOLS         13      // ditto set symbols
#define PMSC_LOADPW             15      // broadcast load state on penwin
#define PMSC_INKSTOP            16

// PMSCL_xx lParam values for PMSC_LOADPW:
#define PMSCL_UNLOADED          0L      // penwin just unloaded
#define PMSCL_LOADED            1L      // penwin just loaded
#define PMSCL_UNLOADING         2L      // penwin about to unload

#define WM_CTLINIT              (WM_PENWINFIRST+7)  // 0x387

// WM_CTLINIT message constants:
#define CTLINIT_HEDIT           1
#define CTLINIT_BEDIT           7
#define CTLINIT_IEDIT           9
#define CTLINIT_MAX             10

#define WM_PENEVENT             (WM_PENWINFIRST+8)  // 0x388

// WM_PENEVENT message values for wParam:
#define PE_PENDOWN              1       // pen tip down
#define PE_PENUP                2       // pen tip went from down to up
#define PE_PENMOVE              3       // pen moved without a tip transition
#define PE_TERMINATING          4       // Peninput about to terminate
#define PE_TERMINATED           5       // Peninput terminated
#define PE_BUFFERWARNING        6       // Buffer half full.
#define PE_BEGININPUT           7       // begin default input
#define PE_SETTARGETS           8       // set target data structure (TARGINFO)
#define PE_BEGINDATA            9       // init message to all targets
#define PE_MOREDATA             10      // target gets more data
#define PE_ENDDATA              11      // termination message to all targets
#define PE_GETPCMINFO           12      // get input collection info
#define PE_GETINKINGINFO        13      // get inking info
#define PE_ENDINPUT             14      // Input termination message to window
					//  starting default input
#define PE_RESULT               15      // sent after ProcessHRC but before GetResultsHRC

#endif /*!NOPENMSGS */

/****** Definitions 3: RC compiler excluded ********************************/

#ifndef RC_INVOKED  // ... rest of file of no interest to rc compiler

//////////////////////////////////////////////////////////////////////////////
/****** Macros **************************************************************/

// misc macros:
//---------------------------------------------------------------------------
#ifndef NOPENDRIVER

#define FPenUpX(x)              ((BOOL)(((x) & BITPENUP) != 0))
#define GetWEventRef()          (LOWORD(GetMessageExtraInfo()))
#endif /*!NOPENDRIVER */

//---------------------------------------------------------------------------
#ifndef NOPENALC

// ALC macros:

#define MpAlcB(lprc,i)          ((lprc)->rgbfAlc[((i) & 0xff) >> 3])
#define MpIbf(i)                ((BYTE)(1 << ((i) & 7)))
#define SetAlcBitAnsi(lprc,i)   do {MpAlcB(lprc,i) |= MpIbf(i);} while (0)
#define ResetAlcBitAnsi(lprc,i) do {MpAlcB(lprc,i) &= ~MpIbf(i);} while (0)
#define IsAlcBitAnsi(lprc, i)   ((MpAlcB(lprc,i) & MpIbf(i)) != 0)
#endif /*!NOPENALC */

//---------------------------------------------------------------------------
#ifndef NOPENDATA

// draw 2.0 pendata using internal stroke formats:
#define DrawPenDataFmt(hdc, lprect, hpndt)\
    DrawPenDataEx(hdc, lprect, hpndt, 0, IX_END, 0, IX_END, NULL, NULL, 0)

#endif /*!NOPENDATA */

//---------------------------------------------------------------------------
#ifndef NOPENHRC

// Handwriting Recognizer:

// Intervals:
// difference of two absolute times (at2 > at1 for positive result):
#define dwDiffAT(at1, at2)\
    (1000L*((at2).sec - (at1).sec) - (DWORD)(at1).ms + (DWORD)(at2).ms)

// comparison of two absolute times (TRUE if at1 < at2):
#define FLTAbsTime(at1, at2)\
    ((at1).sec < (at2).sec || ((at1).sec == (at2).sec && (at1).ms < (at2).ms))

#define FLTEAbsTime(at1, at2)\
    ((at1).sec < (at2).sec || ((at1).sec == (at2).sec && (at1).ms <= (at2).ms))

#define FEQAbsTime(at1, at2)\
    ((at1).sec == (at2).sec && (at1).ms == (at2).ms)

// test if abstime is within an interval:
#define FAbsTimeInInterval(at, lpi)\
    (FLTEAbsTime((lpi)->atBegin, at) && FLTEAbsTime(at, (lpi)->atEnd))

// test if interval (lpiT) is within an another interval (lpiS):
#define FIntervalInInterval(lpiT, lpiS)\
    (FLTEAbsTime((lpiS)->atBegin, (lpiT)->atBegin)\
    && FLTEAbsTime((lpiT)->atEnd, (lpiS)->atEnd))

// test if interval (lpiT) intersects another interval (lpiS):
#define FIntervalXInterval(lpiT, lpiS)\
    (!(FLTAbsTime((lpiT)->atEnd, (lpiS)->atBegin)\
    || FLTAbsTime((lpiS)->atEnd, (lpiT)->atBegin)))

// duration of an LPINTERVAL in ms:
#define dwDurInterval(lpi)  dwDiffAT((lpi)->atBegin, (lpi)->atEnd)

// fill a pointer to an ABSTIME structure from a count of seconds and ms:
#define MakeAbsTime(lpat, sec, ms) do {\
    (lpat)->sec = sec + ((ms) / 1000);\
    (lpat)->ms = (ms) % 1000;\
    } while (0)

// SYV macros:
#define FIsSpecial(syv)         (HIWORD((syv))==SYVHI_SPECIAL)
#define FIsAnsi(syv)            (HIWORD((syv))==SYVHI_ANSI)
#define FIsGesture(syv)         (HIWORD((syv))==SYVHI_GESTURE)
#define FIsKanji(syv)           (HIWORD((syv))==SYVHI_KANJI)
#define FIsShape(syv)           (HIWORD((syv))==SYVHI_SHAPE)
#define FIsUniCode(syv)         (HIWORD((syv))==SYVHI_UNICODE)
#define FIsVKey(syv)            (HIWORD((syv))==SYVHI_VKEY)

#define ChSyvToAnsi(syv)        ((BYTE) (LOBYTE(LOWORD((syv)))))
#define WSyvToKanji(syv)        ((WORD) (LOWORD((syv))))
#define SyvCharacterToSymbol(c) ((LONG)(unsigned char)(c) | 0x00010000)
#define SyvKanjiToSymbol(c)     ((LONG)(UINT)(c) | 0x00030000)

#define FIsSelectGesture(syv)   \
   ((syv) >= SYVSELECTFIRST && (syv) <= SYVSELECTLAST)

#define FIsStdGesture(syv)      \
   (                            \
   FIsSelectGesture(syv)        \
   || (syv)==SYV_CLEAR          \
   || (syv)==SYV_HELP           \
   || (syv)==SYV_EXTENDSELECT   \
   || (syv)==SYV_UNDO           \
   || (syv)==SYV_COPY           \
   || (syv)==SYV_CUT            \
   || (syv)==SYV_PASTE          \
   || (syv)==SYV_CLEARWORD      \
   || (syv)==SYV_KKCONVERT      \
   || (syv)==SYV_USER           \
   || (syv)==SYV_CORRECT        \
   )

#define FIsAnsiGesture(syv) \
   (                            \
   (syv) == SYV_BACKSPACE       \
   || (syv) == SYV_TAB          \
   || (syv) == SYV_RETURN       \
   || (syv) == SYV_SPACE        \
   )

#endif /*!NOPENHRC */

//---------------------------------------------------------------------------
#ifndef NOPENINKPUT

#define SubPenMsgFromWpLp(wp, lp)       (LOWORD(wp))
#ifdef _WIN32
#define EventRefFromWpLp(wp, lp)        (HIWORD(wp))
#define TerminationFromWpLp(wp, lp)     ((int)HIWORD(wp))
#define HpcmFromWpLp(wp, lp)            ((HPCM)(lp))
#else
#define EventRefFromWpLp(wp, lp)        (LOWORD(lp))
#define TerminationFromWpLp(wp, lp)     ((int)LOWORD(lp))
#define HpcmFromWpLp(wp, lp)            ((HPCM)HIWORD(lp))
#endif //_WIN32

#endif   /*!NOPENINKPUT*/

//---------------------------------------------------------------------------
#ifndef NOPENTARGET
#define HwndFromHtrg(htrg)      ((HWND)(DWORD)(htrg))
#define HtrgFromHwnd(hwnd)      ((HTRG)(UINT)(hwnd))
#endif /*!NOPENTARGET*/

//////////////////////////////////////////////////////////////////////////////
/****** Typedefs ************************************************************/

// Simple:
typedef LONG                    ALC;    // Enabled Alphabet
typedef int                     CL;     // Confidence Level
typedef UINT                    HKP;    // Hook Parameter
typedef int                     REC;    // recognition result
typedef LONG                    SYV;    // Symbol Value

#ifndef DECLARE_HANDLE32
#define DECLARE_HANDLE32(name)\
    struct name##__ { int unused; };\
    typedef const struct name##__ FAR* name
#endif //!DECLARE_HANDLE32

DECLARE_HANDLE32(HTRG);                 // Handle to target
DECLARE_HANDLE(HPCM);                   // Handle to Pen Collection Info
DECLARE_HANDLE(HPENDATA);               // handle to ink
DECLARE_HANDLE(HREC);                   // handle to recognizer

// Pointer Types:
typedef ALC FAR*                LPALC;        // ptr to ALC
typedef LPVOID                  LPOEM;        // alias
typedef SYV FAR*                LPSYV;        // ptr to SYV
typedef HPENDATA FAR*           LPHPENDATA;   // ptr to HPENDATA

// Function Prototypes:
typedef int         (CALLBACK *ENUMPROC)(LPSYV, int, VOID FAR*);
typedef int         (CALLBACK *LPDF)(int, LPVOID, LPVOID, int, DWORD, DWORD);
typedef BOOL        (CALLBACK *RCYIELDPROC)(VOID);

// Structures:

typedef struct tagABSTIME       // 2.0 absolute date/time
   {
   DWORD sec;      // number of seconds since 1/1/1970, ret by CRTlib time() fn
   UINT ms;        // additional offset in ms, 0..999
   }
   ABSTIME, FAR *LPABSTIME;

//---------------------------------------------------------------------------
#ifndef NOPENHEDIT

typedef struct tagCTLINITHEDIT  // 2.0 init struct for (h)edit
   {
   DWORD cbSize;                // sizeof(CTLINITHEDIT)
   HWND hwnd;                   // (h)edit window handle
   int id;                      // its id
   DWORD dwFlags;               // CIE_xx
   DWORD dwReserved;            // for future use
   }
   CTLINITHEDIT, FAR *LPCTLINITHEDIT;
#endif /* !NOPENHEDIT */

//---------------------------------------------------------------------------
#ifndef NOPENBEDIT

typedef struct tagBOXLAYOUT     // 1.0 box edit layout
   {
   int cyCusp;                  // pixel height of box (BXS_RECT) or cusp
   int cyEndCusp;               // pixel height of cusps at extreme ends
   UINT style;                  // BXS_xx style
   DWORD dwReserved1;           // reserved
   DWORD dwReserved2;           // reserved
   DWORD dwReserved3;           // reserved
   }
   BOXLAYOUT, FAR *LPBOXLAYOUT;

typedef struct tagCTLINITBEDIT  // 2.0 init struct for box edit
   {
   DWORD cbSize;                // sizeof(CTLINITBEDIT)
   HWND hwnd;                   // box edit window handle
   int id;                      // its id
   WORD wSizeCategory;          // BESC_xx
   WORD wFlags;                 // CIB_xx
   DWORD dwReserved;            // for future use
   }
   CTLINITBEDIT, FAR *LPCTLINITBEDIT;

typedef struct tagBOXEDITINFO   // 1.1 box edit Size Info
   {
   int cxBox;                   // width of a single box
   int cyBox;                   // ditto height
   int cxBase;                  // in-box x-margin to guideline
   int cyBase;                  // in-box y offset from top to baseline
   int cyMid;                   // 0 or distance from baseline to midline
   BOXLAYOUT boxlayout;         // embedded BOXLAYOUT structure
   UINT wFlags;                 // BEIF_xx
   BYTE szFaceName[BEI_FACESIZE];   // font face name
   UINT wFontHeight;            // font height
   UINT rgwReserved[8];         // for future use
   }
   BOXEDITINFO, FAR *LPBOXEDITINFO;
#endif /*!NOPENBEDIT */

//---------------------------------------------------------------------------
#ifndef NOPENCTL

typedef struct tagRECTOFS       // 1.0 rectangle offset for nonisometric inflation
   {
   int dLeft;                   // inflation leftwards from left side
   int dTop;                    // ditto upwards from top
   int dRight;                  // ditto rightwards from right
   int dBottom;                 // ditto downwards from bottom
   }
   RECTOFS, FAR *LPRECTOFS;
#endif /*!NOPENCTL */

//---------------------------------------------------------------------------
#ifndef NOPENDATA

typedef struct tagPENDATAHEADER // 1.0 main pen data header
   {
   UINT wVersion;               // pen data format version
   UINT cbSizeUsed;             // size of pendata mem block in bytes
   UINT cStrokes;               // number of strokes (incl up-strokes)
   UINT cPnt;                   // count of all points
   UINT cPntStrokeMax;          // length (in points) of longest stroke
   RECT rectBound;              // bounding rect of all down points
   UINT wPndts;                 // PDTS_xx bits
   int  nInkWidth;              // ink width in pixels
   DWORD rgbInk;                // ink color
   }
   PENDATAHEADER, FAR *LPPENDATAHEADER, FAR *LPPENDATA;

typedef struct tagSTROKEINFO    // 1.0 stroke header
   {
   UINT cPnt;                   // count of points in stroke
   UINT cbPnts;                 // size of stroke in bytes
   UINT wPdk;                   // state of stroke
   DWORD dwTick;                // time at beginning of stroke
   }
   STROKEINFO, FAR *LPSTROKEINFO;

typedef struct tagPENTIP        // 2.0 Pen Tip characteristics
    {
    DWORD cbSize;               // sizeof(PENTIP)
    BYTE btype;                 // pen type/nib (calligraphic nib, etc.)
    BYTE bwidth;                // width of Nib (typically == nInkWidth)
    BYTE bheight;               // height of Nib
    BYTE bOpacity;              // 0=transparent, 0x80=hilite, 0xFF=opaque
    COLORREF rgb;               // pen color
    DWORD dwFlags;              // TIP_xx flags
    DWORD dwReserved;           // for future expansion
    }
    PENTIP, FAR *LPPENTIP;

typedef BOOL (CALLBACK *ANIMATEPROC)(HPENDATA, UINT, UINT, UINT FAR*, LPARAM);

typedef struct tagANIMATEINFO   // 2.0 Animation parameters
    {
    DWORD cbSize;               // sizeof(ANIMATEINFO)
    UINT uSpeedPct;             // speed percent to animate at
    UINT uPeriodCB;             // time between calls to callback in ms
    UINT fuFlags;               // animation flags
    LPARAM lParam;              // value to pass to callback
    DWORD dwReserved;           // reserved
    }
    ANIMATEINFO, FAR *LPANIMATEINFO;
#endif /*!NOPENDATA */

//---------------------------------------------------------------------------
#ifndef NOPENDRIVER

typedef struct tagOEMPENINFO    // 1.0 OEM pen/tablet hdwe info
   {
   UINT wPdt;                   // pen data type
   UINT wValueMax;              // largest val ret by device
   UINT wDistinct;              // number of distinct readings possible
   }
   OEMPENINFO, FAR *LPOEMPENINFO;

typedef struct tagPENPACKET     // 1.0 pen packet
   {
   UINT wTabletX;               // x in raw coords
   UINT wTabletY;               // ditto y
   UINT wPDK;                   // state bits
   UINT rgwOemData[MAXOEMDATAWORDS]; // OEM-specific data
   }
   PENPACKET, FAR *LPPENPACKET;

typedef struct tagOEM_PENPACKET // 2.0
   {
   UINT wTabletX;               // x in raw coords
   UINT wTabletY;               // ditto y
   UINT wPDK;                   // state bits
   UINT rgwOemData[MAXOEMDATAWORDS];  // OEM-specific data
   DWORD dwTime;
   }
    OEM_PENPACKET, FAR *LPOEM_PENPACKET;

typedef struct tagPENINFO       // 1.0 pen/tablet hdwe info
   {
   UINT cxRawWidth;             // max x coord and tablet width in 0.001"
   UINT cyRawHeight;            // ditto y, height
   UINT wDistinctWidth;         // number of distinct x values tablet ret
   UINT wDistinctHeight;        // ditto y
   int nSamplingRate;           // samples / second
   int nSamplingDist;           // min distance to move before generating event
   LONG lPdc;                   // Pen Device Capabilities
   int cPens;                   // number of pens supported
   int cbOemData;               // width of OEM data packet
   OEMPENINFO rgoempeninfo[MAXOEMDATAWORDS]; // supported OEM data types
   UINT rgwReserved[7];         // for internal use
   UINT fuOEM;                  // which OEM data, timing, PDK_xx to report
   }
   PENINFO, FAR *LPPENINFO;

typedef struct tagCALBSTRUCT    // 1.0 pen calibration
   {
   int wOffsetX;
   int wOffsetY;
   int wDistinctWidth;
   int wDistinctHeight;
   }
   CALBSTRUCT, FAR *LPCALBSTRUCT;

typedef BOOL (CALLBACK *LPFNRAWHOOK)(LPPENPACKET);
#endif /*!NOPENDRIVER */

//---------------------------------------------------------------------------
#ifndef NOPENHRC

// Handwriting Recognizer:

DECLARE_HANDLE32(HRC);          // Handwriting Recognition Context
DECLARE_HANDLE32(HRCRESULT);    // HRC result
DECLARE_HANDLE32(HWL);          // Handwriting wordlist
DECLARE_HANDLE32(HRECHOOK);     // Recognition Result hook handle

typedef HRC                     FAR *LPHRC;
typedef HRCRESULT               FAR *LPHRCRESULT;
typedef HWL                     FAR *LPHWL;

typedef BOOL (CALLBACK *HRCRESULTHOOKPROC)
    (HREC, HRC, UINT, UINT, UINT, LPVOID);

// Inksets:
DECLARE_HANDLE(HINKSET);        // handle to an inkset
typedef HINKSET                 FAR* LPHINKSET; // ptr to HINKSET

typedef struct tagINTERVAL      // 2.0 interval structure for inksets
    {
    ABSTIME atBegin;            // begining of 1-ms granularity interval
    ABSTIME atEnd;              // 1 ms past end of interval
    }
    INTERVAL, FAR *LPINTERVAL;

typedef struct tagBOXRESULTS    // 2.0
    {
    UINT indxBox;
    HINKSET hinksetBox;
    SYV rgSyv[1];
    }
    BOXRESULTS, FAR *LPBOXRESULTS;

typedef struct tagGUIDE         // 1.0 guide structure
   {
   int xOrigin;                 // left edge of first box (screen coord))
   int yOrigin;                 // ditto top edge
   int cxBox;                   // width of a single box
   int cyBox;                   // ditto height
   int cxBase;                  // in-box x-margin to guideline
   int cyBase;                  // in-box y offset from top to baseline
   int cHorzBox;                // count of boxed columns
   int cVertBox;                // ditto rows
   int cyMid;                   // 0 or distance from baseline to midline
   }
   GUIDE, FAR *LPGUIDE;

#endif /*!NOPENHRC */

//---------------------------------------------------------------------------
#ifndef NOPENIEDIT

typedef struct tagCTLINITIEDIT  // 2.0 init struct for Ink Edit
    {
    DWORD cbSize;               // sizeof(CTLINITIEDIT)
    HWND hwnd;                  // IEdit window handle
    int id;                     // its ID
    WORD ieb;                   // IEB_* (background) bits
    WORD iedo;                  // IEDO_* (draw options) bits
    WORD iei;                   // IEI_* (ink input) bits
    WORD ien;                   // IEN_* (notification) bits
    WORD ierec;                 // IEREC_* (recognition) bits
    WORD ies;                   // IES_* (style) bits
    WORD iesec;                 // IESEC_* (security) bits
    WORD pdts;                  // initial pendata scale factor (PDTS_*)
    HPENDATA hpndt;             // initial pendata (or NULL if none)
    HGDIOBJ hgdiobj;            // background brush or bitmap handle
    HPEN hpenGrid;              // pen to use in drawing grid
    POINT ptOrgGrid;            // grid lines point of origin
    WORD wVGrid;                // vertical gridline spacing
    WORD wHGrid;                // horizontal gridline spacing
    DWORD dwApp;                // application-defined data
    DWORD dwReserved;           // reserved for future use
    }
    CTLINITIEDIT, FAR *LPCTLINITIEDIT;

typedef struct tagPDEVENT       // 2.0
    {
    DWORD cbSize;               // sizeof(PDEVENT)
    HWND hwnd;                  // window handle of I-Edit
    UINT wm;                    // WM_* (window message) of event
    WPARAM wParam;              // wParam of message
    LPARAM lParam;              // lParam of message
    POINT pt;                   // event pt in I-Edit client co-ords
    BOOL fPen;                  // TRUE if pen (or other inking device)
    LONG lExInfo;               // GetMessageExtraInfo() return value
    DWORD dwReserved;           // for future use
    }
    PDEVENT, FAR *LPPDEVENT;

typedef struct tagSTRKFMT       // 2.0
    {
    DWORD cbSize;               // sizeof(STRKFMT)
    UINT iesf;                  // stroke format flags and return bits
    UINT iStrk;                 // stroke index if IESF_STROKE
    PENTIP tip;                 // ink tip attributes
    DWORD dwUser;               // user data for strokes
    DWORD dwReserved;           // for future use
    }
    STRKFMT, FAR *LPSTRKFMT;
#endif /*!NOPENIEDIT */

//---------------------------------------------------------------------------
#ifndef NOPENINKPUT

typedef struct tagPCMINFO       // 2.0 Pen Collection Mode Information
   {
   DWORD cbSize;                // sizeof(PCMINFO)
   DWORD dwPcm;                 // PCM_xxx flags
   RECT rectBound;              // if finish on pendown outside this rect
   RECT rectExclude;            // if finish on pendown inside this rect
   HRGN hrgnBound;              // if finish on pendown outside this region
   HRGN hrgnExclude;            // if finish on pendown inside this region
   DWORD dwTimeout;             // if finish after timeout, this many ms
   }
    PCMINFO, FAR *LPPCMINFO;

typedef struct tagINKINGINFO    // 2.0 Pen Inking Information
   {
   DWORD cbSize;                // sizeof(INKINGINFO)
   UINT wFlags;                 // One of the PII_xx flags
   PENTIP tip;                  // Pen type, size and color
   RECT rectClip;               // Clipping rect for the ink
   RECT rectInkStop;            // Rect in which a pen down stops inking
   HRGN hrgnClip;               // Clipping region for the ink
   HRGN hrgnInkStop;            // Region in which a pen down stops inking
   }
    INKINGINFO, FAR *LPINKINGINFO;
#endif /*!NOPENINKPUT */

//---------------------------------------------------------------------------
#ifndef NOPENRC1    // not available in WIN32

typedef struct tagSYC           // 1.0 Symbol Correspondence for Ink
   {
   UINT wStrokeFirst;           // first stroke, inclusive
   UINT wPntFirst;              // first point in first stroke, inclusive
   UINT wStrokeLast;            // last stroke, inclusive
   UINT wPntLast;               // last point in last stroke, inclusive
   BOOL fLastSyc;               // T: no more SYCs follow for current SYE
   }
   SYC, FAR *LPSYC;

typedef struct tagSYE           // 1.0 Symbol Element
   {
   SYV syv;                     // symbol value
   LONG lRecogVal;              // for internal use by recognizer
   CL cl;                       // confidence level
   int iSyc;                    // SYC index
   }
   SYE, FAR *LPSYE;

typedef struct tagSYG           // 1.0 Symbol Graph
   {
   POINT rgpntHotSpots[MAXHOTSPOT]; // hot spots (max 8)
   int cHotSpot;                // number of valid hot spots in rgpntHotSpots
   int nFirstBox;               // row-major index to box of 1st char in result
   LONG lRecogVal;              // reserved for use by recoognizer
   LPSYE lpsye;                 // nodes of symbol graph
   int cSye;                    // number of SYEs in symbol graph
   LPSYC lpsyc;                 // ptr to corresp symbol ink
   int cSyc;                    // ditto count
   }
   SYG, FAR *LPSYG;

typedef struct tagRC            // 1.0 Recognition Context (RC)
   {
   HREC hrec;                   // handle of recognizer to use
   HWND hwnd;                   // window to send results to
   UINT wEventRef;              // index into ink buffer
   UINT wRcPreferences;         // flags: RCP_xx Preferences
   LONG lRcOptions;             // RCO_xx options
   RCYIELDPROC lpfnYield;       // procedure called during Yield()
   BYTE lpUser[cbRcUserMax];    // current writer
   UINT wCountry;               // country code
   UINT wIntlPreferences;       // flags: RCIP_xx
   char lpLanguage[cbRcLanguageMax]; // language strings
   LPDF rglpdf[MAXDICTIONARIES];   // list of dictionary functions
   UINT wTryDictionary;         // max enumerations to search
   CL clErrorLevel;             // level where recognizer should reject input
   ALC alc;                     // enabled alphabet
   ALC alcPriority;             // prioritizes the ALC_ codes
   BYTE rgbfAlc[cbRcrgbfAlcMax];   // bit field for enabled characters
   UINT wResultMode;            // RRM_xx when to send (asap or when complete)
   UINT wTimeOut;               // recognition timeout in ms
   LONG lPcm;                   // flags: PCM_xx for ending recognition
   RECT rectBound;              // bounding rect for inking (def:screen coords)
   RECT rectExclude;            // pen down inside this terminates recognition
   GUIDE guide;                 // struct: defines guidelines for recognizer
   UINT wRcOrient;              // RCOR_xx orientation of writing wrt tablet
   UINT wRcDirect;              // RCD_xx direction of writing
   int nInkWidth;               // ink width 0 (none) or 1..15 pixels
   COLORREF rgbInk;             // ink color
   DWORD dwAppParam;            // for application use
   DWORD dwDictParam;           // for app use to be passed on to dictionaries
   DWORD dwRecognizer;          // for app use to be passed on to recognizer
   UINT rgwReserved[cwRcReservedMax]; // reserved for future use by Windows
   }
   RC, FAR *LPRC;

typedef struct tagRCRESULT      // 1.0 Recognition Result
   {
   SYG syg;                     // symbol graph
   UINT wResultsType;           // see RCRT_xx
   int cSyv;                    // count of symbol values
   LPSYV lpsyv;                 // NULL-term ptr to recog's best guess
   HANDLE hSyv;                 // globally-shared handle to lpsyv mem
   int nBaseLine;               // 0 or baseline of input writing
   int nMidLine;                // ditto midline
   HPENDATA hpendata;           // pen data mem
   RECT rectBoundInk;           // ink data bounds
   POINT pntEnd;                // pt that terminated recog
   LPRC lprc;                   // recog context used
   }
   RCRESULT, FAR *LPRCRESULT;

typedef int         (CALLBACK *LPFUNCRESULTS)(LPRCRESULT, REC);

#endif /*!NOPENRC1 */

//---------------------------------------------------------------------------
#ifndef NOPENTARGET

#ifndef _WIN32
#if (WINVER < 0x0400)
#ifndef _OLE2_H_
typedef struct tagRECTL
{
   LONG     left;
   LONG     top;
   LONG     right;
   LONG     bottom;
} RECTL;
typedef RECTL*       PRECTL;
typedef RECTL NEAR*  NPRECTL;
typedef RECTL FAR*   LPRECTL;
typedef const RECTL FAR* LPCRECTL;
#endif // !_OLE2_H_
#endif // WINVER
#endif // !WIN32

typedef struct tagTARGET        // 2.0 Geometry for a single target.
   {
   DWORD dwFlags;               // individual target flags
   DWORD idTarget;              // TARGINFO.rgTarget[] index
   HTRG  htrgTarget;            // HANDLE32 equiv
   RECTL rectBound;             // Bounding rect of the target
   DWORD dwData;                // data collection info per target
   RECTL rectBoundInk;          // Reserved for internal use, must be zero
   RECTL rectBoundLastInk;      // Reserved for internal use, must be zero
   }
   TARGET, FAR *LPTARGET;

typedef struct tagTARGINFO      // 2.0 A set of targets
   {
   DWORD cbSize;                // sizeof(TARGINFO)
   DWORD dwFlags;               // flags
   HTRG htrgOwner;              // HANDLE32 equiv
   WORD cTargets;               // count of targets
   WORD iTargetLast;            // last target, used by TargetPoints API
				// if TPT_TEXTUAL flag is set
   TARGET rgTarget[1];          // variable-length array of targets
   }
   TARGINFO, FAR *LPTARGINFO;

typedef struct tagINPPARAMS     // 2.0
   {
   DWORD cbSize;                // sizeof(INPPARAMS)
   DWORD dwFlags;
   HPENDATA hpndt;
   TARGET target;               // target structure
   }
    INPPARAMS, FAR *LPINPPARAMS;
#endif /*!NOPENTARGET */

#ifdef JAPAN
typedef struct tagCWX           // 2.0
   {
   DWORD cbSize;                // sizeof(CWXSTRUCT): required entry
   WORD wApplyFlags;            // CWXA_xx apply flags (else use MRU settings)
   HWND hwndText;               // text window if different [NULL=use owner]
   HRC hrc;                     // recognition context [def NULL]
   char szCaption[CBCAPTIONCWX];// caption [def {0}]
   DWORD dwEditStyle;           // style for edit control [def 0]
   DWORD dwSel;                 // selection [def 0]

   // these use Most Recent settings unless corresp [wApplyFlags] bit set:
   DWORD dwFlags;               // CWX_xx context flags [CWXA_CONTEXT]
   WORD ixkb;                   // CWXK_xx keyboard [CWXA_KBD]
   WORD rgState[CKBCWX];        // array of keyboard states [CWXA_STATE]
   POINT ptUL;                  // dlg u.l. corner, screen coords [CWXA_PTUL]
   SIZE sizeHW;                 // dlg HW tab size, screen coords [CWXA_SIZE]
   }
   CWX, FAR *LPCWX;

#endif //JAPAN

//////////////////////////////////////////////////////////////////////////////
/****** APIs and Prototypes *************************************************/

LRESULT CALLBACK    DefPenWindowProc(HWND, UINT, WPARAM, LPARAM);

//---------------------------------------------------------------------------
#ifndef NOPENAPPS   // not available in WIN32

// Pen System Applications:
BOOL      WINAPI ShowKeyboard(HWND, UINT, LPPOINT, LPSKBINFO);

#endif /*!NOPENAPPS */

//---------------------------------------------------------------------------
#ifndef NOPENDATA   // these APIs are implemented in PKPD.DLL

// PenData:
#ifndef NOPENAPIFUN
LPPENDATA WINAPI BeginEnumStrokes(HPENDATA);
LPPENDATA WINAPI EndEnumStrokes(HPENDATA);
HPENDATA  WINAPI CompactPenData(HPENDATA, UINT);
HPENDATA  WINAPI CreatePenData(LPPENINFO, int, UINT, UINT);
VOID      WINAPI DrawPenData(HDC, LPRECT, HPENDATA);
BOOL      WINAPI GetPenDataStroke(LPPENDATA, UINT, LPPOINT FAR*,
				  LPVOID FAR*, LPSTROKEINFO);
#endif //!NOPENAPIFUN
HPENDATA  WINAPI AddPointsPenData(HPENDATA, LPPOINT, LPVOID, LPSTROKEINFO);
int       WINAPI CompressPenData(HPENDATA, UINT, DWORD);
HPENDATA  WINAPI CreatePenDataEx(LPPENINFO, UINT, UINT, UINT);
HRGN      WINAPI CreatePenDataRegion(HPENDATA, UINT);
BOOL      WINAPI DestroyPenData(HPENDATA);
int       WINAPI DrawPenDataEx(HDC, LPRECT, HPENDATA, UINT, UINT, UINT, UINT,
			       ANIMATEPROC, LPANIMATEINFO, UINT);
HPENDATA  WINAPI DuplicatePenData(HPENDATA, UINT);
int       WINAPI ExtractPenDataPoints(HPENDATA, UINT, UINT, UINT, LPPOINT,
				      LPVOID, UINT);
int       WINAPI ExtractPenDataStrokes(HPENDATA, UINT, LPARAM,
				       LPHPENDATA, UINT);
int       WINAPI GetPenDataAttributes(HPENDATA, LPVOID, UINT);
BOOL      WINAPI GetPenDataInfo(HPENDATA, LPPENDATAHEADER, LPPENINFO, DWORD);
BOOL      WINAPI GetPointsFromPenData(HPENDATA, UINT, UINT, UINT, LPPOINT);
int       WINAPI GetStrokeAttributes(HPENDATA, UINT, LPVOID, UINT);
int       WINAPI GetStrokeTableAttributes(HPENDATA, UINT, LPVOID, UINT);
int       WINAPI HitTestPenData(HPENDATA, LPPOINT, UINT, UINT FAR*, UINT FAR*);
int       WINAPI InsertPenData(HPENDATA, HPENDATA, UINT);
int       WINAPI InsertPenDataPoints(HPENDATA, UINT, UINT, UINT,
				     LPPOINT, LPVOID);
int       WINAPI InsertPenDataStroke(HPENDATA, UINT, LPPOINT, LPVOID,
				     LPSTROKEINFO);
BOOL      WINAPI MetricScalePenData(HPENDATA, UINT);
BOOL      WINAPI OffsetPenData(HPENDATA, int, int);
LONG      WINAPI PenDataFromBuffer(LPHPENDATA, UINT, LPBYTE, LONG, LPDWORD);
LONG      WINAPI PenDataToBuffer(HPENDATA, LPBYTE, LONG, LPDWORD);
BOOL      WINAPI RedisplayPenData(HDC, HPENDATA, LPPOINT, LPPOINT,
				  int, DWORD);
int       WINAPI RemovePenDataStrokes(HPENDATA, UINT, UINT);
BOOL      WINAPI ResizePenData(HPENDATA, LPRECT);
int       WINAPI SetStrokeAttributes(HPENDATA, UINT, LPARAM, UINT);
int       WINAPI SetStrokeTableAttributes(HPENDATA, UINT, LPARAM, UINT);
int       WINAPI TrimPenData(HPENDATA, DWORD, DWORD);

#endif /*!NOPENDATA */

//---------------------------------------------------------------------------
#ifndef NOPENDICT   // not available in WIN32

// Dictionary:
BOOL      WINAPI DictionarySearch(LPRC, LPSYE, int, LPSYV, int);
#endif /*!NOPENDICT */

//---------------------------------------------------------------------------
#ifndef NOPENDRIVER

// Pen Hardware/Driver:
#ifndef NOPENAPIFUN
BOOL      WINAPI EndPenCollection(REC);
REC       WINAPI GetPenHwData(LPPOINT, LPVOID, int, UINT, LPSTROKEINFO);
REC       WINAPI GetPenHwEventData(UINT, UINT, LPPOINT, LPVOID,
				   int, LPSTROKEINFO);
BOOL      WINAPI SetPenHook(HKP, LPFNRAWHOOK);
VOID      WINAPI UpdatePenInfo(LPPENINFO);
#endif //!NOPENAPIFUN
BOOL      WINAPI GetPenAsyncState(UINT);
BOOL      WINAPI IsPenEvent(UINT, LONG);
#endif /*!NOPENDRIVER */

//---------------------------------------------------------------------------
#ifndef NOPENHRC

// Handwriting Recognizer:
int       WINAPI AddPenDataHRC(HRC, HPENDATA);
int       WINAPI AddPenInputHRC(HRC, LPPOINT, LPVOID, UINT, LPSTROKEINFO);
int       WINAPI AddWordsHWL(HWL, LPSTR, UINT);
int       WINAPI ConfigHREC(HREC, UINT, WPARAM, LPARAM);
HRC       WINAPI CreateCompatibleHRC(HRC, HREC);
HWL       WINAPI CreateHWL(HREC, LPSTR, UINT, DWORD);
HINKSET   WINAPI CreateInksetHRCRESULT(HRCRESULT, UINT, UINT);
HPENDATA  WINAPI CreatePenDataHRC(HRC);
int       WINAPI DestroyHRC(HRC);
int       WINAPI DestroyHRCRESULT(HRCRESULT);
int       WINAPI DestroyHWL(HWL);
int       WINAPI EnableGestureSetHRC(HRC, SYV, BOOL);
int       WINAPI EnableSystemDictionaryHRC(HRC, BOOL);
int       WINAPI EndPenInputHRC(HRC);
int       WINAPI GetAlphabetHRC(HRC, LPALC, LPBYTE);
int       WINAPI GetAlphabetPriorityHRC(HRC, LPALC, LPBYTE);
int       WINAPI GetAlternateWordsHRCRESULT(HRCRESULT, UINT, UINT,
					    LPHRCRESULT, UINT);
int       WINAPI GetBoxMappingHRCRESULT(HRCRESULT, UINT, UINT, UINT FAR*);
int       WINAPI GetBoxResultsHRC(HRC, UINT, UINT, UINT, LPBOXRESULTS, BOOL);
int       WINAPI GetGuideHRC(HRC, LPGUIDE, UINT FAR*);
int       WINAPI GetHotspotsHRCRESULT(HRCRESULT, UINT, LPPOINT, UINT);
HREC      WINAPI GetHRECFromHRC(HRC);
int       WINAPI GetInternationalHRC(HRC, UINT FAR*, LPSTR, UINT FAR*,
				     UINT FAR*);
int       WINAPI GetMaxResultsHRC(HRC);
int       WINAPI GetResultsHRC(HRC, UINT, LPHRCRESULT, UINT);
int       WINAPI GetSymbolCountHRCRESULT(HRCRESULT);
int       WINAPI GetSymbolsHRCRESULT(HRCRESULT, UINT, LPSYV, UINT);
int       WINAPI GetWordlistHRC(HRC, LPHWL);
int       WINAPI GetWordlistCoercionHRC(HRC);
int       WINAPI ProcessHRC(HRC, DWORD);
int       WINAPI ReadHWL(HWL, HFILE);
int       WINAPI SetAlphabetHRC(HRC, ALC, LPBYTE);
int       WINAPI SetAlphabetPriorityHRC(HRC, ALC, LPBYTE);
int       WINAPI SetBoxAlphabetHRC(HRC, LPALC, UINT);
int       WINAPI SetGuideHRC(HRC, LPGUIDE, UINT);
int       WINAPI SetInternationalHRC(HRC, UINT, LPCSTR, UINT, UINT);
int       WINAPI SetMaxResultsHRC(HRC, UINT);
HRECHOOK  WINAPI SetResultsHookHREC(HREC, HRCRESULTHOOKPROC);
int       WINAPI SetWordlistCoercionHRC(HRC, UINT);
int       WINAPI SetWordlistHRC(HRC, HWL);
int       WINAPI TrainHREC(HREC, LPSYV, UINT, HPENDATA, UINT);
int       WINAPI UnhookResultsHookHREC(HREC, HRECHOOK);
int       WINAPI WriteHWL(HWL, HFILE);

// Recognizer Installation:
HREC      WINAPI InstallRecognizer(LPSTR);
VOID      WINAPI UninstallRecognizer(HREC);

// Inksets:
BOOL      WINAPI AddInksetInterval(HINKSET, LPINTERVAL);
HINKSET   WINAPI CreateInkset(UINT);
BOOL      WINAPI DestroyInkset(HINKSET);
int       WINAPI GetInksetInterval(HINKSET, UINT, LPINTERVAL);
int       WINAPI GetInksetIntervalCount(HINKSET);

// Symbol Values:
int       WINAPI CharacterToSymbol(LPSTR, int, LPSYV);
BOOL      WINAPI SymbolToCharacter(LPSYV, int, LPSTR, LPINT);
#endif /*!NOPENHRC */

//---------------------------------------------------------------------------
#ifndef NOPENINKPUT

// Pen Input/Inking:
int       WINAPI DoDefaultPenInput(HWND, UINT);
int       WINAPI GetPenInput(HPCM, LPPOINT, LPVOID, UINT, UINT, LPSTROKEINFO);
int       WINAPI PeekPenInput(HPCM, UINT, LPPOINT, LPVOID, UINT);
int       WINAPI StartInking(HPCM, UINT, LPINKINGINFO);
HPCM      WINAPI StartPenInput(HWND, UINT, LPPCMINFO, LPINT);
int       WINAPI StopInking(HPCM);
int       WINAPI StopPenInput(HPCM, UINT, int);
#endif /*!NOPENINKPUT */

//---------------------------------------------------------------------------
#ifndef NOPENMISC

// Miscellaneous/Utilities:
VOID      WINAPI BoundingRectFromPoints(LPPOINT, UINT, LPRECT);
BOOL      WINAPI DPtoTP(LPPOINT, int);
UINT      WINAPI GetPenAppFlags(VOID);
VOID      WINAPI SetPenAppFlags(UINT, UINT);
LONG      WINAPI GetPenMiscInfo(WPARAM, LPARAM);
UINT      WINAPI GetVersionPenWin(VOID);
LONG      WINAPI SetPenMiscInfo(WPARAM, LPARAM);
BOOL      WINAPI TPtoDP(LPPOINT, int);
BOOL      WINAPI CorrectWriting(HWND, LPSTR, UINT, LPVOID, DWORD, DWORD);
#ifdef JAPAN
int       WINAPI CorrectWritingEx(HWND, LPSTR, UINT, LPCWX);
#endif //JAPAN
#ifdef JAPAN
HANDLE    WINAPI GetPenResource(WPARAM);
#endif //JAPAN
#ifndef _WIN32
UINT      WINAPI IsPenAware(VOID);
VOID      WINAPI RegisterPenApp(UINT, UINT);
#endif //!_WIN32

#endif /*!NOPENMISC */

//---------------------------------------------------------------------------
#ifndef NOPENRC1    // not available in WIN32

// RC1:
VOID      WINAPI EmulatePen(BOOL);
UINT      WINAPI EnumSymbols(LPSYG, UINT, ENUMPROC, LPVOID);
BOOL      WINAPI ExecuteGesture(HWND, SYV, LPRCRESULT);
VOID      WINAPI FirstSymbolFromGraph(LPSYG, LPSYV, int, LPINT);
UINT      WINAPI GetGlobalRC(LPRC, LPSTR, LPSTR, int);
int       WINAPI GetSymbolCount(LPSYG);
int       WINAPI GetSymbolMaxLength(LPSYG);
VOID      WINAPI InitRC(HWND, LPRC);
REC       WINAPI ProcessWriting(HWND, LPRC);
REC       WINAPI Recognize(LPRC);
REC       WINAPI RecognizeData(LPRC, HPENDATA);
UINT      WINAPI SetGlobalRC(LPRC, LPSTR, LPSTR);
BOOL      WINAPI SetRecogHook(UINT, UINT, HWND);
BOOL      WINAPI TrainContext(LPRCRESULT, LPSYE, int, LPSYC, int);
BOOL      WINAPI TrainInk(LPRC, HPENDATA, LPSYV);

// Custom Recognizer functions - not PenWin APIs (formerly in penwoem.h):
VOID      WINAPI CloseRecognizer(VOID);
UINT      WINAPI ConfigRecognizer(UINT, WPARAM, LPARAM);
BOOL      WINAPI InitRecognizer(LPRC);
REC       WINAPI RecognizeDataInternal(LPRC, HPENDATA, LPFUNCRESULTS);
REC       WINAPI RecognizeInternal(LPRC, LPFUNCRESULTS);
BOOL      WINAPI TrainContextInternal(LPRCRESULT, LPSYE, int, LPSYC, int);
BOOL      WINAPI TrainInkInternal(LPRC, HPENDATA, LPSYV);
#endif /*!NOPENRC1 */

//---------------------------------------------------------------------------
#ifndef NOPENTARGET

// Ink Targeting:
int       WINAPI TargetPoints(LPTARGINFO, LPPOINT, DWORD, UINT, LPSTROKEINFO);

#endif /*!NOPENTARGET */

//---------------------------------------------------------------------------
#ifndef NOPENVIRTEVENT

// Virtual Event Layer:
VOID      WINAPI AtomicVirtualEvent(BOOL);
VOID      WINAPI PostVirtualKeyEvent(UINT, BOOL);
VOID      WINAPI PostVirtualMouseEvent(UINT, int, int);
#endif /*!NOPENVIRTEVENT */

//---------------------------------------------------------------------------

#ifdef  JAPAN
// Kanji
BOOL      WINAPI KKConvert(HWND hwndConvert, HWND hwndCaller,
			   LPSTR lpBuf, UINT cbBuf, LPPOINT lpPnt);

#endif //  JAPAN

#endif /* RC_INVOKED */ // ... all the way back from definitions:3

/****** End of Header Info *************************************************/

#ifdef __cplusplus
}
#endif /* __cplusplus */

#ifndef _WIN32
#ifndef RC_INVOKED
#pragma pack()
#endif /* RC_INVOKED */
#endif //!_WIN32

#endif /* #define _INC_PENWIN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\perhist.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for perhist.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __perhist_h__
#define __perhist_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IPersistHistory_FWD_DEFINED__
#define __IPersistHistory_FWD_DEFINED__
typedef interface IPersistHistory IPersistHistory;
#endif 	/* __IPersistHistory_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_perhist_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// perhist.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// IPersistHistory Interface.


#ifndef _LPPERSISTHISTORY_DEFINED
#define _LPPERSISTHISTORY_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_perhist_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_perhist_0000_v0_0_s_ifspec;

#ifndef __IPersistHistory_INTERFACE_DEFINED__
#define __IPersistHistory_INTERFACE_DEFINED__

/* interface IPersistHistory */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IPersistHistory *LPPERSISTHISTORY;


EXTERN_C const IID IID_IPersistHistory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("91A565C1-E38F-11d0-94BF-00A0C9055CBF")
    IPersistHistory : public IPersist
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LoadHistory( 
            /* [in] */ IStream *pStream,
            /* [in] */ IBindCtx *pbc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveHistory( 
            /* [in] */ IStream *pStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPositionCookie( 
            /* [in] */ DWORD dwPositioncookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPositionCookie( 
            /* [out] */ DWORD *pdwPositioncookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistHistoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPersistHistory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPersistHistory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPersistHistory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IPersistHistory * This,
            /* [out] */ CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *LoadHistory )( 
            IPersistHistory * This,
            /* [in] */ IStream *pStream,
            /* [in] */ IBindCtx *pbc);
        
        HRESULT ( STDMETHODCALLTYPE *SaveHistory )( 
            IPersistHistory * This,
            /* [in] */ IStream *pStream);
        
        HRESULT ( STDMETHODCALLTYPE *SetPositionCookie )( 
            IPersistHistory * This,
            /* [in] */ DWORD dwPositioncookie);
        
        HRESULT ( STDMETHODCALLTYPE *GetPositionCookie )( 
            IPersistHistory * This,
            /* [out] */ DWORD *pdwPositioncookie);
        
        END_INTERFACE
    } IPersistHistoryVtbl;

    interface IPersistHistory
    {
        CONST_VTBL struct IPersistHistoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistHistory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPersistHistory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPersistHistory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPersistHistory_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IPersistHistory_LoadHistory(This,pStream,pbc)	\
    (This)->lpVtbl -> LoadHistory(This,pStream,pbc)

#define IPersistHistory_SaveHistory(This,pStream)	\
    (This)->lpVtbl -> SaveHistory(This,pStream)

#define IPersistHistory_SetPositionCookie(This,dwPositioncookie)	\
    (This)->lpVtbl -> SetPositionCookie(This,dwPositioncookie)

#define IPersistHistory_GetPositionCookie(This,pdwPositioncookie)	\
    (This)->lpVtbl -> GetPositionCookie(This,pdwPositioncookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPersistHistory_LoadHistory_Proxy( 
    IPersistHistory * This,
    /* [in] */ IStream *pStream,
    /* [in] */ IBindCtx *pbc);


void __RPC_STUB IPersistHistory_LoadHistory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPersistHistory_SaveHistory_Proxy( 
    IPersistHistory * This,
    /* [in] */ IStream *pStream);


void __RPC_STUB IPersistHistory_SaveHistory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPersistHistory_SetPositionCookie_Proxy( 
    IPersistHistory * This,
    /* [in] */ DWORD dwPositioncookie);


void __RPC_STUB IPersistHistory_SetPositionCookie_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPersistHistory_GetPositionCookie_Proxy( 
    IPersistHistory * This,
    /* [out] */ DWORD *pdwPositioncookie);


void __RPC_STUB IPersistHistory_GetPositionCookie_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPersistHistory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_perhist_0118 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_perhist_0118_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_perhist_0118_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\pkgguid.h ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    pkgguid.h

--*/

#ifndef __PKGGUID_H__
#define __PKGGUID_H__

// {D2073C40-AB4F-11d0-A732-00A0C9082637}
DEFINE_GUID(IID_ICodeStoreDBEntry,
0xD2073C40, 0xAB4F, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {DF3D9C22-AB4E-11d0-A732-00A0C9082637}
DEFINE_GUID(IID_ICodeStoreDB,
0xDF3D9C22, 0xAB4E, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {DF3D9C23-AB4E-11d0-A732-00A0C9082637}
DEFINE_GUID(CLSID_CodeStoreDB,
0xDF3D9C23, 0xAB4E, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {D2073C42-AB4F-11d0-A732-00A0C9082637}
DEFINE_GUID(IID_IEnumCodeStoreDBEntry,
0xD2073C42, 0xAB4F, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {D2073C43-AB4F-11d0-A732-00A0C9082637}
DEFINE_GUID(IID_IJavaPackageManager,
0xD2073C43, 0xAB4F, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {D2073C46-AB4F-11d0-A732-00A0C9082637}
DEFINE_GUID(IID_IJavaPackage,
0xD2073C46, 0xAB4F, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {D2073C48-AB4F-11d0-A732-00A0C9082637}
DEFINE_GUID(IID_IJavaFile,
0xD2073C48, 0xAB4F, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {D2073C47-AB4F-11d0-A732-00A0C9082637}
DEFINE_GUID(IID_ICreateJavaPackageMgr,
0xD2073C47, 0xAB4F, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {D2073C44-AB4F-11d0-A732-00A0C9082637}
DEFINE_GUID(CLSID_JavaPackageManager,
0xD2073C44, 0xAB4F, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {D2073C45-AB4F-11d0-A732-00A0C9082637}
DEFINE_GUID(IID_IEnumJavaPackage,
0xD2073C45, 0xAB4F, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {D2073C49-AB4F-11d0-A732-00A0C9082637}
DEFINE_GUID(IID_IEnumJavaFile,
0xD2073C49, 0xAB4F, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

#endif // __PKGGUID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\persist.h ===
//-----------------------------------------------------------------------------
//
// File:		persist.h
//
// Copyright: 	Copyright (c) Microsoft Corporation
//
// Contents:	MSPersist external constants GUIDS and other things users need
//
// Comments:
//
//-----------------------------------------------------------------------------

#ifndef PERSIST_H
#define PERSIST_H

// Persist Properties
#define DBPROPFLAGS_PERSIST 0x2000

#define DBPROPVAL_PERSIST_ADTG 0
#define DBPROPVAL_PERSIST_XML 1
#define DBPROP_PersistFormat 2
#define DBPROP_PersistSchema 3
#define DBPROP_HCHAPTER 4
#define DBPROP_MAINTAINPROPS 5

// XML writing only properties
#define DBPROP_Unicode	6

// internal property (read-only)
#define DBPROP_INTERLEAVEDROWS 8

extern const CLSID CLSID_MSPersist
#if (defined DBINITCONSTANTS) | (defined DSINITCONSTANTS)
 = { 0x7c07e0d0, 0x4418, 0x11d2, { 0x92, 0x12, 0x0, 0xc0, 0x4f, 0xbb, 0xbf, 0xb3 } }
#endif
;

// {4D7839A0-5B8E-11d1-A6B3-00A0C9138C66}
extern const GUID	DBPROPSET_PERSIST
#if (defined DBINITCONSTANTS) | (defined DSINITCONSTANTS)
 = { 0x4d7839a0, 0x5b8e, 0x11d1, { 0xa6, 0xb3, 0x0, 0xa0, 0xc9, 0x13, 0x8c, 0x66 } };
#endif
;

#define MS_PERSIST_PROGID "MSPersist"

extern const char *PROGID_MSPersist
#if (defined DBINITCONSTANTS) | (defined DSINITCONSTANTS)
 = MS_PERSIST_PROGID
#endif
;

extern const unsigned short *PROGID_MSPersist_W
#if (defined DBINITCONSTANTS) | (defined DSINITCONSTANTS)
= L"MSPersist"
#endif
;

extern const char *PROGID_MSPersist_Version
#if (defined DBINITCONSTANTS) | (defined DSINITCONSTANTS)
 = MS_PERSIST_PROGID ".1"
#endif
;

extern const unsigned short *PROGID_MSPersist_Version_W
#if (defined DBINITCONSTANTS) | (defined DSINITCONSTANTS)
 = L"MSPersist.1"
#endif
;

#endif // PERSIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\permdlg.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for permdlg.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __permdlg_h__
#define __permdlg_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IJavaZonePermissionEditor_FWD_DEFINED__
#define __IJavaZonePermissionEditor_FWD_DEFINED__
typedef interface IJavaZonePermissionEditor IJavaZonePermissionEditor;
#endif 	/* __IJavaZonePermissionEditor_FWD_DEFINED__ */


#ifndef __JavaRuntimeConfiguration_FWD_DEFINED__
#define __JavaRuntimeConfiguration_FWD_DEFINED__

#ifdef __cplusplus
typedef class JavaRuntimeConfiguration JavaRuntimeConfiguration;
#else
typedef struct JavaRuntimeConfiguration JavaRuntimeConfiguration;
#endif /* __cplusplus */

#endif 	/* __JavaRuntimeConfiguration_FWD_DEFINED__ */


/* header files for imported files */
#include "urlmon.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_permdlg_0000 */
/* [local] */ 

EXTERN_C const CLSID CLSID_JavaRuntimeConfiguration;


extern RPC_IF_HANDLE __MIDL_itf_permdlg_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_permdlg_0000_v0_0_s_ifspec;

#ifndef __IJavaZonePermissionEditor_INTERFACE_DEFINED__
#define __IJavaZonePermissionEditor_INTERFACE_DEFINED__

/* interface IJavaZonePermissionEditor */
/* [unique][uuid][object] */ 

typedef 
enum _JAVADISPLAYMODES
    {	JAVADISPLAY_DEFAULT	= 0,
	JAVADISPLAY_FULL	= 1,
	JAVAEDIT	= 2
    } 	JAVADISPLAYMODES;


EXTERN_C const IID IID_IJavaZonePermissionEditor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85347F8A-C8B7-11d0-8823-00C04FB67C84")
    IJavaZonePermissionEditor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ShowUI( 
            /* [in] */ HWND phwnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwMode,
            /* [in] */ URLZONEREG urlZoneReg,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwPerms,
            /* [in] */ IUnknown *pManager) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaZonePermissionEditorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IJavaZonePermissionEditor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IJavaZonePermissionEditor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IJavaZonePermissionEditor * This);
        
        HRESULT ( STDMETHODCALLTYPE *ShowUI )( 
            IJavaZonePermissionEditor * This,
            /* [in] */ HWND phwnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwMode,
            /* [in] */ URLZONEREG urlZoneReg,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwPerms,
            /* [in] */ IUnknown *pManager);
        
        END_INTERFACE
    } IJavaZonePermissionEditorVtbl;

    interface IJavaZonePermissionEditor
    {
        CONST_VTBL struct IJavaZonePermissionEditorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaZonePermissionEditor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaZonePermissionEditor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaZonePermissionEditor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaZonePermissionEditor_ShowUI(This,phwnd,dwFlags,dwMode,urlZoneReg,dwZone,dwPerms,pManager)	\
    (This)->lpVtbl -> ShowUI(This,phwnd,dwFlags,dwMode,urlZoneReg,dwZone,dwPerms,pManager)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaZonePermissionEditor_ShowUI_Proxy( 
    IJavaZonePermissionEditor * This,
    /* [in] */ HWND phwnd,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwMode,
    /* [in] */ URLZONEREG urlZoneReg,
    /* [in] */ DWORD dwZone,
    /* [in] */ DWORD dwPerms,
    /* [in] */ IUnknown *pManager);


void __RPC_STUB IJavaZonePermissionEditor_ShowUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaZonePermissionEditor_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\platform.h ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1997-1998.
//
//  File:       platform.h
//
//  Contents:   Macros for portable access to platform dependent values.
//
//
// This file contains macros for easy cross platform developing.
// There are macros for compiler differences and platform/layer differences.
//
//----------------------------------------------------------------------------


#ifndef __PLATFORM_H_
#define __PLATFORM_H_

#ifdef __cplusplus
   // +++ Unaligned memory access templates/macros
#  include <unaligned.hpp>
#endif

////////////////////////////////////////////////////////////////////
//
// Global defines (should be moved to NT public headers)
//

#define VER_PLATFORM_WIN32_UNIX 9

////////////////////////////////////////////////////////////////////
//
// Compiler differences
//

#if !defined(_MSC_VER) && !defined(__APOGEE__)
    // For compilers lacking VC++ extensions

#   define __cdecl
#   define INLINEOP      /* Inline operators not available IEUNIX */

#   ifdef UNIX
        // Unix specific compiler problems
#       define UNSIZED_ARRAY 1
#   else
#       define UNSIZED_ARRAY
#   endif // UNIX

#else // !_MSC_VER

    // VC++ compilers

#   define INLINEOP inline
#   define UNSIZED_ARRAY

#endif

#define EMPTY_SIZE UNSIZED_ARRAY

////////////////////////////////////////////////////////////////////
//
// Platform / Layer dependent sections.
//
// NOTE! #ifdefing based on WIN32 is invalid as some layers define
//       WIN32 for compatability.
//

#define ENDEXCEPT  __endexcept
#define ENDFINALLY __endfinally

#if !defined( UNIX )
#define __endexcept
#define __endfinally
#endif // UNIX

// +++ File Separators

#if defined( UNIX )
// UNIX

#  ifndef FILENAME_SEPARATOR
#  define FILENAME_SEPARATOR       '/'
#  endif

#  ifndef FILENAME_SEPARATOR_W
#  define FILENAME_SEPARATOR_W     L'/'
#  endif

#  ifndef FILENAME_SEPARATOR_STR
#  define FILENAME_SEPARATOR_STR   "/"
#  endif

#  ifndef FILENAME_SEPARATOR_STR_W
#  define FILENAME_SEPARATOR_STR_W L"/"
#  endif

#  ifndef PATH_SEPARATOR
#  define PATH_SEPARATOR           ':'
#  endif

#  ifndef PATH_SEPARATOR_W
#  define PATH_SEPARATOR_W         L':'
#  endif

#  ifndef PATH_SEPARATOR_STR
#  define PATH_SEPARATOR_STR       ":"
#  endif

#  ifndef PATH_SEPARATOR_STR_W
#  define PATH_SEPARATOR_STR_W     L":"
#  endif

#  ifndef LINE_SEPARATOR_STR
#  define LINE_SEPARATOR_STR       "\n"
#  endif

#  ifndef LINE_SEPARATOR_STR_W
#  define LINE_SEPARATOR_STR_W     L"\n"
#  endif

#else // UNIX

// Windows / MAC

#  ifndef FILENAME_SEPARATOR
#  define FILENAME_SEPARATOR       '\\'
#  endif

#  ifndef FILENAME_SEPARATOR_W
#  define FILENAME_SEPARATOR_W     L'\\'
#  endif

#  ifndef FILENAME_SEPARATOR_STR
#  define FILENAME_SEPARATOR_STR   "\\"
#  endif

#  ifndef FILENAME_SEPARATOR_STR_W
#  define FILENAME_SEPARATOR_STR_W L"\\"
#  endif

#  ifndef PATH_SEPARATOR
#  define PATH_SEPARATOR           ';'
#  endif

#  ifndef PATH_SEPARATOR_W
#  define PATH_SEPARATOR_W         L';'
#  endif

#  ifndef PATH_SEPARATOR_STR
#  define PATH_SEPARATOR_STR       ";"
#  endif

#  ifndef PATH_SEPARATOR_STR_W
#  define PATH_SEPARATOR_STR_W     L";"
#  endif

#  ifndef LINE_SEPARATOR_STR
#  define LINE_SEPARATOR_STR       "\r\n"
#  endif

#  ifndef LINE_SEPARATOR_STR_W
#  define LINE_SEPARATOR_STR_W     L"\r\n"
#  endif

#endif // Windows / MAC



#ifdef UNIX


#  define PLATFORM_ACCEL_KEY ALT
#  define PLATFORM_ACCEL_STR "Alt"  // --  Look in rc.sed files
#  define FACCELKEY FALT

#define VK_OEM_SLASH 0xBF

#else   /* UNIX  */

#define INTERFACE_PROLOGUE(a)
#define INTERFACE_EPILOGUE(a)
#define INTERFACE_PROLOGUE_(a,b)
#define INTERFACE_EPILOGUE_(a,b)


#  define PLATFORM_ACCEL_KEY CONTROL
#  define PLATFORM_ACCEL_STR "Ctrl"  // --  Look in rc.sed files
#  define FACCELKEY FCONTROL

#define VK_OEM_SLASH '/'

#endif  /* UNIX */

#define MAKELONGLONG(low,high) ((LONGLONG)(((DWORD)(low)) | ((LONGLONG)((DWORD)(high))) << 32))

#ifdef BIG_ENDIAN
#define MAKE_LI(low,high) { high, low }
#define PALETTE_ENTRY( r, g, b, f )  { f, b, g, r }
#else
#define MAKE_LI(low,high) { low, high }
#define PALETTE_ENTRY( r, g, b, f )  { r, g, b, f }
#endif

#endif // __PLATFORM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\plan16.h ===
/*****************************************************************************\
* Copyright (C) Microsoft Corporation, 1990-1999
* PLAN16.H - PORTABILITY MAPPING HEADER FILE FOR LANMAN API
*
* This file provides macros to map portable lanman code to its 16 bit form.
\*****************************************************************************/

#if _MSC_VER > 1000
#pragma once
#endif

/*-----------------------------------LANMAN----------------------------------*/

/* LANMAN MACROS: */

#define COPYTOARRAY(pDest, pSource)     strcpy(pDest, pSource)

/* LANMAN API: */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\playlist.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* Compiler settings for playlist.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __playlist_h__
#define __playlist_h__

/* Forward Declarations */ 

#ifndef __IAMPlayListItem_FWD_DEFINED__
#define __IAMPlayListItem_FWD_DEFINED__
typedef interface IAMPlayListItem IAMPlayListItem;
#endif 	/* __IAMPlayListItem_FWD_DEFINED__ */


#ifndef __IAMPlayList_FWD_DEFINED__
#define __IAMPlayList_FWD_DEFINED__
typedef interface IAMPlayList IAMPlayList;
#endif 	/* __IAMPlayList_FWD_DEFINED__ */


#ifndef __ISpecifyParticularPages_FWD_DEFINED__
#define __ISpecifyParticularPages_FWD_DEFINED__
typedef interface ISpecifyParticularPages ISpecifyParticularPages;
#endif 	/* __ISpecifyParticularPages_FWD_DEFINED__ */


#ifndef __IAMRebuild_FWD_DEFINED__
#define __IAMRebuild_FWD_DEFINED__
typedef interface IAMRebuild IAMRebuild;
#endif 	/* __IAMRebuild_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "strmif.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_playlist_0000 */
/* [local] */ 


enum AMPlayListItemFlags
    {	AMPLAYLISTITEM_CANSKIP	= 0x1,
	AMPLAYLISTITEM_CANBIND	= 0x2
    };


extern RPC_IF_HANDLE __MIDL_itf_playlist_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_playlist_0000_v0_0_s_ifspec;

#ifndef __IAMPlayListItem_INTERFACE_DEFINED__
#define __IAMPlayListItem_INTERFACE_DEFINED__

/* interface IAMPlayListItem */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMPlayListItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868ff-0ad4-11ce-b03a-0020af0ba770")
    IAMPlayListItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [out] */ DWORD __RPC_FAR *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourceCount( 
            /* [out] */ DWORD __RPC_FAR *pdwSources) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourceURL( 
            /* [in] */ DWORD dwSourceIndex,
            /* [out] */ BSTR __RPC_FAR *pbstrURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourceStart( 
            /* [in] */ DWORD dwSourceIndex,
            /* [out] */ REFERENCE_TIME __RPC_FAR *prtStart) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourceDuration( 
            /* [in] */ DWORD dwSourceIndex,
            /* [out] */ REFERENCE_TIME __RPC_FAR *prtDuration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourceStartMarker( 
            /* [in] */ DWORD dwSourceIndex,
            /* [out] */ DWORD __RPC_FAR *pdwMarker) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourceEndMarker( 
            /* [in] */ DWORD dwSourceIndex,
            /* [out] */ DWORD __RPC_FAR *pdwMarker) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourceStartMarkerName( 
            /* [in] */ DWORD dwSourceIndex,
            /* [out] */ BSTR __RPC_FAR *pbstrStartMarker) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourceEndMarkerName( 
            /* [in] */ DWORD dwSourceIndex,
            /* [out] */ BSTR __RPC_FAR *pbstrEndMarker) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLinkURL( 
            /* [out] */ BSTR __RPC_FAR *pbstrURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScanDuration( 
            /* [in] */ DWORD dwSourceIndex,
            /* [out] */ REFERENCE_TIME __RPC_FAR *prtScanDuration) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMPlayListItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAMPlayListItem __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAMPlayListItem __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAMPlayListItem __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )( 
            IAMPlayListItem __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSourceCount )( 
            IAMPlayListItem __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwSources);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSourceURL )( 
            IAMPlayListItem __RPC_FAR * This,
            /* [in] */ DWORD dwSourceIndex,
            /* [out] */ BSTR __RPC_FAR *pbstrURL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSourceStart )( 
            IAMPlayListItem __RPC_FAR * This,
            /* [in] */ DWORD dwSourceIndex,
            /* [out] */ REFERENCE_TIME __RPC_FAR *prtStart);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSourceDuration )( 
            IAMPlayListItem __RPC_FAR * This,
            /* [in] */ DWORD dwSourceIndex,
            /* [out] */ REFERENCE_TIME __RPC_FAR *prtDuration);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSourceStartMarker )( 
            IAMPlayListItem __RPC_FAR * This,
            /* [in] */ DWORD dwSourceIndex,
            /* [out] */ DWORD __RPC_FAR *pdwMarker);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSourceEndMarker )( 
            IAMPlayListItem __RPC_FAR * This,
            /* [in] */ DWORD dwSourceIndex,
            /* [out] */ DWORD __RPC_FAR *pdwMarker);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSourceStartMarkerName )( 
            IAMPlayListItem __RPC_FAR * This,
            /* [in] */ DWORD dwSourceIndex,
            /* [out] */ BSTR __RPC_FAR *pbstrStartMarker);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSourceEndMarkerName )( 
            IAMPlayListItem __RPC_FAR * This,
            /* [in] */ DWORD dwSourceIndex,
            /* [out] */ BSTR __RPC_FAR *pbstrEndMarker);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLinkURL )( 
            IAMPlayListItem __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrURL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScanDuration )( 
            IAMPlayListItem __RPC_FAR * This,
            /* [in] */ DWORD dwSourceIndex,
            /* [out] */ REFERENCE_TIME __RPC_FAR *prtScanDuration);
        
        END_INTERFACE
    } IAMPlayListItemVtbl;

    interface IAMPlayListItem
    {
        CONST_VTBL struct IAMPlayListItemVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMPlayListItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMPlayListItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMPlayListItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMPlayListItem_GetFlags(This,pdwFlags)	\
    (This)->lpVtbl -> GetFlags(This,pdwFlags)

#define IAMPlayListItem_GetSourceCount(This,pdwSources)	\
    (This)->lpVtbl -> GetSourceCount(This,pdwSources)

#define IAMPlayListItem_GetSourceURL(This,dwSourceIndex,pbstrURL)	\
    (This)->lpVtbl -> GetSourceURL(This,dwSourceIndex,pbstrURL)

#define IAMPlayListItem_GetSourceStart(This,dwSourceIndex,prtStart)	\
    (This)->lpVtbl -> GetSourceStart(This,dwSourceIndex,prtStart)

#define IAMPlayListItem_GetSourceDuration(This,dwSourceIndex,prtDuration)	\
    (This)->lpVtbl -> GetSourceDuration(This,dwSourceIndex,prtDuration)

#define IAMPlayListItem_GetSourceStartMarker(This,dwSourceIndex,pdwMarker)	\
    (This)->lpVtbl -> GetSourceStartMarker(This,dwSourceIndex,pdwMarker)

#define IAMPlayListItem_GetSourceEndMarker(This,dwSourceIndex,pdwMarker)	\
    (This)->lpVtbl -> GetSourceEndMarker(This,dwSourceIndex,pdwMarker)

#define IAMPlayListItem_GetSourceStartMarkerName(This,dwSourceIndex,pbstrStartMarker)	\
    (This)->lpVtbl -> GetSourceStartMarkerName(This,dwSourceIndex,pbstrStartMarker)

#define IAMPlayListItem_GetSourceEndMarkerName(This,dwSourceIndex,pbstrEndMarker)	\
    (This)->lpVtbl -> GetSourceEndMarkerName(This,dwSourceIndex,pbstrEndMarker)

#define IAMPlayListItem_GetLinkURL(This,pbstrURL)	\
    (This)->lpVtbl -> GetLinkURL(This,pbstrURL)

#define IAMPlayListItem_GetScanDuration(This,dwSourceIndex,prtScanDuration)	\
    (This)->lpVtbl -> GetScanDuration(This,dwSourceIndex,prtScanDuration)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMPlayListItem_GetFlags_Proxy( 
    IAMPlayListItem __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwFlags);


void __RPC_STUB IAMPlayListItem_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMPlayListItem_GetSourceCount_Proxy( 
    IAMPlayListItem __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwSources);


void __RPC_STUB IAMPlayListItem_GetSourceCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMPlayListItem_GetSourceURL_Proxy( 
    IAMPlayListItem __RPC_FAR * This,
    /* [in] */ DWORD dwSourceIndex,
    /* [out] */ BSTR __RPC_FAR *pbstrURL);


void __RPC_STUB IAMPlayListItem_GetSourceURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMPlayListItem_GetSourceStart_Proxy( 
    IAMPlayListItem __RPC_FAR * This,
    /* [in] */ DWORD dwSourceIndex,
    /* [out] */ REFERENCE_TIME __RPC_FAR *prtStart);


void __RPC_STUB IAMPlayListItem_GetSourceStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMPlayListItem_GetSourceDuration_Proxy( 
    IAMPlayListItem __RPC_FAR * This,
    /* [in] */ DWORD dwSourceIndex,
    /* [out] */ REFERENCE_TIME __RPC_FAR *prtDuration);


void __RPC_STUB IAMPlayListItem_GetSourceDuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMPlayListItem_GetSourceStartMarker_Proxy( 
    IAMPlayListItem __RPC_FAR * This,
    /* [in] */ DWORD dwSourceIndex,
    /* [out] */ DWORD __RPC_FAR *pdwMarker);


void __RPC_STUB IAMPlayListItem_GetSourceStartMarker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMPlayListItem_GetSourceEndMarker_Proxy( 
    IAMPlayListItem __RPC_FAR * This,
    /* [in] */ DWORD dwSourceIndex,
    /* [out] */ DWORD __RPC_FAR *pdwMarker);


void __RPC_STUB IAMPlayListItem_GetSourceEndMarker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMPlayListItem_GetSourceStartMarkerName_Proxy( 
    IAMPlayListItem __RPC_FAR * This,
    /* [in] */ DWORD dwSourceIndex,
    /* [out] */ BSTR __RPC_FAR *pbstrStartMarker);


void __RPC_STUB IAMPlayListItem_GetSourceStartMarkerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMPlayListItem_GetSourceEndMarkerName_Proxy( 
    IAMPlayListItem __RPC_FAR * This,
    /* [in] */ DWORD dwSourceIndex,
    /* [out] */ BSTR __RPC_FAR *pbstrEndMarker);


void __RPC_STUB IAMPlayListItem_GetSourceEndMarkerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMPlayListItem_GetLinkURL_Proxy( 
    IAMPlayListItem __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrURL);


void __RPC_STUB IAMPlayListItem_GetLinkURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMPlayListItem_GetScanDuration_Proxy( 
    IAMPlayListItem __RPC_FAR * This,
    /* [in] */ DWORD dwSourceIndex,
    /* [out] */ REFERENCE_TIME __RPC_FAR *prtScanDuration);


void __RPC_STUB IAMPlayListItem_GetScanDuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMPlayListItem_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_playlist_0348 */
/* [local] */ 


enum AMPlayListFlags
    {	AMPLAYLIST_STARTINSCANMODE	= 0x1,
	AMPLAYLIST_FORCEBANNER	= 0x2
    };

enum AMPlayListEventFlags
    {	AMPLAYLISTEVENT_RESUME	= 0,
	AMPLAYLISTEVENT_BREAK	= 0x1,
	AMPLAYLISTEVENT_NEXT	= 0x2,
	AMPLAYLISTEVENT_MASK	= 0xf,
	AMPLAYLISTEVENT_REFRESH	= 0x10
    };


extern RPC_IF_HANDLE __MIDL_itf_playlist_0348_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_playlist_0348_v0_0_s_ifspec;

#ifndef __IAMPlayList_INTERFACE_DEFINED__
#define __IAMPlayList_INTERFACE_DEFINED__

/* interface IAMPlayList */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMPlayList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868fe-0ad4-11ce-b03a-0020af0ba770")
    IAMPlayList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [out] */ DWORD __RPC_FAR *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemCount( 
            /* [out] */ DWORD __RPC_FAR *pdwItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItem( 
            /* [in] */ DWORD dwItemIndex,
            /* [out] */ IAMPlayListItem __RPC_FAR *__RPC_FAR *ppItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNamedEvent( 
            /* [in] */ WCHAR __RPC_FAR *pwszEventName,
            /* [in] */ DWORD dwItemIndex,
            /* [out] */ IAMPlayListItem __RPC_FAR *__RPC_FAR *ppItem,
            /* [out] */ DWORD __RPC_FAR *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRepeatInfo( 
            /* [out] */ DWORD __RPC_FAR *pdwRepeatCount,
            /* [out] */ DWORD __RPC_FAR *pdwRepeatStart,
            /* [out] */ DWORD __RPC_FAR *pdwRepeatEnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMPlayListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAMPlayList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAMPlayList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAMPlayList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )( 
            IAMPlayList __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItemCount )( 
            IAMPlayList __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwItems);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItem )( 
            IAMPlayList __RPC_FAR * This,
            /* [in] */ DWORD dwItemIndex,
            /* [out] */ IAMPlayListItem __RPC_FAR *__RPC_FAR *ppItem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNamedEvent )( 
            IAMPlayList __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszEventName,
            /* [in] */ DWORD dwItemIndex,
            /* [out] */ IAMPlayListItem __RPC_FAR *__RPC_FAR *ppItem,
            /* [out] */ DWORD __RPC_FAR *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRepeatInfo )( 
            IAMPlayList __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwRepeatCount,
            /* [out] */ DWORD __RPC_FAR *pdwRepeatStart,
            /* [out] */ DWORD __RPC_FAR *pdwRepeatEnd);
        
        END_INTERFACE
    } IAMPlayListVtbl;

    interface IAMPlayList
    {
        CONST_VTBL struct IAMPlayListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMPlayList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMPlayList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMPlayList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMPlayList_GetFlags(This,pdwFlags)	\
    (This)->lpVtbl -> GetFlags(This,pdwFlags)

#define IAMPlayList_GetItemCount(This,pdwItems)	\
    (This)->lpVtbl -> GetItemCount(This,pdwItems)

#define IAMPlayList_GetItem(This,dwItemIndex,ppItem)	\
    (This)->lpVtbl -> GetItem(This,dwItemIndex,ppItem)

#define IAMPlayList_GetNamedEvent(This,pwszEventName,dwItemIndex,ppItem,pdwFlags)	\
    (This)->lpVtbl -> GetNamedEvent(This,pwszEventName,dwItemIndex,ppItem,pdwFlags)

#define IAMPlayList_GetRepeatInfo(This,pdwRepeatCount,pdwRepeatStart,pdwRepeatEnd)	\
    (This)->lpVtbl -> GetRepeatInfo(This,pdwRepeatCount,pdwRepeatStart,pdwRepeatEnd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMPlayList_GetFlags_Proxy( 
    IAMPlayList __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwFlags);


void __RPC_STUB IAMPlayList_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMPlayList_GetItemCount_Proxy( 
    IAMPlayList __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwItems);


void __RPC_STUB IAMPlayList_GetItemCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMPlayList_GetItem_Proxy( 
    IAMPlayList __RPC_FAR * This,
    /* [in] */ DWORD dwItemIndex,
    /* [out] */ IAMPlayListItem __RPC_FAR *__RPC_FAR *ppItem);


void __RPC_STUB IAMPlayList_GetItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMPlayList_GetNamedEvent_Proxy( 
    IAMPlayList __RPC_FAR * This,
    /* [in] */ WCHAR __RPC_FAR *pwszEventName,
    /* [in] */ DWORD dwItemIndex,
    /* [out] */ IAMPlayListItem __RPC_FAR *__RPC_FAR *ppItem,
    /* [out] */ DWORD __RPC_FAR *pdwFlags);


void __RPC_STUB IAMPlayList_GetNamedEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMPlayList_GetRepeatInfo_Proxy( 
    IAMPlayList __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwRepeatCount,
    /* [out] */ DWORD __RPC_FAR *pdwRepeatStart,
    /* [out] */ DWORD __RPC_FAR *pdwRepeatEnd);


void __RPC_STUB IAMPlayList_GetRepeatInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMPlayList_INTERFACE_DEFINED__ */


#ifndef __ISpecifyParticularPages_INTERFACE_DEFINED__
#define __ISpecifyParticularPages_INTERFACE_DEFINED__

/* interface ISpecifyParticularPages */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_ISpecifyParticularPages;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4C437B91-6E9E-11d1-A704-006097C4E476")
    ISpecifyParticularPages : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPages( 
            /* [in] */ REFGUID guidWhatPages,
            /* [out] */ CAUUID __RPC_FAR *pPages) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpecifyParticularPagesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISpecifyParticularPages __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISpecifyParticularPages __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISpecifyParticularPages __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPages )( 
            ISpecifyParticularPages __RPC_FAR * This,
            /* [in] */ REFGUID guidWhatPages,
            /* [out] */ CAUUID __RPC_FAR *pPages);
        
        END_INTERFACE
    } ISpecifyParticularPagesVtbl;

    interface ISpecifyParticularPages
    {
        CONST_VTBL struct ISpecifyParticularPagesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpecifyParticularPages_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpecifyParticularPages_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpecifyParticularPages_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpecifyParticularPages_GetPages(This,guidWhatPages,pPages)	\
    (This)->lpVtbl -> GetPages(This,guidWhatPages,pPages)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpecifyParticularPages_GetPages_Proxy( 
    ISpecifyParticularPages __RPC_FAR * This,
    /* [in] */ REFGUID guidWhatPages,
    /* [out] */ CAUUID __RPC_FAR *pPages);


void __RPC_STUB ISpecifyParticularPages_GetPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpecifyParticularPages_INTERFACE_DEFINED__ */


#ifndef __IAMRebuild_INTERFACE_DEFINED__
#define __IAMRebuild_INTERFACE_DEFINED__

/* interface IAMRebuild */
/* [object][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IAMRebuild;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("02EF04DD-7580-11d1-BECE-00C04FB6E937")
    IAMRebuild : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RebuildNow( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMRebuildVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAMRebuild __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAMRebuild __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAMRebuild __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RebuildNow )( 
            IAMRebuild __RPC_FAR * This);
        
        END_INTERFACE
    } IAMRebuildVtbl;

    interface IAMRebuild
    {
        CONST_VTBL struct IAMRebuildVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMRebuild_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMRebuild_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMRebuild_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMRebuild_RebuildNow(This)	\
    (This)->lpVtbl -> RebuildNow(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMRebuild_RebuildNow_Proxy( 
    IAMRebuild __RPC_FAR * This);


void __RPC_STUB IAMRebuild_RebuildNow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMRebuild_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_playlist_0351 */
/* [local] */ 

EXTERN_GUID(IID_IAMPlayListItem,0x56a868ff,0x0ad4,0x11ce,0xb0,0xa3,0x0,0x20,0xaf,0x0b,0xa7,0x70);
EXTERN_GUID(IID_IAMRebuild,0x2ef04dd,0x7580,0x11d1,0xbe,0xce,0x0,0xc0,0x4f,0xb6,0xe9,0x37);
EXTERN_GUID(IID_IAMPlayList,0x56a868fe,0x0ad4,0x11ce,0xb0,0xa3,0x0,0x20,0xaf,0x0b,0xa7,0x70);
EXTERN_GUID(SPECIFYPAGES_STATISTICS,0x4c437b92,0x6e9e,0x11d1,0xa7,0x4,0x0,0x60,0x97,0xc4,0xe4,0x76);
EXTERN_GUID(IID_ISpecifyParticularPages,0x4c437b91,0x6e9e,0x11d1,0xa7,0x4,0x0,0x60,0x97,0xc4,0xe4,0x76);


extern RPC_IF_HANDLE __MIDL_itf_playlist_0351_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_playlist_0351_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\pngfilt.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Fri Jul 30 23:15:12 1999
 */
/* Compiler settings for pngfilt.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __pngfilt_h__
#define __pngfilt_h__

/* Forward Declarations */ 

#ifndef __CoPNGFilter_FWD_DEFINED__
#define __CoPNGFilter_FWD_DEFINED__

#ifdef __cplusplus
typedef class CoPNGFilter CoPNGFilter;
#else
typedef struct CoPNGFilter CoPNGFilter;
#endif /* __cplusplus */

#endif 	/* __CoPNGFilter_FWD_DEFINED__ */


/* header files for imported files */
#include "ocmm.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __PNGFilterLib_LIBRARY_DEFINED__
#define __PNGFilterLib_LIBRARY_DEFINED__

/* library PNGFilterLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_PNGFilterLib;

EXTERN_C const CLSID CLSID_CoPNGFilter;

#ifdef __cplusplus

class DECLSPEC_UUID("A3CCEDF7-2DE2-11D0-86F4-00A0C913F750")
CoPNGFilter;
#endif
#endif /* __PNGFilterLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\plan32.h ===
/*****************************************************************************\
* Copyright (C) Microsoft Corporation, 1990-1999
* PLAN32.H - PORTABILITY MAPPING HEADER FILE
*
* This file provides macros to map portable lanman code to its 32 bit form.
\*****************************************************************************/

#if _MSC_VER > 1000
#pragma once
#endif


/*----------------------------------LANMAN----------------------------------*/

/* LANMAN MACROS: */

#define COPYTOARRAY(pDest, pSource)     pDest = pSource

/* LANMAN API: */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\pkgmgr.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Fri Jul 11 15:30:21 1997
 */
/* Compiler settings for pkgmgr.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __pkgmgr_h__
#define __pkgmgr_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IEnumCodeStoreDBEntry_FWD_DEFINED__
#define __IEnumCodeStoreDBEntry_FWD_DEFINED__
typedef interface IEnumCodeStoreDBEntry IEnumCodeStoreDBEntry;
#endif 	/* __IEnumCodeStoreDBEntry_FWD_DEFINED__ */


#ifndef __ICodeStoreDBEntry_FWD_DEFINED__
#define __ICodeStoreDBEntry_FWD_DEFINED__
typedef interface ICodeStoreDBEntry ICodeStoreDBEntry;
#endif 	/* __ICodeStoreDBEntry_FWD_DEFINED__ */


#ifndef __ICodeStoreDB_FWD_DEFINED__
#define __ICodeStoreDB_FWD_DEFINED__
typedef interface ICodeStoreDB ICodeStoreDB;
#endif 	/* __ICodeStoreDB_FWD_DEFINED__ */


#ifndef __IJavaPackageManager_FWD_DEFINED__
#define __IJavaPackageManager_FWD_DEFINED__
typedef interface IJavaPackageManager IJavaPackageManager;
#endif 	/* __IJavaPackageManager_FWD_DEFINED__ */


#ifndef __IJavaPackage_FWD_DEFINED__
#define __IJavaPackage_FWD_DEFINED__
typedef interface IJavaPackage IJavaPackage;
#endif 	/* __IJavaPackage_FWD_DEFINED__ */


#ifndef __ICreateJavaPackageMgr_FWD_DEFINED__
#define __ICreateJavaPackageMgr_FWD_DEFINED__
typedef interface ICreateJavaPackageMgr ICreateJavaPackageMgr;
#endif 	/* __ICreateJavaPackageMgr_FWD_DEFINED__ */


#ifndef __IJavaFile_FWD_DEFINED__
#define __IJavaFile_FWD_DEFINED__
typedef interface IJavaFile IJavaFile;
#endif 	/* __IJavaFile_FWD_DEFINED__ */


#ifndef __IEnumJavaPackage_FWD_DEFINED__
#define __IEnumJavaPackage_FWD_DEFINED__
typedef interface IEnumJavaPackage IEnumJavaPackage;
#endif 	/* __IEnumJavaPackage_FWD_DEFINED__ */


#ifndef __IEnumJavaFile_FWD_DEFINED__
#define __IEnumJavaFile_FWD_DEFINED__
typedef interface IEnumJavaFile IEnumJavaFile;
#endif 	/* __IEnumJavaFile_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 







typedef const BYTE __RPC_FAR *LPCBYTE;

typedef /* [public] */ 
enum __MIDL___MIDL__intf_0000_0001
    {	JPMPII_SYSTEMCLASS	= 0,
	JPMPII_NONSYSTEMCLASS	= 1,
	JPMPII_NEEDSTRUSTEDSOURCE	= 2,
	ALL_JPMPII_FLAGS	= JPMPII_SYSTEMCLASS | JPMPII_NONSYSTEMCLASS | JPMPII_NEEDSTRUSTEDSOURCE
    }	JPMPII_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL__intf_0000_0002
    {	JPMINST_NOVERSIONCHECK	= 1,
	JPMINST_NOSIGNERCHECK	= 2,
	JPMINST_AUTODETECTPACKAGES	= 4,
	JPMINST_DELETEINPUTFILE	= 8,
	ALL_JPMINST_FLAGS	= JPMINST_NOVERSIONCHECK | JPMINST_NOSIGNERCHECK | JPMINST_AUTODETECTPACKAGES | JPMINST_DELETEINPUTFILE
    }	JPMINST_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL__intf_0000_0003
    {	JPMINST_CAB	= 0,
	JPMINST_ZIP	= 1,
	JPMINST_JAR	= 2
    }	JPMINST_FILETYPES;

typedef struct  tagPACKAGEINSTALLINFO
    {
    DWORD cbStruct;
    LPCOLESTR pszPackageName;
    DWORD dwVersionMS;
    DWORD dwVersionLS;
    DWORD dwFlags;
    LPCOLESTR pszCodebaseURL;
    LPCOLESTR pszDistributionUnit;
    LPUNKNOWN pUnknown;
    HRESULT result;
    }	PACKAGEINSTALLINFO;

typedef /* [unique] */ PACKAGEINSTALLINFO __RPC_FAR *LPPACKAGEINSTALLINFO;

typedef /* [unique] */ const PACKAGEINSTALLINFO __RPC_FAR *LPCPACKAGEINSTALLINFO;

typedef struct  tagPACKAGESECURITYINFO
    {
    DWORD cbStruct;
    LPCBYTE pCapabilities;
    DWORD cbCapabilities;
    LPCBYTE pSigner;
    DWORD cbSigner;
    BOOL fAllPermissions;
    }	PACKAGESECURITYINFO;

typedef /* [unique] */ const PACKAGESECURITYINFO __RPC_FAR *LPCPACKAGESECURITYINFO;



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;


#ifndef __JPKGMGR_LIBRARY_DEFINED__
#define __JPKGMGR_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: JPKGMGR
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [helpstring][version][uuid] */ 


typedef /* [public] */ 
enum __MIDL___MIDL__intf_0071_0001
    {	CRF_REMOVECHILDREN	= 1,
	CRF_REMOVEVALUESONLY	= 2,
	CRF_REMOVEEMPTYPARENTSALSO	= 4
    }	CSDB_REMOVE_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL__intf_0071_0002
    {	CGF_FULLYQUALIFIED	= 1
    }	CSDB_GETNAME_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL__intf_0073_0001
    {	JPMFI_NEEDS_TRUSTED_SOURCE	= 0x1,
	JPMFI_IS_STREAM	= 0x2,
	JPMFI_IS_PE_NATIVE	= 0x8,
	JPMFI_FROM_PKG_DATABASE	= 0x10,
	JPMFI_FROM_CLASSPATH	= 0x20
    }	JPM_FILEINFO_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL__intf_0073_0002
    {	JPMGFN_SIMPLE	= 1,
	JPMGFN_FULLYQUALIFIED	= 2,
	JPMGFN_LOCALFILEPATH	= 3
    }	JPM_GETFILENAME_TYPE;


EXTERN_C const IID LIBID_JPKGMGR;

#ifndef __IEnumCodeStoreDBEntry_INTERFACE_DEFINED__
#define __IEnumCodeStoreDBEntry_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumCodeStoreDBEntry
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IEnumCodeStoreDBEntry __RPC_FAR *LPENUMCODESTOREDBENTRY;


EXTERN_C const IID IID_IEnumCodeStoreDBEntry;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumCodeStoreDBEntry : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumCodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumCodeStoreDBEntryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumCodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumCodeStoreDBEntry __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumCodeStoreDBEntry __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumCodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumCodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumCodeStoreDBEntry __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumCodeStoreDBEntry __RPC_FAR * This,
            /* [out] */ IEnumCodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumCodeStoreDBEntryVtbl;

    interface IEnumCodeStoreDBEntry
    {
        CONST_VTBL struct IEnumCodeStoreDBEntryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumCodeStoreDBEntry_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumCodeStoreDBEntry_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumCodeStoreDBEntry_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumCodeStoreDBEntry_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumCodeStoreDBEntry_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumCodeStoreDBEntry_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumCodeStoreDBEntry_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumCodeStoreDBEntry_Next_Proxy( 
    IEnumCodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumCodeStoreDBEntry_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCodeStoreDBEntry_Skip_Proxy( 
    IEnumCodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumCodeStoreDBEntry_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCodeStoreDBEntry_Reset_Proxy( 
    IEnumCodeStoreDBEntry __RPC_FAR * This);


void __RPC_STUB IEnumCodeStoreDBEntry_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCodeStoreDBEntry_Clone_Proxy( 
    IEnumCodeStoreDBEntry __RPC_FAR * This,
    /* [out] */ IEnumCodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumCodeStoreDBEntry_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumCodeStoreDBEntry_INTERFACE_DEFINED__ */


#ifndef __ICodeStoreDBEntry_INTERFACE_DEFINED__
#define __ICodeStoreDBEntry_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICodeStoreDBEntry
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_ICodeStoreDBEntry;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICodeStoreDBEntry : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ DWORD dwFlags,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateChild( 
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveChild( 
            /* [in] */ LPCOLESTR pszName,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChild( 
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumChildren( 
            /* [retval][out] */ IEnumCodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParent( 
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppParent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteProperty( 
            /* [in] */ LPCOLESTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDWORDPropertyA( 
            /* [in] */ LPCSTR pszName,
            /* [out] */ DWORD __RPC_FAR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDWORDPropertyA( 
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStringPropertyA( 
            /* [in] */ LPCSTR pszName,
            /* [out] */ LPSTR pszVal,
            /* [in] */ DWORD cbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStringPropertyA( 
            /* [in] */ LPCSTR pszName,
            /* [in] */ LPCSTR pszVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICodeStoreDBEntryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICodeStoreDBEntry __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICodeStoreDBEntry __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateChild )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveChild )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszName,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChild )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumChildren )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [retval][out] */ IEnumCodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParent )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppParent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProperty )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteProperty )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDWORDPropertyA )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [out] */ DWORD __RPC_FAR *pVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDWORDPropertyA )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStringPropertyA )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [out] */ LPSTR pszVal,
            /* [in] */ DWORD cbVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStringPropertyA )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ LPCSTR pszVal);
        
        END_INTERFACE
    } ICodeStoreDBEntryVtbl;

    interface ICodeStoreDBEntry
    {
        CONST_VTBL struct ICodeStoreDBEntryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICodeStoreDBEntry_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICodeStoreDBEntry_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICodeStoreDBEntry_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICodeStoreDBEntry_GetName(This,dwFlags,pbstrName)	\
    (This)->lpVtbl -> GetName(This,dwFlags,pbstrName)

#define ICodeStoreDBEntry_CreateChild(This,pszName,ppEntry)	\
    (This)->lpVtbl -> CreateChild(This,pszName,ppEntry)

#define ICodeStoreDBEntry_RemoveChild(This,pszName,dwFlags)	\
    (This)->lpVtbl -> RemoveChild(This,pszName,dwFlags)

#define ICodeStoreDBEntry_GetChild(This,pszName,ppEntry)	\
    (This)->lpVtbl -> GetChild(This,pszName,ppEntry)

#define ICodeStoreDBEntry_EnumChildren(This,ppEntry)	\
    (This)->lpVtbl -> EnumChildren(This,ppEntry)

#define ICodeStoreDBEntry_GetParent(This,ppParent)	\
    (This)->lpVtbl -> GetParent(This,ppParent)

#define ICodeStoreDBEntry_GetProperty(This,pszName,pvarProperty)	\
    (This)->lpVtbl -> GetProperty(This,pszName,pvarProperty)

#define ICodeStoreDBEntry_SetProperty(This,pszName,pvarProperty)	\
    (This)->lpVtbl -> SetProperty(This,pszName,pvarProperty)

#define ICodeStoreDBEntry_DeleteProperty(This,pszName)	\
    (This)->lpVtbl -> DeleteProperty(This,pszName)

#define ICodeStoreDBEntry_GetDWORDPropertyA(This,pszName,pVal)	\
    (This)->lpVtbl -> GetDWORDPropertyA(This,pszName,pVal)

#define ICodeStoreDBEntry_SetDWORDPropertyA(This,pszName,dwVal)	\
    (This)->lpVtbl -> SetDWORDPropertyA(This,pszName,dwVal)

#define ICodeStoreDBEntry_GetStringPropertyA(This,pszName,pszVal,cbVal)	\
    (This)->lpVtbl -> GetStringPropertyA(This,pszName,pszVal,cbVal)

#define ICodeStoreDBEntry_SetStringPropertyA(This,pszName,pszVal)	\
    (This)->lpVtbl -> SetStringPropertyA(This,pszName,pszVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_GetName_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB ICodeStoreDBEntry_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_CreateChild_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszName,
    /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);


void __RPC_STUB ICodeStoreDBEntry_CreateChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_RemoveChild_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszName,
    DWORD dwFlags);


void __RPC_STUB ICodeStoreDBEntry_RemoveChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_GetChild_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszName,
    /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);


void __RPC_STUB ICodeStoreDBEntry_GetChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_EnumChildren_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [retval][out] */ IEnumCodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);


void __RPC_STUB ICodeStoreDBEntry_EnumChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_GetParent_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppParent);


void __RPC_STUB ICodeStoreDBEntry_GetParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_GetProperty_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty);


void __RPC_STUB ICodeStoreDBEntry_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_SetProperty_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty);


void __RPC_STUB ICodeStoreDBEntry_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_DeleteProperty_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszName);


void __RPC_STUB ICodeStoreDBEntry_DeleteProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_GetDWORDPropertyA_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [out] */ DWORD __RPC_FAR *pVal);


void __RPC_STUB ICodeStoreDBEntry_GetDWORDPropertyA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_SetDWORDPropertyA_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD dwVal);


void __RPC_STUB ICodeStoreDBEntry_SetDWORDPropertyA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_GetStringPropertyA_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [out] */ LPSTR pszVal,
    /* [in] */ DWORD cbVal);


void __RPC_STUB ICodeStoreDBEntry_GetStringPropertyA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_SetStringPropertyA_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [in] */ LPCSTR pszVal);


void __RPC_STUB ICodeStoreDBEntry_SetStringPropertyA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICodeStoreDBEntry_INTERFACE_DEFINED__ */


#ifndef __ICodeStoreDB_INTERFACE_DEFINED__
#define __ICodeStoreDB_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICodeStoreDB
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_ICodeStoreDB;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICodeStoreDB : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateEntry( 
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveEntry( 
            /* [in] */ LPCOLESTR pszName,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEntry( 
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRootEntries( 
            /* [retval][out] */ IEnumCodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICodeStoreDBVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICodeStoreDB __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICodeStoreDB __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICodeStoreDB __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateEntry )( 
            ICodeStoreDB __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveEntry )( 
            ICodeStoreDB __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszName,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEntry )( 
            ICodeStoreDB __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumRootEntries )( 
            ICodeStoreDB __RPC_FAR * This,
            /* [retval][out] */ IEnumCodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);
        
        END_INTERFACE
    } ICodeStoreDBVtbl;

    interface ICodeStoreDB
    {
        CONST_VTBL struct ICodeStoreDBVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICodeStoreDB_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICodeStoreDB_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICodeStoreDB_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICodeStoreDB_CreateEntry(This,pszName,ppEntry)	\
    (This)->lpVtbl -> CreateEntry(This,pszName,ppEntry)

#define ICodeStoreDB_RemoveEntry(This,pszName,dwFlags)	\
    (This)->lpVtbl -> RemoveEntry(This,pszName,dwFlags)

#define ICodeStoreDB_GetEntry(This,pszName,ppEntry)	\
    (This)->lpVtbl -> GetEntry(This,pszName,ppEntry)

#define ICodeStoreDB_EnumRootEntries(This,ppEntry)	\
    (This)->lpVtbl -> EnumRootEntries(This,ppEntry)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICodeStoreDB_CreateEntry_Proxy( 
    ICodeStoreDB __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszName,
    /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);


void __RPC_STUB ICodeStoreDB_CreateEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDB_RemoveEntry_Proxy( 
    ICodeStoreDB __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszName,
    DWORD dwFlags);


void __RPC_STUB ICodeStoreDB_RemoveEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDB_GetEntry_Proxy( 
    ICodeStoreDB __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszName,
    /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);


void __RPC_STUB ICodeStoreDB_GetEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDB_EnumRootEntries_Proxy( 
    ICodeStoreDB __RPC_FAR * This,
    /* [retval][out] */ IEnumCodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);


void __RPC_STUB ICodeStoreDB_EnumRootEntries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICodeStoreDB_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CLSID_CodeStoreDB;

class CLSID_CodeStoreDB;
#endif

#ifndef __IJavaPackageManager_INTERFACE_DEFINED__
#define __IJavaPackageManager_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaPackageManager
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IJavaPackageManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaPackageManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InstallPackage( 
            /* [in] */ LPCOLESTR pszFileName,
            /* [in] */ LPCOLESTR pszNamespace,
            /* [in] */ DWORD dwFileType,
            /* [out][in] */ LPPACKAGEINSTALLINFO pPackageInfo,
            /* [in] */ UINT cPackages,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCPACKAGESECURITYINFO pSecurityInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UninstallPackage( 
            /* [in] */ LPCOLESTR pszPackageName,
            /* [in] */ LPCOLESTR pszNamespace,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumPackages( 
            /* [in] */ LPCOLESTR pszNamespace,
            /* [retval][out] */ IEnumJavaPackage __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPackage( 
            /* [in] */ LPCOLESTR pszPackageName,
            /* [in] */ LPCOLESTR pszNamespace,
            /* [retval][out] */ IJavaPackage __RPC_FAR *__RPC_FAR *ppPackage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFile( 
            /* [in] */ LPCOLESTR pszFileName,
            /* [in] */ LPCOLESTR pszNamespace,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IJavaFile __RPC_FAR *__RPC_FAR *ppFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExplicitClassPath( 
            /* [out] */ BSTR __RPC_FAR *pbstrPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExplicitClassPath( 
            /* [in] */ LPCOLESTR pszPath,
            /* [in] */ BOOL fAppend) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCurrentDirectory( 
            /* [in] */ LPCOLESTR pszDir) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaPackageManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaPackageManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaPackageManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaPackageManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallPackage )( 
            IJavaPackageManager __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszFileName,
            /* [in] */ LPCOLESTR pszNamespace,
            /* [in] */ DWORD dwFileType,
            /* [out][in] */ LPPACKAGEINSTALLINFO pPackageInfo,
            /* [in] */ UINT cPackages,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCPACKAGESECURITYINFO pSecurityInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UninstallPackage )( 
            IJavaPackageManager __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszPackageName,
            /* [in] */ LPCOLESTR pszNamespace,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumPackages )( 
            IJavaPackageManager __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszNamespace,
            /* [retval][out] */ IEnumJavaPackage __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPackage )( 
            IJavaPackageManager __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszPackageName,
            /* [in] */ LPCOLESTR pszNamespace,
            /* [retval][out] */ IJavaPackage __RPC_FAR *__RPC_FAR *ppPackage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFile )( 
            IJavaPackageManager __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszFileName,
            /* [in] */ LPCOLESTR pszNamespace,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IJavaFile __RPC_FAR *__RPC_FAR *ppFile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExplicitClassPath )( 
            IJavaPackageManager __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrPath);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetExplicitClassPath )( 
            IJavaPackageManager __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszPath,
            /* [in] */ BOOL fAppend);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCurrentDirectory )( 
            IJavaPackageManager __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszDir);
        
        END_INTERFACE
    } IJavaPackageManagerVtbl;

    interface IJavaPackageManager
    {
        CONST_VTBL struct IJavaPackageManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaPackageManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaPackageManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaPackageManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaPackageManager_InstallPackage(This,pszFileName,pszNamespace,dwFileType,pPackageInfo,cPackages,dwFlags,pSecurityInfo)	\
    (This)->lpVtbl -> InstallPackage(This,pszFileName,pszNamespace,dwFileType,pPackageInfo,cPackages,dwFlags,pSecurityInfo)

#define IJavaPackageManager_UninstallPackage(This,pszPackageName,pszNamespace,dwFlags)	\
    (This)->lpVtbl -> UninstallPackage(This,pszPackageName,pszNamespace,dwFlags)

#define IJavaPackageManager_EnumPackages(This,pszNamespace,ppEnum)	\
    (This)->lpVtbl -> EnumPackages(This,pszNamespace,ppEnum)

#define IJavaPackageManager_GetPackage(This,pszPackageName,pszNamespace,ppPackage)	\
    (This)->lpVtbl -> GetPackage(This,pszPackageName,pszNamespace,ppPackage)

#define IJavaPackageManager_GetFile(This,pszFileName,pszNamespace,dwFlags,ppFile)	\
    (This)->lpVtbl -> GetFile(This,pszFileName,pszNamespace,dwFlags,ppFile)

#define IJavaPackageManager_GetExplicitClassPath(This,pbstrPath)	\
    (This)->lpVtbl -> GetExplicitClassPath(This,pbstrPath)

#define IJavaPackageManager_SetExplicitClassPath(This,pszPath,fAppend)	\
    (This)->lpVtbl -> SetExplicitClassPath(This,pszPath,fAppend)

#define IJavaPackageManager_SetCurrentDirectory(This,pszDir)	\
    (This)->lpVtbl -> SetCurrentDirectory(This,pszDir)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaPackageManager_InstallPackage_Proxy( 
    IJavaPackageManager __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszFileName,
    /* [in] */ LPCOLESTR pszNamespace,
    /* [in] */ DWORD dwFileType,
    /* [out][in] */ LPPACKAGEINSTALLINFO pPackageInfo,
    /* [in] */ UINT cPackages,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCPACKAGESECURITYINFO pSecurityInfo);


void __RPC_STUB IJavaPackageManager_InstallPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackageManager_UninstallPackage_Proxy( 
    IJavaPackageManager __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszPackageName,
    /* [in] */ LPCOLESTR pszNamespace,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IJavaPackageManager_UninstallPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackageManager_EnumPackages_Proxy( 
    IJavaPackageManager __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszNamespace,
    /* [retval][out] */ IEnumJavaPackage __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IJavaPackageManager_EnumPackages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackageManager_GetPackage_Proxy( 
    IJavaPackageManager __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszPackageName,
    /* [in] */ LPCOLESTR pszNamespace,
    /* [retval][out] */ IJavaPackage __RPC_FAR *__RPC_FAR *ppPackage);


void __RPC_STUB IJavaPackageManager_GetPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackageManager_GetFile_Proxy( 
    IJavaPackageManager __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszFileName,
    /* [in] */ LPCOLESTR pszNamespace,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IJavaFile __RPC_FAR *__RPC_FAR *ppFile);


void __RPC_STUB IJavaPackageManager_GetFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackageManager_GetExplicitClassPath_Proxy( 
    IJavaPackageManager __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrPath);


void __RPC_STUB IJavaPackageManager_GetExplicitClassPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackageManager_SetExplicitClassPath_Proxy( 
    IJavaPackageManager __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszPath,
    /* [in] */ BOOL fAppend);


void __RPC_STUB IJavaPackageManager_SetExplicitClassPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackageManager_SetCurrentDirectory_Proxy( 
    IJavaPackageManager __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszDir);


void __RPC_STUB IJavaPackageManager_SetCurrentDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaPackageManager_INTERFACE_DEFINED__ */


#ifndef __IJavaPackage_INTERFACE_DEFINED__
#define __IJavaPackage_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaPackage
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IJavaPackage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaPackage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPackageName( 
            /* [out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [out] */ DWORD __RPC_FAR *pdwVersionMS,
            /* [out] */ DWORD __RPC_FAR *pdwVersionLS) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilePath( 
            /* [out] */ BSTR __RPC_FAR *pbstrPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSystemClass( 
            /* [out] */ BOOL __RPC_FAR *pfIsSystemClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NeedsTrustedSource( 
            /* [out] */ BOOL __RPC_FAR *pfNeedsTrustedSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCapabilities( 
            /* [out] */ LPCBYTE __RPC_FAR *ppCapabilities,
            /* [out] */ DWORD __RPC_FAR *pcbCapabilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSigner( 
            /* [out] */ LPCBYTE __RPC_FAR *ppSigner,
            /* [out] */ DWORD __RPC_FAR *pcbSigner) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDatabaseEntry( 
            /* [out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumFiles( 
            /* [in] */ DWORD dwFlags,
            /* [retval][out] */ IEnumJavaFile __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilePathA( 
            /* [out] */ LPSTR pszPath,
            /* [in] */ DWORD cbPath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaPackageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaPackage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaPackage __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaPackage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPackageName )( 
            IJavaPackage __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVersion )( 
            IJavaPackage __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwVersionMS,
            /* [out] */ DWORD __RPC_FAR *pdwVersionLS);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFilePath )( 
            IJavaPackage __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrPath);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsSystemClass )( 
            IJavaPackage __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfIsSystemClass);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NeedsTrustedSource )( 
            IJavaPackage __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfNeedsTrustedSource);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCapabilities )( 
            IJavaPackage __RPC_FAR * This,
            /* [out] */ LPCBYTE __RPC_FAR *ppCapabilities,
            /* [out] */ DWORD __RPC_FAR *pcbCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSigner )( 
            IJavaPackage __RPC_FAR * This,
            /* [out] */ LPCBYTE __RPC_FAR *ppSigner,
            /* [out] */ DWORD __RPC_FAR *pcbSigner);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDatabaseEntry )( 
            IJavaPackage __RPC_FAR * This,
            /* [out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumFiles )( 
            IJavaPackage __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [retval][out] */ IEnumJavaFile __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFilePathA )( 
            IJavaPackage __RPC_FAR * This,
            /* [out] */ LPSTR pszPath,
            /* [in] */ DWORD cbPath);
        
        END_INTERFACE
    } IJavaPackageVtbl;

    interface IJavaPackage
    {
        CONST_VTBL struct IJavaPackageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaPackage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaPackage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaPackage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaPackage_GetPackageName(This,pbstrName)	\
    (This)->lpVtbl -> GetPackageName(This,pbstrName)

#define IJavaPackage_GetVersion(This,pdwVersionMS,pdwVersionLS)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersionMS,pdwVersionLS)

#define IJavaPackage_GetFilePath(This,pbstrPath)	\
    (This)->lpVtbl -> GetFilePath(This,pbstrPath)

#define IJavaPackage_IsSystemClass(This,pfIsSystemClass)	\
    (This)->lpVtbl -> IsSystemClass(This,pfIsSystemClass)

#define IJavaPackage_NeedsTrustedSource(This,pfNeedsTrustedSource)	\
    (This)->lpVtbl -> NeedsTrustedSource(This,pfNeedsTrustedSource)

#define IJavaPackage_GetCapabilities(This,ppCapabilities,pcbCapabilities)	\
    (This)->lpVtbl -> GetCapabilities(This,ppCapabilities,pcbCapabilities)

#define IJavaPackage_GetSigner(This,ppSigner,pcbSigner)	\
    (This)->lpVtbl -> GetSigner(This,ppSigner,pcbSigner)

#define IJavaPackage_GetDatabaseEntry(This,ppEntry)	\
    (This)->lpVtbl -> GetDatabaseEntry(This,ppEntry)

#define IJavaPackage_EnumFiles(This,dwFlags,ppEnum)	\
    (This)->lpVtbl -> EnumFiles(This,dwFlags,ppEnum)

#define IJavaPackage_GetFilePathA(This,pszPath,cbPath)	\
    (This)->lpVtbl -> GetFilePathA(This,pszPath,cbPath)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaPackage_GetPackageName_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB IJavaPackage_GetPackageName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackage_GetVersion_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwVersionMS,
    /* [out] */ DWORD __RPC_FAR *pdwVersionLS);


void __RPC_STUB IJavaPackage_GetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackage_GetFilePath_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrPath);


void __RPC_STUB IJavaPackage_GetFilePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackage_IsSystemClass_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfIsSystemClass);


void __RPC_STUB IJavaPackage_IsSystemClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackage_NeedsTrustedSource_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfNeedsTrustedSource);


void __RPC_STUB IJavaPackage_NeedsTrustedSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackage_GetCapabilities_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [out] */ LPCBYTE __RPC_FAR *ppCapabilities,
    /* [out] */ DWORD __RPC_FAR *pcbCapabilities);


void __RPC_STUB IJavaPackage_GetCapabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackage_GetSigner_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [out] */ LPCBYTE __RPC_FAR *ppSigner,
    /* [out] */ DWORD __RPC_FAR *pcbSigner);


void __RPC_STUB IJavaPackage_GetSigner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackage_GetDatabaseEntry_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);


void __RPC_STUB IJavaPackage_GetDatabaseEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackage_EnumFiles_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [retval][out] */ IEnumJavaFile __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IJavaPackage_EnumFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackage_GetFilePathA_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [out] */ LPSTR pszPath,
    /* [in] */ DWORD cbPath);


void __RPC_STUB IJavaPackage_GetFilePathA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaPackage_INTERFACE_DEFINED__ */


#ifndef __ICreateJavaPackageMgr_INTERFACE_DEFINED__
#define __ICreateJavaPackageMgr_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICreateJavaPackageMgr
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ICreateJavaPackageMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICreateJavaPackageMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPackageManager( 
            /* [out] */ IJavaPackageManager __RPC_FAR *__RPC_FAR *ppPackageMgr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICreateJavaPackageMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICreateJavaPackageMgr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICreateJavaPackageMgr __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICreateJavaPackageMgr __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPackageManager )( 
            ICreateJavaPackageMgr __RPC_FAR * This,
            /* [out] */ IJavaPackageManager __RPC_FAR *__RPC_FAR *ppPackageMgr);
        
        END_INTERFACE
    } ICreateJavaPackageMgrVtbl;

    interface ICreateJavaPackageMgr
    {
        CONST_VTBL struct ICreateJavaPackageMgrVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICreateJavaPackageMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICreateJavaPackageMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICreateJavaPackageMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICreateJavaPackageMgr_GetPackageManager(This,ppPackageMgr)	\
    (This)->lpVtbl -> GetPackageManager(This,ppPackageMgr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICreateJavaPackageMgr_GetPackageManager_Proxy( 
    ICreateJavaPackageMgr __RPC_FAR * This,
    /* [out] */ IJavaPackageManager __RPC_FAR *__RPC_FAR *ppPackageMgr);


void __RPC_STUB ICreateJavaPackageMgr_GetPackageManager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICreateJavaPackageMgr_INTERFACE_DEFINED__ */


#ifndef __IJavaFile_INTERFACE_DEFINED__
#define __IJavaFile_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaFile
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IJavaFile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaFile : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ DWORD dwType,
            /* [out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetFlags( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileStream( 
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPENativePath( 
            /* [out] */ BSTR __RPC_FAR *pbstrPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPENativePathA( 
            /* [out] */ LPSTR pszPath,
            /* [in] */ DWORD cbPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimestamp( 
            /* [out] */ DWORD __RPC_FAR *pdwTimestamp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaFileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaFile __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaFile __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaFile __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IJavaFile __RPC_FAR * This,
            /* [in] */ DWORD dwType,
            /* [out] */ BSTR __RPC_FAR *pbstrName);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )( 
            IJavaFile __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFileStream )( 
            IJavaFile __RPC_FAR * This,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPENativePath )( 
            IJavaFile __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrPath);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPENativePathA )( 
            IJavaFile __RPC_FAR * This,
            /* [out] */ LPSTR pszPath,
            /* [in] */ DWORD cbPath);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTimestamp )( 
            IJavaFile __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwTimestamp);
        
        END_INTERFACE
    } IJavaFileVtbl;

    interface IJavaFile
    {
        CONST_VTBL struct IJavaFileVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaFile_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaFile_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaFile_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaFile_GetName(This,dwType,pbstrName)	\
    (This)->lpVtbl -> GetName(This,dwType,pbstrName)

#define IJavaFile_GetFlags(This)	\
    (This)->lpVtbl -> GetFlags(This)

#define IJavaFile_GetFileStream(This,ppStream)	\
    (This)->lpVtbl -> GetFileStream(This,ppStream)

#define IJavaFile_GetPENativePath(This,pbstrPath)	\
    (This)->lpVtbl -> GetPENativePath(This,pbstrPath)

#define IJavaFile_GetPENativePathA(This,pszPath,cbPath)	\
    (This)->lpVtbl -> GetPENativePathA(This,pszPath,cbPath)

#define IJavaFile_GetTimestamp(This,pdwTimestamp)	\
    (This)->lpVtbl -> GetTimestamp(This,pdwTimestamp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaFile_GetName_Proxy( 
    IJavaFile __RPC_FAR * This,
    /* [in] */ DWORD dwType,
    /* [out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB IJavaFile_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IJavaFile_GetFlags_Proxy( 
    IJavaFile __RPC_FAR * This);


void __RPC_STUB IJavaFile_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaFile_GetFileStream_Proxy( 
    IJavaFile __RPC_FAR * This,
    /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream);


void __RPC_STUB IJavaFile_GetFileStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaFile_GetPENativePath_Proxy( 
    IJavaFile __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrPath);


void __RPC_STUB IJavaFile_GetPENativePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaFile_GetPENativePathA_Proxy( 
    IJavaFile __RPC_FAR * This,
    /* [out] */ LPSTR pszPath,
    /* [in] */ DWORD cbPath);


void __RPC_STUB IJavaFile_GetPENativePathA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaFile_GetTimestamp_Proxy( 
    IJavaFile __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwTimestamp);


void __RPC_STUB IJavaFile_GetTimestamp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaFile_INTERFACE_DEFINED__ */


#ifndef __IEnumJavaPackage_INTERFACE_DEFINED__
#define __IEnumJavaPackage_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumJavaPackage
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IEnumJavaPackage __RPC_FAR *LPENUMJAVAPACKAGE;


EXTERN_C const IID IID_IEnumJavaPackage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumJavaPackage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IJavaPackage __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumJavaPackage __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumJavaPackageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumJavaPackage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumJavaPackage __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumJavaPackage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumJavaPackage __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IJavaPackage __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumJavaPackage __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumJavaPackage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumJavaPackage __RPC_FAR * This,
            /* [out] */ IEnumJavaPackage __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumJavaPackageVtbl;

    interface IEnumJavaPackage
    {
        CONST_VTBL struct IEnumJavaPackageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumJavaPackage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumJavaPackage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumJavaPackage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumJavaPackage_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumJavaPackage_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumJavaPackage_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumJavaPackage_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumJavaPackage_Next_Proxy( 
    IEnumJavaPackage __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IJavaPackage __RPC_FAR *__RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumJavaPackage_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumJavaPackage_Skip_Proxy( 
    IEnumJavaPackage __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumJavaPackage_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumJavaPackage_Reset_Proxy( 
    IEnumJavaPackage __RPC_FAR * This);


void __RPC_STUB IEnumJavaPackage_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumJavaPackage_Clone_Proxy( 
    IEnumJavaPackage __RPC_FAR * This,
    /* [out] */ IEnumJavaPackage __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumJavaPackage_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumJavaPackage_INTERFACE_DEFINED__ */


#ifndef __IEnumJavaFile_INTERFACE_DEFINED__
#define __IEnumJavaFile_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumJavaFile
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IEnumJavaFile __RPC_FAR *LPENUMJAVAFILE;


EXTERN_C const IID IID_IEnumJavaFile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumJavaFile : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IJavaFile __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumJavaFile __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumJavaFileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumJavaFile __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumJavaFile __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumJavaFile __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumJavaFile __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IJavaFile __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumJavaFile __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumJavaFile __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumJavaFile __RPC_FAR * This,
            /* [out] */ IEnumJavaFile __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumJavaFileVtbl;

    interface IEnumJavaFile
    {
        CONST_VTBL struct IEnumJavaFileVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumJavaFile_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumJavaFile_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumJavaFile_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumJavaFile_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumJavaFile_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumJavaFile_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumJavaFile_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumJavaFile_Next_Proxy( 
    IEnumJavaFile __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IJavaFile __RPC_FAR *__RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumJavaFile_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumJavaFile_Skip_Proxy( 
    IEnumJavaFile __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumJavaFile_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumJavaFile_Reset_Proxy( 
    IEnumJavaFile __RPC_FAR * This);


void __RPC_STUB IEnumJavaFile_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumJavaFile_Clone_Proxy( 
    IEnumJavaFile __RPC_FAR * This,
    /* [out] */ IEnumJavaFile __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumJavaFile_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumJavaFile_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CLSID_JavaPackageManager;

class CLSID_JavaPackageManager;
#endif
#endif /* __JPKGMGR_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\poclass.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    poclass.h

Abstract:

    Defines power policy device driver interfaces.

Author:

    Ken Reneris (kenr) 02-Feb-1997

Revision History:

--*/

//
// Power management policy device GUIDs
//

DEFINE_GUID( GUID_DEVICE_BATTERY,           0x72631e54L, 0x78A4, 0x11d0, 0xbc, 0xf7, 0x00, 0xaa, 0x00, 0xb7, 0xb3, 0x2a );
DEFINE_GUID( GUID_DEVICE_SYS_BUTTON,        0x4AFA3D53L, 0x74A7, 0x11d0, 0xbe, 0x5e, 0x00, 0xA0, 0xC9, 0x06, 0x28, 0x57 );
DEFINE_GUID( GUID_DEVICE_LID,               0x4AFA3D52L, 0x74A7, 0x11d0, 0xbe, 0x5e, 0x00, 0xA0, 0xC9, 0x06, 0x28, 0x57 );
DEFINE_GUID( GUID_DEVICE_THERMAL_ZONE,      0x4AFA3D51L, 0x74A7, 0x11d0, 0xbe, 0x5e, 0x00, 0xA0, 0xC9, 0x06, 0x28, 0x57 );
DEFINE_GUID( GUID_DEVICE_PROCESSOR,         0x97fadb10L, 0x4e33, 0x40ae, 0x35, 0x9c, 0x8b, 0xef, 0x02, 0x9d, 0xbd, 0xd0 );
DEFINE_GUID( GUID_DEVICE_MEMORY,            0x3fd0f03dL, 0x92e0, 0x45fb, 0xb7, 0x5c, 0x5e, 0xd8, 0xff, 0xb0, 0x10, 0x21 );
DEFINE_GUID( GUID_DEVICE_MESSAGE_INDICATOR, 0XCD48A365L, 0xfa94, 0x4ce2, 0xa2, 0x32, 0xa1, 0xb7, 0x64, 0xe5, 0xd8, 0xb4 );
// copied from hidclass.h
DEFINE_GUID( GUID_CLASS_INPUT,              0x4D1E55B2L, 0xF16F, 0x11CF, 0x88, 0xCB, 0x00, 0x11, 0x11, 0x00, 0x00, 0x30 );

#ifndef _POCLASS_
#define _POCLASS_

//
// Battery driver interface (devices of registrying as GUID_DEVICE_BATTERY)
//

typedef enum {
    BatteryInformation,
    BatteryGranularityInformation,
    BatteryTemperature,
    BatteryEstimatedTime,
    BatteryDeviceName,
    BatteryManufactureDate,
    BatteryManufactureName,
    BatteryUniqueID
} BATTERY_QUERY_INFORMATION_LEVEL;

typedef struct _BATTERY_QUERY_INFORMATION {
    ULONG                           BatteryTag;
    BATTERY_QUERY_INFORMATION_LEVEL InformationLevel;
    ULONG                           AtRate;
} BATTERY_QUERY_INFORMATION, *PBATTERY_QUERY_INFORMATION;

typedef struct _BATTERY_INFORMATION {
    ULONG       Capabilities;
    UCHAR       Technology;
    UCHAR       Reserved[3];
    UCHAR       Chemistry[4];
    ULONG       DesignedCapacity;
    ULONG       FullChargedCapacity;
    ULONG       DefaultAlert1;
    ULONG       DefaultAlert2;
    ULONG       CriticalBias;
    ULONG       CycleCount;
} BATTERY_INFORMATION, *PBATTERY_INFORMATION;

// BATTERY_INFORMATION.*Capacity constants
#define UNKNOWN_CAPACITY            0xFFFFFFFF

// BATTERY_INFORMATION.Capabilities flags
#define BATTERY_SYSTEM_BATTERY          0x80000000
#define BATTERY_CAPACITY_RELATIVE       0x40000000
#define BATTERY_IS_SHORT_TERM           0x20000000
#define BATTERY_SET_CHARGE_SUPPORTED    0x00000001
#define BATTERY_SET_DISCHARGE_SUPPORTED 0x00000002
#define BATTERY_SET_RESUME_SUPPORTED    0x00000004

typedef enum {
    BatteryCriticalBias,
    BatteryCharge,
    BatteryDischarge
} BATTERY_SET_INFORMATION_LEVEL;

typedef struct _BATTERY_SET_INFORMATION {
    ULONG                         BatteryTag;
    BATTERY_SET_INFORMATION_LEVEL InformationLevel;
    UCHAR                         Buffer[1];
} BATTERY_SET_INFORMATION, *PBATTERY_SET_INFORMATION;

typedef struct _BATTERY_WAIT_STATUS {
    ULONG       BatteryTag;
    ULONG       Timeout;
    ULONG       PowerState;
    ULONG       LowCapacity;
    ULONG       HighCapacity;
} BATTERY_WAIT_STATUS, *PBATTERY_WAIT_STATUS;

typedef struct _BATTERY_STATUS {
    ULONG       PowerState;
    ULONG       Capacity;
    ULONG       Voltage;
    LONG        Current;
} BATTERY_STATUS, *PBATTERY_STATUS;

// Battery Status Constants
#define UNKNOWN_RATE                0xFFFFFFFF
#define UNKNOWN_VOLTAGE             0xFFFFFFFF


// PowerState flags

#define BATTERY_POWER_ON_LINE   0x00000001
#define BATTERY_DISCHARGING     0x00000002
#define BATTERY_CHARGING        0x00000004
#define BATTERY_CRITICAL        0x00000008

// Max battery driver BATTERY_QUERY_INFORMATION_LEVEL string storage
// size in bytes.
#define MAX_BATTERY_STRING_SIZE 128

// Struct for accessing the packed date format in BatteryManufactureDate.
typedef struct _BATTERY_MANUFACTURE_DATE
{
    UCHAR   Day;
    UCHAR   Month;
    USHORT  Year;
} BATTERY_MANUFACTURE_DATE, *PBATTERY_MANUFACTURE_DATE;

// battery

#define IOCTL_BATTERY_QUERY_TAG         \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x10, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_BATTERY_QUERY_INFORMATION \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x11, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_BATTERY_SET_INFORMATION   \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x12, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_BATTERY_QUERY_STATUS      \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x13, METHOD_BUFFERED, FILE_READ_ACCESS)

#define BATTERY_TAG_INVALID     0

#ifndef _WINDOWS_

//
// Battery Class-Miniport interfaces
//

typedef
NTSTATUS
(*BCLASS_QUERY_TAG)(
    IN PVOID Context,
    OUT PULONG BatteryTag
    );

typedef
NTSTATUS
(*BCLASS_QUERY_INFORMATION)(
    IN PVOID Context,
    IN ULONG BatteryTag,
    IN BATTERY_QUERY_INFORMATION_LEVEL Level,
    IN ULONG AtRate OPTIONAL,
    OUT PVOID Buffer,
    IN  ULONG BufferLength,
    OUT PULONG ReturnedLength
    );

typedef
NTSTATUS
(*BCLASS_QUERY_STATUS)(
    IN PVOID Context,
    IN ULONG BatteryTag,
    OUT PBATTERY_STATUS BatteryStatus
    );

typedef struct {
    ULONG                   PowerState;
    ULONG                   LowCapacity;
    ULONG                   HighCapacity;
} BATTERY_NOTIFY, *PBATTERY_NOTIFY;

typedef
NTSTATUS
(*BCLASS_SET_STATUS_NOTIFY)(
    IN PVOID Context,
    IN ULONG BatteryTag,
    IN PBATTERY_NOTIFY BatteryNotify
    );

typedef
NTSTATUS
(*BCLASS_SET_INFORMATION)(
    IN PVOID Context,
    IN ULONG BatteryTag,
    IN BATTERY_SET_INFORMATION_LEVEL Level,
    IN PVOID Buffer OPTIONAL
    );

typedef
NTSTATUS
(*BCLASS_DISABLE_STATUS_NOTIFY)(
    IN PVOID Context
    );


typedef struct {
    USHORT                          MajorVersion;
    USHORT                          MinorVersion;

    PVOID                           Context;        // Miniport context

    BCLASS_QUERY_TAG                QueryTag;
    BCLASS_QUERY_INFORMATION        QueryInformation;
    BCLASS_SET_INFORMATION          SetInformation;
    BCLASS_QUERY_STATUS             QueryStatus;
    BCLASS_SET_STATUS_NOTIFY        SetStatusNotify;
    BCLASS_DISABLE_STATUS_NOTIFY    DisableStatusNotify;
    PDEVICE_OBJECT                  Pdo;
    PUNICODE_STRING                 DeviceName;
} BATTERY_MINIPORT_INFO, *PBATTERY_MINIPORT_INFO;



#define BATTERY_CLASS_MAJOR_VERSION     0x0001
#define BATTERY_CLASS_MINOR_VERSION     0x0000


//
// Battery class driver functions
//

#if !defined(BATTERYCLASS)
    #define BATTERYCLASSAPI DECLSPEC_IMPORT
#else
    #define BATTERYCLASSAPI
#endif


NTSTATUS
BATTERYCLASSAPI
BatteryClassInitializeDevice (
    IN PBATTERY_MINIPORT_INFO MiniportInfo,
    IN PVOID *ClassData
    );

NTSTATUS
BATTERYCLASSAPI
BatteryClassUnload (
    IN PVOID ClassData
    );

NTSTATUS
BATTERYCLASSAPI
BatteryClassIoctl (
    IN PVOID ClassData,
    IN PIRP Irp
    );

NTSTATUS
BATTERYCLASSAPI
BatteryClassStatusNotify (
    IN PVOID ClassData
    );

#endif // _WINDOWS_

//
// Thermal Zone driver interface (devices of registrying as GUID_DEVICE_THERMAL_ZONE)
//

#define MAX_ACTIVE_COOLING_LEVELS       10

typedef struct _THERMAL_INFORMATION {
    ULONG           ThermalStamp;
    ULONG           ThermalConstant1;
    ULONG           ThermalConstant2;
    KAFFINITY       Processors;
    ULONG           SamplingPeriod;
    ULONG           CurrentTemperature;
    ULONG           PassiveTripPoint;
    ULONG           CriticalTripPoint;
    UCHAR           ActiveTripPointCount;
    ULONG           ActiveTripPoint[MAX_ACTIVE_COOLING_LEVELS];
} THERMAL_INFORMATION, *PTHERMAL_INFORMATION;

#define ACTIVE_COOLING          0x0
#define PASSIVE_COOLING         0x1

// thermal

#define IOCTL_THERMAL_QUERY_INFORMATION \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x20, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_THERMAL_SET_COOLING_POLICY\
        CTL_CODE(FILE_DEVICE_BATTERY, 0x21, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_RUN_ACTIVE_COOLING_METHOD\
        CTL_CODE(FILE_DEVICE_BATTERY, 0x22, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// Lid class driver functions
//

#define IOCTL_QUERY_LID\
        CTL_CODE(FILE_DEVICE_BATTERY, 0x30, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// Switch class driver functions
//

#define IOCTL_NOTIFY_SWITCH_EVENT\
        CTL_CODE(FILE_DEVICE_BATTERY, 0x40, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// System button class driver functions
//

#define IOCTL_GET_SYS_BUTTON_CAPS       \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x50, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_GET_SYS_BUTTON_EVENT      \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x51, METHOD_BUFFERED, FILE_READ_ACCESS)

#define SYS_BUTTON_POWER        0x00000001
#define SYS_BUTTON_SLEEP        0x00000002
#define SYS_BUTTON_LID          0x00000004
#define SYS_BUTTON_WAKE         0x80000000

//
// Processor object class driver functions
//

typedef struct {
    ULONG   PhysicalID;
    ULONG   PBlkAddress;
    UCHAR   PBlkLength;
} PROCESSOR_OBJECT_INFO, *PPROCESSOR_OBJECT_INFO;

#define IOCTL_GET_PROCESSOR_OBJ_INFO        \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x60, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// Message indicator class driver functions
//
#define IOCTL_SET_SYS_MESSAGE_INDICATOR     \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x70, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#endif // _POCLASS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\polarity.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    POLARITY.H

Abstract:

    properly map __declspec( dllexport ) or import

History:

--*/

#if _MSC_VER > 1000
#pragma once
#endif

// If we are building the DLL then define the 
// class as exported otherwise as imported
// ============================================
#ifndef POLARITY_HEADERFILE_IS_INCLUDED
#define POLARITY_HEADERFILE_IS_INCLUDED
//#pragma message( "Including Polarity.h..." )

 #ifdef USE_POLARITY
  #ifdef BUILDING_DLL
//   #pragma message( "Building static library or DLL..." )
   #define POLARITY __declspec( dllexport )
  #else 
//   #pragma message( "Building Provider..." )
   #define POLARITY __declspec( dllimport )
  #endif
 #else
  #define POLARITY
//  #pragma message( "NO Polarity...")
 #endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\poppack.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/

#if ! (defined(lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 && !defined(_M_I86)) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(pop)
#else
#pragma pack()
#endif
#else
#pragma pack()
#endif
#endif // ! (defined(lint) || defined(RC_INVOKED))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\ppcinst.h ===
/*++

Copyright (c) 1993  IBM Corporation

Module Name:

    ppcinst.h

Abstract:

    PowerPC instruction and floating constant definitions.

Author:

    Rick Simpson   30 July 1993

Revision History:

--*/

#ifndef _PPCINST_
#define _PPCINST_
#if _MSC_VER > 1000
#pragma once
#endif


//
//     POWERPC INSTRUCTION FORMAT STRUCTURES
//

typedef union _PPC_INSTRUCTION {
    ULONG Long;
    UCHAR Byte[4];

    struct {
        ULONG bit31   :  1;
        ULONG bit30   :  1;
	 LONG bit6_29 : 24;
	ULONG bit0_5  :  6;
    } i_f;

#define Primary_Op  i_f.bit0_5

#define Iform_LI  i_f.bit6_29
#define Iform_AA  i_f.bit30
#define Iform_LK  i_f.bit31

    struct {
        ULONG bit31    :  1;
        ULONG bit30    :  1;
	 LONG bit16_29 : 14;
	ULONG bit11_15 :  5;
	ULONG bit6_10  :  5;
        ULONG bit0_5   :  6;
    } b_f;

#define Bform_BO  b_f.bit6_10
#define Bform_BI  b_f.bit11_15
#define Bform_BD  b_f.bit16_29
#define Bform_AA  b_f.bit30
#define Bform_LK  b_f.bit31

    struct {
	ULONG bit31    :  1;
	ULONG bit30    :  1;
	ULONG bit6_29  : 24;
	ULONG bit0_5   :  6;
    } sc_f;

#define SCform_XO  sc_f.bit30

    struct {
	 LONG bit16_31 : 16;
	ULONG bit11_15 :  5;
	ULONG bit6_10  :  5;
	ULONG bit0_5   :  6;
    } d_f1;
    struct {
	ULONG bit16_31 : 16;
	ULONG bit11_15 :  5;
	ULONG bit10    :  1;
	ULONG bit9     :  1;
	ULONG bit6_8   :  3;
	ULONG bit0_5   :  6;
    } d_f2;

#define Dform_RT   d_f1.bit6_10
#define Dform_RS   d_f1.bit6_10
#define Dform_TO   d_f1.bit6_10
#define Dform_FRT  d_f1.bit6_10
#define Dform_FRS  d_f1.bit6_10
#define Dform_BF   d_f2.bit6_8
#define Dform_L    d_f2.bit10
#define Dform_RA   d_f1.bit11_15
#define Dform_D    d_f1.bit16_31
#define Dform_SI   d_f1.bit16_31
#define Dform_UI   d_f2.bit16_31

    struct {
	ULONG bit30_31 :  2;
	 LONG bit16_29 : 14;
	ULONG bit11_15 :  5;
	ULONG bit6_10  :  5;
	ULONG bit0_5   :  6;
    } ds_f;

#define DSform_RT  ds_f.bit6_10
#define DSform_RS  ds_f.bit6_10
#define DSform_RA  ds_f.bit11_15
#define DSform_DS  ds_f.bit16_29
#define DSform_XO  ds_f.bit30_31

    struct {
	ULONG bit31    :  1;
	ULONG bit21_30 : 10;
	ULONG bit16_20 :  5;
	ULONG bit11_15 :  5;
	ULONG bit6_10  :  5;
	ULONG bit0_5   :  6;
    } x_f1;
    struct {
	ULONG bit20_31 : 12;
	ULONG bit16_19 :  4;
	ULONG bit14_15 :  2;
	ULONG bit11_13 :  3;
	ULONG bit10    :  1;
	ULONG bit9     :  1;
	ULONG bit6_8   :  3;
	ULONG bit0_5   :  6;
    } x_f2;
    struct {
	ULONG bit16_31 : 16;
	ULONG bit12_15 :  4;
	ULONG bit0_11  : 12;
    } x_f3;

#define Xform_RT   x_f1.bit6_10
#define Xform_RS   x_f1.bit6_10
#define Xform_TO   x_f1.bit6_10
#define Xform_FRT  x_f1.bit6_10
#define Xform_FRS  x_f1.bit6_10
#define Xform_BT   x_f1.bit6_10
#define Xform_BF   x_f2.bit6_8
#define Xform_L    x_f2.bit10
#define Xform_RA   x_f1.bit11_15
#define Xform_FRA  x_f1.bit11_15
#define Xform_BFA  x_f2.bit11_13
#define Xform_SR   x_f3.bit12_15
#define Xform_RB   x_f1.bit16_20
#define Xform_NB   x_f1.bit16_20
#define Xform_SH   x_f1.bit16_20
#define Xform_FRB  x_f1.bit16_20
#define Xform_U    x_f2.bit16_19
#define Xform_XO   x_f1.bit21_30
#define Xform_RC   x_f1.bit31

    struct {
	ULONG bit31    :  1;
	ULONG bit21_30 : 10;
	ULONG bit16_20 :  5;
	ULONG bit11_15 :  5;
	ULONG bit6_10  :  5;
	ULONG bit0_5   :  6;
    } xl_f1;
    struct {
	ULONG bit14_31 : 18;
	ULONG bit11_13 :  3;
	ULONG bit9_10  :  2;
	ULONG bit6_8   :  3;
	ULONG bit0_5   :  6;
    } xl_f2;

#define XLform_LK   xl_f1.bit31
#define XLform_XO   xl_f1.bit21_30
#define XLform_BB   xl_f1.bit16_20
#define XLform_BA   xl_f1.bit11_15
#define XLform_BI   xl_f1.bit11_15
#define XLform_BFA  xl_f2.bit11_13
#define XLform_BT   xl_f1.bit6_10
#define XLform_BO   xl_f1.bit6_10
#define XLform_BF   xl_f2.bit6_8

    struct {
	ULONG bit31    :  1;
	ULONG bit21_30 : 10;
	ULONG bit11_20 : 10;
	ULONG bit6_10  :  5;
	ULONG bit0_5   :  6;
    } xfx_f1;
    struct {
	ULONG bit20_31 : 12;
	ULONG bit12_19 :  8;
	ULONG bit6_11  :  6;
	ULONG bit0_5   :  6;
    } xfx_f2;

#define XFXform_RT  xfx_f1.bit6_10
#define XFXform_RS  xfx_f1.bit6_10
#define XFXform_spr xfx_f1.bit11_20
#define XFXform_tbr xfx_f1.bit11_20
#define XFXform_spr xfx_f1.bit11_20
#define XFXform_FXM xfx_f2.bit12_19
#define XFXform_XO  xfx_f1.bit21_30

    struct {
	ULONG bit31    :  1;
	ULONG bit21_30 : 10;
	ULONG bit16_20 :  5;
	ULONG bit15    :  1;
	ULONG bit7_14  :  8;
	ULONG bit6     :  1;
	ULONG bit0_5   :  6;
    } xfl_f;

#define XFLform_FLM xfl_f.bit7_14
#define XFLform_FRB xfl_f.bit16_20
#define XFLform_XO  xfl_f.bit21_30
#define XFLform_RC  xfl_f.bit31

    struct {
	ULONG bit31    :  1;
	ULONG bit30    :  1;
	ULONG bit21_29 :  9;
	ULONG bit16_20 :  5;
	ULONG bit10_15 :  5;
	ULONG bit6_10  :  5;
	ULONG bit0_5   :  6;
    } xs_f;

#define XSform_RS  xs_f.bit6_10
#define XSform_RA  xs_f.bit11_15
#define XSform_sh1 xs_f.bit16_20
#define XSform_XO  xs_f.bit21_29
#define XSform_sh2 xs_f.bit30
#define XSform_RC  xs_f.bit31

    struct {
	ULONG bit31    :  1;
	ULONG bit22_30 :  9;
	ULONG bit21    :  1;
	ULONG bit16_20 :  5;
	ULONG bit10_15 :  5;
	ULONG bit6_10  :  5;
	ULONG bit0_5   :  6;
    } xo_f;

#define XOform_RT  xo_f.bit6_10
#define XOform_RA  xo_f.bit11_15
#define XOform_RB  xo_f.bit16_20
#define XOform_OE  xo_f.bit21
#define XOform_XO  xo_f.bit22_30
#define XOform_RC  xo_f.bit31

    struct {
	ULONG bit31    :  1;
	ULONG bit26_30 :  5;
	ULONG bit21_25 :  5;
	ULONG bit16_20 :  5;
	ULONG bit11_15 :  5;
	ULONG bit6_10  :  5;
	ULONG bit0_5   :  6;
    } a_f;

#define Aform_FRT  a_f.bit6_10
#define Aform_FRA  a_f.bit11_15
#define Aform_FRB  a_f.bit16_20
#define Aform_FRC  a_f.bit21_25
#define Aform_XO   a_f.bit26_30
#define Aform_RC   a_f.bit31

    struct {
	ULONG bit31    :  1;
	ULONG bit26_30 :  5;
	ULONG bit21_25 :  5;
	ULONG bit16_20 :  5;
	ULONG bit11_15 :  5;
	ULONG bit6_10  :  5;
	ULONG bit0_5   :  6;
    } m_f;

#define Mform_RS  m_f.bit6_10
#define Mform_RA  m_f.bit11_15
#define Mform_RB  m_f.bit16_20
#define Mform_SH  m_f.bit16_20
#define Mform_MB  m_f.bit21_25
#define Mform_ME  m_f.bit26_30
#define Mform_RC  m_f.bit31

    struct {
	ULONG bit31    :  1;
	ULONG bit30    :  1;
	ULONG bit27_29 :  3;
	ULONG bit21_26 :  6;
	ULONG bit16_20 :  5;
	ULONG bit11_15 :  5;
	ULONG bit6_10  :  5;
	ULONG bit0_5   :  6;
    } md_f;

#define MDform_RS   md_f.bit6_10
#define MDform_RA   md_f.bit11_15
#define MDform_sh1  md_f.bit16_20
#define MDform_mb   md_f.bit21_26
#define MDform_me   md_f.bit21_26
#define MDform_XO   md_f.bit27_29
#define MDform_sh2  md_f.bit30
#define MDform_RC   md_f.bit31

    struct {
	ULONG bit31    :  1;
	ULONG bit27_30 :  4;
	ULONG bit21_26 :  6;
	ULONG bit16_20 :  5;
	ULONG bit11_15 :  5;
	ULONG bit6_10  :  5;
	ULONG bit0_5   :  6;
    } mds_f;

#define MDSform_RS  mds_f.bit6_10
#define MDSform_RA  mds_f.bit11_15
#define MDSform_RB  mds_f.bit16_20
#define MDSform_mb  mds_f.bit21_26
#define MDSform_me  mds_f.bit21_26
#define MDSform_XO  mds_f.bit27_30
#define MDSform_RC  mds_f.bit31

} PPC_INSTRUCTION, *PPPC_INSTRUCTION;

//
//     POWERPC PRIMARY AND SECONDARY (EXTENDED) OPCODES
//

#define TDI_OP       2
#define TWI_OP       3
#define MULLI_OP     7
#define SUBFIC_OP    8
#define CMPLI_OP    10
#define CMPI_OP     11
#define ADDIC_OP    12
#define ADDIC_RC_OP 13
#define ADDI_OP     14
#define ADDIS_OP    15
#define BC_OP       16
#define SC_OP       17
#define B_OP        18

#define X19_OP      19    // Extended ops for primary code 19:
#define   MCRF_OP       0
#define   BCLR_OP      16
#define   CRNOR_OP     33
#define   RFI_OP       50
#define   CRANDC_OP   129
#define   ISYNC_OP    150
#define   CRXOR_OP    193
#define	  CRNAND_OP   225
#define	  CRAND_OP    257
#define	  CREQV_OP    289
#define	  CRORC_OP    417
#define	  CROR_OP     449
#define	  BCCTR_OP    528

#define RLWIMI_OP   20
#define RLWINM_OP   21
#define RLWNM_OP    23
#define ORI_OP      24
#define	ORIS_OP	    25
#define XORI_OP	    26
#define	XORIS_OP    27
#define	ANDI_RC_OP  28
#define ANDIS_RC_OP 29

#define X30_OP	    30    // Extended ops for primary code 30:
#define   RLDICL_OP     0
#define   RLDICR_OP	1
#define	  RLDIC_OP	2
#define	  RLDIMI_OP	3
#define   RLDCL_OP	8
#define   RLDCR_OP	9

#define X31_OP      31    // Extended ops for primary code 31:
#define   CMP_OP	0
#define	  TW_OP		4
#define	  SUBFC_OP	8
#define	  MULHDU_OP	9
#define	  ADDC_OP      10
#define	  MULHWU_OP    11
#define	  MFCR_OP      19
#define	  LWARX_OP     20
#define	  LDX_OP       21
#define	  LWZX_OP      23
#define	  SLW_OP       24
#define	  CNTLZW_OP    26
#define	  SLD_OP       27
#define	  AND_OP       28
#define	  CMPL_OP      32
#define	  SUBF_OP      40
#define	  LDUX_OP      53
#define	  DCBST_OP     54
#define	  LWZUX_OP     55
#define	  CNTLZD_OP    58
#define	  ANDC_OP      60
#define	  TD_OP	       68
#define	  MULHD_OP     73
#define	  MULHW_OP     75
#define	  MFMSR_OP     83
#define	  LDARX_OP     84
#define	  DCBF_OP      86
#define	  LBZX_OP      87
#define	  NEG_OP      104
#define	  LBZUX_OP    119
#define	  NOR_OP      124
#define	  SUBFE_OP    136
#define	  ADDE_OP     138
#define	  MTCRF_OP    144
#define	  MTMSR_OP    146
#define	  STDX_OP     149
#define	  STWCX_RC_OP 150	
#define	  STWX_OP     151
#define	  STDUX_OP    181
#define	  STWUX_OP    183
#define	  SUBFZE_OP   200
#define	  ADDZE_OP    202
#define	  MTSR_OP     210
#define	  STDCX_RC_OP 214
#define	  STBX_OP     215
#define	  SUBFME_OP   232
#define	  MULLD_OP    233
#define	  ADDME_OP    234
#define	  MULLW_OP    235
#define	  MTSRIN_OP   242
#define	  DCBTST_OP   246
#define	  STBUX_OP    247
#define	  ADD_OP      266
#define	  DCBT_OP     278
#define	  LHZX_OP     279
#define	  EQV_OP      284
#define	  TLBIE_OP    306
#define	  ECIWX_OP    310
#define	  LHZUX_OP    311
#define	  XOR_OP      316
#define	  MFSPR_OP    339
#define	  LWAX_OP     341
#define	  LHAX_OP     343
#define	  TLBIA_OP    370
#define	  MFTB_OP     371
#define	  LWAUX_OP    373
#define	  LHAUX_OP    375
#define	  STHX_OP     407
#define	  ORC_OP      412
#define	  SRADI_OP    413
#define	  SLBIE_OP    434
#define	  ECOWX_OP    438
#define	  STHUX_OP    439
#define	  OR_OP	      444
#define	  DIVDU_OP    457
#define	  DIVWU_OP    459
#define	  MTSPR_OP    467
#define	  DCBI_OP     470
#define	  NAND_OP     476
#define	  DIVD_OP     489
#define	  DIVW_OP     491
#define	  SLBIA_OP    498
#define	  MCRXR_OP    512
#define	  LSWX_OP     533
#define	  LWBRX_OP    534
#define	  LFSX_OP     535
#define	  SRW_OP      536
#define	  SRD_OP      539
#define	  TLBSYNC_OP  566
#define	  LFSUX_OP    567
#define	  MFSR_OP     595
#define	  LSWI_OP     597
#define	  SYNC_OP     598
#define	  LFDX_OP     599
#define	  LFDUX_OP    631
#define	  MFSRIN_OP   659
#define	  STSWX_OP    661
#define	  STWBRX_OP   662
#define	  STFSX_OP    663
#define	  STFSUX_OP   695
#define	  STSWI_OP    725
#define	  STFDX_OP    727
#define	  STFDUX_OP   759
#define	  LHBRX_OP    790
#define	  SRAW_OP     792
#define	  SRAD_OP     794
#define	  SRAWI_OP    824
#define	  EIEIO_OP    854
#define	  STHBRX_OP   918
#define	  EXTSH_OP    922
#define	  EXTSB_OP    954
#define	  ICBI_OP     982
#define	  STFIWX_OP   983
#define	  EXTSW_OP    986
#define	  DCBZ_OP    1014

#define LWZ_OP      32
#define LWZU_OP	    33
#define	LBZ_OP	    34
#define	LBZU_OP	    35
#define	STW_OP	    36
#define	STWU_OP	    37
#define	STB_OP	    38
#define	STBU_OP	    39
#define	LHZ_OP	    40
#define	LHZU_OP	    41
#define	LHA_OP	    42
#define	LHAU_OP	    43
#define	STH_OP	    44
#define	STHU_OP	    45
#define	LFS_OP	    48
#define	LFSU_OP	    49
#define	LFD_OP	    50
#define	LFDU_OP	    51
#define STFS_OP	    52
#define	STFSU_OP    53
#define	STFD_OP	    54
#define	STFDU_OP    55

#define X58_OP      58    // Extended ops for primary code 58:
#define   LD_OP	        0
#define	  LDU_OP	1
#define	  LWA_OP	2

#define X59_OP      59    // Extended ops for primary code 59:
#define	  FDIVS_OP     18
#define	  FSUBS_OP     20
#define	  FADDS_OP     21
#define	  FSQRTS_OP    22
#define	  FRES_OP      24
#define	  FMULS_OP     25
#define	  FMSUBS_OP    28
#define   FMADDS_OP    29
#define	  FNMSUBS_OP   30
#define	  FNMADDS_OP   31

#define X62_OP      62    // Extended ops for primary code 62:
#define   STD_OP        0
#define   STDU_OP       1

#define X63_OP	    63	  // Extended ops for primary code 63:
#define   FCMPU_OP      0
#define	  FRSP_OP      12
#define	  FCTIW_OP     14
#define	  FCTIWZ_OP    15
#define	  FDIV_OP      18
#define	  FSUB_OP      20
#define	  FADD_OP      21
#define	  FSQRT_OP     22
#define	  FSEL_OP      23
#define	  FMUL_OP      25
#define	  FSQRTE_OP    26
#define	  FMSUB_OP     28
#define   FMADD_OP     29
#define	  FNMSUB_OP    30
#define	  FNMADD_OP    31
#define	  FCMPO_OP     32
#define	  MTFSB1_OP    38
#define	  FNEG_OP      40
#define	  MCRFS_OP     64
#define	  MTFSB0_OP    70
#define	  FMR_OP       72
#define	  MTFSFI_OP   134
#define	  FNABS_OP    136
#define	  FABS_OP     264
#define	  MFFS_OP     583
#define	  MTFSF_OP    711
#define	  FCTID_OP    814
#define	  FCTIDZ_OP   815
#define	  FCFID_OP    846

//
// Define certain specific instructions
//

#define SYSTEM_CALL_INSTR  0x44000002L  // sc
#define RETURN_INSTR       0x4E800020L  // blr
#define BREAK_INSTR        0x0FE00000L  // break <number>
#define TRAP_INSTR         0x0C000000L  // trap word immediate
#define NO_OP_INSTR	       0x60000000L  // ori r.0, r.0, 0
#define INVALID_INSTR	   0x00000000L  // all 0's => invalid

//
// Define specific values for the TO field of the TRAP_INSTR
//

#define TO_BREAKPOINT                   0x03E00000L  // Unconditional breakpoint
#define TO_DIVIDE_BY_ZERO               0x00C00000L  // Integer divide by zero
#define TO_UNCONDITIONAL_DIVIDE_BY_ZERO 0x00E00000L  // Unconditional divide
                                                     // by zero

//
//     IEEE FLOATING POINT VALUE REPRESENTATION
//

//
// Define maximum and minimum single and double exponent values.
//

#define DOUBLE_MAXIMUM_EXPONENT  2047
#define DOUBLE_MINIMUM_EXPONENT  0
#define SINGLE_MAXIMUM_EXPONENT  255
#define SINGLE_MINIMUM_EXPONENT  0

//
// Define single and double exponent bias values.
//

#define SINGLE_EXPONENT_BIAS  127
#define DOUBLE_EXPONENT_BIAS  1023

//
// Define the largest single and double values;
//

#define DOUBLE_MAXIMUM_VALUE_LOW   0xffffffff
#define DOUBLE_MAXIMUM_VALUE_HIGH  0x7fefffff
#define SINGLE_MAXIMUM_VALUE       0x7f7fffff

//
// Define single and double quite and signaling Nan values.
//

#define DOUBLE_NAN_LOW     0xffffffff
#define DOUBLE_QUIET_NAN   0x7ff7ffff
#define DOUBLE_SIGNAL_NAN  0x7fffffff
#define SINGLE_QUIET_NAN   0x7fbfffff
#define SINGLE_SIGNAL_NAN  0x7fffffff

//
// Define positive single and double infinity values.
//

#define DOUBLE_INFINITY_VALUE_LOW   0x0
#define DOUBLE_INFINITY_VALUE_HIGH  0x7ff00000
#define SINGLE_INFINITY_VALUE       0x7f800000

//
// Define rounding modes.
//

#define ROUND_TO_NEAREST         0
#define ROUND_TO_ZERO            1
#define ROUND_TO_PLUS_INFINITY   2
#define ROUND_TO_MINUS_INFINITY  3

#endif // _PPCINST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\port1632.h ===
/***************************************************************************\
* Module Name: 1632PORT.H
*
* Copyright (c) 1985-1999, Microsoft Corporation
*
* Master include file for Portable Windows applications.
*
* History:
*  sanfords    1/10/91        Created
*
\***************************************************************************/

/*
 * This file maps a Meta-API for Windows to specific 16-bit or 32-bit forms
 * allowing a single portable C source for windows to work on multiple
 * versions of Windows.
 */

#ifndef _PORT1632_
#define _PORT1632_

#if _MSC_VER > 1000
#pragma once
#endif

#if defined(WIN16)
/* ---------------- Maps to windows 3.0 and 3.1 16-bit APIs ----------------*/
#include "ptypes16.h"
#include "pwin16.h"
#include "plan16.h"
/* -------------------------------------------------------------------------*/

#elif defined(WIN32)
/* ---------------- Maps to windows 3.2 and 4.0 32-bit APIs ----------------*/
#include "ptypes32.h"
#include "pcrt32.h"
#include "pwin32.h"
#include "plan32.h"
/* -------------------------------------------------------------------------*/
#else
#error You must define either WIN32 or WIN16
#endif /* WIN32 or WIN16 */
#endif /* ndef _PORT1632_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\profinfo.h ===
//=============================================================================
//  profinfo.h   -   Header file for profile info structure.
//
//  Copyright (c) Microsoft Corporation 2000
//  All rights reserved
//
//=============================================================================

#ifndef _INC_PROFINFO
#define _INC_PROFINFO

#ifdef __midl
#define FAR
#define MIDL_STRING [string, unique]
#else
#define MIDL_STRING
#endif  // __midl

typedef struct _PROFILEINFOA {
    DWORD       dwSize;                 // Set to sizeof(PROFILEINFO) before calling
    DWORD       dwFlags;                // See PI_ flags defined in userenv.h
    MIDL_STRING LPSTR       lpUserName;             // User name (required)
    MIDL_STRING LPSTR       lpProfilePath;          // Roaming profile path (optional, can be NULL)
    MIDL_STRING LPSTR       lpDefaultPath;          // Default user profile path (optional, can be NULL)
    MIDL_STRING LPSTR       lpServerName;           // Validating domain controller name in netbios format (optional, can be NULL but group NT4 style policy won't be applied)
    MIDL_STRING LPSTR       lpPolicyPath;           // Path to the NT4 style policy file (optional, can be NULL)
#ifdef __midl
    ULONG_PTR   hProfile;               // Filled in by the function.  Registry key handle open to the root.
#else
    HANDLE      hProfile;               // Filled in by the function.  Registry key handle open to the root.
#endif
    } PROFILEINFOA, FAR * LPPROFILEINFOA;
typedef struct _PROFILEINFOW {
    DWORD       dwSize;                 // Set to sizeof(PROFILEINFO) before calling
    DWORD       dwFlags;                // See PI_ flags defined in userenv.h
    MIDL_STRING LPWSTR      lpUserName;             // User name (required)
    MIDL_STRING LPWSTR      lpProfilePath;          // Roaming profile path (optional, can be NULL)
    MIDL_STRING LPWSTR      lpDefaultPath;          // Default user profile path (optional, can be NULL)
    MIDL_STRING LPWSTR      lpServerName;           // Validating domain controller name in netbios format (optional, can be NULL but group NT4 style policy won't be applied)
    MIDL_STRING LPWSTR      lpPolicyPath;           // Path to the NT4 style policy file (optional, can be NULL)
#ifdef __midl
    ULONG_PTR   hProfile;               // Filled in by the function.  Registry key handle open to the root.
#else
    HANDLE      hProfile;               // Filled in by the function.  Registry key handle open to the root.
#endif
    } PROFILEINFOW, FAR * LPPROFILEINFOW;
#ifdef UNICODE
typedef PROFILEINFOW PROFILEINFO;
typedef LPPROFILEINFOW LPPROFILEINFO;
#else
typedef PROFILEINFOA PROFILEINFO;
typedef LPPROFILEINFOA LPPROFILEINFO;
#endif // UNICODE

#endif  // _INC_PROFINFO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\prgsnk.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for prgsnk.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __prgsnk_h__
#define __prgsnk_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IProgSink_FWD_DEFINED__
#define __IProgSink_FWD_DEFINED__
typedef interface IProgSink IProgSink;
#endif 	/* __IProgSink_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "oleidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IProgSink_INTERFACE_DEFINED__
#define __IProgSink_INTERFACE_DEFINED__

/* interface IProgSink */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IProgSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f371-98b5-11cf-bb82-00aa00bdce0b")
    IProgSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddProgress( 
            /* [in] */ DWORD dwClass,
            /* [out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProgress( 
            /* [in] */ DWORD dwCookie,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwState,
            /* [in] */ LPCTSTR pchText,
            /* [in] */ DWORD dwIds,
            /* [in] */ DWORD dwPos,
            /* [in] */ DWORD dwMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DelProgress( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProgSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IProgSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IProgSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IProgSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddProgress )( 
            IProgSink * This,
            /* [in] */ DWORD dwClass,
            /* [out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *SetProgress )( 
            IProgSink * This,
            /* [in] */ DWORD dwCookie,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwState,
            /* [in] */ LPCTSTR pchText,
            /* [in] */ DWORD dwIds,
            /* [in] */ DWORD dwPos,
            /* [in] */ DWORD dwMax);
        
        HRESULT ( STDMETHODCALLTYPE *DelProgress )( 
            IProgSink * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } IProgSinkVtbl;

    interface IProgSink
    {
        CONST_VTBL struct IProgSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProgSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProgSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProgSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProgSink_AddProgress(This,dwClass,pdwCookie)	\
    (This)->lpVtbl -> AddProgress(This,dwClass,pdwCookie)

#define IProgSink_SetProgress(This,dwCookie,dwFlags,dwState,pchText,dwIds,dwPos,dwMax)	\
    (This)->lpVtbl -> SetProgress(This,dwCookie,dwFlags,dwState,pchText,dwIds,dwPos,dwMax)

#define IProgSink_DelProgress(This,dwCookie)	\
    (This)->lpVtbl -> DelProgress(This,dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IProgSink_AddProgress_Proxy( 
    IProgSink * This,
    /* [in] */ DWORD dwClass,
    /* [out] */ DWORD *pdwCookie);


void __RPC_STUB IProgSink_AddProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IProgSink_SetProgress_Proxy( 
    IProgSink * This,
    /* [in] */ DWORD dwCookie,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwState,
    /* [in] */ LPCTSTR pchText,
    /* [in] */ DWORD dwIds,
    /* [in] */ DWORD dwPos,
    /* [in] */ DWORD dwMax);


void __RPC_STUB IProgSink_SetProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IProgSink_DelProgress_Proxy( 
    IProgSink * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IProgSink_DelProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProgSink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_prgsnk_0140 */
/* [local] */ 

#define PROGSINK_CLASS_FORWARDED    0x80000000
#define PROGSINK_CLASS_NOSPIN       0x40000000
#define PROGSINK_CLASS_HTML         0x00000000
#define PROGSINK_CLASS_MULTIMEDIA   0x00000001
#define PROGSINK_CLASS_CONTROL      0x00000002
#define PROGSINK_CLASS_DATABIND     0x00000003
#define PROGSINK_CLASS_OTHER        0x00000004
#define PROGSINK_CLASS_NOREMAIN     0x00000005
#define PROGSINK_CLASS_FRAME        0x00000006

#define PROGSINK_STATE_IDLE         0x00000000
#define PROGSINK_STATE_FINISHING    0x00000001
#define PROGSINK_STATE_CONNECTING   0x00000002
#define PROGSINK_STATE_LOADING      0x00000003

#define PROGSINK_SET_STATE          0x00000001
#define PROGSINK_SET_TEXT           0x00000002
#define PROGSINK_SET_IDS            0x00000004
#define PROGSINK_SET_POS            0x00000008
#define PROGSINK_SET_MAX            0x00000010



extern RPC_IF_HANDLE __MIDL_itf_prgsnk_0140_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_prgsnk_0140_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\powrprof.h ===
/*****************************************************************************\
*                                                                             *
* powrprof.h - - Interface for powrprof.dll, the power policy applicator      *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/


// Registry storage structures for the GLOBAL_POWER_POLICY data. There are two
// structures, GLOBAL_MACHINE_POWER_POLICY and GLOBAL_USER_POWER_POLICY. the
// GLOBAL_MACHINE_POWER_POLICY stores per machine data for which there is no UI.
// GLOBAL_USER_POWER_POLICY stores the per user data.

typedef struct _GLOBAL_MACHINE_POWER_POLICY{
    ULONG                   Revision;
    SYSTEM_POWER_STATE      LidOpenWakeAc;
    SYSTEM_POWER_STATE      LidOpenWakeDc;
    ULONG                   BroadcastCapacityResolution;
} GLOBAL_MACHINE_POWER_POLICY, *PGLOBAL_MACHINE_POWER_POLICY;

typedef struct _GLOBAL_USER_POWER_POLICY{
    ULONG                   Revision;
    POWER_ACTION_POLICY     PowerButtonAc;
    POWER_ACTION_POLICY     PowerButtonDc;
    POWER_ACTION_POLICY     SleepButtonAc;
    POWER_ACTION_POLICY     SleepButtonDc;
    POWER_ACTION_POLICY     LidCloseAc;
    POWER_ACTION_POLICY     LidCloseDc;
    SYSTEM_POWER_LEVEL      DischargePolicy[NUM_DISCHARGE_POLICIES];
    ULONG                   GlobalFlags;
} GLOBAL_USER_POWER_POLICY, *PGLOBAL_USER_POWER_POLICY;

// Structure to manage global power policies at the user level. This structure
// contains data which is common across all power policy profiles.

typedef struct _GLOBAL_POWER_POLICY{
    GLOBAL_USER_POWER_POLICY    user;
    GLOBAL_MACHINE_POWER_POLICY mach;
} GLOBAL_POWER_POLICY, *PGLOBAL_POWER_POLICY;


// Registry storage structures for the POWER_POLICY data. There are three
// structures, MACHINE_POWER_POLICY, MACHINE_PROCESSOR_POWER_POLICY and USER_POWER_POLICY. the
// MACHINE_POWER_POLICY stores per machine data for which there is no UI.
// USER_POWER_POLICY stores the per user data.

typedef struct _MACHINE_POWER_POLICY{
    ULONG                   Revision;       // 1

    // meaning of power action "sleep"
    SYSTEM_POWER_STATE      MinSleepAc;
    SYSTEM_POWER_STATE      MinSleepDc;
    SYSTEM_POWER_STATE      ReducedLatencySleepAc;
    SYSTEM_POWER_STATE      ReducedLatencySleepDc;

    // parameters for dozing
    ULONG                   DozeTimeoutAc;
    ULONG                   DozeTimeoutDc;
    ULONG                   DozeS4TimeoutAc;
    ULONG                   DozeS4TimeoutDc;

    // processor policies
    UCHAR                   MinThrottleAc;
    UCHAR                   MinThrottleDc;
    UCHAR                   pad1[2];
    POWER_ACTION_POLICY     OverThrottledAc;
    POWER_ACTION_POLICY     OverThrottledDc;

} MACHINE_POWER_POLICY, *PMACHINE_POWER_POLICY;

typedef struct _MACHINE_PROCESSOR_POWER_POLICY {
    ULONG                   Revision;       // 1
    
    PROCESSOR_POWER_POLICY  ProcessorPolicyAc;    
    PROCESSOR_POWER_POLICY  ProcessorPolicyDc;    

} MACHINE_PROCESSOR_POWER_POLICY, *PMACHINE_PROCESSOR_POWER_POLICY;

typedef struct _USER_POWER_POLICY{
    ULONG                   Revision;       // 1


    // "system idle" detection
    POWER_ACTION_POLICY     IdleAc;
    POWER_ACTION_POLICY     IdleDc;
    ULONG                   IdleTimeoutAc;
    ULONG                   IdleTimeoutDc;
    UCHAR                   IdleSensitivityAc;
    UCHAR                   IdleSensitivityDc;
    
    // Throttling Policy
    UCHAR                   ThrottlePolicyAc;
    UCHAR                   ThrottlePolicyDc;

    // meaning of power action "sleep"
    SYSTEM_POWER_STATE      MaxSleepAc;
    SYSTEM_POWER_STATE      MaxSleepDc;

    // For future use
    ULONG                   Reserved[2];

    // video policies
    ULONG                   VideoTimeoutAc;
    ULONG                   VideoTimeoutDc;

    // hard disk policies
    ULONG                   SpindownTimeoutAc;
    ULONG                   SpindownTimeoutDc;

    // processor policies
    BOOLEAN                 OptimizeForPowerAc;
    BOOLEAN                 OptimizeForPowerDc;
    UCHAR                   FanThrottleToleranceAc;
    UCHAR                   FanThrottleToleranceDc;
    UCHAR                   ForcedThrottleAc;
    UCHAR                   ForcedThrottleDc;
    
} USER_POWER_POLICY, *PUSER_POWER_POLICY;

// Structure to manage power policies at the user level. This structure
// contains data which is unique across power policy profiles.

typedef struct _POWER_POLICY{
    USER_POWER_POLICY       user;
    MACHINE_POWER_POLICY    mach;
} POWER_POLICY, *PPOWER_POLICY;


// Constants for GlobalFlags

#define EnableSysTrayBatteryMeter   0x01
#define EnableMultiBatteryDisplay   0x02
#define EnablePasswordLogon         0x04
#define EnableWakeOnRing            0x08
#define EnableVideoDimDisplay       0x10

// This constant is passed as a uiID to WritePwrScheme.
#define NEWSCHEME (UINT)-1

// Prototype for EnumPwrSchemes callback proceedures.

typedef BOOLEAN (CALLBACK* PWRSCHEMESENUMPROC)(UINT, DWORD, LPTSTR, DWORD, LPTSTR, PPOWER_POLICY, LPARAM);
typedef BOOLEAN (CALLBACK* PFNNTINITIATEPWRACTION)(POWER_ACTION, SYSTEM_POWER_STATE, ULONG, BOOLEAN);

// Public function prototypes

BOOLEAN WINAPI GetPwrDiskSpindownRange(PUINT, PUINT);
BOOLEAN WINAPI EnumPwrSchemes(PWRSCHEMESENUMPROC, LPARAM);
BOOLEAN WINAPI ReadGlobalPwrPolicy(PGLOBAL_POWER_POLICY);
BOOLEAN WINAPI ReadPwrScheme(UINT, PPOWER_POLICY);
BOOLEAN WINAPI WritePwrScheme(PUINT, LPTSTR, LPTSTR, PPOWER_POLICY);
BOOLEAN WINAPI WriteGlobalPwrPolicy(PGLOBAL_POWER_POLICY);
BOOLEAN WINAPI DeletePwrScheme(UINT);
BOOLEAN WINAPI GetActivePwrScheme(PUINT);
BOOLEAN WINAPI SetActivePwrScheme(UINT, PGLOBAL_POWER_POLICY, PPOWER_POLICY);
BOOLEAN WINAPI GetPwrCapabilities(PSYSTEM_POWER_CAPABILITIES);
BOOLEAN WINAPI IsPwrSuspendAllowed(VOID);
BOOLEAN WINAPI IsPwrHibernateAllowed(VOID);
BOOLEAN WINAPI IsPwrShutdownAllowed(VOID);
BOOLEAN WINAPI IsAdminOverrideActive(PADMINISTRATOR_POWER_POLICY);
BOOLEAN WINAPI SetSuspendState(BOOLEAN, BOOLEAN, BOOLEAN);
BOOLEAN WINAPI GetCurrentPowerPolicies(PGLOBAL_POWER_POLICY, PPOWER_POLICY);
BOOLEAN WINAPI CanUserWritePwrScheme(VOID);
BOOLEAN WINAPI ReadProcessorPwrScheme(UINT, PMACHINE_PROCESSOR_POWER_POLICY);
BOOLEAN WINAPI WriteProcessorPwrScheme(UINT, PMACHINE_PROCESSOR_POWER_POLICY);
BOOLEAN WINAPI ValidatePowerPolicies(PGLOBAL_POWER_POLICY, PPOWER_POLICY);
#ifndef NT_SUCCESS
#define NTSTATUS LONG
#define _OVERRIDE_NTSTATUS_
#endif

NTSTATUS WINAPI CallNtPowerInformation(POWER_INFORMATION_LEVEL, PVOID, ULONG, PVOID, ULONG);

#ifdef _OVERRIDE_NTSTATUS_
#undef NTSTATUS
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\propapi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       propapi.h
//
//  Contents:   Stuff needed to make properties build for Nashville and
//              NT... definitions of Nt property api.
//
//
//  History:    07-Aug-95   BillMo      Created.
//              22-Feb-96   MikeHill    Fixed the non-WINNT version of
//                                      PROPASSERTMSG.
//              09-May-96   MikeHill    Update define to allow PropSet names
//                                      to be 255 characters (from 127).
//              31-May-96   MikeHill    Add OSVersion to RtlCreatePropSet.
//              18-Jun-96   MikeHill    Add OleAut32 wrappers to Unicode callouts.
//              15-Jul-96   MikeHill    - Remvd Win32 SEH exception-related code.
//                                      - WCHAR=>OLECHAR where applicable.
//                                      - Added RtlOnMappedStreamEvent
//                                      - Added Mac versions of PROPASSERT
//
//--------------------------------------------------------------------------


#ifndef _PROPAPI_H_
#define _PROPAPI_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// typedef the function prototypes necessary
// for the UNICODECALLOUTS structure.
//

typedef UINT (WINAPI FNGETACP)(VOID);

typedef int (WINAPI FNMULTIBYTETOWIDECHAR)(
    IN UINT CodePage,
    IN DWORD dwFlags,
    IN LPCSTR lpMultiByteStr,
    IN int cchMultiByte,
    OUT LPWSTR lpWideCharStr,
    IN int cchWideChar);

typedef int (WINAPI FNWIDECHARTOMULTIBYTE)(
    IN UINT CodePage,
    IN DWORD dwFlags,
    IN LPCWSTR lpWideCharStr,
    IN int cchWideChar,
    OUT LPSTR lpMultiByteStr,
    IN int cchMultiByte,
    IN LPCSTR lpDefaultChar,
    IN LPBOOL lpUsedDefaultChar);

typedef BSTR FNSYSALLOCSTRING(
    OLECHAR FAR* pwsz);

typedef VOID FNSYSFREESTRING(
    BSTR pwsz);

//
// The UNICODECALLOUTS structure holds function
// pointers for routines needed by the property
// set routines in NTDLL.
//

typedef struct _UNICODECALLOUTS
{
    FNGETACP              *pfnGetACP;
    FNMULTIBYTETOWIDECHAR *pfnMultiByteToWideChar;
    FNWIDECHARTOMULTIBYTE *pfnWideCharToMultiByte;
    FNSYSALLOCSTRING      *pfnSysAllocString;
    FNSYSFREESTRING       *pfnSysFreeString;
} UNICODECALLOUTS;


//
// Define the default UNICODECALLOUTS
// values.
//

STDAPI_(BSTR)
PropSysAllocString(OLECHAR FAR* pwsz);

STDAPI_(VOID)
PropSysFreeString(BSTR bstr);

#define WIN32_UNICODECALLOUTS \
    GetACP,                   \
    MultiByteToWideChar,      \
    WideCharToMultiByte,      \
    PropSysAllocString,       \
    PropSysFreeString


// Is this pure NT (the IProp DLL needs to run on Win95)?
#if defined(WINNT) && !defined(IPROPERTY_DLL)

    // Set the function modifiers
#   define PROPSYSAPI NTSYSAPI
#   define PROPAPI NTAPI

    // How do we free mem allocated in the low-level propset routines?
#   define PropFreeHeap(h, z, p) RtlFreeHeap(h, z, p)

    // Assert implementations
#   define PROPASSERT ASSERT
#   define PROPASSERTMSG ASSERTMSG

    // Generate the default non-simple property stream/storage name
#   define PROPGENPROPERTYNAME_SIZEOF  ( (sizeof("prop")+10+1) * sizeof(WCHAR) )
#   define PROPGENPROPERTYNAME_CB(s,cb,n) StringCbPrintf( (s), cb, L"prop%lu", (n) )

    // Ansi sprintf implementations
#   define PropSprintfA StringCbPrintfA
#   define PropVsprintfA vsprintf

// Otherwise this is either the IProp DLL (NT, Win95, Mac),
// or it's the Win95 OLE32build.

#else // #if defined(WINNT) && !defined(IPROPERTY_DLL)

    // Set the function modifiers
#   define PROPSYSAPI
#   define PROPAPI

    // How do we free mem allocated in low-level propset routines?
#   define PropFreeHeap(h, z, p) CoTaskMemFree(p)

    // Assert implementations
#   if DBG==1
#       ifdef _MAC_NODOC
#           define PROPASSERT(f)                { if (!(f)) FnAssert(#f, NULL, __FILE__, __LINE__); }
#           define PROPASSERTMSG(szReason, f)   { if (!(f)) FnAssert(#f, szReason, __FILE__, __LINE__); }
#       else
#           define PROPASSERT(f) PROPASSERTMSG(NULL,f)
#           define PROPASSERTMSG(szReason,f) { if(!(f)) PropAssertFailed(#f,__FILE__,__LINE__,szReason); }
#       endif
#   else
#       define PROPASSERT(f)
#       define PROPASSERTMSG(szReason, f)
#   endif // #if DBG==1

    // Generate the default non-simple property stream/storage name
#   define PROPGENPROPERTYNAME(s,n) \
    { \
        memcpy ((s), OLESTR("prop"), sizeof (OLESTR("prop"))); \
        ULTOO  ((n), &(s)[sizeof("prop") - 1], 10); \
    }

    // Ansi sprintf implementations
#   ifdef IPROPERTY_DLL
#       define PropSprintfA sprintf
#       define PropVsprintfA vsprintf
#   else
#       define PropSprintfA wsprintfA
#       define PropVsprintfA wvsprintfA
#   endif	// #ifdef _MAC_NODOC

#endif // #if defined(WINNT) && !defined(IPROPERTY_DLL) ... #else



#define WC_PROPSET0     ((WCHAR)   0x0005) //(L'#'))
#define OC_PROPSET0     ((OLECHAR) 0x0005) //OLESTR('#'))

#define CBIT_BYTE       8
#define CBIT_GUID       (CBIT_BYTE * sizeof(GUID))
#define CBIT_CHARMASK   5

// The wFormat field in the header indicates what features
// are supported.

#define PROPSET_WFORMAT_ORIGINAL         0

#define PROPSET_WFORMAT_VERSTREAM        1
#define PROPSET_WFORMAT_CASE_SENSITIVE   1
#define PROPSET_WFORMAT_BEHAVIOR         1
#define PROPSET_WFORMAT_LONG_NAMES       1
#define PROPSET_WFORMAT_EXPANDED_VTS     1

// Allow for OC_PROPSET0 and a GUID mapped to a 32 character alphabet
#define CCH_PROPSET        (1 + (CBIT_GUID + CBIT_CHARMASK-1)/CBIT_CHARMASK)
#define CCH_PROPSETSZ      (CCH_PROPSET + 1)            // allow null
#define CCH_PROPSETCOLONSZ (1 + CCH_PROPSET + 1)        // allow colon and null

// Define the max property name in units of characters
// (and synonomously in wchars).

#define CCH_MAXPROPNAME    255                          // Matches Shell & Office
#define CCH_MAXPROPNAMESZ  (CCH_MAXPROPNAME + 1)        // allow null
#define CWC_MAXPROPNAME    CCH_MAXPROPNAME
#define CWC_MAXPROPNAMESZ  CCH_MAXPROPNAMESZ

#define MAX_DOCFILE_ENTRY_NAME  31

//+--------------------------------------------------------------------------
// Property Access APIs:
//---------------------------------------------------------------------------

typedef VOID *NTPROP;
typedef VOID *NTMAPPEDSTREAM;
typedef VOID *NTMEMORYALLOCATOR;


VOID PROPSYSAPI PROPAPI
RtlSetUnicodeCallouts(
    IN UNICODECALLOUTS *pUnicodeCallouts);

ULONG PROPSYSAPI PROPAPI
RtlGuidToPropertySetName(
    IN GUID const *pguid,
    OUT OLECHAR aocname[]);

NTSTATUS PROPSYSAPI PROPAPI
RtlPropertySetNameToGuid(
    IN ULONG cwcname,
    IN OLECHAR const aocname[],
    OUT GUID *pguid);

VOID
PrSetUnicodeCallouts(
    IN UNICODECALLOUTS *pUnicodeCallouts);

ULONG
PrGuidToPropertySetName(
    IN GUID const *pguid,
    OUT OLECHAR aocname[]);

NTSTATUS
PrPropertySetNameToGuid(
    IN ULONG cwcname,
    IN OLECHAR const aocname[],
    OUT GUID *pguid);


// RtlCreatePropertySet Flags:

#define CREATEPROP_READ         0x0000 // request read access (must exist)
#define CREATEPROP_WRITE        0x0001 // request write access (must exist)
#define CREATEPROP_CREATE       0x0002 // create (overwrite if exists)
#define CREATEPROP_CREATEIF     0x0003 // create (open existing if exists)
#define CREATEPROP_DELETE       0x0004 // delete
#define CREATEPROP_UNKNOWN      0x0008 // read/write state is unknown
#define CREATEPROP_MODEMASK     0x000f // open mode mask

#define CREATEPROP_NONSIMPLE    0x0010 // Is non-simple propset (in a storage)


// RtlCreateMappedStream Flags:

#define CMS_READONLY      0x00000000    // Opened for read-only
#define CMS_WRITE         0x00000001    // Opened for write access
#define CMS_TRANSACTED    0x00000002    // Is transacted


NTSTATUS PROPSYSAPI PROPAPI
RtlCreatePropertySet(
    IN NTMAPPEDSTREAM ms,       // Nt mapped stream
    IN USHORT Flags,	// NONSIMPLE|*1* of READ/WRITE/CREATE/CREATEIF/DELETE
    OPTIONAL IN GUID const *pguid, // property set guid (create only)
    OPTIONAL IN GUID const *pclsid,// CLASSID of propset code (create only)
    IN NTMEMORYALLOCATOR ma,	// caller's memory allocator
    IN ULONG LocaleId,		// Locale Id (create only)
    OPTIONAL OUT ULONG *pOSVersion,// OS Version field in header.
    IN OUT USHORT *pCodePage,   // IN: CodePage of property set (create only)
                                // OUT: CodePage of property set (always)
    OUT NTPROP *pnp);           // Nt property set context

NTSTATUS PROPSYSAPI PROPAPI
RtlClosePropertySet(
    IN NTPROP np);              // property set context

NTSTATUS
PrCreatePropertySet(
    IN NTMAPPEDSTREAM ms,       // Nt mapped stream
    IN USHORT Flags,	// NONSIMPLE|*1* of READ/WRITE/CREATE/CREATEIF/DELETE
    OPTIONAL IN GUID const *pguid, // property set guid (create only)
    OPTIONAL IN GUID const *pclsid,// CLASSID of propset code (create only)
    IN NTMEMORYALLOCATOR ma,	// caller's memory allocator
    IN ULONG LocaleId,		// Locale Id (create only)
    OPTIONAL OUT ULONG *pOSVersion,// OS Version field in header.
    IN OUT USHORT *pCodePage,   // IN: CodePage of property set (create only)
                                // OUT: CodePage of property set (always)
    IN OUT DWORD *pgrfBehavior,    // IN: Behavior of property set (create only)
                                    // OUT:  Behavior of property set (always)
    OUT NTPROP *pnp);           // Nt property set context

NTSTATUS
PrClosePropertySet(
    IN NTPROP np);              // property set context

// *NOTE* RtlOnMappedStreamEvent assumes that the caller has
// already taken the CPropertySetStream::Lock.
#define CBSTM_UNKNOWN   ((ULONG) -1)
NTSTATUS PROPSYSAPI PROPAPI
RtlOnMappedStreamEvent(
    IN VOID *pv,               // property set context (NTPROP)
    IN VOID *pbuf,             // property set buffer
    IN ULONG cbstm );          // size of underlying stream, or CBSTM_UNKNOWN
NTSTATUS
PrOnMappedStreamEvent(
    IN VOID *pv,               // property set context (NTPROP)
    IN VOID *pbuf,             // property set buffer
    IN ULONG cbstm );          // size of underlying stream, or CBSTM_UNKNOWN

NTSTATUS PROPSYSAPI PROPAPI
RtlFlushPropertySet(
    IN NTPROP np);              // property set context
NTSTATUS
PrFlushPropertySet(
    IN NTPROP np);              // property set context

typedef struct _INDIRECTPROPERTY        // ip
{
    ULONG       Index;          // Index into Variant and PropId arrays
    LPOLESTR    poszName;       // Old indirect name, RtlSetProperties() only
} INDIRECTPROPERTY;

NTSTATUS PROPSYSAPI PROPAPI
RtlSetProperties(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID pidNameFirst,     // first PROPID for new named properties
    IN PROPSPEC const aprs[],   // array of property specifiers
    OPTIONAL OUT PROPID apid[], // buffer for array of propids
    OPTIONAL OUT INDIRECTPROPERTY **ppip, // pointer to returned pointer to
                                // MAXULONG terminated array of Indirect
                                // properties w/indexes into aprs & avar
    OPTIONAL IN PROPVARIANT const avar[]);// array of properties with values
NTSTATUS
PrSetProperties(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID pidNameFirst,     // first PROPID for new named properties
    IN PROPSPEC const aprs[],   // array of property specifiers
    OUT USHORT *pCodePage,      // updated code page
    OPTIONAL OUT PROPID apid[], // buffer for array of propids
    OPTIONAL OUT INDIRECTPROPERTY **ppip, // pointer to returned pointer to
                                // MAXULONG terminated array of Indirect
                                // properties w/indexes into aprs & avar
    OPTIONAL IN PROPVARIANT const avar[]);// array of properties with values

NTSTATUS PROPSYSAPI PROPAPI
RtlQueryProperties(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPSPEC const aprs[],   // array of property specifiers
    OPTIONAL OUT PROPID apid[], // buffer for array of propids
    OPTIONAL OUT INDIRECTPROPERTY **ppip, // pointer to returned pointer to
                                // MAXULONG terminated array of Indirect
                                // properties w/indexes into aprs & avar
    IN OUT PROPVARIANT *avar,   // IN: array of uninitialized PROPVARIANTs,
                                // OUT: may contain pointers to alloc'd memory
    OUT ULONG *pcpropFound);    // count of property values retrieved
NTSTATUS
PrQueryProperties(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPSPEC const aprs[],   // array of property specifiers
    OPTIONAL OUT PROPID apid[], // buffer for array of propids
    OPTIONAL OUT INDIRECTPROPERTY **ppip, // pointer to returned pointer to
                                // MAXULONG terminated array of Indirect
                                // properties w/indexes into aprs & avar
    IN OUT PROPVARIANT *avar,   // IN: array of uninitialized PROPVARIANTs,
                                // OUT: may contain pointers to alloc'd memory
    OUT ULONG *pcpropFound);    // count of property values retrieved



#define ENUMPROP_NONAMES        0x00000001      // return property IDs only

NTSTATUS PROPSYSAPI PROPAPI
RtlEnumerateProperties(
    IN NTPROP np,               // property set context
    IN ULONG Flags,             // flags: No Names (propids only), etc.
    IN OUT ULONG *pkey,         // bookmark; caller set to 0 before 1st call
    IN OUT ULONG *pcprop,       // pointer to property count
    OPTIONAL OUT PROPSPEC aprs[],// IN: array of uninitialized PROPSPECs
                                // OUT: may contain pointers to alloc'd strings
    OPTIONAL OUT STATPROPSTG asps[]);
                                // IN: array of uninitialized STATPROPSTGs
                                // OUT: may contain pointers to alloc'd strings

NTSTATUS PROPSYSAPI PROPAPI
RtlQueryPropertyNames(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID const *apid,      // PROPID array
    OUT OLECHAR *aposz[]        // OUT pointers to allocated strings
    );

NTSTATUS PROPSYSAPI PROPAPI
RtlSetPropertyNames(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID const *apid,      // PROPID array
    IN OLECHAR const * const aposz[] // pointers to property names
    );

NTSTATUS PROPSYSAPI PROPAPI
RtlSetPropertySetClassId(
    IN NTPROP np,               // property set context
    IN GUID const *pclsid       // new CLASSID of propset code
    );

NTSTATUS PROPSYSAPI PROPAPI
RtlQueryPropertySet(
    IN NTPROP np,               // property set context
    OUT STATPROPSETSTG *pspss   // buffer for property set stat information
    );

NTSTATUS PROPSYSAPI PROPAPI
RtlEnumeratePropertySets(
    IN HANDLE hstg,             // structured storage handle
    IN BOOLEAN fRestart,        // restart scan
    IN OUT ULONG *pcspss,       // pointer to count of STATPROPSETSTGs
    IN OUT GUID *pkey,          // bookmark
    OUT STATPROPSETSTG *pspss   // array of STATPROPSETSTGs
    );





NTSTATUS
PrEnumerateProperties(
    IN NTPROP np,               // property set context
    IN ULONG Flags,             // flags: No Names (propids only), etc.
    IN OUT ULONG *pkey,         // bookmark; caller set to 0 before 1st call
    IN OUT ULONG *pcprop,       // pointer to property count
    OPTIONAL OUT PROPSPEC aprs[],// IN: array of uninitialized PROPSPECs
                                // OUT: may contain pointers to alloc'd strings
    OPTIONAL OUT STATPROPSTG asps[]);
                                // IN: array of uninitialized STATPROPSTGs
                                // OUT: may contain pointers to alloc'd strings

NTSTATUS
PrQueryPropertyNames(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID const *apid,      // PROPID array
    OUT OLECHAR *aposz[]        // OUT pointers to allocated strings
    );

NTSTATUS
PrSetPropertyNames(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID const *apid,      // PROPID array
    IN OLECHAR const * const aposz[] // pointers to property names
    );

NTSTATUS
PrSetPropertySetClassId(
    IN NTPROP np,               // property set context
    IN GUID const *pclsid       // new CLASSID of propset code
    );

NTSTATUS
PrQueryPropertySet(
    IN NTPROP np,               // property set context
    OUT STATPROPSETSTG *pspss   // buffer for property set stat information
    );

NTSTATUS
PrEnumeratePropertySets(
    IN HANDLE hstg,             // structured storage handle
    IN BOOLEAN fRestart,        // restart scan
    IN OUT ULONG *pcspss,       // pointer to count of STATPROPSETSTGs
    IN OUT GUID *pkey,          // bookmark
    OUT STATPROPSETSTG *pspss   // array of STATPROPSETSTGs
    );



#ifdef __cplusplus
}
#endif

#endif // ifndef _PROPAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\propset.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1993-1999
//
// File:	propset.h
//
// Contents:	OLE Appendix B property set structure definitions
//
// History:	15-Jul-94       brianb    created
//		15-Aug-94       SethuR    revised
//              22-Feb-96       MikeHill  Changed cb in tagENTRY to cch.
//              28-May-96       MikeHill  Changed OSVER_* to OSKIND_*.
//
//---------------------------------------------------------------------------

#ifndef _PROPSET_H_
#define _PROPSET_H_

#if _MSC_VER > 1000
#pragma once
#endif

// CBMAXPROPSETSTREAM must be a power of 2.
#define CBMAXPROPSETSTREAM	(1024 * 1024)

#define IsIndirectVarType(vt)			\
	    ((vt) == VT_STREAM ||		\
	     (vt) == VT_STREAMED_OBJECT ||	\
	     (vt) == VT_STORAGE ||		\
	     (vt) == VT_STORED_OBJECT ||        \
             (vt) == VT_VERSIONED_STREAM)


// Defines for the high order WORD of dwOSVer:

#define OSKIND_WINDOWS      0x0000
#define OSKIND_MACINTOSH    0x0001
#define OSKIND_WIN32        0x0002


typedef struct tagFORMATIDOFFSET	// fo
{
    FMTID	fmtid;
    DWORD	dwOffset;
} FORMATIDOFFSET;

#define CB_FORMATIDOFFSET	sizeof(FORMATIDOFFSET)


typedef struct tagPROPERTYSETHEADER	// ph
{
    WORD        wByteOrder;	// Always 0xfffe
    WORD        wFormat;	// Always 0
    DWORD       dwOSVer;	// System version
    CLSID       clsid;		// Application CLSID
    DWORD       reserved;	// reserved (must be at least 1)
} PROPERTYSETHEADER;

#define CB_PROPERTYSETHEADER	sizeof(PROPERTYSETHEADER)
#define PROPSET_BYTEORDER       0xFFFE


typedef struct tagPROPERTYIDOFFSET	// po
{
    DWORD       propid;
    DWORD       dwOffset;
} PROPERTYIDOFFSET;

#define CB_PROPERTYIDOFFSET	sizeof(PROPERTYIDOFFSET)


typedef struct tagPROPERTYSECTIONHEADER	// sh
{
    DWORD       cbSection;
    DWORD       cProperties;
    PROPERTYIDOFFSET rgprop[1];
} PROPERTYSECTIONHEADER;

#define CB_PROPERTYSECTIONHEADER FIELD_OFFSET(PROPERTYSECTIONHEADER, rgprop)


typedef struct tagSERIALIZEDPROPERTYVALUE		// prop
{
    DWORD	dwType;
    BYTE	rgb[1];
} SERIALIZEDPROPERTYVALUE;

#define CB_SERIALIZEDPROPERTYVALUE  FIELD_OFFSET(SERIALIZEDPROPERTYVALUE, rgb)

typedef struct tagENTRY			// ent
{
    DWORD propid;
    DWORD cch;			// Includes trailing '\0' or L'\0'
    char  sz[1];		// WCHAR if UNICODE CodePage
} ENTRY;

#define CB_DICTIONARY_ENTRY             FIELD_OFFSET(ENTRY, sz)


typedef struct tagDICTIONARY		// dy
{
    DWORD	cEntries;
    ENTRY	rgEntry[1];
} DICTIONARY;

#define CB_DICTIONARY		FIELD_OFFSET(DICTIONARY, rgEntry)

#endif // _PROPSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\propvar.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// File:        propvar.h
//
// Contents:    PROPVARIANT manipulation code
//
// History:     15-Aug-95   vich        created
//              01-Jul-96   MikeHill    Updated to allow Win32 SEH removal
//
//---------------------------------------------------------------------------

#ifndef _PROPVAR_H_
#define _PROPVAR_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <debnot.h>
#include <propset.h>
#include <propapi.h>   // PROPASSERT

SERIALIZEDPROPERTYVALUE *
RtlConvertVariantToProperty(
    IN PROPVARIANT const *pvar,
    IN USHORT CodePage,
    OUT SERIALIZEDPROPERTYVALUE *pprop,
    IN OUT ULONG *pcb,
    IN PROPID pid,
    IN BOOLEAN fVariantVector,
    OPTIONAL OUT ULONG *pcIndirect);

SERIALIZEDPROPERTYVALUE *
RtlConvertVariantToPropertyNoEH(     // No NT Exception Handling version
    IN PROPVARIANT const *pvar,
    IN USHORT CodePage,
    OUT SERIALIZEDPROPERTYVALUE *pprop,
    IN OUT ULONG *pcb,
    IN PROPID pid,
    IN BOOLEAN fVariantVector,
    OPTIONAL OUT ULONG *pcIndirect,
    OUT NTSTATUS *pstatus);

BOOLEAN
RtlConvertPropertyToVariant(
    IN SERIALIZEDPROPERTYVALUE const *pprop,
    IN USHORT CodePage,
    OUT PROPVARIANT *pvar,
    IN PMemoryAllocator *pma);

BOOLEAN
RtlConvertPropertyToVariantNoEH(     // No NT Exception Handling version
    IN SERIALIZEDPROPERTYVALUE const *pprop,
    IN USHORT CodePage,
    OUT PROPVARIANT *pvar,
    IN PMemoryAllocator *pma,
    OUT NTSTATUS *pstatus);




EXTERN_C SERIALIZEDPROPERTYVALUE * __stdcall
StgConvertVariantToProperty(
    IN PROPVARIANT const *pvar,
    IN USHORT CodePage,
    OUT SERIALIZEDPROPERTYVALUE *pprop,
    IN OUT ULONG *pcb,
    IN PROPID pid,
    IN BOOLEAN fVector,
    OPTIONAL OUT ULONG *pcIndirect);

EXTERN_C SERIALIZEDPROPERTYVALUE * __stdcall
StgConvertVariantToPropertyNoEH(     // No NT Exception Handling version
    IN PROPVARIANT const *pvar,
    IN USHORT CodePage,
    OUT SERIALIZEDPROPERTYVALUE *pprop,
    IN OUT ULONG *pcb,
    IN PROPID pid,
    IN BOOLEAN fVector,
    IN BOOLEAN fArray,
    OPTIONAL OUT ULONG *pcIndirect,
    OPTIONAL OUT WORD *pwMinFormatRequired,
    OUT NTSTATUS *pstatus);

EXTERN_C BOOLEAN __stdcall
StgConvertPropertyToVariant(
    IN SERIALIZEDPROPERTYVALUE const *pprop,
    IN USHORT CodePage,
    OUT PROPVARIANT *pvar,
    IN PMemoryAllocator *pma);

EXTERN_C BOOLEAN __stdcall
StgConvertPropertyToVariantNoEH(     // No NT Exception Handling version
    IN SERIALIZEDPROPERTYVALUE const *pprop,
    IN ULONG cbprop,
    IN USHORT CodePage,
    OUT PROPVARIANT *pvar,
    IN PMemoryAllocator *pma,
    OUT NTSTATUS *pstatus);





#ifndef KERNEL
VOID
CleanupVariants(
    IN PROPVARIANT *pvar,
    IN ULONG cprop,
    IN PMemoryAllocator *pma);
#endif

#if DBGPROP
BOOLEAN IsUnicodeString(WCHAR const *pwszname, ULONG cb);
BOOLEAN IsAnsiString(CHAR const *pszname, ULONG cb);
#endif


//+--------------------------------------------------------------------------
// Function:    SignalOverflow, SignalInvalidParameter, SignalStatus
//
// Synopsis:    ASSERT and raise data corrupt/overflow/specified error
//
// Arguments:   [szReason]              -- string explanation
//              [Status]                -- Status to raise (SignalStatus only)
//
// Returns:     None
//+--------------------------------------------------------------------------


#define StatusOverflow(pstatus, szReason)           \
          *(pstatus) = STATUS_BUFFER_OVERFLOW;      \
          TraceStatus(szReason)

#define StatusAccessDenied(pstatus, szReason)   \
          *(pstatus) = STATUS_ACCESS_DENIED;        \
          TraceStatus(szReason);

#define StatusInvalidParameter(pstatus, szReason)   \
          *(pstatus) = STATUS_INVALID_PARAMETER;    \
          TraceStatus(szReason);

#define StatusNoMemory(pstatus, szReason)           \
          *(pstatus) = STATUS_INSUFFICIENT_RESOURCES;\
          TraceStatus(szReason);

#define StatusDiskFull(pstatus, szReason)           \
          *(pstatus) = STATUS_DISK_FULL;            \
          TraceStatus(szReason);

#define StatusError(pstatus, szReason, Status)      \
          *(pstatus) = Status;                      \
          TraceStatus(szReason);

#ifdef KERNEL
#define StatusKBufferOverflow(pstatus, szReason) StatusOverflow(pstatus, szReason)
#else
#define StatusKBufferOverflow(pstatus, szReason) StatusNoMemory(pstatus, szReason)
#endif


#ifdef KERNEL
#define KERNELSELECT(k, u)      k
#else
#define KERNELSELECT(k, u)      u
#endif

#define DBGPROPASSERT   KERNELSELECT(DBGPROP, DBG)

#if DBGPROPASSERT
#define TraceStatus(szReason)                                   \
	{							\
	    DebugTrace(0, DEBTRACE_ERROR, (szReason "\n"));     \
	    PROPASSERTMSG(szReason, !(DebugLevel & DEBTRACE_WARN)); \
	}


#else
#define TraceStatus(szReason)
#endif



#define AssertVarField(field, cb) \
  PROPASSERT(FIELD_OFFSET(PROPVARIANT, iVal) == FIELD_OFFSET(PROPVARIANT, field) && \
	 sizeof(((PROPVARIANT *) 0)->field) == (cb))

#define AssertVarVector(field, cbElem) \
  PROPASSERT(FIELD_OFFSET(PROPVARIANT, cai.cElems) == \
	     FIELD_OFFSET(PROPVARIANT, field.cElems) && \
         FIELD_OFFSET(PROPVARIANT, cai.pElems) == \
	     FIELD_OFFSET(PROPVARIANT, field.pElems) && \
	 sizeof(((PROPVARIANT *) 0)->field.pElems[0]) == (cbElem))

#define AssertByteField(field)	    AssertVarField(field, sizeof(BYTE))
#define AssertShortField(field)	    AssertVarField(field, sizeof(SHORT))
#define AssertLongField(field)	    AssertVarField(field, sizeof(LONG))
#define AssertLongLongField(field)  AssertVarField(field, sizeof(LONGLONG))
#define AssertStringField(field)    AssertVarField(field, sizeof(VOID *))

#define AssertByteVector(field)	    AssertVarVector(field, sizeof(BYTE))
#define AssertShortVector(field)    AssertVarVector(field, sizeof(SHORT))
#define AssertLongVector(field)	    AssertVarVector(field, sizeof(LONG))
#define AssertLongLongVector(field) AssertVarVector(field, sizeof(LONGLONG))
#define AssertStringVector(field)   AssertVarVector(field, sizeof(VOID *))
#define AssertVariantVector(field)  AssertVarVector(field, sizeof(PROPVARIANT))


#define BSTRLEN(bstrVal)	*((ULONG *) bstrVal - 1)


//+-------------------------------------------------------------------
// Class:       CBufferAllocator, private
//
// Synopsis:    allocation from a buffer
//
// Notes:       The Summary catalog APIs use a single buffer to serialize row
//              values on input and deserialize them on output.  This class
//              encapsulates the memory allocation routines for these APIs.
//--------------------------------------------------------------------

class CBufferAllocator : public PMemoryAllocator
{
public:
    inline CBufferAllocator(ULONG cbBuffer, VOID *pvBuffer)
    {
	_cbFree = cbBuffer;
	_pvCur = _pvBuffer = pvBuffer;
#if _X86_	// stack variables on x86 are not aligned
	PROPASSERT(((ULONG) _pvCur & (sizeof(LONG) - 1)) == 0);
#else // RISC
	PROPASSERT(((ULONG_PTR) _pvCur & (sizeof(LONGLONG) - 1)) == 0);
#endif // X86/RISC
    }

    VOID *Allocate(ULONG cbSize);
    VOID Free(VOID *pv) { }

    inline ULONG GetFreeSize(VOID) { return(_cbFree); }

private:
    ULONG  _cbFree;
    VOID  *_pvCur;
    VOID  *_pvBuffer;
};

//+-------------------------------------------------------------------
// Member:      CBufferAllocator::Allocate, private
//
// Synopsis:    allocation from a buffer
//
// Arguments:   [cb]	-- Count of bytes to be allocated.
//
// Returns:     pointer to 'allocated' memory -- NULL if no space left
//--------------------------------------------------------------------

#define DEFINE_CBufferAllocator__Allocate			\
VOID *								\
CBufferAllocator::Allocate(ULONG cb)				\
{								\
    VOID *pv;							\
								\
    cb = (cb + sizeof(LONGLONG) - 1) & ~(sizeof(LONGLONG) - 1);	\
    if (cb > _cbFree)						\
    {								\
        return(NULL);						\
    }								\
    pv = _pvCur;						\
    _pvCur = (BYTE *) _pvCur + cb;				\
    _cbFree -= cb;						\
    return(pv);							\
}

#endif // !_PROPVAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\provexce.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  ProvExce.h
//
//  Purpose: Exception handling classes
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _PROVIDER_EXCEPT_H
#define _PROVIDER_EXCEPT_H

/**************************************************************
 *
 **************************************************************/

#include <eh.h>

/**************************************************************
 *
 **************************************************************/

class CHeap_Exception
{
public:

	enum HEAP_ERROR
	{
		E_ALLOCATION_ERROR = 0 ,
		E_FREE_ERROR
	};

private:

	HEAP_ERROR m_Error;

public:

	CHeap_Exception ( HEAP_ERROR e ) : m_Error ( e ) {}
	~CHeap_Exception () {}

	HEAP_ERROR GetError() { return m_Error ; }
} ;

/**************************************************************
 *
 **************************************************************/

class CStructured_Exception
{
private:

    UINT m_nSE ;
	EXCEPTION_POINTERS *m_pExp ;

public:

    CStructured_Exception () {}
    CStructured_Exception ( UINT n , EXCEPTION_POINTERS *pExp ) : m_nSE ( n ) , m_pExp ( pExp ) {}
    ~CStructured_Exception () {}
    UINT GetSENumber () { return m_nSE ; }
	EXCEPTION_POINTERS *GetExtendedInfo() { return m_pExp ; }
} ;

/**************************************************************
 *
 **************************************************************/

class CSetStructuredExceptionHandler
{
private:

	_se_translator_function m_PrevFunc ;

public:

	static void _cdecl trans_func ( UINT u , EXCEPTION_POINTERS *pExp )
	{
		throw CStructured_Exception ( u , pExp ) ;
	}

	CSetStructuredExceptionHandler () : m_PrevFunc ( NULL )
	{
		m_PrevFunc = _set_se_translator ( trans_func ) ;
	}

	~CSetStructuredExceptionHandler ()
	{
		_set_se_translator ( m_PrevFunc ) ;
	}
} ;

/**************************************************************
 *
 **************************************************************/

#endif //_PROVIDER_EXCEPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\propidl.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for propidl.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __propidl_h__
#define __propidl_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IPropertyStorage_FWD_DEFINED__
#define __IPropertyStorage_FWD_DEFINED__
typedef interface IPropertyStorage IPropertyStorage;
#endif 	/* __IPropertyStorage_FWD_DEFINED__ */


#ifndef __IPropertySetStorage_FWD_DEFINED__
#define __IPropertySetStorage_FWD_DEFINED__
typedef interface IPropertySetStorage IPropertySetStorage;
#endif 	/* __IPropertySetStorage_FWD_DEFINED__ */


#ifndef __IEnumSTATPROPSTG_FWD_DEFINED__
#define __IEnumSTATPROPSTG_FWD_DEFINED__
typedef interface IEnumSTATPROPSTG IEnumSTATPROPSTG;
#endif 	/* __IEnumSTATPROPSTG_FWD_DEFINED__ */


#ifndef __IEnumSTATPROPSETSTG_FWD_DEFINED__
#define __IEnumSTATPROPSETSTG_FWD_DEFINED__
typedef interface IEnumSTATPROPSETSTG IEnumSTATPROPSETSTG;
#endif 	/* __IEnumSTATPROPSETSTG_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_propidl_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------
#if ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)    /* Nameless struct/union */
#pragma warning(disable:4237)    /* obsolete member named 'bool' */
#endif
#if ( _MSC_VER >= 1020 )
#pragma once
#endif



typedef struct tagVersionedStream
    {
    GUID guidVersion;
    IStream *pStream;
    } 	VERSIONEDSTREAM;

typedef struct tagVersionedStream *LPVERSIONEDSTREAM;


// Flags for IPropertySetStorage::Create
#define	PROPSETFLAG_DEFAULT	( 0 )

#define	PROPSETFLAG_NONSIMPLE	( 1 )

#define	PROPSETFLAG_ANSI	( 2 )

//   (This flag is only supported on StgCreatePropStg & StgOpenPropStg
#define	PROPSETFLAG_UNBUFFERED	( 4 )

//   (This flag causes a version-1 property set to be created
#define	PROPSETFLAG_CASE_SENSITIVE	( 8 )


// Flags for the reservied PID_BEHAVIOR property
#define	PROPSET_BEHAVIOR_CASE_SENSITIVE	( 1 )

#ifdef MIDL_PASS
// This is the PROPVARIANT definition for marshaling.
typedef struct tag_inner_PROPVARIANT PROPVARIANT;

#else
// This is the standard C layout of the PROPVARIANT.
typedef struct tagPROPVARIANT PROPVARIANT;
#endif
typedef struct tagCAC
    {
    ULONG cElems;
    /* [size_is] */ CHAR *pElems;
    } 	CAC;

typedef struct tagCAUB
    {
    ULONG cElems;
    /* [size_is] */ UCHAR *pElems;
    } 	CAUB;

typedef struct tagCAI
    {
    ULONG cElems;
    /* [size_is] */ SHORT *pElems;
    } 	CAI;

typedef struct tagCAUI
    {
    ULONG cElems;
    /* [size_is] */ USHORT *pElems;
    } 	CAUI;

typedef struct tagCAL
    {
    ULONG cElems;
    /* [size_is] */ LONG *pElems;
    } 	CAL;

typedef struct tagCAUL
    {
    ULONG cElems;
    /* [size_is] */ ULONG *pElems;
    } 	CAUL;

typedef struct tagCAFLT
    {
    ULONG cElems;
    /* [size_is] */ FLOAT *pElems;
    } 	CAFLT;

typedef struct tagCADBL
    {
    ULONG cElems;
    /* [size_is] */ DOUBLE *pElems;
    } 	CADBL;

typedef struct tagCACY
    {
    ULONG cElems;
    /* [size_is] */ CY *pElems;
    } 	CACY;

typedef struct tagCADATE
    {
    ULONG cElems;
    /* [size_is] */ DATE *pElems;
    } 	CADATE;

typedef struct tagCABSTR
    {
    ULONG cElems;
    /* [size_is] */ BSTR *pElems;
    } 	CABSTR;

typedef struct tagCABSTRBLOB
    {
    ULONG cElems;
    /* [size_is] */ BSTRBLOB *pElems;
    } 	CABSTRBLOB;

typedef struct tagCABOOL
    {
    ULONG cElems;
    /* [size_is] */ VARIANT_BOOL *pElems;
    } 	CABOOL;

typedef struct tagCASCODE
    {
    ULONG cElems;
    /* [size_is] */ SCODE *pElems;
    } 	CASCODE;

typedef struct tagCAPROPVARIANT
    {
    ULONG cElems;
    /* [size_is] */ PROPVARIANT *pElems;
    } 	CAPROPVARIANT;

typedef struct tagCAH
    {
    ULONG cElems;
    /* [size_is] */ LARGE_INTEGER *pElems;
    } 	CAH;

typedef struct tagCAUH
    {
    ULONG cElems;
    /* [size_is] */ ULARGE_INTEGER *pElems;
    } 	CAUH;

typedef struct tagCALPSTR
    {
    ULONG cElems;
    /* [size_is] */ LPSTR *pElems;
    } 	CALPSTR;

typedef struct tagCALPWSTR
    {
    ULONG cElems;
    /* [size_is] */ LPWSTR *pElems;
    } 	CALPWSTR;

typedef struct tagCAFILETIME
    {
    ULONG cElems;
    /* [size_is] */ FILETIME *pElems;
    } 	CAFILETIME;

typedef struct tagCACLIPDATA
    {
    ULONG cElems;
    /* [size_is] */ CLIPDATA *pElems;
    } 	CACLIPDATA;

typedef struct tagCACLSID
    {
    ULONG cElems;
    /* [size_is] */ CLSID *pElems;
    } 	CACLSID;

#ifdef MIDL_PASS
// This is the PROPVARIANT padding layout for marshaling.
typedef BYTE PROPVAR_PAD1;

typedef BYTE PROPVAR_PAD2;

typedef ULONG PROPVAR_PAD3;

#else
// This is the standard C layout of the structure.
typedef WORD PROPVAR_PAD1;
typedef WORD PROPVAR_PAD2;
typedef WORD PROPVAR_PAD3;
#define tag_inner_PROPVARIANT
#endif
#ifndef MIDL_PASS
struct tagPROPVARIANT {
  union {
#endif
struct tag_inner_PROPVARIANT
    {
    VARTYPE vt;
    PROPVAR_PAD1 wReserved1;
    PROPVAR_PAD2 wReserved2;
    PROPVAR_PAD3 wReserved3;
    /* [switch_is] */ /* [switch_type] */ union 
        {
        /* [case()] */  /* Empty union arm */ 
        /* [case()] */ CHAR cVal;
        /* [case()] */ UCHAR bVal;
        /* [case()] */ SHORT iVal;
        /* [case()] */ USHORT uiVal;
        /* [case()] */ LONG lVal;
        /* [case()] */ ULONG ulVal;
        /* [case()] */ INT intVal;
        /* [case()] */ UINT uintVal;
        /* [case()] */ LARGE_INTEGER hVal;
        /* [case()] */ ULARGE_INTEGER uhVal;
        /* [case()] */ FLOAT fltVal;
        /* [case()] */ DOUBLE dblVal;
        /* [case()] */ VARIANT_BOOL boolVal;
        /* [case()] */ _VARIANT_BOOL bool;
        /* [case()] */ SCODE scode;
        /* [case()] */ CY cyVal;
        /* [case()] */ DATE date;
        /* [case()] */ FILETIME filetime;
        /* [case()] */ CLSID *puuid;
        /* [case()] */ CLIPDATA *pclipdata;
        /* [case()] */ BSTR bstrVal;
        /* [case()] */ BSTRBLOB bstrblobVal;
        /* [case()] */ BLOB blob;
        /* [case()] */ LPSTR pszVal;
        /* [case()] */ LPWSTR pwszVal;
        /* [case()] */ IUnknown *punkVal;
        /* [case()] */ IDispatch *pdispVal;
        /* [case()] */ IStream *pStream;
        /* [case()] */ IStorage *pStorage;
        /* [case()] */ LPVERSIONEDSTREAM pVersionedStream;
        /* [case()] */ LPSAFEARRAY parray;
        /* [case()] */ CAC cac;
        /* [case()] */ CAUB caub;
        /* [case()] */ CAI cai;
        /* [case()] */ CAUI caui;
        /* [case()] */ CAL cal;
        /* [case()] */ CAUL caul;
        /* [case()] */ CAH cah;
        /* [case()] */ CAUH cauh;
        /* [case()] */ CAFLT caflt;
        /* [case()] */ CADBL cadbl;
        /* [case()] */ CABOOL cabool;
        /* [case()] */ CASCODE cascode;
        /* [case()] */ CACY cacy;
        /* [case()] */ CADATE cadate;
        /* [case()] */ CAFILETIME cafiletime;
        /* [case()] */ CACLSID cauuid;
        /* [case()] */ CACLIPDATA caclipdata;
        /* [case()] */ CABSTR cabstr;
        /* [case()] */ CABSTRBLOB cabstrblob;
        /* [case()] */ CALPSTR calpstr;
        /* [case()] */ CALPWSTR calpwstr;
        /* [case()] */ CAPROPVARIANT capropvar;
        /* [case()] */ CHAR *pcVal;
        /* [case()] */ UCHAR *pbVal;
        /* [case()] */ SHORT *piVal;
        /* [case()] */ USHORT *puiVal;
        /* [case()] */ LONG *plVal;
        /* [case()] */ ULONG *pulVal;
        /* [case()] */ INT *pintVal;
        /* [case()] */ UINT *puintVal;
        /* [case()] */ FLOAT *pfltVal;
        /* [case()] */ DOUBLE *pdblVal;
        /* [case()] */ VARIANT_BOOL *pboolVal;
        /* [case()] */ DECIMAL *pdecVal;
        /* [case()] */ SCODE *pscode;
        /* [case()] */ CY *pcyVal;
        /* [case()] */ DATE *pdate;
        /* [case()] */ BSTR *pbstrVal;
        /* [case()] */ IUnknown **ppunkVal;
        /* [case()] */ IDispatch **ppdispVal;
        /* [case()] */ LPSAFEARRAY *pparray;
        /* [case()] */ PROPVARIANT *pvarVal;
        } 	;
    } ;
#ifndef MIDL_PASS
    DECIMAL decVal;
  };
};
#endif
#ifdef MIDL_PASS
// This is the LPPROPVARIANT definition for marshaling.
typedef struct tag_inner_PROPVARIANT *LPPROPVARIANT;

#else
// This is the standard C layout of the PROPVARIANT.
typedef struct tagPROPVARIANT * LPPROPVARIANT;
#endif
// Reserved global Property IDs
#define	PID_DICTIONARY	( 0 )

#define	PID_CODEPAGE	( 0x1 )

#define	PID_FIRST_USABLE	( 0x2 )

#define	PID_FIRST_NAME_DEFAULT	( 0xfff )

#define	PID_LOCALE	( 0x80000000 )

#define	PID_MODIFY_TIME	( 0x80000001 )

#define	PID_SECURITY	( 0x80000002 )

#define	PID_BEHAVIOR	( 0x80000003 )

#define	PID_ILLEGAL	( 0xffffffff )

// Range which is read-only to downlevel implementations
#define	PID_MIN_READONLY	( 0x80000000 )

#define	PID_MAX_READONLY	( 0xbfffffff )

// Property IDs for the DiscardableInformation Property Set

#define PIDDI_THUMBNAIL          0x00000002L // VT_BLOB

// Property IDs for the SummaryInformation Property Set

#define PIDSI_TITLE               0x00000002L  // VT_LPSTR
#define PIDSI_SUBJECT             0x00000003L  // VT_LPSTR
#define PIDSI_AUTHOR              0x00000004L  // VT_LPSTR
#define PIDSI_KEYWORDS            0x00000005L  // VT_LPSTR
#define PIDSI_COMMENTS            0x00000006L  // VT_LPSTR
#define PIDSI_TEMPLATE            0x00000007L  // VT_LPSTR
#define PIDSI_LASTAUTHOR          0x00000008L  // VT_LPSTR
#define PIDSI_REVNUMBER           0x00000009L  // VT_LPSTR
#define PIDSI_EDITTIME            0x0000000aL  // VT_FILETIME (UTC)
#define PIDSI_LASTPRINTED         0x0000000bL  // VT_FILETIME (UTC)
#define PIDSI_CREATE_DTM          0x0000000cL  // VT_FILETIME (UTC)
#define PIDSI_LASTSAVE_DTM        0x0000000dL  // VT_FILETIME (UTC)
#define PIDSI_PAGECOUNT           0x0000000eL  // VT_I4
#define PIDSI_WORDCOUNT           0x0000000fL  // VT_I4
#define PIDSI_CHARCOUNT           0x00000010L  // VT_I4
#define PIDSI_THUMBNAIL           0x00000011L  // VT_CF
#define PIDSI_APPNAME             0x00000012L  // VT_LPSTR
#define PIDSI_DOC_SECURITY        0x00000013L  // VT_I4

// Property IDs for the DocSummaryInformation Property Set

#define PIDDSI_CATEGORY          0x00000002 // VT_LPSTR
#define PIDDSI_PRESFORMAT        0x00000003 // VT_LPSTR
#define PIDDSI_BYTECOUNT         0x00000004 // VT_I4
#define PIDDSI_LINECOUNT         0x00000005 // VT_I4
#define PIDDSI_PARCOUNT          0x00000006 // VT_I4
#define PIDDSI_SLIDECOUNT        0x00000007 // VT_I4
#define PIDDSI_NOTECOUNT         0x00000008 // VT_I4
#define PIDDSI_HIDDENCOUNT       0x00000009 // VT_I4
#define PIDDSI_MMCLIPCOUNT       0x0000000A // VT_I4
#define PIDDSI_SCALE             0x0000000B // VT_BOOL
#define PIDDSI_HEADINGPAIR       0x0000000C // VT_VARIANT | VT_VECTOR
#define PIDDSI_DOCPARTS          0x0000000D // VT_LPSTR | VT_VECTOR
#define PIDDSI_MANAGER           0x0000000E // VT_LPSTR
#define PIDDSI_COMPANY           0x0000000F // VT_LPSTR
#define PIDDSI_LINKSDIRTY        0x00000010 // VT_BOOL


//  FMTID_MediaFileSummaryInfo - Property IDs

#define PIDMSI_EDITOR                   0x00000002L  // VT_LPWSTR
#define PIDMSI_SUPPLIER                 0x00000003L  // VT_LPWSTR
#define PIDMSI_SOURCE                   0x00000004L  // VT_LPWSTR
#define PIDMSI_SEQUENCE_NO              0x00000005L  // VT_LPWSTR
#define PIDMSI_PROJECT                  0x00000006L  // VT_LPWSTR
#define PIDMSI_STATUS                   0x00000007L  // VT_UI4
#define PIDMSI_OWNER                    0x00000008L  // VT_LPWSTR
#define PIDMSI_RATING                   0x00000009L  // VT_LPWSTR
#define PIDMSI_PRODUCTION               0x0000000AL  // VT_FILETIME (UTC)
#define PIDMSI_COPYRIGHT                0x0000000BL  // VT_LPWSTR

//  PIDMSI_STATUS value definitions

enum PIDMSI_STATUS_VALUE
    {	PIDMSI_STATUS_NORMAL	= 0,
	PIDMSI_STATUS_NEW	= PIDMSI_STATUS_NORMAL + 1,
	PIDMSI_STATUS_PRELIM	= PIDMSI_STATUS_NEW + 1,
	PIDMSI_STATUS_DRAFT	= PIDMSI_STATUS_PRELIM + 1,
	PIDMSI_STATUS_INPROGRESS	= PIDMSI_STATUS_DRAFT + 1,
	PIDMSI_STATUS_EDIT	= PIDMSI_STATUS_INPROGRESS + 1,
	PIDMSI_STATUS_REVIEW	= PIDMSI_STATUS_EDIT + 1,
	PIDMSI_STATUS_PROOF	= PIDMSI_STATUS_REVIEW + 1,
	PIDMSI_STATUS_FINAL	= PIDMSI_STATUS_PROOF + 1,
	PIDMSI_STATUS_OTHER	= 0x7fff
    } ;
#define	PRSPEC_INVALID	( 0xffffffff )

#define	PRSPEC_LPWSTR	( 0 )

#define	PRSPEC_PROPID	( 1 )

typedef struct tagPROPSPEC
    {
    ULONG ulKind;
    /* [switch_is] */ /* [switch_type] */ union 
        {
        /* [case()] */ PROPID propid;
        /* [case()] */ LPOLESTR lpwstr;
        /* [default] */  /* Empty union arm */ 
        } 	;
    } 	PROPSPEC;

typedef struct tagSTATPROPSTG
    {
    LPOLESTR lpwstrName;
    PROPID propid;
    VARTYPE vt;
    } 	STATPROPSTG;

// Macros for parsing the OS Version of the Property Set Header
#define PROPSETHDR_OSVER_KIND(dwOSVer)      HIWORD( (dwOSVer) )
#define PROPSETHDR_OSVER_MAJOR(dwOSVer)     LOBYTE(LOWORD( (dwOSVer) ))
#define PROPSETHDR_OSVER_MINOR(dwOSVer)     HIBYTE(LOWORD( (dwOSVer) ))
#define PROPSETHDR_OSVERSION_UNKNOWN        0xFFFFFFFF
typedef struct tagSTATPROPSETSTG
    {
    FMTID fmtid;
    CLSID clsid;
    DWORD grfFlags;
    FILETIME mtime;
    FILETIME ctime;
    FILETIME atime;
    DWORD dwOSVersion;
    } 	STATPROPSETSTG;



extern RPC_IF_HANDLE __MIDL_itf_propidl_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propidl_0000_v0_0_s_ifspec;

#ifndef __IPropertyStorage_INTERFACE_DEFINED__
#define __IPropertyStorage_INTERFACE_DEFINED__

/* interface IPropertyStorage */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IPropertyStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000138-0000-0000-C000-000000000046")
    IPropertyStorage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReadMultiple( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ const PROPSPEC rgpspec[  ],
            /* [size_is][out] */ PROPVARIANT rgpropvar[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteMultiple( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ const PROPSPEC rgpspec[  ],
            /* [size_is][in] */ const PROPVARIANT rgpropvar[  ],
            /* [in] */ PROPID propidNameFirst) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteMultiple( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ const PROPSPEC rgpspec[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadPropertyNames( 
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ const PROPID rgpropid[  ],
            /* [size_is][out] */ LPOLESTR rglpwstrName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WritePropertyNames( 
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ const PROPID rgpropid[  ],
            /* [size_is][in] */ const LPOLESTR rglpwstrName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeletePropertyNames( 
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ const PROPID rgpropid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ DWORD grfCommitFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Revert( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enum( 
            /* [out] */ IEnumSTATPROPSTG **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimes( 
            /* [in] */ const FILETIME *pctime,
            /* [in] */ const FILETIME *patime,
            /* [in] */ const FILETIME *pmtime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClass( 
            /* [in] */ REFCLSID clsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stat( 
            /* [out] */ STATPROPSETSTG *pstatpsstg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyStorage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyStorage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyStorage * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReadMultiple )( 
            IPropertyStorage * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ const PROPSPEC rgpspec[  ],
            /* [size_is][out] */ PROPVARIANT rgpropvar[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *WriteMultiple )( 
            IPropertyStorage * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ const PROPSPEC rgpspec[  ],
            /* [size_is][in] */ const PROPVARIANT rgpropvar[  ],
            /* [in] */ PROPID propidNameFirst);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteMultiple )( 
            IPropertyStorage * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ const PROPSPEC rgpspec[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ReadPropertyNames )( 
            IPropertyStorage * This,
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ const PROPID rgpropid[  ],
            /* [size_is][out] */ LPOLESTR rglpwstrName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *WritePropertyNames )( 
            IPropertyStorage * This,
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ const PROPID rgpropid[  ],
            /* [size_is][in] */ const LPOLESTR rglpwstrName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *DeletePropertyNames )( 
            IPropertyStorage * This,
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ const PROPID rgpropid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IPropertyStorage * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Revert )( 
            IPropertyStorage * This);
        
        HRESULT ( STDMETHODCALLTYPE *Enum )( 
            IPropertyStorage * This,
            /* [out] */ IEnumSTATPROPSTG **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimes )( 
            IPropertyStorage * This,
            /* [in] */ const FILETIME *pctime,
            /* [in] */ const FILETIME *patime,
            /* [in] */ const FILETIME *pmtime);
        
        HRESULT ( STDMETHODCALLTYPE *SetClass )( 
            IPropertyStorage * This,
            /* [in] */ REFCLSID clsid);
        
        HRESULT ( STDMETHODCALLTYPE *Stat )( 
            IPropertyStorage * This,
            /* [out] */ STATPROPSETSTG *pstatpsstg);
        
        END_INTERFACE
    } IPropertyStorageVtbl;

    interface IPropertyStorage
    {
        CONST_VTBL struct IPropertyStorageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyStorage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertyStorage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropertyStorage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropertyStorage_ReadMultiple(This,cpspec,rgpspec,rgpropvar)	\
    (This)->lpVtbl -> ReadMultiple(This,cpspec,rgpspec,rgpropvar)

#define IPropertyStorage_WriteMultiple(This,cpspec,rgpspec,rgpropvar,propidNameFirst)	\
    (This)->lpVtbl -> WriteMultiple(This,cpspec,rgpspec,rgpropvar,propidNameFirst)

#define IPropertyStorage_DeleteMultiple(This,cpspec,rgpspec)	\
    (This)->lpVtbl -> DeleteMultiple(This,cpspec,rgpspec)

#define IPropertyStorage_ReadPropertyNames(This,cpropid,rgpropid,rglpwstrName)	\
    (This)->lpVtbl -> ReadPropertyNames(This,cpropid,rgpropid,rglpwstrName)

#define IPropertyStorage_WritePropertyNames(This,cpropid,rgpropid,rglpwstrName)	\
    (This)->lpVtbl -> WritePropertyNames(This,cpropid,rgpropid,rglpwstrName)

#define IPropertyStorage_DeletePropertyNames(This,cpropid,rgpropid)	\
    (This)->lpVtbl -> DeletePropertyNames(This,cpropid,rgpropid)

#define IPropertyStorage_Commit(This,grfCommitFlags)	\
    (This)->lpVtbl -> Commit(This,grfCommitFlags)

#define IPropertyStorage_Revert(This)	\
    (This)->lpVtbl -> Revert(This)

#define IPropertyStorage_Enum(This,ppenum)	\
    (This)->lpVtbl -> Enum(This,ppenum)

#define IPropertyStorage_SetTimes(This,pctime,patime,pmtime)	\
    (This)->lpVtbl -> SetTimes(This,pctime,patime,pmtime)

#define IPropertyStorage_SetClass(This,clsid)	\
    (This)->lpVtbl -> SetClass(This,clsid)

#define IPropertyStorage_Stat(This,pstatpsstg)	\
    (This)->lpVtbl -> Stat(This,pstatpsstg)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPropertyStorage_ReadMultiple_Proxy( 
    IPropertyStorage * This,
    /* [in] */ ULONG cpspec,
    /* [size_is][in] */ const PROPSPEC rgpspec[  ],
    /* [size_is][out] */ PROPVARIANT rgpropvar[  ]);


void __RPC_STUB IPropertyStorage_ReadMultiple_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyStorage_WriteMultiple_Proxy( 
    IPropertyStorage * This,
    /* [in] */ ULONG cpspec,
    /* [size_is][in] */ const PROPSPEC rgpspec[  ],
    /* [size_is][in] */ const PROPVARIANT rgpropvar[  ],
    /* [in] */ PROPID propidNameFirst);


void __RPC_STUB IPropertyStorage_WriteMultiple_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyStorage_DeleteMultiple_Proxy( 
    IPropertyStorage * This,
    /* [in] */ ULONG cpspec,
    /* [size_is][in] */ const PROPSPEC rgpspec[  ]);


void __RPC_STUB IPropertyStorage_DeleteMultiple_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyStorage_ReadPropertyNames_Proxy( 
    IPropertyStorage * This,
    /* [in] */ ULONG cpropid,
    /* [size_is][in] */ const PROPID rgpropid[  ],
    /* [size_is][out] */ LPOLESTR rglpwstrName[  ]);


void __RPC_STUB IPropertyStorage_ReadPropertyNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyStorage_WritePropertyNames_Proxy( 
    IPropertyStorage * This,
    /* [in] */ ULONG cpropid,
    /* [size_is][in] */ const PROPID rgpropid[  ],
    /* [size_is][in] */ const LPOLESTR rglpwstrName[  ]);


void __RPC_STUB IPropertyStorage_WritePropertyNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyStorage_DeletePropertyNames_Proxy( 
    IPropertyStorage * This,
    /* [in] */ ULONG cpropid,
    /* [size_is][in] */ const PROPID rgpropid[  ]);


void __RPC_STUB IPropertyStorage_DeletePropertyNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyStorage_Commit_Proxy( 
    IPropertyStorage * This,
    /* [in] */ DWORD grfCommitFlags);


void __RPC_STUB IPropertyStorage_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyStorage_Revert_Proxy( 
    IPropertyStorage * This);


void __RPC_STUB IPropertyStorage_Revert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyStorage_Enum_Proxy( 
    IPropertyStorage * This,
    /* [out] */ IEnumSTATPROPSTG **ppenum);


void __RPC_STUB IPropertyStorage_Enum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyStorage_SetTimes_Proxy( 
    IPropertyStorage * This,
    /* [in] */ const FILETIME *pctime,
    /* [in] */ const FILETIME *patime,
    /* [in] */ const FILETIME *pmtime);


void __RPC_STUB IPropertyStorage_SetTimes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyStorage_SetClass_Proxy( 
    IPropertyStorage * This,
    /* [in] */ REFCLSID clsid);


void __RPC_STUB IPropertyStorage_SetClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyStorage_Stat_Proxy( 
    IPropertyStorage * This,
    /* [out] */ STATPROPSETSTG *pstatpsstg);


void __RPC_STUB IPropertyStorage_Stat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertyStorage_INTERFACE_DEFINED__ */


#ifndef __IPropertySetStorage_INTERFACE_DEFINED__
#define __IPropertySetStorage_INTERFACE_DEFINED__

/* interface IPropertySetStorage */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IPropertySetStorage *LPPROPERTYSETSTORAGE;


EXTERN_C const IID IID_IPropertySetStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0000013A-0000-0000-C000-000000000046")
    IPropertySetStorage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ REFFMTID rfmtid,
            /* [unique][in] */ const CLSID *pclsid,
            /* [in] */ DWORD grfFlags,
            /* [in] */ DWORD grfMode,
            /* [out] */ IPropertyStorage **ppprstg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ REFFMTID rfmtid,
            /* [in] */ DWORD grfMode,
            /* [out] */ IPropertyStorage **ppprstg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ REFFMTID rfmtid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enum( 
            /* [out] */ IEnumSTATPROPSETSTG **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertySetStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertySetStorage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertySetStorage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertySetStorage * This);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            IPropertySetStorage * This,
            /* [in] */ REFFMTID rfmtid,
            /* [unique][in] */ const CLSID *pclsid,
            /* [in] */ DWORD grfFlags,
            /* [in] */ DWORD grfMode,
            /* [out] */ IPropertyStorage **ppprstg);
        
        HRESULT ( STDMETHODCALLTYPE *Open )( 
            IPropertySetStorage * This,
            /* [in] */ REFFMTID rfmtid,
            /* [in] */ DWORD grfMode,
            /* [out] */ IPropertyStorage **ppprstg);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IPropertySetStorage * This,
            /* [in] */ REFFMTID rfmtid);
        
        HRESULT ( STDMETHODCALLTYPE *Enum )( 
            IPropertySetStorage * This,
            /* [out] */ IEnumSTATPROPSETSTG **ppenum);
        
        END_INTERFACE
    } IPropertySetStorageVtbl;

    interface IPropertySetStorage
    {
        CONST_VTBL struct IPropertySetStorageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertySetStorage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertySetStorage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropertySetStorage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropertySetStorage_Create(This,rfmtid,pclsid,grfFlags,grfMode,ppprstg)	\
    (This)->lpVtbl -> Create(This,rfmtid,pclsid,grfFlags,grfMode,ppprstg)

#define IPropertySetStorage_Open(This,rfmtid,grfMode,ppprstg)	\
    (This)->lpVtbl -> Open(This,rfmtid,grfMode,ppprstg)

#define IPropertySetStorage_Delete(This,rfmtid)	\
    (This)->lpVtbl -> Delete(This,rfmtid)

#define IPropertySetStorage_Enum(This,ppenum)	\
    (This)->lpVtbl -> Enum(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPropertySetStorage_Create_Proxy( 
    IPropertySetStorage * This,
    /* [in] */ REFFMTID rfmtid,
    /* [unique][in] */ const CLSID *pclsid,
    /* [in] */ DWORD grfFlags,
    /* [in] */ DWORD grfMode,
    /* [out] */ IPropertyStorage **ppprstg);


void __RPC_STUB IPropertySetStorage_Create_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertySetStorage_Open_Proxy( 
    IPropertySetStorage * This,
    /* [in] */ REFFMTID rfmtid,
    /* [in] */ DWORD grfMode,
    /* [out] */ IPropertyStorage **ppprstg);


void __RPC_STUB IPropertySetStorage_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertySetStorage_Delete_Proxy( 
    IPropertySetStorage * This,
    /* [in] */ REFFMTID rfmtid);


void __RPC_STUB IPropertySetStorage_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertySetStorage_Enum_Proxy( 
    IPropertySetStorage * This,
    /* [out] */ IEnumSTATPROPSETSTG **ppenum);


void __RPC_STUB IPropertySetStorage_Enum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertySetStorage_INTERFACE_DEFINED__ */


#ifndef __IEnumSTATPROPSTG_INTERFACE_DEFINED__
#define __IEnumSTATPROPSTG_INTERFACE_DEFINED__

/* interface IEnumSTATPROPSTG */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IEnumSTATPROPSTG *LPENUMSTATPROPSTG;


EXTERN_C const IID IID_IEnumSTATPROPSTG;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000139-0000-0000-C000-000000000046")
    IEnumSTATPROPSTG : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ STATPROPSTG *rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumSTATPROPSTG **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumSTATPROPSTGVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumSTATPROPSTG * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumSTATPROPSTG * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumSTATPROPSTG * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumSTATPROPSTG * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ STATPROPSTG *rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumSTATPROPSTG * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumSTATPROPSTG * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumSTATPROPSTG * This,
            /* [out] */ IEnumSTATPROPSTG **ppenum);
        
        END_INTERFACE
    } IEnumSTATPROPSTGVtbl;

    interface IEnumSTATPROPSTG
    {
        CONST_VTBL struct IEnumSTATPROPSTGVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumSTATPROPSTG_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumSTATPROPSTG_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumSTATPROPSTG_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumSTATPROPSTG_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumSTATPROPSTG_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumSTATPROPSTG_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumSTATPROPSTG_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumSTATPROPSTG_RemoteNext_Proxy( 
    IEnumSTATPROPSTG * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATPROPSTG *rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IEnumSTATPROPSTG_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumSTATPROPSTG_Skip_Proxy( 
    IEnumSTATPROPSTG * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumSTATPROPSTG_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumSTATPROPSTG_Reset_Proxy( 
    IEnumSTATPROPSTG * This);


void __RPC_STUB IEnumSTATPROPSTG_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumSTATPROPSTG_Clone_Proxy( 
    IEnumSTATPROPSTG * This,
    /* [out] */ IEnumSTATPROPSTG **ppenum);


void __RPC_STUB IEnumSTATPROPSTG_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumSTATPROPSTG_INTERFACE_DEFINED__ */


#ifndef __IEnumSTATPROPSETSTG_INTERFACE_DEFINED__
#define __IEnumSTATPROPSETSTG_INTERFACE_DEFINED__

/* interface IEnumSTATPROPSETSTG */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IEnumSTATPROPSETSTG *LPENUMSTATPROPSETSTG;


EXTERN_C const IID IID_IEnumSTATPROPSETSTG;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0000013B-0000-0000-C000-000000000046")
    IEnumSTATPROPSETSTG : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ STATPROPSETSTG *rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumSTATPROPSETSTG **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumSTATPROPSETSTGVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumSTATPROPSETSTG * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumSTATPROPSETSTG * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumSTATPROPSETSTG * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumSTATPROPSETSTG * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ STATPROPSETSTG *rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumSTATPROPSETSTG * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumSTATPROPSETSTG * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumSTATPROPSETSTG * This,
            /* [out] */ IEnumSTATPROPSETSTG **ppenum);
        
        END_INTERFACE
    } IEnumSTATPROPSETSTGVtbl;

    interface IEnumSTATPROPSETSTG
    {
        CONST_VTBL struct IEnumSTATPROPSETSTGVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumSTATPROPSETSTG_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumSTATPROPSETSTG_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumSTATPROPSETSTG_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumSTATPROPSETSTG_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumSTATPROPSETSTG_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumSTATPROPSETSTG_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumSTATPROPSETSTG_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumSTATPROPSETSTG_RemoteNext_Proxy( 
    IEnumSTATPROPSETSTG * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATPROPSETSTG *rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IEnumSTATPROPSETSTG_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumSTATPROPSETSTG_Skip_Proxy( 
    IEnumSTATPROPSETSTG * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumSTATPROPSETSTG_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumSTATPROPSETSTG_Reset_Proxy( 
    IEnumSTATPROPSETSTG * This);


void __RPC_STUB IEnumSTATPROPSETSTG_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumSTATPROPSETSTG_Clone_Proxy( 
    IEnumSTATPROPSETSTG * This,
    /* [out] */ IEnumSTATPROPSETSTG **ppenum);


void __RPC_STUB IEnumSTATPROPSETSTG_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumSTATPROPSETSTG_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_propidl_0120 */
/* [local] */ 

typedef /* [unique] */ IPropertyStorage *LPPROPERTYSTORAGE;

WINOLEAPI PropVariantCopy ( PROPVARIANT * pvarDest, const PROPVARIANT * pvarSrc );
WINOLEAPI PropVariantClear ( PROPVARIANT * pvar );
WINOLEAPI FreePropVariantArray ( ULONG cVariants, PROPVARIANT * rgvars );

#define _PROPVARIANTINIT_DEFINED_
#   ifdef __cplusplus
inline void PropVariantInit ( PROPVARIANT * pvar )
{
    memset ( pvar, 0, sizeof(PROPVARIANT) );
}
#   else
#   define PropVariantInit(pvar) memset ( (pvar), 0, sizeof(PROPVARIANT) )
#   endif


#ifndef _STGCREATEPROPSTG_DEFINED_
WINOLEAPI StgCreatePropStg( IUnknown* pUnk, REFFMTID fmtid, const CLSID *pclsid, DWORD grfFlags, DWORD dwReserved, IPropertyStorage **ppPropStg );
WINOLEAPI StgOpenPropStg( IUnknown* pUnk, REFFMTID fmtid, DWORD grfFlags, DWORD dwReserved, IPropertyStorage **ppPropStg );
WINOLEAPI StgCreatePropSetStg( IStorage *pStorage, DWORD dwReserved, IPropertySetStorage **ppPropSetStg);

#define CCH_MAX_PROPSTG_NAME    31
WINOLEAPI FmtIdToPropStgName( const FMTID *pfmtid, LPOLESTR oszName );
WINOLEAPI PropStgNameToFmtId( const LPOLESTR oszName, FMTID *pfmtid );
#endif
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)    /* Nameless struct/union */
#pragma warning(default:4237)    /* keywords bool, true, false, etc.. */
#endif


extern RPC_IF_HANDLE __MIDL_itf_propidl_0120_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propidl_0120_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumSTATPROPSTG_Next_Proxy( 
    IEnumSTATPROPSTG * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATPROPSTG *rgelt,
    /* [out] */ ULONG *pceltFetched);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumSTATPROPSTG_Next_Stub( 
    IEnumSTATPROPSTG * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATPROPSTG *rgelt,
    /* [out] */ ULONG *pceltFetched);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumSTATPROPSETSTG_Next_Proxy( 
    IEnumSTATPROPSETSTG * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATPROPSETSTG *rgelt,
    /* [out] */ ULONG *pceltFetched);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumSTATPROPSETSTG_Next_Stub( 
    IEnumSTATPROPSETSTG * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATPROPSETSTG *rgelt,
    /* [out] */ ULONG *pceltFetched);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\pshpck16.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack8.h

Abstract:

    This file turns 8 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 ) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push,16)
#else
#pragma pack(16)
#endif
#else
#pragma pack(16)
#endif
#endif // ! (defined(lint) || defined(RC_INVOKED))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\provider.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  Provider.h
//
//  Purpose: declaration of Provider class
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _PROVIDER_H__
#define _PROVIDER_H__

/////////////////////////////////////////////////////
// INSTANCE Provider
//
// pure virtual base class for providers
// holds instances
// gathers information and instantiates instances
/////////////////////////////////////////////////////
class POLARITY Provider : public CThreadBase
{
    // CWbemProviderGlue needs to access some protected/private methods
    // which we don't want to publish to just anyone.

    friend class CWbemProviderGlue;

    public:
        Provider( LPCWSTR a_pszName, LPCWSTR a_pszNameSpace = NULL );
        ~Provider();

    protected:
        /* Override These Methods To Implement Your Provider */
        
        // This is the entrypoint for changes.
        // You are handed a changed instance.
        // If you can make the changes - do so.
        // If you cannot return an appropriate error code (WBEM_E_XXXXXXX)
        // base object returns WBEM_E_PROVIDER_NOT_CAPABLE
        virtual HRESULT PutInstance(const CInstance& newInstance, long lFlags = 0L);

        // entrypoint to delete an instance
        // examine the instance passed in, determine whether you can delete it
        virtual HRESULT DeleteInstance(const CInstance& newInstance, long lFlags = 0L);

        // execute a method
        virtual HRESULT ExecMethod(const CInstance& cInstance, 
                                   const BSTR bstrMethodName, 
                                   CInstance *pInParams, 
                                   CInstance *pOutParams, 
                                   long lFlags = 0L);

        // find and create all instances of your class
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);

        // you will be given an object with the key properties filled in
        // you need to fill in all of the rest of the properties, or
        // return WBEM_E_NOT_FOUND if the object doesn't exist.
        virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);

        // You will be given an object with the key properties filled in.
        // You can either fill in all the properties, or check the Query object
        // to see what properties are required.  If you don't implement this method, the
        // GetObject(CInstance, long) method will be called instead.
        virtual HRESULT GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery &Query);

        // If a provider wants to process queries, they should override this
        virtual HRESULT ExecQuery(MethodContext *pMethodContext, 
                                  CFrameworkQuery& cQuery, 
                                  long lFlags = 0L);

        // flushes cache
        // only override if you allocate memory that could be flushed
        virtual void Flush(void);

        /* Helpers - Use These, Do Not Override */

        // allocate a new instance & return pointer to it
        // the memory is your responsibility to Release()
        // UNLESS you pass it off to Provider::Commit
        CInstance *CreateNewInstance(MethodContext *pMethodContext);

        // used to send your new instance back to the framework
        // set bCache to true to cache object 
        // !! caching is NOT IMPLEMENTED in this release !!
        // do not delete or release the pointer once committed.
        HRESULT Commit(CInstance *pInstance, bool bCache = false);

        // Helper function for building a WBEM Object Path for a local Instance
        bool GetLocalInstancePath( const CInstance *pInstance, CHString& strPath );

        //   Builds a full instance path from a relative path
        CHString MakeLocalPath( const CHString &strRelPath );

        // Returns the computer name as a CHString.  Save yourself the os call,
        // since we've got it hanging around anyway.
        const CHString &GetLocalComputerName() {return s_strComputerName;}
        const CHString &GetNamespace() {return m_strNameSpace;}

        // sets the CreationClassName property to the name of this provider
        bool SetCreationClassName(CInstance *pInstance);

        // accesses the name of the provider
        const CHString &GetProviderName() {return m_name;}

        // Flag validation constants
        enum FlagDefs
        {
            EnumerationFlags = (WBEM_FLAG_DIRECT_READ | WBEM_FLAG_SEND_STATUS),
            GetObjFlags = (WBEM_FLAG_SEND_STATUS | WBEM_FLAG_DIRECT_READ),
            MethodFlags = WBEM_FLAG_SEND_STATUS,
            DeletionFlags = WBEM_FLAG_SEND_STATUS,
            PutInstanceFlags = (WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_SEND_STATUS),
            QueryFlags = WBEM_FLAG_SEND_STATUS | WBEM_FLAG_DIRECT_READ
        };

        // returns WBEM_E_UNSUPPORTED_PARAMETER or WBEM_S_NO_ERROR
        HRESULT ValidateFlags(long lFlags, FlagDefs lAcceptableFlags);

        // you can override the following to support flags 
        // above and beyond those listed in FlagDefs above
        virtual HRESULT ValidateEnumerationFlags(long lFlags);
        virtual HRESULT ValidateGetObjFlags(long lFlags);
        virtual HRESULT ValidateMethodFlags(long lFlags);
        virtual HRESULT ValidateQueryFlags(long lFlags);
        virtual HRESULT ValidateDeletionFlags(long lFlags);
        virtual HRESULT ValidatePutInstanceFlags(long lFlags);
        
    private:

        IWbemServices       *m_pIMosProvider;    // provides instances
        CHString            m_name;             // name of this provider
        CHString            m_strNameSpace;     // name of this provider's namespace
        IWbemClassObject    *m_piClassObject;    // holds class object from which others are cloned.

        static CHString     s_strComputerName;  // Holds the computer name for building
                                                // instance paths.
        
        BOOL ValidateIMOSPointer( void );       // This function ensures that our IMOS
                                                // pointer is available, and is called
                                                // by the framework entrypoint functions

        /* Interfaces For Use by the Framework         */
        HRESULT GetObject(  ParsedObjectPath *pParsedObjectPath, 
                            MethodContext *pContext, long lFlags = 0L );

        HRESULT ExecuteQuery( MethodContext *pContext, 
                              CFrameworkQuery &pQuery, 
                              long lFlags = 0L);

        HRESULT CreateInstanceEnum( MethodContext *pContext, long lFlags = 0L );

        HRESULT PutInstance( IWbemClassObject __RPC_FAR *pInst,
                             long lFlags,
                             MethodContext *pContext );

        HRESULT DeleteInstance( ParsedObjectPath *pParsedObjectPath,
                                long lFlags,
                                MethodContext *pContext );

        HRESULT ExecMethod( ParsedObjectPath *pParsedObjectPath,
                            BSTR bstrMethodName,
                            long lFlags,
                            CInstance *pInParams,
                            CInstance *pOutParams,
                            MethodContext *pContext );

        // Static helper function called by constructor to make sure the
        // computer name variable is properly initialized.
        static void WINAPI InitComputerName( void );

        // Sets an instance key from a parsed object path.
        BOOL SetKeyFromParsedObjectPath( CInstance *pInstance, 
                                         ParsedObjectPath *pParsedObjectPath );

        IWbemClassObject *GetClassObjectInterface(MethodContext *pMethodContext);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\prsht.h ===
/*****************************************************************************\
*                                                                             *
* prsht.h - - Interface for the Windows Property Sheet Pages                  *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/

#ifndef _PRSHT_H_
#define _PRSHT_H_


#ifndef _WINRESRC_
#ifndef _WIN32_IE
#define _WIN32_IE 0x0501
#else
#if (_WIN32_IE < 0x0400) && defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0500)
#error _WIN32_IE setting conflicts with _WIN32_WINNT setting
#endif
#endif
#endif

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINCOMMCTRLAPI
#if !defined(_COMCTL32_) && defined(_WIN32)
#define WINCOMMCTRLAPI DECLSPEC_IMPORT
#else
#define WINCOMMCTRLAPI
#endif
#endif // WINCOMMCTRLAPI

#ifndef CCSIZEOF_STRUCT
#define CCSIZEOF_STRUCT(structname, member)  (((int)((LPBYTE)(&((structname*)0)->member) - ((LPBYTE)((structname*)0)))) + sizeof(((structname*)0)->member))
#endif

//
// For compilers that don't support nameless unions
//
#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME   u
#define DUMMYUNIONNAME2  u2
#define DUMMYUNIONNAME3  u3
#define DUMMYUNIONNAME4  u4
#define DUMMYUNIONNAME5  u5
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#define DUMMYUNIONNAME4
#define DUMMYUNIONNAME5
#endif
#endif // DUMMYUNIONNAME

#ifdef _WIN64
#include <pshpack8.h>
#else
#include <pshpack4.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif


#ifndef SNDMSG
#ifdef __cplusplus
#ifndef _MAC
#define SNDMSG ::SendMessage
#else
#define SNDMSG ::AfxSendMessage
#endif
#else
#ifndef _MAC
#define SNDMSG SendMessage
#else
#define SNDMSG AfxSendMessage
#endif
#endif
#endif // ifndef SNDMSG

#define MAXPROPPAGES            100

struct _PSP;
typedef struct _PSP * HPROPSHEETPAGE;

#ifndef MIDL_PASS
struct _PROPSHEETPAGEA;
struct _PROPSHEETPAGEW;
#endif

typedef UINT (CALLBACK *LPFNPSPCALLBACKA)(HWND hwnd, UINT uMsg, struct _PROPSHEETPAGEA *ppsp);
typedef UINT (CALLBACK *LPFNPSPCALLBACKW)(HWND hwnd, UINT uMsg, struct _PROPSHEETPAGEW *ppsp);

#ifdef UNICODE
#define LPFNPSPCALLBACK         LPFNPSPCALLBACKW
#else
#define LPFNPSPCALLBACK         LPFNPSPCALLBACKA
#endif

#define PSP_DEFAULT                0x00000000
#define PSP_DLGINDIRECT            0x00000001
#define PSP_USEHICON               0x00000002
#define PSP_USEICONID              0x00000004
#define PSP_USETITLE               0x00000008
#define PSP_RTLREADING             0x00000010

#define PSP_HASHELP                0x00000020
#define PSP_USEREFPARENT           0x00000040
#define PSP_USECALLBACK            0x00000080
#define PSP_PREMATURE              0x00000400

#if (_WIN32_IE >= 0x0400)
//----- New flags for wizard97 --------------
#define PSP_HIDEHEADER             0x00000800
#define PSP_USEHEADERTITLE         0x00001000
#define PSP_USEHEADERSUBTITLE      0x00002000
//-------------------------------------------
#endif
#if (_WIN32_WINNT >= 0x0501) || ISOLATION_AWARE_ENABLED
#define PSP_USEFUSIONCONTEXT       0x00004000
#endif


#if (_WIN32_IE >= 0x0500)
#define PSPCB_ADDREF            0
#endif
#define PSPCB_RELEASE           1
#define PSPCB_CREATE            2

#define PROPSHEETPAGEA_V1_SIZE CCSIZEOF_STRUCT(PROPSHEETPAGEA, pcRefParent)
#define PROPSHEETPAGEW_V1_SIZE CCSIZEOF_STRUCT(PROPSHEETPAGEW, pcRefParent)

#define PROPSHEETPAGEA_V2_SIZE CCSIZEOF_STRUCT(PROPSHEETPAGEA, pszHeaderSubTitle)
#define PROPSHEETPAGEW_V2_SIZE CCSIZEOF_STRUCT(PROPSHEETPAGEW, pszHeaderSubTitle)

#ifdef _WIN32
typedef LPCDLGTEMPLATE PROPSHEETPAGE_RESOURCE;
#else
typedef const VOID* PROPSHEETPAGE_RESOURCE;
#endif

#define PROPSHEETPAGEA_V1_FIELDS   \
    DWORD           dwSize;        \
    DWORD           dwFlags;       \
    HINSTANCE       hInstance;     \
    union                          \
    {                              \
        LPCSTR      pszTemplate;   \
        PROPSHEETPAGE_RESOURCE pResource; \
    } DUMMYUNIONNAME;              \
    union                          \
    {                              \
        HICON        hIcon;        \
        LPCSTR       pszIcon;      \
    } DUMMYUNIONNAME2;             \
    LPCSTR           pszTitle;     \
    DLGPROC          pfnDlgProc;   \
    LPARAM           lParam;       \
    LPFNPSPCALLBACKA pfnCallback;  \
    UINT             *pcRefParent; \

#define PROPSHEETPAGEW_V1_FIELDS   \
    DWORD           dwSize;        \
    DWORD           dwFlags;       \
    HINSTANCE       hInstance;     \
    union                          \
    {                              \
        LPCWSTR     pszTemplate;   \
        PROPSHEETPAGE_RESOURCE pResource; \
    } DUMMYUNIONNAME;              \
    union                          \
    {                              \
        HICON        hIcon;        \
        LPCWSTR      pszIcon;      \
    } DUMMYUNIONNAME2;             \
    LPCWSTR          pszTitle;     \
    DLGPROC          pfnDlgProc;   \
    LPARAM           lParam;       \
    LPFNPSPCALLBACKW pfnCallback;  \
    UINT             *pcRefParent; \

#if (_WIN32_WINNT >= 0x0501) || ISOLATION_AWARE_ENABLED
#define  _PROPSHEETPAGEA_V3 _PROPSHEETPAGEA
#define  _PROPSHEETPAGEW_V3 _PROPSHEETPAGEW
#elif (_WIN32_IE >= 0x0400)
#define  _PROPSHEETPAGEA_V2 _PROPSHEETPAGEA
#define  _PROPSHEETPAGEW_V2 _PROPSHEETPAGEW
#else
#define  _PROPSHEETPAGEA_V1 _PROPSHEETPAGEA
#define  _PROPSHEETPAGEW_V1 _PROPSHEETPAGEW
#endif

typedef struct _PROPSHEETPAGEA_V1
{
    PROPSHEETPAGEA_V1_FIELDS
} PROPSHEETPAGEA_V1, *LPPROPSHEETPAGEA_V1;
typedef const PROPSHEETPAGEA_V1 *LPCPROPSHEETPAGEA_V1;

typedef struct _PROPSHEETPAGEA_V2
{
    PROPSHEETPAGEA_V1_FIELDS

    LPCSTR           pszHeaderTitle;    // this is displayed in the header
    LPCSTR           pszHeaderSubTitle; //
} PROPSHEETPAGEA_V2, *LPPROPSHEETPAGEA_V2;
typedef const PROPSHEETPAGEA_V2 *LPCPROPSHEETPAGEA_V2;

typedef struct _PROPSHEETPAGEA_V3
{
    PROPSHEETPAGEA_V1_FIELDS

    LPCSTR           pszHeaderTitle;    // this is displayed in the header
    LPCSTR           pszHeaderSubTitle; //

    HANDLE           hActCtx;
} PROPSHEETPAGEA_V3, *LPPROPSHEETPAGEA_V3;
typedef const PROPSHEETPAGEA_V3 *LPCPROPSHEETPAGEA_V3;


typedef struct _PROPSHEETPAGEW_V1
{
    PROPSHEETPAGEW_V1_FIELDS
} PROPSHEETPAGEW_V1, *LPPROPSHEETPAGEW_V1;
typedef const PROPSHEETPAGEW_V1 *LPCPROPSHEETPAGEW_V1;

typedef struct _PROPSHEETPAGEW_V2
{
    PROPSHEETPAGEW_V1_FIELDS

    LPCWSTR           pszHeaderTitle;    // this is displayed in the header
    LPCWSTR           pszHeaderSubTitle; //
} PROPSHEETPAGEW_V2, *LPPROPSHEETPAGEW_V2;
typedef const PROPSHEETPAGEW_V2 *LPCPROPSHEETPAGEW_V2;

typedef struct _PROPSHEETPAGEW_V3
{
    PROPSHEETPAGEW_V1_FIELDS

    LPCWSTR           pszHeaderTitle;    // this is displayed in the header
    LPCWSTR           pszHeaderSubTitle; //

    HANDLE           hActCtx;
} PROPSHEETPAGEW_V3, *LPPROPSHEETPAGEW_V3;
typedef const PROPSHEETPAGEW_V3 *LPCPROPSHEETPAGEW_V3;

typedef    PROPSHEETPAGEA_V3    PROPSHEETPAGEA_LATEST;
typedef    PROPSHEETPAGEW_V3    PROPSHEETPAGEW_LATEST;
typedef  LPPROPSHEETPAGEA_V3  LPPROPSHEETPAGEA_LATEST;
typedef  LPPROPSHEETPAGEW_V3  LPPROPSHEETPAGEW_LATEST;
typedef LPCPROPSHEETPAGEA_V3 LPCPROPSHEETPAGEA_LATEST;
typedef LPCPROPSHEETPAGEW_V3 LPCPROPSHEETPAGEW_LATEST;

#if (_WIN32_WINNT >= 0x0501) || ISOLATION_AWARE_ENABLED
typedef    PROPSHEETPAGEA_V3    PROPSHEETPAGEA;
typedef    PROPSHEETPAGEW_V3    PROPSHEETPAGEW;
typedef  LPPROPSHEETPAGEA_V3  LPPROPSHEETPAGEA;
typedef  LPPROPSHEETPAGEW_V3  LPPROPSHEETPAGEW;
typedef LPCPROPSHEETPAGEA_V3 LPCPROPSHEETPAGEA;
typedef LPCPROPSHEETPAGEW_V3 LPCPROPSHEETPAGEW;
#elif (_WIN32_IE >= 0x0400)
typedef    PROPSHEETPAGEA_V2    PROPSHEETPAGEA;
typedef    PROPSHEETPAGEW_V2    PROPSHEETPAGEW;
typedef  LPPROPSHEETPAGEA_V2  LPPROPSHEETPAGEA;
typedef  LPPROPSHEETPAGEW_V2  LPPROPSHEETPAGEW;
typedef LPCPROPSHEETPAGEA_V2 LPCPROPSHEETPAGEA;
typedef LPCPROPSHEETPAGEW_V2 LPCPROPSHEETPAGEW;
#else
typedef    PROPSHEETPAGEA_V1    PROPSHEETPAGEA;
typedef    PROPSHEETPAGEW_V1    PROPSHEETPAGEW;
typedef  LPPROPSHEETPAGEA_V1  LPPROPSHEETPAGEA;
typedef  LPPROPSHEETPAGEW_V1  LPPROPSHEETPAGEW;
typedef LPCPROPSHEETPAGEA_V1 LPCPROPSHEETPAGEA;
typedef LPCPROPSHEETPAGEW_V1 LPCPROPSHEETPAGEW;
#endif

#if 0 // IEUNIX reserved.
/* Macros for the missing definitions.  */
/* Not all, because mostly used in C++. */
#if __STDC__ || defined (NONAMELESSUNION)
#   define PSP_pszTemplate(X) ((X).u.pszTemplate)
#else
#   define PSP_pszTemplate(X) ((X).pszTemplate)
#endif
#endif

#ifdef UNICODE
#define    PROPSHEETPAGE           PROPSHEETPAGEW
#define  LPPROPSHEETPAGE         LPPROPSHEETPAGEW
#define LPCPROPSHEETPAGE        LPCPROPSHEETPAGEW
#define    PROPSHEETPAGE_V1_SIZE   PROPSHEETPAGEW_V1_SIZE
#define    PROPSHEETPAGE_V2_SIZE   PROPSHEETPAGEW_V2_SIZE
#define    PROPSHEETPAGE_V1        PROPSHEETPAGEW_V1
#define  LPPROPSHEETPAGE_V1      LPPROPSHEETPAGEW_V1
#define LPCPROPSHEETPAGE_V1     LPCPROPSHEETPAGEW_V1
#define    PROPSHEETPAGE_V2        PROPSHEETPAGEW_V2
#define  LPPROPSHEETPAGE_V2      LPPROPSHEETPAGEW_V2
#define LPCPROPSHEETPAGE_V2     LPCPROPSHEETPAGEW_V2
#define    PROPSHEETPAGE_V3        PROPSHEETPAGEW_V3
#define  LPPROPSHEETPAGE_V3      LPPROPSHEETPAGEW_V3
#define LPCPROPSHEETPAGE_V3     LPCPROPSHEETPAGEW_V3
#define    PROPSHEETPAGE_LATEST    PROPSHEETPAGEW_LATEST
#define  LPPROPSHEETPAGE_LATEST  LPPROPSHEETPAGEW_LATEST
#define LPCPROPSHEETPAGE_LATEST LPCPROPSHEETPAGEW_LATEST
#else
#define    PROPSHEETPAGE           PROPSHEETPAGEA
#define  LPPROPSHEETPAGE         LPPROPSHEETPAGEA
#define LPCPROPSHEETPAGE        LPCPROPSHEETPAGEA
#define    PROPSHEETPAGE_V1_SIZE   PROPSHEETPAGEA_V1_SIZE
#define    PROPSHEETPAGE_V2_SIZE   PROPSHEETPAGEA_V2_SIZE
#define    PROPSHEETPAGE_V1        PROPSHEETPAGEA_V1
#define  LPPROPSHEETPAGE_V1      LPPROPSHEETPAGEA_V1
#define LPCPROPSHEETPAGE_V1     LPCPROPSHEETPAGEA_V1
#define    PROPSHEETPAGE_V2        PROPSHEETPAGEA_V2
#define  LPPROPSHEETPAGE_V2      LPPROPSHEETPAGEA_V2
#define LPCPROPSHEETPAGE_V2     LPCPROPSHEETPAGEA_V2
#define    PROPSHEETPAGE_V3        PROPSHEETPAGEA_V3
#define  LPPROPSHEETPAGE_V3      LPPROPSHEETPAGEA_V3
#define LPCPROPSHEETPAGE_V3     LPCPROPSHEETPAGEA_V3
#define    PROPSHEETPAGE_LATEST    PROPSHEETPAGEA_LATEST
#define  LPPROPSHEETPAGE_LATEST  LPPROPSHEETPAGEA_LATEST
#define LPCPROPSHEETPAGE_LATEST LPCPROPSHEETPAGEA_LATEST
#endif

#define PSH_DEFAULT             0x00000000
#define PSH_PROPTITLE           0x00000001
#define PSH_USEHICON            0x00000002
#define PSH_USEICONID           0x00000004
#define PSH_PROPSHEETPAGE       0x00000008
#define PSH_WIZARDHASFINISH     0x00000010
#define PSH_WIZARD              0x00000020
#define PSH_USEPSTARTPAGE       0x00000040
#define PSH_NOAPPLYNOW          0x00000080
#define PSH_USECALLBACK         0x00000100
#define PSH_HASHELP             0x00000200
#define PSH_MODELESS            0x00000400
#define PSH_RTLREADING          0x00000800
#define PSH_WIZARDCONTEXTHELP   0x00001000

#if (_WIN32_IE >= 0x0400)
//----- New flags for wizard97 -----------
#if (_WIN32_IE < 0x0500)
#define PSH_WIZARD97            0x00002000
#else
#define PSH_WIZARD97            0x01000000
#endif
// 0x00004000 was not used by any previous release
#define PSH_WATERMARK           0x00008000
#define PSH_USEHBMWATERMARK     0x00010000  // user pass in a hbmWatermark instead of pszbmWatermark
#define PSH_USEHPLWATERMARK     0x00020000  //
#define PSH_STRETCHWATERMARK    0x00040000  // stretchwatermark also applies for the header
#define PSH_HEADER              0x00080000
#define PSH_USEHBMHEADER        0x00100000
#define PSH_USEPAGELANG         0x00200000  // use frame dialog template matched to page
//----------------------------------------
#endif

#if (_WIN32_IE >= 0x0500)
//----- New flags for wizard-lite --------
#define PSH_WIZARD_LITE         0x00400000
#define PSH_NOCONTEXTHELP       0x02000000
//----------------------------------------
#endif


typedef int (CALLBACK *PFNPROPSHEETCALLBACK)(HWND, UINT, LPARAM);

#define PROPSHEETHEADERA_V1_SIZE CCSIZEOF_STRUCT(PROPSHEETHEADERA, pfnCallback)
#define PROPSHEETHEADERW_V1_SIZE CCSIZEOF_STRUCT(PROPSHEETHEADERW, pfnCallback)

#define PROPSHEETHEADERA_V2_SIZE CCSIZEOF_STRUCT(PROPSHEETHEADERA, DUMMYUNION5_MEMBER(hbmHeader))
#define PROPSHEETHEADERW_V2_SIZE CCSIZEOF_STRUCT(PROPSHEETHEADERW, DUMMYUNION5_MEMBER(hbmHeader))

typedef struct _PROPSHEETHEADERA 
{
        DWORD           dwSize;
        DWORD           dwFlags;
        HWND            hwndParent;
        HINSTANCE       hInstance;
        union 
        {
            HICON       hIcon;
            LPCSTR      pszIcon;
        } DUMMYUNIONNAME;
        LPCSTR          pszCaption;

        UINT            nPages;
        union 
        {
            UINT        nStartPage;
            LPCSTR      pStartPage;
        } DUMMYUNIONNAME2;
        union 
        {
            LPCPROPSHEETPAGEA ppsp;
            HPROPSHEETPAGE *phpage;
        } DUMMYUNIONNAME3;
        PFNPROPSHEETCALLBACK pfnCallback;

#if (_WIN32_IE >= 0x0400)
        union 
        {
            HBITMAP hbmWatermark;
            LPCSTR pszbmWatermark;
        } DUMMYUNIONNAME4;
        HPALETTE hplWatermark;
        union 
        {
            HBITMAP hbmHeader;     // Header  bitmap shares the palette with watermark
            LPCSTR pszbmHeader;
        } DUMMYUNIONNAME5;
#endif
} PROPSHEETHEADERA, *LPPROPSHEETHEADERA;

typedef const PROPSHEETHEADERA *LPCPROPSHEETHEADERA;

typedef struct _PROPSHEETHEADERW 
{
        DWORD           dwSize;
        DWORD           dwFlags;
        HWND            hwndParent;
        HINSTANCE       hInstance;
        union 
        {
            HICON       hIcon;
            LPCWSTR     pszIcon;
        } DUMMYUNIONNAME;
        LPCWSTR         pszCaption;


        UINT            nPages;
        union 
        {
            UINT        nStartPage;
            LPCWSTR     pStartPage;
        } DUMMYUNIONNAME2;
        union 
        {
            LPCPROPSHEETPAGEW ppsp;
            HPROPSHEETPAGE *phpage;
        } DUMMYUNIONNAME3;
        PFNPROPSHEETCALLBACK pfnCallback;

#if (_WIN32_IE >= 0x0400)
        union 
        {
            HBITMAP hbmWatermark;
            LPCWSTR pszbmWatermark;
        } DUMMYUNIONNAME4;
        HPALETTE hplWatermark;
        union 
        {
            HBITMAP hbmHeader;
            LPCWSTR pszbmHeader;
        } DUMMYUNIONNAME5;
#endif
} PROPSHEETHEADERW, *LPPROPSHEETHEADERW;
typedef const PROPSHEETHEADERW *LPCPROPSHEETHEADERW;

#if 0 //IEUNIX reserved.
/* Macros for the missing definitions.  */
/* Not all, because mostly used in C++. */
#if __STDC__ || defined (NONAMELESSUNION)
#   define PSH_nStartPage(X) ((X).u2.nStartPage)
#   define PSH_ppsp(X)       ((X).u3.ppsp)
#else
#   define PSH_nStartPage(X) ((X).nStartPage)
#   define PSH_ppsp(X)       ((X).ppsp)
#endif
#endif

#ifdef UNICODE
#define PROPSHEETHEADER         PROPSHEETHEADERW
#define LPPROPSHEETHEADER       LPPROPSHEETHEADERW
#define LPCPROPSHEETHEADER      LPCPROPSHEETHEADERW
#define PROPSHEETHEADER_V1_SIZE PROPSHEETHEADERW_V1_SIZE
#define PROPSHEETHEADER_V2_SIZE PROPSHEETHEADERW_V2_SIZE
#else
#define PROPSHEETHEADER         PROPSHEETHEADERA
#define LPPROPSHEETHEADER       LPPROPSHEETHEADERA
#define LPCPROPSHEETHEADER      LPCPROPSHEETHEADERA
#define PROPSHEETHEADER_V1_SIZE PROPSHEETHEADERA_V1_SIZE
#define PROPSHEETHEADER_V2_SIZE PROPSHEETHEADERA_V2_SIZE
#endif


#define PSCB_INITIALIZED  1
#define PSCB_PRECREATE    2

#if (_WIN32_IE >= 0x560)
// PSCB_BUTTONPRESSED will be sent when the user clicks a button in the
// property dialog (OK, Cancel, Apply, or Close).  The message will be sent
// to PROPSHEETHEADER's pfnCallback if the PSH_USECALLBACK flag was specified.
// The LPARAM will be equal to one of the following based on the button pressed:
// This message is only supported on comctl32 v6.
// PSBTN_FINISH (Close), PSBTN_OK, PSBTN_APPLYNOW, or PSBTN_CANCEL

#define PSCB_BUTTONPRESSED 3
#endif  // _WIN32_IE >= 0x560


WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreatePropertySheetPageA(LPCPROPSHEETPAGEA constPropSheetPagePointer);
WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreatePropertySheetPageW(LPCPROPSHEETPAGEW constPropSheetPagePointer);
WINCOMMCTRLAPI BOOL           WINAPI DestroyPropertySheetPage(HPROPSHEETPAGE);

WINCOMMCTRLAPI INT_PTR        WINAPI PropertySheetA(LPCPROPSHEETHEADERA);

WINCOMMCTRLAPI INT_PTR        WINAPI PropertySheetW(LPCPROPSHEETHEADERW);

#ifdef UNICODE
#define CreatePropertySheetPage  CreatePropertySheetPageW
#define PropertySheet            PropertySheetW
#else
#define CreatePropertySheetPage  CreatePropertySheetPageA
#define PropertySheet            PropertySheetA
#endif



typedef BOOL (CALLBACK *LPFNADDPROPSHEETPAGE)(HPROPSHEETPAGE, LPARAM);
typedef BOOL (CALLBACK *LPFNADDPROPSHEETPAGES)(LPVOID, LPFNADDPROPSHEETPAGE, LPARAM);


typedef struct _PSHNOTIFY
{
    NMHDR hdr;
    LPARAM lParam;
} PSHNOTIFY, *LPPSHNOTIFY;

#define PSN_FIRST               (0U-200U)
#define PSN_LAST                (0U-299U)


#define PSN_SETACTIVE           (PSN_FIRST-0)
#define PSN_KILLACTIVE          (PSN_FIRST-1)
// #define PSN_VALIDATE            (PSN_FIRST-1)
#define PSN_APPLY               (PSN_FIRST-2)
#define PSN_RESET               (PSN_FIRST-3)
// #define PSN_CANCEL              (PSN_FIRST-3)
#define PSN_HELP                (PSN_FIRST-5)
#define PSN_WIZBACK             (PSN_FIRST-6)
#define PSN_WIZNEXT             (PSN_FIRST-7)
#define PSN_WIZFINISH           (PSN_FIRST-8)
#define PSN_QUERYCANCEL         (PSN_FIRST-9)
#if (_WIN32_IE >= 0x0400)
#define PSN_GETOBJECT           (PSN_FIRST-10)
#endif // 0x0400
#if (_WIN32_IE >= 0x0500)
#define PSN_TRANSLATEACCELERATOR (PSN_FIRST-12)
#define PSN_QUERYINITIALFOCUS   (PSN_FIRST-13)
#endif // 0x0500

#define PSNRET_NOERROR              0
#define PSNRET_INVALID              1
#define PSNRET_INVALID_NOCHANGEPAGE 2
#define PSNRET_MESSAGEHANDLED       3

#define PSM_SETCURSEL           (WM_USER + 101)
#define PropSheet_SetCurSel(hDlg, hpage, index) \
        SNDMSG(hDlg, PSM_SETCURSEL, (WPARAM)index, (LPARAM)hpage)


#define PSM_REMOVEPAGE          (WM_USER + 102)
#define PropSheet_RemovePage(hDlg, index, hpage) \
        SNDMSG(hDlg, PSM_REMOVEPAGE, index, (LPARAM)hpage)


#define PSM_ADDPAGE             (WM_USER + 103)
#define PropSheet_AddPage(hDlg, hpage) \
        SNDMSG(hDlg, PSM_ADDPAGE, 0, (LPARAM)hpage)


#define PSM_CHANGED             (WM_USER + 104)
#define PropSheet_Changed(hDlg, hwnd) \
        SNDMSG(hDlg, PSM_CHANGED, (WPARAM)hwnd, 0L)


#define PSM_RESTARTWINDOWS      (WM_USER + 105)
#define PropSheet_RestartWindows(hDlg) \
        SNDMSG(hDlg, PSM_RESTARTWINDOWS, 0, 0L)


#define PSM_REBOOTSYSTEM        (WM_USER + 106)
#define PropSheet_RebootSystem(hDlg) \
        SNDMSG(hDlg, PSM_REBOOTSYSTEM, 0, 0L)


#define PSM_CANCELTOCLOSE       (WM_USER + 107)
#define PropSheet_CancelToClose(hDlg) \
        PostMessage(hDlg, PSM_CANCELTOCLOSE, 0, 0L)


#define PSM_QUERYSIBLINGS       (WM_USER + 108)
#define PropSheet_QuerySiblings(hDlg, wParam, lParam) \
        SNDMSG(hDlg, PSM_QUERYSIBLINGS, wParam, lParam)


#define PSM_UNCHANGED           (WM_USER + 109)
#define PropSheet_UnChanged(hDlg, hwnd) \
        SNDMSG(hDlg, PSM_UNCHANGED, (WPARAM)hwnd, 0L)


#define PSM_APPLY               (WM_USER + 110)
#define PropSheet_Apply(hDlg) \
        SNDMSG(hDlg, PSM_APPLY, 0, 0L)


#define PSM_SETTITLEA           (WM_USER + 111)
#define PSM_SETTITLEW           (WM_USER + 120)


#ifdef UNICODE
#define PSM_SETTITLE            PSM_SETTITLEW
#else
#define PSM_SETTITLE            PSM_SETTITLEA
#endif

#define PropSheet_SetTitle(hDlg, wStyle, lpszText)\
        SNDMSG(hDlg, PSM_SETTITLE, wStyle, (LPARAM)(LPCTSTR)(lpszText))


#define PSM_SETWIZBUTTONS       (WM_USER + 112)
#define PropSheet_SetWizButtons(hDlg, dwFlags) \
        PostMessage(hDlg, PSM_SETWIZBUTTONS, 0, (LPARAM)dwFlags)


#define PSWIZB_BACK             0x00000001
#define PSWIZB_NEXT             0x00000002
#define PSWIZB_FINISH           0x00000004
#define PSWIZB_DISABLEDFINISH   0x00000008


#define PSM_PRESSBUTTON         (WM_USER + 113)
#define PropSheet_PressButton(hDlg, iButton) \
        PostMessage(hDlg, PSM_PRESSBUTTON, (WPARAM)iButton, 0)


#define PSBTN_BACK              0
#define PSBTN_NEXT              1
#define PSBTN_FINISH            2
#define PSBTN_OK                3
#define PSBTN_APPLYNOW          4
#define PSBTN_CANCEL            5
#define PSBTN_HELP              6
#define PSBTN_MAX               6



#define PSM_SETCURSELID         (WM_USER + 114)
#define PropSheet_SetCurSelByID(hDlg, id) \
        SNDMSG(hDlg, PSM_SETCURSELID, 0, (LPARAM)id)


#define PSM_SETFINISHTEXTA      (WM_USER + 115)
#define PSM_SETFINISHTEXTW      (WM_USER + 121)

#ifdef UNICODE
#define PSM_SETFINISHTEXT       PSM_SETFINISHTEXTW
#else
#define PSM_SETFINISHTEXT       PSM_SETFINISHTEXTA
#endif

#define PropSheet_SetFinishText(hDlg, lpszText) \
        SNDMSG(hDlg, PSM_SETFINISHTEXT, 0, (LPARAM)lpszText)


#define PSM_GETTABCONTROL       (WM_USER + 116)
#define PropSheet_GetTabControl(hDlg) \
        (HWND)SNDMSG(hDlg, PSM_GETTABCONTROL, 0, 0)

#define PSM_ISDIALOGMESSAGE     (WM_USER + 117)
#define PropSheet_IsDialogMessage(hDlg, pMsg) \
        (BOOL)SNDMSG(hDlg, PSM_ISDIALOGMESSAGE, 0, (LPARAM)pMsg)

#define PSM_GETCURRENTPAGEHWND  (WM_USER + 118)
#define PropSheet_GetCurrentPageHwnd(hDlg) \
        (HWND)SNDMSG(hDlg, PSM_GETCURRENTPAGEHWND, 0, 0L)

#define PSM_INSERTPAGE          (WM_USER + 119)
#define PropSheet_InsertPage(hDlg, index, hpage) \
        SNDMSG(hDlg, PSM_INSERTPAGE, (WPARAM)(index), (LPARAM)(hpage))


#if (_WIN32_IE >= 0x0500)
#define PSM_SETHEADERTITLEA     (WM_USER + 125)
#define PSM_SETHEADERTITLEW     (WM_USER + 126)

#ifdef UNICODE
#define PSM_SETHEADERTITLE      PSM_SETHEADERTITLEW
#else
#define PSM_SETHEADERTITLE      PSM_SETHEADERTITLEA
#endif

#define PropSheet_SetHeaderTitle(hDlg, index, lpszText) \
        SNDMSG(hDlg, PSM_SETHEADERTITLE, (WPARAM)(index), (LPARAM)(lpszText))


#define PSM_SETHEADERSUBTITLEA     (WM_USER + 127)
#define PSM_SETHEADERSUBTITLEW     (WM_USER + 128)

#ifdef UNICODE
#define PSM_SETHEADERSUBTITLE      PSM_SETHEADERSUBTITLEW
#else
#define PSM_SETHEADERSUBTITLE      PSM_SETHEADERSUBTITLEA
#endif

#define PropSheet_SetHeaderSubTitle(hDlg, index, lpszText) \
        SNDMSG(hDlg, PSM_SETHEADERSUBTITLE, (WPARAM)(index), (LPARAM)(lpszText))

#define PSM_HWNDTOINDEX            (WM_USER + 129)
#define PropSheet_HwndToIndex(hDlg, hwnd) \
        (int)SNDMSG(hDlg, PSM_HWNDTOINDEX, (WPARAM)(hwnd), 0)

#define PSM_INDEXTOHWND            (WM_USER + 130)
#define PropSheet_IndexToHwnd(hDlg, i) \
        (HWND)SNDMSG(hDlg, PSM_INDEXTOHWND, (WPARAM)(i), 0)

#define PSM_PAGETOINDEX            (WM_USER + 131)
#define PropSheet_PageToIndex(hDlg, hpage) \
        (int)SNDMSG(hDlg, PSM_PAGETOINDEX, 0, (LPARAM)(hpage))

#define PSM_INDEXTOPAGE            (WM_USER + 132)
#define PropSheet_IndexToPage(hDlg, i) \
        (HPROPSHEETPAGE)SNDMSG(hDlg, PSM_INDEXTOPAGE, (WPARAM)(i), 0)

#define PSM_IDTOINDEX              (WM_USER + 133)
#define PropSheet_IdToIndex(hDlg, id) \
        (int)SNDMSG(hDlg, PSM_IDTOINDEX, 0, (LPARAM)(id))

#define PSM_INDEXTOID              (WM_USER + 134)
#define PropSheet_IndexToId(hDlg, i) \
        SNDMSG(hDlg, PSM_INDEXTOID, (WPARAM)(i), 0)

#define PSM_GETRESULT              (WM_USER + 135)
#define PropSheet_GetResult(hDlg) \
        SNDMSG(hDlg, PSM_GETRESULT, 0, 0)

#define PSM_RECALCPAGESIZES        (WM_USER + 136)
#define PropSheet_RecalcPageSizes(hDlg) \
        SNDMSG(hDlg, PSM_RECALCPAGESIZES, 0, 0)
#endif // 0x0500

#define ID_PSRESTARTWINDOWS     0x2
#define ID_PSREBOOTSYSTEM       (ID_PSRESTARTWINDOWS | 0x1)


#define WIZ_CXDLG               276
#define WIZ_CYDLG               140

#define WIZ_CXBMP               80

#define WIZ_BODYX               92
#define WIZ_BODYCX              184

#define PROP_SM_CXDLG           212
#define PROP_SM_CYDLG           188

#define PROP_MED_CXDLG          227
#define PROP_MED_CYDLG          215

#define PROP_LG_CXDLG           252
#define PROP_LG_CYDLG           218





#if !defined(RC_INVOKED) /* RC complains about long symbols in #ifs */
#if defined(ISOLATION_AWARE_ENABLED) && (ISOLATION_AWARE_ENABLED != 0)


#if !defined(ISOLATION_AWARE_USE_STATIC_LIBRARY)
#define ISOLATION_AWARE_USE_STATIC_LIBRARY 0
#endif

#if !defined(ISOLATION_AWARE_BUILD_STATIC_LIBRARY)
#define ISOLATION_AWARE_BUILD_STATIC_LIBRARY 0
#endif

#if !defined(ISOLATION_AWARE_INLINE)
#if ISOLATION_AWARE_BUILD_STATIC_LIBRARY
#define ISOLATION_AWARE_INLINE /* nothing */
#else
#if defined(__cplusplus)
#define ISOLATION_AWARE_INLINE inline
#else
#define ISOLATION_AWARE_INLINE __inline
#endif
#endif
#endif

#if !ISOLATION_AWARE_USE_STATIC_LIBRARY
FARPROC WINAPI PrshtIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY(LPCSTR pszProcName);


#ifndef CCSIZEOF_STRUCT
#define CCSIZEOF_STRUCT(structname, member)  (((int)((LPBYTE)(&((structname*)0)->member) - ((LPBYTE)((structname*)0)))) + sizeof(((structname*)0)->member))
#endif

#endif /* ISOLATION_AWARE_USE_STATIC_LIBRARY */
HPROPSHEETPAGE WINAPI IsolationAwareCreatePropertySheetPageA(LPCPROPSHEETPAGEA constPropSheetPagePointer);
HPROPSHEETPAGE WINAPI IsolationAwareCreatePropertySheetPageW(LPCPROPSHEETPAGEW constPropSheetPagePointer);
BOOL WINAPI IsolationAwareDestroyPropertySheetPage(HPROPSHEETPAGE unnamed1);
INT_PTR WINAPI IsolationAwarePropertySheetA(LPCPROPSHEETHEADERA unnamed1);
INT_PTR WINAPI IsolationAwarePropertySheetW(LPCPROPSHEETHEADERW unnamed1);

#if defined(UNICODE)

#define IsolationAwareCreatePropertySheetPage IsolationAwareCreatePropertySheetPageW
#define IsolationAwarePropertySheet IsolationAwarePropertySheetW

#else /* UNICODE */

#define IsolationAwareCreatePropertySheetPage IsolationAwareCreatePropertySheetPageA
#define IsolationAwarePropertySheet IsolationAwarePropertySheetA

#endif /* UNICODE */

#if !ISOLATION_AWARE_USE_STATIC_LIBRARY
ISOLATION_AWARE_INLINE HPROPSHEETPAGE WINAPI IsolationAwareCreatePropertySheetPageA(LPCPROPSHEETPAGEA constPropSheetPagePointer)
{
    HPROPSHEETPAGE result = NULL;
    typedef HPROPSHEETPAGE (WINAPI* PFN)(LPCPROPSHEETPAGEA constPropSheetPagePointer);
    static PFN s_pfn;

    const LPPROPSHEETPAGEA_LATEST latestPropSheetPagePointer = (LPPROPSHEETPAGEA_LATEST)constPropSheetPagePointer;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess = IsolationAwarePrivateT_SqbjaYRiRY || IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return result;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)PrshtIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("CreatePropertySheetPageA");
            if (s_pfn == NULL)
                __leave;
        }

        if (IsolationAwarePrivateT_SqbjaYRiRY)
        {
            if ((latestPropSheetPagePointer->dwFlags & PSP_USEFUSIONCONTEXT) != 0)
            {
                latestPropSheetPagePointer->dwFlags &= ~PSP_USEFUSIONCONTEXT;
            }
        }
        else if ((   latestPropSheetPagePointer->dwFlags & PSP_USEFUSIONCONTEXT) == 0
                    && latestPropSheetPagePointer->dwSize >= CCSIZEOF_STRUCT(PROPSHEETPAGEA_V3, hActCtx)
                  )
        {
            latestPropSheetPagePointer->dwFlags |= PSP_USEFUSIONCONTEXT;
            latestPropSheetPagePointer->hActCtx = WinbaseIsolationAwarePrivateT_UnPgpgk;
        }
        result = s_pfn(constPropSheetPagePointer);
    }
    __finally
    {
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
        {
            const BOOL fPreserveLastError = (result == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE HPROPSHEETPAGE WINAPI IsolationAwareCreatePropertySheetPageW(LPCPROPSHEETPAGEW constPropSheetPagePointer)
{
    HPROPSHEETPAGE result = NULL;
    typedef HPROPSHEETPAGE (WINAPI* PFN)(LPCPROPSHEETPAGEW constPropSheetPagePointer);
    static PFN s_pfn;

    const LPPROPSHEETPAGEW_LATEST latestPropSheetPagePointer = (LPPROPSHEETPAGEW_LATEST)constPropSheetPagePointer;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess = IsolationAwarePrivateT_SqbjaYRiRY || IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return result;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)PrshtIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("CreatePropertySheetPageW");
            if (s_pfn == NULL)
                __leave;
        }

        if (IsolationAwarePrivateT_SqbjaYRiRY)
        {
            if ((latestPropSheetPagePointer->dwFlags & PSP_USEFUSIONCONTEXT) != 0)
            {
                latestPropSheetPagePointer->dwFlags &= ~PSP_USEFUSIONCONTEXT;
            }
        }
        else if ((   latestPropSheetPagePointer->dwFlags & PSP_USEFUSIONCONTEXT) == 0
                    && latestPropSheetPagePointer->dwSize >= CCSIZEOF_STRUCT(PROPSHEETPAGEW_V3, hActCtx)
                  )
        {
            latestPropSheetPagePointer->dwFlags |= PSP_USEFUSIONCONTEXT;
            latestPropSheetPagePointer->hActCtx = WinbaseIsolationAwarePrivateT_UnPgpgk;
        }
        result = s_pfn(constPropSheetPagePointer);
    }
    __finally
    {
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
        {
            const BOOL fPreserveLastError = (result == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE BOOL WINAPI IsolationAwareDestroyPropertySheetPage(HPROPSHEETPAGE unnamed1)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HPROPSHEETPAGE unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess = IsolationAwarePrivateT_SqbjaYRiRY || IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)PrshtIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DestroyPropertySheetPage");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1);
    }
    __finally
    {
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE INT_PTR WINAPI IsolationAwarePropertySheetA(LPCPROPSHEETHEADERA unnamed1)
{
    INT_PTR nResult = -1;
    typedef INT_PTR (WINAPI* PFN)(LPCPROPSHEETHEADERA unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess = IsolationAwarePrivateT_SqbjaYRiRY || IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)PrshtIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("PropertySheetA");
            if (s_pfn == NULL)
                __leave;
        }
        nResult = s_pfn(unnamed1);
    }
    __finally
    {
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
        {
            const BOOL fPreserveLastError = (nResult == -1);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE INT_PTR WINAPI IsolationAwarePropertySheetW(LPCPROPSHEETHEADERW unnamed1)
{
    INT_PTR nResult = -1;
    typedef INT_PTR (WINAPI* PFN)(LPCPROPSHEETHEADERW unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess = IsolationAwarePrivateT_SqbjaYRiRY || IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)PrshtIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("PropertySheetW");
            if (s_pfn == NULL)
                __leave;
        }
        nResult = s_pfn(unnamed1);
    }
    __finally
    {
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
        {
            const BOOL fPreserveLastError = (nResult == -1);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE FARPROC WINAPI PrshtIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY(LPCSTR pszProcName)
/* This function is shared by the other stubs in this header. */
{
    FARPROC proc = NULL;
    static HMODULE s_module;
    BOOL fActivateActCtxSuccess = FALSE;
    ULONG_PTR ulpCookie = 0;
    const static IsolationAwarePrivatepBAFGnAG_zBqHyr_vAsB
        c = { IsolationAwarePrivatezlybNQyVOeNeln, IsolationAwarePrivatezlybNQyVOeNelJ, "Comctl32.dll", L"Comctl32.dll" };
    static IsolationAwarePrivatezHGnoyr_zBqHyr_vAsB m;

    __try
    {
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
        {
            fActivateActCtxSuccess = IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
            if (!fActivateActCtxSuccess)
                __leave;
        }
        proc = IsolationAwarePrivatezltRgCebPnQQeRff(&c, &m, pszProcName);
    }
    __finally
    {
        if (!IsolationAwarePrivateT_SqbjaYRiRY && fActivateActCtxSuccess)
        {
            const DWORD dwLastError = (proc == NULL) ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (proc == NULL)
                SetLastError(dwLastError);
        }
    }
    return proc;
}

#endif /* ISOLATION_AWARE_USE_STATIC_LIBRARY */

#define CreatePropertySheetPageA IsolationAwareCreatePropertySheetPageA
#define CreatePropertySheetPageW IsolationAwareCreatePropertySheetPageW
#define DestroyPropertySheetPage IsolationAwareDestroyPropertySheetPage
#define PropertySheetA IsolationAwarePropertySheetA
#define PropertySheetW IsolationAwarePropertySheetW

#endif /* ISOLATION_AWARE_ENABLED */
#endif /* RC */



#ifdef __cplusplus
}
#endif

#include <poppack.h>


#endif  // _PRSHT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\pshpack2.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack2.h

Abstract:

    This file turns 2 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 && !defined(_M_I86)) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push,2)
#else
#pragma pack(2)
#endif
#else
#pragma pack(2)
#endif
#endif // ! (defined(lint) || defined(RC_INVOKED))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\psapi.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1994-1999  Microsoft Corporation

Module Name:

    psapi.h

Abstract:

    Include file for APIs provided by PSAPI.DLL

Author:

    Richard Shupak   [richards]  06-Jan-1994

Revision History:

--*/

#ifndef _PSAPI_H_
#define _PSAPI_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

BOOL
WINAPI
EnumProcesses(
    DWORD * lpidProcess,
    DWORD   cb,
    DWORD * cbNeeded
    );

BOOL
WINAPI
EnumProcessModules(
    HANDLE hProcess,
    HMODULE *lphModule,
    DWORD cb,
    LPDWORD lpcbNeeded
    );

DWORD
WINAPI
GetModuleBaseNameA(
    HANDLE hProcess,
    HMODULE hModule,
    LPSTR lpBaseName,
    DWORD nSize
    );

DWORD
WINAPI
GetModuleBaseNameW(
    HANDLE hProcess,
    HMODULE hModule,
    LPWSTR lpBaseName,
    DWORD nSize
    );

#ifdef UNICODE
#define GetModuleBaseName  GetModuleBaseNameW
#else
#define GetModuleBaseName  GetModuleBaseNameA
#endif // !UNICODE


DWORD
WINAPI
GetModuleFileNameExA(
    HANDLE hProcess,
    HMODULE hModule,
    LPSTR lpFilename,
    DWORD nSize
    );

DWORD
WINAPI
GetModuleFileNameExW(
    HANDLE hProcess,
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    );

#ifdef UNICODE
#define GetModuleFileNameEx  GetModuleFileNameExW
#else
#define GetModuleFileNameEx  GetModuleFileNameExA
#endif // !UNICODE


typedef struct _MODULEINFO {
    LPVOID lpBaseOfDll;
    DWORD SizeOfImage;
    LPVOID EntryPoint;
} MODULEINFO, *LPMODULEINFO;


BOOL
WINAPI
GetModuleInformation(
    HANDLE hProcess,
    HMODULE hModule,
    LPMODULEINFO lpmodinfo,
    DWORD cb
    );


BOOL
WINAPI
EmptyWorkingSet(
    HANDLE hProcess
    );


BOOL
WINAPI
QueryWorkingSet(
    HANDLE hProcess,
    PVOID pv,
    DWORD cb
    );

BOOL
WINAPI
InitializeProcessForWsWatch(
    HANDLE hProcess
    );


typedef struct _PSAPI_WS_WATCH_INFORMATION {
    LPVOID FaultingPc;
    LPVOID FaultingVa;
} PSAPI_WS_WATCH_INFORMATION, *PPSAPI_WS_WATCH_INFORMATION;

BOOL
WINAPI
GetWsChanges(
    HANDLE hProcess,
    PPSAPI_WS_WATCH_INFORMATION lpWatchInfo,
    DWORD cb
    );

DWORD
WINAPI
GetMappedFileNameW(
    HANDLE hProcess,
    LPVOID lpv,
    LPWSTR lpFilename,
    DWORD nSize
    );

DWORD
WINAPI
GetMappedFileNameA(
    HANDLE hProcess,
    LPVOID lpv,
    LPSTR lpFilename,
    DWORD nSize
    );

#ifdef UNICODE
#define GetMappedFileName  GetMappedFileNameW
#else
#define GetMappedFileName  GetMappedFileNameA
#endif // !UNICODE

BOOL
WINAPI
EnumDeviceDrivers(
    LPVOID *lpImageBase,
    DWORD cb,
    LPDWORD lpcbNeeded
    );


DWORD
WINAPI
GetDeviceDriverBaseNameA(
    LPVOID ImageBase,
    LPSTR lpBaseName,
    DWORD nSize
    );

DWORD
WINAPI
GetDeviceDriverBaseNameW(
    LPVOID ImageBase,
    LPWSTR lpBaseName,
    DWORD nSize
    );

#ifdef UNICODE
#define GetDeviceDriverBaseName  GetDeviceDriverBaseNameW
#else
#define GetDeviceDriverBaseName  GetDeviceDriverBaseNameA
#endif // !UNICODE


DWORD
WINAPI
GetDeviceDriverFileNameA(
    LPVOID ImageBase,
    LPSTR lpFilename,
    DWORD nSize
    );

DWORD
WINAPI
GetDeviceDriverFileNameW(
    LPVOID ImageBase,
    LPWSTR lpFilename,
    DWORD nSize
    );

#ifdef UNICODE
#define GetDeviceDriverFileName  GetDeviceDriverFileNameW
#else
#define GetDeviceDriverFileName  GetDeviceDriverFileNameA
#endif // !UNICODE

// Structure for GetProcessMemoryInfo()

typedef struct _PROCESS_MEMORY_COUNTERS {
    DWORD cb;
    DWORD PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
} PROCESS_MEMORY_COUNTERS;
typedef PROCESS_MEMORY_COUNTERS *PPROCESS_MEMORY_COUNTERS;

#if (_WIN32_WINNT >= 0x0501)

typedef struct _PROCESS_MEMORY_COUNTERS_EX {
    DWORD cb;
    DWORD PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivateUsage;
} PROCESS_MEMORY_COUNTERS_EX;
typedef PROCESS_MEMORY_COUNTERS_EX *PPROCESS_MEMORY_COUNTERS_EX;

#endif

BOOL
WINAPI
GetProcessMemoryInfo(
    HANDLE Process,
    PPROCESS_MEMORY_COUNTERS ppsmemCounters,
    DWORD cb
    );

typedef struct _PERFORMANCE_INFORMATION {
    DWORD cb;
    SIZE_T CommitTotal;
    SIZE_T CommitLimit;
    SIZE_T CommitPeak;
    SIZE_T PhysicalTotal;
    SIZE_T PhysicalAvailable;
    SIZE_T SystemCache;
    SIZE_T KernelTotal;
    SIZE_T KernelPaged;
    SIZE_T KernelNonpaged;
    SIZE_T PageSize;
    DWORD HandleCount;
    DWORD ProcessCount;
    DWORD ThreadCount;
} PERFORMANCE_INFORMATION, *PPERFORMANCE_INFORMATION, PERFORMACE_INFORMATION, *PPERFORMACE_INFORMATION;

BOOL
WINAPI
GetPerformanceInfo (
    PPERFORMACE_INFORMATION pPerformanceInformation,
    DWORD cb
    );

typedef struct _ENUM_PAGE_FILE_INFORMATION {
    DWORD cb;
    DWORD Reserved;
    SIZE_T TotalSize;
    SIZE_T TotalInUse;
    SIZE_T PeakUsage;
} ENUM_PAGE_FILE_INFORMATION, *PENUM_PAGE_FILE_INFORMATION;

typedef BOOL (*PENUM_PAGE_FILE_CALLBACKW) (LPVOID pContext, PENUM_PAGE_FILE_INFORMATION pPageFileInfo, LPCWSTR lpFilename);

typedef BOOL (*PENUM_PAGE_FILE_CALLBACKA) (LPVOID pContext, PENUM_PAGE_FILE_INFORMATION pPageFileInfo, LPCSTR lpFilename);

BOOL
WINAPI
EnumPageFilesW (
    PENUM_PAGE_FILE_CALLBACKW pCallBackRoutine,
    LPVOID pContext
    );

BOOL
WINAPI
EnumPageFilesA (
    PENUM_PAGE_FILE_CALLBACKA pCallBackRoutine,
    LPVOID pContext
    );

#ifdef UNICODE
#define PENUM_PAGE_FILE_CALLBACK PENUM_PAGE_FILE_CALLBACKW
#define EnumPageFiles EnumPageFilesW
#else
#define PENUM_PAGE_FILE_CALLBACK PENUM_PAGE_FILE_CALLBACKA
#define EnumPageFiles EnumPageFilesA
#endif // !UNICODE

DWORD
WINAPI
GetProcessImageFileNameA(
    HANDLE hProcess,
    LPSTR lpImageFileName,
    DWORD nSize
    );

DWORD
WINAPI
GetProcessImageFileNameW(
    HANDLE hProcess,
    LPWSTR lpImageFileName,
    DWORD nSize
    );

#ifdef UNICODE
#define GetProcessImageFileName  GetProcessImageFileNameW
#else
#define GetProcessImageFileName  GetProcessImageFileNameA
#endif // !UNICODE

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\pshpack1.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack1.h

Abstract:

    This file turns 1 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 && !defined(_M_I86)) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push,1)
#else
#pragma pack(1)
#endif
#else
#pragma pack(1)
#endif
#endif // ! (defined(lint) || defined(RC_INVOKED))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\pshpack4.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack4.h

Abstract:

    This file turns 4 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 && !defined(_M_I86)) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push,4)
#else
#pragma pack(4)
#endif
#else
#pragma pack(4)
#endif
#endif // ! (defined(lint) || defined(RC_INVOKED))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\pshpack8.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack8.h

Abstract:

    This file turns 8 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 && !defined(_M_I86)) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push,8)
#else
#pragma pack(8)
#endif
#else
#pragma pack(8)
#endif
#endif // ! (defined(lint) || defined(RC_INVOKED))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\pstore.h ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    pstore.h

Abstract:

    This module defines the Protected Storage COM interface and associated
    data structures.

Author:

    Scott Field (sfield)    13-Mar-97

--*/

#ifndef __PSTORE_H__
#define __PSTORE_H__

#if _MSC_VER > 1000
#pragma once
#endif

/*
    Typedefs, values
*/

// provider flags

// provider capabilities
typedef DWORD PST_PROVIDERCAPABILITIES;

#define PST_PC_PFX              0x00000001
#define PST_PC_HARDWARE         0x00000002
#define PST_PC_SMARTCARD        0x00000004
#define PST_PC_PCMCIA           0x00000008
#define PST_PC_MULTIPLE_REPOSITORIES    0x00000010
#define PST_PC_ROAMABLE         0x00000020


// NYI (not yet implemented)
typedef DWORD PST_REPOSITORYCAPABILITIES;

#define PST_RC_REMOVABLE        0x80000000


// provider storage area
typedef DWORD PST_KEY;

#define PST_KEY_CURRENT_USER    0x00000000
#define PST_KEY_LOCAL_MACHINE   0x00000001



/*
    dwDefaultConfirmationStyle flags
*/

//
// allows user to choose confirmation style
//
#define     PST_CF_DEFAULT              0x00000000

//
// forces silent item creation
//
#define     PST_CF_NONE                 0x00000001



/*
    dwPromptFlags
*/

//
// app forces confirmation to be shown
//
#define     PST_PF_ALWAYS_SHOW          0x00000001


//
// RSABase rqmt: determine if item has ui attached
//
#define     PST_PF_NEVER_SHOW           0x00000002

/*
    dwFlags values
*/

//
// Allows caller to specify creation not overwrite
// of item during WriteItem call
//
#define     PST_NO_OVERWRITE            0x00000002

//
// specifies insecure data stream to be written/read
// there is no protection or guarantees for this data
// flag only valid during item read/write calls
// default: item calls are secure
//
#define     PST_UNRESTRICTED_ITEMDATA   0x00000004


//
// on ReadItem call
// return value on success without UI on item is PST_E_OK
// return value on success with UI on item is PST_E_ITEM_EXISTS
// return value on failure is a different error code
//
#define     PST_PROMPT_QUERY            0x00000008

//
// on ReadItem, DeleteItem, for data migration purposes:
// Avoid displaying UI on ReadItem unless a custom password is required (highsecurity).
// Avoid displaying UI on DeleteItem, period.
//
#define     PST_NO_UI_MIGRATION         0x00000010



/*
    Security masks, rule modifiers
*/

//
// models access after NT access mask
//

// read, write
typedef DWORD PST_ACCESSMODE;

#define     PST_READ                0x0001
#define     PST_WRITE               0x0002


// PST_ACCESSCLAUSETYPE

// memhash, diskhash, authenticode, etc
typedef DWORD PST_ACCESSCLAUSETYPE;

//
// pbClauseData points to PST_AUTHENTICODEDATA structure.
//
#define     PST_AUTHENTICODE            1

//
// pbClauseData points to PST_BINARYCHECKDATA structure.
//
#define     PST_BINARY_CHECK            2

//
// pbClauseData points to valid Windows NT security descriptor.
// note that performance is improved on Set operations if the security
// descriptor is in self-relative format, with valid owner and group Sids
// (non-NULL).
//
#define     PST_SECURITY_DESCRIPTOR     4

//
// pbClauseData is in self-relative format
// (for internal use only)
//
#define     PST_SELF_RELATIVE_CLAUSE    0x80000000L

//
// currently access clause modifiers - NOT to be or'd together
//


//
// specified image is the immediate caller, and is an application (.exe)
//

#define     PST_AC_SINGLE_CALLER        0

//
// specified image is not necessary the immediate caller, and is an
// application (.exe)
//

#define     PST_AC_TOP_LEVEL_CALLER     1

//
// specified image is the immediate caller.  May be
// an application (.exe) or a .dll
//

#define     PST_AC_IMMEDIATE_CALLER     2


/*
    Provider Parameters
*/
//
// flush the internal cache of passwords -- temporary?
//
#define     PST_PP_FLUSH_PW_CACHE       0x1




/*
    Provider Defns
*/

//
// Microsoft Base Provider (MS_BASE_PSTPROVIDER...)
//
#define MS_BASE_PSTPROVIDER_NAME            L"System Protected Storage"

// {8A078C30-3755-11d0-A0BD-00AA0061426A}
#define MS_BASE_PSTPROVIDER_ID              { 0x8a078c30, 0x3755, 0x11d0, { 0xa0, 0xbd, 0x0, 0xaa, 0x0, 0x61, 0x42, 0x6a } }
#define MS_BASE_PSTPROVIDER_SZID            L"8A078C30-3755-11d0-A0BD-00AA0061426A"

//
// Microsoft PFX Provider (MS_PFX_PSTPROVIDER...)
//
#define MS_PFX_PSTPROVIDER_NAME             L"PFX Storage Provider"

// {3ca94f30-7ac1-11d0-8c42-00c04fc299eb}
#define MS_PFX_PSTPROVIDER_ID               { 0x3ca94f30, 0x7ac1, 0x11d0, {0x8c, 0x42, 0x00, 0xc0, 0x4f, 0xc2, 0x99, 0xeb} }
#define MS_PFX_PSTPROVIDER_SZID             L"3ca94f30-7ac1-11d0-8c42-00c04fc299eb"



/*
    Globally registered Type/Subtype guid/name pairs
*/

#define PST_CONFIGDATA_TYPE_STRING              L"Configuration Data"
// 8ec99652-8909-11d0-8c4d-00c04fc297eb
#define PST_CONFIGDATA_TYPE_GUID                        \
{   0x8ec99652,                                         \
    0x8909,                                             \
    0x11d0,                                             \
    {0x8c, 0x4d, 0x00, 0xc0, 0x4f, 0xc2, 0x97, 0xeb}    \
}

#define PST_PROTECTEDSTORAGE_SUBTYPE_STRING     L"Protected Storage"
// d3121b8e-8a7d-11d0-8c4f-00c04fc297eb
#define PST_PROTECTEDSTORAGE_SUBTYPE_GUID               \
{   0xd3121b8e,                                         \
    0x8a7d,                                             \
    0x11d0,                                             \
    {0x8c, 0x4f, 0x00, 0xc0, 0x4f, 0xc2, 0x97, 0xeb}    \
}


#define PST_PSTORE_PROVIDERS_SUBTYPE_STRING     L"Protected Storage Provider List"
// 8ed17a64-91d0-11d0-8c43-00c04fc2c621
#define PST_PSTORE_PROVIDERS_SUBTYPE_GUID               \
{                                                       \
    0x8ed17a64,                                         \
    0x91d0,                                             \
    0x11d0,                                             \
    {0x8c, 0x43, 0x00, 0xc0, 0x4f, 0xc2, 0xc6, 0x21}    \
}


//
// error codes
//


#ifndef PST_E_OK
#define PST_E_OK                        _HRESULT_TYPEDEF_(0x00000000L)


#define PST_E_FAIL                      _HRESULT_TYPEDEF_(0x800C0001L)
#define PST_E_PROV_DLL_NOT_FOUND        _HRESULT_TYPEDEF_(0x800C0002L)
#define PST_E_INVALID_HANDLE            _HRESULT_TYPEDEF_(0x800C0003L)
#define PST_E_TYPE_EXISTS               _HRESULT_TYPEDEF_(0x800C0004L)
#define PST_E_TYPE_NO_EXISTS            _HRESULT_TYPEDEF_(0x800C0005L)
#define PST_E_INVALID_RULESET           _HRESULT_TYPEDEF_(0x800C0006L)
#define PST_E_NO_PERMISSIONS            _HRESULT_TYPEDEF_(0x800C0007L)
#define PST_E_STORAGE_ERROR             _HRESULT_TYPEDEF_(0x800C0008L)
#define PST_E_CALLER_NOT_VERIFIED       _HRESULT_TYPEDEF_(0x800C0009L)
#define PST_E_WRONG_PASSWORD            _HRESULT_TYPEDEF_(0x800C000AL)
#define PST_E_DISK_IMAGE_MISMATCH       _HRESULT_TYPEDEF_(0x800C000BL)
// 000C pending
#define PST_E_UNKNOWN_EXCEPTION         _HRESULT_TYPEDEF_(0x800C000DL)
#define PST_E_BAD_FLAGS                 _HRESULT_TYPEDEF_(0x800C000EL)
#define PST_E_ITEM_EXISTS               _HRESULT_TYPEDEF_(0x800C000FL)
#define PST_E_ITEM_NO_EXISTS            _HRESULT_TYPEDEF_(0x800C0010L)
#define PST_E_SERVICE_UNAVAILABLE       _HRESULT_TYPEDEF_(0x800C0011L)
#define PST_E_NOTEMPTY                  _HRESULT_TYPEDEF_(0x800C0012L)
#define PST_E_INVALID_STRING            _HRESULT_TYPEDEF_(0x800C0013L)
#define PST_E_STATE_INVALID             _HRESULT_TYPEDEF_(0x800C0014L)
#define PST_E_NOT_OPEN                  _HRESULT_TYPEDEF_(0x800C0015L)
#define PST_E_ALREADY_OPEN              _HRESULT_TYPEDEF_(0x800C0016L)
#define PST_E_NYI                       _HRESULT_TYPEDEF_(0x800C0F00L)


#define MIN_PST_ERROR                   0x800C0001
#define MAX_PST_ERROR                   0x800C0F00

#endif  // !PST_OK



/* this ALWAYS GENERATED file contains the definitions for the interfaces */

//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifdef __cplusplus
extern "C"{
#endif

/* Forward Declarations */

/* header files for imported files */
#include "wtypes.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Wed Apr 23 23:56:10 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */


typedef DWORD PST_PROVIDERCAPABILITIES;

typedef DWORD PST_REPOSITORYCAPABILITIES;

typedef DWORD PST_KEY;

typedef DWORD PST_ACCESSMODE;

typedef DWORD PST_ACCESSCLAUSETYPE;

typedef GUID UUID;

typedef ULARGE_INTEGER PST_PROVIDER_HANDLE;

typedef GUID PST_PROVIDERID;

typedef PST_PROVIDERID __RPC_FAR *PPST_PROVIDERID;

typedef struct  _PST_PROVIDERINFO
    {
    DWORD cbSize;
    PST_PROVIDERID ID;
    PST_PROVIDERCAPABILITIES Capabilities;
    LPWSTR szProviderName;
    }   PST_PROVIDERINFO;

typedef struct _PST_PROVIDERINFO __RPC_FAR *PPST_PROVIDERINFO;

typedef struct  _PST_TYPEINFO
    {
    DWORD cbSize;
    LPWSTR szDisplayName;
    }   PST_TYPEINFO;

typedef struct _PST_TYPEINFO __RPC_FAR *PPST_TYPEINFO;

typedef struct  _PST_PROMPTINFO
    {
    DWORD cbSize;
    DWORD dwPromptFlags;
    HWND  hwndApp;
    LPCWSTR szPrompt;
    }   PST_PROMPTINFO;

typedef struct _PST_PROMPTINFO __RPC_FAR *PPST_PROMPTINFO;

typedef struct  _PST_ACCESSCLAUSE
    {
    DWORD cbSize;
    PST_ACCESSCLAUSETYPE ClauseType;
    DWORD cbClauseData;
    /* [size_is] */ VOID __RPC_FAR *pbClauseData;
    }   PST_ACCESSCLAUSE;

typedef struct _PST_ACCESSCLAUSE __RPC_FAR *PPST_ACCESSCLAUSE;

typedef struct  _PST_ACCESSRULE
    {
    DWORD cbSize;
    PST_ACCESSMODE AccessModeFlags;
    DWORD cClauses;
    /* [size_is] */ PST_ACCESSCLAUSE __RPC_FAR *rgClauses;
    }   PST_ACCESSRULE;

typedef struct _PST_ACCESSRULE __RPC_FAR *PPST_ACCESSRULE;

typedef struct  _PST_ACCESSRULESET
    {
    DWORD cbSize;
    DWORD cRules;
    /* [size_is] */ PST_ACCESSRULE __RPC_FAR *rgRules;
    }   PST_ACCESSRULESET;

typedef struct _PST_ACCESSRULESET __RPC_FAR *PPST_ACCESSRULESET;

typedef struct  _PST_AUTHENTICODEDATA
    {
    DWORD cbSize;
    DWORD dwModifiers;
    LPCWSTR szRootCA;
    LPCWSTR szIssuer;
    LPCWSTR szPublisher;
    LPCWSTR szProgramName;
    }   PST_AUTHENTICODEDATA;

typedef struct _PST_AUTHENTICODEDATA __RPC_FAR *PPST_AUTHENTICODEDATA;

typedef struct _PST_AUTHENTICODEDATA __RPC_FAR *LPPST_AUTHENTICODEDATA;

typedef struct  _PST_BINARYCHECKDATA
    {
    DWORD cbSize;
    DWORD dwModifiers;
    LPCWSTR szFilePath;
    }   PST_BINARYCHECKDATA;

typedef struct _PST_BINARYCHECKDATA __RPC_FAR *PPST_BINARYCHECKDATA;

typedef struct _PST_BINARYCHECKDATA __RPC_FAR *LPPST_BINARYCHECKDATA;



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif



/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Wed Apr 23 23:56:14 1997
 */
/* Compiler settings for pstorec.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifdef __cplusplus
extern "C"{
#endif

/* Forward Declarations */

#ifndef __IEnumPStoreItems_FWD_DEFINED__
#define __IEnumPStoreItems_FWD_DEFINED__
typedef interface IEnumPStoreItems IEnumPStoreItems;
#endif  /* __IEnumPStoreItems_FWD_DEFINED__ */


#ifndef __IEnumPStoreTypes_FWD_DEFINED__
#define __IEnumPStoreTypes_FWD_DEFINED__
typedef interface IEnumPStoreTypes IEnumPStoreTypes;
#endif  /* __IEnumPStoreTypes_FWD_DEFINED__ */


#ifndef __IPStore_FWD_DEFINED__
#define __IPStore_FWD_DEFINED__
typedef interface IPStore IPStore;
#endif  /* __IPStore_FWD_DEFINED__ */


#ifndef __IEnumPStoreProviders_FWD_DEFINED__
#define __IEnumPStoreProviders_FWD_DEFINED__
typedef interface IEnumPStoreProviders IEnumPStoreProviders;
#endif  /* __IEnumPStoreProviders_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

#ifndef __IEnumPStoreItems_INTERFACE_DEFINED__
#define __IEnumPStoreItems_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumPStoreItems
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */



EXTERN_C const IID IID_IEnumPStoreItems;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IEnumPStoreItems : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(
            /* [in] */ DWORD celt,
            /* [out] */ LPWSTR __RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched) = 0;

        virtual HRESULT STDMETHODCALLTYPE Skip(
            /* [in] */ DWORD celt) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum) = 0;

    };

#else   /* C style interface */

    typedef struct IEnumPStoreItemsVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IEnumPStoreItems __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IEnumPStoreItems __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IEnumPStoreItems __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )(
            IEnumPStoreItems __RPC_FAR * This,
            /* [in] */ DWORD celt,
            /* [out] */ LPWSTR __RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )(
            IEnumPStoreItems __RPC_FAR * This,
            /* [in] */ DWORD celt);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            IEnumPStoreItems __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IEnumPStoreItems __RPC_FAR * This,
            /* [out] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);

        END_INTERFACE
    } IEnumPStoreItemsVtbl;

    interface IEnumPStoreItems
    {
        CONST_VTBL struct IEnumPStoreItemsVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IEnumPStoreItems_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumPStoreItems_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IEnumPStoreItems_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IEnumPStoreItems_Next(This,celt,rgelt,pceltFetched) \
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumPStoreItems_Skip(This,celt)    \
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumPStoreItems_Reset(This)    \
    (This)->lpVtbl -> Reset(This)

#define IEnumPStoreItems_Clone(This,ppenum) \
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IEnumPStoreItems_Next_Proxy(
    IEnumPStoreItems __RPC_FAR * This,
    /* [in] */ DWORD celt,
    /* [out] */ LPWSTR __RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumPStoreItems_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreItems_Skip_Proxy(
    IEnumPStoreItems __RPC_FAR * This,
    /* [in] */ DWORD celt);


void __RPC_STUB IEnumPStoreItems_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreItems_Reset_Proxy(
    IEnumPStoreItems __RPC_FAR * This);


void __RPC_STUB IEnumPStoreItems_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreItems_Clone_Proxy(
    IEnumPStoreItems __RPC_FAR * This,
    /* [out] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumPStoreItems_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEnumPStoreItems_INTERFACE_DEFINED__ */


#ifndef __IEnumPStoreTypes_INTERFACE_DEFINED__
#define __IEnumPStoreTypes_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumPStoreTypes
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */



EXTERN_C const IID IID_IEnumPStoreTypes;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IEnumPStoreTypes : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(
            /* [in] */ DWORD celt,
            /* [out][size_is] */ GUID __RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched) = 0;

        virtual HRESULT STDMETHODCALLTYPE Skip(
            /* [in] */ DWORD celt) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum) = 0;

    };

#else   /* C style interface */

    typedef struct IEnumPStoreTypesVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IEnumPStoreTypes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IEnumPStoreTypes __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IEnumPStoreTypes __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )(
            IEnumPStoreTypes __RPC_FAR * This,
            /* [in] */ DWORD celt,
            /* [out][size_is] */ GUID __RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )(
            IEnumPStoreTypes __RPC_FAR * This,
            /* [in] */ DWORD celt);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            IEnumPStoreTypes __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IEnumPStoreTypes __RPC_FAR * This,
            /* [out] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);

        END_INTERFACE
    } IEnumPStoreTypesVtbl;

    interface IEnumPStoreTypes
    {
        CONST_VTBL struct IEnumPStoreTypesVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IEnumPStoreTypes_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumPStoreTypes_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IEnumPStoreTypes_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IEnumPStoreTypes_Next(This,celt,rgelt,pceltFetched) \
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumPStoreTypes_Skip(This,celt)    \
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumPStoreTypes_Reset(This)    \
    (This)->lpVtbl -> Reset(This)

#define IEnumPStoreTypes_Clone(This,ppenum) \
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IEnumPStoreTypes_Next_Proxy(
    IEnumPStoreTypes __RPC_FAR * This,
    /* [in] */ DWORD celt,
    /* [out][size_is] */ GUID __RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumPStoreTypes_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreTypes_Skip_Proxy(
    IEnumPStoreTypes __RPC_FAR * This,
    /* [in] */ DWORD celt);


void __RPC_STUB IEnumPStoreTypes_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreTypes_Reset_Proxy(
    IEnumPStoreTypes __RPC_FAR * This);


void __RPC_STUB IEnumPStoreTypes_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreTypes_Clone_Proxy(
    IEnumPStoreTypes __RPC_FAR * This,
    /* [out] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumPStoreTypes_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEnumPStoreTypes_INTERFACE_DEFINED__ */


#ifndef __IPStore_INTERFACE_DEFINED__
#define __IPStore_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPStore
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */



EXTERN_C const IID IID_IPStore;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IPStore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInfo(
            /* [out] */ PPST_PROVIDERINFO __RPC_FAR *ppProperties) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetProvParam(
            /* [in] */ DWORD dwParam,
            /* [out] */ DWORD __RPC_FAR *pcbData,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetProvParam(
            /* [in] */ DWORD dwParam,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE CreateType(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ PPST_TYPEINFO pInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteType(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE CreateSubtype(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ PPST_TYPEINFO pInfo,
            /* [in] */ PPST_ACCESSRULESET pRules,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetSubtypeInfo(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteSubtype(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE ReadAccessRuleset(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [out] */ PPST_ACCESSRULESET __RPC_FAR *ppRules,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE WriteAccessRuleset(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ PPST_ACCESSRULESET pRules,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumTypes(
            /* [in] */ PST_KEY Key,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumSubtypes(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE ReadItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [out] */ DWORD __RPC_FAR *pcbData,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE WriteItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwDefaultConfirmationStyle,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE OpenItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ PST_ACCESSMODE ModeFlags,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE CloseItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumItems(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum) = 0;

    };

#else   /* C style interface */

    typedef struct IPStoreVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IPStore __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IPStore __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IPStore __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInfo )(
            IPStore __RPC_FAR * This,
            /* [out] */ PPST_PROVIDERINFO __RPC_FAR *ppProperties);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProvParam )(
            IPStore __RPC_FAR * This,
            /* [in] */ DWORD dwParam,
            /* [out] */ DWORD __RPC_FAR *pcbData,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProvParam )(
            IPStore __RPC_FAR * This,
            /* [in] */ DWORD dwParam,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateType )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ PPST_TYPEINFO pInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteType )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateSubtype )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ PPST_TYPEINFO pInfo,
            /* [in] */ PPST_ACCESSRULESET pRules,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSubtypeInfo )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteSubtype )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadAccessRuleset )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [out] */ PPST_ACCESSRULESET __RPC_FAR *ppRules,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteAccessRuleset )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ PPST_ACCESSRULESET pRules,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumTypes )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumSubtypes )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [out] */ DWORD __RPC_FAR *pcbData,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwDefaultConfirmationStyle,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ PST_ACCESSMODE ModeFlags,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumItems )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);

        END_INTERFACE
    } IPStoreVtbl;

    interface IPStore
    {
        CONST_VTBL struct IPStoreVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IPStore_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPStore_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IPStore_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IPStore_GetInfo(This,ppProperties)  \
    (This)->lpVtbl -> GetInfo(This,ppProperties)

#define IPStore_GetProvParam(This,dwParam,pcbData,ppbData,dwFlags)  \
    (This)->lpVtbl -> GetProvParam(This,dwParam,pcbData,ppbData,dwFlags)

#define IPStore_SetProvParam(This,dwParam,cbData,pbData,dwFlags)    \
    (This)->lpVtbl -> SetProvParam(This,dwParam,cbData,pbData,dwFlags)

#define IPStore_CreateType(This,Key,pType,pInfo,dwFlags)    \
    (This)->lpVtbl -> CreateType(This,Key,pType,pInfo,dwFlags)

#define IPStore_GetTypeInfo(This,Key,pType,ppInfo,dwFlags)  \
    (This)->lpVtbl -> GetTypeInfo(This,Key,pType,ppInfo,dwFlags)

#define IPStore_DeleteType(This,Key,pType,dwFlags)  \
    (This)->lpVtbl -> DeleteType(This,Key,pType,dwFlags)

#define IPStore_CreateSubtype(This,Key,pType,pSubtype,pInfo,pRules,dwFlags) \
    (This)->lpVtbl -> CreateSubtype(This,Key,pType,pSubtype,pInfo,pRules,dwFlags)

#define IPStore_GetSubtypeInfo(This,Key,pType,pSubtype,ppInfo,dwFlags)  \
    (This)->lpVtbl -> GetSubtypeInfo(This,Key,pType,pSubtype,ppInfo,dwFlags)

#define IPStore_DeleteSubtype(This,Key,pType,pSubtype,dwFlags)  \
    (This)->lpVtbl -> DeleteSubtype(This,Key,pType,pSubtype,dwFlags)

#define IPStore_ReadAccessRuleset(This,Key,pType,pSubtype,ppRules,dwFlags)  \
    (This)->lpVtbl -> ReadAccessRuleset(This,Key,pType,pSubtype,ppRules,dwFlags)

#define IPStore_WriteAccessRuleset(This,Key,pType,pSubtype,pRules,dwFlags)  \
    (This)->lpVtbl -> WriteAccessRuleset(This,Key,pType,pSubtype,pRules,dwFlags)

#define IPStore_EnumTypes(This,Key,dwFlags,ppenum)  \
    (This)->lpVtbl -> EnumTypes(This,Key,dwFlags,ppenum)

#define IPStore_EnumSubtypes(This,Key,pType,dwFlags,ppenum) \
    (This)->lpVtbl -> EnumSubtypes(This,Key,pType,dwFlags,ppenum)

#define IPStore_DeleteItem(This,Key,pItemType,pItemSubtype,szItemName,pPromptInfo,dwFlags)  \
    (This)->lpVtbl -> DeleteItem(This,Key,pItemType,pItemSubtype,szItemName,pPromptInfo,dwFlags)

#define IPStore_ReadItem(This,Key,pItemType,pItemSubtype,szItemName,pcbData,ppbData,pPromptInfo,dwFlags)    \
    (This)->lpVtbl -> ReadItem(This,Key,pItemType,pItemSubtype,szItemName,pcbData,ppbData,pPromptInfo,dwFlags)

#define IPStore_WriteItem(This,Key,pItemType,pItemSubtype,szItemName,cbData,pbData,pPromptInfo,dwDefaultConfirmationStyle,dwFlags)  \
    (This)->lpVtbl -> WriteItem(This,Key,pItemType,pItemSubtype,szItemName,cbData,pbData,pPromptInfo,dwDefaultConfirmationStyle,dwFlags)

#define IPStore_OpenItem(This,Key,pItemType,pItemSubtype,szItemName,ModeFlags,pPromptInfo,dwFlags)  \
    (This)->lpVtbl -> OpenItem(This,Key,pItemType,pItemSubtype,szItemName,ModeFlags,pPromptInfo,dwFlags)

#define IPStore_CloseItem(This,Key,pItemType,pItemSubtype,szItemName,dwFlags)   \
    (This)->lpVtbl -> CloseItem(This,Key,pItemType,pItemSubtype,szItemName,dwFlags)

#define IPStore_EnumItems(This,Key,pItemType,pItemSubtype,dwFlags,ppenum)   \
    (This)->lpVtbl -> EnumItems(This,Key,pItemType,pItemSubtype,dwFlags,ppenum)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IPStore_GetInfo_Proxy(
    IPStore __RPC_FAR * This,
    /* [out] */ PPST_PROVIDERINFO __RPC_FAR *ppProperties);


void __RPC_STUB IPStore_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_GetProvParam_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ DWORD dwParam,
    /* [out] */ DWORD __RPC_FAR *pcbData,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_GetProvParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_SetProvParam_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ DWORD dwParam,
    /* [in] */ DWORD cbData,
    /* [size_is][in] */ BYTE __RPC_FAR *pbData,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_SetProvParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_CreateType_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ PPST_TYPEINFO pInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_CreateType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_GetTypeInfo_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_GetTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_DeleteType_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_DeleteType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_CreateSubtype_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ PPST_TYPEINFO pInfo,
    /* [in] */ PPST_ACCESSRULESET pRules,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_CreateSubtype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_GetSubtypeInfo_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_GetSubtypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_DeleteSubtype_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_DeleteSubtype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_ReadAccessRuleset_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [out] */ PPST_ACCESSRULESET __RPC_FAR *ppRules,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_ReadAccessRuleset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_WriteAccessRuleset_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ PPST_ACCESSRULESET pRules,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_WriteAccessRuleset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_EnumTypes_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IPStore_EnumTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_EnumSubtypes_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IPStore_EnumSubtypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_DeleteItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_DeleteItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_ReadItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [out] */ DWORD __RPC_FAR *pcbData,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_ReadItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_WriteItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD cbData,
    /* [size_is][in] */ BYTE __RPC_FAR *pbData,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwDefaultConfirmationStyle,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_WriteItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_OpenItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ PST_ACCESSMODE ModeFlags,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_OpenItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_CloseItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_CloseItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_EnumItems_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IPStore_EnumItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IPStore_INTERFACE_DEFINED__ */


#ifndef __IEnumPStoreProviders_INTERFACE_DEFINED__
#define __IEnumPStoreProviders_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumPStoreProviders
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */



EXTERN_C const IID IID_IEnumPStoreProviders;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IEnumPStoreProviders : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(
            /* [in] */ DWORD celt,
            /* [out][size_is] */ PST_PROVIDERINFO __RPC_FAR *__RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched) = 0;

        virtual HRESULT STDMETHODCALLTYPE Skip(
            /* [in] */ DWORD celt) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum) = 0;

    };

#else   /* C style interface */

    typedef struct IEnumPStoreProvidersVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IEnumPStoreProviders __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IEnumPStoreProviders __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IEnumPStoreProviders __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )(
            IEnumPStoreProviders __RPC_FAR * This,
            /* [in] */ DWORD celt,
            /* [out][size_is] */ PST_PROVIDERINFO __RPC_FAR *__RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )(
            IEnumPStoreProviders __RPC_FAR * This,
            /* [in] */ DWORD celt);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            IEnumPStoreProviders __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IEnumPStoreProviders __RPC_FAR * This,
            /* [out] */ IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum);

        END_INTERFACE
    } IEnumPStoreProvidersVtbl;

    interface IEnumPStoreProviders
    {
        CONST_VTBL struct IEnumPStoreProvidersVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IEnumPStoreProviders_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumPStoreProviders_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IEnumPStoreProviders_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IEnumPStoreProviders_Next(This,celt,rgelt,pceltFetched) \
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumPStoreProviders_Skip(This,celt)    \
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumPStoreProviders_Reset(This)    \
    (This)->lpVtbl -> Reset(This)

#define IEnumPStoreProviders_Clone(This,ppenum) \
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IEnumPStoreProviders_Next_Proxy(
    IEnumPStoreProviders __RPC_FAR * This,
    /* [in] */ DWORD celt,
    /* [out][size_is] */ PST_PROVIDERINFO __RPC_FAR *__RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumPStoreProviders_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreProviders_Skip_Proxy(
    IEnumPStoreProviders __RPC_FAR * This,
    /* [in] */ DWORD celt);


void __RPC_STUB IEnumPStoreProviders_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreProviders_Reset_Proxy(
    IEnumPStoreProviders __RPC_FAR * This);


void __RPC_STUB IEnumPStoreProviders_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreProviders_Clone_Proxy(
    IEnumPStoreProviders __RPC_FAR * This,
    /* [out] */ IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumPStoreProviders_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEnumPStoreProviders_INTERFACE_DEFINED__ */



#ifndef __PSTORECLib_LIBRARY_DEFINED__
#define __PSTORECLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: PSTORECLib
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [helpstring][version][uuid] */



EXTERN_C const IID LIBID_PSTORECLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CPStore;

class CPStore;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CEnumTypes;

class CEnumTypes;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CEnumItems;

class CEnumItems;
#endif
#endif /* __PSTORECLib_LIBRARY_DEFINED__ */

/****************************************
 * Generated header for interface: __MIDL__intf_0080
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */


HRESULT __stdcall PStoreCreateInstance(
    IPStore __RPC_FAR *__RPC_FAR *ppProvider,
    PST_PROVIDERID __RPC_FAR *pProviderID,
    void __RPC_FAR *pReserved,
    DWORD dwFlags);

HRESULT __stdcall PStoreEnumProviders(
    DWORD dwFlags,
    IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum);



extern RPC_IF_HANDLE __MIDL__intf_0080_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0080_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif // PSTORE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\ptypes32.h ===
/*****************************************************************************\
* Copyright (C) Microsoft Corporation, 1990-1999
* PTYPES32.H - PORTABILITY MAPPING HEADER FILE
*
* This file provides types for 16/32 bit portable code.
\*****************************************************************************/

#if _MSC_VER > 1000
#pragma once
#endif

#include <setjmp.h>

/* TYPES: */

#define    HUGE_T
typedef    DWORD        WORD2DWORD     ;
typedef    DWORD        CHARPARM       ;
typedef    DWORD        SHORTPARM      ;
typedef    DWORD        VERSION        ;
typedef    LPSTR        PDLLMEM        ;
typedef    unsigned long  CHAR2ULONG   ;
typedef    unsigned long  USHORT2ULONG ;
typedef    unsigned long  SHORT2ULONG  ;
typedef    unsigned long  INT2DWORD    ;
typedef    unsigned short BYTE2WORD    ;
typedef    POINTS       MPOINT         ;
typedef    WORD         INT2WORD       ;
typedef    jmp_buf      MCATCHBUF      ;
typedef    MCATCHBUF    *LPMCATCHBUF   ;

#define HFILE2INT(h, flags)     (INT)_open_osfhandle((long)(h), (int)(flags))
#define INT2HFILE(i)            (HFILE)_get_osfhandle((int)(i))
#define DUPHFILE(h)             MDupHandle(h)
#define MGLOBALPTR(p)           (LPSTR)(p)

/* PRAGMAS */

#define _LOADDS
#define _EXPORT

#define ERROR_GETADDR_FAILED    0x8001

#define INITWINDOWS()

#define WF_PMODE        0x0001      /* from winkrnl.h */
#define WF_CPU286       0x0002
#define WF_CPU386       0x0004
#define WF_CPU486       0x0008
#define WF_STANDARD     0x0010
#define WF_WIN286       0x0010
#define WF_ENHANCED     0x0020
#define WF_WIN386       0x0020
#define WF_CPU086       0x0040
#define WF_CPU186       0x0080
#define WF_LARGEFRAME   0x0100
#define WF_SMALLFRAME   0x0200
#define WF_80x87        0x0400


/* DEFINITIONS */


#define TF_FORCEDRIVE       (BYTE)0x80
#define DLLMEM_MOVEABLE     0
#define DLLMEM_ZEROINIT     GMEM_ZEROINIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\pwin16.h ===
/*****************************************************************************\
* Copyright (C) Microsoft Corporation, 1990-1999
* PWIN16.H - PORTABILITY MAPPING HEADER FILE
*
* This file provides macros to map portable windows code to its 16 bit form.
\*****************************************************************************/

#if _MSC_VER > 1000
#pragma once
#endif

/*-----------------------------------USER------------------------------------*/

DWORD FAR PASCAL     MGetLastError(VOID);
DWORD FAR PASCAL     MSendMsgEM_GETSEL(HWND hDlg, INT FAR *piStart, INT FAR *piEnd);

/* HELPER MACROS */

#define MAPVALUE(v16, v32)              (v16)
#define MAPTYPE(v16, v32)               v16
#define MAKEMPOINT(l)                   (*((MPOINT FAR *)&(l)))
#define MPOINT2POINT(mpt, pt)           (pt = *(POINT FAR *)&(mpt))
#define POINT2MPOINT(pt, mpt)           (mpt = *(MPOINT FAR *)&(pt))
#define LONG2POINT(l, pt)               ((pt).x = (INT)LOWORD(l), (pt).y = (INT)HIWORD(l))

#define GETWINDOWUINT(hwnd, index)      (UINT)GetWindowWord(hwnd, index)
#define SETWINDOWUINT(hwnd, index, ui)  (UINT)SetWindowWord(hwnd, index, (WORD)(ui))
#define SETCLASSUINT(hwnd, index, ui)   (UINT)SetClassWord(hwnd, index, (WORD)(ui))
#define GETCLASSUINT(hwnd, index)       (UINT)GetClassWord(hwnd, index)

#define GETCBCLSEXTRA(hwnd)             GETCLASSUINT(hwnd, GCW_CBCLSEXTRA)
#define SETCBCLSEXTRA(hwnd, cb)         SETCLASSUINT(hwnd, GCW_CBCLSEXTRA, cb)
#define GETCBWNDEXTRA(hwnd)             GETCLASSUINT(hwnd, GCW_CBWNDEXTRA)
#define SETCBWNDEXTRA(hwnd, cb)         SETCLASSUINT(hwnd, GCW_CBWNDEXTRA, cb)
#define GETCLASSBRBACKGROUND(hwnd)      (HBRUSH)GETCLASSUINT(hwnd, GCW_HBRBACKGROUND)
#define SETCLASSBRBACKGROUND(hwnd, h)   (HBRUSH)SETCLASSUINT(hwnd, GCW_HBRBACKGROUND, h)
#define GETCLASSCURSOR(hwnd)            (HCURSOR)GETCLASSUINT(hwnd, GCW_HCURSOR)
#define SETCLASSCURSOR(hwnd, h)         (HCURSOR)SETCLASSUINT(hwnd, GCW_HCURSOR, h)
#define GETCLASSHMODULE(hwnd)           (HMODULE)GETCLASSUINT(hwnd, GCW_HMODULE)
#define SETCLASSHMODULE(hwnd, h)        (HMODULE)SETCLASSUINT(hwnd, GCW_HMODULE, h)
#define GETCLASSICON(hwnd)              (HICON)GETCLASSUINT((hwnd), GCW_HICON)
#define SETCLASSICON(hwnd, h)           (HICON)SETCLASSUINT((hwnd), GCW_HICON, h)
#define GETCLASSSTYLE(hwnd)             GETCLASSUINT((hwnd), GCW_STYLE)
#define SETCLASSSTYLE(hwnd, style)      SETCLASSUINT((hwnd), GCW_STYLE, style)
#define GETHWNDINSTANCE(hwnd)           (HMODULE)GETWINDOWUINT((hwnd), GWW_HINSTANCE)
#define SETHWNDINSTANCE(hwnd, h)        (HMODULE)SETWINDOWUINT((hwnd), GWW_HINSTANCE, h)
#define GETHWNDPARENT(hwnd)             (HWND)GETWINDOWUINT((hwnd), GWW_HWNDPARENT)
#define SETHWNDPARENT(hwnd, h)          (HWND)SETWINDOWUINT((hwnd), GWW_HWNDPARENT, h)
#define GETWINDOWID(hwnd)               GETWINDOWUINT((hwnd), GWW_ID)
#define SETWINDOWID(hwnd, id)           SETWINDOWUINT((hwnd), GWW_ID, id)

/* USER API */

#define MDlgDirSelect(hDlg, lpstr, nLength, nIDListBox) \
            DlgDirSelect(hDlg, lpstr, nIDListBox)

#define MDlgDirSelectCOMBOBOX(hDlg, lpstr, nLength, nIDComboBox) \
            DlgDirSelectComboBox(hDlg, lpstr, nIDComboBox)

#define MMain(hInst, hPrevInst, lpCmdLine, nCmdShow) \
   INT PASCAL WinMain(HANDLE hInst, HANDLE hPrevInst, LPSTR lpCmdLine, \
   INT nCmdShow) {  \
   INT _argc;       \
   CHAR **_argv;

/* USER MESSAGES: */

#define GET_WPARAM(wp, lp)                      (wp)
#define GET_LPARAM(wp, lp)                      (lp)

#define WM_CTLCOLORMSGBOX       0x0132
#define WM_CTLCOLOREDIT         0x0133
#define WM_CTLCOLORLISTBOX      0x0134
#define WM_CTLCOLORBTN          0x0135
#define WM_CTLCOLORDLG          0x0136
#define WM_CTLCOLORSCROLLBAR    0x0137
#define WM_CTLCOLORSTATIC       0x0138

#define GET_WM_ACTIVATE_STATE(wp, lp)               (wp)
#define GET_WM_ACTIVATE_FMINIMIZED(wp, lp)          (BOOL)HIWORD(lp)
#define GET_WM_ACTIVATE_HWND(wp, lp)                (HWND)LOWORD(lp)
#define GET_WM_ACTIVATE_MPS(s, fmin, hwnd)   \
        (WPARAM)(s), MAKELONG(hwnd, fmin)

#define GET_WM_CHARTOITEM_CHAR(wp, lp)              (CHAR)(wp)
#define GET_WM_CHARTOITEM_POS(wp, lp)               HIWORD(lp)
#define GET_WM_CHARTOITEM_HWND(wp, lp)              (HWND)LOWORD(lp)
#define GET_WM_CHARTOITEM_MPS(ch, pos, hwnd) \
        (WPARAM)(ch), MAKELONG(hwnd, pos)

#define GET_WM_COMMAND_ID(wp, lp)                   (wp)
#define GET_WM_COMMAND_HWND(wp, lp)                 (HWND)LOWORD(lp)
#define GET_WM_COMMAND_CMD(wp, lp)                  HIWORD(lp)
#define GET_WM_COMMAND_MPS(id, hwnd, cmd)    \
        (WPARAM)(id), MAKELONG(hwnd, cmd)

#define GET_WM_CTLCOLOR_HDC(wp, lp, msg)            (HDC)(wp)
#define GET_WM_CTLCOLOR_HWND(wp, lp, msg)           (HWND)LOWORD(lp)
#define GET_WM_CTLCOLOR_TYPE(wp, lp, msg)           HIWORD(lp)
#define GET_WM_CTLCOLOR_MPS(hdc, hwnd, type) \
        (WPARAM)(hdc), MAKELONG(hwnd, type)

#define GET_WM_MENUSELECT_CMD(wp, lp)               (wp)
#define GET_WM_MENUSELECT_FLAGS(wp, lp)             LOWORD(lp)
#define GET_WM_MENUSELECT_HMENU(wp, lp)             (HMENU)HIWORD(lp)
#define GET_WM_MENUSELECT_MPS(cmd, f, hmenu)  \
        (WPARAM)(cmd), MAKELONG(f, hmenu)

// Note: the following are for interpreting MDIclient to MDI child messages.
#define GET_WM_MDIACTIVATE_FACTIVATE(hwnd, wp, lp)  (BOOL)(wp)
#define GET_WM_MDIACTIVATE_HWNDDEACT(wp, lp)        (HWND)HIWORD(lp)
#define GET_WM_MDIACTIVATE_HWNDACTIVATE(wp, lp)     (HWND)LOWORD(lp)
// Note: the following is for sending to the MDI client window.
#define GET_WM_MDIACTIVATE_MPS(f, hwndD, hwndA)\
        (WPARAM)(hwndA), 0

#define GET_WM_MDISETMENU_MPS(hmenuF, hmenuW) 0, MAKELONG(hmenuF, hmenuW)

#define GET_WM_MENUCHAR_CHAR(wp, lp)                (CHAR)(wp)
#define GET_WM_MENUCHAR_HMENU(wp, lp)               (HMENU)LOWORD(lp)
#define GET_WM_MENUCHAR_FMENU(wp, lp)               (BOOL)HIWORD(lp)
#define GET_WM_MENUCHAR_MPS(ch, hmenu, f)    \
        (WPARAM)(ch), MAKELONG(hmenu, f)

#define GET_WM_PARENTNOTIFY_MSG(wp, lp)             (wp)
#define GET_WM_PARENTNOTIFY_ID(wp, lp)              HIWORD(lp)
#define GET_WM_PARENTNOTIFY_HWNDCHILD(wp, lp)       (HWND)LOWORD(lp)
#define GET_WM_PARENTNOTIFY_X(wp, lp)               (INT)LOWORD(lp)
#define GET_WM_PARENTNOTIFY_Y(wp, lp)               (INT)HIWORD(lp)
#define GET_WM_PARENTNOTIFY_MPS(msg, id, hwnd) \
        (WPARAM)(msg), MAKELONG(hwnd, id)
#define GET_WM_PARENTNOTIFY2_MPS(msg, x, y) \
        (WPARAM)(msg), MAKELONG(x, y)

#define GET_WM_VKEYTOITEM_CODE(wp, lp)              (wp)
#define GET_WM_VKEYTOITEM_ITEM(wp, lp)              (INT)HIWORD(lp)
#define GET_WM_VKEYTOITEM_HWND(wp, lp)              (HWND)LOWORD(lp)
#define GET_WM_VKEYTOITEM_MPS(code, item, hwnd) \
        (WPARAM)(code), MAKELONG(hwnd, item)

#define GET_EM_SETSEL_START(wp, lp)                 LOWORD(lp)
#define GET_EM_SETSEL_END(wp, lp)                   HIWORD(lp)
#define GET_EM_SETSEL_MPS(iStart, iEnd) \
        0, MAKELONG(iStart, iEnd)

#define GET_EM_LINESCROLL_MPS(vert, horz)     \
        0, MAKELONG(vert, horz)

#define GET_WM_HSCROLL_CODE(wp, lp)                 (wp)
#define GET_WM_HSCROLL_POS(wp, lp)                  LOWORD(lp)
#define GET_WM_HSCROLL_HWND(wp, lp)                 (HWND)HIWORD(lp)
#define GET_WM_HSCROLL_MPS(code, pos, hwnd)    \
        (WPARAM)(code), MAKELONG(pos, hwnd)

#define GET_WM_VSCROLL_CODE(wp, lp)                 (wp)
#define GET_WM_VSCROLL_POS(wp, lp)                  LOWORD(lp)
#define GET_WM_VSCROLL_HWND(wp, lp)                 (HWND)HIWORD(lp)
#define GET_WM_VSCROLL_MPS(code, pos, hwnd)    \
        (WPARAM)(code), MAKELONG(pos, hwnd)

#define GET_WM_CHANGECBCHAIN_HWNDNEXT(wp, lp)       (HWND)LOWORD(lp)

#define DDEFREE(msg, lp)

#define GET_WM_DDE_ACK_STATUS(wp, lp)               LOWORD(lp)
#define GET_WM_DDE_ACK_ITEM(wp, lp)                 (ATOM)HIWORD(lp)
#define MPostWM_DDE_ACK(hTo, hFrom, wStatus, aItem) \
        PostMessage(hTo, WM_DDE_ACK, (WPARAM)hFrom, MAKELONG(wStatus, aItem))

#define GET_WM_DDE_ADVISE_HOPTIONS(wp, lp)          (HANDLE)LOWORD(lp)
#define GET_WM_DDE_ADVISE_ITEM(wp, lp)              (ATOM)HIWORD(lp)
#define MPostWM_DDE_ADVISE(hTo, hFrom, hOptions, aItem) \
        PostMessage(hTo, WM_DDE_ADVISE, (WPARAM)hFrom, MAKELONG(hOptions, aItem))

#define GET_WM_DDE_DATA_HDATA(wp, lp)               (HANDLE)LOWORD(lp)
#define GET_WM_DDE_DATA_ITEM(wp, lp)                (ATOM)HIWORD(lp)
#define MPostWM_DDE_DATA(hTo, hFrom, hData, aItem) \
        PostMessage(hTo, WM_DDE_DATA, (WPARAM)hFrom, MAKELONG(hData, aItem))

#define GET_WM_DDE_EXECUTE_HDATA(wp, lp)            (HANDLE)HIWORD(lp)
#define MPostWM_DDE_EXECUTE(hTo, hFrom, hDataExec) \
        PostMessage(hTo, WM_DDE_EXECUTE, (WPARAM)hFrom, MAKELONG(0, hDataExec))

#define GET_WM_DDE_POKE_HDATA(wp, lp)               (HANDLE)LOWORD(lp)
#define GET_WM_DDE_POKE_ITEM(wp, lp)                (ATOM)HIWORD(lp)
#define MPostWM_DDE_POKE(hTo, hFrom, hData, aItem) \
        PostMessage(hTo, WM_DDE_POKE, (WPARAM)hFrom, MAKELONG(hData, aItem))

#define GET_WM_DDE_EXECACK_STATUS(wp, lp)           (WORD)LOWORD(lp)
#define GET_WM_DDE_EXECACK_HDATA(wp, lp)            (HANDLE)HIWORD(lp)
#define MPostWM_DDE_EXECACK(hTo, hFrom, hCommands, wStatus) \
        PostMessage(hTo, WM_DDE_ACK, (WPARAM)hFrom, MAKELONG(wStatus, hCommands))

#define GET_WM_DDE_REQUEST_FORMAT(wp, lp)           (ATOM)LOWORD(lp)
#define GET_WM_DDE_REQUEST_ITEM(wp, lp)             (ATOM)HIWORD(lp)
#define MPostWM_DDE_REQUEST(hTo, hFrom, fmt, aItem) \
        PostMessage(hTo, WM_DDE_REQUEST, (WPARAM)hFrom, MAKELONG(fmt, aItem))

#define GET_WM_DDE_UNADVISE_FORMAT(wp, lp)          (ATOM)LOWORD(lp)
#define GET_WM_DDE_UNADVISE_ITEM(wp, lp)            (ATOM)HIWORD(lp)
#define MPostWM_DDE_UNADVISE(hTo, hFrom, fmt, aItem) \
        PostMessage(hTo, WM_DDE_UNADVISE, (WPARAM)hFrom, MAKELONG(fmt, aItem))

#define MPostWM_DDE_TERMINATE(hTo, hFrom) \
        PostMessage(hTo, WM_DDE_TERMINATE, (WPARAM)hFrom, 0)

/*-----------------------------------GDI-------------------------------------*/

BOOL  FAR PASCAL     MGetAspectRatioFilter(HDC hdc, INT FAR * pcx, INT FAR * pcy);
BOOL  FAR PASCAL     MGetBitmapDimension(HANDLE hBitmap, INT FAR * pcx, INT FAR * pcy);
BOOL  FAR PASCAL     MGetBrushOrg(HDC hdc, INT FAR * px, INT FAR * py);
BOOL  FAR PASCAL     MGetCurrentPosition(HDC hdc, INT FAR * px, INT FAR * py);
BOOL  FAR PASCAL     MGetTextExtent(HDC hdc, LPSTR lpstr, INT cnt, INT FAR * pcx, INT FAR * pcy);
BOOL  FAR PASCAL     MGetViewportExt(HDC hdc, INT FAR * pcx, INT FAR * pcy);
BOOL  FAR PASCAL     MGetViewportOrg(HDC hdc, INT FAR * px, INT FAR * py);
BOOL  FAR PASCAL     MGetWindowExt(HDC hdc, INT FAR * pcx, INT FAR * pcy);
BOOL  FAR PASCAL     MGetWindowOrg(HDC hdc, INT FAR * px, INT FAR * py);

#define MCreateDiscardableBitmap CreateDiscardableBitmap
#define MMoveTo                  (VOID)MoveTo
#define MOffsetViewportOrg       (VOID)OffsetViewportOrg
#define MOffsetWindowOrg         (VOID)OffsetWindowOrg
#define MScaleViewportExt        (VOID)ScaleViewportExt
#define MScaleWindowExt          (VOID)ScaleWindowExt
#define MSetBitmapDimension      (VOID)SetBitmapDimension
#define MSetBrushOrg             (VOID)SetBrushOrg
#define MSetViewportExt          (VOID)SetViewportExt
#define MSetViewportOrg          (VOID)SetViewportOrg
#define MSetWindowExt            (VOID)SetWindowExt
#define MSetWindowOrg            (VOID)SetWindowOrg
#define MUnrealizeObject         UnrealizeObject


/*-------------------------------------DEV-----------------------------------*/

DWORD FAR PASCAL     MDeviceCapabilities(LPSTR lpDriverName,
    LPSTR lpDeviceName, LPSTR lpPort, WORD2DWORD nIndex, LPSTR lpOutput,
    LPDEVMODE lpDevMode);
BOOL  FAR PASCAL     MDeviceMode(HWND hWnd, LPSTR lpDriverName,
    LPSTR lpDeviceName, LPSTR lpOutput);
WORD2DWORD FAR PASCAL    MExtDeviceMode(HWND hWnd,LPSTR lpDriverName,
    LPDEVMODE lpDevModeOutput, LPSTR lpDeviceName, LPSTR lpPort,
    LPDEVMODE lpDevModeInput, LPSTR lpProfile, WORD2DWORD flMode);

/*-----------------------------------KERNEL----------------------------------*/

HANDLE FAR PASCAL   MLoadLibrary(LPSTR lpszFilename);
BOOL FAR PASCAL MDeleteFile(LPSTR lpPathName);

#define DLLMEM_MOVEABLE         LMEM_MOVEABLE
#define DLLMEM_ZEROINIT         LMEM_ZEROINIT
#define GETMAJORVERSION(x)      LOBYTE(x)
#define GETMINORVERSION(x)      HIBYTE(x)

#define MCATCHBUF               CATCHBUF
#define LPMCATCHBUF             LPCATCHBUF

/* FUNCTION MAPPINGS */

#define MLocalInit               LocalInit
#define MLockData(dummy)         LockData(dummy)
#define MUnlockData(dummy)       UnlockData(dummy)
#define MDllSharedAlloc          LocalAlloc
#define MDllSharedFlags          LocalFlags
#define MDllSharedFree           LocalFree
#define MDllSharedHandle         LocalHandle
#define MDllSharedLock           LocalLock
#define MDllSharedRealloc        LocalReAlloc
#define MDllSharedSize           LocalSize
#define MDllSharedUnlock         LocalUnlock
#define MFreeDOSEnvironment(p)   TRUE
#define MGetCurrentTask          GetCurrentTask
#define MGetDOSEnvironment       GetDOSEnvironment
#define MGetDriveType            GetDriveType
#define MGetModuleUsage          GetModuleUsage
#define MGetTempDrive            GetTempDrive
#define MGetTempFileName         GetTempFileName
#define MGetWinFlags             GetWinFlags
#define MOpenComm                (HFILE)OpenComm
#define MSetCommState(fh, lpDCB) SetCommState(lpDCB)
#define MReadComm                ReadComm
#define MWriteComm               WriteComm
#define MCloseComm               CloseComm
#define MOpenFile                (HFILE)OpenFile
#define MThrow                   Throw
#define MCatch                   Catch
#define M_lclose                 _lclose
#define M_lcreat                 (HFILE)_lcreat
#define M_llseek                 _llseek
#define M_lopen                  (HFILE)_lopen
#define M_lread                  _lread
#define M_lwrite                 _lwrite
#define MGetMetaFileBits         GetMetaFileBits
#define MSetMetaFileBits         SetMetaFileBits
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\pwin32.h ===
#ifndef __PWIN32_H__
#define __PWIN32_H__

#if _MSC_VER > 1000
#pragma once
#endif

#include <dde.h>

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

/*****************************************************************************\
* Copyright (C) Microsoft Corporation, 1990-1999
* PWIN32.H - PORTABILITY MAPPING HEADER FILE
*
* This file provides macros to map portable windows code to its 32 bit form.
\*****************************************************************************/

/*-----------------------------------USER------------------------------------*/

/* HELPER MACROS */

#define MAPVALUE(v16, v32)              (v32)
#define MAPTYPE(v16, v32)               v32
#define MAKEMPOINT(l)                   (*((MPOINT *)&(l)))
#define MPOINT2POINT(mpt,pt)            ((pt).x = (mpt).x, (pt).y = (mpt).y)
#define POINT2MPOINT(pt, mpt)           ((mpt).x = (SHORT)(pt).x, (mpt).y = (SHORT)(pt).y)
#define LONG2POINT(l, pt)               ((pt).x = (SHORT)LOWORD(l), (pt).y = (SHORT)HIWORD(l))

#define SETWINDOWUINT(hwnd, index, ui)  (UINT)SetWindowLong(hwnd, index, (LONG)(ui))
#define GETWINDOWUINT(hwnd, index)      (UINT)GetWindowLong(hwnd, index)
#define SETCLASSUINT(hwnd, index, ui)   (UINT)SetClassLong(hwnd, index, (LONG)(ui))
#define GETCLASSUINT(hwnd, index)       (UINT)GetClassLong(hwnd, index)

#define GETCBCLSEXTRA(hwnd)             GETCLASSUINT(hwnd, GCL_CBCLSEXTRA)
#define SETCBCLSEXTRA(hwnd, cb)         SETCLASSUINT(hwnd, GCL_CBCLSEXTRA, cb)
#define GETCBWNDEXTRA(hwnd)             GETCLASSUINT(hwnd, GCL_CBWNDEXTRA)
#define SETCBWNDEXTRA(hwnd, cb)         SETCLASSUINT(hwnd, GCL_CBWNDEXTRA, cb)
#define GETCLASSBRBACKGROUND(hwnd)      (HBRUSH)GetClassLongPtr((hwnd), GCLP_HBRBACKGROUND)
#define SETCLASSBRBACKGROUND(hwnd, h)   (HBRUSH)SetClassLongPtr((hwnd), GCLP_HBRBACKGROUND, (LONG_PTR)(h))
#define GETCLASSCURSOR(hwnd)            (HCURSOR)GetClassLongPtr((hwnd), GCLP_HCURSOR)
#define SETCLASSCURSOR(hwnd, h)         (HCURSOR)SetClassLongPtr((hwnd), GCLP_HCURSOR, (LONG_PTR)(h))
#define GETCLASSHMODULE(hwnd)           (HMODULE)GetClassLongPtr((hwnd), GCLP_HMODULE)
#define SETCLASSHMODULE(hwnd, h)        (HMODULE)SetClassLongPtr((hwnd), GCLP_HMODULE, (LONG_PTR)(h))
#define GETCLASSICON(hwnd)              (HICON)GetClassLongPtr((hwnd), GCLP_HICON)
#define SETCLASSICON(hwnd, h)           (HICON)SetClassLongPtr((hwnd), GCLP_HICON, (LONG_PTR)(h))
#define GETCLASSSTYLE(hwnd)             GETCLASSUINT((hwnd), GCL_STYLE)
#define SETCLASSSTYLE(hwnd, style)      SETCLASSUINT((hwnd), GCL_STYLE, style)
#define GETHWNDINSTANCE(hwnd)           (HINSTANCE)GetWindowLongPtr((hwnd), GWLP_HINSTANCE)
#define SETHWNDINSTANCE(hwnd, h)        (HINSTANCE)SetWindowLongPtr((hwnd), GWLP_HINSTANCE, (LONG_PTR)(h))
#define GETHWNDPARENT(hwnd)             (HWND)GetWindowLongPtr((hwnd), GWLP_HWNDPARENT)
#define SETHWNDPARENT(hwnd, h)          (HWND)SetWindowLongPtr((hwnd), GWLP_HWNDPARENT, (LONG_PTR)(h))
#define GETWINDOWID(hwnd)               GETWINDOWUINT((hwnd), GWL_ID)
#define SETWINDOWID(hwnd, id)           SETWINDOWUINT((hwnd), GWL_ID, id)

/* USER API */

#define MDlgDirSelect(hDlg, lpstr, nLength, nIDListBox) \
    DlgDirSelectEx(hDlg, lpstr, nLength, nIDListBox)

#define MDlgDirSelectCOMBOBOX(hDlg, lpstr, nLength, nIDComboBox) \
    DlgDirSelectComboBoxEx(hDlg, lpstr, nLength, nIDComboBox)

#define MGetLastError                    GetLastError

#define MMain(hInst, hPrevInst, lpCmdLine, nCmdShow) \
   INT WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR lpCmdLine, \
   INT nCmdShow) {  \
   INT _argc;       \
   CHAR **_argv;

__inline LPSTR MGetCmdLine()
{
    LPSTR lpCmdLine, lpT;

    lpCmdLine = GetCommandLineA();

    // on NT, lpCmdLine's first string includes its own name, remove this
    // to make it exactly like the windows command line.

    if (*lpCmdLine) {
        lpT = strchr(lpCmdLine, ' ');   // skip self name
        if (lpT) {
            lpCmdLine = lpT;
            while (*lpCmdLine == ' ') {
                lpCmdLine++;            // skip spaces to end or first cmd
            }
        } else {
            lpCmdLine += strlen(lpCmdLine);   // point to NULL
        }
    }
    return(lpCmdLine);
}

__inline DWORD APIENTRY MSendMsgEM_GETSEL(HWND hDlg, WORD2DWORD * piStart, WORD2DWORD * piEnd)
{
    DWORD   dw;

    dw = (DWORD)SendMessage(hDlg, EM_GETSEL, 0, 0);
    if (piEnd != NULL)
        *piEnd   = (WORD2DWORD) HIWORD(dw);
    if (piStart != NULL)
        *piStart = (WORD2DWORD) LOWORD(dw);

    return(dw);
}


/* USER MESSAGES: */

#define GET_WPARAM(wp, lp)                      (wp)
#define GET_LPARAM(wp, lp)                      (lp)

#define GET_WM_ACTIVATE_STATE(wp, lp)           LOWORD(wp)
#define GET_WM_ACTIVATE_FMINIMIZED(wp, lp)      (BOOL)HIWORD(wp)
#define GET_WM_ACTIVATE_HWND(wp, lp)            (HWND)(lp)
#define GET_WM_ACTIVATE_MPS(s, fmin, hwnd)   \
        (WPARAM)MAKELONG((s), (fmin)), (LPARAM)(hwnd)

#define GET_WM_CHARTOITEM_CHAR(wp, lp)          (TCHAR)LOWORD(wp)
#define GET_WM_CHARTOITEM_POS(wp, lp)           HIWORD(wp)
#define GET_WM_CHARTOITEM_HWND(wp, lp)          (HWND)(lp)
#define GET_WM_CHARTOITEM_MPS(ch, pos, hwnd) \
        (WPARAM)MAKELONG((pos), (ch)), (LPARAM)(hwnd)

#define GET_WM_COMMAND_ID(wp, lp)               LOWORD(wp)
#define GET_WM_COMMAND_HWND(wp, lp)             (HWND)(lp)
#define GET_WM_COMMAND_CMD(wp, lp)              HIWORD(wp)
#define GET_WM_COMMAND_MPS(id, hwnd, cmd)    \
        (WPARAM)MAKELONG(id, cmd), (LPARAM)(hwnd)

#define WM_CTLCOLOR                             0x0019

#define GET_WM_CTLCOLOR_HDC(wp, lp, msg)        (HDC)(wp)
#define GET_WM_CTLCOLOR_HWND(wp, lp, msg)       (HWND)(lp)
#define GET_WM_CTLCOLOR_TYPE(wp, lp, msg)       (WORD)(msg - WM_CTLCOLORMSGBOX)
#define GET_WM_CTLCOLOR_MSG(type)               (WORD)(WM_CTLCOLORMSGBOX+(type))
#define GET_WM_CTLCOLOR_MPS(hdc, hwnd, type) \
        (WPARAM)(hdc), (LPARAM)(hwnd)


#define GET_WM_MENUSELECT_CMD(wp, lp)               LOWORD(wp)
#define GET_WM_MENUSELECT_FLAGS(wp, lp)             (UINT)(int)(short)HIWORD(wp)
#define GET_WM_MENUSELECT_HMENU(wp, lp)             (HMENU)(lp)
#define GET_WM_MENUSELECT_MPS(cmd, f, hmenu)  \
        (WPARAM)MAKELONG(cmd, f), (LPARAM)(hmenu)

// Note: the following are for interpreting MDIclient to MDI child messages.
#define GET_WM_MDIACTIVATE_FACTIVATE(hwnd, wp, lp)  (lp == (LPARAM)hwnd)
#define GET_WM_MDIACTIVATE_HWNDDEACT(wp, lp)        (HWND)(wp)
#define GET_WM_MDIACTIVATE_HWNDACTIVATE(wp, lp)     (HWND)(lp)
// Note: the following is for sending to the MDI client window.
#define GET_WM_MDIACTIVATE_MPS(f, hwndD, hwndA)\
        (WPARAM)(hwndA), 0

#define GET_WM_MDISETMENU_MPS(hmenuF, hmenuW) (WPARAM)hmenuF, (LPARAM)hmenuW

#define GET_WM_MENUCHAR_CHAR(wp, lp)                (TCHAR)LOWORD(wp)
#define GET_WM_MENUCHAR_HMENU(wp, lp)               (HMENU)(lp)
#define GET_WM_MENUCHAR_FMENU(wp, lp)               (BOOL)HIWORD(wp)
#define GET_WM_MENUCHAR_MPS(ch, hmenu, f)    \
        (WPARAM)MAKELONG(ch, f), (LPARAM)(hmenu)

#define GET_WM_PARENTNOTIFY_MSG(wp, lp)             LOWORD(wp)
#define GET_WM_PARENTNOTIFY_ID(wp, lp)              HIWORD(wp)
#define GET_WM_PARENTNOTIFY_HWNDCHILD(wp, lp)       (HWND)(lp)
#define GET_WM_PARENTNOTIFY_X(wp, lp)               (INT)LOWORD(lp)
#define GET_WM_PARENTNOTIFY_Y(wp, lp)               (INT)HIWORD(lp)
#define GET_WM_PARENTNOTIFY_MPS(msg, id, hwnd) \
        (WPARAM)MAKELONG(id, msg), (LPARAM)(hwnd)
#define GET_WM_PARENTNOTIFY2_MPS(msg, x, y) \
        (WPARAM)MAKELONG(0, msg), MAKELONG(x, y)

#define GET_WM_VKEYTOITEM_CODE(wp, lp)              (INT)LOWORD(wp)
#define GET_WM_VKEYTOITEM_ITEM(wp, lp)              HIWORD(wp)
#define GET_WM_VKEYTOITEM_HWND(wp, lp)              (HWND)(lp)
#define GET_WM_VKEYTOITEM_MPS(code, item, hwnd) \
        (WPARAM)MAKELONG(item, code), (LPARAM)(hwnd)

#define GET_EM_SETSEL_START(wp, lp)                 (INT)(wp)
#define GET_EM_SETSEL_END(wp, lp)                   (lp)
#define GET_EM_SETSEL_MPS(iStart, iEnd) \
        (WPARAM)(iStart), (LONG)(iEnd)

#define GET_EM_LINESCROLL_MPS(vert, horz)     \
        (WPARAM)horz, (LONG)vert

#define GET_WM_CHANGECBCHAIN_HWNDNEXT(wp, lp)       (HWND)(lp)

#define GET_WM_HSCROLL_CODE(wp, lp)                 LOWORD(wp)
#define GET_WM_HSCROLL_POS(wp, lp)                  HIWORD(wp)
#define GET_WM_HSCROLL_HWND(wp, lp)                 (HWND)(lp)
#define GET_WM_HSCROLL_MPS(code, pos, hwnd)    \
        (WPARAM)MAKELONG(code, pos), (LPARAM)(hwnd)

#define GET_WM_VSCROLL_CODE(wp, lp)                 LOWORD(wp)
#define GET_WM_VSCROLL_POS(wp, lp)                  HIWORD(wp)
#define GET_WM_VSCROLL_HWND(wp, lp)                 (HWND)(lp)
#define GET_WM_VSCROLL_MPS(code, pos, hwnd)    \
        (WPARAM)MAKELONG(code, pos), (LPARAM)(hwnd)

/* DDE macros */

__inline UINT_PTR APIENTRY MGetDDElParamLo(UINT msg,LPARAM lParam)
{
    UINT_PTR uiLo;

    if (UnpackDDElParam(msg, lParam, &uiLo, NULL))
        return uiLo;
    else
        return 0;
}
__inline UINT_PTR APIENTRY MGetDDElParamHi(UINT msg,LPARAM lParam)
{
    UINT_PTR uiHi;

    if (UnpackDDElParam(msg, lParam, NULL, &uiHi))
        return uiHi;
    else
        return 0;
}

__inline BOOL APIENTRY MPostDDEMsg(HWND hwndTo,UINT msg,HWND hwndFrom,UINT_PTR uiLo,UINT_PTR uiHi)
{
    LPARAM lParam;

    lParam = PackDDElParam(msg, uiLo, uiHi);
    if (lParam) {
        if (PostMessage(hwndTo, msg, (WPARAM)hwndFrom, lParam)) {
            return(TRUE);
        }
        FreeDDElParam(msg, lParam);
    }
    return(FALSE);
}

#define DDEFREE(msg, lp)                            FreeDDElParam(msg, lp)

#define GET_WM_DDE_ACK_STATUS(wp, lp)               ((WORD)MGetDDElParamLo(WM_DDE_ACK, lp))
#define GET_WM_DDE_ACK_ITEM(wp, lp)                 ((ATOM)MGetDDElParamHi(WM_DDE_ACK, lp))
#define MPostWM_DDE_ACK(hTo, hFrom, wStatus, aItem) \
        MPostDDEMsg(hTo, WM_DDE_ACK, hFrom, (UINT_PTR)wStatus, (UINT_PTR)aItem)

#define GET_WM_DDE_ADVISE_HOPTIONS(wp, lp)          ((HANDLE)MGetDDElParamLo(WM_DDE_ADVISE, lp))
#define GET_WM_DDE_ADVISE_ITEM(wp, lp)              ((ATOM)MGetDDElParamHi(WM_DDE_ADVISE, lp))
#define MPostWM_DDE_ADVISE(hTo, hFrom, hOptions, aItem) \
        MPostDDEMsg(hTo, WM_DDE_ADVISE, hFrom, (UINT_PTR)hOptions, (UINT_PTR)aItem)

#define GET_WM_DDE_DATA_HDATA(wp, lp)               ((HANDLE)MGetDDElParamLo(WM_DDE_DATA, lp))
#define GET_WM_DDE_DATA_ITEM(wp, lp)                ((ATOM)MGetDDElParamHi(WM_DDE_DATA, lp))
#define MPostWM_DDE_DATA(hTo, hFrom, hData, aItem) \
        MPostDDEMsg(hTo, WM_DDE_DATA, hFrom, (UINT_PTR)hData, (UINT_PTR)aItem)

#define GET_WM_DDE_EXECUTE_HDATA(wp, lp)            ((HANDLE)lp)
#define MPostWM_DDE_EXECUTE(hTo, hFrom, hDataExec) \
        PostMessage(hTo, WM_DDE_EXECUTE, (WPARAM)hFrom, (LPARAM)hDataExec)

#define GET_WM_DDE_POKE_HDATA(wp, lp)               ((HANDLE)MGetDDElParamLo(WM_DDE_POKE, lp))
#define GET_WM_DDE_POKE_ITEM(wp, lp)                ((ATOM)MGetDDElParamHi(WM_DDE_POKE, lp))
#define MPostWM_DDE_POKE(hTo, hFrom, hData, aItem) \
        MPostDDEMsg(hTo, WM_DDE_POKE, hFrom, (UINT_PTR)hData, (UINT_PTR)aItem)

#define GET_WM_DDE_EXECACK_STATUS(wp, lp)           ((WORD)MGetDDElParamLo(WM_DDE_ACK, lp))
#define GET_WM_DDE_EXECACK_HDATA(wp, lp)            ((HANDLE)MGetDDElParamHi(WM_DDE_ACK, lp))
#define MPostWM_DDE_EXECACK(hTo, hFrom, wStatus, hCommands) \
        MPostDDEMsg(hTo, WM_DDE_ACK, hFrom, (UINT_PTR)wStatus, (UINT_PTR)hCommands)

#define GET_WM_DDE_REQUEST_FORMAT(wp, lp)           ((ATOM)LOWORD(lp))
#define GET_WM_DDE_REQUEST_ITEM(wp, lp)             ((ATOM)HIWORD(lp))
#define MPostWM_DDE_REQUEST(hTo, hFrom, fmt, aItem) \
        MPostDDEMsg(hTo, WM_DDE_REQUEST, hFrom, (UINT_PTR)fmt, (UINT_PTR)aItem)

#define GET_WM_DDE_UNADVISE_FORMAT(wp, lp)          ((ATOM)LOWORD(lp))
#define GET_WM_DDE_UNADVISE_ITEM(wp, lp)            ((ATOM)HIWORD(lp))
#define MPostWM_DDE_UNADVISE(hTo, hFrom, fmt, aItem) \
        MPostDDEMsg(hTo, WM_DDE_UNADVISE, hFrom, (UINT_PTR)fmt, (UINT_PTR)aItem)

#define MPostWM_DDE_TERMINATE(hTo, hFrom) \
        PostMessage(hTo, WM_DDE_TERMINATE, (WPARAM)hFrom, 0L)


/*-----------------------------------GDI-------------------------------------*/

__inline BOOL APIENTRY MGetAspectRatioFilter(HDC hdc, INT * pcx, INT * pcy)
{
    SIZE Size;
    BOOL fSuccess;

    fSuccess = GetAspectRatioFilterEx(hdc, & Size);
    if (pcx != NULL)
        *pcx  = (INT)Size.cx;
    if (pcy != NULL)
        *pcy = (INT)Size.cy;

    return(fSuccess);
}

__inline BOOL APIENTRY MGetBitmapDimension(HANDLE hBitmap, INT * pcx, INT * pcy)
{

    SIZE Size;
    BOOL fSuccess;

    fSuccess = GetBitmapDimensionEx((HBITMAP)hBitmap, & Size);
    if (pcx != NULL)
        *pcx  = (INT)Size.cx;
    if (pcy != NULL)
        *pcy = (INT)Size.cy;

    return(fSuccess);

}

__inline BOOL APIENTRY MGetBrushOrg(HDC hdc, INT * px, INT * py)
{
    POINT   Point;
    BOOL fSuccess;

    fSuccess = GetBrushOrgEx(hdc, & Point);
    if (px != NULL)
        *px = Point.x;
    if (py != NULL)
        *py = Point.y;

    return(fSuccess);

}

__inline BOOL APIENTRY MGetCurrentPosition(HDC hdc, INT * px, INT * py)
{

    POINT   Point;
    BOOL fSuccess;

    fSuccess = GetCurrentPositionEx(hdc, & Point);
    if (px != NULL)
        *px = Point.x;
    if (py != NULL)
        *py = Point.y;

    return(fSuccess);

}

__inline BOOL APIENTRY MGetTextExtent(HDC hdc, LPSTR lpstr, INT cnt, INT * pcx, INT * pcy)
{
    SIZE Size;
    BOOL fSuccess;

    fSuccess = GetTextExtentPointA(hdc, lpstr, (DWORD)cnt, & Size);
    if (pcx != NULL)
        *pcx = (INT)Size.cx;
    if (pcy != NULL)
        *pcy = (INT)Size.cy;

    return(fSuccess);
}

__inline BOOL APIENTRY MGetViewportExt(HDC hdc, INT * pcx, INT * pcy)
{
    SIZE Size;
    BOOL fSuccess;

    fSuccess = GetViewportExtEx(hdc, & Size);
    if (pcx != NULL)
        *pcx = (INT)Size.cx;
    if (pcy != NULL)
        *pcy = (INT)Size.cy;

    return(fSuccess);
}

__inline BOOL APIENTRY MGetViewportOrg(HDC hdc, INT * px, INT * py)
{
    POINT   Point;
    BOOL    fSuccess;

    fSuccess = GetViewportOrgEx(hdc, & Point);
    if (px != NULL)
        *px = Point.x;
    if (py != NULL)
        *py = Point.y;

    return(fSuccess);
}

__inline BOOL APIENTRY MGetWindowExt(HDC hdc, INT * pcx, INT * pcy)
{
    SIZE Size;
    BOOL fSuccess;

    fSuccess = GetWindowExtEx(hdc, & Size);
    if (pcx != NULL)
        *pcx = (INT)Size.cx;
    if (pcy != NULL)
        *pcy = (INT)Size.cy;

    return(fSuccess);
}

__inline BOOL APIENTRY MGetWindowOrg(HDC hdc, INT * px, INT * py)
{
    POINT   Point;
    BOOL    fSuccess;

    fSuccess = GetWindowOrgEx(hdc, & Point);
    if (px != NULL)
        *px = Point.x;
    if (py != NULL)
        *py = Point.y;

    return(fSuccess);
}

__inline HANDLE APIENTRY MGetMetaFileBits(HMETAFILE hmf)
{
    HANDLE h;
    DWORD dwSize;

    h = GlobalAlloc(0, dwSize = GetMetaFileBitsEx(hmf, 0, NULL));
    if (h) {
        GetMetaFileBitsEx(hmf, dwSize, GlobalLock(h));
        GlobalUnlock(h);
        DeleteMetaFile(hmf);
    }
    return(h);
}

__inline HMETAFILE APIENTRY MSetMetaFileBits(HANDLE h)
{
    HMETAFILE hmf;

    hmf = SetMetaFileBitsEx((UINT) GlobalSize(h), (CONST BYTE *)GlobalLock(h));
    GlobalUnlock(h);
    GlobalFree(h);
    return(hmf);
}


#define MCreateDiscardableBitmap(h, x, y) CreateCompatibleBitmap(h, (DWORD)(x), (DWORD)(y))
#define MMoveTo(hdc, x, y)               MoveToEx(hdc, x, y, NULL)
#define MOffsetViewportOrg(hdc, x, y)    OffsetViewportOrgEx(hdc, x, y, NULL)
#define MOffsetWindowOrg(hdc, x, y)      OffsetWindowOrgEx(hdc, x, y, NULL)
#define MScaleViewportExt(hdc, x, y, xd, yd) ScaleViewportExtEx(hdc, x, y, xd, yd, NULL)
#define MScaleWindowExt(hdc, x, y, xd, yd)   ScaleWindowExtEx(hdc, x, y, xd, yd, NULL)
#define MSetBitmapDimension(hbm, x, y)   SetBitmapDimensionEx(hbm, (DWORD)(x), (DWORD)(y), NULL)
#define MSetBrushOrg(hbm, x, y)          SetBrushOrgEx(hbm, x, y, NULL)
#define MSetViewportExt(hdc, x, y)       SetViewportExtEx(hdc, x, y, NULL)
#define MSetViewportOrg(hdc, x, y)       SetViewportOrgEx(hdc, x, y, NULL)
#define MSetWindowExt(hdc, x, y)         SetWindowExtEx(hdc, x, y, NULL)
#define MSetWindowOrg(hdc, x, y)         SetWindowOrgEx(hdc, x, y, NULL)

/* Removed APIs */

#define MUnrealizeObject(h)          ((h), TRUE)

/*-----------------------------------KERNEL----------------------------------*/

__inline HFILE APIENTRY MDupHandle(HFILE h)
{
    HANDLE hDup;
      if (DuplicateHandle(GetCurrentProcess(), LongToHandle(h), GetCurrentProcess(),
            &hDup, 0, FALSE, DUPLICATE_SAME_ACCESS)) {
        return((HFILE)((ULONG_PTR)hDup));
    }
    return((HFILE)-1);
}

__inline BOOL APIENTRY MFreeDOSEnvironment(LPSTR lpEnv)
{
    return(GlobalFree(GlobalHandle(lpEnv)) == NULL);
}


__inline LPSTR APIENTRY MGetDOSEnvironment(VOID)
{
    // no way to make this work on NT.  TO BE CANNED!!

    // For now, just use an empty string.
    static char szNULL[] = "";

    return(szNULL);
}

__inline HANDLE APIENTRY MGetInstHandle()
{
    return GetModuleHandle( NULL );
}
__inline WORD APIENTRY MGetDriveType(INT nDrive)
{
  CHAR lpPath[] = "A:\\";

  lpPath[0] = (char)(nDrive + 'A');
  return((WORD)GetDriveTypeA((LPSTR)lpPath));
}

__inline BYTE APIENTRY MGetTempDrive(BYTE cDriveLtr)
{
    DWORD  dwReturnLength;
    CHAR   lpBuffer[MAX_PATH];

    if (cDriveLtr == 0) {
        dwReturnLength = GetCurrentDirectoryA(sizeof(lpBuffer), lpBuffer);
    } else {
        dwReturnLength = GetTempPathA(sizeof(lpBuffer), lpBuffer);
    }

    if (dwReturnLength && lpBuffer[0] != '\\') {
        return(lpBuffer[0]);
    } else {
        return('\0');
    }
}

__inline INT APIENTRY MGetTempFileName(BYTE cDriveLtr, LPSTR lpstrPrefix, WORD wUnique,LPSTR lpTempFileName)
{
    DWORD  cb;
    CHAR   lpTempPath[MAX_PATH];

    lpTempPath[0] = '\0';
    if (cDriveLtr & TF_FORCEDRIVE) {
        cb = GetCurrentDirectoryA(sizeof(lpTempPath), lpTempPath);
        if (cb) {
            if (lpTempPath[0] != (cDriveLtr & ~TF_FORCEDRIVE)) {
                lpTempPath[2] = '\\';
                lpTempPath[3] = '\0';
            }
        }
    } else {
        cb = GetTempPathA(sizeof(lpTempPath), lpTempPath);
    }
    return((INT)GetTempFileNameA(lpTempPath, lpstrPrefix, wUnique,
        lpTempFileName));
}

__inline INT APIENTRY MReadComm(HFILE nCid,LPSTR lpBuf,INT nSize)
{
    DWORD cbRead;

    if (!ReadFile(LongToHandle(nCid), lpBuf, nSize, &cbRead, 0))
        return(-(INT)cbRead);
    return((INT)cbRead);
}

__inline INT APIENTRY MWriteComm(HFILE nCid,LPSTR lpBuf,INT nSize)
{
    DWORD cbWritten;

    if (!WriteFile(LongToHandle(nCid), lpBuf, nSize, &cbWritten, 0))
        return(-(INT)cbWritten);
    return((INT)cbWritten);
}


#define GETMAJORVERSION(x)                  ((x)&0xff)
#define GETMINORVERSION(x)                  (((x)>>8)&0xff)

/* FUNCTION MAPPINGS */

#define GetInstanceData(hPrevInst, pbuf, cb) (cb)
#define MOpenComm(lpstr, wqin, wqout) (wqin), (wqout), CreateFile(lpstr,       \
                                           GENERIC_READ | GENERIC_WRITE, 0,    \
                                           NULL,                               \
                                           OPEN_EXISTING | TRUNCATE_EXISTING,  \
                                           FILE_FLAG_WRITE_THROUGH, 0)

#define MSetCommState(h, lpDCB)             SetCommState((HANDLE)h, lpDCB)
#define MCloseComm(h)                       (INT)!CloseHandle((HANDLE)h)
#define MDllSharedAlloc(dwFlags, dwBytes)   GlobalAlloc(GMEM_DDESHARE | dwFlags, dwBytes)
#define MDllSharedFlags(hMem)               GlobalFlags(hMem)
#define MDllSharedFree                      GlobalFree
#define MDllSharedHandle                    GlobalHandle
#define MDllSharedLock                      GlobalLock
#define MDllSharedRealloc(hMem, dwBytes, dwFlags) \
        GlobalReAlloc(hMem, dwBytes, dwFlags)
#define MDllSharedSize                      GlobalSize
#define MDllSharedUnlock                    GlobalUnlock
#define MGetCurrentTask                     GetCurrentThreadId
#define MGetModuleUsage(h)                  ((h), 1)
#define MGetWinFlags()                      WF_PMODE
#define MLoadLibrary(lpsz)                  LoadLibrary(lpsz)
#define MLocalInit(w, p1, p2)               ((w),(p1),(p2),TRUE)
#define MLockData(dummy)
#define MUnlockData(dummy)
#define M_lclose(fh)                        _lclose((HFILE)fh)
#define M_lcreat                            (HFILE)_lcreat
#define MOpenFile                           (HFILE)OpenFile
#define M_llseek(fh, lOff, iOrg)            SetFilePointer(LongToPtr(fh), lOff, NULL, (DWORD)iOrg)
#define MDeleteFile                         DeleteFile
#define M_lopen                             (HFILE)_lopen
#define M_lread(fh, lpBuf, cb)              _lread((HFILE)fh, lpBuf, cb)
#define M_lwrite(fh, lpBuf, cb)             _lwrite((HFILE)fh, lpBuf, cb)

#define MCatch                              setjmp
#define MThrow                              longjmp

#ifdef __cplusplus
}
#endif

#endif      // __PWIN32_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\ptypes16.h ===
/*****************************************************************************\
* Copyright (C) Microsoft Corporation, 1990-1999
* PTYPES16.H - PORTABILITY MAPPING HEADER FILE
*
* This file provides typedefs for portable 16/32 bit code.
\*****************************************************************************/

#if _MSC_VER > 1000
#pragma once
#endif

/* TEMPORARY FIXES: */

#ifndef CCHDEVICENAME
#include <drivinit.h>
#endif

#define ERROR_GETADDR_FAILED     0x8001
#define ERROR_ALLOCATION_FAILURE 0x8002

#define INITWINDOWS()

/* TYPES: */

#ifndef WIN31

typedef  unsigned int   UINT           ;
typedef  WORD           WPARAM         ;
typedef  LONG           LPARAM         ;
typedef  int            HFILE          ;
typedef  HANDLE         HINSTANCE      ;
typedef  HANDLE         HMODULE        ;

#endif /* !WIN31 */

typedef  int            INT            ;
typedef  signed char    SCHAR          ;
typedef  WORD           WORD2DWORD     ;
typedef  char           TCHAR          ;
typedef  char           CHARPARM       ;
typedef  char           CHAR           ;
typedef  int            SHORTPARM      ;
typedef  int            SHORT          ;
typedef  WORD           VERSION        ;
typedef  HANDLE         HMETAFILE      ;
typedef  WORD           PDLLMEM        ;
typedef  char           CHAR2ULONG     ;
typedef  unsigned short USHORT2ULONG   ;
typedef  short          SHORT2ULONG    ;
typedef  int            INT2DWORD      ;
typedef  int            INT2WORD       ;
typedef  char           BYTE2WORD      ;
typedef  POINT          MPOINT         ;

#define  WNDPROC        FARPROC
#define  PROC           FARPROC
#define  APIENTRY       FAR PASCAL
#define  HUGE_T         huge

#define HFILE2INT(h, flags)     (INT)(h)
#define INT2HFILE(i)            (HFILE)(i)
#define DUPHFILE(h)             (HFILE)dup((INT)(h))
#define MGLOBALPTR(p)           HIWORD((LONG)p)

/* PRAGMAS */

#define _LOADDS _loadds
#define _EXPORT _export
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\qedit_i.c ===
/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for qedit.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IPropertySetter,0xAE9472BD,0xB0C3,0x11D2,0x8D,0x24,0x00,0xA0,0xC9,0x44,0x1E,0x20);


MIDL_DEFINE_GUID(IID, IID_IDxtCompositor,0xBB44391E,0x6ABD,0x422f,0x9E,0x2E,0x38,0x5C,0x9D,0xFF,0x51,0xFC);


MIDL_DEFINE_GUID(IID, IID_IDxtAlphaSetter,0x4EE9EAD9,0xDA4D,0x43d0,0x93,0x83,0x06,0xB9,0x0C,0x08,0xB1,0x2B);


MIDL_DEFINE_GUID(IID, IID_IDxtJpeg,0xDE75D011,0x7A65,0x11D2,0x8C,0xEA,0x00,0xA0,0xC9,0x44,0x1E,0x20);


MIDL_DEFINE_GUID(IID, IID_IDxtKey,0x3255de56,0x38fb,0x4901,0xb9,0x80,0x94,0xb4,0x38,0x01,0x0d,0x7b);


MIDL_DEFINE_GUID(IID, IID_IMediaLocator,0x288581E0,0x66CE,0x11d2,0x91,0x8F,0x00,0xC0,0xDF,0x10,0xD4,0x34);


MIDL_DEFINE_GUID(IID, IID_IMediaDet,0x65BD0710,0x24D2,0x4ff7,0x93,0x24,0xED,0x2E,0x5D,0x3A,0xBA,0xFA);


MIDL_DEFINE_GUID(IID, IID_IGrfCache,0xAE9472BE,0xB0C3,0x11D2,0x8D,0x24,0x00,0xA0,0xC9,0x44,0x1E,0x20);


MIDL_DEFINE_GUID(IID, IID_IRenderEngine,0x6BEE3A81,0x66C9,0x11d2,0x91,0x8F,0x00,0xC0,0xDF,0x10,0xD4,0x34);


MIDL_DEFINE_GUID(IID, IID_IFindCompressorCB,0xF03FA8DE,0x879A,0x4d59,0x9B,0x2C,0x26,0xBB,0x1C,0xF8,0x34,0x61);


MIDL_DEFINE_GUID(IID, IID_ISmartRenderEngine,0xF03FA8CE,0x879A,0x4d59,0x9B,0x2C,0x26,0xBB,0x1C,0xF8,0x34,0x61);


MIDL_DEFINE_GUID(IID, IID_IAMTimelineObj,0x78530B77,0x61F9,0x11D2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(IID, IID_IAMTimelineEffectable,0xEAE58537,0x622E,0x11d2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(IID, IID_IAMTimelineEffect,0xBCE0C264,0x622D,0x11d2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(IID, IID_IAMTimelineTransable,0x378FA386,0x622E,0x11d2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(IID, IID_IAMTimelineSplittable,0xA0F840A0,0xD590,0x11d2,0x8D,0x55,0x00,0xA0,0xC9,0x44,0x1E,0x20);


MIDL_DEFINE_GUID(IID, IID_IAMTimelineTrans,0xBCE0C265,0x622D,0x11d2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(IID, IID_IAMTimelineSrc,0x78530B79,0x61F9,0x11D2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(IID, IID_IAMTimelineTrack,0xEAE58538,0x622E,0x11d2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(IID, IID_IAMTimelineVirtualTrack,0xA8ED5F80,0xC2C7,0x11d2,0x8D,0x39,0x00,0xA0,0xC9,0x44,0x1E,0x20);


MIDL_DEFINE_GUID(IID, IID_IAMTimelineComp,0xEAE58536,0x622E,0x11d2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(IID, IID_IAMTimelineGroup,0x9EED4F00,0xB8A6,0x11d2,0x80,0x23,0x00,0xC0,0xDF,0x10,0xD4,0x34);


MIDL_DEFINE_GUID(IID, IID_IAMTimeline,0x78530B74,0x61F9,0x11D2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(IID, IID_IXml2Dex,0x18C628ED,0x962A,0x11D2,0x8D,0x08,0x00,0xA0,0xC9,0x44,0x1E,0x20);


MIDL_DEFINE_GUID(IID, IID_IAMErrorLog,0xE43E73A2,0x0EFA,0x11d3,0x96,0x01,0x00,0xA0,0xC9,0x44,0x1E,0x20);


MIDL_DEFINE_GUID(IID, IID_IAMSetErrorLog,0x963566DA,0xBE21,0x4eaf,0x88,0xE9,0x35,0x70,0x4F,0x8F,0x52,0xA1);


MIDL_DEFINE_GUID(IID, IID_ISampleGrabberCB,0x0579154A,0x2B53,0x4994,0xB0,0xD0,0xE7,0x73,0x14,0x8E,0xFF,0x85);


MIDL_DEFINE_GUID(IID, IID_ISampleGrabber,0x6B652FFF,0x11FE,0x4fce,0x92,0xAD,0x02,0x66,0xB5,0xD7,0xC7,0x8F);


MIDL_DEFINE_GUID(IID, LIBID_DexterLib,0x78530B68,0x61F9,0x11D2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(CLSID, CLSID_AMTimeline,0x78530B75,0x61F9,0x11D2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(CLSID, CLSID_AMTimelineObj,0x78530B78,0x61F9,0x11D2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(CLSID, CLSID_AMTimelineSrc,0x78530B7A,0x61F9,0x11D2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(CLSID, CLSID_AMTimelineTrack,0x8F6C3C50,0x897B,0x11d2,0x8C,0xFB,0x00,0xA0,0xC9,0x44,0x1E,0x20);


MIDL_DEFINE_GUID(CLSID, CLSID_AMTimelineComp,0x74D2EC80,0x6233,0x11d2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(CLSID, CLSID_AMTimelineGroup,0xF6D371E1,0xB8A6,0x11d2,0x80,0x23,0x00,0xC0,0xDF,0x10,0xD4,0x34);


MIDL_DEFINE_GUID(CLSID, CLSID_AMTimelineTrans,0x74D2EC81,0x6233,0x11d2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(CLSID, CLSID_AMTimelineEffect,0x74D2EC82,0x6233,0x11d2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(CLSID, CLSID_RenderEngine,0x64D8A8E0,0x80A2,0x11d2,0x8C,0xF3,0x00,0xA0,0xC9,0x44,0x1E,0x20);


MIDL_DEFINE_GUID(CLSID, CLSID_SmartRenderEngine,0x498B0949,0xBBE9,0x4072,0x98,0xBE,0x6C,0xCA,0xEB,0x79,0xDC,0x6F);


MIDL_DEFINE_GUID(CLSID, CLSID_AudMixer,0x036A9790,0xC153,0x11d2,0x9E,0xF7,0x00,0x60,0x08,0x03,0x9E,0x37);


MIDL_DEFINE_GUID(CLSID, CLSID_Xml2Dex,0x18C628EE,0x962A,0x11D2,0x8D,0x08,0x00,0xA0,0xC9,0x44,0x1E,0x20);


MIDL_DEFINE_GUID(CLSID, CLSID_MediaLocator,0xCC1101F2,0x79DC,0x11D2,0x8C,0xE6,0x00,0xA0,0xC9,0x44,0x1E,0x20);


MIDL_DEFINE_GUID(CLSID, CLSID_PropertySetter,0xADF95821,0xDED7,0x11d2,0xAC,0xBE,0x00,0x80,0xC7,0x5E,0x24,0x6E);


MIDL_DEFINE_GUID(CLSID, CLSID_MediaDet,0x65BD0711,0x24D2,0x4ff7,0x93,0x24,0xED,0x2E,0x5D,0x3A,0xBA,0xFA);


MIDL_DEFINE_GUID(CLSID, CLSID_SampleGrabber,0xC1F400A0,0x3F08,0x11d3,0x9F,0x0B,0x00,0x60,0x08,0x03,0x9E,0x37);


MIDL_DEFINE_GUID(CLSID, CLSID_NullRenderer,0xC1F400A4,0x3F08,0x11d3,0x9F,0x0B,0x00,0x60,0x08,0x03,0x9E,0x37);


MIDL_DEFINE_GUID(CLSID, CLSID_DxtCompositor,0xBB44391D,0x6ABD,0x422f,0x9E,0x2E,0x38,0x5C,0x9D,0xFF,0x51,0xFC);


MIDL_DEFINE_GUID(CLSID, CLSID_DxtAlphaSetter,0x506D89AE,0x909A,0x44f7,0x94,0x44,0xAB,0xD5,0x75,0x89,0x6E,0x35);


MIDL_DEFINE_GUID(CLSID, CLSID_DxtJpeg,0xDE75D012,0x7A65,0x11D2,0x8C,0xEA,0x00,0xA0,0xC9,0x44,0x1E,0x20);


MIDL_DEFINE_GUID(CLSID, CLSID_ColorSource,0x0cfdd070,0x581a,0x11d2,0x9e,0xe6,0x00,0x60,0x08,0x03,0x9e,0x37);


MIDL_DEFINE_GUID(CLSID, CLSID_DxtKey,0xC5B19592,0x145E,0x11d3,0x9F,0x04,0x00,0x60,0x08,0x03,0x9E,0x37);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/



/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for qedit.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IPropertySetter,0xAE9472BD,0xB0C3,0x11D2,0x8D,0x24,0x00,0xA0,0xC9,0x44,0x1E,0x20);


MIDL_DEFINE_GUID(IID, IID_IDxtCompositor,0xBB44391E,0x6ABD,0x422f,0x9E,0x2E,0x38,0x5C,0x9D,0xFF,0x51,0xFC);


MIDL_DEFINE_GUID(IID, IID_IDxtAlphaSetter,0x4EE9EAD9,0xDA4D,0x43d0,0x93,0x83,0x06,0xB9,0x0C,0x08,0xB1,0x2B);


MIDL_DEFINE_GUID(IID, IID_IDxtJpeg,0xDE75D011,0x7A65,0x11D2,0x8C,0xEA,0x00,0xA0,0xC9,0x44,0x1E,0x20);


MIDL_DEFINE_GUID(IID, IID_IDxtKey,0x3255de56,0x38fb,0x4901,0xb9,0x80,0x94,0xb4,0x38,0x01,0x0d,0x7b);


MIDL_DEFINE_GUID(IID, IID_IMediaLocator,0x288581E0,0x66CE,0x11d2,0x91,0x8F,0x00,0xC0,0xDF,0x10,0xD4,0x34);


MIDL_DEFINE_GUID(IID, IID_IMediaDet,0x65BD0710,0x24D2,0x4ff7,0x93,0x24,0xED,0x2E,0x5D,0x3A,0xBA,0xFA);


MIDL_DEFINE_GUID(IID, IID_IGrfCache,0xAE9472BE,0xB0C3,0x11D2,0x8D,0x24,0x00,0xA0,0xC9,0x44,0x1E,0x20);


MIDL_DEFINE_GUID(IID, IID_IRenderEngine,0x6BEE3A81,0x66C9,0x11d2,0x91,0x8F,0x00,0xC0,0xDF,0x10,0xD4,0x34);


MIDL_DEFINE_GUID(IID, IID_IFindCompressorCB,0xF03FA8DE,0x879A,0x4d59,0x9B,0x2C,0x26,0xBB,0x1C,0xF8,0x34,0x61);


MIDL_DEFINE_GUID(IID, IID_ISmartRenderEngine,0xF03FA8CE,0x879A,0x4d59,0x9B,0x2C,0x26,0xBB,0x1C,0xF8,0x34,0x61);


MIDL_DEFINE_GUID(IID, IID_IAMTimelineObj,0x78530B77,0x61F9,0x11D2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(IID, IID_IAMTimelineEffectable,0xEAE58537,0x622E,0x11d2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(IID, IID_IAMTimelineEffect,0xBCE0C264,0x622D,0x11d2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(IID, IID_IAMTimelineTransable,0x378FA386,0x622E,0x11d2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(IID, IID_IAMTimelineSplittable,0xA0F840A0,0xD590,0x11d2,0x8D,0x55,0x00,0xA0,0xC9,0x44,0x1E,0x20);


MIDL_DEFINE_GUID(IID, IID_IAMTimelineTrans,0xBCE0C265,0x622D,0x11d2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(IID, IID_IAMTimelineSrc,0x78530B79,0x61F9,0x11D2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(IID, IID_IAMTimelineTrack,0xEAE58538,0x622E,0x11d2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(IID, IID_IAMTimelineVirtualTrack,0xA8ED5F80,0xC2C7,0x11d2,0x8D,0x39,0x00,0xA0,0xC9,0x44,0x1E,0x20);


MIDL_DEFINE_GUID(IID, IID_IAMTimelineComp,0xEAE58536,0x622E,0x11d2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(IID, IID_IAMTimelineGroup,0x9EED4F00,0xB8A6,0x11d2,0x80,0x23,0x00,0xC0,0xDF,0x10,0xD4,0x34);


MIDL_DEFINE_GUID(IID, IID_IAMTimeline,0x78530B74,0x61F9,0x11D2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(IID, IID_IXml2Dex,0x18C628ED,0x962A,0x11D2,0x8D,0x08,0x00,0xA0,0xC9,0x44,0x1E,0x20);


MIDL_DEFINE_GUID(IID, IID_IAMErrorLog,0xE43E73A2,0x0EFA,0x11d3,0x96,0x01,0x00,0xA0,0xC9,0x44,0x1E,0x20);


MIDL_DEFINE_GUID(IID, IID_IAMSetErrorLog,0x963566DA,0xBE21,0x4eaf,0x88,0xE9,0x35,0x70,0x4F,0x8F,0x52,0xA1);


MIDL_DEFINE_GUID(IID, IID_ISampleGrabberCB,0x0579154A,0x2B53,0x4994,0xB0,0xD0,0xE7,0x73,0x14,0x8E,0xFF,0x85);


MIDL_DEFINE_GUID(IID, IID_ISampleGrabber,0x6B652FFF,0x11FE,0x4fce,0x92,0xAD,0x02,0x66,0xB5,0xD7,0xC7,0x8F);


MIDL_DEFINE_GUID(IID, LIBID_DexterLib,0x78530B68,0x61F9,0x11D2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(CLSID, CLSID_AMTimeline,0x78530B75,0x61F9,0x11D2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(CLSID, CLSID_AMTimelineObj,0x78530B78,0x61F9,0x11D2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(CLSID, CLSID_AMTimelineSrc,0x78530B7A,0x61F9,0x11D2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(CLSID, CLSID_AMTimelineTrack,0x8F6C3C50,0x897B,0x11d2,0x8C,0xFB,0x00,0xA0,0xC9,0x44,0x1E,0x20);


MIDL_DEFINE_GUID(CLSID, CLSID_AMTimelineComp,0x74D2EC80,0x6233,0x11d2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(CLSID, CLSID_AMTimelineGroup,0xF6D371E1,0xB8A6,0x11d2,0x80,0x23,0x00,0xC0,0xDF,0x10,0xD4,0x34);


MIDL_DEFINE_GUID(CLSID, CLSID_AMTimelineTrans,0x74D2EC81,0x6233,0x11d2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(CLSID, CLSID_AMTimelineEffect,0x74D2EC82,0x6233,0x11d2,0x8C,0xAD,0x00,0xA0,0x24,0x58,0x09,0x02);


MIDL_DEFINE_GUID(CLSID, CLSID_RenderEngine,0x64D8A8E0,0x80A2,0x11d2,0x8C,0xF3,0x00,0xA0,0xC9,0x44,0x1E,0x20);


MIDL_DEFINE_GUID(CLSID, CLSID_SmartRenderEngine,0x498B0949,0xBBE9,0x4072,0x98,0xBE,0x6C,0xCA,0xEB,0x79,0xDC,0x6F);


MIDL_DEFINE_GUID(CLSID, CLSID_AudMixer,0x036A9790,0xC153,0x11d2,0x9E,0xF7,0x00,0x60,0x08,0x03,0x9E,0x37);


MIDL_DEFINE_GUID(CLSID, CLSID_Xml2Dex,0x18C628EE,0x962A,0x11D2,0x8D,0x08,0x00,0xA0,0xC9,0x44,0x1E,0x20);


MIDL_DEFINE_GUID(CLSID, CLSID_MediaLocator,0xCC1101F2,0x79DC,0x11D2,0x8C,0xE6,0x00,0xA0,0xC9,0x44,0x1E,0x20);


MIDL_DEFINE_GUID(CLSID, CLSID_PropertySetter,0xADF95821,0xDED7,0x11d2,0xAC,0xBE,0x00,0x80,0xC7,0x5E,0x24,0x6E);


MIDL_DEFINE_GUID(CLSID, CLSID_MediaDet,0x65BD0711,0x24D2,0x4ff7,0x93,0x24,0xED,0x2E,0x5D,0x3A,0xBA,0xFA);


MIDL_DEFINE_GUID(CLSID, CLSID_SampleGrabber,0xC1F400A0,0x3F08,0x11d3,0x9F,0x0B,0x00,0x60,0x08,0x03,0x9E,0x37);


MIDL_DEFINE_GUID(CLSID, CLSID_NullRenderer,0xC1F400A4,0x3F08,0x11d3,0x9F,0x0B,0x00,0x60,0x08,0x03,0x9E,0x37);


MIDL_DEFINE_GUID(CLSID, CLSID_DxtCompositor,0xBB44391D,0x6ABD,0x422f,0x9E,0x2E,0x38,0x5C,0x9D,0xFF,0x51,0xFC);


MIDL_DEFINE_GUID(CLSID, CLSID_DxtAlphaSetter,0x506D89AE,0x909A,0x44f7,0x94,0x44,0xAB,0xD5,0x75,0x89,0x6E,0x35);


MIDL_DEFINE_GUID(CLSID, CLSID_DxtJpeg,0xDE75D012,0x7A65,0x11D2,0x8C,0xEA,0x00,0xA0,0xC9,0x44,0x1E,0x20);


MIDL_DEFINE_GUID(CLSID, CLSID_ColorSource,0x0cfdd070,0x581a,0x11d2,0x9e,0xe6,0x00,0x60,0x08,0x03,0x9e,0x37);


MIDL_DEFINE_GUID(CLSID, CLSID_DxtKey,0xC5B19592,0x145E,0x11d3,0x9F,0x04,0x00,0x60,0x08,0x03,0x9E,0x37);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\qmgr.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for qmgr.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __qmgr_h__
#define __qmgr_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IBackgroundCopyJob1_FWD_DEFINED__
#define __IBackgroundCopyJob1_FWD_DEFINED__
typedef interface IBackgroundCopyJob1 IBackgroundCopyJob1;
#endif 	/* __IBackgroundCopyJob1_FWD_DEFINED__ */


#ifndef __IEnumBackgroundCopyJobs1_FWD_DEFINED__
#define __IEnumBackgroundCopyJobs1_FWD_DEFINED__
typedef interface IEnumBackgroundCopyJobs1 IEnumBackgroundCopyJobs1;
#endif 	/* __IEnumBackgroundCopyJobs1_FWD_DEFINED__ */


#ifndef __IBackgroundCopyGroup_FWD_DEFINED__
#define __IBackgroundCopyGroup_FWD_DEFINED__
typedef interface IBackgroundCopyGroup IBackgroundCopyGroup;
#endif 	/* __IBackgroundCopyGroup_FWD_DEFINED__ */


#ifndef __IEnumBackgroundCopyGroups_FWD_DEFINED__
#define __IEnumBackgroundCopyGroups_FWD_DEFINED__
typedef interface IEnumBackgroundCopyGroups IEnumBackgroundCopyGroups;
#endif 	/* __IEnumBackgroundCopyGroups_FWD_DEFINED__ */


#ifndef __IBackgroundCopyCallback1_FWD_DEFINED__
#define __IBackgroundCopyCallback1_FWD_DEFINED__
typedef interface IBackgroundCopyCallback1 IBackgroundCopyCallback1;
#endif 	/* __IBackgroundCopyCallback1_FWD_DEFINED__ */


#ifndef __IBackgroundCopyQMgr_FWD_DEFINED__
#define __IBackgroundCopyQMgr_FWD_DEFINED__
typedef interface IBackgroundCopyQMgr IBackgroundCopyQMgr;
#endif 	/* __IBackgroundCopyQMgr_FWD_DEFINED__ */


#ifndef __BackgroundCopyQMgr_FWD_DEFINED__
#define __BackgroundCopyQMgr_FWD_DEFINED__

#ifdef __cplusplus
typedef class BackgroundCopyQMgr BackgroundCopyQMgr;
#else
typedef struct BackgroundCopyQMgr BackgroundCopyQMgr;
#endif /* __cplusplus */

#endif 	/* __BackgroundCopyQMgr_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "ocidl.h"
#include "docobj.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_qmgr_0000 */
/* [local] */ 

// Background Copy QMgr Public Interface
#define  QM_NOTIFY_FILE_DONE         0x00000001
#define  QM_NOTIFY_JOB_DONE          0x00000002
#define  QM_NOTIFY_GROUP_DONE        0x00000004
#define  QM_NOTIFY_DISABLE_NOTIFY    0x00000040
#define  QM_NOTIFY_USE_PROGRESSEX    0x00000080
#define  QM_STATUS_FILE_COMPLETE     0x00000001
#define  QM_STATUS_FILE_INCOMPLETE   0x00000002
#define  QM_STATUS_JOB_COMPLETE      0x00000004
#define  QM_STATUS_JOB_INCOMPLETE    0x00000008
#define  QM_STATUS_JOB_ERROR         0x00000010
#define  QM_STATUS_JOB_FOREGROUND    0x00000020
#define  QM_STATUS_GROUP_COMPLETE    0x00000040
#define  QM_STATUS_GROUP_INCOMPLETE  0x00000080
#define  QM_STATUS_GROUP_SUSPENDED   0x00000100
#define  QM_STATUS_GROUP_ERROR       0x00000200
#define  QM_STATUS_GROUP_FOREGROUND  0x00000400
#define  QM_PROTOCOL_HTTP            1
#define  QM_PROTOCOL_FTP             2
#define  QM_PROTOCOL_SMB             3
#define  QM_PROTOCOL_CUSTOM          4
#define  QM_PROGRESS_PERCENT_DONE    1
#define  QM_PROGRESS_TIME_DONE       2
#define  QM_PROGRESS_SIZE_DONE       3
#define  QM_E_INVALID_STATE          0x81001001
#define  QM_E_SERVICE_UNAVAILABLE    0x81001002
#define  QM_E_DOWNLOADER_UNAVAILABLE 0x81001003
#define  QM_E_ITEM_NOT_FOUND         0x81001004


extern RPC_IF_HANDLE __MIDL_itf_qmgr_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_qmgr_0000_v0_0_s_ifspec;

#ifndef __IBackgroundCopyJob1_INTERFACE_DEFINED__
#define __IBackgroundCopyJob1_INTERFACE_DEFINED__

/* interface IBackgroundCopyJob1 */
/* [object][helpstring][uuid] */ 

typedef struct _FILESETINFO
    {
    BSTR bstrRemoteFile;
    BSTR bstrLocalFile;
    DWORD dwSizeHint;
    } 	FILESETINFO;


EXTERN_C const IID IID_IBackgroundCopyJob1;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("59f5553c-2031-4629-bb18-2645a6970947")
    IBackgroundCopyJob1 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CancelJob( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProgress( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ DWORD *pdwProgress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ DWORD *pdwStatus,
            /* [out] */ DWORD *pdwWin32Result,
            /* [out] */ DWORD *pdwTransportResult,
            /* [out] */ DWORD *pdwNumOfRetries) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddFiles( 
            /* [in] */ ULONG cFileCount,
            /* [size_is][in] */ FILESETINFO **ppFileSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFile( 
            /* [in] */ ULONG cFileIndex,
            /* [out] */ FILESETINFO *pFileInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileCount( 
            /* [out] */ DWORD *pdwFileCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SwitchToForeground( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_JobID( 
            /* [out] */ GUID *pguidJobID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBackgroundCopyJob1Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBackgroundCopyJob1 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBackgroundCopyJob1 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBackgroundCopyJob1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *CancelJob )( 
            IBackgroundCopyJob1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProgress )( 
            IBackgroundCopyJob1 * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ DWORD *pdwProgress);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IBackgroundCopyJob1 * This,
            /* [out] */ DWORD *pdwStatus,
            /* [out] */ DWORD *pdwWin32Result,
            /* [out] */ DWORD *pdwTransportResult,
            /* [out] */ DWORD *pdwNumOfRetries);
        
        HRESULT ( STDMETHODCALLTYPE *AddFiles )( 
            IBackgroundCopyJob1 * This,
            /* [in] */ ULONG cFileCount,
            /* [size_is][in] */ FILESETINFO **ppFileSet);
        
        HRESULT ( STDMETHODCALLTYPE *GetFile )( 
            IBackgroundCopyJob1 * This,
            /* [in] */ ULONG cFileIndex,
            /* [out] */ FILESETINFO *pFileInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileCount )( 
            IBackgroundCopyJob1 * This,
            /* [out] */ DWORD *pdwFileCount);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToForeground )( 
            IBackgroundCopyJob1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_JobID )( 
            IBackgroundCopyJob1 * This,
            /* [out] */ GUID *pguidJobID);
        
        END_INTERFACE
    } IBackgroundCopyJob1Vtbl;

    interface IBackgroundCopyJob1
    {
        CONST_VTBL struct IBackgroundCopyJob1Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBackgroundCopyJob1_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBackgroundCopyJob1_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBackgroundCopyJob1_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBackgroundCopyJob1_CancelJob(This)	\
    (This)->lpVtbl -> CancelJob(This)

#define IBackgroundCopyJob1_GetProgress(This,dwFlags,pdwProgress)	\
    (This)->lpVtbl -> GetProgress(This,dwFlags,pdwProgress)

#define IBackgroundCopyJob1_GetStatus(This,pdwStatus,pdwWin32Result,pdwTransportResult,pdwNumOfRetries)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus,pdwWin32Result,pdwTransportResult,pdwNumOfRetries)

#define IBackgroundCopyJob1_AddFiles(This,cFileCount,ppFileSet)	\
    (This)->lpVtbl -> AddFiles(This,cFileCount,ppFileSet)

#define IBackgroundCopyJob1_GetFile(This,cFileIndex,pFileInfo)	\
    (This)->lpVtbl -> GetFile(This,cFileIndex,pFileInfo)

#define IBackgroundCopyJob1_GetFileCount(This,pdwFileCount)	\
    (This)->lpVtbl -> GetFileCount(This,pdwFileCount)

#define IBackgroundCopyJob1_SwitchToForeground(This)	\
    (This)->lpVtbl -> SwitchToForeground(This)

#define IBackgroundCopyJob1_get_JobID(This,pguidJobID)	\
    (This)->lpVtbl -> get_JobID(This,pguidJobID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBackgroundCopyJob1_CancelJob_Proxy( 
    IBackgroundCopyJob1 * This);


void __RPC_STUB IBackgroundCopyJob1_CancelJob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob1_GetProgress_Proxy( 
    IBackgroundCopyJob1 * This,
    /* [in] */ DWORD dwFlags,
    /* [out] */ DWORD *pdwProgress);


void __RPC_STUB IBackgroundCopyJob1_GetProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob1_GetStatus_Proxy( 
    IBackgroundCopyJob1 * This,
    /* [out] */ DWORD *pdwStatus,
    /* [out] */ DWORD *pdwWin32Result,
    /* [out] */ DWORD *pdwTransportResult,
    /* [out] */ DWORD *pdwNumOfRetries);


void __RPC_STUB IBackgroundCopyJob1_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob1_AddFiles_Proxy( 
    IBackgroundCopyJob1 * This,
    /* [in] */ ULONG cFileCount,
    /* [size_is][in] */ FILESETINFO **ppFileSet);


void __RPC_STUB IBackgroundCopyJob1_AddFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob1_GetFile_Proxy( 
    IBackgroundCopyJob1 * This,
    /* [in] */ ULONG cFileIndex,
    /* [out] */ FILESETINFO *pFileInfo);


void __RPC_STUB IBackgroundCopyJob1_GetFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob1_GetFileCount_Proxy( 
    IBackgroundCopyJob1 * This,
    /* [out] */ DWORD *pdwFileCount);


void __RPC_STUB IBackgroundCopyJob1_GetFileCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob1_SwitchToForeground_Proxy( 
    IBackgroundCopyJob1 * This);


void __RPC_STUB IBackgroundCopyJob1_SwitchToForeground_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob1_get_JobID_Proxy( 
    IBackgroundCopyJob1 * This,
    /* [out] */ GUID *pguidJobID);


void __RPC_STUB IBackgroundCopyJob1_get_JobID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBackgroundCopyJob1_INTERFACE_DEFINED__ */


#ifndef __IEnumBackgroundCopyJobs1_INTERFACE_DEFINED__
#define __IEnumBackgroundCopyJobs1_INTERFACE_DEFINED__

/* interface IEnumBackgroundCopyJobs1 */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumBackgroundCopyJobs1;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8baeba9d-8f1c-42c4-b82c-09ae79980d25")
    IEnumBackgroundCopyJobs1 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ GUID *rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumBackgroundCopyJobs1 **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *puCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumBackgroundCopyJobs1Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumBackgroundCopyJobs1 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumBackgroundCopyJobs1 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumBackgroundCopyJobs1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumBackgroundCopyJobs1 * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ GUID *rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumBackgroundCopyJobs1 * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumBackgroundCopyJobs1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumBackgroundCopyJobs1 * This,
            /* [out] */ IEnumBackgroundCopyJobs1 **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumBackgroundCopyJobs1 * This,
            /* [out] */ ULONG *puCount);
        
        END_INTERFACE
    } IEnumBackgroundCopyJobs1Vtbl;

    interface IEnumBackgroundCopyJobs1
    {
        CONST_VTBL struct IEnumBackgroundCopyJobs1Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumBackgroundCopyJobs1_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumBackgroundCopyJobs1_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumBackgroundCopyJobs1_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumBackgroundCopyJobs1_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumBackgroundCopyJobs1_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumBackgroundCopyJobs1_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumBackgroundCopyJobs1_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#define IEnumBackgroundCopyJobs1_GetCount(This,puCount)	\
    (This)->lpVtbl -> GetCount(This,puCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumBackgroundCopyJobs1_Next_Proxy( 
    IEnumBackgroundCopyJobs1 * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ GUID *rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IEnumBackgroundCopyJobs1_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumBackgroundCopyJobs1_Skip_Proxy( 
    IEnumBackgroundCopyJobs1 * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumBackgroundCopyJobs1_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumBackgroundCopyJobs1_Reset_Proxy( 
    IEnumBackgroundCopyJobs1 * This);


void __RPC_STUB IEnumBackgroundCopyJobs1_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumBackgroundCopyJobs1_Clone_Proxy( 
    IEnumBackgroundCopyJobs1 * This,
    /* [out] */ IEnumBackgroundCopyJobs1 **ppenum);


void __RPC_STUB IEnumBackgroundCopyJobs1_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumBackgroundCopyJobs1_GetCount_Proxy( 
    IEnumBackgroundCopyJobs1 * This,
    /* [out] */ ULONG *puCount);


void __RPC_STUB IEnumBackgroundCopyJobs1_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumBackgroundCopyJobs1_INTERFACE_DEFINED__ */


#ifndef __IBackgroundCopyGroup_INTERFACE_DEFINED__
#define __IBackgroundCopyGroup_INTERFACE_DEFINED__

/* interface IBackgroundCopyGroup */
/* [object][helpstring][uuid] */ 

typedef 
enum GROUPPROP
    {	GROUPPROP_PRIORITY	= 0,
	GROUPPROP_REMOTEUSERID	= 1,
	GROUPPROP_REMOTEUSERPWD	= 2,
	GROUPPROP_LOCALUSERID	= 3,
	GROUPPROP_LOCALUSERPWD	= 4,
	GROUPPROP_PROTOCOLFLAGS	= 5,
	GROUPPROP_NOTIFYFLAGS	= 6,
	GROUPPROP_NOTIFYCLSID	= 7,
	GROUPPROP_PROGRESSSIZE	= 8,
	GROUPPROP_PROGRESSPERCENT	= 9,
	GROUPPROP_PROGRESSTIME	= 10,
	GROUPPROP_DISPLAYNAME	= 11,
	GROUPPROP_DESCRIPTION	= 12
    } 	GROUPPROP;


EXTERN_C const IID IID_IBackgroundCopyGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1ded80a7-53ea-424f-8a04-17fea9adc4f5")
    IBackgroundCopyGroup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProp( 
            /* [in] */ GROUPPROP propID,
            /* [out] */ VARIANT *pvarVal) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetProp( 
            /* [in] */ GROUPPROP propID,
            /* [in] */ VARIANT *pvarVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProgress( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ DWORD *pdwProgress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ DWORD *pdwStatus,
            /* [out] */ DWORD *pdwJobIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetJob( 
            /* [in] */ GUID jobID,
            /* [out] */ IBackgroundCopyJob1 **ppJob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SuspendGroup( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumeGroup( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelGroup( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Size( 
            /* [out] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_GroupID( 
            /* [out] */ GUID *pguidGroupID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateJob( 
            /* [in] */ GUID guidJobID,
            /* [out] */ IBackgroundCopyJob1 **ppJob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumJobs( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ IEnumBackgroundCopyJobs1 **ppEnumJobs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SwitchToForeground( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryNewJobInterface( 
            /* [in] */ REFIID iid,
            /* [iid_is][out] */ IUnknown **pUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNotificationPointer( 
            /* [in] */ REFIID iid,
            /* [in] */ IUnknown *pUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBackgroundCopyGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBackgroundCopyGroup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBackgroundCopyGroup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBackgroundCopyGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProp )( 
            IBackgroundCopyGroup * This,
            /* [in] */ GROUPPROP propID,
            /* [out] */ VARIANT *pvarVal);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetProp )( 
            IBackgroundCopyGroup * This,
            /* [in] */ GROUPPROP propID,
            /* [in] */ VARIANT *pvarVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetProgress )( 
            IBackgroundCopyGroup * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ DWORD *pdwProgress);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IBackgroundCopyGroup * This,
            /* [out] */ DWORD *pdwStatus,
            /* [out] */ DWORD *pdwJobIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetJob )( 
            IBackgroundCopyGroup * This,
            /* [in] */ GUID jobID,
            /* [out] */ IBackgroundCopyJob1 **ppJob);
        
        HRESULT ( STDMETHODCALLTYPE *SuspendGroup )( 
            IBackgroundCopyGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResumeGroup )( 
            IBackgroundCopyGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *CancelGroup )( 
            IBackgroundCopyGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_Size )( 
            IBackgroundCopyGroup * This,
            /* [out] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *get_GroupID )( 
            IBackgroundCopyGroup * This,
            /* [out] */ GUID *pguidGroupID);
        
        HRESULT ( STDMETHODCALLTYPE *CreateJob )( 
            IBackgroundCopyGroup * This,
            /* [in] */ GUID guidJobID,
            /* [out] */ IBackgroundCopyJob1 **ppJob);
        
        HRESULT ( STDMETHODCALLTYPE *EnumJobs )( 
            IBackgroundCopyGroup * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IEnumBackgroundCopyJobs1 **ppEnumJobs);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToForeground )( 
            IBackgroundCopyGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryNewJobInterface )( 
            IBackgroundCopyGroup * This,
            /* [in] */ REFIID iid,
            /* [iid_is][out] */ IUnknown **pUnk);
        
        HRESULT ( STDMETHODCALLTYPE *SetNotificationPointer )( 
            IBackgroundCopyGroup * This,
            /* [in] */ REFIID iid,
            /* [in] */ IUnknown *pUnk);
        
        END_INTERFACE
    } IBackgroundCopyGroupVtbl;

    interface IBackgroundCopyGroup
    {
        CONST_VTBL struct IBackgroundCopyGroupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBackgroundCopyGroup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBackgroundCopyGroup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBackgroundCopyGroup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBackgroundCopyGroup_GetProp(This,propID,pvarVal)	\
    (This)->lpVtbl -> GetProp(This,propID,pvarVal)

#define IBackgroundCopyGroup_SetProp(This,propID,pvarVal)	\
    (This)->lpVtbl -> SetProp(This,propID,pvarVal)

#define IBackgroundCopyGroup_GetProgress(This,dwFlags,pdwProgress)	\
    (This)->lpVtbl -> GetProgress(This,dwFlags,pdwProgress)

#define IBackgroundCopyGroup_GetStatus(This,pdwStatus,pdwJobIndex)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus,pdwJobIndex)

#define IBackgroundCopyGroup_GetJob(This,jobID,ppJob)	\
    (This)->lpVtbl -> GetJob(This,jobID,ppJob)

#define IBackgroundCopyGroup_SuspendGroup(This)	\
    (This)->lpVtbl -> SuspendGroup(This)

#define IBackgroundCopyGroup_ResumeGroup(This)	\
    (This)->lpVtbl -> ResumeGroup(This)

#define IBackgroundCopyGroup_CancelGroup(This)	\
    (This)->lpVtbl -> CancelGroup(This)

#define IBackgroundCopyGroup_get_Size(This,pdwSize)	\
    (This)->lpVtbl -> get_Size(This,pdwSize)

#define IBackgroundCopyGroup_get_GroupID(This,pguidGroupID)	\
    (This)->lpVtbl -> get_GroupID(This,pguidGroupID)

#define IBackgroundCopyGroup_CreateJob(This,guidJobID,ppJob)	\
    (This)->lpVtbl -> CreateJob(This,guidJobID,ppJob)

#define IBackgroundCopyGroup_EnumJobs(This,dwFlags,ppEnumJobs)	\
    (This)->lpVtbl -> EnumJobs(This,dwFlags,ppEnumJobs)

#define IBackgroundCopyGroup_SwitchToForeground(This)	\
    (This)->lpVtbl -> SwitchToForeground(This)

#define IBackgroundCopyGroup_QueryNewJobInterface(This,iid,pUnk)	\
    (This)->lpVtbl -> QueryNewJobInterface(This,iid,pUnk)

#define IBackgroundCopyGroup_SetNotificationPointer(This,iid,pUnk)	\
    (This)->lpVtbl -> SetNotificationPointer(This,iid,pUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBackgroundCopyGroup_GetProp_Proxy( 
    IBackgroundCopyGroup * This,
    /* [in] */ GROUPPROP propID,
    /* [out] */ VARIANT *pvarVal);


void __RPC_STUB IBackgroundCopyGroup_GetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBackgroundCopyGroup_InternalSetProp_Proxy( 
    IBackgroundCopyGroup * This,
    /* [in] */ GROUPPROP propID,
    /* [in] */ VARIANT *pvarVal);


void __RPC_STUB IBackgroundCopyGroup_InternalSetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyGroup_GetProgress_Proxy( 
    IBackgroundCopyGroup * This,
    /* [in] */ DWORD dwFlags,
    /* [out] */ DWORD *pdwProgress);


void __RPC_STUB IBackgroundCopyGroup_GetProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyGroup_GetStatus_Proxy( 
    IBackgroundCopyGroup * This,
    /* [out] */ DWORD *pdwStatus,
    /* [out] */ DWORD *pdwJobIndex);


void __RPC_STUB IBackgroundCopyGroup_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyGroup_GetJob_Proxy( 
    IBackgroundCopyGroup * This,
    /* [in] */ GUID jobID,
    /* [out] */ IBackgroundCopyJob1 **ppJob);


void __RPC_STUB IBackgroundCopyGroup_GetJob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyGroup_SuspendGroup_Proxy( 
    IBackgroundCopyGroup * This);


void __RPC_STUB IBackgroundCopyGroup_SuspendGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyGroup_ResumeGroup_Proxy( 
    IBackgroundCopyGroup * This);


void __RPC_STUB IBackgroundCopyGroup_ResumeGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyGroup_CancelGroup_Proxy( 
    IBackgroundCopyGroup * This);


void __RPC_STUB IBackgroundCopyGroup_CancelGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyGroup_get_Size_Proxy( 
    IBackgroundCopyGroup * This,
    /* [out] */ DWORD *pdwSize);


void __RPC_STUB IBackgroundCopyGroup_get_Size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyGroup_get_GroupID_Proxy( 
    IBackgroundCopyGroup * This,
    /* [out] */ GUID *pguidGroupID);


void __RPC_STUB IBackgroundCopyGroup_get_GroupID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyGroup_CreateJob_Proxy( 
    IBackgroundCopyGroup * This,
    /* [in] */ GUID guidJobID,
    /* [out] */ IBackgroundCopyJob1 **ppJob);


void __RPC_STUB IBackgroundCopyGroup_CreateJob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyGroup_EnumJobs_Proxy( 
    IBackgroundCopyGroup * This,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IEnumBackgroundCopyJobs1 **ppEnumJobs);


void __RPC_STUB IBackgroundCopyGroup_EnumJobs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyGroup_SwitchToForeground_Proxy( 
    IBackgroundCopyGroup * This);


void __RPC_STUB IBackgroundCopyGroup_SwitchToForeground_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyGroup_QueryNewJobInterface_Proxy( 
    IBackgroundCopyGroup * This,
    /* [in] */ REFIID iid,
    /* [iid_is][out] */ IUnknown **pUnk);


void __RPC_STUB IBackgroundCopyGroup_QueryNewJobInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyGroup_SetNotificationPointer_Proxy( 
    IBackgroundCopyGroup * This,
    /* [in] */ REFIID iid,
    /* [in] */ IUnknown *pUnk);


void __RPC_STUB IBackgroundCopyGroup_SetNotificationPointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBackgroundCopyGroup_INTERFACE_DEFINED__ */


#ifndef __IEnumBackgroundCopyGroups_INTERFACE_DEFINED__
#define __IEnumBackgroundCopyGroups_INTERFACE_DEFINED__

/* interface IEnumBackgroundCopyGroups */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumBackgroundCopyGroups;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d993e603-4aa4-47c5-8665-c20d39c2ba4f")
    IEnumBackgroundCopyGroups : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ GUID *rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumBackgroundCopyGroups **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *puCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumBackgroundCopyGroupsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumBackgroundCopyGroups * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumBackgroundCopyGroups * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumBackgroundCopyGroups * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumBackgroundCopyGroups * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ GUID *rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumBackgroundCopyGroups * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumBackgroundCopyGroups * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumBackgroundCopyGroups * This,
            /* [out] */ IEnumBackgroundCopyGroups **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumBackgroundCopyGroups * This,
            /* [out] */ ULONG *puCount);
        
        END_INTERFACE
    } IEnumBackgroundCopyGroupsVtbl;

    interface IEnumBackgroundCopyGroups
    {
        CONST_VTBL struct IEnumBackgroundCopyGroupsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumBackgroundCopyGroups_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumBackgroundCopyGroups_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumBackgroundCopyGroups_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumBackgroundCopyGroups_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumBackgroundCopyGroups_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumBackgroundCopyGroups_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumBackgroundCopyGroups_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#define IEnumBackgroundCopyGroups_GetCount(This,puCount)	\
    (This)->lpVtbl -> GetCount(This,puCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumBackgroundCopyGroups_Next_Proxy( 
    IEnumBackgroundCopyGroups * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ GUID *rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IEnumBackgroundCopyGroups_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumBackgroundCopyGroups_Skip_Proxy( 
    IEnumBackgroundCopyGroups * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumBackgroundCopyGroups_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumBackgroundCopyGroups_Reset_Proxy( 
    IEnumBackgroundCopyGroups * This);


void __RPC_STUB IEnumBackgroundCopyGroups_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumBackgroundCopyGroups_Clone_Proxy( 
    IEnumBackgroundCopyGroups * This,
    /* [out] */ IEnumBackgroundCopyGroups **ppenum);


void __RPC_STUB IEnumBackgroundCopyGroups_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumBackgroundCopyGroups_GetCount_Proxy( 
    IEnumBackgroundCopyGroups * This,
    /* [out] */ ULONG *puCount);


void __RPC_STUB IEnumBackgroundCopyGroups_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumBackgroundCopyGroups_INTERFACE_DEFINED__ */


#ifndef __IBackgroundCopyCallback1_INTERFACE_DEFINED__
#define __IBackgroundCopyCallback1_INTERFACE_DEFINED__

/* interface IBackgroundCopyCallback1 */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IBackgroundCopyCallback1;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("084f6593-3800-4e08-9b59-99fa59addf82")
    IBackgroundCopyCallback1 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStatus( 
            /* [in] */ IBackgroundCopyGroup *pGroup,
            /* [in] */ IBackgroundCopyJob1 *pJob,
            /* [in] */ DWORD dwFileIndex,
            /* [in] */ DWORD dwStatus,
            /* [in] */ DWORD dwNumOfRetries,
            /* [in] */ DWORD dwWin32Result,
            /* [in] */ DWORD dwTransportResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ DWORD ProgressType,
            /* [in] */ IBackgroundCopyGroup *pGroup,
            /* [in] */ IBackgroundCopyJob1 *pJob,
            /* [in] */ DWORD dwFileIndex,
            /* [in] */ DWORD dwProgressValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnProgressEx( 
            /* [in] */ DWORD ProgressType,
            /* [in] */ IBackgroundCopyGroup *pGroup,
            /* [in] */ IBackgroundCopyJob1 *pJob,
            /* [in] */ DWORD dwFileIndex,
            /* [in] */ DWORD dwProgressValue,
            /* [in] */ DWORD dwByteArraySize,
            /* [size_is][in] */ BYTE *pByte) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBackgroundCopyCallback1Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBackgroundCopyCallback1 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBackgroundCopyCallback1 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBackgroundCopyCallback1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStatus )( 
            IBackgroundCopyCallback1 * This,
            /* [in] */ IBackgroundCopyGroup *pGroup,
            /* [in] */ IBackgroundCopyJob1 *pJob,
            /* [in] */ DWORD dwFileIndex,
            /* [in] */ DWORD dwStatus,
            /* [in] */ DWORD dwNumOfRetries,
            /* [in] */ DWORD dwWin32Result,
            /* [in] */ DWORD dwTransportResult);
        
        HRESULT ( STDMETHODCALLTYPE *OnProgress )( 
            IBackgroundCopyCallback1 * This,
            /* [in] */ DWORD ProgressType,
            /* [in] */ IBackgroundCopyGroup *pGroup,
            /* [in] */ IBackgroundCopyJob1 *pJob,
            /* [in] */ DWORD dwFileIndex,
            /* [in] */ DWORD dwProgressValue);
        
        HRESULT ( STDMETHODCALLTYPE *OnProgressEx )( 
            IBackgroundCopyCallback1 * This,
            /* [in] */ DWORD ProgressType,
            /* [in] */ IBackgroundCopyGroup *pGroup,
            /* [in] */ IBackgroundCopyJob1 *pJob,
            /* [in] */ DWORD dwFileIndex,
            /* [in] */ DWORD dwProgressValue,
            /* [in] */ DWORD dwByteArraySize,
            /* [size_is][in] */ BYTE *pByte);
        
        END_INTERFACE
    } IBackgroundCopyCallback1Vtbl;

    interface IBackgroundCopyCallback1
    {
        CONST_VTBL struct IBackgroundCopyCallback1Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBackgroundCopyCallback1_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBackgroundCopyCallback1_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBackgroundCopyCallback1_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBackgroundCopyCallback1_OnStatus(This,pGroup,pJob,dwFileIndex,dwStatus,dwNumOfRetries,dwWin32Result,dwTransportResult)	\
    (This)->lpVtbl -> OnStatus(This,pGroup,pJob,dwFileIndex,dwStatus,dwNumOfRetries,dwWin32Result,dwTransportResult)

#define IBackgroundCopyCallback1_OnProgress(This,ProgressType,pGroup,pJob,dwFileIndex,dwProgressValue)	\
    (This)->lpVtbl -> OnProgress(This,ProgressType,pGroup,pJob,dwFileIndex,dwProgressValue)

#define IBackgroundCopyCallback1_OnProgressEx(This,ProgressType,pGroup,pJob,dwFileIndex,dwProgressValue,dwByteArraySize,pByte)	\
    (This)->lpVtbl -> OnProgressEx(This,ProgressType,pGroup,pJob,dwFileIndex,dwProgressValue,dwByteArraySize,pByte)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBackgroundCopyCallback1_OnStatus_Proxy( 
    IBackgroundCopyCallback1 * This,
    /* [in] */ IBackgroundCopyGroup *pGroup,
    /* [in] */ IBackgroundCopyJob1 *pJob,
    /* [in] */ DWORD dwFileIndex,
    /* [in] */ DWORD dwStatus,
    /* [in] */ DWORD dwNumOfRetries,
    /* [in] */ DWORD dwWin32Result,
    /* [in] */ DWORD dwTransportResult);


void __RPC_STUB IBackgroundCopyCallback1_OnStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyCallback1_OnProgress_Proxy( 
    IBackgroundCopyCallback1 * This,
    /* [in] */ DWORD ProgressType,
    /* [in] */ IBackgroundCopyGroup *pGroup,
    /* [in] */ IBackgroundCopyJob1 *pJob,
    /* [in] */ DWORD dwFileIndex,
    /* [in] */ DWORD dwProgressValue);


void __RPC_STUB IBackgroundCopyCallback1_OnProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyCallback1_OnProgressEx_Proxy( 
    IBackgroundCopyCallback1 * This,
    /* [in] */ DWORD ProgressType,
    /* [in] */ IBackgroundCopyGroup *pGroup,
    /* [in] */ IBackgroundCopyJob1 *pJob,
    /* [in] */ DWORD dwFileIndex,
    /* [in] */ DWORD dwProgressValue,
    /* [in] */ DWORD dwByteArraySize,
    /* [size_is][in] */ BYTE *pByte);


void __RPC_STUB IBackgroundCopyCallback1_OnProgressEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBackgroundCopyCallback1_INTERFACE_DEFINED__ */


#ifndef __IBackgroundCopyQMgr_INTERFACE_DEFINED__
#define __IBackgroundCopyQMgr_INTERFACE_DEFINED__

/* interface IBackgroundCopyQMgr */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IBackgroundCopyQMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("16f41c69-09f5-41d2-8cd8-3c08c47bc8a8")
    IBackgroundCopyQMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateGroup( 
            /* [in] */ GUID guidGroupID,
            /* [out] */ IBackgroundCopyGroup **ppGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroup( 
            /* [in] */ GUID groupID,
            /* [out] */ IBackgroundCopyGroup **ppGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumGroups( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ IEnumBackgroundCopyGroups **ppEnumGroups) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBackgroundCopyQMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBackgroundCopyQMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBackgroundCopyQMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBackgroundCopyQMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateGroup )( 
            IBackgroundCopyQMgr * This,
            /* [in] */ GUID guidGroupID,
            /* [out] */ IBackgroundCopyGroup **ppGroup);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroup )( 
            IBackgroundCopyQMgr * This,
            /* [in] */ GUID groupID,
            /* [out] */ IBackgroundCopyGroup **ppGroup);
        
        HRESULT ( STDMETHODCALLTYPE *EnumGroups )( 
            IBackgroundCopyQMgr * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IEnumBackgroundCopyGroups **ppEnumGroups);
        
        END_INTERFACE
    } IBackgroundCopyQMgrVtbl;

    interface IBackgroundCopyQMgr
    {
        CONST_VTBL struct IBackgroundCopyQMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBackgroundCopyQMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBackgroundCopyQMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBackgroundCopyQMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBackgroundCopyQMgr_CreateGroup(This,guidGroupID,ppGroup)	\
    (This)->lpVtbl -> CreateGroup(This,guidGroupID,ppGroup)

#define IBackgroundCopyQMgr_GetGroup(This,groupID,ppGroup)	\
    (This)->lpVtbl -> GetGroup(This,groupID,ppGroup)

#define IBackgroundCopyQMgr_EnumGroups(This,dwFlags,ppEnumGroups)	\
    (This)->lpVtbl -> EnumGroups(This,dwFlags,ppEnumGroups)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBackgroundCopyQMgr_CreateGroup_Proxy( 
    IBackgroundCopyQMgr * This,
    /* [in] */ GUID guidGroupID,
    /* [out] */ IBackgroundCopyGroup **ppGroup);


void __RPC_STUB IBackgroundCopyQMgr_CreateGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyQMgr_GetGroup_Proxy( 
    IBackgroundCopyQMgr * This,
    /* [in] */ GUID groupID,
    /* [out] */ IBackgroundCopyGroup **ppGroup);


void __RPC_STUB IBackgroundCopyQMgr_GetGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyQMgr_EnumGroups_Proxy( 
    IBackgroundCopyQMgr * This,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IEnumBackgroundCopyGroups **ppEnumGroups);


void __RPC_STUB IBackgroundCopyQMgr_EnumGroups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBackgroundCopyQMgr_INTERFACE_DEFINED__ */



#ifndef __BackgroundCopyQMgr_LIBRARY_DEFINED__
#define __BackgroundCopyQMgr_LIBRARY_DEFINED__

/* library BackgroundCopyQMgr */
/* [version][lcid][helpstring][uuid] */ 


EXTERN_C const IID LIBID_BackgroundCopyQMgr;

EXTERN_C const CLSID CLSID_BackgroundCopyQMgr;

#ifdef __cplusplus

class DECLSPEC_UUID("69AD4AEE-51BE-439b-A92C-86AE490E8B30")
BackgroundCopyQMgr;
#endif
#endif /* __BackgroundCopyQMgr_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IBackgroundCopyGroup_SetProp_Proxy( 
    IBackgroundCopyGroup * This,
    /* [in] */ GROUPPROP propID,
    /* [in] */ VARIANT *pvarVal);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBackgroundCopyGroup_SetProp_Stub( 
    IBackgroundCopyGroup * This,
    /* [in] */ GROUPPROP propID,
    /* [in] */ VARIANT *pvarVal);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\qedit.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for qedit.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __qedit_h__
#define __qedit_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IPropertySetter_FWD_DEFINED__
#define __IPropertySetter_FWD_DEFINED__
typedef interface IPropertySetter IPropertySetter;
#endif 	/* __IPropertySetter_FWD_DEFINED__ */


#ifndef __IDxtCompositor_FWD_DEFINED__
#define __IDxtCompositor_FWD_DEFINED__
typedef interface IDxtCompositor IDxtCompositor;
#endif 	/* __IDxtCompositor_FWD_DEFINED__ */


#ifndef __IDxtAlphaSetter_FWD_DEFINED__
#define __IDxtAlphaSetter_FWD_DEFINED__
typedef interface IDxtAlphaSetter IDxtAlphaSetter;
#endif 	/* __IDxtAlphaSetter_FWD_DEFINED__ */


#ifndef __IDxtJpeg_FWD_DEFINED__
#define __IDxtJpeg_FWD_DEFINED__
typedef interface IDxtJpeg IDxtJpeg;
#endif 	/* __IDxtJpeg_FWD_DEFINED__ */


#ifndef __IDxtKey_FWD_DEFINED__
#define __IDxtKey_FWD_DEFINED__
typedef interface IDxtKey IDxtKey;
#endif 	/* __IDxtKey_FWD_DEFINED__ */


#ifndef __IMediaLocator_FWD_DEFINED__
#define __IMediaLocator_FWD_DEFINED__
typedef interface IMediaLocator IMediaLocator;
#endif 	/* __IMediaLocator_FWD_DEFINED__ */


#ifndef __IMediaDet_FWD_DEFINED__
#define __IMediaDet_FWD_DEFINED__
typedef interface IMediaDet IMediaDet;
#endif 	/* __IMediaDet_FWD_DEFINED__ */


#ifndef __IGrfCache_FWD_DEFINED__
#define __IGrfCache_FWD_DEFINED__
typedef interface IGrfCache IGrfCache;
#endif 	/* __IGrfCache_FWD_DEFINED__ */


#ifndef __IRenderEngine_FWD_DEFINED__
#define __IRenderEngine_FWD_DEFINED__
typedef interface IRenderEngine IRenderEngine;
#endif 	/* __IRenderEngine_FWD_DEFINED__ */


#ifndef __IFindCompressorCB_FWD_DEFINED__
#define __IFindCompressorCB_FWD_DEFINED__
typedef interface IFindCompressorCB IFindCompressorCB;
#endif 	/* __IFindCompressorCB_FWD_DEFINED__ */


#ifndef __ISmartRenderEngine_FWD_DEFINED__
#define __ISmartRenderEngine_FWD_DEFINED__
typedef interface ISmartRenderEngine ISmartRenderEngine;
#endif 	/* __ISmartRenderEngine_FWD_DEFINED__ */


#ifndef __IAMTimelineObj_FWD_DEFINED__
#define __IAMTimelineObj_FWD_DEFINED__
typedef interface IAMTimelineObj IAMTimelineObj;
#endif 	/* __IAMTimelineObj_FWD_DEFINED__ */


#ifndef __IAMTimelineEffectable_FWD_DEFINED__
#define __IAMTimelineEffectable_FWD_DEFINED__
typedef interface IAMTimelineEffectable IAMTimelineEffectable;
#endif 	/* __IAMTimelineEffectable_FWD_DEFINED__ */


#ifndef __IAMTimelineEffect_FWD_DEFINED__
#define __IAMTimelineEffect_FWD_DEFINED__
typedef interface IAMTimelineEffect IAMTimelineEffect;
#endif 	/* __IAMTimelineEffect_FWD_DEFINED__ */


#ifndef __IAMTimelineTransable_FWD_DEFINED__
#define __IAMTimelineTransable_FWD_DEFINED__
typedef interface IAMTimelineTransable IAMTimelineTransable;
#endif 	/* __IAMTimelineTransable_FWD_DEFINED__ */


#ifndef __IAMTimelineSplittable_FWD_DEFINED__
#define __IAMTimelineSplittable_FWD_DEFINED__
typedef interface IAMTimelineSplittable IAMTimelineSplittable;
#endif 	/* __IAMTimelineSplittable_FWD_DEFINED__ */


#ifndef __IAMTimelineTrans_FWD_DEFINED__
#define __IAMTimelineTrans_FWD_DEFINED__
typedef interface IAMTimelineTrans IAMTimelineTrans;
#endif 	/* __IAMTimelineTrans_FWD_DEFINED__ */


#ifndef __IAMTimelineSrc_FWD_DEFINED__
#define __IAMTimelineSrc_FWD_DEFINED__
typedef interface IAMTimelineSrc IAMTimelineSrc;
#endif 	/* __IAMTimelineSrc_FWD_DEFINED__ */


#ifndef __IAMTimelineTrack_FWD_DEFINED__
#define __IAMTimelineTrack_FWD_DEFINED__
typedef interface IAMTimelineTrack IAMTimelineTrack;
#endif 	/* __IAMTimelineTrack_FWD_DEFINED__ */


#ifndef __IAMTimelineVirtualTrack_FWD_DEFINED__
#define __IAMTimelineVirtualTrack_FWD_DEFINED__
typedef interface IAMTimelineVirtualTrack IAMTimelineVirtualTrack;
#endif 	/* __IAMTimelineVirtualTrack_FWD_DEFINED__ */


#ifndef __IAMTimelineComp_FWD_DEFINED__
#define __IAMTimelineComp_FWD_DEFINED__
typedef interface IAMTimelineComp IAMTimelineComp;
#endif 	/* __IAMTimelineComp_FWD_DEFINED__ */


#ifndef __IAMTimelineGroup_FWD_DEFINED__
#define __IAMTimelineGroup_FWD_DEFINED__
typedef interface IAMTimelineGroup IAMTimelineGroup;
#endif 	/* __IAMTimelineGroup_FWD_DEFINED__ */


#ifndef __IAMTimeline_FWD_DEFINED__
#define __IAMTimeline_FWD_DEFINED__
typedef interface IAMTimeline IAMTimeline;
#endif 	/* __IAMTimeline_FWD_DEFINED__ */


#ifndef __IXml2Dex_FWD_DEFINED__
#define __IXml2Dex_FWD_DEFINED__
typedef interface IXml2Dex IXml2Dex;
#endif 	/* __IXml2Dex_FWD_DEFINED__ */


#ifndef __IAMErrorLog_FWD_DEFINED__
#define __IAMErrorLog_FWD_DEFINED__
typedef interface IAMErrorLog IAMErrorLog;
#endif 	/* __IAMErrorLog_FWD_DEFINED__ */


#ifndef __IAMSetErrorLog_FWD_DEFINED__
#define __IAMSetErrorLog_FWD_DEFINED__
typedef interface IAMSetErrorLog IAMSetErrorLog;
#endif 	/* __IAMSetErrorLog_FWD_DEFINED__ */


#ifndef __ISampleGrabberCB_FWD_DEFINED__
#define __ISampleGrabberCB_FWD_DEFINED__
typedef interface ISampleGrabberCB ISampleGrabberCB;
#endif 	/* __ISampleGrabberCB_FWD_DEFINED__ */


#ifndef __ISampleGrabber_FWD_DEFINED__
#define __ISampleGrabber_FWD_DEFINED__
typedef interface ISampleGrabber ISampleGrabber;
#endif 	/* __ISampleGrabber_FWD_DEFINED__ */


#ifndef __AMTimeline_FWD_DEFINED__
#define __AMTimeline_FWD_DEFINED__

#ifdef __cplusplus
typedef class AMTimeline AMTimeline;
#else
typedef struct AMTimeline AMTimeline;
#endif /* __cplusplus */

#endif 	/* __AMTimeline_FWD_DEFINED__ */


#ifndef __AMTimelineObj_FWD_DEFINED__
#define __AMTimelineObj_FWD_DEFINED__

#ifdef __cplusplus
typedef class AMTimelineObj AMTimelineObj;
#else
typedef struct AMTimelineObj AMTimelineObj;
#endif /* __cplusplus */

#endif 	/* __AMTimelineObj_FWD_DEFINED__ */


#ifndef __AMTimelineSrc_FWD_DEFINED__
#define __AMTimelineSrc_FWD_DEFINED__

#ifdef __cplusplus
typedef class AMTimelineSrc AMTimelineSrc;
#else
typedef struct AMTimelineSrc AMTimelineSrc;
#endif /* __cplusplus */

#endif 	/* __AMTimelineSrc_FWD_DEFINED__ */


#ifndef __AMTimelineTrack_FWD_DEFINED__
#define __AMTimelineTrack_FWD_DEFINED__

#ifdef __cplusplus
typedef class AMTimelineTrack AMTimelineTrack;
#else
typedef struct AMTimelineTrack AMTimelineTrack;
#endif /* __cplusplus */

#endif 	/* __AMTimelineTrack_FWD_DEFINED__ */


#ifndef __AMTimelineComp_FWD_DEFINED__
#define __AMTimelineComp_FWD_DEFINED__

#ifdef __cplusplus
typedef class AMTimelineComp AMTimelineComp;
#else
typedef struct AMTimelineComp AMTimelineComp;
#endif /* __cplusplus */

#endif 	/* __AMTimelineComp_FWD_DEFINED__ */


#ifndef __AMTimelineGroup_FWD_DEFINED__
#define __AMTimelineGroup_FWD_DEFINED__

#ifdef __cplusplus
typedef class AMTimelineGroup AMTimelineGroup;
#else
typedef struct AMTimelineGroup AMTimelineGroup;
#endif /* __cplusplus */

#endif 	/* __AMTimelineGroup_FWD_DEFINED__ */


#ifndef __AMTimelineTrans_FWD_DEFINED__
#define __AMTimelineTrans_FWD_DEFINED__

#ifdef __cplusplus
typedef class AMTimelineTrans AMTimelineTrans;
#else
typedef struct AMTimelineTrans AMTimelineTrans;
#endif /* __cplusplus */

#endif 	/* __AMTimelineTrans_FWD_DEFINED__ */


#ifndef __AMTimelineEffect_FWD_DEFINED__
#define __AMTimelineEffect_FWD_DEFINED__

#ifdef __cplusplus
typedef class AMTimelineEffect AMTimelineEffect;
#else
typedef struct AMTimelineEffect AMTimelineEffect;
#endif /* __cplusplus */

#endif 	/* __AMTimelineEffect_FWD_DEFINED__ */


#ifndef __RenderEngine_FWD_DEFINED__
#define __RenderEngine_FWD_DEFINED__

#ifdef __cplusplus
typedef class RenderEngine RenderEngine;
#else
typedef struct RenderEngine RenderEngine;
#endif /* __cplusplus */

#endif 	/* __RenderEngine_FWD_DEFINED__ */


#ifndef __SmartRenderEngine_FWD_DEFINED__
#define __SmartRenderEngine_FWD_DEFINED__

#ifdef __cplusplus
typedef class SmartRenderEngine SmartRenderEngine;
#else
typedef struct SmartRenderEngine SmartRenderEngine;
#endif /* __cplusplus */

#endif 	/* __SmartRenderEngine_FWD_DEFINED__ */


#ifndef __AudMixer_FWD_DEFINED__
#define __AudMixer_FWD_DEFINED__

#ifdef __cplusplus
typedef class AudMixer AudMixer;
#else
typedef struct AudMixer AudMixer;
#endif /* __cplusplus */

#endif 	/* __AudMixer_FWD_DEFINED__ */


#ifndef __Xml2Dex_FWD_DEFINED__
#define __Xml2Dex_FWD_DEFINED__

#ifdef __cplusplus
typedef class Xml2Dex Xml2Dex;
#else
typedef struct Xml2Dex Xml2Dex;
#endif /* __cplusplus */

#endif 	/* __Xml2Dex_FWD_DEFINED__ */


#ifndef __MediaLocator_FWD_DEFINED__
#define __MediaLocator_FWD_DEFINED__

#ifdef __cplusplus
typedef class MediaLocator MediaLocator;
#else
typedef struct MediaLocator MediaLocator;
#endif /* __cplusplus */

#endif 	/* __MediaLocator_FWD_DEFINED__ */


#ifndef __PropertySetter_FWD_DEFINED__
#define __PropertySetter_FWD_DEFINED__

#ifdef __cplusplus
typedef class PropertySetter PropertySetter;
#else
typedef struct PropertySetter PropertySetter;
#endif /* __cplusplus */

#endif 	/* __PropertySetter_FWD_DEFINED__ */


#ifndef __MediaDet_FWD_DEFINED__
#define __MediaDet_FWD_DEFINED__

#ifdef __cplusplus
typedef class MediaDet MediaDet;
#else
typedef struct MediaDet MediaDet;
#endif /* __cplusplus */

#endif 	/* __MediaDet_FWD_DEFINED__ */


#ifndef __SampleGrabber_FWD_DEFINED__
#define __SampleGrabber_FWD_DEFINED__

#ifdef __cplusplus
typedef class SampleGrabber SampleGrabber;
#else
typedef struct SampleGrabber SampleGrabber;
#endif /* __cplusplus */

#endif 	/* __SampleGrabber_FWD_DEFINED__ */


#ifndef __NullRenderer_FWD_DEFINED__
#define __NullRenderer_FWD_DEFINED__

#ifdef __cplusplus
typedef class NullRenderer NullRenderer;
#else
typedef struct NullRenderer NullRenderer;
#endif /* __cplusplus */

#endif 	/* __NullRenderer_FWD_DEFINED__ */


#ifndef __DxtCompositor_FWD_DEFINED__
#define __DxtCompositor_FWD_DEFINED__

#ifdef __cplusplus
typedef class DxtCompositor DxtCompositor;
#else
typedef struct DxtCompositor DxtCompositor;
#endif /* __cplusplus */

#endif 	/* __DxtCompositor_FWD_DEFINED__ */


#ifndef __DxtAlphaSetter_FWD_DEFINED__
#define __DxtAlphaSetter_FWD_DEFINED__

#ifdef __cplusplus
typedef class DxtAlphaSetter DxtAlphaSetter;
#else
typedef struct DxtAlphaSetter DxtAlphaSetter;
#endif /* __cplusplus */

#endif 	/* __DxtAlphaSetter_FWD_DEFINED__ */


#ifndef __DxtJpeg_FWD_DEFINED__
#define __DxtJpeg_FWD_DEFINED__

#ifdef __cplusplus
typedef class DxtJpeg DxtJpeg;
#else
typedef struct DxtJpeg DxtJpeg;
#endif /* __cplusplus */

#endif 	/* __DxtJpeg_FWD_DEFINED__ */


#ifndef __ColorSource_FWD_DEFINED__
#define __ColorSource_FWD_DEFINED__

#ifdef __cplusplus
typedef class ColorSource ColorSource;
#else
typedef struct ColorSource ColorSource;
#endif /* __cplusplus */

#endif 	/* __ColorSource_FWD_DEFINED__ */


#ifndef __DxtKey_FWD_DEFINED__
#define __DxtKey_FWD_DEFINED__

#ifdef __cplusplus
typedef class DxtKey DxtKey;
#else
typedef struct DxtKey DxtKey;
#endif /* __cplusplus */

#endif 	/* __DxtKey_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "dxtrans.h"
#include "amstream.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_qedit_0000 */
/* [local] */ 










typedef /* [public] */ 
enum __MIDL___MIDL_itf_qedit_0000_0001
    {	DEXTERF_JUMP	= 0,
	DEXTERF_INTERPOLATE	= DEXTERF_JUMP + 1
    } 	DEXTERF;

typedef /* [public][public][public][public] */ struct __MIDL___MIDL_itf_qedit_0000_0002
    {
    BSTR Name;
    DISPID dispID;
    LONG nValues;
    } 	DEXTER_PARAM;

typedef /* [public][public][public][public] */ struct __MIDL___MIDL_itf_qedit_0000_0003
    {
    VARIANT v;
    REFERENCE_TIME rt;
    DWORD dwInterp;
    } 	DEXTER_VALUE;


enum __MIDL___MIDL_itf_qedit_0000_0004
    {	DEXTER_AUDIO_JUMP	= 0,
	DEXTER_AUDIO_INTERPOLATE	= DEXTER_AUDIO_JUMP + 1
    } ;
typedef /* [public] */ struct __MIDL___MIDL_itf_qedit_0000_0005
    {
    REFERENCE_TIME rtEnd;
    double dLevel;
    BOOL bMethod;
    } 	DEXTER_AUDIO_VOLUMEENVELOPE;


enum __MIDL___MIDL_itf_qedit_0000_0006
    {	TIMELINE_INSERT_MODE_INSERT	= 1,
	TIMELINE_INSERT_MODE_OVERLAY	= 2
    } ;
typedef /* [public][public][public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_qedit_0000_0007
    {	TIMELINE_MAJOR_TYPE_COMPOSITE	= 1,
	TIMELINE_MAJOR_TYPE_TRACK	= 2,
	TIMELINE_MAJOR_TYPE_SOURCE	= 4,
	TIMELINE_MAJOR_TYPE_TRANSITION	= 8,
	TIMELINE_MAJOR_TYPE_EFFECT	= 16,
	TIMELINE_MAJOR_TYPE_GROUP	= 128
    } 	TIMELINE_MAJOR_TYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_qedit_0000_0008
    {	DEXTERF_BOUNDING	= -1,
	DEXTERF_EXACTLY_AT	= 0,
	DEXTERF_FORWARDS	= 1
    } 	DEXTERF_TRACK_SEARCH_FLAGS;

typedef struct _SCompFmt0
    {
    long nFormatId;
    AM_MEDIA_TYPE MediaType;
    } 	SCompFmt0;


enum __MIDL___MIDL_itf_qedit_0000_0009
    {	RESIZEF_STRETCH	= 0,
	RESIZEF_CROP	= RESIZEF_STRETCH + 1,
	RESIZEF_PRESERVEASPECTRATIO	= RESIZEF_CROP + 1,
	RESIZEF_PRESERVEASPECTRATIO_NOLETTERBOX	= RESIZEF_PRESERVEASPECTRATIO + 1
    } ;

enum __MIDL___MIDL_itf_qedit_0000_0010
    {	CONNECTF_DYNAMIC_NONE	= 0,
	CONNECTF_DYNAMIC_SOURCES	= 0x1,
	CONNECTF_DYNAMIC_EFFECTS	= 0x2
    } ;

enum __MIDL___MIDL_itf_qedit_0000_0011
    {	SFN_VALIDATEF_CHECK	= 0x1,
	SFN_VALIDATEF_POPUP	= 0x2,
	SFN_VALIDATEF_TELLME	= 0x4,
	SFN_VALIDATEF_REPLACE	= 0x8,
	SFN_VALIDATEF_USELOCAL	= 0x10,
	SFN_VALIDATEF_NOFIND	= 0x20,
	SFN_VALIDATEF_IGNOREMUTED	= 0x40,
	SFN_VALIDATEF_END	= SFN_VALIDATEF_IGNOREMUTED + 1
    } ;

enum __MIDL___MIDL_itf_qedit_0000_0012
    {	DXTKEY_RGB	= 0,
	DXTKEY_NONRED	= DXTKEY_RGB + 1,
	DXTKEY_LUMINANCE	= DXTKEY_NONRED + 1,
	DXTKEY_ALPHA	= DXTKEY_LUMINANCE + 1,
	DXTKEY_HUE	= DXTKEY_ALPHA + 1
    } ;


extern RPC_IF_HANDLE __MIDL_itf_qedit_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_qedit_0000_v0_0_s_ifspec;

#ifndef __IPropertySetter_INTERFACE_DEFINED__
#define __IPropertySetter_INTERFACE_DEFINED__

/* interface IPropertySetter */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPropertySetter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AE9472BD-B0C3-11D2-8D24-00A0C9441E20")
    IPropertySetter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LoadXML( 
            /* [in] */ IUnknown *pxml) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PrintXML( 
            /* [out] */ char *pszXML,
            /* [in] */ int cbXML,
            /* [out] */ int *pcbPrinted,
            /* [in] */ int indent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloneProps( 
            /* [out] */ IPropertySetter **ppSetter,
            /* [in] */ REFERENCE_TIME rtStart,
            /* [in] */ REFERENCE_TIME rtStop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddProp( 
            /* [in] */ DEXTER_PARAM Param,
            /* [in] */ DEXTER_VALUE *paValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProps( 
            /* [out] */ LONG *pcParams,
            /* [out] */ DEXTER_PARAM **paParam,
            /* [out] */ DEXTER_VALUE **paValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeProps( 
            /* [in] */ LONG cParams,
            /* [in] */ DEXTER_PARAM *paParam,
            /* [in] */ DEXTER_VALUE *paValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearProps( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveToBlob( 
            /* [out] */ LONG *pcSize,
            /* [out] */ BYTE **ppb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadFromBlob( 
            /* [in] */ LONG cSize,
            /* [in] */ BYTE *pb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProps( 
            /* [in] */ IUnknown *pTarget,
            /* [in] */ REFERENCE_TIME rtNow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PrintXMLW( 
            /* [out] */ WCHAR *pszXML,
            /* [in] */ int cchXML,
            /* [out] */ int *pcchPrinted,
            /* [in] */ int indent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertySetterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertySetter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertySetter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertySetter * This);
        
        HRESULT ( STDMETHODCALLTYPE *LoadXML )( 
            IPropertySetter * This,
            /* [in] */ IUnknown *pxml);
        
        HRESULT ( STDMETHODCALLTYPE *PrintXML )( 
            IPropertySetter * This,
            /* [out] */ char *pszXML,
            /* [in] */ int cbXML,
            /* [out] */ int *pcbPrinted,
            /* [in] */ int indent);
        
        HRESULT ( STDMETHODCALLTYPE *CloneProps )( 
            IPropertySetter * This,
            /* [out] */ IPropertySetter **ppSetter,
            /* [in] */ REFERENCE_TIME rtStart,
            /* [in] */ REFERENCE_TIME rtStop);
        
        HRESULT ( STDMETHODCALLTYPE *AddProp )( 
            IPropertySetter * This,
            /* [in] */ DEXTER_PARAM Param,
            /* [in] */ DEXTER_VALUE *paValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetProps )( 
            IPropertySetter * This,
            /* [out] */ LONG *pcParams,
            /* [out] */ DEXTER_PARAM **paParam,
            /* [out] */ DEXTER_VALUE **paValue);
        
        HRESULT ( STDMETHODCALLTYPE *FreeProps )( 
            IPropertySetter * This,
            /* [in] */ LONG cParams,
            /* [in] */ DEXTER_PARAM *paParam,
            /* [in] */ DEXTER_VALUE *paValue);
        
        HRESULT ( STDMETHODCALLTYPE *ClearProps )( 
            IPropertySetter * This);
        
        HRESULT ( STDMETHODCALLTYPE *SaveToBlob )( 
            IPropertySetter * This,
            /* [out] */ LONG *pcSize,
            /* [out] */ BYTE **ppb);
        
        HRESULT ( STDMETHODCALLTYPE *LoadFromBlob )( 
            IPropertySetter * This,
            /* [in] */ LONG cSize,
            /* [in] */ BYTE *pb);
        
        HRESULT ( STDMETHODCALLTYPE *SetProps )( 
            IPropertySetter * This,
            /* [in] */ IUnknown *pTarget,
            /* [in] */ REFERENCE_TIME rtNow);
        
        HRESULT ( STDMETHODCALLTYPE *PrintXMLW )( 
            IPropertySetter * This,
            /* [out] */ WCHAR *pszXML,
            /* [in] */ int cchXML,
            /* [out] */ int *pcchPrinted,
            /* [in] */ int indent);
        
        END_INTERFACE
    } IPropertySetterVtbl;

    interface IPropertySetter
    {
        CONST_VTBL struct IPropertySetterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertySetter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertySetter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropertySetter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropertySetter_LoadXML(This,pxml)	\
    (This)->lpVtbl -> LoadXML(This,pxml)

#define IPropertySetter_PrintXML(This,pszXML,cbXML,pcbPrinted,indent)	\
    (This)->lpVtbl -> PrintXML(This,pszXML,cbXML,pcbPrinted,indent)

#define IPropertySetter_CloneProps(This,ppSetter,rtStart,rtStop)	\
    (This)->lpVtbl -> CloneProps(This,ppSetter,rtStart,rtStop)

#define IPropertySetter_AddProp(This,Param,paValue)	\
    (This)->lpVtbl -> AddProp(This,Param,paValue)

#define IPropertySetter_GetProps(This,pcParams,paParam,paValue)	\
    (This)->lpVtbl -> GetProps(This,pcParams,paParam,paValue)

#define IPropertySetter_FreeProps(This,cParams,paParam,paValue)	\
    (This)->lpVtbl -> FreeProps(This,cParams,paParam,paValue)

#define IPropertySetter_ClearProps(This)	\
    (This)->lpVtbl -> ClearProps(This)

#define IPropertySetter_SaveToBlob(This,pcSize,ppb)	\
    (This)->lpVtbl -> SaveToBlob(This,pcSize,ppb)

#define IPropertySetter_LoadFromBlob(This,cSize,pb)	\
    (This)->lpVtbl -> LoadFromBlob(This,cSize,pb)

#define IPropertySetter_SetProps(This,pTarget,rtNow)	\
    (This)->lpVtbl -> SetProps(This,pTarget,rtNow)

#define IPropertySetter_PrintXMLW(This,pszXML,cchXML,pcchPrinted,indent)	\
    (This)->lpVtbl -> PrintXMLW(This,pszXML,cchXML,pcchPrinted,indent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPropertySetter_LoadXML_Proxy( 
    IPropertySetter * This,
    /* [in] */ IUnknown *pxml);


void __RPC_STUB IPropertySetter_LoadXML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertySetter_PrintXML_Proxy( 
    IPropertySetter * This,
    /* [out] */ char *pszXML,
    /* [in] */ int cbXML,
    /* [out] */ int *pcbPrinted,
    /* [in] */ int indent);


void __RPC_STUB IPropertySetter_PrintXML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertySetter_CloneProps_Proxy( 
    IPropertySetter * This,
    /* [out] */ IPropertySetter **ppSetter,
    /* [in] */ REFERENCE_TIME rtStart,
    /* [in] */ REFERENCE_TIME rtStop);


void __RPC_STUB IPropertySetter_CloneProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertySetter_AddProp_Proxy( 
    IPropertySetter * This,
    /* [in] */ DEXTER_PARAM Param,
    /* [in] */ DEXTER_VALUE *paValue);


void __RPC_STUB IPropertySetter_AddProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertySetter_GetProps_Proxy( 
    IPropertySetter * This,
    /* [out] */ LONG *pcParams,
    /* [out] */ DEXTER_PARAM **paParam,
    /* [out] */ DEXTER_VALUE **paValue);


void __RPC_STUB IPropertySetter_GetProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertySetter_FreeProps_Proxy( 
    IPropertySetter * This,
    /* [in] */ LONG cParams,
    /* [in] */ DEXTER_PARAM *paParam,
    /* [in] */ DEXTER_VALUE *paValue);


void __RPC_STUB IPropertySetter_FreeProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertySetter_ClearProps_Proxy( 
    IPropertySetter * This);


void __RPC_STUB IPropertySetter_ClearProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertySetter_SaveToBlob_Proxy( 
    IPropertySetter * This,
    /* [out] */ LONG *pcSize,
    /* [out] */ BYTE **ppb);


void __RPC_STUB IPropertySetter_SaveToBlob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertySetter_LoadFromBlob_Proxy( 
    IPropertySetter * This,
    /* [in] */ LONG cSize,
    /* [in] */ BYTE *pb);


void __RPC_STUB IPropertySetter_LoadFromBlob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertySetter_SetProps_Proxy( 
    IPropertySetter * This,
    /* [in] */ IUnknown *pTarget,
    /* [in] */ REFERENCE_TIME rtNow);


void __RPC_STUB IPropertySetter_SetProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertySetter_PrintXMLW_Proxy( 
    IPropertySetter * This,
    /* [out] */ WCHAR *pszXML,
    /* [in] */ int cchXML,
    /* [out] */ int *pcchPrinted,
    /* [in] */ int indent);


void __RPC_STUB IPropertySetter_PrintXMLW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertySetter_INTERFACE_DEFINED__ */


#ifndef __IDxtCompositor_INTERFACE_DEFINED__
#define __IDxtCompositor_INTERFACE_DEFINED__

/* interface IDxtCompositor */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDxtCompositor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BB44391E-6ABD-422f-9E2E-385C9DFF51FC")
    IDxtCompositor : public IDXEffect
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OffsetX( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OffsetX( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OffsetY( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OffsetY( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Height( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Height( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SrcOffsetX( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SrcOffsetX( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SrcOffsetY( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SrcOffsetY( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SrcWidth( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SrcWidth( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SrcHeight( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SrcHeight( 
            /* [in] */ long newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDxtCompositorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDxtCompositor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDxtCompositor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDxtCompositor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDxtCompositor * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDxtCompositor * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDxtCompositor * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDxtCompositor * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDxtCompositor * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDxtCompositor * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDxtCompositor * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDxtCompositor * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDxtCompositor * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDxtCompositor * This,
            /* [in] */ float newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OffsetX )( 
            IDxtCompositor * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OffsetX )( 
            IDxtCompositor * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OffsetY )( 
            IDxtCompositor * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OffsetY )( 
            IDxtCompositor * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Width )( 
            IDxtCompositor * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Width )( 
            IDxtCompositor * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Height )( 
            IDxtCompositor * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Height )( 
            IDxtCompositor * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SrcOffsetX )( 
            IDxtCompositor * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SrcOffsetX )( 
            IDxtCompositor * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SrcOffsetY )( 
            IDxtCompositor * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SrcOffsetY )( 
            IDxtCompositor * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SrcWidth )( 
            IDxtCompositor * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SrcWidth )( 
            IDxtCompositor * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SrcHeight )( 
            IDxtCompositor * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SrcHeight )( 
            IDxtCompositor * This,
            /* [in] */ long newVal);
        
        END_INTERFACE
    } IDxtCompositorVtbl;

    interface IDxtCompositor
    {
        CONST_VTBL struct IDxtCompositorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDxtCompositor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDxtCompositor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDxtCompositor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDxtCompositor_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDxtCompositor_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDxtCompositor_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDxtCompositor_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDxtCompositor_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDxtCompositor_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDxtCompositor_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDxtCompositor_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDxtCompositor_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDxtCompositor_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDxtCompositor_get_OffsetX(This,pVal)	\
    (This)->lpVtbl -> get_OffsetX(This,pVal)

#define IDxtCompositor_put_OffsetX(This,newVal)	\
    (This)->lpVtbl -> put_OffsetX(This,newVal)

#define IDxtCompositor_get_OffsetY(This,pVal)	\
    (This)->lpVtbl -> get_OffsetY(This,pVal)

#define IDxtCompositor_put_OffsetY(This,newVal)	\
    (This)->lpVtbl -> put_OffsetY(This,newVal)

#define IDxtCompositor_get_Width(This,pVal)	\
    (This)->lpVtbl -> get_Width(This,pVal)

#define IDxtCompositor_put_Width(This,newVal)	\
    (This)->lpVtbl -> put_Width(This,newVal)

#define IDxtCompositor_get_Height(This,pVal)	\
    (This)->lpVtbl -> get_Height(This,pVal)

#define IDxtCompositor_put_Height(This,newVal)	\
    (This)->lpVtbl -> put_Height(This,newVal)

#define IDxtCompositor_get_SrcOffsetX(This,pVal)	\
    (This)->lpVtbl -> get_SrcOffsetX(This,pVal)

#define IDxtCompositor_put_SrcOffsetX(This,newVal)	\
    (This)->lpVtbl -> put_SrcOffsetX(This,newVal)

#define IDxtCompositor_get_SrcOffsetY(This,pVal)	\
    (This)->lpVtbl -> get_SrcOffsetY(This,pVal)

#define IDxtCompositor_put_SrcOffsetY(This,newVal)	\
    (This)->lpVtbl -> put_SrcOffsetY(This,newVal)

#define IDxtCompositor_get_SrcWidth(This,pVal)	\
    (This)->lpVtbl -> get_SrcWidth(This,pVal)

#define IDxtCompositor_put_SrcWidth(This,newVal)	\
    (This)->lpVtbl -> put_SrcWidth(This,newVal)

#define IDxtCompositor_get_SrcHeight(This,pVal)	\
    (This)->lpVtbl -> get_SrcHeight(This,pVal)

#define IDxtCompositor_put_SrcHeight(This,newVal)	\
    (This)->lpVtbl -> put_SrcHeight(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDxtCompositor_get_OffsetX_Proxy( 
    IDxtCompositor * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDxtCompositor_get_OffsetX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDxtCompositor_put_OffsetX_Proxy( 
    IDxtCompositor * This,
    /* [in] */ long newVal);


void __RPC_STUB IDxtCompositor_put_OffsetX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDxtCompositor_get_OffsetY_Proxy( 
    IDxtCompositor * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDxtCompositor_get_OffsetY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDxtCompositor_put_OffsetY_Proxy( 
    IDxtCompositor * This,
    /* [in] */ long newVal);


void __RPC_STUB IDxtCompositor_put_OffsetY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDxtCompositor_get_Width_Proxy( 
    IDxtCompositor * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDxtCompositor_get_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDxtCompositor_put_Width_Proxy( 
    IDxtCompositor * This,
    /* [in] */ long newVal);


void __RPC_STUB IDxtCompositor_put_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDxtCompositor_get_Height_Proxy( 
    IDxtCompositor * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDxtCompositor_get_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDxtCompositor_put_Height_Proxy( 
    IDxtCompositor * This,
    /* [in] */ long newVal);


void __RPC_STUB IDxtCompositor_put_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDxtCompositor_get_SrcOffsetX_Proxy( 
    IDxtCompositor * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDxtCompositor_get_SrcOffsetX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDxtCompositor_put_SrcOffsetX_Proxy( 
    IDxtCompositor * This,
    /* [in] */ long newVal);


void __RPC_STUB IDxtCompositor_put_SrcOffsetX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDxtCompositor_get_SrcOffsetY_Proxy( 
    IDxtCompositor * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDxtCompositor_get_SrcOffsetY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDxtCompositor_put_SrcOffsetY_Proxy( 
    IDxtCompositor * This,
    /* [in] */ long newVal);


void __RPC_STUB IDxtCompositor_put_SrcOffsetY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDxtCompositor_get_SrcWidth_Proxy( 
    IDxtCompositor * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDxtCompositor_get_SrcWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDxtCompositor_put_SrcWidth_Proxy( 
    IDxtCompositor * This,
    /* [in] */ long newVal);


void __RPC_STUB IDxtCompositor_put_SrcWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDxtCompositor_get_SrcHeight_Proxy( 
    IDxtCompositor * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDxtCompositor_get_SrcHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDxtCompositor_put_SrcHeight_Proxy( 
    IDxtCompositor * This,
    /* [in] */ long newVal);


void __RPC_STUB IDxtCompositor_put_SrcHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDxtCompositor_INTERFACE_DEFINED__ */


#ifndef __IDxtAlphaSetter_INTERFACE_DEFINED__
#define __IDxtAlphaSetter_INTERFACE_DEFINED__

/* interface IDxtAlphaSetter */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDxtAlphaSetter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4EE9EAD9-DA4D-43d0-9383-06B90C08B12B")
    IDxtAlphaSetter : public IDXEffect
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Alpha( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Alpha( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AlphaRamp( 
            /* [retval][out] */ double *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AlphaRamp( 
            /* [in] */ double newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDxtAlphaSetterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDxtAlphaSetter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDxtAlphaSetter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDxtAlphaSetter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDxtAlphaSetter * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDxtAlphaSetter * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDxtAlphaSetter * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDxtAlphaSetter * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDxtAlphaSetter * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDxtAlphaSetter * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDxtAlphaSetter * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDxtAlphaSetter * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDxtAlphaSetter * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDxtAlphaSetter * This,
            /* [in] */ float newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Alpha )( 
            IDxtAlphaSetter * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Alpha )( 
            IDxtAlphaSetter * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AlphaRamp )( 
            IDxtAlphaSetter * This,
            /* [retval][out] */ double *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AlphaRamp )( 
            IDxtAlphaSetter * This,
            /* [in] */ double newVal);
        
        END_INTERFACE
    } IDxtAlphaSetterVtbl;

    interface IDxtAlphaSetter
    {
        CONST_VTBL struct IDxtAlphaSetterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDxtAlphaSetter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDxtAlphaSetter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDxtAlphaSetter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDxtAlphaSetter_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDxtAlphaSetter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDxtAlphaSetter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDxtAlphaSetter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDxtAlphaSetter_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDxtAlphaSetter_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDxtAlphaSetter_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDxtAlphaSetter_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDxtAlphaSetter_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDxtAlphaSetter_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDxtAlphaSetter_get_Alpha(This,pVal)	\
    (This)->lpVtbl -> get_Alpha(This,pVal)

#define IDxtAlphaSetter_put_Alpha(This,newVal)	\
    (This)->lpVtbl -> put_Alpha(This,newVal)

#define IDxtAlphaSetter_get_AlphaRamp(This,pVal)	\
    (This)->lpVtbl -> get_AlphaRamp(This,pVal)

#define IDxtAlphaSetter_put_AlphaRamp(This,newVal)	\
    (This)->lpVtbl -> put_AlphaRamp(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDxtAlphaSetter_get_Alpha_Proxy( 
    IDxtAlphaSetter * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDxtAlphaSetter_get_Alpha_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDxtAlphaSetter_put_Alpha_Proxy( 
    IDxtAlphaSetter * This,
    /* [in] */ long newVal);


void __RPC_STUB IDxtAlphaSetter_put_Alpha_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDxtAlphaSetter_get_AlphaRamp_Proxy( 
    IDxtAlphaSetter * This,
    /* [retval][out] */ double *pVal);


void __RPC_STUB IDxtAlphaSetter_get_AlphaRamp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDxtAlphaSetter_put_AlphaRamp_Proxy( 
    IDxtAlphaSetter * This,
    /* [in] */ double newVal);


void __RPC_STUB IDxtAlphaSetter_put_AlphaRamp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDxtAlphaSetter_INTERFACE_DEFINED__ */


#ifndef __IDxtJpeg_INTERFACE_DEFINED__
#define __IDxtJpeg_INTERFACE_DEFINED__

/* interface IDxtJpeg */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDxtJpeg;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DE75D011-7A65-11D2-8CEA-00A0C9441E20")
    IDxtJpeg : public IDXEffect
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MaskNum( 
            /* [retval][out] */ long *__MIDL_0018) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MaskNum( 
            /* [in] */ long __MIDL_0019) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MaskName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MaskName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ScaleX( 
            /* [retval][out] */ double *__MIDL_0020) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ScaleX( 
            /* [in] */ double __MIDL_0021) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ScaleY( 
            /* [retval][out] */ double *__MIDL_0022) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ScaleY( 
            /* [in] */ double __MIDL_0023) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OffsetX( 
            /* [retval][out] */ long *__MIDL_0024) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OffsetX( 
            /* [in] */ long __MIDL_0025) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OffsetY( 
            /* [retval][out] */ long *__MIDL_0026) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OffsetY( 
            /* [in] */ long __MIDL_0027) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReplicateX( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ReplicateX( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReplicateY( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ReplicateY( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BorderColor( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BorderColor( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BorderWidth( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BorderWidth( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BorderSoftness( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BorderSoftness( 
            /* [in] */ long newVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyChanges( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadDefSettings( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDxtJpegVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDxtJpeg * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDxtJpeg * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDxtJpeg * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDxtJpeg * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDxtJpeg * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDxtJpeg * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDxtJpeg * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDxtJpeg * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDxtJpeg * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDxtJpeg * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDxtJpeg * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDxtJpeg * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDxtJpeg * This,
            /* [in] */ float newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaskNum )( 
            IDxtJpeg * This,
            /* [retval][out] */ long *__MIDL_0018);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaskNum )( 
            IDxtJpeg * This,
            /* [in] */ long __MIDL_0019);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaskName )( 
            IDxtJpeg * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaskName )( 
            IDxtJpeg * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ScaleX )( 
            IDxtJpeg * This,
            /* [retval][out] */ double *__MIDL_0020);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ScaleX )( 
            IDxtJpeg * This,
            /* [in] */ double __MIDL_0021);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ScaleY )( 
            IDxtJpeg * This,
            /* [retval][out] */ double *__MIDL_0022);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ScaleY )( 
            IDxtJpeg * This,
            /* [in] */ double __MIDL_0023);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OffsetX )( 
            IDxtJpeg * This,
            /* [retval][out] */ long *__MIDL_0024);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OffsetX )( 
            IDxtJpeg * This,
            /* [in] */ long __MIDL_0025);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OffsetY )( 
            IDxtJpeg * This,
            /* [retval][out] */ long *__MIDL_0026);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OffsetY )( 
            IDxtJpeg * This,
            /* [in] */ long __MIDL_0027);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReplicateX )( 
            IDxtJpeg * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReplicateX )( 
            IDxtJpeg * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReplicateY )( 
            IDxtJpeg * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReplicateY )( 
            IDxtJpeg * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BorderColor )( 
            IDxtJpeg * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BorderColor )( 
            IDxtJpeg * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BorderWidth )( 
            IDxtJpeg * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BorderWidth )( 
            IDxtJpeg * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BorderSoftness )( 
            IDxtJpeg * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BorderSoftness )( 
            IDxtJpeg * This,
            /* [in] */ long newVal);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyChanges )( 
            IDxtJpeg * This);
        
        HRESULT ( STDMETHODCALLTYPE *LoadDefSettings )( 
            IDxtJpeg * This);
        
        END_INTERFACE
    } IDxtJpegVtbl;

    interface IDxtJpeg
    {
        CONST_VTBL struct IDxtJpegVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDxtJpeg_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDxtJpeg_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDxtJpeg_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDxtJpeg_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDxtJpeg_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDxtJpeg_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDxtJpeg_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDxtJpeg_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDxtJpeg_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDxtJpeg_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDxtJpeg_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDxtJpeg_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDxtJpeg_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDxtJpeg_get_MaskNum(This,__MIDL_0018)	\
    (This)->lpVtbl -> get_MaskNum(This,__MIDL_0018)

#define IDxtJpeg_put_MaskNum(This,__MIDL_0019)	\
    (This)->lpVtbl -> put_MaskNum(This,__MIDL_0019)

#define IDxtJpeg_get_MaskName(This,pVal)	\
    (This)->lpVtbl -> get_MaskName(This,pVal)

#define IDxtJpeg_put_MaskName(This,newVal)	\
    (This)->lpVtbl -> put_MaskName(This,newVal)

#define IDxtJpeg_get_ScaleX(This,__MIDL_0020)	\
    (This)->lpVtbl -> get_ScaleX(This,__MIDL_0020)

#define IDxtJpeg_put_ScaleX(This,__MIDL_0021)	\
    (This)->lpVtbl -> put_ScaleX(This,__MIDL_0021)

#define IDxtJpeg_get_ScaleY(This,__MIDL_0022)	\
    (This)->lpVtbl -> get_ScaleY(This,__MIDL_0022)

#define IDxtJpeg_put_ScaleY(This,__MIDL_0023)	\
    (This)->lpVtbl -> put_ScaleY(This,__MIDL_0023)

#define IDxtJpeg_get_OffsetX(This,__MIDL_0024)	\
    (This)->lpVtbl -> get_OffsetX(This,__MIDL_0024)

#define IDxtJpeg_put_OffsetX(This,__MIDL_0025)	\
    (This)->lpVtbl -> put_OffsetX(This,__MIDL_0025)

#define IDxtJpeg_get_OffsetY(This,__MIDL_0026)	\
    (This)->lpVtbl -> get_OffsetY(This,__MIDL_0026)

#define IDxtJpeg_put_OffsetY(This,__MIDL_0027)	\
    (This)->lpVtbl -> put_OffsetY(This,__MIDL_0027)

#define IDxtJpeg_get_ReplicateX(This,pVal)	\
    (This)->lpVtbl -> get_ReplicateX(This,pVal)

#define IDxtJpeg_put_ReplicateX(This,newVal)	\
    (This)->lpVtbl -> put_ReplicateX(This,newVal)

#define IDxtJpeg_get_ReplicateY(This,pVal)	\
    (This)->lpVtbl -> get_ReplicateY(This,pVal)

#define IDxtJpeg_put_ReplicateY(This,newVal)	\
    (This)->lpVtbl -> put_ReplicateY(This,newVal)

#define IDxtJpeg_get_BorderColor(This,pVal)	\
    (This)->lpVtbl -> get_BorderColor(This,pVal)

#define IDxtJpeg_put_BorderColor(This,newVal)	\
    (This)->lpVtbl -> put_BorderColor(This,newVal)

#define IDxtJpeg_get_BorderWidth(This,pVal)	\
    (This)->lpVtbl -> get_BorderWidth(This,pVal)

#define IDxtJpeg_put_BorderWidth(This,newVal)	\
    (This)->lpVtbl -> put_BorderWidth(This,newVal)

#define IDxtJpeg_get_BorderSoftness(This,pVal)	\
    (This)->lpVtbl -> get_BorderSoftness(This,pVal)

#define IDxtJpeg_put_BorderSoftness(This,newVal)	\
    (This)->lpVtbl -> put_BorderSoftness(This,newVal)

#define IDxtJpeg_ApplyChanges(This)	\
    (This)->lpVtbl -> ApplyChanges(This)

#define IDxtJpeg_LoadDefSettings(This)	\
    (This)->lpVtbl -> LoadDefSettings(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDxtJpeg_get_MaskNum_Proxy( 
    IDxtJpeg * This,
    /* [retval][out] */ long *__MIDL_0018);


void __RPC_STUB IDxtJpeg_get_MaskNum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDxtJpeg_put_MaskNum_Proxy( 
    IDxtJpeg * This,
    /* [in] */ long __MIDL_0019);


void __RPC_STUB IDxtJpeg_put_MaskNum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDxtJpeg_get_MaskName_Proxy( 
    IDxtJpeg * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IDxtJpeg_get_MaskName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDxtJpeg_put_MaskName_Proxy( 
    IDxtJpeg * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDxtJpeg_put_MaskName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDxtJpeg_get_ScaleX_Proxy( 
    IDxtJpeg * This,
    /* [retval][out] */ double *__MIDL_0020);


void __RPC_STUB IDxtJpeg_get_ScaleX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDxtJpeg_put_ScaleX_Proxy( 
    IDxtJpeg * This,
    /* [in] */ double __MIDL_0021);


void __RPC_STUB IDxtJpeg_put_ScaleX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDxtJpeg_get_ScaleY_Proxy( 
    IDxtJpeg * This,
    /* [retval][out] */ double *__MIDL_0022);


void __RPC_STUB IDxtJpeg_get_ScaleY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDxtJpeg_put_ScaleY_Proxy( 
    IDxtJpeg * This,
    /* [in] */ double __MIDL_0023);


void __RPC_STUB IDxtJpeg_put_ScaleY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDxtJpeg_get_OffsetX_Proxy( 
    IDxtJpeg * This,
    /* [retval][out] */ long *__MIDL_0024);


void __RPC_STUB IDxtJpeg_get_OffsetX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDxtJpeg_put_OffsetX_Proxy( 
    IDxtJpeg * This,
    /* [in] */ long __MIDL_0025);


void __RPC_STUB IDxtJpeg_put_OffsetX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDxtJpeg_get_OffsetY_Proxy( 
    IDxtJpeg * This,
    /* [retval][out] */ long *__MIDL_0026);


void __RPC_STUB IDxtJpeg_get_OffsetY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDxtJpeg_put_OffsetY_Proxy( 
    IDxtJpeg * This,
    /* [in] */ long __MIDL_0027);


void __RPC_STUB IDxtJpeg_put_OffsetY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDxtJpeg_get_ReplicateX_Proxy( 
    IDxtJpeg * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDxtJpeg_get_ReplicateX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDxtJpeg_put_ReplicateX_Proxy( 
    IDxtJpeg * This,
    /* [in] */ long newVal);


void __RPC_STUB IDxtJpeg_put_ReplicateX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDxtJpeg_get_ReplicateY_Proxy( 
    IDxtJpeg * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDxtJpeg_get_ReplicateY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDxtJpeg_put_ReplicateY_Proxy( 
    IDxtJpeg * This,
    /* [in] */ long newVal);


void __RPC_STUB IDxtJpeg_put_ReplicateY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDxtJpeg_get_BorderColor_Proxy( 
    IDxtJpeg * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDxtJpeg_get_BorderColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDxtJpeg_put_BorderColor_Proxy( 
    IDxtJpeg * This,
    /* [in] */ long newVal);


void __RPC_STUB IDxtJpeg_put_BorderColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDxtJpeg_get_BorderWidth_Proxy( 
    IDxtJpeg * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDxtJpeg_get_BorderWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDxtJpeg_put_BorderWidth_Proxy( 
    IDxtJpeg * This,
    /* [in] */ long newVal);


void __RPC_STUB IDxtJpeg_put_BorderWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDxtJpeg_get_BorderSoftness_Proxy( 
    IDxtJpeg * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDxtJpeg_get_BorderSoftness_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDxtJpeg_put_BorderSoftness_Proxy( 
    IDxtJpeg * This,
    /* [in] */ long newVal);


void __RPC_STUB IDxtJpeg_put_BorderSoftness_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDxtJpeg_ApplyChanges_Proxy( 
    IDxtJpeg * This);


void __RPC_STUB IDxtJpeg_ApplyChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDxtJpeg_LoadDefSettings_Proxy( 
    IDxtJpeg * This);


void __RPC_STUB IDxtJpeg_LoadDefSettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDxtJpeg_INTERFACE_DEFINED__ */


#ifndef __IDxtKey_INTERFACE_DEFINED__
#define __IDxtKey_INTERFACE_DEFINED__

/* interface IDxtKey */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDxtKey;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3255de56-38fb-4901-b980-94b438010d7b")
    IDxtKey : public IDXEffect
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_KeyType( 
            /* [retval][out] */ int *__MIDL_0028) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_KeyType( 
            /* [in] */ int __MIDL_0029) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Hue( 
            /* [retval][out] */ int *__MIDL_0030) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Hue( 
            /* [in] */ int __MIDL_0031) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Luminance( 
            /* [retval][out] */ int *__MIDL_0032) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Luminance( 
            /* [in] */ int __MIDL_0033) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RGB( 
            /* [retval][out] */ DWORD *__MIDL_0034) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RGB( 
            /* [in] */ DWORD __MIDL_0035) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Similarity( 
            /* [retval][out] */ int *__MIDL_0036) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Similarity( 
            /* [in] */ int __MIDL_0037) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Invert( 
            /* [retval][out] */ BOOL *__MIDL_0038) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Invert( 
            /* [in] */ BOOL __MIDL_0039) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDxtKeyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDxtKey * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDxtKey * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDxtKey * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDxtKey * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDxtKey * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDxtKey * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDxtKey * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDxtKey * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDxtKey * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDxtKey * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDxtKey * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDxtKey * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDxtKey * This,
            /* [in] */ float newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeyType )( 
            IDxtKey * This,
            /* [retval][out] */ int *__MIDL_0028);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeyType )( 
            IDxtKey * This,
            /* [in] */ int __MIDL_0029);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Hue )( 
            IDxtKey * This,
            /* [retval][out] */ int *__MIDL_0030);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Hue )( 
            IDxtKey * This,
            /* [in] */ int __MIDL_0031);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Luminance )( 
            IDxtKey * This,
            /* [retval][out] */ int *__MIDL_0032);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Luminance )( 
            IDxtKey * This,
            /* [in] */ int __MIDL_0033);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RGB )( 
            IDxtKey * This,
            /* [retval][out] */ DWORD *__MIDL_0034);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RGB )( 
            IDxtKey * This,
            /* [in] */ DWORD __MIDL_0035);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Similarity )( 
            IDxtKey * This,
            /* [retval][out] */ int *__MIDL_0036);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Similarity )( 
            IDxtKey * This,
            /* [in] */ int __MIDL_0037);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Invert )( 
            IDxtKey * This,
            /* [retval][out] */ BOOL *__MIDL_0038);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Invert )( 
            IDxtKey * This,
            /* [in] */ BOOL __MIDL_0039);
        
        END_INTERFACE
    } IDxtKeyVtbl;

    interface IDxtKey
    {
        CONST_VTBL struct IDxtKeyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDxtKey_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDxtKey_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDxtKey_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDxtKey_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDxtKey_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDxtKey_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDxtKey_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDxtKey_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDxtKey_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDxtKey_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDxtKey_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDxtKey_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDxtKey_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDxtKey_get_KeyType(This,__MIDL_0028)	\
    (This)->lpVtbl -> get_KeyType(This,__MIDL_0028)

#define IDxtKey_put_KeyType(This,__MIDL_0029)	\
    (This)->lpVtbl -> put_KeyType(This,__MIDL_0029)

#define IDxtKey_get_Hue(This,__MIDL_0030)	\
    (This)->lpVtbl -> get_Hue(This,__MIDL_0030)

#define IDxtKey_put_Hue(This,__MIDL_0031)	\
    (This)->lpVtbl -> put_Hue(This,__MIDL_0031)

#define IDxtKey_get_Luminance(This,__MIDL_0032)	\
    (This)->lpVtbl -> get_Luminance(This,__MIDL_0032)

#define IDxtKey_put_Luminance(This,__MIDL_0033)	\
    (This)->lpVtbl -> put_Luminance(This,__MIDL_0033)

#define IDxtKey_get_RGB(This,__MIDL_0034)	\
    (This)->lpVtbl -> get_RGB(This,__MIDL_0034)

#define IDxtKey_put_RGB(This,__MIDL_0035)	\
    (This)->lpVtbl -> put_RGB(This,__MIDL_0035)

#define IDxtKey_get_Similarity(This,__MIDL_0036)	\
    (This)->lpVtbl -> get_Similarity(This,__MIDL_0036)

#define IDxtKey_put_Similarity(This,__MIDL_0037)	\
    (This)->lpVtbl -> put_Similarity(This,__MIDL_0037)

#define IDxtKey_get_Invert(This,__MIDL_0038)	\
    (This)->lpVtbl -> get_Invert(This,__MIDL_0038)

#define IDxtKey_put_Invert(This,__MIDL_0039)	\
    (This)->lpVtbl -> put_Invert(This,__MIDL_0039)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDxtKey_get_KeyType_Proxy( 
    IDxtKey * This,
    /* [retval][out] */ int *__MIDL_0028);


void __RPC_STUB IDxtKey_get_KeyType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDxtKey_put_KeyType_Proxy( 
    IDxtKey * This,
    /* [in] */ int __MIDL_0029);


void __RPC_STUB IDxtKey_put_KeyType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDxtKey_get_Hue_Proxy( 
    IDxtKey * This,
    /* [retval][out] */ int *__MIDL_0030);


void __RPC_STUB IDxtKey_get_Hue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDxtKey_put_Hue_Proxy( 
    IDxtKey * This,
    /* [in] */ int __MIDL_0031);


void __RPC_STUB IDxtKey_put_Hue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDxtKey_get_Luminance_Proxy( 
    IDxtKey * This,
    /* [retval][out] */ int *__MIDL_0032);


void __RPC_STUB IDxtKey_get_Luminance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDxtKey_put_Luminance_Proxy( 
    IDxtKey * This,
    /* [in] */ int __MIDL_0033);


void __RPC_STUB IDxtKey_put_Luminance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDxtKey_get_RGB_Proxy( 
    IDxtKey * This,
    /* [retval][out] */ DWORD *__MIDL_0034);


void __RPC_STUB IDxtKey_get_RGB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDxtKey_put_RGB_Proxy( 
    IDxtKey * This,
    /* [in] */ DWORD __MIDL_0035);


void __RPC_STUB IDxtKey_put_RGB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDxtKey_get_Similarity_Proxy( 
    IDxtKey * This,
    /* [retval][out] */ int *__MIDL_0036);


void __RPC_STUB IDxtKey_get_Similarity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDxtKey_put_Similarity_Proxy( 
    IDxtKey * This,
    /* [in] */ int __MIDL_0037);


void __RPC_STUB IDxtKey_put_Similarity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDxtKey_get_Invert_Proxy( 
    IDxtKey * This,
    /* [retval][out] */ BOOL *__MIDL_0038);


void __RPC_STUB IDxtKey_get_Invert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDxtKey_put_Invert_Proxy( 
    IDxtKey * This,
    /* [in] */ BOOL __MIDL_0039);


void __RPC_STUB IDxtKey_put_Invert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDxtKey_INTERFACE_DEFINED__ */


#ifndef __IMediaLocator_INTERFACE_DEFINED__
#define __IMediaLocator_INTERFACE_DEFINED__

/* interface IMediaLocator */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IMediaLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("288581E0-66CE-11d2-918F-00C0DF10D434")
    IMediaLocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindMediaFile( 
            BSTR Input,
            BSTR FilterString,
            BSTR *pOutput,
            long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddFoundLocation( 
            BSTR DirectoryName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaLocator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaLocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaLocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *FindMediaFile )( 
            IMediaLocator * This,
            BSTR Input,
            BSTR FilterString,
            BSTR *pOutput,
            long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *AddFoundLocation )( 
            IMediaLocator * This,
            BSTR DirectoryName);
        
        END_INTERFACE
    } IMediaLocatorVtbl;

    interface IMediaLocator
    {
        CONST_VTBL struct IMediaLocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaLocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMediaLocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMediaLocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMediaLocator_FindMediaFile(This,Input,FilterString,pOutput,Flags)	\
    (This)->lpVtbl -> FindMediaFile(This,Input,FilterString,pOutput,Flags)

#define IMediaLocator_AddFoundLocation(This,DirectoryName)	\
    (This)->lpVtbl -> AddFoundLocation(This,DirectoryName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMediaLocator_FindMediaFile_Proxy( 
    IMediaLocator * This,
    BSTR Input,
    BSTR FilterString,
    BSTR *pOutput,
    long Flags);


void __RPC_STUB IMediaLocator_FindMediaFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaLocator_AddFoundLocation_Proxy( 
    IMediaLocator * This,
    BSTR DirectoryName);


void __RPC_STUB IMediaLocator_AddFoundLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMediaLocator_INTERFACE_DEFINED__ */


#ifndef __IMediaDet_INTERFACE_DEFINED__
#define __IMediaDet_INTERFACE_DEFINED__

/* interface IMediaDet */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IMediaDet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("65BD0710-24D2-4ff7-9324-ED2E5D3ABAFA")
    IMediaDet : public IUnknown
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Filter( 
            /* [retval][out] */ IUnknown **pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Filter( 
            /* [in] */ IUnknown *newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutputStreams( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentStream( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CurrentStream( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamType( 
            /* [retval][out] */ GUID *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamTypeB( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamLength( 
            /* [retval][out] */ double *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Filename( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Filename( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetBitmapBits( 
            double StreamTime,
            long *pBufferSize,
            char *pBuffer,
            long Width,
            long Height) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE WriteBitmapBits( 
            double StreamTime,
            long Width,
            long Height,
            BSTR Filename) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamMediaType( 
            /* [retval][out] */ AM_MEDIA_TYPE *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSampleGrabber( 
            /* [out] */ ISampleGrabber **ppVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FrameRate( 
            /* [retval][out] */ double *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnterBitmapGrabMode( 
            double SeekTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaDetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaDet * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaDet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaDet * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Filter )( 
            IMediaDet * This,
            /* [retval][out] */ IUnknown **pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Filter )( 
            IMediaDet * This,
            /* [in] */ IUnknown *newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutputStreams )( 
            IMediaDet * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentStream )( 
            IMediaDet * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentStream )( 
            IMediaDet * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamType )( 
            IMediaDet * This,
            /* [retval][out] */ GUID *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamTypeB )( 
            IMediaDet * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamLength )( 
            IMediaDet * This,
            /* [retval][out] */ double *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Filename )( 
            IMediaDet * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Filename )( 
            IMediaDet * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetBitmapBits )( 
            IMediaDet * This,
            double StreamTime,
            long *pBufferSize,
            char *pBuffer,
            long Width,
            long Height);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *WriteBitmapBits )( 
            IMediaDet * This,
            double StreamTime,
            long Width,
            long Height,
            BSTR Filename);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamMediaType )( 
            IMediaDet * This,
            /* [retval][out] */ AM_MEDIA_TYPE *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSampleGrabber )( 
            IMediaDet * This,
            /* [out] */ ISampleGrabber **ppVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FrameRate )( 
            IMediaDet * This,
            /* [retval][out] */ double *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnterBitmapGrabMode )( 
            IMediaDet * This,
            double SeekTime);
        
        END_INTERFACE
    } IMediaDetVtbl;

    interface IMediaDet
    {
        CONST_VTBL struct IMediaDetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaDet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMediaDet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMediaDet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMediaDet_get_Filter(This,pVal)	\
    (This)->lpVtbl -> get_Filter(This,pVal)

#define IMediaDet_put_Filter(This,newVal)	\
    (This)->lpVtbl -> put_Filter(This,newVal)

#define IMediaDet_get_OutputStreams(This,pVal)	\
    (This)->lpVtbl -> get_OutputStreams(This,pVal)

#define IMediaDet_get_CurrentStream(This,pVal)	\
    (This)->lpVtbl -> get_CurrentStream(This,pVal)

#define IMediaDet_put_CurrentStream(This,newVal)	\
    (This)->lpVtbl -> put_CurrentStream(This,newVal)

#define IMediaDet_get_StreamType(This,pVal)	\
    (This)->lpVtbl -> get_StreamType(This,pVal)

#define IMediaDet_get_StreamTypeB(This,pVal)	\
    (This)->lpVtbl -> get_StreamTypeB(This,pVal)

#define IMediaDet_get_StreamLength(This,pVal)	\
    (This)->lpVtbl -> get_StreamLength(This,pVal)

#define IMediaDet_get_Filename(This,pVal)	\
    (This)->lpVtbl -> get_Filename(This,pVal)

#define IMediaDet_put_Filename(This,newVal)	\
    (This)->lpVtbl -> put_Filename(This,newVal)

#define IMediaDet_GetBitmapBits(This,StreamTime,pBufferSize,pBuffer,Width,Height)	\
    (This)->lpVtbl -> GetBitmapBits(This,StreamTime,pBufferSize,pBuffer,Width,Height)

#define IMediaDet_WriteBitmapBits(This,StreamTime,Width,Height,Filename)	\
    (This)->lpVtbl -> WriteBitmapBits(This,StreamTime,Width,Height,Filename)

#define IMediaDet_get_StreamMediaType(This,pVal)	\
    (This)->lpVtbl -> get_StreamMediaType(This,pVal)

#define IMediaDet_GetSampleGrabber(This,ppVal)	\
    (This)->lpVtbl -> GetSampleGrabber(This,ppVal)

#define IMediaDet_get_FrameRate(This,pVal)	\
    (This)->lpVtbl -> get_FrameRate(This,pVal)

#define IMediaDet_EnterBitmapGrabMode(This,SeekTime)	\
    (This)->lpVtbl -> EnterBitmapGrabMode(This,SeekTime)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMediaDet_get_Filter_Proxy( 
    IMediaDet * This,
    /* [retval][out] */ IUnknown **pVal);


void __RPC_STUB IMediaDet_get_Filter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMediaDet_put_Filter_Proxy( 
    IMediaDet * This,
    /* [in] */ IUnknown *newVal);


void __RPC_STUB IMediaDet_put_Filter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMediaDet_get_OutputStreams_Proxy( 
    IMediaDet * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IMediaDet_get_OutputStreams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMediaDet_get_CurrentStream_Proxy( 
    IMediaDet * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IMediaDet_get_CurrentStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMediaDet_put_CurrentStream_Proxy( 
    IMediaDet * This,
    /* [in] */ long newVal);


void __RPC_STUB IMediaDet_put_CurrentStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMediaDet_get_StreamType_Proxy( 
    IMediaDet * This,
    /* [retval][out] */ GUID *pVal);


void __RPC_STUB IMediaDet_get_StreamType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMediaDet_get_StreamTypeB_Proxy( 
    IMediaDet * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IMediaDet_get_StreamTypeB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMediaDet_get_StreamLength_Proxy( 
    IMediaDet * This,
    /* [retval][out] */ double *pVal);


void __RPC_STUB IMediaDet_get_StreamLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMediaDet_get_Filename_Proxy( 
    IMediaDet * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IMediaDet_get_Filename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMediaDet_put_Filename_Proxy( 
    IMediaDet * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMediaDet_put_Filename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaDet_GetBitmapBits_Proxy( 
    IMediaDet * This,
    double StreamTime,
    long *pBufferSize,
    char *pBuffer,
    long Width,
    long Height);


void __RPC_STUB IMediaDet_GetBitmapBits_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaDet_WriteBitmapBits_Proxy( 
    IMediaDet * This,
    double StreamTime,
    long Width,
    long Height,
    BSTR Filename);


void __RPC_STUB IMediaDet_WriteBitmapBits_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMediaDet_get_StreamMediaType_Proxy( 
    IMediaDet * This,
    /* [retval][out] */ AM_MEDIA_TYPE *pVal);


void __RPC_STUB IMediaDet_get_StreamMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaDet_GetSampleGrabber_Proxy( 
    IMediaDet * This,
    /* [out] */ ISampleGrabber **ppVal);


void __RPC_STUB IMediaDet_GetSampleGrabber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMediaDet_get_FrameRate_Proxy( 
    IMediaDet * This,
    /* [retval][out] */ double *pVal);


void __RPC_STUB IMediaDet_get_FrameRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaDet_EnterBitmapGrabMode_Proxy( 
    IMediaDet * This,
    double SeekTime);


void __RPC_STUB IMediaDet_EnterBitmapGrabMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMediaDet_INTERFACE_DEFINED__ */


#ifndef __IGrfCache_INTERFACE_DEFINED__
#define __IGrfCache_INTERFACE_DEFINED__

/* interface IGrfCache */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IGrfCache;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AE9472BE-B0C3-11D2-8D24-00A0C9441E20")
    IGrfCache : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddFilter( 
            IGrfCache *ChainedCache,
            LONGLONG ID,
            const IBaseFilter *pFilter,
            LPCWSTR pName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ConnectPins( 
            IGrfCache *ChainedCache,
            LONGLONG PinID1,
            const IPin *pPin1,
            LONGLONG PinID2,
            const IPin *pPin2) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetGraph( 
            const IGraphBuilder *pGraph) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DoConnectionsNow( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGrfCacheVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGrfCache * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGrfCache * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGrfCache * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGrfCache * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGrfCache * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGrfCache * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGrfCache * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddFilter )( 
            IGrfCache * This,
            IGrfCache *ChainedCache,
            LONGLONG ID,
            const IBaseFilter *pFilter,
            LPCWSTR pName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ConnectPins )( 
            IGrfCache * This,
            IGrfCache *ChainedCache,
            LONGLONG PinID1,
            const IPin *pPin1,
            LONGLONG PinID2,
            const IPin *pPin2);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetGraph )( 
            IGrfCache * This,
            const IGraphBuilder *pGraph);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DoConnectionsNow )( 
            IGrfCache * This);
        
        END_INTERFACE
    } IGrfCacheVtbl;

    interface IGrfCache
    {
        CONST_VTBL struct IGrfCacheVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGrfCache_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGrfCache_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGrfCache_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGrfCache_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGrfCache_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGrfCache_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGrfCache_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGrfCache_AddFilter(This,ChainedCache,ID,pFilter,pName)	\
    (This)->lpVtbl -> AddFilter(This,ChainedCache,ID,pFilter,pName)

#define IGrfCache_ConnectPins(This,ChainedCache,PinID1,pPin1,PinID2,pPin2)	\
    (This)->lpVtbl -> ConnectPins(This,ChainedCache,PinID1,pPin1,PinID2,pPin2)

#define IGrfCache_SetGraph(This,pGraph)	\
    (This)->lpVtbl -> SetGraph(This,pGraph)

#define IGrfCache_DoConnectionsNow(This)	\
    (This)->lpVtbl -> DoConnectionsNow(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGrfCache_AddFilter_Proxy( 
    IGrfCache * This,
    IGrfCache *ChainedCache,
    LONGLONG ID,
    const IBaseFilter *pFilter,
    LPCWSTR pName);


void __RPC_STUB IGrfCache_AddFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGrfCache_ConnectPins_Proxy( 
    IGrfCache * This,
    IGrfCache *ChainedCache,
    LONGLONG PinID1,
    const IPin *pPin1,
    LONGLONG PinID2,
    const IPin *pPin2);


void __RPC_STUB IGrfCache_ConnectPins_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGrfCache_SetGraph_Proxy( 
    IGrfCache * This,
    const IGraphBuilder *pGraph);


void __RPC_STUB IGrfCache_SetGraph_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGrfCache_DoConnectionsNow_Proxy( 
    IGrfCache * This);


void __RPC_STUB IGrfCache_DoConnectionsNow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGrfCache_INTERFACE_DEFINED__ */


#ifndef __IRenderEngine_INTERFACE_DEFINED__
#define __IRenderEngine_INTERFACE_DEFINED__

/* interface IRenderEngine */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRenderEngine;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6BEE3A81-66C9-11d2-918F-00C0DF10D434")
    IRenderEngine : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetTimelineObject( 
            IAMTimeline *pTimeline) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimelineObject( 
            /* [out] */ IAMTimeline **ppTimeline) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilterGraph( 
            /* [out] */ IGraphBuilder **ppFG) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFilterGraph( 
            IGraphBuilder *pFG) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInterestRange( 
            REFERENCE_TIME Start,
            REFERENCE_TIME Stop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInterestRange2( 
            double Start,
            double Stop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRenderRange( 
            REFERENCE_TIME Start,
            REFERENCE_TIME Stop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRenderRange2( 
            double Start,
            double Stop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroupOutputPin( 
            long Group,
            /* [out] */ IPin **ppRenderPin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ScrapIt( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenderOutputPins( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVendorString( 
            /* [retval][out] */ BSTR *pVendorID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectFrontEnd( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSourceConnectCallback( 
            IGrfCache *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDynamicReconnectLevel( 
            long Level) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoSmartRecompression( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UseInSmartRecompressionGraph( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSourceNameValidation( 
            BSTR FilterString,
            IMediaLocator *pOverride,
            LONG Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Decommit( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCaps( 
            long Index,
            long *pReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRenderEngineVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRenderEngine * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRenderEngine * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRenderEngine * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimelineObject )( 
            IRenderEngine * This,
            IAMTimeline *pTimeline);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimelineObject )( 
            IRenderEngine * This,
            /* [out] */ IAMTimeline **ppTimeline);
        
        HRESULT ( STDMETHODCALLTYPE *GetFilterGraph )( 
            IRenderEngine * This,
            /* [out] */ IGraphBuilder **ppFG);
        
        HRESULT ( STDMETHODCALLTYPE *SetFilterGraph )( 
            IRenderEngine * This,
            IGraphBuilder *pFG);
        
        HRESULT ( STDMETHODCALLTYPE *SetInterestRange )( 
            IRenderEngine * This,
            REFERENCE_TIME Start,
            REFERENCE_TIME Stop);
        
        HRESULT ( STDMETHODCALLTYPE *SetInterestRange2 )( 
            IRenderEngine * This,
            double Start,
            double Stop);
        
        HRESULT ( STDMETHODCALLTYPE *SetRenderRange )( 
            IRenderEngine * This,
            REFERENCE_TIME Start,
            REFERENCE_TIME Stop);
        
        HRESULT ( STDMETHODCALLTYPE *SetRenderRange2 )( 
            IRenderEngine * This,
            double Start,
            double Stop);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupOutputPin )( 
            IRenderEngine * This,
            long Group,
            /* [out] */ IPin **ppRenderPin);
        
        HRESULT ( STDMETHODCALLTYPE *ScrapIt )( 
            IRenderEngine * This);
        
        HRESULT ( STDMETHODCALLTYPE *RenderOutputPins )( 
            IRenderEngine * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVendorString )( 
            IRenderEngine * This,
            /* [retval][out] */ BSTR *pVendorID);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectFrontEnd )( 
            IRenderEngine * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSourceConnectCallback )( 
            IRenderEngine * This,
            IGrfCache *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE *SetDynamicReconnectLevel )( 
            IRenderEngine * This,
            long Level);
        
        HRESULT ( STDMETHODCALLTYPE *DoSmartRecompression )( 
            IRenderEngine * This);
        
        HRESULT ( STDMETHODCALLTYPE *UseInSmartRecompressionGraph )( 
            IRenderEngine * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSourceNameValidation )( 
            IRenderEngine * This,
            BSTR FilterString,
            IMediaLocator *pOverride,
            LONG Flags);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IRenderEngine * This);
        
        HRESULT ( STDMETHODCALLTYPE *Decommit )( 
            IRenderEngine * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCaps )( 
            IRenderEngine * This,
            long Index,
            long *pReturn);
        
        END_INTERFACE
    } IRenderEngineVtbl;

    interface IRenderEngine
    {
        CONST_VTBL struct IRenderEngineVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRenderEngine_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRenderEngine_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRenderEngine_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRenderEngine_SetTimelineObject(This,pTimeline)	\
    (This)->lpVtbl -> SetTimelineObject(This,pTimeline)

#define IRenderEngine_GetTimelineObject(This,ppTimeline)	\
    (This)->lpVtbl -> GetTimelineObject(This,ppTimeline)

#define IRenderEngine_GetFilterGraph(This,ppFG)	\
    (This)->lpVtbl -> GetFilterGraph(This,ppFG)

#define IRenderEngine_SetFilterGraph(This,pFG)	\
    (This)->lpVtbl -> SetFilterGraph(This,pFG)

#define IRenderEngine_SetInterestRange(This,Start,Stop)	\
    (This)->lpVtbl -> SetInterestRange(This,Start,Stop)

#define IRenderEngine_SetInterestRange2(This,Start,Stop)	\
    (This)->lpVtbl -> SetInterestRange2(This,Start,Stop)

#define IRenderEngine_SetRenderRange(This,Start,Stop)	\
    (This)->lpVtbl -> SetRenderRange(This,Start,Stop)

#define IRenderEngine_SetRenderRange2(This,Start,Stop)	\
    (This)->lpVtbl -> SetRenderRange2(This,Start,Stop)

#define IRenderEngine_GetGroupOutputPin(This,Group,ppRenderPin)	\
    (This)->lpVtbl -> GetGroupOutputPin(This,Group,ppRenderPin)

#define IRenderEngine_ScrapIt(This)	\
    (This)->lpVtbl -> ScrapIt(This)

#define IRenderEngine_RenderOutputPins(This)	\
    (This)->lpVtbl -> RenderOutputPins(This)

#define IRenderEngine_GetVendorString(This,pVendorID)	\
    (This)->lpVtbl -> GetVendorString(This,pVendorID)

#define IRenderEngine_ConnectFrontEnd(This)	\
    (This)->lpVtbl -> ConnectFrontEnd(This)

#define IRenderEngine_SetSourceConnectCallback(This,pCallback)	\
    (This)->lpVtbl -> SetSourceConnectCallback(This,pCallback)

#define IRenderEngine_SetDynamicReconnectLevel(This,Level)	\
    (This)->lpVtbl -> SetDynamicReconnectLevel(This,Level)

#define IRenderEngine_DoSmartRecompression(This)	\
    (This)->lpVtbl -> DoSmartRecompression(This)

#define IRenderEngine_UseInSmartRecompressionGraph(This)	\
    (This)->lpVtbl -> UseInSmartRecompressionGraph(This)

#define IRenderEngine_SetSourceNameValidation(This,FilterString,pOverride,Flags)	\
    (This)->lpVtbl -> SetSourceNameValidation(This,FilterString,pOverride,Flags)

#define IRenderEngine_Commit(This)	\
    (This)->lpVtbl -> Commit(This)

#define IRenderEngine_Decommit(This)	\
    (This)->lpVtbl -> Decommit(This)

#define IRenderEngine_GetCaps(This,Index,pReturn)	\
    (This)->lpVtbl -> GetCaps(This,Index,pReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRenderEngine_SetTimelineObject_Proxy( 
    IRenderEngine * This,
    IAMTimeline *pTimeline);


void __RPC_STUB IRenderEngine_SetTimelineObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRenderEngine_GetTimelineObject_Proxy( 
    IRenderEngine * This,
    /* [out] */ IAMTimeline **ppTimeline);


void __RPC_STUB IRenderEngine_GetTimelineObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRenderEngine_GetFilterGraph_Proxy( 
    IRenderEngine * This,
    /* [out] */ IGraphBuilder **ppFG);


void __RPC_STUB IRenderEngine_GetFilterGraph_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRenderEngine_SetFilterGraph_Proxy( 
    IRenderEngine * This,
    IGraphBuilder *pFG);


void __RPC_STUB IRenderEngine_SetFilterGraph_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRenderEngine_SetInterestRange_Proxy( 
    IRenderEngine * This,
    REFERENCE_TIME Start,
    REFERENCE_TIME Stop);


void __RPC_STUB IRenderEngine_SetInterestRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRenderEngine_SetInterestRange2_Proxy( 
    IRenderEngine * This,
    double Start,
    double Stop);


void __RPC_STUB IRenderEngine_SetInterestRange2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRenderEngine_SetRenderRange_Proxy( 
    IRenderEngine * This,
    REFERENCE_TIME Start,
    REFERENCE_TIME Stop);


void __RPC_STUB IRenderEngine_SetRenderRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRenderEngine_SetRenderRange2_Proxy( 
    IRenderEngine * This,
    double Start,
    double Stop);


void __RPC_STUB IRenderEngine_SetRenderRange2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRenderEngine_GetGroupOutputPin_Proxy( 
    IRenderEngine * This,
    long Group,
    /* [out] */ IPin **ppRenderPin);


void __RPC_STUB IRenderEngine_GetGroupOutputPin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRenderEngine_ScrapIt_Proxy( 
    IRenderEngine * This);


void __RPC_STUB IRenderEngine_ScrapIt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRenderEngine_RenderOutputPins_Proxy( 
    IRenderEngine * This);


void __RPC_STUB IRenderEngine_RenderOutputPins_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRenderEngine_GetVendorString_Proxy( 
    IRenderEngine * This,
    /* [retval][out] */ BSTR *pVendorID);


void __RPC_STUB IRenderEngine_GetVendorString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRenderEngine_ConnectFrontEnd_Proxy( 
    IRenderEngine * This);


void __RPC_STUB IRenderEngine_ConnectFrontEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRenderEngine_SetSourceConnectCallback_Proxy( 
    IRenderEngine * This,
    IGrfCache *pCallback);


void __RPC_STUB IRenderEngine_SetSourceConnectCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRenderEngine_SetDynamicReconnectLevel_Proxy( 
    IRenderEngine * This,
    long Level);


void __RPC_STUB IRenderEngine_SetDynamicReconnectLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRenderEngine_DoSmartRecompression_Proxy( 
    IRenderEngine * This);


void __RPC_STUB IRenderEngine_DoSmartRecompression_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRenderEngine_UseInSmartRecompressionGraph_Proxy( 
    IRenderEngine * This);


void __RPC_STUB IRenderEngine_UseInSmartRecompressionGraph_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRenderEngine_SetSourceNameValidation_Proxy( 
    IRenderEngine * This,
    BSTR FilterString,
    IMediaLocator *pOverride,
    LONG Flags);


void __RPC_STUB IRenderEngine_SetSourceNameValidation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRenderEngine_Commit_Proxy( 
    IRenderEngine * This);


void __RPC_STUB IRenderEngine_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRenderEngine_Decommit_Proxy( 
    IRenderEngine * This);


void __RPC_STUB IRenderEngine_Decommit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRenderEngine_GetCaps_Proxy( 
    IRenderEngine * This,
    long Index,
    long *pReturn);


void __RPC_STUB IRenderEngine_GetCaps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRenderEngine_INTERFACE_DEFINED__ */


#ifndef __IFindCompressorCB_INTERFACE_DEFINED__
#define __IFindCompressorCB_INTERFACE_DEFINED__

/* interface IFindCompressorCB */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IFindCompressorCB;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F03FA8DE-879A-4d59-9B2C-26BB1CF83461")
    IFindCompressorCB : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCompressor( 
            AM_MEDIA_TYPE *pType,
            AM_MEDIA_TYPE *pCompType,
            /* [out] */ IBaseFilter **ppFilter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFindCompressorCBVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFindCompressorCB * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFindCompressorCB * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFindCompressorCB * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompressor )( 
            IFindCompressorCB * This,
            AM_MEDIA_TYPE *pType,
            AM_MEDIA_TYPE *pCompType,
            /* [out] */ IBaseFilter **ppFilter);
        
        END_INTERFACE
    } IFindCompressorCBVtbl;

    interface IFindCompressorCB
    {
        CONST_VTBL struct IFindCompressorCBVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFindCompressorCB_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFindCompressorCB_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFindCompressorCB_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFindCompressorCB_GetCompressor(This,pType,pCompType,ppFilter)	\
    (This)->lpVtbl -> GetCompressor(This,pType,pCompType,ppFilter)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IFindCompressorCB_GetCompressor_Proxy( 
    IFindCompressorCB * This,
    AM_MEDIA_TYPE *pType,
    AM_MEDIA_TYPE *pCompType,
    /* [out] */ IBaseFilter **ppFilter);


void __RPC_STUB IFindCompressorCB_GetCompressor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFindCompressorCB_INTERFACE_DEFINED__ */


#ifndef __ISmartRenderEngine_INTERFACE_DEFINED__
#define __ISmartRenderEngine_INTERFACE_DEFINED__

/* interface ISmartRenderEngine */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISmartRenderEngine;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F03FA8CE-879A-4d59-9B2C-26BB1CF83461")
    ISmartRenderEngine : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetGroupCompressor( 
            long Group,
            IBaseFilter *pCompressor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroupCompressor( 
            long Group,
            IBaseFilter **pCompressor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFindCompressorCB( 
            IFindCompressorCB *pCallback) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISmartRenderEngineVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISmartRenderEngine * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISmartRenderEngine * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISmartRenderEngine * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetGroupCompressor )( 
            ISmartRenderEngine * This,
            long Group,
            IBaseFilter *pCompressor);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupCompressor )( 
            ISmartRenderEngine * This,
            long Group,
            IBaseFilter **pCompressor);
        
        HRESULT ( STDMETHODCALLTYPE *SetFindCompressorCB )( 
            ISmartRenderEngine * This,
            IFindCompressorCB *pCallback);
        
        END_INTERFACE
    } ISmartRenderEngineVtbl;

    interface ISmartRenderEngine
    {
        CONST_VTBL struct ISmartRenderEngineVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISmartRenderEngine_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISmartRenderEngine_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISmartRenderEngine_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISmartRenderEngine_SetGroupCompressor(This,Group,pCompressor)	\
    (This)->lpVtbl -> SetGroupCompressor(This,Group,pCompressor)

#define ISmartRenderEngine_GetGroupCompressor(This,Group,pCompressor)	\
    (This)->lpVtbl -> GetGroupCompressor(This,Group,pCompressor)

#define ISmartRenderEngine_SetFindCompressorCB(This,pCallback)	\
    (This)->lpVtbl -> SetFindCompressorCB(This,pCallback)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISmartRenderEngine_SetGroupCompressor_Proxy( 
    ISmartRenderEngine * This,
    long Group,
    IBaseFilter *pCompressor);


void __RPC_STUB ISmartRenderEngine_SetGroupCompressor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISmartRenderEngine_GetGroupCompressor_Proxy( 
    ISmartRenderEngine * This,
    long Group,
    IBaseFilter **pCompressor);


void __RPC_STUB ISmartRenderEngine_GetGroupCompressor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISmartRenderEngine_SetFindCompressorCB_Proxy( 
    ISmartRenderEngine * This,
    IFindCompressorCB *pCallback);


void __RPC_STUB ISmartRenderEngine_SetFindCompressorCB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISmartRenderEngine_INTERFACE_DEFINED__ */


#ifndef __IAMTimelineObj_INTERFACE_DEFINED__
#define __IAMTimelineObj_INTERFACE_DEFINED__

/* interface IAMTimelineObj */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IAMTimelineObj;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("78530B77-61F9-11D2-8CAD-00A024580902")
    IAMTimelineObj : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStartStop( 
            REFERENCE_TIME *pStart,
            REFERENCE_TIME *pStop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStartStop2( 
            REFTIME *pStart,
            REFTIME *pStop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FixTimes( 
            REFERENCE_TIME *pStart,
            REFERENCE_TIME *pStop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FixTimes2( 
            REFTIME *pStart,
            REFTIME *pStop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStartStop( 
            REFERENCE_TIME Start,
            REFERENCE_TIME Stop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStartStop2( 
            REFTIME Start,
            REFTIME Stop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPropertySetter( 
            /* [retval][out] */ IPropertySetter **pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetPropertySetter( 
            IPropertySetter *newVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubObject( 
            /* [retval][out] */ IUnknown **pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSubObject( 
            IUnknown *newVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSubObjectGUID( 
            GUID newVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSubObjectGUIDB( 
            BSTR newVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubObjectGUID( 
            GUID *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubObjectGUIDB( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubObjectLoaded( 
            BOOL *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTimelineType( 
            TIMELINE_MAJOR_TYPE *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetTimelineType( 
            TIMELINE_MAJOR_TYPE newVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetUserID( 
            long *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetUserID( 
            long newVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetGenID( 
            long *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetUserName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetUserName( 
            BSTR newVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetUserData( 
            BYTE *pData,
            long *pSize) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetUserData( 
            BYTE *pData,
            long Size) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMuted( 
            BOOL *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMuted( 
            BOOL newVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetLocked( 
            BOOL *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetLocked( 
            BOOL newVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDirtyRange( 
            REFERENCE_TIME *pStart,
            REFERENCE_TIME *pStop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDirtyRange2( 
            REFTIME *pStart,
            REFTIME *pStop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDirtyRange( 
            REFERENCE_TIME Start,
            REFERENCE_TIME Stop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDirtyRange2( 
            REFTIME Start,
            REFTIME Stop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ClearDirty( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Remove( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveAll( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimelineNoRef( 
            IAMTimeline **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroupIBelongTo( 
            /* [out] */ IAMTimelineGroup **ppGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEmbedDepth( 
            long *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimelineObjVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimelineObj * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimelineObj * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimelineObj * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetStartStop )( 
            IAMTimelineObj * This,
            REFERENCE_TIME *pStart,
            REFERENCE_TIME *pStop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetStartStop2 )( 
            IAMTimelineObj * This,
            REFTIME *pStart,
            REFTIME *pStop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FixTimes )( 
            IAMTimelineObj * This,
            REFERENCE_TIME *pStart,
            REFERENCE_TIME *pStop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FixTimes2 )( 
            IAMTimelineObj * This,
            REFTIME *pStart,
            REFTIME *pStop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStartStop )( 
            IAMTimelineObj * This,
            REFERENCE_TIME Start,
            REFERENCE_TIME Stop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStartStop2 )( 
            IAMTimelineObj * This,
            REFTIME Start,
            REFTIME Stop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPropertySetter )( 
            IAMTimelineObj * This,
            /* [retval][out] */ IPropertySetter **pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetPropertySetter )( 
            IAMTimelineObj * This,
            IPropertySetter *newVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSubObject )( 
            IAMTimelineObj * This,
            /* [retval][out] */ IUnknown **pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetSubObject )( 
            IAMTimelineObj * This,
            IUnknown *newVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetSubObjectGUID )( 
            IAMTimelineObj * This,
            GUID newVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetSubObjectGUIDB )( 
            IAMTimelineObj * This,
            BSTR newVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSubObjectGUID )( 
            IAMTimelineObj * This,
            GUID *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSubObjectGUIDB )( 
            IAMTimelineObj * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSubObjectLoaded )( 
            IAMTimelineObj * This,
            BOOL *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTimelineType )( 
            IAMTimelineObj * This,
            TIMELINE_MAJOR_TYPE *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetTimelineType )( 
            IAMTimelineObj * This,
            TIMELINE_MAJOR_TYPE newVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetUserID )( 
            IAMTimelineObj * This,
            long *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetUserID )( 
            IAMTimelineObj * This,
            long newVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetGenID )( 
            IAMTimelineObj * This,
            long *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetUserName )( 
            IAMTimelineObj * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetUserName )( 
            IAMTimelineObj * This,
            BSTR newVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetUserData )( 
            IAMTimelineObj * This,
            BYTE *pData,
            long *pSize);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetUserData )( 
            IAMTimelineObj * This,
            BYTE *pData,
            long Size);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMuted )( 
            IAMTimelineObj * This,
            BOOL *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMuted )( 
            IAMTimelineObj * This,
            BOOL newVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetLocked )( 
            IAMTimelineObj * This,
            BOOL *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetLocked )( 
            IAMTimelineObj * This,
            BOOL newVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDirtyRange )( 
            IAMTimelineObj * This,
            REFERENCE_TIME *pStart,
            REFERENCE_TIME *pStop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDirtyRange2 )( 
            IAMTimelineObj * This,
            REFTIME *pStart,
            REFTIME *pStop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetDirtyRange )( 
            IAMTimelineObj * This,
            REFERENCE_TIME Start,
            REFERENCE_TIME Stop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetDirtyRange2 )( 
            IAMTimelineObj * This,
            REFTIME Start,
            REFTIME Stop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ClearDirty )( 
            IAMTimelineObj * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IAMTimelineObj * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveAll )( 
            IAMTimelineObj * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimelineNoRef )( 
            IAMTimelineObj * This,
            IAMTimeline **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupIBelongTo )( 
            IAMTimelineObj * This,
            /* [out] */ IAMTimelineGroup **ppGroup);
        
        HRESULT ( STDMETHODCALLTYPE *GetEmbedDepth )( 
            IAMTimelineObj * This,
            long *pVal);
        
        END_INTERFACE
    } IAMTimelineObjVtbl;

    interface IAMTimelineObj
    {
        CONST_VTBL struct IAMTimelineObjVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimelineObj_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMTimelineObj_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMTimelineObj_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMTimelineObj_GetStartStop(This,pStart,pStop)	\
    (This)->lpVtbl -> GetStartStop(This,pStart,pStop)

#define IAMTimelineObj_GetStartStop2(This,pStart,pStop)	\
    (This)->lpVtbl -> GetStartStop2(This,pStart,pStop)

#define IAMTimelineObj_FixTimes(This,pStart,pStop)	\
    (This)->lpVtbl -> FixTimes(This,pStart,pStop)

#define IAMTimelineObj_FixTimes2(This,pStart,pStop)	\
    (This)->lpVtbl -> FixTimes2(This,pStart,pStop)

#define IAMTimelineObj_SetStartStop(This,Start,Stop)	\
    (This)->lpVtbl -> SetStartStop(This,Start,Stop)

#define IAMTimelineObj_SetStartStop2(This,Start,Stop)	\
    (This)->lpVtbl -> SetStartStop2(This,Start,Stop)

#define IAMTimelineObj_GetPropertySetter(This,pVal)	\
    (This)->lpVtbl -> GetPropertySetter(This,pVal)

#define IAMTimelineObj_SetPropertySetter(This,newVal)	\
    (This)->lpVtbl -> SetPropertySetter(This,newVal)

#define IAMTimelineObj_GetSubObject(This,pVal)	\
    (This)->lpVtbl -> GetSubObject(This,pVal)

#define IAMTimelineObj_SetSubObject(This,newVal)	\
    (This)->lpVtbl -> SetSubObject(This,newVal)

#define IAMTimelineObj_SetSubObjectGUID(This,newVal)	\
    (This)->lpVtbl -> SetSubObjectGUID(This,newVal)

#define IAMTimelineObj_SetSubObjectGUIDB(This,newVal)	\
    (This)->lpVtbl -> SetSubObjectGUIDB(This,newVal)

#define IAMTimelineObj_GetSubObjectGUID(This,pVal)	\
    (This)->lpVtbl -> GetSubObjectGUID(This,pVal)

#define IAMTimelineObj_GetSubObjectGUIDB(This,pVal)	\
    (This)->lpVtbl -> GetSubObjectGUIDB(This,pVal)

#define IAMTimelineObj_GetSubObjectLoaded(This,pVal)	\
    (This)->lpVtbl -> GetSubObjectLoaded(This,pVal)

#define IAMTimelineObj_GetTimelineType(This,pVal)	\
    (This)->lpVtbl -> GetTimelineType(This,pVal)

#define IAMTimelineObj_SetTimelineType(This,newVal)	\
    (This)->lpVtbl -> SetTimelineType(This,newVal)

#define IAMTimelineObj_GetUserID(This,pVal)	\
    (This)->lpVtbl -> GetUserID(This,pVal)

#define IAMTimelineObj_SetUserID(This,newVal)	\
    (This)->lpVtbl -> SetUserID(This,newVal)

#define IAMTimelineObj_GetGenID(This,pVal)	\
    (This)->lpVtbl -> GetGenID(This,pVal)

#define IAMTimelineObj_GetUserName(This,pVal)	\
    (This)->lpVtbl -> GetUserName(This,pVal)

#define IAMTimelineObj_SetUserName(This,newVal)	\
    (This)->lpVtbl -> SetUserName(This,newVal)

#define IAMTimelineObj_GetUserData(This,pData,pSize)	\
    (This)->lpVtbl -> GetUserData(This,pData,pSize)

#define IAMTimelineObj_SetUserData(This,pData,Size)	\
    (This)->lpVtbl -> SetUserData(This,pData,Size)

#define IAMTimelineObj_GetMuted(This,pVal)	\
    (This)->lpVtbl -> GetMuted(This,pVal)

#define IAMTimelineObj_SetMuted(This,newVal)	\
    (This)->lpVtbl -> SetMuted(This,newVal)

#define IAMTimelineObj_GetLocked(This,pVal)	\
    (This)->lpVtbl -> GetLocked(This,pVal)

#define IAMTimelineObj_SetLocked(This,newVal)	\
    (This)->lpVtbl -> SetLocked(This,newVal)

#define IAMTimelineObj_GetDirtyRange(This,pStart,pStop)	\
    (This)->lpVtbl -> GetDirtyRange(This,pStart,pStop)

#define IAMTimelineObj_GetDirtyRange2(This,pStart,pStop)	\
    (This)->lpVtbl -> GetDirtyRange2(This,pStart,pStop)

#define IAMTimelineObj_SetDirtyRange(This,Start,Stop)	\
    (This)->lpVtbl -> SetDirtyRange(This,Start,Stop)

#define IAMTimelineObj_SetDirtyRange2(This,Start,Stop)	\
    (This)->lpVtbl -> SetDirtyRange2(This,Start,Stop)

#define IAMTimelineObj_ClearDirty(This)	\
    (This)->lpVtbl -> ClearDirty(This)

#define IAMTimelineObj_Remove(This)	\
    (This)->lpVtbl -> Remove(This)

#define IAMTimelineObj_RemoveAll(This)	\
    (This)->lpVtbl -> RemoveAll(This)

#define IAMTimelineObj_GetTimelineNoRef(This,ppResult)	\
    (This)->lpVtbl -> GetTimelineNoRef(This,ppResult)

#define IAMTimelineObj_GetGroupIBelongTo(This,ppGroup)	\
    (This)->lpVtbl -> GetGroupIBelongTo(This,ppGroup)

#define IAMTimelineObj_GetEmbedDepth(This,pVal)	\
    (This)->lpVtbl -> GetEmbedDepth(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_GetStartStop_Proxy( 
    IAMTimelineObj * This,
    REFERENCE_TIME *pStart,
    REFERENCE_TIME *pStop);


void __RPC_STUB IAMTimelineObj_GetStartStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_GetStartStop2_Proxy( 
    IAMTimelineObj * This,
    REFTIME *pStart,
    REFTIME *pStop);


void __RPC_STUB IAMTimelineObj_GetStartStop2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_FixTimes_Proxy( 
    IAMTimelineObj * This,
    REFERENCE_TIME *pStart,
    REFERENCE_TIME *pStop);


void __RPC_STUB IAMTimelineObj_FixTimes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_FixTimes2_Proxy( 
    IAMTimelineObj * This,
    REFTIME *pStart,
    REFTIME *pStop);


void __RPC_STUB IAMTimelineObj_FixTimes2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_SetStartStop_Proxy( 
    IAMTimelineObj * This,
    REFERENCE_TIME Start,
    REFERENCE_TIME Stop);


void __RPC_STUB IAMTimelineObj_SetStartStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_SetStartStop2_Proxy( 
    IAMTimelineObj * This,
    REFTIME Start,
    REFTIME Stop);


void __RPC_STUB IAMTimelineObj_SetStartStop2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_GetPropertySetter_Proxy( 
    IAMTimelineObj * This,
    /* [retval][out] */ IPropertySetter **pVal);


void __RPC_STUB IAMTimelineObj_GetPropertySetter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_SetPropertySetter_Proxy( 
    IAMTimelineObj * This,
    IPropertySetter *newVal);


void __RPC_STUB IAMTimelineObj_SetPropertySetter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_GetSubObject_Proxy( 
    IAMTimelineObj * This,
    /* [retval][out] */ IUnknown **pVal);


void __RPC_STUB IAMTimelineObj_GetSubObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_SetSubObject_Proxy( 
    IAMTimelineObj * This,
    IUnknown *newVal);


void __RPC_STUB IAMTimelineObj_SetSubObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_SetSubObjectGUID_Proxy( 
    IAMTimelineObj * This,
    GUID newVal);


void __RPC_STUB IAMTimelineObj_SetSubObjectGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_SetSubObjectGUIDB_Proxy( 
    IAMTimelineObj * This,
    BSTR newVal);


void __RPC_STUB IAMTimelineObj_SetSubObjectGUIDB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_GetSubObjectGUID_Proxy( 
    IAMTimelineObj * This,
    GUID *pVal);


void __RPC_STUB IAMTimelineObj_GetSubObjectGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_GetSubObjectGUIDB_Proxy( 
    IAMTimelineObj * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IAMTimelineObj_GetSubObjectGUIDB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_GetSubObjectLoaded_Proxy( 
    IAMTimelineObj * This,
    BOOL *pVal);


void __RPC_STUB IAMTimelineObj_GetSubObjectLoaded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_GetTimelineType_Proxy( 
    IAMTimelineObj * This,
    TIMELINE_MAJOR_TYPE *pVal);


void __RPC_STUB IAMTimelineObj_GetTimelineType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_SetTimelineType_Proxy( 
    IAMTimelineObj * This,
    TIMELINE_MAJOR_TYPE newVal);


void __RPC_STUB IAMTimelineObj_SetTimelineType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_GetUserID_Proxy( 
    IAMTimelineObj * This,
    long *pVal);


void __RPC_STUB IAMTimelineObj_GetUserID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_SetUserID_Proxy( 
    IAMTimelineObj * This,
    long newVal);


void __RPC_STUB IAMTimelineObj_SetUserID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_GetGenID_Proxy( 
    IAMTimelineObj * This,
    long *pVal);


void __RPC_STUB IAMTimelineObj_GetGenID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_GetUserName_Proxy( 
    IAMTimelineObj * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IAMTimelineObj_GetUserName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_SetUserName_Proxy( 
    IAMTimelineObj * This,
    BSTR newVal);


void __RPC_STUB IAMTimelineObj_SetUserName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_GetUserData_Proxy( 
    IAMTimelineObj * This,
    BYTE *pData,
    long *pSize);


void __RPC_STUB IAMTimelineObj_GetUserData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_SetUserData_Proxy( 
    IAMTimelineObj * This,
    BYTE *pData,
    long Size);


void __RPC_STUB IAMTimelineObj_SetUserData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_GetMuted_Proxy( 
    IAMTimelineObj * This,
    BOOL *pVal);


void __RPC_STUB IAMTimelineObj_GetMuted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_SetMuted_Proxy( 
    IAMTimelineObj * This,
    BOOL newVal);


void __RPC_STUB IAMTimelineObj_SetMuted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_GetLocked_Proxy( 
    IAMTimelineObj * This,
    BOOL *pVal);


void __RPC_STUB IAMTimelineObj_GetLocked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_SetLocked_Proxy( 
    IAMTimelineObj * This,
    BOOL newVal);


void __RPC_STUB IAMTimelineObj_SetLocked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_GetDirtyRange_Proxy( 
    IAMTimelineObj * This,
    REFERENCE_TIME *pStart,
    REFERENCE_TIME *pStop);


void __RPC_STUB IAMTimelineObj_GetDirtyRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_GetDirtyRange2_Proxy( 
    IAMTimelineObj * This,
    REFTIME *pStart,
    REFTIME *pStop);


void __RPC_STUB IAMTimelineObj_GetDirtyRange2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_SetDirtyRange_Proxy( 
    IAMTimelineObj * This,
    REFERENCE_TIME Start,
    REFERENCE_TIME Stop);


void __RPC_STUB IAMTimelineObj_SetDirtyRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_SetDirtyRange2_Proxy( 
    IAMTimelineObj * This,
    REFTIME Start,
    REFTIME Stop);


void __RPC_STUB IAMTimelineObj_SetDirtyRange2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_ClearDirty_Proxy( 
    IAMTimelineObj * This);


void __RPC_STUB IAMTimelineObj_ClearDirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_Remove_Proxy( 
    IAMTimelineObj * This);


void __RPC_STUB IAMTimelineObj_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineObj_RemoveAll_Proxy( 
    IAMTimelineObj * This);


void __RPC_STUB IAMTimelineObj_RemoveAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimelineObj_GetTimelineNoRef_Proxy( 
    IAMTimelineObj * This,
    IAMTimeline **ppResult);


void __RPC_STUB IAMTimelineObj_GetTimelineNoRef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimelineObj_GetGroupIBelongTo_Proxy( 
    IAMTimelineObj * This,
    /* [out] */ IAMTimelineGroup **ppGroup);


void __RPC_STUB IAMTimelineObj_GetGroupIBelongTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimelineObj_GetEmbedDepth_Proxy( 
    IAMTimelineObj * This,
    long *pVal);


void __RPC_STUB IAMTimelineObj_GetEmbedDepth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMTimelineObj_INTERFACE_DEFINED__ */


#ifndef __IAMTimelineEffectable_INTERFACE_DEFINED__
#define __IAMTimelineEffectable_INTERFACE_DEFINED__

/* interface IAMTimelineEffectable */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMTimelineEffectable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EAE58537-622E-11d2-8CAD-00A024580902")
    IAMTimelineEffectable : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EffectInsBefore( 
            IAMTimelineObj *pFX,
            long priority) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EffectSwapPriorities( 
            long PriorityA,
            long PriorityB) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EffectGetCount( 
            long *pCount) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetEffect( 
            /* [out] */ IAMTimelineObj **ppFx,
            long Which) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimelineEffectableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimelineEffectable * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimelineEffectable * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimelineEffectable * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EffectInsBefore )( 
            IAMTimelineEffectable * This,
            IAMTimelineObj *pFX,
            long priority);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EffectSwapPriorities )( 
            IAMTimelineEffectable * This,
            long PriorityA,
            long PriorityB);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EffectGetCount )( 
            IAMTimelineEffectable * This,
            long *pCount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetEffect )( 
            IAMTimelineEffectable * This,
            /* [out] */ IAMTimelineObj **ppFx,
            long Which);
        
        END_INTERFACE
    } IAMTimelineEffectableVtbl;

    interface IAMTimelineEffectable
    {
        CONST_VTBL struct IAMTimelineEffectableVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimelineEffectable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMTimelineEffectable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMTimelineEffectable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMTimelineEffectable_EffectInsBefore(This,pFX,priority)	\
    (This)->lpVtbl -> EffectInsBefore(This,pFX,priority)

#define IAMTimelineEffectable_EffectSwapPriorities(This,PriorityA,PriorityB)	\
    (This)->lpVtbl -> EffectSwapPriorities(This,PriorityA,PriorityB)

#define IAMTimelineEffectable_EffectGetCount(This,pCount)	\
    (This)->lpVtbl -> EffectGetCount(This,pCount)

#define IAMTimelineEffectable_GetEffect(This,ppFx,Which)	\
    (This)->lpVtbl -> GetEffect(This,ppFx,Which)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineEffectable_EffectInsBefore_Proxy( 
    IAMTimelineEffectable * This,
    IAMTimelineObj *pFX,
    long priority);


void __RPC_STUB IAMTimelineEffectable_EffectInsBefore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineEffectable_EffectSwapPriorities_Proxy( 
    IAMTimelineEffectable * This,
    long PriorityA,
    long PriorityB);


void __RPC_STUB IAMTimelineEffectable_EffectSwapPriorities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineEffectable_EffectGetCount_Proxy( 
    IAMTimelineEffectable * This,
    long *pCount);


void __RPC_STUB IAMTimelineEffectable_EffectGetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineEffectable_GetEffect_Proxy( 
    IAMTimelineEffectable * This,
    /* [out] */ IAMTimelineObj **ppFx,
    long Which);


void __RPC_STUB IAMTimelineEffectable_GetEffect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMTimelineEffectable_INTERFACE_DEFINED__ */


#ifndef __IAMTimelineEffect_INTERFACE_DEFINED__
#define __IAMTimelineEffect_INTERFACE_DEFINED__

/* interface IAMTimelineEffect */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMTimelineEffect;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BCE0C264-622D-11d2-8CAD-00A024580902")
    IAMTimelineEffect : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EffectGetPriority( 
            long *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimelineEffectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimelineEffect * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimelineEffect * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimelineEffect * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EffectGetPriority )( 
            IAMTimelineEffect * This,
            long *pVal);
        
        END_INTERFACE
    } IAMTimelineEffectVtbl;

    interface IAMTimelineEffect
    {
        CONST_VTBL struct IAMTimelineEffectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimelineEffect_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMTimelineEffect_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMTimelineEffect_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMTimelineEffect_EffectGetPriority(This,pVal)	\
    (This)->lpVtbl -> EffectGetPriority(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineEffect_EffectGetPriority_Proxy( 
    IAMTimelineEffect * This,
    long *pVal);


void __RPC_STUB IAMTimelineEffect_EffectGetPriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMTimelineEffect_INTERFACE_DEFINED__ */


#ifndef __IAMTimelineTransable_INTERFACE_DEFINED__
#define __IAMTimelineTransable_INTERFACE_DEFINED__

/* interface IAMTimelineTransable */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMTimelineTransable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("378FA386-622E-11d2-8CAD-00A024580902")
    IAMTimelineTransable : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TransAdd( 
            IAMTimelineObj *pTrans) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TransGetCount( 
            long *pCount) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetNextTrans( 
            /* [out] */ IAMTimelineObj **ppTrans,
            REFERENCE_TIME *pInOut) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetNextTrans2( 
            /* [out] */ IAMTimelineObj **ppTrans,
            REFTIME *pInOut) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTransAtTime( 
            /* [out] */ IAMTimelineObj **ppObj,
            REFERENCE_TIME Time,
            long SearchDirection) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTransAtTime2( 
            /* [out] */ IAMTimelineObj **ppObj,
            REFTIME Time,
            long SearchDirection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimelineTransableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimelineTransable * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimelineTransable * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimelineTransable * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TransAdd )( 
            IAMTimelineTransable * This,
            IAMTimelineObj *pTrans);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TransGetCount )( 
            IAMTimelineTransable * This,
            long *pCount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetNextTrans )( 
            IAMTimelineTransable * This,
            /* [out] */ IAMTimelineObj **ppTrans,
            REFERENCE_TIME *pInOut);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetNextTrans2 )( 
            IAMTimelineTransable * This,
            /* [out] */ IAMTimelineObj **ppTrans,
            REFTIME *pInOut);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTransAtTime )( 
            IAMTimelineTransable * This,
            /* [out] */ IAMTimelineObj **ppObj,
            REFERENCE_TIME Time,
            long SearchDirection);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTransAtTime2 )( 
            IAMTimelineTransable * This,
            /* [out] */ IAMTimelineObj **ppObj,
            REFTIME Time,
            long SearchDirection);
        
        END_INTERFACE
    } IAMTimelineTransableVtbl;

    interface IAMTimelineTransable
    {
        CONST_VTBL struct IAMTimelineTransableVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimelineTransable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMTimelineTransable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMTimelineTransable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMTimelineTransable_TransAdd(This,pTrans)	\
    (This)->lpVtbl -> TransAdd(This,pTrans)

#define IAMTimelineTransable_TransGetCount(This,pCount)	\
    (This)->lpVtbl -> TransGetCount(This,pCount)

#define IAMTimelineTransable_GetNextTrans(This,ppTrans,pInOut)	\
    (This)->lpVtbl -> GetNextTrans(This,ppTrans,pInOut)

#define IAMTimelineTransable_GetNextTrans2(This,ppTrans,pInOut)	\
    (This)->lpVtbl -> GetNextTrans2(This,ppTrans,pInOut)

#define IAMTimelineTransable_GetTransAtTime(This,ppObj,Time,SearchDirection)	\
    (This)->lpVtbl -> GetTransAtTime(This,ppObj,Time,SearchDirection)

#define IAMTimelineTransable_GetTransAtTime2(This,ppObj,Time,SearchDirection)	\
    (This)->lpVtbl -> GetTransAtTime2(This,ppObj,Time,SearchDirection)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineTransable_TransAdd_Proxy( 
    IAMTimelineTransable * This,
    IAMTimelineObj *pTrans);


void __RPC_STUB IAMTimelineTransable_TransAdd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineTransable_TransGetCount_Proxy( 
    IAMTimelineTransable * This,
    long *pCount);


void __RPC_STUB IAMTimelineTransable_TransGetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineTransable_GetNextTrans_Proxy( 
    IAMTimelineTransable * This,
    /* [out] */ IAMTimelineObj **ppTrans,
    REFERENCE_TIME *pInOut);


void __RPC_STUB IAMTimelineTransable_GetNextTrans_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineTransable_GetNextTrans2_Proxy( 
    IAMTimelineTransable * This,
    /* [out] */ IAMTimelineObj **ppTrans,
    REFTIME *pInOut);


void __RPC_STUB IAMTimelineTransable_GetNextTrans2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineTransable_GetTransAtTime_Proxy( 
    IAMTimelineTransable * This,
    /* [out] */ IAMTimelineObj **ppObj,
    REFERENCE_TIME Time,
    long SearchDirection);


void __RPC_STUB IAMTimelineTransable_GetTransAtTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineTransable_GetTransAtTime2_Proxy( 
    IAMTimelineTransable * This,
    /* [out] */ IAMTimelineObj **ppObj,
    REFTIME Time,
    long SearchDirection);


void __RPC_STUB IAMTimelineTransable_GetTransAtTime2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMTimelineTransable_INTERFACE_DEFINED__ */


#ifndef __IAMTimelineSplittable_INTERFACE_DEFINED__
#define __IAMTimelineSplittable_INTERFACE_DEFINED__

/* interface IAMTimelineSplittable */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMTimelineSplittable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A0F840A0-D590-11d2-8D55-00A0C9441E20")
    IAMTimelineSplittable : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SplitAt( 
            REFERENCE_TIME Time) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SplitAt2( 
            REFTIME Time) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimelineSplittableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimelineSplittable * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimelineSplittable * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimelineSplittable * This);
        
        HRESULT ( STDMETHODCALLTYPE *SplitAt )( 
            IAMTimelineSplittable * This,
            REFERENCE_TIME Time);
        
        HRESULT ( STDMETHODCALLTYPE *SplitAt2 )( 
            IAMTimelineSplittable * This,
            REFTIME Time);
        
        END_INTERFACE
    } IAMTimelineSplittableVtbl;

    interface IAMTimelineSplittable
    {
        CONST_VTBL struct IAMTimelineSplittableVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimelineSplittable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMTimelineSplittable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMTimelineSplittable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMTimelineSplittable_SplitAt(This,Time)	\
    (This)->lpVtbl -> SplitAt(This,Time)

#define IAMTimelineSplittable_SplitAt2(This,Time)	\
    (This)->lpVtbl -> SplitAt2(This,Time)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMTimelineSplittable_SplitAt_Proxy( 
    IAMTimelineSplittable * This,
    REFERENCE_TIME Time);


void __RPC_STUB IAMTimelineSplittable_SplitAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimelineSplittable_SplitAt2_Proxy( 
    IAMTimelineSplittable * This,
    REFTIME Time);


void __RPC_STUB IAMTimelineSplittable_SplitAt2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMTimelineSplittable_INTERFACE_DEFINED__ */


#ifndef __IAMTimelineTrans_INTERFACE_DEFINED__
#define __IAMTimelineTrans_INTERFACE_DEFINED__

/* interface IAMTimelineTrans */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMTimelineTrans;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BCE0C265-622D-11d2-8CAD-00A024580902")
    IAMTimelineTrans : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCutPoint( 
            REFERENCE_TIME *pTLTime) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCutPoint2( 
            REFTIME *pTLTime) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetCutPoint( 
            REFERENCE_TIME TLTime) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetCutPoint2( 
            REFTIME TLTime) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSwapInputs( 
            BOOL *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSwapInputs( 
            BOOL pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCutsOnly( 
            BOOL *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetCutsOnly( 
            BOOL pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimelineTransVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimelineTrans * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimelineTrans * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimelineTrans * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCutPoint )( 
            IAMTimelineTrans * This,
            REFERENCE_TIME *pTLTime);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCutPoint2 )( 
            IAMTimelineTrans * This,
            REFTIME *pTLTime);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetCutPoint )( 
            IAMTimelineTrans * This,
            REFERENCE_TIME TLTime);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetCutPoint2 )( 
            IAMTimelineTrans * This,
            REFTIME TLTime);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSwapInputs )( 
            IAMTimelineTrans * This,
            BOOL *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetSwapInputs )( 
            IAMTimelineTrans * This,
            BOOL pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCutsOnly )( 
            IAMTimelineTrans * This,
            BOOL *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetCutsOnly )( 
            IAMTimelineTrans * This,
            BOOL pVal);
        
        END_INTERFACE
    } IAMTimelineTransVtbl;

    interface IAMTimelineTrans
    {
        CONST_VTBL struct IAMTimelineTransVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimelineTrans_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMTimelineTrans_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMTimelineTrans_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMTimelineTrans_GetCutPoint(This,pTLTime)	\
    (This)->lpVtbl -> GetCutPoint(This,pTLTime)

#define IAMTimelineTrans_GetCutPoint2(This,pTLTime)	\
    (This)->lpVtbl -> GetCutPoint2(This,pTLTime)

#define IAMTimelineTrans_SetCutPoint(This,TLTime)	\
    (This)->lpVtbl -> SetCutPoint(This,TLTime)

#define IAMTimelineTrans_SetCutPoint2(This,TLTime)	\
    (This)->lpVtbl -> SetCutPoint2(This,TLTime)

#define IAMTimelineTrans_GetSwapInputs(This,pVal)	\
    (This)->lpVtbl -> GetSwapInputs(This,pVal)

#define IAMTimelineTrans_SetSwapInputs(This,pVal)	\
    (This)->lpVtbl -> SetSwapInputs(This,pVal)

#define IAMTimelineTrans_GetCutsOnly(This,pVal)	\
    (This)->lpVtbl -> GetCutsOnly(This,pVal)

#define IAMTimelineTrans_SetCutsOnly(This,pVal)	\
    (This)->lpVtbl -> SetCutsOnly(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineTrans_GetCutPoint_Proxy( 
    IAMTimelineTrans * This,
    REFERENCE_TIME *pTLTime);


void __RPC_STUB IAMTimelineTrans_GetCutPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineTrans_GetCutPoint2_Proxy( 
    IAMTimelineTrans * This,
    REFTIME *pTLTime);


void __RPC_STUB IAMTimelineTrans_GetCutPoint2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineTrans_SetCutPoint_Proxy( 
    IAMTimelineTrans * This,
    REFERENCE_TIME TLTime);


void __RPC_STUB IAMTimelineTrans_SetCutPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineTrans_SetCutPoint2_Proxy( 
    IAMTimelineTrans * This,
    REFTIME TLTime);


void __RPC_STUB IAMTimelineTrans_SetCutPoint2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineTrans_GetSwapInputs_Proxy( 
    IAMTimelineTrans * This,
    BOOL *pVal);


void __RPC_STUB IAMTimelineTrans_GetSwapInputs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineTrans_SetSwapInputs_Proxy( 
    IAMTimelineTrans * This,
    BOOL pVal);


void __RPC_STUB IAMTimelineTrans_SetSwapInputs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineTrans_GetCutsOnly_Proxy( 
    IAMTimelineTrans * This,
    BOOL *pVal);


void __RPC_STUB IAMTimelineTrans_GetCutsOnly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineTrans_SetCutsOnly_Proxy( 
    IAMTimelineTrans * This,
    BOOL pVal);


void __RPC_STUB IAMTimelineTrans_SetCutsOnly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMTimelineTrans_INTERFACE_DEFINED__ */


#ifndef __IAMTimelineSrc_INTERFACE_DEFINED__
#define __IAMTimelineSrc_INTERFACE_DEFINED__

/* interface IAMTimelineSrc */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMTimelineSrc;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("78530B79-61F9-11D2-8CAD-00A024580902")
    IAMTimelineSrc : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMediaTimes( 
            REFERENCE_TIME *pStart,
            REFERENCE_TIME *pStop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMediaTimes2( 
            REFTIME *pStart,
            REFTIME *pStop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ModifyStopTime( 
            REFERENCE_TIME Stop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ModifyStopTime2( 
            REFTIME Stop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FixMediaTimes( 
            REFERENCE_TIME *pStart,
            REFERENCE_TIME *pStop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FixMediaTimes2( 
            REFTIME *pStart,
            REFTIME *pStop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMediaTimes( 
            REFERENCE_TIME Start,
            REFERENCE_TIME Stop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMediaTimes2( 
            REFTIME Start,
            REFTIME Stop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMediaLength( 
            REFERENCE_TIME Length) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMediaLength2( 
            REFTIME Length) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMediaLength( 
            REFERENCE_TIME *pLength) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMediaLength2( 
            REFTIME *pLength) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMediaName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMediaName( 
            BSTR newVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SpliceWithNext( 
            IAMTimelineObj *pNext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStreamNumber( 
            long *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStreamNumber( 
            long Val) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsNormalRate( 
            BOOL *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDefaultFPS( 
            double *pFPS) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDefaultFPS( 
            double FPS) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStretchMode( 
            int *pnStretchMode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStretchMode( 
            int nStretchMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimelineSrcVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimelineSrc * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimelineSrc * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimelineSrc * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMediaTimes )( 
            IAMTimelineSrc * This,
            REFERENCE_TIME *pStart,
            REFERENCE_TIME *pStop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMediaTimes2 )( 
            IAMTimelineSrc * This,
            REFTIME *pStart,
            REFTIME *pStop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ModifyStopTime )( 
            IAMTimelineSrc * This,
            REFERENCE_TIME Stop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ModifyStopTime2 )( 
            IAMTimelineSrc * This,
            REFTIME Stop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FixMediaTimes )( 
            IAMTimelineSrc * This,
            REFERENCE_TIME *pStart,
            REFERENCE_TIME *pStop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FixMediaTimes2 )( 
            IAMTimelineSrc * This,
            REFTIME *pStart,
            REFTIME *pStop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMediaTimes )( 
            IAMTimelineSrc * This,
            REFERENCE_TIME Start,
            REFERENCE_TIME Stop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMediaTimes2 )( 
            IAMTimelineSrc * This,
            REFTIME Start,
            REFTIME Stop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMediaLength )( 
            IAMTimelineSrc * This,
            REFERENCE_TIME Length);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMediaLength2 )( 
            IAMTimelineSrc * This,
            REFTIME Length);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMediaLength )( 
            IAMTimelineSrc * This,
            REFERENCE_TIME *pLength);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMediaLength2 )( 
            IAMTimelineSrc * This,
            REFTIME *pLength);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMediaName )( 
            IAMTimelineSrc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMediaName )( 
            IAMTimelineSrc * This,
            BSTR newVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SpliceWithNext )( 
            IAMTimelineSrc * This,
            IAMTimelineObj *pNext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetStreamNumber )( 
            IAMTimelineSrc * This,
            long *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStreamNumber )( 
            IAMTimelineSrc * This,
            long Val);
        
        HRESULT ( STDMETHODCALLTYPE *IsNormalRate )( 
            IAMTimelineSrc * This,
            BOOL *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDefaultFPS )( 
            IAMTimelineSrc * This,
            double *pFPS);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetDefaultFPS )( 
            IAMTimelineSrc * This,
            double FPS);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetStretchMode )( 
            IAMTimelineSrc * This,
            int *pnStretchMode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStretchMode )( 
            IAMTimelineSrc * This,
            int nStretchMode);
        
        END_INTERFACE
    } IAMTimelineSrcVtbl;

    interface IAMTimelineSrc
    {
        CONST_VTBL struct IAMTimelineSrcVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimelineSrc_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMTimelineSrc_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMTimelineSrc_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMTimelineSrc_GetMediaTimes(This,pStart,pStop)	\
    (This)->lpVtbl -> GetMediaTimes(This,pStart,pStop)

#define IAMTimelineSrc_GetMediaTimes2(This,pStart,pStop)	\
    (This)->lpVtbl -> GetMediaTimes2(This,pStart,pStop)

#define IAMTimelineSrc_ModifyStopTime(This,Stop)	\
    (This)->lpVtbl -> ModifyStopTime(This,Stop)

#define IAMTimelineSrc_ModifyStopTime2(This,Stop)	\
    (This)->lpVtbl -> ModifyStopTime2(This,Stop)

#define IAMTimelineSrc_FixMediaTimes(This,pStart,pStop)	\
    (This)->lpVtbl -> FixMediaTimes(This,pStart,pStop)

#define IAMTimelineSrc_FixMediaTimes2(This,pStart,pStop)	\
    (This)->lpVtbl -> FixMediaTimes2(This,pStart,pStop)

#define IAMTimelineSrc_SetMediaTimes(This,Start,Stop)	\
    (This)->lpVtbl -> SetMediaTimes(This,Start,Stop)

#define IAMTimelineSrc_SetMediaTimes2(This,Start,Stop)	\
    (This)->lpVtbl -> SetMediaTimes2(This,Start,Stop)

#define IAMTimelineSrc_SetMediaLength(This,Length)	\
    (This)->lpVtbl -> SetMediaLength(This,Length)

#define IAMTimelineSrc_SetMediaLength2(This,Length)	\
    (This)->lpVtbl -> SetMediaLength2(This,Length)

#define IAMTimelineSrc_GetMediaLength(This,pLength)	\
    (This)->lpVtbl -> GetMediaLength(This,pLength)

#define IAMTimelineSrc_GetMediaLength2(This,pLength)	\
    (This)->lpVtbl -> GetMediaLength2(This,pLength)

#define IAMTimelineSrc_GetMediaName(This,pVal)	\
    (This)->lpVtbl -> GetMediaName(This,pVal)

#define IAMTimelineSrc_SetMediaName(This,newVal)	\
    (This)->lpVtbl -> SetMediaName(This,newVal)

#define IAMTimelineSrc_SpliceWithNext(This,pNext)	\
    (This)->lpVtbl -> SpliceWithNext(This,pNext)

#define IAMTimelineSrc_GetStreamNumber(This,pVal)	\
    (This)->lpVtbl -> GetStreamNumber(This,pVal)

#define IAMTimelineSrc_SetStreamNumber(This,Val)	\
    (This)->lpVtbl -> SetStreamNumber(This,Val)

#define IAMTimelineSrc_IsNormalRate(This,pVal)	\
    (This)->lpVtbl -> IsNormalRate(This,pVal)

#define IAMTimelineSrc_GetDefaultFPS(This,pFPS)	\
    (This)->lpVtbl -> GetDefaultFPS(This,pFPS)

#define IAMTimelineSrc_SetDefaultFPS(This,FPS)	\
    (This)->lpVtbl -> SetDefaultFPS(This,FPS)

#define IAMTimelineSrc_GetStretchMode(This,pnStretchMode)	\
    (This)->lpVtbl -> GetStretchMode(This,pnStretchMode)

#define IAMTimelineSrc_SetStretchMode(This,nStretchMode)	\
    (This)->lpVtbl -> SetStretchMode(This,nStretchMode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineSrc_GetMediaTimes_Proxy( 
    IAMTimelineSrc * This,
    REFERENCE_TIME *pStart,
    REFERENCE_TIME *pStop);


void __RPC_STUB IAMTimelineSrc_GetMediaTimes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineSrc_GetMediaTimes2_Proxy( 
    IAMTimelineSrc * This,
    REFTIME *pStart,
    REFTIME *pStop);


void __RPC_STUB IAMTimelineSrc_GetMediaTimes2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineSrc_ModifyStopTime_Proxy( 
    IAMTimelineSrc * This,
    REFERENCE_TIME Stop);


void __RPC_STUB IAMTimelineSrc_ModifyStopTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineSrc_ModifyStopTime2_Proxy( 
    IAMTimelineSrc * This,
    REFTIME Stop);


void __RPC_STUB IAMTimelineSrc_ModifyStopTime2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineSrc_FixMediaTimes_Proxy( 
    IAMTimelineSrc * This,
    REFERENCE_TIME *pStart,
    REFERENCE_TIME *pStop);


void __RPC_STUB IAMTimelineSrc_FixMediaTimes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineSrc_FixMediaTimes2_Proxy( 
    IAMTimelineSrc * This,
    REFTIME *pStart,
    REFTIME *pStop);


void __RPC_STUB IAMTimelineSrc_FixMediaTimes2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineSrc_SetMediaTimes_Proxy( 
    IAMTimelineSrc * This,
    REFERENCE_TIME Start,
    REFERENCE_TIME Stop);


void __RPC_STUB IAMTimelineSrc_SetMediaTimes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineSrc_SetMediaTimes2_Proxy( 
    IAMTimelineSrc * This,
    REFTIME Start,
    REFTIME Stop);


void __RPC_STUB IAMTimelineSrc_SetMediaTimes2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineSrc_SetMediaLength_Proxy( 
    IAMTimelineSrc * This,
    REFERENCE_TIME Length);


void __RPC_STUB IAMTimelineSrc_SetMediaLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineSrc_SetMediaLength2_Proxy( 
    IAMTimelineSrc * This,
    REFTIME Length);


void __RPC_STUB IAMTimelineSrc_SetMediaLength2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineSrc_GetMediaLength_Proxy( 
    IAMTimelineSrc * This,
    REFERENCE_TIME *pLength);


void __RPC_STUB IAMTimelineSrc_GetMediaLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineSrc_GetMediaLength2_Proxy( 
    IAMTimelineSrc * This,
    REFTIME *pLength);


void __RPC_STUB IAMTimelineSrc_GetMediaLength2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineSrc_GetMediaName_Proxy( 
    IAMTimelineSrc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IAMTimelineSrc_GetMediaName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineSrc_SetMediaName_Proxy( 
    IAMTimelineSrc * This,
    BSTR newVal);


void __RPC_STUB IAMTimelineSrc_SetMediaName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineSrc_SpliceWithNext_Proxy( 
    IAMTimelineSrc * This,
    IAMTimelineObj *pNext);


void __RPC_STUB IAMTimelineSrc_SpliceWithNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineSrc_GetStreamNumber_Proxy( 
    IAMTimelineSrc * This,
    long *pVal);


void __RPC_STUB IAMTimelineSrc_GetStreamNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineSrc_SetStreamNumber_Proxy( 
    IAMTimelineSrc * This,
    long Val);


void __RPC_STUB IAMTimelineSrc_SetStreamNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimelineSrc_IsNormalRate_Proxy( 
    IAMTimelineSrc * This,
    BOOL *pVal);


void __RPC_STUB IAMTimelineSrc_IsNormalRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineSrc_GetDefaultFPS_Proxy( 
    IAMTimelineSrc * This,
    double *pFPS);


void __RPC_STUB IAMTimelineSrc_GetDefaultFPS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineSrc_SetDefaultFPS_Proxy( 
    IAMTimelineSrc * This,
    double FPS);


void __RPC_STUB IAMTimelineSrc_SetDefaultFPS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineSrc_GetStretchMode_Proxy( 
    IAMTimelineSrc * This,
    int *pnStretchMode);


void __RPC_STUB IAMTimelineSrc_GetStretchMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineSrc_SetStretchMode_Proxy( 
    IAMTimelineSrc * This,
    int nStretchMode);


void __RPC_STUB IAMTimelineSrc_SetStretchMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMTimelineSrc_INTERFACE_DEFINED__ */


#ifndef __IAMTimelineTrack_INTERFACE_DEFINED__
#define __IAMTimelineTrack_INTERFACE_DEFINED__

/* interface IAMTimelineTrack */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMTimelineTrack;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EAE58538-622E-11d2-8CAD-00A024580902")
    IAMTimelineTrack : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SrcAdd( 
            IAMTimelineObj *pSource) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetNextSrc( 
            /* [out] */ IAMTimelineObj **ppSrc,
            REFERENCE_TIME *pInOut) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetNextSrc2( 
            /* [out] */ IAMTimelineObj **ppSrc,
            REFTIME *pInOut) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MoveEverythingBy( 
            REFERENCE_TIME Start,
            REFERENCE_TIME MoveBy) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MoveEverythingBy2( 
            REFTIME Start,
            REFTIME MoveBy) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSourcesCount( 
            long *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AreYouBlank( 
            long *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSrcAtTime( 
            /* [out] */ IAMTimelineObj **ppSrc,
            REFERENCE_TIME Time,
            long SearchDirection) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSrcAtTime2( 
            /* [out] */ IAMTimelineObj **ppSrc,
            REFTIME Time,
            long SearchDirection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertSpace( 
            REFERENCE_TIME rtStart,
            REFERENCE_TIME rtEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertSpace2( 
            REFTIME rtStart,
            REFTIME rtEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ZeroBetween( 
            REFERENCE_TIME rtStart,
            REFERENCE_TIME rtEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ZeroBetween2( 
            REFTIME rtStart,
            REFTIME rtEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextSrcEx( 
            IAMTimelineObj *pLast,
            /* [out] */ IAMTimelineObj **ppNext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimelineTrackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimelineTrack * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimelineTrack * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimelineTrack * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SrcAdd )( 
            IAMTimelineTrack * This,
            IAMTimelineObj *pSource);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetNextSrc )( 
            IAMTimelineTrack * This,
            /* [out] */ IAMTimelineObj **ppSrc,
            REFERENCE_TIME *pInOut);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetNextSrc2 )( 
            IAMTimelineTrack * This,
            /* [out] */ IAMTimelineObj **ppSrc,
            REFTIME *pInOut);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *MoveEverythingBy )( 
            IAMTimelineTrack * This,
            REFERENCE_TIME Start,
            REFERENCE_TIME MoveBy);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *MoveEverythingBy2 )( 
            IAMTimelineTrack * This,
            REFTIME Start,
            REFTIME MoveBy);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSourcesCount )( 
            IAMTimelineTrack * This,
            long *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AreYouBlank )( 
            IAMTimelineTrack * This,
            long *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSrcAtTime )( 
            IAMTimelineTrack * This,
            /* [out] */ IAMTimelineObj **ppSrc,
            REFERENCE_TIME Time,
            long SearchDirection);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSrcAtTime2 )( 
            IAMTimelineTrack * This,
            /* [out] */ IAMTimelineObj **ppSrc,
            REFTIME Time,
            long SearchDirection);
        
        HRESULT ( STDMETHODCALLTYPE *InsertSpace )( 
            IAMTimelineTrack * This,
            REFERENCE_TIME rtStart,
            REFERENCE_TIME rtEnd);
        
        HRESULT ( STDMETHODCALLTYPE *InsertSpace2 )( 
            IAMTimelineTrack * This,
            REFTIME rtStart,
            REFTIME rtEnd);
        
        HRESULT ( STDMETHODCALLTYPE *ZeroBetween )( 
            IAMTimelineTrack * This,
            REFERENCE_TIME rtStart,
            REFERENCE_TIME rtEnd);
        
        HRESULT ( STDMETHODCALLTYPE *ZeroBetween2 )( 
            IAMTimelineTrack * This,
            REFTIME rtStart,
            REFTIME rtEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextSrcEx )( 
            IAMTimelineTrack * This,
            IAMTimelineObj *pLast,
            /* [out] */ IAMTimelineObj **ppNext);
        
        END_INTERFACE
    } IAMTimelineTrackVtbl;

    interface IAMTimelineTrack
    {
        CONST_VTBL struct IAMTimelineTrackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimelineTrack_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMTimelineTrack_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMTimelineTrack_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMTimelineTrack_SrcAdd(This,pSource)	\
    (This)->lpVtbl -> SrcAdd(This,pSource)

#define IAMTimelineTrack_GetNextSrc(This,ppSrc,pInOut)	\
    (This)->lpVtbl -> GetNextSrc(This,ppSrc,pInOut)

#define IAMTimelineTrack_GetNextSrc2(This,ppSrc,pInOut)	\
    (This)->lpVtbl -> GetNextSrc2(This,ppSrc,pInOut)

#define IAMTimelineTrack_MoveEverythingBy(This,Start,MoveBy)	\
    (This)->lpVtbl -> MoveEverythingBy(This,Start,MoveBy)

#define IAMTimelineTrack_MoveEverythingBy2(This,Start,MoveBy)	\
    (This)->lpVtbl -> MoveEverythingBy2(This,Start,MoveBy)

#define IAMTimelineTrack_GetSourcesCount(This,pVal)	\
    (This)->lpVtbl -> GetSourcesCount(This,pVal)

#define IAMTimelineTrack_AreYouBlank(This,pVal)	\
    (This)->lpVtbl -> AreYouBlank(This,pVal)

#define IAMTimelineTrack_GetSrcAtTime(This,ppSrc,Time,SearchDirection)	\
    (This)->lpVtbl -> GetSrcAtTime(This,ppSrc,Time,SearchDirection)

#define IAMTimelineTrack_GetSrcAtTime2(This,ppSrc,Time,SearchDirection)	\
    (This)->lpVtbl -> GetSrcAtTime2(This,ppSrc,Time,SearchDirection)

#define IAMTimelineTrack_InsertSpace(This,rtStart,rtEnd)	\
    (This)->lpVtbl -> InsertSpace(This,rtStart,rtEnd)

#define IAMTimelineTrack_InsertSpace2(This,rtStart,rtEnd)	\
    (This)->lpVtbl -> InsertSpace2(This,rtStart,rtEnd)

#define IAMTimelineTrack_ZeroBetween(This,rtStart,rtEnd)	\
    (This)->lpVtbl -> ZeroBetween(This,rtStart,rtEnd)

#define IAMTimelineTrack_ZeroBetween2(This,rtStart,rtEnd)	\
    (This)->lpVtbl -> ZeroBetween2(This,rtStart,rtEnd)

#define IAMTimelineTrack_GetNextSrcEx(This,pLast,ppNext)	\
    (This)->lpVtbl -> GetNextSrcEx(This,pLast,ppNext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineTrack_SrcAdd_Proxy( 
    IAMTimelineTrack * This,
    IAMTimelineObj *pSource);


void __RPC_STUB IAMTimelineTrack_SrcAdd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineTrack_GetNextSrc_Proxy( 
    IAMTimelineTrack * This,
    /* [out] */ IAMTimelineObj **ppSrc,
    REFERENCE_TIME *pInOut);


void __RPC_STUB IAMTimelineTrack_GetNextSrc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineTrack_GetNextSrc2_Proxy( 
    IAMTimelineTrack * This,
    /* [out] */ IAMTimelineObj **ppSrc,
    REFTIME *pInOut);


void __RPC_STUB IAMTimelineTrack_GetNextSrc2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineTrack_MoveEverythingBy_Proxy( 
    IAMTimelineTrack * This,
    REFERENCE_TIME Start,
    REFERENCE_TIME MoveBy);


void __RPC_STUB IAMTimelineTrack_MoveEverythingBy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineTrack_MoveEverythingBy2_Proxy( 
    IAMTimelineTrack * This,
    REFTIME Start,
    REFTIME MoveBy);


void __RPC_STUB IAMTimelineTrack_MoveEverythingBy2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineTrack_GetSourcesCount_Proxy( 
    IAMTimelineTrack * This,
    long *pVal);


void __RPC_STUB IAMTimelineTrack_GetSourcesCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineTrack_AreYouBlank_Proxy( 
    IAMTimelineTrack * This,
    long *pVal);


void __RPC_STUB IAMTimelineTrack_AreYouBlank_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineTrack_GetSrcAtTime_Proxy( 
    IAMTimelineTrack * This,
    /* [out] */ IAMTimelineObj **ppSrc,
    REFERENCE_TIME Time,
    long SearchDirection);


void __RPC_STUB IAMTimelineTrack_GetSrcAtTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineTrack_GetSrcAtTime2_Proxy( 
    IAMTimelineTrack * This,
    /* [out] */ IAMTimelineObj **ppSrc,
    REFTIME Time,
    long SearchDirection);


void __RPC_STUB IAMTimelineTrack_GetSrcAtTime2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimelineTrack_InsertSpace_Proxy( 
    IAMTimelineTrack * This,
    REFERENCE_TIME rtStart,
    REFERENCE_TIME rtEnd);


void __RPC_STUB IAMTimelineTrack_InsertSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimelineTrack_InsertSpace2_Proxy( 
    IAMTimelineTrack * This,
    REFTIME rtStart,
    REFTIME rtEnd);


void __RPC_STUB IAMTimelineTrack_InsertSpace2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimelineTrack_ZeroBetween_Proxy( 
    IAMTimelineTrack * This,
    REFERENCE_TIME rtStart,
    REFERENCE_TIME rtEnd);


void __RPC_STUB IAMTimelineTrack_ZeroBetween_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimelineTrack_ZeroBetween2_Proxy( 
    IAMTimelineTrack * This,
    REFTIME rtStart,
    REFTIME rtEnd);


void __RPC_STUB IAMTimelineTrack_ZeroBetween2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimelineTrack_GetNextSrcEx_Proxy( 
    IAMTimelineTrack * This,
    IAMTimelineObj *pLast,
    /* [out] */ IAMTimelineObj **ppNext);


void __RPC_STUB IAMTimelineTrack_GetNextSrcEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMTimelineTrack_INTERFACE_DEFINED__ */


#ifndef __IAMTimelineVirtualTrack_INTERFACE_DEFINED__
#define __IAMTimelineVirtualTrack_INTERFACE_DEFINED__

/* interface IAMTimelineVirtualTrack */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMTimelineVirtualTrack;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A8ED5F80-C2C7-11d2-8D39-00A0C9441E20")
    IAMTimelineVirtualTrack : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TrackGetPriority( 
            long *pPriority) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetTrackDirty( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimelineVirtualTrackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimelineVirtualTrack * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimelineVirtualTrack * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimelineVirtualTrack * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TrackGetPriority )( 
            IAMTimelineVirtualTrack * This,
            long *pPriority);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetTrackDirty )( 
            IAMTimelineVirtualTrack * This);
        
        END_INTERFACE
    } IAMTimelineVirtualTrackVtbl;

    interface IAMTimelineVirtualTrack
    {
        CONST_VTBL struct IAMTimelineVirtualTrackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimelineVirtualTrack_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMTimelineVirtualTrack_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMTimelineVirtualTrack_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMTimelineVirtualTrack_TrackGetPriority(This,pPriority)	\
    (This)->lpVtbl -> TrackGetPriority(This,pPriority)

#define IAMTimelineVirtualTrack_SetTrackDirty(This)	\
    (This)->lpVtbl -> SetTrackDirty(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineVirtualTrack_TrackGetPriority_Proxy( 
    IAMTimelineVirtualTrack * This,
    long *pPriority);


void __RPC_STUB IAMTimelineVirtualTrack_TrackGetPriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineVirtualTrack_SetTrackDirty_Proxy( 
    IAMTimelineVirtualTrack * This);


void __RPC_STUB IAMTimelineVirtualTrack_SetTrackDirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMTimelineVirtualTrack_INTERFACE_DEFINED__ */


#ifndef __IAMTimelineComp_INTERFACE_DEFINED__
#define __IAMTimelineComp_INTERFACE_DEFINED__

/* interface IAMTimelineComp */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMTimelineComp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EAE58536-622E-11d2-8CAD-00A024580902")
    IAMTimelineComp : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE VTrackInsBefore( 
            IAMTimelineObj *pVirtualTrack,
            long Priority) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE VTrackSwapPriorities( 
            long VirtualTrackA,
            long VirtualTrackB) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE VTrackGetCount( 
            long *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVTrack( 
            /* [out] */ IAMTimelineObj **ppVirtualTrack,
            long Which) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCountOfType( 
            long *pVal,
            long *pValWithComps,
            TIMELINE_MAJOR_TYPE MajorType) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetRecursiveLayerOfType( 
            /* [out] */ IAMTimelineObj **ppVirtualTrack,
            long WhichLayer,
            TIMELINE_MAJOR_TYPE Type) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetRecursiveLayerOfTypeI( 
            /* [out] */ IAMTimelineObj **ppVirtualTrack,
            /* [out][in] */ long *pWhichLayer,
            TIMELINE_MAJOR_TYPE Type) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextVTrack( 
            IAMTimelineObj *pVirtualTrack,
            /* [out] */ IAMTimelineObj **ppNextVirtualTrack) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimelineCompVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimelineComp * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimelineComp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimelineComp * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *VTrackInsBefore )( 
            IAMTimelineComp * This,
            IAMTimelineObj *pVirtualTrack,
            long Priority);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *VTrackSwapPriorities )( 
            IAMTimelineComp * This,
            long VirtualTrackA,
            long VirtualTrackB);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *VTrackGetCount )( 
            IAMTimelineComp * This,
            long *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetVTrack )( 
            IAMTimelineComp * This,
            /* [out] */ IAMTimelineObj **ppVirtualTrack,
            long Which);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCountOfType )( 
            IAMTimelineComp * This,
            long *pVal,
            long *pValWithComps,
            TIMELINE_MAJOR_TYPE MajorType);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetRecursiveLayerOfType )( 
            IAMTimelineComp * This,
            /* [out] */ IAMTimelineObj **ppVirtualTrack,
            long WhichLayer,
            TIMELINE_MAJOR_TYPE Type);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetRecursiveLayerOfTypeI )( 
            IAMTimelineComp * This,
            /* [out] */ IAMTimelineObj **ppVirtualTrack,
            /* [out][in] */ long *pWhichLayer,
            TIMELINE_MAJOR_TYPE Type);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextVTrack )( 
            IAMTimelineComp * This,
            IAMTimelineObj *pVirtualTrack,
            /* [out] */ IAMTimelineObj **ppNextVirtualTrack);
        
        END_INTERFACE
    } IAMTimelineCompVtbl;

    interface IAMTimelineComp
    {
        CONST_VTBL struct IAMTimelineCompVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimelineComp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMTimelineComp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMTimelineComp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMTimelineComp_VTrackInsBefore(This,pVirtualTrack,Priority)	\
    (This)->lpVtbl -> VTrackInsBefore(This,pVirtualTrack,Priority)

#define IAMTimelineComp_VTrackSwapPriorities(This,VirtualTrackA,VirtualTrackB)	\
    (This)->lpVtbl -> VTrackSwapPriorities(This,VirtualTrackA,VirtualTrackB)

#define IAMTimelineComp_VTrackGetCount(This,pVal)	\
    (This)->lpVtbl -> VTrackGetCount(This,pVal)

#define IAMTimelineComp_GetVTrack(This,ppVirtualTrack,Which)	\
    (This)->lpVtbl -> GetVTrack(This,ppVirtualTrack,Which)

#define IAMTimelineComp_GetCountOfType(This,pVal,pValWithComps,MajorType)	\
    (This)->lpVtbl -> GetCountOfType(This,pVal,pValWithComps,MajorType)

#define IAMTimelineComp_GetRecursiveLayerOfType(This,ppVirtualTrack,WhichLayer,Type)	\
    (This)->lpVtbl -> GetRecursiveLayerOfType(This,ppVirtualTrack,WhichLayer,Type)

#define IAMTimelineComp_GetRecursiveLayerOfTypeI(This,ppVirtualTrack,pWhichLayer,Type)	\
    (This)->lpVtbl -> GetRecursiveLayerOfTypeI(This,ppVirtualTrack,pWhichLayer,Type)

#define IAMTimelineComp_GetNextVTrack(This,pVirtualTrack,ppNextVirtualTrack)	\
    (This)->lpVtbl -> GetNextVTrack(This,pVirtualTrack,ppNextVirtualTrack)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineComp_VTrackInsBefore_Proxy( 
    IAMTimelineComp * This,
    IAMTimelineObj *pVirtualTrack,
    long Priority);


void __RPC_STUB IAMTimelineComp_VTrackInsBefore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineComp_VTrackSwapPriorities_Proxy( 
    IAMTimelineComp * This,
    long VirtualTrackA,
    long VirtualTrackB);


void __RPC_STUB IAMTimelineComp_VTrackSwapPriorities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineComp_VTrackGetCount_Proxy( 
    IAMTimelineComp * This,
    long *pVal);


void __RPC_STUB IAMTimelineComp_VTrackGetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineComp_GetVTrack_Proxy( 
    IAMTimelineComp * This,
    /* [out] */ IAMTimelineObj **ppVirtualTrack,
    long Which);


void __RPC_STUB IAMTimelineComp_GetVTrack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineComp_GetCountOfType_Proxy( 
    IAMTimelineComp * This,
    long *pVal,
    long *pValWithComps,
    TIMELINE_MAJOR_TYPE MajorType);


void __RPC_STUB IAMTimelineComp_GetCountOfType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineComp_GetRecursiveLayerOfType_Proxy( 
    IAMTimelineComp * This,
    /* [out] */ IAMTimelineObj **ppVirtualTrack,
    long WhichLayer,
    TIMELINE_MAJOR_TYPE Type);


void __RPC_STUB IAMTimelineComp_GetRecursiveLayerOfType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineComp_GetRecursiveLayerOfTypeI_Proxy( 
    IAMTimelineComp * This,
    /* [out] */ IAMTimelineObj **ppVirtualTrack,
    /* [out][in] */ long *pWhichLayer,
    TIMELINE_MAJOR_TYPE Type);


void __RPC_STUB IAMTimelineComp_GetRecursiveLayerOfTypeI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimelineComp_GetNextVTrack_Proxy( 
    IAMTimelineComp * This,
    IAMTimelineObj *pVirtualTrack,
    /* [out] */ IAMTimelineObj **ppNextVirtualTrack);


void __RPC_STUB IAMTimelineComp_GetNextVTrack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMTimelineComp_INTERFACE_DEFINED__ */


#ifndef __IAMTimelineGroup_INTERFACE_DEFINED__
#define __IAMTimelineGroup_INTERFACE_DEFINED__

/* interface IAMTimelineGroup */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMTimelineGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9EED4F00-B8A6-11d2-8023-00C0DF10D434")
    IAMTimelineGroup : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetTimeline( 
            IAMTimeline *pTimeline) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTimeline( 
            /* [out] */ IAMTimeline **ppTimeline) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPriority( 
            long *pPriority) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMediaType( 
            /* [out] */ AM_MEDIA_TYPE *__MIDL_0040) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMediaType( 
            /* [in] */ AM_MEDIA_TYPE *__MIDL_0041) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetOutputFPS( 
            double FPS) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetOutputFPS( 
            double *pFPS) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetGroupName( 
            BSTR pGroupName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetGroupName( 
            /* [retval][out] */ BSTR *pGroupName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetPreviewMode( 
            BOOL fPreview) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPreviewMode( 
            BOOL *pfPreview) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMediaTypeForVB( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetOutputBuffering( 
            /* [out] */ int *pnBuffer) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetOutputBuffering( 
            /* [in] */ int nBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSmartRecompressFormat( 
            long *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSmartRecompressFormat( 
            long **ppFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSmartRecompressFormatSet( 
            BOOL *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsRecompressFormatDirty( 
            BOOL *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearRecompressFormatDirty( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRecompFormatFromSource( 
            IAMTimelineSrc *pSource) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimelineGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimelineGroup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimelineGroup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimelineGroup * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetTimeline )( 
            IAMTimelineGroup * This,
            IAMTimeline *pTimeline);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTimeline )( 
            IAMTimelineGroup * This,
            /* [out] */ IAMTimeline **ppTimeline);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPriority )( 
            IAMTimelineGroup * This,
            long *pPriority);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMediaType )( 
            IAMTimelineGroup * This,
            /* [out] */ AM_MEDIA_TYPE *__MIDL_0040);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMediaType )( 
            IAMTimelineGroup * This,
            /* [in] */ AM_MEDIA_TYPE *__MIDL_0041);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetOutputFPS )( 
            IAMTimelineGroup * This,
            double FPS);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetOutputFPS )( 
            IAMTimelineGroup * This,
            double *pFPS);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetGroupName )( 
            IAMTimelineGroup * This,
            BSTR pGroupName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetGroupName )( 
            IAMTimelineGroup * This,
            /* [retval][out] */ BSTR *pGroupName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetPreviewMode )( 
            IAMTimelineGroup * This,
            BOOL fPreview);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPreviewMode )( 
            IAMTimelineGroup * This,
            BOOL *pfPreview);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMediaTypeForVB )( 
            IAMTimelineGroup * This,
            /* [in] */ long Val);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetOutputBuffering )( 
            IAMTimelineGroup * This,
            /* [out] */ int *pnBuffer);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetOutputBuffering )( 
            IAMTimelineGroup * This,
            /* [in] */ int nBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *SetSmartRecompressFormat )( 
            IAMTimelineGroup * This,
            long *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetSmartRecompressFormat )( 
            IAMTimelineGroup * This,
            long **ppFormat);
        
        HRESULT ( STDMETHODCALLTYPE *IsSmartRecompressFormatSet )( 
            IAMTimelineGroup * This,
            BOOL *pVal);
        
        HRESULT ( STDMETHODCALLTYPE *IsRecompressFormatDirty )( 
            IAMTimelineGroup * This,
            BOOL *pVal);
        
        HRESULT ( STDMETHODCALLTYPE *ClearRecompressFormatDirty )( 
            IAMTimelineGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetRecompFormatFromSource )( 
            IAMTimelineGroup * This,
            IAMTimelineSrc *pSource);
        
        END_INTERFACE
    } IAMTimelineGroupVtbl;

    interface IAMTimelineGroup
    {
        CONST_VTBL struct IAMTimelineGroupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimelineGroup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMTimelineGroup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMTimelineGroup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMTimelineGroup_SetTimeline(This,pTimeline)	\
    (This)->lpVtbl -> SetTimeline(This,pTimeline)

#define IAMTimelineGroup_GetTimeline(This,ppTimeline)	\
    (This)->lpVtbl -> GetTimeline(This,ppTimeline)

#define IAMTimelineGroup_GetPriority(This,pPriority)	\
    (This)->lpVtbl -> GetPriority(This,pPriority)

#define IAMTimelineGroup_GetMediaType(This,__MIDL_0040)	\
    (This)->lpVtbl -> GetMediaType(This,__MIDL_0040)

#define IAMTimelineGroup_SetMediaType(This,__MIDL_0041)	\
    (This)->lpVtbl -> SetMediaType(This,__MIDL_0041)

#define IAMTimelineGroup_SetOutputFPS(This,FPS)	\
    (This)->lpVtbl -> SetOutputFPS(This,FPS)

#define IAMTimelineGroup_GetOutputFPS(This,pFPS)	\
    (This)->lpVtbl -> GetOutputFPS(This,pFPS)

#define IAMTimelineGroup_SetGroupName(This,pGroupName)	\
    (This)->lpVtbl -> SetGroupName(This,pGroupName)

#define IAMTimelineGroup_GetGroupName(This,pGroupName)	\
    (This)->lpVtbl -> GetGroupName(This,pGroupName)

#define IAMTimelineGroup_SetPreviewMode(This,fPreview)	\
    (This)->lpVtbl -> SetPreviewMode(This,fPreview)

#define IAMTimelineGroup_GetPreviewMode(This,pfPreview)	\
    (This)->lpVtbl -> GetPreviewMode(This,pfPreview)

#define IAMTimelineGroup_SetMediaTypeForVB(This,Val)	\
    (This)->lpVtbl -> SetMediaTypeForVB(This,Val)

#define IAMTimelineGroup_GetOutputBuffering(This,pnBuffer)	\
    (This)->lpVtbl -> GetOutputBuffering(This,pnBuffer)

#define IAMTimelineGroup_SetOutputBuffering(This,nBuffer)	\
    (This)->lpVtbl -> SetOutputBuffering(This,nBuffer)

#define IAMTimelineGroup_SetSmartRecompressFormat(This,pFormat)	\
    (This)->lpVtbl -> SetSmartRecompressFormat(This,pFormat)

#define IAMTimelineGroup_GetSmartRecompressFormat(This,ppFormat)	\
    (This)->lpVtbl -> GetSmartRecompressFormat(This,ppFormat)

#define IAMTimelineGroup_IsSmartRecompressFormatSet(This,pVal)	\
    (This)->lpVtbl -> IsSmartRecompressFormatSet(This,pVal)

#define IAMTimelineGroup_IsRecompressFormatDirty(This,pVal)	\
    (This)->lpVtbl -> IsRecompressFormatDirty(This,pVal)

#define IAMTimelineGroup_ClearRecompressFormatDirty(This)	\
    (This)->lpVtbl -> ClearRecompressFormatDirty(This)

#define IAMTimelineGroup_SetRecompFormatFromSource(This,pSource)	\
    (This)->lpVtbl -> SetRecompFormatFromSource(This,pSource)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineGroup_SetTimeline_Proxy( 
    IAMTimelineGroup * This,
    IAMTimeline *pTimeline);


void __RPC_STUB IAMTimelineGroup_SetTimeline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineGroup_GetTimeline_Proxy( 
    IAMTimelineGroup * This,
    /* [out] */ IAMTimeline **ppTimeline);


void __RPC_STUB IAMTimelineGroup_GetTimeline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineGroup_GetPriority_Proxy( 
    IAMTimelineGroup * This,
    long *pPriority);


void __RPC_STUB IAMTimelineGroup_GetPriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineGroup_GetMediaType_Proxy( 
    IAMTimelineGroup * This,
    /* [out] */ AM_MEDIA_TYPE *__MIDL_0040);


void __RPC_STUB IAMTimelineGroup_GetMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineGroup_SetMediaType_Proxy( 
    IAMTimelineGroup * This,
    /* [in] */ AM_MEDIA_TYPE *__MIDL_0041);


void __RPC_STUB IAMTimelineGroup_SetMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineGroup_SetOutputFPS_Proxy( 
    IAMTimelineGroup * This,
    double FPS);


void __RPC_STUB IAMTimelineGroup_SetOutputFPS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineGroup_GetOutputFPS_Proxy( 
    IAMTimelineGroup * This,
    double *pFPS);


void __RPC_STUB IAMTimelineGroup_GetOutputFPS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineGroup_SetGroupName_Proxy( 
    IAMTimelineGroup * This,
    BSTR pGroupName);


void __RPC_STUB IAMTimelineGroup_SetGroupName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineGroup_GetGroupName_Proxy( 
    IAMTimelineGroup * This,
    /* [retval][out] */ BSTR *pGroupName);


void __RPC_STUB IAMTimelineGroup_GetGroupName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineGroup_SetPreviewMode_Proxy( 
    IAMTimelineGroup * This,
    BOOL fPreview);


void __RPC_STUB IAMTimelineGroup_SetPreviewMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineGroup_GetPreviewMode_Proxy( 
    IAMTimelineGroup * This,
    BOOL *pfPreview);


void __RPC_STUB IAMTimelineGroup_GetPreviewMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineGroup_SetMediaTypeForVB_Proxy( 
    IAMTimelineGroup * This,
    /* [in] */ long Val);


void __RPC_STUB IAMTimelineGroup_SetMediaTypeForVB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineGroup_GetOutputBuffering_Proxy( 
    IAMTimelineGroup * This,
    /* [out] */ int *pnBuffer);


void __RPC_STUB IAMTimelineGroup_GetOutputBuffering_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineGroup_SetOutputBuffering_Proxy( 
    IAMTimelineGroup * This,
    /* [in] */ int nBuffer);


void __RPC_STUB IAMTimelineGroup_SetOutputBuffering_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimelineGroup_SetSmartRecompressFormat_Proxy( 
    IAMTimelineGroup * This,
    long *pFormat);


void __RPC_STUB IAMTimelineGroup_SetSmartRecompressFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimelineGroup_GetSmartRecompressFormat_Proxy( 
    IAMTimelineGroup * This,
    long **ppFormat);


void __RPC_STUB IAMTimelineGroup_GetSmartRecompressFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimelineGroup_IsSmartRecompressFormatSet_Proxy( 
    IAMTimelineGroup * This,
    BOOL *pVal);


void __RPC_STUB IAMTimelineGroup_IsSmartRecompressFormatSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimelineGroup_IsRecompressFormatDirty_Proxy( 
    IAMTimelineGroup * This,
    BOOL *pVal);


void __RPC_STUB IAMTimelineGroup_IsRecompressFormatDirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimelineGroup_ClearRecompressFormatDirty_Proxy( 
    IAMTimelineGroup * This);


void __RPC_STUB IAMTimelineGroup_ClearRecompressFormatDirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimelineGroup_SetRecompFormatFromSource_Proxy( 
    IAMTimelineGroup * This,
    IAMTimelineSrc *pSource);


void __RPC_STUB IAMTimelineGroup_SetRecompFormatFromSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMTimelineGroup_INTERFACE_DEFINED__ */


#ifndef __IAMTimeline_INTERFACE_DEFINED__
#define __IAMTimeline_INTERFACE_DEFINED__

/* interface IAMTimeline */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMTimeline;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("78530B74-61F9-11D2-8CAD-00A024580902")
    IAMTimeline : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateEmptyNode( 
            /* [out] */ IAMTimelineObj **ppObj,
            TIMELINE_MAJOR_TYPE Type) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddGroup( 
            IAMTimelineObj *pGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemGroupFromList( 
            IAMTimelineObj *pGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroup( 
            /* [out] */ IAMTimelineObj **ppGroup,
            long WhichGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroupCount( 
            long *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearAllGroups( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInsertMode( 
            long *pMode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetInsertMode( 
            long Mode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnableTransitions( 
            BOOL fEnabled) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TransitionsEnabled( 
            BOOL *pfEnabled) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnableEffects( 
            BOOL fEnabled) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EffectsEnabled( 
            BOOL *pfEnabled) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetInterestRange( 
            REFERENCE_TIME Start,
            REFERENCE_TIME Stop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDuration( 
            REFERENCE_TIME *pDuration) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDuration2( 
            double *pDuration) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDefaultFPS( 
            double FPS) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDefaultFPS( 
            double *pFPS) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsDirty( 
            BOOL *pDirty) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDirtyRange( 
            REFERENCE_TIME *pStart,
            REFERENCE_TIME *pStop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCountOfType( 
            long Group,
            long *pVal,
            long *pValWithComps,
            TIMELINE_MAJOR_TYPE MajorType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ValidateSourceNames( 
            long ValidateFlags,
            IMediaLocator *pOverride,
            LONG_PTR NotifyEventHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultTransition( 
            GUID *pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultTransition( 
            GUID *pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultEffect( 
            GUID *pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultEffect( 
            GUID *pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultTransitionB( 
            BSTR pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultTransitionB( 
            /* [retval][out] */ BSTR *pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultEffectB( 
            BSTR pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultEffectB( 
            /* [retval][out] */ BSTR *pGuid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimelineVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimeline * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimeline * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimeline * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateEmptyNode )( 
            IAMTimeline * This,
            /* [out] */ IAMTimelineObj **ppObj,
            TIMELINE_MAJOR_TYPE Type);
        
        HRESULT ( STDMETHODCALLTYPE *AddGroup )( 
            IAMTimeline * This,
            IAMTimelineObj *pGroup);
        
        HRESULT ( STDMETHODCALLTYPE *RemGroupFromList )( 
            IAMTimeline * This,
            IAMTimelineObj *pGroup);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroup )( 
            IAMTimeline * This,
            /* [out] */ IAMTimelineObj **ppGroup,
            long WhichGroup);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupCount )( 
            IAMTimeline * This,
            long *pCount);
        
        HRESULT ( STDMETHODCALLTYPE *ClearAllGroups )( 
            IAMTimeline * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInsertMode )( 
            IAMTimeline * This,
            long *pMode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetInsertMode )( 
            IAMTimeline * This,
            long Mode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnableTransitions )( 
            IAMTimeline * This,
            BOOL fEnabled);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TransitionsEnabled )( 
            IAMTimeline * This,
            BOOL *pfEnabled);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnableEffects )( 
            IAMTimeline * This,
            BOOL fEnabled);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EffectsEnabled )( 
            IAMTimeline * This,
            BOOL *pfEnabled);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetInterestRange )( 
            IAMTimeline * This,
            REFERENCE_TIME Start,
            REFERENCE_TIME Stop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDuration )( 
            IAMTimeline * This,
            REFERENCE_TIME *pDuration);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDuration2 )( 
            IAMTimeline * This,
            double *pDuration);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetDefaultFPS )( 
            IAMTimeline * This,
            double FPS);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDefaultFPS )( 
            IAMTimeline * This,
            double *pFPS);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsDirty )( 
            IAMTimeline * This,
            BOOL *pDirty);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDirtyRange )( 
            IAMTimeline * This,
            REFERENCE_TIME *pStart,
            REFERENCE_TIME *pStop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCountOfType )( 
            IAMTimeline * This,
            long Group,
            long *pVal,
            long *pValWithComps,
            TIMELINE_MAJOR_TYPE MajorType);
        
        HRESULT ( STDMETHODCALLTYPE *ValidateSourceNames )( 
            IAMTimeline * This,
            long ValidateFlags,
            IMediaLocator *pOverride,
            LONG_PTR NotifyEventHandle);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultTransition )( 
            IAMTimeline * This,
            GUID *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultTransition )( 
            IAMTimeline * This,
            GUID *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultEffect )( 
            IAMTimeline * This,
            GUID *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultEffect )( 
            IAMTimeline * This,
            GUID *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultTransitionB )( 
            IAMTimeline * This,
            BSTR pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultTransitionB )( 
            IAMTimeline * This,
            /* [retval][out] */ BSTR *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultEffectB )( 
            IAMTimeline * This,
            BSTR pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultEffectB )( 
            IAMTimeline * This,
            /* [retval][out] */ BSTR *pGuid);
        
        END_INTERFACE
    } IAMTimelineVtbl;

    interface IAMTimeline
    {
        CONST_VTBL struct IAMTimelineVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimeline_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMTimeline_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMTimeline_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMTimeline_CreateEmptyNode(This,ppObj,Type)	\
    (This)->lpVtbl -> CreateEmptyNode(This,ppObj,Type)

#define IAMTimeline_AddGroup(This,pGroup)	\
    (This)->lpVtbl -> AddGroup(This,pGroup)

#define IAMTimeline_RemGroupFromList(This,pGroup)	\
    (This)->lpVtbl -> RemGroupFromList(This,pGroup)

#define IAMTimeline_GetGroup(This,ppGroup,WhichGroup)	\
    (This)->lpVtbl -> GetGroup(This,ppGroup,WhichGroup)

#define IAMTimeline_GetGroupCount(This,pCount)	\
    (This)->lpVtbl -> GetGroupCount(This,pCount)

#define IAMTimeline_ClearAllGroups(This)	\
    (This)->lpVtbl -> ClearAllGroups(This)

#define IAMTimeline_GetInsertMode(This,pMode)	\
    (This)->lpVtbl -> GetInsertMode(This,pMode)

#define IAMTimeline_SetInsertMode(This,Mode)	\
    (This)->lpVtbl -> SetInsertMode(This,Mode)

#define IAMTimeline_EnableTransitions(This,fEnabled)	\
    (This)->lpVtbl -> EnableTransitions(This,fEnabled)

#define IAMTimeline_TransitionsEnabled(This,pfEnabled)	\
    (This)->lpVtbl -> TransitionsEnabled(This,pfEnabled)

#define IAMTimeline_EnableEffects(This,fEnabled)	\
    (This)->lpVtbl -> EnableEffects(This,fEnabled)

#define IAMTimeline_EffectsEnabled(This,pfEnabled)	\
    (This)->lpVtbl -> EffectsEnabled(This,pfEnabled)

#define IAMTimeline_SetInterestRange(This,Start,Stop)	\
    (This)->lpVtbl -> SetInterestRange(This,Start,Stop)

#define IAMTimeline_GetDuration(This,pDuration)	\
    (This)->lpVtbl -> GetDuration(This,pDuration)

#define IAMTimeline_GetDuration2(This,pDuration)	\
    (This)->lpVtbl -> GetDuration2(This,pDuration)

#define IAMTimeline_SetDefaultFPS(This,FPS)	\
    (This)->lpVtbl -> SetDefaultFPS(This,FPS)

#define IAMTimeline_GetDefaultFPS(This,pFPS)	\
    (This)->lpVtbl -> GetDefaultFPS(This,pFPS)

#define IAMTimeline_IsDirty(This,pDirty)	\
    (This)->lpVtbl -> IsDirty(This,pDirty)

#define IAMTimeline_GetDirtyRange(This,pStart,pStop)	\
    (This)->lpVtbl -> GetDirtyRange(This,pStart,pStop)

#define IAMTimeline_GetCountOfType(This,Group,pVal,pValWithComps,MajorType)	\
    (This)->lpVtbl -> GetCountOfType(This,Group,pVal,pValWithComps,MajorType)

#define IAMTimeline_ValidateSourceNames(This,ValidateFlags,pOverride,NotifyEventHandle)	\
    (This)->lpVtbl -> ValidateSourceNames(This,ValidateFlags,pOverride,NotifyEventHandle)

#define IAMTimeline_SetDefaultTransition(This,pGuid)	\
    (This)->lpVtbl -> SetDefaultTransition(This,pGuid)

#define IAMTimeline_GetDefaultTransition(This,pGuid)	\
    (This)->lpVtbl -> GetDefaultTransition(This,pGuid)

#define IAMTimeline_SetDefaultEffect(This,pGuid)	\
    (This)->lpVtbl -> SetDefaultEffect(This,pGuid)

#define IAMTimeline_GetDefaultEffect(This,pGuid)	\
    (This)->lpVtbl -> GetDefaultEffect(This,pGuid)

#define IAMTimeline_SetDefaultTransitionB(This,pGuid)	\
    (This)->lpVtbl -> SetDefaultTransitionB(This,pGuid)

#define IAMTimeline_GetDefaultTransitionB(This,pGuid)	\
    (This)->lpVtbl -> GetDefaultTransitionB(This,pGuid)

#define IAMTimeline_SetDefaultEffectB(This,pGuid)	\
    (This)->lpVtbl -> SetDefaultEffectB(This,pGuid)

#define IAMTimeline_GetDefaultEffectB(This,pGuid)	\
    (This)->lpVtbl -> GetDefaultEffectB(This,pGuid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimeline_CreateEmptyNode_Proxy( 
    IAMTimeline * This,
    /* [out] */ IAMTimelineObj **ppObj,
    TIMELINE_MAJOR_TYPE Type);


void __RPC_STUB IAMTimeline_CreateEmptyNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_AddGroup_Proxy( 
    IAMTimeline * This,
    IAMTimelineObj *pGroup);


void __RPC_STUB IAMTimeline_AddGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_RemGroupFromList_Proxy( 
    IAMTimeline * This,
    IAMTimelineObj *pGroup);


void __RPC_STUB IAMTimeline_RemGroupFromList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_GetGroup_Proxy( 
    IAMTimeline * This,
    /* [out] */ IAMTimelineObj **ppGroup,
    long WhichGroup);


void __RPC_STUB IAMTimeline_GetGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_GetGroupCount_Proxy( 
    IAMTimeline * This,
    long *pCount);


void __RPC_STUB IAMTimeline_GetGroupCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_ClearAllGroups_Proxy( 
    IAMTimeline * This);


void __RPC_STUB IAMTimeline_ClearAllGroups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_GetInsertMode_Proxy( 
    IAMTimeline * This,
    long *pMode);


void __RPC_STUB IAMTimeline_GetInsertMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimeline_SetInsertMode_Proxy( 
    IAMTimeline * This,
    long Mode);


void __RPC_STUB IAMTimeline_SetInsertMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimeline_EnableTransitions_Proxy( 
    IAMTimeline * This,
    BOOL fEnabled);


void __RPC_STUB IAMTimeline_EnableTransitions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimeline_TransitionsEnabled_Proxy( 
    IAMTimeline * This,
    BOOL *pfEnabled);


void __RPC_STUB IAMTimeline_TransitionsEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimeline_EnableEffects_Proxy( 
    IAMTimeline * This,
    BOOL fEnabled);


void __RPC_STUB IAMTimeline_EnableEffects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimeline_EffectsEnabled_Proxy( 
    IAMTimeline * This,
    BOOL *pfEnabled);


void __RPC_STUB IAMTimeline_EffectsEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimeline_SetInterestRange_Proxy( 
    IAMTimeline * This,
    REFERENCE_TIME Start,
    REFERENCE_TIME Stop);


void __RPC_STUB IAMTimeline_SetInterestRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimeline_GetDuration_Proxy( 
    IAMTimeline * This,
    REFERENCE_TIME *pDuration);


void __RPC_STUB IAMTimeline_GetDuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimeline_GetDuration2_Proxy( 
    IAMTimeline * This,
    double *pDuration);


void __RPC_STUB IAMTimeline_GetDuration2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimeline_SetDefaultFPS_Proxy( 
    IAMTimeline * This,
    double FPS);


void __RPC_STUB IAMTimeline_SetDefaultFPS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimeline_GetDefaultFPS_Proxy( 
    IAMTimeline * This,
    double *pFPS);


void __RPC_STUB IAMTimeline_GetDefaultFPS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimeline_IsDirty_Proxy( 
    IAMTimeline * This,
    BOOL *pDirty);


void __RPC_STUB IAMTimeline_IsDirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimeline_GetDirtyRange_Proxy( 
    IAMTimeline * This,
    REFERENCE_TIME *pStart,
    REFERENCE_TIME *pStop);


void __RPC_STUB IAMTimeline_GetDirtyRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimeline_GetCountOfType_Proxy( 
    IAMTimeline * This,
    long Group,
    long *pVal,
    long *pValWithComps,
    TIMELINE_MAJOR_TYPE MajorType);


void __RPC_STUB IAMTimeline_GetCountOfType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_ValidateSourceNames_Proxy( 
    IAMTimeline * This,
    long ValidateFlags,
    IMediaLocator *pOverride,
    LONG_PTR NotifyEventHandle);


void __RPC_STUB IAMTimeline_ValidateSourceNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_SetDefaultTransition_Proxy( 
    IAMTimeline * This,
    GUID *pGuid);


void __RPC_STUB IAMTimeline_SetDefaultTransition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_GetDefaultTransition_Proxy( 
    IAMTimeline * This,
    GUID *pGuid);


void __RPC_STUB IAMTimeline_GetDefaultTransition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_SetDefaultEffect_Proxy( 
    IAMTimeline * This,
    GUID *pGuid);


void __RPC_STUB IAMTimeline_SetDefaultEffect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_GetDefaultEffect_Proxy( 
    IAMTimeline * This,
    GUID *pGuid);


void __RPC_STUB IAMTimeline_GetDefaultEffect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_SetDefaultTransitionB_Proxy( 
    IAMTimeline * This,
    BSTR pGuid);


void __RPC_STUB IAMTimeline_SetDefaultTransitionB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_GetDefaultTransitionB_Proxy( 
    IAMTimeline * This,
    /* [retval][out] */ BSTR *pGuid);


void __RPC_STUB IAMTimeline_GetDefaultTransitionB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_SetDefaultEffectB_Proxy( 
    IAMTimeline * This,
    BSTR pGuid);


void __RPC_STUB IAMTimeline_SetDefaultEffectB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_GetDefaultEffectB_Proxy( 
    IAMTimeline * This,
    /* [retval][out] */ BSTR *pGuid);


void __RPC_STUB IAMTimeline_GetDefaultEffectB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMTimeline_INTERFACE_DEFINED__ */


#ifndef __IXml2Dex_INTERFACE_DEFINED__
#define __IXml2Dex_INTERFACE_DEFINED__

/* interface IXml2Dex */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IXml2Dex;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("18C628ED-962A-11D2-8D08-00A0C9441E20")
    IXml2Dex : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateGraphFromFile( 
            /* [out] */ IUnknown **ppGraph,
            IUnknown *pTimeline,
            BSTR Filename) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE WriteGrfFile( 
            IUnknown *pGraph,
            BSTR FileName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE WriteXMLFile( 
            IUnknown *pTimeline,
            BSTR FileName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReadXMLFile( 
            IUnknown *pTimeline,
            BSTR XMLName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( 
            IUnknown *pTimeline,
            double dStart,
            double dEnd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE WriteXMLPart( 
            IUnknown *pTimeline,
            double dStart,
            double dEnd,
            BSTR FileName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PasteXMLFile( 
            IUnknown *pTimeline,
            double dStart,
            BSTR FileName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CopyXML( 
            IUnknown *pTimeline,
            double dStart,
            double dEnd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PasteXML( 
            IUnknown *pTimeline,
            double dStart) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReadXML( 
            IUnknown *pTimeline,
            IUnknown *pXML) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE WriteXML( 
            IUnknown *pTimeline,
            BSTR *pbstrXML) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXml2DexVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXml2Dex * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXml2Dex * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXml2Dex * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXml2Dex * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXml2Dex * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXml2Dex * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXml2Dex * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateGraphFromFile )( 
            IXml2Dex * This,
            /* [out] */ IUnknown **ppGraph,
            IUnknown *pTimeline,
            BSTR Filename);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *WriteGrfFile )( 
            IXml2Dex * This,
            IUnknown *pGraph,
            BSTR FileName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *WriteXMLFile )( 
            IXml2Dex * This,
            IUnknown *pTimeline,
            BSTR FileName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ReadXMLFile )( 
            IXml2Dex * This,
            IUnknown *pTimeline,
            BSTR XMLName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IXml2Dex * This,
            IUnknown *pTimeline,
            double dStart,
            double dEnd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *WriteXMLPart )( 
            IXml2Dex * This,
            IUnknown *pTimeline,
            double dStart,
            double dEnd,
            BSTR FileName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PasteXMLFile )( 
            IXml2Dex * This,
            IUnknown *pTimeline,
            double dStart,
            BSTR FileName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CopyXML )( 
            IXml2Dex * This,
            IUnknown *pTimeline,
            double dStart,
            double dEnd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PasteXML )( 
            IXml2Dex * This,
            IUnknown *pTimeline,
            double dStart);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IXml2Dex * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ReadXML )( 
            IXml2Dex * This,
            IUnknown *pTimeline,
            IUnknown *pXML);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *WriteXML )( 
            IXml2Dex * This,
            IUnknown *pTimeline,
            BSTR *pbstrXML);
        
        END_INTERFACE
    } IXml2DexVtbl;

    interface IXml2Dex
    {
        CONST_VTBL struct IXml2DexVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXml2Dex_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXml2Dex_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXml2Dex_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXml2Dex_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXml2Dex_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXml2Dex_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXml2Dex_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXml2Dex_CreateGraphFromFile(This,ppGraph,pTimeline,Filename)	\
    (This)->lpVtbl -> CreateGraphFromFile(This,ppGraph,pTimeline,Filename)

#define IXml2Dex_WriteGrfFile(This,pGraph,FileName)	\
    (This)->lpVtbl -> WriteGrfFile(This,pGraph,FileName)

#define IXml2Dex_WriteXMLFile(This,pTimeline,FileName)	\
    (This)->lpVtbl -> WriteXMLFile(This,pTimeline,FileName)

#define IXml2Dex_ReadXMLFile(This,pTimeline,XMLName)	\
    (This)->lpVtbl -> ReadXMLFile(This,pTimeline,XMLName)

#define IXml2Dex_Delete(This,pTimeline,dStart,dEnd)	\
    (This)->lpVtbl -> Delete(This,pTimeline,dStart,dEnd)

#define IXml2Dex_WriteXMLPart(This,pTimeline,dStart,dEnd,FileName)	\
    (This)->lpVtbl -> WriteXMLPart(This,pTimeline,dStart,dEnd,FileName)

#define IXml2Dex_PasteXMLFile(This,pTimeline,dStart,FileName)	\
    (This)->lpVtbl -> PasteXMLFile(This,pTimeline,dStart,FileName)

#define IXml2Dex_CopyXML(This,pTimeline,dStart,dEnd)	\
    (This)->lpVtbl -> CopyXML(This,pTimeline,dStart,dEnd)

#define IXml2Dex_PasteXML(This,pTimeline,dStart)	\
    (This)->lpVtbl -> PasteXML(This,pTimeline,dStart)

#define IXml2Dex_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IXml2Dex_ReadXML(This,pTimeline,pXML)	\
    (This)->lpVtbl -> ReadXML(This,pTimeline,pXML)

#define IXml2Dex_WriteXML(This,pTimeline,pbstrXML)	\
    (This)->lpVtbl -> WriteXML(This,pTimeline,pbstrXML)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXml2Dex_CreateGraphFromFile_Proxy( 
    IXml2Dex * This,
    /* [out] */ IUnknown **ppGraph,
    IUnknown *pTimeline,
    BSTR Filename);


void __RPC_STUB IXml2Dex_CreateGraphFromFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXml2Dex_WriteGrfFile_Proxy( 
    IXml2Dex * This,
    IUnknown *pGraph,
    BSTR FileName);


void __RPC_STUB IXml2Dex_WriteGrfFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXml2Dex_WriteXMLFile_Proxy( 
    IXml2Dex * This,
    IUnknown *pTimeline,
    BSTR FileName);


void __RPC_STUB IXml2Dex_WriteXMLFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXml2Dex_ReadXMLFile_Proxy( 
    IXml2Dex * This,
    IUnknown *pTimeline,
    BSTR XMLName);


void __RPC_STUB IXml2Dex_ReadXMLFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXml2Dex_Delete_Proxy( 
    IXml2Dex * This,
    IUnknown *pTimeline,
    double dStart,
    double dEnd);


void __RPC_STUB IXml2Dex_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXml2Dex_WriteXMLPart_Proxy( 
    IXml2Dex * This,
    IUnknown *pTimeline,
    double dStart,
    double dEnd,
    BSTR FileName);


void __RPC_STUB IXml2Dex_WriteXMLPart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXml2Dex_PasteXMLFile_Proxy( 
    IXml2Dex * This,
    IUnknown *pTimeline,
    double dStart,
    BSTR FileName);


void __RPC_STUB IXml2Dex_PasteXMLFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXml2Dex_CopyXML_Proxy( 
    IXml2Dex * This,
    IUnknown *pTimeline,
    double dStart,
    double dEnd);


void __RPC_STUB IXml2Dex_CopyXML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXml2Dex_PasteXML_Proxy( 
    IXml2Dex * This,
    IUnknown *pTimeline,
    double dStart);


void __RPC_STUB IXml2Dex_PasteXML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXml2Dex_Reset_Proxy( 
    IXml2Dex * This);


void __RPC_STUB IXml2Dex_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXml2Dex_ReadXML_Proxy( 
    IXml2Dex * This,
    IUnknown *pTimeline,
    IUnknown *pXML);


void __RPC_STUB IXml2Dex_ReadXML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXml2Dex_WriteXML_Proxy( 
    IXml2Dex * This,
    IUnknown *pTimeline,
    BSTR *pbstrXML);


void __RPC_STUB IXml2Dex_WriteXML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXml2Dex_INTERFACE_DEFINED__ */


#ifndef __IAMErrorLog_INTERFACE_DEFINED__
#define __IAMErrorLog_INTERFACE_DEFINED__

/* interface IAMErrorLog */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMErrorLog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E43E73A2-0EFA-11d3-9601-00A0C9441E20")
    IAMErrorLog : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LogError( 
            long Severity,
            BSTR pErrorString,
            long ErrorCode,
            long hresult,
            /* [in] */ VARIANT *pExtraInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMErrorLogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMErrorLog * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMErrorLog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMErrorLog * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *LogError )( 
            IAMErrorLog * This,
            long Severity,
            BSTR pErrorString,
            long ErrorCode,
            long hresult,
            /* [in] */ VARIANT *pExtraInfo);
        
        END_INTERFACE
    } IAMErrorLogVtbl;

    interface IAMErrorLog
    {
        CONST_VTBL struct IAMErrorLogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMErrorLog_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMErrorLog_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMErrorLog_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMErrorLog_LogError(This,Severity,pErrorString,ErrorCode,hresult,pExtraInfo)	\
    (This)->lpVtbl -> LogError(This,Severity,pErrorString,ErrorCode,hresult,pExtraInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMErrorLog_LogError_Proxy( 
    IAMErrorLog * This,
    long Severity,
    BSTR pErrorString,
    long ErrorCode,
    long hresult,
    /* [in] */ VARIANT *pExtraInfo);


void __RPC_STUB IAMErrorLog_LogError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMErrorLog_INTERFACE_DEFINED__ */


#ifndef __IAMSetErrorLog_INTERFACE_DEFINED__
#define __IAMSetErrorLog_INTERFACE_DEFINED__

/* interface IAMSetErrorLog */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMSetErrorLog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("963566DA-BE21-4eaf-88E9-35704F8F52A1")
    IAMSetErrorLog : public IUnknown
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorLog( 
            /* [retval][out] */ IAMErrorLog **pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ErrorLog( 
            /* [in] */ IAMErrorLog *newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMSetErrorLogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMSetErrorLog * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMSetErrorLog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMSetErrorLog * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorLog )( 
            IAMSetErrorLog * This,
            /* [retval][out] */ IAMErrorLog **pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ErrorLog )( 
            IAMSetErrorLog * This,
            /* [in] */ IAMErrorLog *newVal);
        
        END_INTERFACE
    } IAMSetErrorLogVtbl;

    interface IAMSetErrorLog
    {
        CONST_VTBL struct IAMSetErrorLogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMSetErrorLog_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMSetErrorLog_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMSetErrorLog_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMSetErrorLog_get_ErrorLog(This,pVal)	\
    (This)->lpVtbl -> get_ErrorLog(This,pVal)

#define IAMSetErrorLog_put_ErrorLog(This,newVal)	\
    (This)->lpVtbl -> put_ErrorLog(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAMSetErrorLog_get_ErrorLog_Proxy( 
    IAMSetErrorLog * This,
    /* [retval][out] */ IAMErrorLog **pVal);


void __RPC_STUB IAMSetErrorLog_get_ErrorLog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAMSetErrorLog_put_ErrorLog_Proxy( 
    IAMSetErrorLog * This,
    /* [in] */ IAMErrorLog *newVal);


void __RPC_STUB IAMSetErrorLog_put_ErrorLog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMSetErrorLog_INTERFACE_DEFINED__ */


#ifndef __ISampleGrabberCB_INTERFACE_DEFINED__
#define __ISampleGrabberCB_INTERFACE_DEFINED__

/* interface ISampleGrabberCB */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_ISampleGrabberCB;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0579154A-2B53-4994-B0D0-E773148EFF85")
    ISampleGrabberCB : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SampleCB( 
            double SampleTime,
            IMediaSample *pSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BufferCB( 
            double SampleTime,
            BYTE *pBuffer,
            long BufferLen) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISampleGrabberCBVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISampleGrabberCB * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISampleGrabberCB * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISampleGrabberCB * This);
        
        HRESULT ( STDMETHODCALLTYPE *SampleCB )( 
            ISampleGrabberCB * This,
            double SampleTime,
            IMediaSample *pSample);
        
        HRESULT ( STDMETHODCALLTYPE *BufferCB )( 
            ISampleGrabberCB * This,
            double SampleTime,
            BYTE *pBuffer,
            long BufferLen);
        
        END_INTERFACE
    } ISampleGrabberCBVtbl;

    interface ISampleGrabberCB
    {
        CONST_VTBL struct ISampleGrabberCBVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISampleGrabberCB_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISampleGrabberCB_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISampleGrabberCB_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISampleGrabberCB_SampleCB(This,SampleTime,pSample)	\
    (This)->lpVtbl -> SampleCB(This,SampleTime,pSample)

#define ISampleGrabberCB_BufferCB(This,SampleTime,pBuffer,BufferLen)	\
    (This)->lpVtbl -> BufferCB(This,SampleTime,pBuffer,BufferLen)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISampleGrabberCB_SampleCB_Proxy( 
    ISampleGrabberCB * This,
    double SampleTime,
    IMediaSample *pSample);


void __RPC_STUB ISampleGrabberCB_SampleCB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISampleGrabberCB_BufferCB_Proxy( 
    ISampleGrabberCB * This,
    double SampleTime,
    BYTE *pBuffer,
    long BufferLen);


void __RPC_STUB ISampleGrabberCB_BufferCB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISampleGrabberCB_INTERFACE_DEFINED__ */


#ifndef __ISampleGrabber_INTERFACE_DEFINED__
#define __ISampleGrabber_INTERFACE_DEFINED__

/* interface ISampleGrabber */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_ISampleGrabber;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6B652FFF-11FE-4fce-92AD-0266B5D7C78F")
    ISampleGrabber : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetOneShot( 
            BOOL OneShot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMediaType( 
            const AM_MEDIA_TYPE *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectedMediaType( 
            AM_MEDIA_TYPE *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBufferSamples( 
            BOOL BufferThem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentBuffer( 
            /* [out][in] */ long *pBufferSize,
            /* [out] */ long *pBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentSample( 
            /* [retval][out] */ IMediaSample **ppSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCallback( 
            ISampleGrabberCB *pCallback,
            long WhichMethodToCallback) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISampleGrabberVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISampleGrabber * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISampleGrabber * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISampleGrabber * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetOneShot )( 
            ISampleGrabber * This,
            BOOL OneShot);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaType )( 
            ISampleGrabber * This,
            const AM_MEDIA_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnectedMediaType )( 
            ISampleGrabber * This,
            AM_MEDIA_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *SetBufferSamples )( 
            ISampleGrabber * This,
            BOOL BufferThem);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentBuffer )( 
            ISampleGrabber * This,
            /* [out][in] */ long *pBufferSize,
            /* [out] */ long *pBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentSample )( 
            ISampleGrabber * This,
            /* [retval][out] */ IMediaSample **ppSample);
        
        HRESULT ( STDMETHODCALLTYPE *SetCallback )( 
            ISampleGrabber * This,
            ISampleGrabberCB *pCallback,
            long WhichMethodToCallback);
        
        END_INTERFACE
    } ISampleGrabberVtbl;

    interface ISampleGrabber
    {
        CONST_VTBL struct ISampleGrabberVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISampleGrabber_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISampleGrabber_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISampleGrabber_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISampleGrabber_SetOneShot(This,OneShot)	\
    (This)->lpVtbl -> SetOneShot(This,OneShot)

#define ISampleGrabber_SetMediaType(This,pType)	\
    (This)->lpVtbl -> SetMediaType(This,pType)

#define ISampleGrabber_GetConnectedMediaType(This,pType)	\
    (This)->lpVtbl -> GetConnectedMediaType(This,pType)

#define ISampleGrabber_SetBufferSamples(This,BufferThem)	\
    (This)->lpVtbl -> SetBufferSamples(This,BufferThem)

#define ISampleGrabber_GetCurrentBuffer(This,pBufferSize,pBuffer)	\
    (This)->lpVtbl -> GetCurrentBuffer(This,pBufferSize,pBuffer)

#define ISampleGrabber_GetCurrentSample(This,ppSample)	\
    (This)->lpVtbl -> GetCurrentSample(This,ppSample)

#define ISampleGrabber_SetCallback(This,pCallback,WhichMethodToCallback)	\
    (This)->lpVtbl -> SetCallback(This,pCallback,WhichMethodToCallback)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISampleGrabber_SetOneShot_Proxy( 
    ISampleGrabber * This,
    BOOL OneShot);


void __RPC_STUB ISampleGrabber_SetOneShot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISampleGrabber_SetMediaType_Proxy( 
    ISampleGrabber * This,
    const AM_MEDIA_TYPE *pType);


void __RPC_STUB ISampleGrabber_SetMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISampleGrabber_GetConnectedMediaType_Proxy( 
    ISampleGrabber * This,
    AM_MEDIA_TYPE *pType);


void __RPC_STUB ISampleGrabber_GetConnectedMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISampleGrabber_SetBufferSamples_Proxy( 
    ISampleGrabber * This,
    BOOL BufferThem);


void __RPC_STUB ISampleGrabber_SetBufferSamples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISampleGrabber_GetCurrentBuffer_Proxy( 
    ISampleGrabber * This,
    /* [out][in] */ long *pBufferSize,
    /* [out] */ long *pBuffer);


void __RPC_STUB ISampleGrabber_GetCurrentBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISampleGrabber_GetCurrentSample_Proxy( 
    ISampleGrabber * This,
    /* [retval][out] */ IMediaSample **ppSample);


void __RPC_STUB ISampleGrabber_GetCurrentSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISampleGrabber_SetCallback_Proxy( 
    ISampleGrabber * This,
    ISampleGrabberCB *pCallback,
    long WhichMethodToCallback);


void __RPC_STUB ISampleGrabber_SetCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISampleGrabber_INTERFACE_DEFINED__ */



#ifndef __DexterLib_LIBRARY_DEFINED__
#define __DexterLib_LIBRARY_DEFINED__

/* library DexterLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DexterLib;

EXTERN_C const CLSID CLSID_AMTimeline;

#ifdef __cplusplus

class DECLSPEC_UUID("78530B75-61F9-11D2-8CAD-00A024580902")
AMTimeline;
#endif

EXTERN_C const CLSID CLSID_AMTimelineObj;

#ifdef __cplusplus

class DECLSPEC_UUID("78530B78-61F9-11D2-8CAD-00A024580902")
AMTimelineObj;
#endif

EXTERN_C const CLSID CLSID_AMTimelineSrc;

#ifdef __cplusplus

class DECLSPEC_UUID("78530B7A-61F9-11D2-8CAD-00A024580902")
AMTimelineSrc;
#endif

EXTERN_C const CLSID CLSID_AMTimelineTrack;

#ifdef __cplusplus

class DECLSPEC_UUID("8F6C3C50-897B-11d2-8CFB-00A0C9441E20")
AMTimelineTrack;
#endif

EXTERN_C const CLSID CLSID_AMTimelineComp;

#ifdef __cplusplus

class DECLSPEC_UUID("74D2EC80-6233-11d2-8CAD-00A024580902")
AMTimelineComp;
#endif

EXTERN_C const CLSID CLSID_AMTimelineGroup;

#ifdef __cplusplus

class DECLSPEC_UUID("F6D371E1-B8A6-11d2-8023-00C0DF10D434")
AMTimelineGroup;
#endif

EXTERN_C const CLSID CLSID_AMTimelineTrans;

#ifdef __cplusplus

class DECLSPEC_UUID("74D2EC81-6233-11d2-8CAD-00A024580902")
AMTimelineTrans;
#endif

EXTERN_C const CLSID CLSID_AMTimelineEffect;

#ifdef __cplusplus

class DECLSPEC_UUID("74D2EC82-6233-11d2-8CAD-00A024580902")
AMTimelineEffect;
#endif

EXTERN_C const CLSID CLSID_RenderEngine;

#ifdef __cplusplus

class DECLSPEC_UUID("64D8A8E0-80A2-11d2-8CF3-00A0C9441E20")
RenderEngine;
#endif

EXTERN_C const CLSID CLSID_SmartRenderEngine;

#ifdef __cplusplus

class DECLSPEC_UUID("498B0949-BBE9-4072-98BE-6CCAEB79DC6F")
SmartRenderEngine;
#endif

EXTERN_C const CLSID CLSID_AudMixer;

#ifdef __cplusplus

class DECLSPEC_UUID("036A9790-C153-11d2-9EF7-006008039E37")
AudMixer;
#endif

EXTERN_C const CLSID CLSID_Xml2Dex;

#ifdef __cplusplus

class DECLSPEC_UUID("18C628EE-962A-11D2-8D08-00A0C9441E20")
Xml2Dex;
#endif

EXTERN_C const CLSID CLSID_MediaLocator;

#ifdef __cplusplus

class DECLSPEC_UUID("CC1101F2-79DC-11D2-8CE6-00A0C9441E20")
MediaLocator;
#endif

EXTERN_C const CLSID CLSID_PropertySetter;

#ifdef __cplusplus

class DECLSPEC_UUID("ADF95821-DED7-11d2-ACBE-0080C75E246E")
PropertySetter;
#endif

EXTERN_C const CLSID CLSID_MediaDet;

#ifdef __cplusplus

class DECLSPEC_UUID("65BD0711-24D2-4ff7-9324-ED2E5D3ABAFA")
MediaDet;
#endif

EXTERN_C const CLSID CLSID_SampleGrabber;

#ifdef __cplusplus

class DECLSPEC_UUID("C1F400A0-3F08-11d3-9F0B-006008039E37")
SampleGrabber;
#endif

EXTERN_C const CLSID CLSID_NullRenderer;

#ifdef __cplusplus

class DECLSPEC_UUID("C1F400A4-3F08-11d3-9F0B-006008039E37")
NullRenderer;
#endif

EXTERN_C const CLSID CLSID_DxtCompositor;

#ifdef __cplusplus

class DECLSPEC_UUID("BB44391D-6ABD-422f-9E2E-385C9DFF51FC")
DxtCompositor;
#endif

EXTERN_C const CLSID CLSID_DxtAlphaSetter;

#ifdef __cplusplus

class DECLSPEC_UUID("506D89AE-909A-44f7-9444-ABD575896E35")
DxtAlphaSetter;
#endif

EXTERN_C const CLSID CLSID_DxtJpeg;

#ifdef __cplusplus

class DECLSPEC_UUID("DE75D012-7A65-11D2-8CEA-00A0C9441E20")
DxtJpeg;
#endif

EXTERN_C const CLSID CLSID_ColorSource;

#ifdef __cplusplus

class DECLSPEC_UUID("0cfdd070-581a-11d2-9ee6-006008039e37")
ColorSource;
#endif

EXTERN_C const CLSID CLSID_DxtKey;

#ifdef __cplusplus

class DECLSPEC_UUID("C5B19592-145E-11d3-9F04-006008039E37")
DxtKey;
#endif
#endif /* __DexterLib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_qedit_0485 */
/* [local] */ 


enum __MIDL___MIDL_itf_qedit_0485_0001
    {	E_NOTINTREE	= 0x80040400,
	E_RENDER_ENGINE_IS_BROKEN	= 0x80040401,
	E_MUST_INIT_RENDERER	= 0x80040402,
	E_NOTDETERMINED	= 0x80040403,
	E_NO_TIMELINE	= 0x80040404,
	S_WARN_OUTPUTRESET	= 40404
    } ;
#define DEX_IDS_BAD_SOURCE_NAME    1400
#define DEX_IDS_BAD_SOURCE_NAME2    1401
#define DEX_IDS_MISSING_SOURCE_NAME    1402
#define DEX_IDS_UNKNOWN_SOURCE    1403
#define DEX_IDS_INSTALL_PROBLEM    1404
#define DEX_IDS_NO_SOURCE_NAMES    1405
#define DEX_IDS_BAD_MEDIATYPE    1406
#define DEX_IDS_STREAM_NUMBER    1407
#define DEX_IDS_OUTOFMEMORY        1408
#define DEX_IDS_DIBSEQ_NOTALLSAME    1409
#define DEX_IDS_CLIPTOOSHORT        1410
#define DEX_IDS_INVALID_DXT        1411
#define DEX_IDS_INVALID_DEFAULT_DXT    1412
#define DEX_IDS_NO_3D        1413
#define DEX_IDS_BROKEN_DXT        1414
#define DEX_IDS_NO_SUCH_PROPERTY    1415
#define DEX_IDS_ILLEGAL_PROPERTY_VAL    1416
#define DEX_IDS_INVALID_XML        1417
#define DEX_IDS_CANT_FIND_FILTER    1418
#define DEX_IDS_DISK_WRITE_ERROR    1419
#define DEX_IDS_INVALID_AUDIO_FX    1420
#define DEX_IDS_CANT_FIND_COMPRESSOR 1421
#define DEX_IDS_TIMELINE_PARSE    1426
#define DEX_IDS_GRAPH_ERROR        1427
#define DEX_IDS_GRID_ERROR        1428
#define DEX_IDS_INTERFACE_ERROR    1429
EXTERN_GUID(CLSID_VideoEffects1Category, 0xcc7bfb42, 0xf175, 0x11d1, 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59);
EXTERN_GUID(CLSID_VideoEffects2Category, 0xcc7bfb43, 0xf175, 0x11d1, 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59);
EXTERN_GUID(CLSID_AudioEffects1Category, 0xcc7bfb44, 0xf175, 0x11d1, 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59);
EXTERN_GUID(CLSID_AudioEffects2Category, 0xcc7bfb45, 0xf175, 0x11d1, 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59);


extern RPC_IF_HANDLE __MIDL_itf_qedit_0485_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_qedit_0485_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\qospol.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    qospol.h - QOS policy elements

Abstract:

    This module defines QOS policy elements.

Revision History:

--*/

#ifndef __QOSPOL_H_
#define __QOSPOL_H_

#define PE_TYPE_APPID       3       // policy element contains Application Identity

// Policy Location attribute carries sub application attributes
#define PE_ATTRIB_TYPE_POLICY_LOCATOR            1

#define POLICY_LOCATOR_SUB_TYPE_ASCII_DN         1
#define POLICY_LOCATOR_SUB_TYPE_UNICODE_DN       2
#define POLICY_LOCATOR_SUB_TYPE_ASCII_DN_ENC     3
#define POLICY_LOCATOR_SUB_TYPE_UNICODE_DN_ENC   4


// Credentials attribute carries the application identity
#define PE_ATTRIB_TYPE_CREDENTIAL        2

#define CREDENTIAL_SUB_TYPE_ASCII_ID     1
#define CREDENTIAL_SUB_TYPE_UNICODE_ID   2
#define CREDENTIAL_SUB_TYPE_KERBEROS_TKT 3
#define CREDENTIAL_SUB_TYPE_X509_V3_CERT 4
#define CREDENTIAL_SUB_TYPE_PGP_CERT     5


// Identity Policy Element attribute structure
typedef struct _IDPE_ATTR {

    USHORT  PeAttribLength;
    
    UCHAR   PeAttribType;            // Use the #defines from above
    
    UCHAR   PeAttribSubType;        // Use the #defines from above
    
    UCHAR   PeAttribValue[4];
    
} IDPE_ATTR, *LPIDPE_ATTR;

#define IDPE_ATTR_HDR_LEN    (sizeof(USHORT)+sizeof(UCHAR)+sizeof(UCHAR))

#define RSVP_BYTE_MULTIPLE(x)       (((x+3) / 4) * 4)


#endif // __QOSPOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\qos.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    qos.h - QoS definitions for NDIS components.

Abstract:

    This module defines the Quality of Service structures and types used
    by Winsock applications.

Revision History:

--*/

#ifndef __QOS_H_
#define __QOS_H_


/*
 *  Definitions for valued-based Service Type for each direction of data flow.
 */

typedef ULONG   SERVICETYPE;

#define SERVICETYPE_NOTRAFFIC               0x00000000  /* No data in this 
                                                         * direction */
#define SERVICETYPE_BESTEFFORT              0x00000001  /* Best Effort */
#define SERVICETYPE_CONTROLLEDLOAD          0x00000002  /* Controlled Load */
#define SERVICETYPE_GUARANTEED              0x00000003  /* Guaranteed */

#define SERVICETYPE_NETWORK_UNAVAILABLE     0x00000004  /* Used to notify 
                                                         * change to user */
#define SERVICETYPE_GENERAL_INFORMATION     0x00000005  /* corresponds to 
                                                         * "General Parameters"
                                                         * defined by IntServ */
#define SERVICETYPE_NOCHANGE                0x00000006  /* used to indicate
                                                         * that the flow spec
                                                         * contains no change
                                                         * from any previous
                                                         * one */
#define SERVICETYPE_NONCONFORMING           0x00000009  /* Non-Conforming Traffic */
#define SERVICETYPE_NETWORK_CONTROL         0x0000000A  /* Network Control traffic */
#define SERVICETYPE_QUALITATIVE             0x0000000D  /* Qualitative applications */ 



/*********  The usage of these is currently not supported.  ***************/
#define SERVICE_BESTEFFORT                  0x80010000
#define SERVICE_CONTROLLEDLOAD              0x80020000
#define SERVICE_GUARANTEED                  0x80040000
#define SERVICE_QUALITATIVE                 0x80200000
/* **************************** ***** ************************************ */



/*
 * Flags to control the usage of RSVP on this flow.
 */

/*
 * to turn off traffic control, 'OR' ( | ) this flag with the 
 * ServiceType field in the FLOWSPEC
 */
#define SERVICE_NO_TRAFFIC_CONTROL   0x81000000


/*
 * this flag can be used to prevent any rsvp signaling messages from being 
 * sent. Local traffic control will be invoked, but no RSVP Path messages 
 * will be sent.This flag can also be used in conjunction with a receiving 
 * flowspec to suppress the automatic generation of a Reserve message.  
 * The application would receive notification that a Path  message had arrived 
 * and would then need to alter the QOS by issuing WSAIoctl( SIO_SET_QOS ), 
 * to unset this flag and thereby causing Reserve messages to go out.
 */

#define SERVICE_NO_QOS_SIGNALING   0x40000000




/*
 *  Flow Specifications for each direction of data flow.
 */
typedef struct _flowspec
{
    ULONG       TokenRate;              /* In Bytes/sec */
    ULONG       TokenBucketSize;        /* In Bytes */
    ULONG       PeakBandwidth;          /* In Bytes/sec */
    ULONG       Latency;                /* In microseconds */
    ULONG       DelayVariation;         /* In microseconds */
    SERVICETYPE ServiceType;
    ULONG       MaxSduSize;             /* In Bytes */
    ULONG       MinimumPolicedSize;     /* In Bytes */

} FLOWSPEC, *PFLOWSPEC, * LPFLOWSPEC;

/*
 * this value can be used in the FLOWSPEC structure to instruct the Rsvp Service 
 * provider to derive the appropriate default value for the parameter.  Note 
 * that not all values in the FLOWSPEC structure can be defaults. In the
 * ReceivingFlowspec, all parameters can be defaulted except the ServiceType.  
 * In the SendingFlowspec, the MaxSduSize and MinimumPolicedSize can be
 * defaulted. Other defaults may be possible. Refer to the appropriate
 * documentation.
 */
#define QOS_NOT_SPECIFIED     0xFFFFFFFF

/*
 * define a value that can be used for the PeakBandwidth, which will map into 
 * positive infinity when the FLOWSPEC is converted into IntServ floating point 
 * format.  We can't use (-1) because that value was previously defined to mean
 * "select the default".
 */
#define   POSITIVE_INFINITY_RATE     0xFFFFFFFE



/*
 * the provider specific structure can have a number of objects in it.
 * Each next structure in the
 * ProviderSpecific will be the QOS_OBJECT_HDR struct that prefaces the actual
 * data with a type and length for that object.  This QOS_OBJECT struct can 
 * repeat several times if there are several objects.  This list of objects
 * terminates either when the buffer length has been reached ( WSABUF ) or
 * an object of type QOS_END_OF_LIST is encountered.
 */
typedef struct  {

    ULONG   ObjectType;
    ULONG   ObjectLength;  /* the length of object buffer INCLUDING 
                            * this header */

} QOS_OBJECT_HDR, *LPQOS_OBJECT_HDR;


/*
 * general QOS objects start at this offset from the base and have a range 
 * of 1000
 */
#define   QOS_GENERAL_ID_BASE                      2000

#define   QOS_OBJECT_END_OF_LIST                   (0x00000001 + QOS_GENERAL_ID_BASE) 
          /* QOS_End_of_list structure passed */
#define   QOS_OBJECT_SD_MODE                       (0x00000002 + QOS_GENERAL_ID_BASE) 
          /* QOS_ShapeDiscard structure passed */
#define   QOS_OBJECT_SHAPING_RATE	           (0x00000003 + QOS_GENERAL_ID_BASE)
          /* QOS_ShapingRate structure */
#define   QOS_OBJECT_DESTADDR                      (0x00000004 + QOS_GENERAL_ID_BASE)
          /* QOS_DestAddr structure (defined in qossp.h) */


/*
 * This structure is used to define the behaviour that the traffic
 * control packet shaper will apply to the flow.
 *
 * TC_NONCONF_BORROW - the flow will receive resources remaining 
 *  after all higher priority flows have been serviced. If a 
 *  TokenRate is specified, packets may be non-conforming and
 *  will be demoted to less than best-effort priority.
 *  
 * TC_NONCONF_SHAPE - TokenRate must be specified. Non-conforming
 *  packets will be retianed in the packet shaper until they become
 *  conforming.
 *
 * TC_NONCONF_DISCARD - TokenRate must be specified. Non-conforming
 *  packets will be discarded.
 *
 */

typedef struct _QOS_SD_MODE {

    QOS_OBJECT_HDR   ObjectHdr;
    ULONG            ShapeDiscardMode;

} QOS_SD_MODE, *LPQOS_SD_MODE;

#define TC_NONCONF_BORROW      0
#define TC_NONCONF_SHAPE       1
#define TC_NONCONF_DISCARD     2
#define TC_NONCONF_BORROW_PLUS 3 // Not supported currently


/*
 * This structure allows an app to specify a prorated "average token rate" using by
 * the traffic shaper under SHAPE modehaper queue. It is expressed in bytes per sec.
 *
 * ShapingRate (bytes per sec.)
 *
 */

typedef struct _QOS_SHAPING_RATE {

    QOS_OBJECT_HDR   ObjectHdr;
    ULONG            ShapingRate;

} QOS_SHAPING_RATE, *LPQOS_SHAPING_RATE;


#endif  /* __QOS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\ras.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ras.h

Abstract:

    Remote Access external API

    WINVER values in this file:
        WINVER < 0x400 = Windows NT 3.5, Windows NT 3.51
        WINVER = 0x400 = Windows 95, Windows98, Windows NT4 (default)
        WINVER > 0x400 = Windows NT4 enhancements
        WINVER = 0x500 = Windows 2000

--*/

#ifndef _RAS_H_
#define _RAS_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef UNLEN
#include <lmcons.h>
#endif

#include <pshpack4.h>

#define RAS_MaxDeviceType     16
#define RAS_MaxPhoneNumber    128
#define RAS_MaxIpAddress      15
#define RAS_MaxIpxAddress     21

#if (WINVER >= 0x400)
#define RAS_MaxEntryName      256
#define RAS_MaxDeviceName     128
#define RAS_MaxCallbackNumber RAS_MaxPhoneNumber
#else
#define RAS_MaxEntryName      20
#define RAS_MaxDeviceName     32
#define RAS_MaxCallbackNumber 48
#endif

#define RAS_MaxAreaCode       10
#define RAS_MaxPadType        32
#define RAS_MaxX25Address     200
#define RAS_MaxFacilities     200
#define RAS_MaxUserData       200
#define RAS_MaxReplyMessage   1024
#define RAS_MaxDnsSuffix      256

DECLARE_HANDLE( HRASCONN );
#define LPHRASCONN HRASCONN*

#if (WINVER >= 0x501)
#define RASCF_AllUsers		0x00000001
#define RASCF_GlobalCreds	0x00000002
#endif

/* Identifies an active RAS connection.  (See RasEnumConnections)
*/
#define RASCONNW struct tagRASCONNW
RASCONNW
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    WCHAR    szEntryName[ RAS_MaxEntryName + 1 ];

#if (WINVER >= 0x400)
    WCHAR    szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR    szDeviceName[ RAS_MaxDeviceName + 1 ];
#endif
#if (WINVER >= 0x401)
    WCHAR    szPhonebook [ MAX_PATH ];
    DWORD    dwSubEntry;
#endif
#if (WINVER >= 0x500)
    GUID    guidEntry;
#endif
#if (WINVER >= 0x501)
	DWORD	dwFlags;
	LUID    luid;
#endif
};

#define RASCONNA struct tagRASCONNA
RASCONNA
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    CHAR     szEntryName[ RAS_MaxEntryName + 1 ];

#if (WINVER >= 0x400)
    CHAR     szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR     szDeviceName[ RAS_MaxDeviceName + 1 ];
#endif
#if (WINVER >= 0x401)
    CHAR     szPhonebook [ MAX_PATH ];
    DWORD    dwSubEntry;
#endif
#if (WINVER >= 0x500)
    GUID     guidEntry;
#endif
#if (WINVER >= 0x501)
	DWORD	dwFlags;
	LUID    luid;
#endif
};

#ifdef UNICODE
#define RASCONN RASCONNW
#else
#define RASCONN RASCONNA
#endif

#define LPRASCONNW RASCONNW*
#define LPRASCONNA RASCONNA*
#define LPRASCONN  RASCONN*


/* Enumerates intermediate states to a connection.  (See RasDial)
*/
#define RASCS_PAUSED 0x1000
#define RASCS_DONE   0x2000

#define RASCONNSTATE enum tagRASCONNSTATE
RASCONNSTATE
{
    RASCS_OpenPort = 0,
    RASCS_PortOpened,
    RASCS_ConnectDevice,
    RASCS_DeviceConnected,
    RASCS_AllDevicesConnected,
    RASCS_Authenticate,
    RASCS_AuthNotify,
    RASCS_AuthRetry,
    RASCS_AuthCallback,
    RASCS_AuthChangePassword,
    RASCS_AuthProject,
    RASCS_AuthLinkSpeed,
    RASCS_AuthAck,
    RASCS_ReAuthenticate,
    RASCS_Authenticated,
    RASCS_PrepareForCallback,
    RASCS_WaitForModemReset,
    RASCS_WaitForCallback,
    RASCS_Projected,

#if (WINVER >= 0x400)
    RASCS_StartAuthentication,
    RASCS_CallbackComplete,
    RASCS_LogonNetwork,
#endif
    RASCS_SubEntryConnected,
    RASCS_SubEntryDisconnected,

    RASCS_Interactive = RASCS_PAUSED,
    RASCS_RetryAuthentication,
    RASCS_CallbackSetByCaller,
    RASCS_PasswordExpired,
#if (WINVER >= 0x500)
    RASCS_InvokeEapUI,
#endif

    RASCS_Connected = RASCS_DONE,
    RASCS_Disconnected
};

#define LPRASCONNSTATE RASCONNSTATE*


/* Describes the status of a RAS connection.  (See RasConnectionStatus)
*/
#define RASCONNSTATUSW struct tagRASCONNSTATUSW
RASCONNSTATUSW
{
    DWORD        dwSize;
    RASCONNSTATE rasconnstate;
    DWORD        dwError;
    WCHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
#if (WINVER >= 0x401)
    WCHAR        szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
#endif
};

#define RASCONNSTATUSA struct tagRASCONNSTATUSA
RASCONNSTATUSA
{
    DWORD        dwSize;
    RASCONNSTATE rasconnstate;
    DWORD        dwError;
    CHAR         szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR         szDeviceName[ RAS_MaxDeviceName + 1 ];
#if (WINVER >= 0x401)
    CHAR         szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
#endif
};

#ifdef UNICODE
#define RASCONNSTATUS RASCONNSTATUSW
#else
#define RASCONNSTATUS RASCONNSTATUSA
#endif

#define LPRASCONNSTATUSW RASCONNSTATUSW*
#define LPRASCONNSTATUSA RASCONNSTATUSA*
#define LPRASCONNSTATUS  RASCONNSTATUS*

/* Describes connection establishment parameters.  (See RasDial)
*/
#define RASDIALPARAMSW struct tagRASDIALPARAMSW
RASDIALPARAMSW
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName + 1 ];
    WCHAR szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    WCHAR szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
#if (WINVER >= 0x401)
    DWORD dwSubEntry;
    ULONG_PTR dwCallbackId;
#endif
};

#define RASDIALPARAMSA struct tagRASDIALPARAMSA
RASDIALPARAMSA
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];
    CHAR  szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    CHAR  szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
    CHAR  szUserName[ UNLEN + 1 ];
    CHAR  szPassword[ PWLEN + 1 ];
    CHAR  szDomain[ DNLEN + 1 ];
#if (WINVER >= 0x401)
    DWORD dwSubEntry;
    ULONG_PTR dwCallbackId;
#endif
};

#ifdef UNICODE
#define RASDIALPARAMS RASDIALPARAMSW
#else
#define RASDIALPARAMS RASDIALPARAMSA
#endif

#define LPRASDIALPARAMSW RASDIALPARAMSW*
#define LPRASDIALPARAMSA RASDIALPARAMSA*
#define LPRASDIALPARAMS  RASDIALPARAMS*

#if (WINVER >= 0x500)

#define RASEAPINFO struct tagRASEAPINFO
RASEAPINFO
{
    DWORD dwSizeofEapInfo;
    BYTE  *pbEapInfo;
};

#endif

/* Describes extended connection establishment options.  (See RasDial)
*/
#define RASDIALEXTENSIONS struct tagRASDIALEXTENSIONS
RASDIALEXTENSIONS
{
    DWORD     dwSize;
    DWORD     dwfOptions;
    HWND      hwndParent;
    ULONG_PTR reserved;
#if (WINVER >= 0x500)
    ULONG_PTR reserved1;
    RASEAPINFO RasEapInfo;
#endif
};

#define LPRASDIALEXTENSIONS RASDIALEXTENSIONS*

/* 'dwfOptions' bit flags.
*/
#define RDEOPT_UsePrefixSuffix           0x00000001
#define RDEOPT_PausedStates              0x00000002
#define RDEOPT_IgnoreModemSpeaker        0x00000004
#define RDEOPT_SetModemSpeaker           0x00000008
#define RDEOPT_IgnoreSoftwareCompression 0x00000010
#define RDEOPT_SetSoftwareCompression    0x00000020
#define RDEOPT_DisableConnectedUI        0x00000040
#define RDEOPT_DisableReconnectUI        0x00000080
#define RDEOPT_DisableReconnect          0x00000100
#define RDEOPT_NoUser                    0x00000200
#define RDEOPT_PauseOnScript             0x00000400
#define RDEOPT_Router                    0x00000800

#if (WINVER >= 0x500)
#define RDEOPT_CustomDial                0x00001000
#endif

#if (WINVER >= 0x501)
#define RDEOPT_UseCustomScripting        0x00002000
#endif


//
// This flag when set in the RASENTRYNAME structure
// indicates that the phonebook to which this entry
// belongs is a system phonebook.
//
#define REN_User                         0x00000000
#define REN_AllUsers                     0x00000001


/* Describes an enumerated RAS phone book entry name.  (See RasEntryEnum)
*/
#define RASENTRYNAMEW struct tagRASENTRYNAMEW
RASENTRYNAMEW
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName + 1 ];

#if (WINVER >= 0x500)
    //
    // If this flag is REN_AllUsers then its a
    // system phonebook.
    //
    DWORD dwFlags;
    WCHAR szPhonebookPath[MAX_PATH + 1];
#endif
};

#define RASENTRYNAMEA struct tagRASENTRYNAMEA
RASENTRYNAMEA
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];

#if (WINVER >= 0x500)
    DWORD dwFlags;
    CHAR  szPhonebookPath[MAX_PATH + 1];
#endif

};

#ifdef UNICODE
#define RASENTRYNAME RASENTRYNAMEW
#else
#define RASENTRYNAME RASENTRYNAMEA
#endif

#define LPRASENTRYNAMEW RASENTRYNAMEW*
#define LPRASENTRYNAMEA RASENTRYNAMEA*
#define LPRASENTRYNAME  RASENTRYNAME*


/* Protocol code to projection data structure mapping.
*/
#define RASPROJECTION enum tagRASPROJECTION
RASPROJECTION
{
    RASP_Amb = 0x10000,
    RASP_PppNbf = 0x803F,
    RASP_PppIpx = 0x802B,
    RASP_PppIp = 0x8021,
#if (WINVER >= 0x500)
    RASP_PppCcp = 0x80FD,
#endif
    RASP_PppLcp = 0xC021,
    RASP_Slip = 0x20000
};

#define LPRASPROJECTION RASPROJECTION*


/* Describes the result of a RAS AMB (Authentication Message Block)
** projection.  This protocol is used with NT 3.1 and OS/2 1.3 downlevel
** RAS servers.
*/
#define RASAMBW struct tagRASAMBW
RASAMBW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
};

#define RASAMBA struct tagRASAMBA
RASAMBA
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
};

#ifdef UNICODE
#define RASAMB RASAMBW
#else
#define RASAMB RASAMBA
#endif

#define LPRASAMBW RASAMBW*
#define LPRASAMBA RASAMBA*
#define LPRASAMB  RASAMB*


/* Describes the result of a PPP NBF (NetBEUI) projection.
*/
#define RASPPPNBFW struct tagRASPPPNBFW
RASPPPNBFW
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwNetBiosError;
    WCHAR szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    WCHAR szWorkstationName[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
};

#define RASPPPNBFA struct tagRASPPPNBFA
RASPPPNBFA
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwNetBiosError;
    CHAR  szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    CHAR  szWorkstationName[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
};

#ifdef UNICODE
#define RASPPPNBF RASPPPNBFW
#else
#define RASPPPNBF RASPPPNBFA
#endif

#define LPRASPPPNBFW RASPPPNBFW*
#define LPRASPPPNBFA RASPPPNBFA*
#define LPRASPPPNBF  RASPPPNBF*


/* Describes the results of a PPP IPX (Internetwork Packet Exchange)
** projection.
*/
#define RASPPPIPXW struct tagRASIPXW
RASPPPIPXW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szIpxAddress[ RAS_MaxIpxAddress + 1 ];
};


#define RASPPPIPXA struct tagRASPPPIPXA
RASPPPIPXA
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szIpxAddress[ RAS_MaxIpxAddress + 1 ];
};

#ifdef UNICODE
#define RASPPPIPX RASPPPIPXW
#else
#define RASPPPIPX RASPPPIPXA
#endif

#define LPRASPPPIPXW RASPPPIPXW*
#define LPRASPPPIPXA RASPPPIPXA*
#define LPRASPPPIPX  RASPPPIPX*


/* Describes the results of a PPP IP (Internet) projection.
*/

#if (WINVER >= 0x500)

/* RASPPPIP 'dwOptions' and 'dwServerOptions' flags.
*/
#define RASIPO_VJ       0x00000001

#endif

#define RASPPPIPW struct tagRASPPPIPW
RASPPPIPW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szIpAddress[ RAS_MaxIpAddress + 1 ];

#ifndef WINNT35COMPATIBLE

    /* This field was added between Windows NT 3.51 beta and Windows NT 3.51
    ** final, and between Windows 95 M8 beta and Windows 95 final.  If you do
    ** not require the server address and wish to retrieve PPP IP information
    ** from Windows NT 3.5 or early Windows NT 3.51 betas, or on early Windows
    ** 95 betas, define WINNT35COMPATIBLE.
    **
    ** The server IP address is not provided by all PPP implementations,
    ** though Windows NT server's do provide it.
    */
    WCHAR szServerIpAddress[ RAS_MaxIpAddress + 1 ];

#endif
#if (WINVER >= 0x500)
    DWORD dwOptions;
    DWORD dwServerOptions;
#endif
};

#define RASPPPIPA struct tagRASPPPIPA
RASPPPIPA
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szIpAddress[ RAS_MaxIpAddress + 1 ];

#ifndef WINNT35COMPATIBLE

    /* See RASPPPIPW comment.
    */
    CHAR  szServerIpAddress[ RAS_MaxIpAddress + 1 ];

#endif
#if (WINVER >= 0x500)
    DWORD dwOptions;
    DWORD dwServerOptions;
#endif
};

#ifdef UNICODE
#define RASPPPIP RASPPPIPW
#else
#define RASPPPIP RASPPPIPA
#endif

#define LPRASPPPIPW RASPPPIPW*
#define LPRASPPPIPA RASPPPIPA*
#define LPRASPPPIP  RASPPPIP*


/* Describes the results of a PPP LCP/multi-link negotiation.
*/

#if (WINVER >= 0x500)

/* RASPPPLCP 'dwAuthenticatonProtocol' values.
*/
#define RASLCPAP_PAP          0xC023
#define RASLCPAP_SPAP         0xC027
#define RASLCPAP_CHAP         0xC223
#define RASLCPAP_EAP          0xC227

/* RASPPPLCP 'dwAuthenticatonData' values.
*/
#define RASLCPAD_CHAP_MD5     0x05
#define RASLCPAD_CHAP_MS      0x80
#define RASLCPAD_CHAP_MSV2    0x81

/* RASPPPLCP 'dwOptions' and 'dwServerOptions' flags.
*/
#define RASLCPO_PFC           0x00000001
#define RASLCPO_ACFC          0x00000002
#define RASLCPO_SSHF          0x00000004
#define RASLCPO_DES_56        0x00000008
#define RASLCPO_3_DES         0x00000010

#endif


#define RASPPPLCPW struct tagRASPPPLCPW
RASPPPLCPW
{
    DWORD dwSize;
    BOOL  fBundled;

#if (WINVER >= 0x500)
    DWORD dwError;
    DWORD dwAuthenticationProtocol;
    DWORD dwAuthenticationData;
    DWORD dwEapTypeId;
    DWORD dwServerAuthenticationProtocol;
    DWORD dwServerAuthenticationData;
    DWORD dwServerEapTypeId;
    BOOL  fMultilink;
    DWORD dwTerminateReason;
    DWORD dwServerTerminateReason;
    WCHAR szReplyMessage[RAS_MaxReplyMessage];
    DWORD dwOptions;
    DWORD dwServerOptions;
#endif

};

#define RASPPPLCPA struct tagRASPPPLCPA
RASPPPLCPA
{
    DWORD dwSize;
    BOOL  fBundled;

#if (WINVER >= 0x500)
    DWORD dwError;
    DWORD dwAuthenticationProtocol;
    DWORD dwAuthenticationData;
    DWORD dwEapTypeId;
    DWORD dwServerAuthenticationProtocol;
    DWORD dwServerAuthenticationData;
    DWORD dwServerEapTypeId;
    BOOL  fMultilink;
    DWORD dwTerminateReason;
    DWORD dwServerTerminateReason;
    CHAR  szReplyMessage[RAS_MaxReplyMessage];
    DWORD dwOptions;
    DWORD dwServerOptions;
#endif

};


#ifdef UNICODE
#define RASPPPLCP RASPPPLCPW
#else
#define RASPPPLCP RASPPPLCPA
#endif

#define LPRASPPPLCPW RASPPPLCPW*
#define LPRASPPPLCPA RASPPPLCPA*
#define LPRASPPPLCP  RASPPPLCP*


/* Describes the results of a SLIP (Serial Line IP) projection.
*/
#define RASSLIPW struct tagRASSLIPW
RASSLIPW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szIpAddress[ RAS_MaxIpAddress + 1 ];
};


#define RASSLIPA struct tagRASSLIPA
RASSLIPA
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szIpAddress[ RAS_MaxIpAddress + 1 ];
};

#ifdef UNICODE
#define RASSLIP RASSLIPW
#else
#define RASSLIP RASSLIPA
#endif

#define LPRASSLIPW RASSLIPW*
#define LPRASSLIPA RASSLIPA*
#define LPRASSLIP  RASSLIP*

#if (WINVER >= 0x500)

/* Describes the results of a PPP CCP (Compression Control Protocol)
projection.
*/

/* RASPPPCCP 'dwCompressionAlgorithm' values.
*/
#define RASCCPCA_MPPC         0x00000006
#define RASCCPCA_STAC         0x00000005

/* RASPPPCCP 'dwOptions' values.
*/
#define RASCCPO_Compression       0x00000001
#define RASCCPO_HistoryLess       0x00000002
#define RASCCPO_Encryption56bit   0x00000010
#define RASCCPO_Encryption40bit   0x00000020
#define RASCCPO_Encryption128bit  0x00000040

#define RASPPPCCP struct tagRASPPPCCP
RASPPPCCP
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwCompressionAlgorithm;
    DWORD dwOptions;
    DWORD dwServerCompressionAlgorithm;
    DWORD dwServerOptions;
};

#define LPRASPPPCCP  RASPPPCCP*

#endif

/* If using RasDial message notifications, get the notification message code
** by passing this string to the RegisterWindowMessageA() API.
** WM_RASDIALEVENT is used only if a unique message cannot be registered.
*/
#define RASDIALEVENT    "RasDialEvent"
#define WM_RASDIALEVENT 0xCCCD

/* Prototypes for caller's RasDial callback handler.  Arguments are the
** message ID (currently always WM_RASDIALEVENT), the current RASCONNSTATE and
** the error that has occurred (or 0 if none).  Extended arguments are the
** handle of the RAS connection and an extended error code.
**
** For RASDIALFUNC2, subsequent callback notifications for all
** subentries can be cancelled by returning FALSE.
*/
typedef VOID (WINAPI *RASDIALFUNC)( UINT, RASCONNSTATE, DWORD );
typedef VOID (WINAPI *RASDIALFUNC1)( HRASCONN, UINT, RASCONNSTATE, DWORD, DWORD );
typedef DWORD (WINAPI *RASDIALFUNC2)( ULONG_PTR, DWORD, HRASCONN, UINT, RASCONNSTATE, DWORD, DWORD );


/* Information describing a RAS-capable device.
*/
#define RASDEVINFOW struct tagRASDEVINFOW
RASDEVINFOW
{
    DWORD    dwSize;
    WCHAR    szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR    szDeviceName[ RAS_MaxDeviceName + 1 ];
};

#define RASDEVINFOA struct tagRASDEVINFOA
RASDEVINFOA
{
    DWORD    dwSize;
    CHAR     szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR     szDeviceName[ RAS_MaxDeviceName + 1 ];
};

#ifdef UNICODE
#define RASDEVINFO RASDEVINFOW
#else
#define RASDEVINFO RASDEVINFOA
#endif

#define LPRASDEVINFOW RASDEVINFOW*
#define LPRASDEVINFOA RASDEVINFOA*
#define LPRASDEVINFO  RASDEVINFO*

/* RAS country information (currently retrieved from TAPI).
*/
#define RASCTRYINFO struct RASCTRYINFO
RASCTRYINFO
{
    DWORD   dwSize;
    DWORD   dwCountryID;
    DWORD   dwNextCountryID;
    DWORD   dwCountryCode;
    DWORD   dwCountryNameOffset;
};

/* There is currently no difference between
** RASCTRYINFOA and RASCTRYINFOW.  This may
** change in the future.
*/
#define RASCTRYINFOW   RASCTRYINFO
#define RASCTRYINFOA   RASCTRYINFO

#define LPRASCTRYINFOW RASCTRYINFOW*
#define LPRASCTRYINFOA RASCTRYINFOW*
#define LPRASCTRYINFO  RASCTRYINFO*

/* A RAS IP address.
*/
#define RASIPADDR struct RASIPADDR
RASIPADDR
{
    BYTE a;
    BYTE b;
    BYTE c;
    BYTE d;
};

#if (WINVER >= 0x500)

#define ET_None         0  // No encryption
#define ET_Require      1  // Require Encryption
#define ET_RequireMax   2  // Require max encryption
#define ET_Optional     3  // Do encryption if possible. None Ok.

#endif

#define VS_Default		0   // default (PPTP for now)
#define VS_PptpOnly	    1	// Only PPTP is attempted.
#define VS_PptpFirst	2   // PPTP is tried first.
#define VS_L2tpOnly 	3	// Only L2TP is attempted.
#define VS_L2tpFirst	4	// L2TP is tried first.

/* A RAS phone book entry.
*/
#define RASENTRYA struct tagRASENTRYA
RASENTRYA
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number.
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    CHAR        szAreaCode[ RAS_MaxAreaCode + 1 ];
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    CHAR        szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    CHAR        szAutodialDll[ MAX_PATH ];
    CHAR        szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    CHAR        szX25PadType[ RAS_MaxPadType + 1 ];
    CHAR        szX25Address[ RAS_MaxX25Address + 1 ];
    CHAR        szX25Facilities[ RAS_MaxFacilities + 1 ];
    CHAR        szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
#if (WINVER >= 0x401)
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;
#endif

#if (WINVER >= 0x500)

    //
    // Entry Type
    //
    DWORD       dwType;

    //
    // Encryption type
    //
    DWORD       dwEncryptionType;

    //
    // CustomAuthKey to be used for EAP
    //
    DWORD       dwCustomAuthKey;

    //
    // Guid of the connection
    //
    GUID        guidId;

    //
    // Custom Dial Dll
    //
    CHAR        szCustomDialDll[MAX_PATH];

    //
    // DwVpnStrategy
    //
    DWORD       dwVpnStrategy;
#endif

#if (WINVER >= 0x501)
	//
	// More RASEO_* options
	//
	DWORD		dwfOptions2;

	//
	// For future use
	//
	DWORD       dwfOptions3;

	CHAR		szDnsSuffix[RAS_MaxDnsSuffix];

	DWORD       dwTcpWindowSize;

	CHAR        szPrerequisitePbk[MAX_PATH];

	CHAR        szPrerequisiteEntry[RAS_MaxEntryName + 1];

	DWORD       dwRedialCount;

	DWORD       dwRedialPause;
#endif

};

#define RASENTRYW struct tagRASENTRYW
RASENTRYW
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    WCHAR       szAreaCode[ RAS_MaxAreaCode + 1 ];
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    WCHAR       szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    WCHAR       szAutodialDll[ MAX_PATH ];
    WCHAR       szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    WCHAR       szX25PadType[ RAS_MaxPadType + 1 ];
    WCHAR       szX25Address[ RAS_MaxX25Address + 1 ];
    WCHAR       szX25Facilities[ RAS_MaxFacilities + 1 ];
    WCHAR       szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
#if (WINVER >= 0x401)
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;
#endif

#if (WINVER >= 0x500)
    //
    // Entry Type
    //
    DWORD       dwType;

    //
    // EncryptionType
    //
    DWORD       dwEncryptionType;

    //
    // CustomAuthKey to be used for EAP
    //
    DWORD       dwCustomAuthKey;

    //
    // Guid of the connection
    //
    GUID        guidId;

    //
    // Custom Dial Dll
    //
    WCHAR       szCustomDialDll[MAX_PATH];

    //
    // Vpn Strategy
    //
    DWORD       dwVpnStrategy;
#endif

#if (WINVER >= 0x501)
	//
	// More RASEO_* options
	//
	DWORD		dwfOptions2;

	//
	// For future use
	//
	DWORD       dwfOptions3;

	WCHAR		szDnsSuffix[RAS_MaxDnsSuffix];

	DWORD       dwTcpWindowSize;

	WCHAR       szPrerequisitePbk[MAX_PATH];

	WCHAR       szPrerequisiteEntry[RAS_MaxEntryName + 1];

	DWORD       dwRedialCount;

	DWORD       dwRedialPause;
#endif
};

#ifdef UNICODE
#define RASENTRY RASENTRYW
#else
#define RASENTRY RASENTRYA
#endif

#define LPRASENTRYW RASENTRYW*
#define LPRASENTRYA RASENTRYA*
#define LPRASENTRY  RASENTRY*

/* RASENTRY 'dwfOptions' bit flags.
*/
#define RASEO_UseCountryAndAreaCodes    0x00000001
#define RASEO_SpecificIpAddr            0x00000002
#define RASEO_SpecificNameServers       0x00000004
#define RASEO_IpHeaderCompression       0x00000008
#define RASEO_RemoteDefaultGateway      0x00000010
#define RASEO_DisableLcpExtensions      0x00000020
#define RASEO_TerminalBeforeDial        0x00000040
#define RASEO_TerminalAfterDial         0x00000080
#define RASEO_ModemLights               0x00000100
#define RASEO_SwCompression             0x00000200
#define RASEO_RequireEncryptedPw        0x00000400
#define RASEO_RequireMsEncryptedPw      0x00000800
#define RASEO_RequireDataEncryption     0x00001000
#define RASEO_NetworkLogon              0x00002000
#define RASEO_UseLogonCredentials       0x00004000
#define RASEO_PromoteAlternates         0x00008000

#if (WINVER >= 0x401)
#define RASEO_SecureLocalFiles          0x00010000
#endif

#if (WINVER >= 0x500)
#define RASEO_RequireEAP                0x00020000
#define RASEO_RequirePAP                0x00040000
#define RASEO_RequireSPAP               0x00080000
#define RASEO_Custom                    0x00100000

#define RASEO_PreviewPhoneNumber        0x00200000
#define RASEO_SharedPhoneNumbers        0x00800000
#define RASEO_PreviewUserPw             0x01000000
#define RASEO_PreviewDomain             0x02000000
#define RASEO_ShowDialingProgress       0x04000000
#define RASEO_RequireCHAP               0x08000000
#define RASEO_RequireMsCHAP             0x10000000
#define RASEO_RequireMsCHAP2            0x20000000
#define RASEO_RequireW95MSCHAP          0x40000000
#define RASEO_CustomScript              0x80000000
#endif

#if (WINVER >= 0x501)
//
// RASENTRY dwfOptions2 bit flags
//
#define RASEO2_SecureFileAndPrint       0x00000001
#define RASEO2_SecureClientForMSNet     0x00000002
#define RASEO2_DontNegotiateMultilink   0x00000004
#define RASEO2_DontUseRasCredentials    0x00000008
#define RASEO2_UsePreSharedKey          0x00000010
#define RASEO2_Internet                 0x00000020
#define RASEO2_DisableNbtOverIP         0x00000040
#define RASEO2_UseGlobalDeviceSettings  0x00000080
#define RASEO2_ReconnectIfDropped       0x00000100
#define RASEO2_SharePhoneNumbers        0x00000200
#endif

/* RASENTRY 'dwProtocols' bit flags.
*/
#define RASNP_NetBEUI                   0x00000001
#define RASNP_Ipx                       0x00000002
#define RASNP_Ip                        0x00000004

/* RASENTRY 'dwFramingProtocols' bit flags.
*/
#define RASFP_Ppp                       0x00000001
#define RASFP_Slip                      0x00000002
#define RASFP_Ras                       0x00000004

/* RASENTRY 'szDeviceType' default strings.
*/
#define RASDT_Modem                     TEXT("modem")
#define RASDT_Isdn                      TEXT("isdn")
#define RASDT_X25                       TEXT("x25")
#define RASDT_Vpn                       TEXT("vpn")
#define RASDT_Pad                       TEXT("pad")
#define RASDT_Generic                   TEXT("GENERIC")
#define RASDT_Serial        			TEXT("SERIAL")
#define RASDT_FrameRelay                TEXT("FRAMERELAY")
#define RASDT_Atm                       TEXT("ATM")
#define RASDT_Sonet                     TEXT("SONET")
#define RASDT_SW56                      TEXT("SW56")
#define RASDT_Irda                      TEXT("IRDA")
#define RASDT_Parallel                  TEXT("PARALLEL")
#if (WINVER >= 0x501)
#define RASDT_PPPoE                     TEXT("PPPoE")
#endif


// The entry type used to determine which UI properties
// are to be presented to user.  This generally corresponds
// to a Connections "add" wizard selection.
//
#define RASET_Phone     1  // Phone lines: modem, ISDN, X.25, etc
#define RASET_Vpn       2  // Virtual private network
#define RASET_Direct    3  // Direct connect: serial, parallel
#define RASET_Internet  4  // BaseCamp internet
#if (WINVER >= 0x501)
#define RASET_Broadband 5  // Broadband
#endif

/* Old AutoDial DLL function prototype.
**
** This prototype is documented for backward-compatibility
** purposes only.  It is superceded by the RASADFUNCA
** and RASADFUNCW definitions below.  DO NOT USE THIS
** PROTOTYPE IN NEW CODE.  SUPPORT FOR IT MAY BE REMOVED
** IN FUTURE VERSIONS OF RAS.
*/
typedef BOOL (WINAPI *ORASADFUNC)( HWND, LPSTR, DWORD, LPDWORD );

#if (WINVER >= 0x400)

/* Flags for RasConnectionNotification().
*/
#define RASCN_Connection        0x00000001
#define RASCN_Disconnection     0x00000002
#define RASCN_BandwidthAdded    0x00000004
#define RASCN_BandwidthRemoved  0x00000008

#endif

#if (WINVER >= 0x401)
/* RASENTRY 'dwDialMode' values.
*/
#define RASEDM_DialAll                  1
#define RASEDM_DialAsNeeded             2

/* RASENTRY 'dwIdleDisconnectSeconds' constants.
*/
#define RASIDS_Disabled                 0xffffffff
#define RASIDS_UseGlobalValue           0

/* AutoDial DLL function parameter block.
*/
#define RASADPARAMS struct tagRASADPARAMS
RASADPARAMS
{
    DWORD       dwSize;
    HWND        hwndOwner;
    DWORD       dwFlags;
    LONG        xDlg;
    LONG        yDlg;
};

#define LPRASADPARAMS RASADPARAMS*

/* AutoDial DLL function parameter block 'dwFlags.'
*/
#define RASADFLG_PositionDlg            0x00000001

/* Prototype AutoDial DLL function.
*/
typedef BOOL (WINAPI *RASADFUNCA)( LPSTR, LPSTR, LPRASADPARAMS, LPDWORD );
typedef BOOL (WINAPI *RASADFUNCW)( LPWSTR, LPWSTR, LPRASADPARAMS, LPDWORD );

#ifdef UNICODE
#define RASADFUNC RASADFUNCW
#else
#define RASADFUNC RASADFUNCA
#endif

/* A RAS phone book multilinked sub-entry.
*/
#define RASSUBENTRYA struct tagRASSUBENTRYA
RASSUBENTRYA
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};

#define RASSUBENTRYW struct tagRASSUBENTRYW
RASSUBENTRYW
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};

#ifdef UNICODE
#define RASSUBENTRY RASSUBENTRYW
#else
#define RASSUBENTRY RASSUBENTRYA
#endif

#define LPRASSUBENTRYW RASSUBENTRYW*
#define LPRASSUBENTRYA RASSUBENTRYA*
#define LPRASSUBENTRY  RASSUBENTRY*

/* Ras{Get,Set}Credentials structure.  These calls
** supercede Ras{Get,Set}EntryDialParams.
*/
#define RASCREDENTIALSA struct tagRASCREDENTIALSA
RASCREDENTIALSA
{
    DWORD dwSize;
    DWORD dwMask;
    CHAR szUserName[ UNLEN + 1 ];
    CHAR szPassword[ PWLEN + 1 ];
    CHAR szDomain[ DNLEN + 1 ];
};

#define RASCREDENTIALSW struct tagRASCREDENTIALSW
RASCREDENTIALSW
{
    DWORD dwSize;
    DWORD dwMask;
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
};

#ifdef UNICODE
#define RASCREDENTIALS RASCREDENTIALSW
#else
#define RASCREDENTIALS RASCREDENTIALSA
#endif

#define LPRASCREDENTIALSW RASCREDENTIALSW*
#define LPRASCREDENTIALSA RASCREDENTIALSA*
#define LPRASCREDENTIALS  RASCREDENTIALS*

/* RASCREDENTIALS 'dwMask' values.
*/
#define RASCM_UserName          0x00000001
#define RASCM_Password          0x00000002
#define RASCM_Domain            0x00000004
#if (WINVER >= 501)
#define RASCM_DefaultCreds       0x00000008
#define RASCM_PreSharedKey       0x00000010
#define RASCM_ServerPreSharedKey 0x00000020
#define RASCM_DDMPreSharedKey    0x00000040
#endif

/* AutoDial address properties.
*/
#define RASAUTODIALENTRYA struct tagRASAUTODIALENTRYA
RASAUTODIALENTRYA
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwDialingLocation;
    CHAR szEntry[ RAS_MaxEntryName + 1];
};

#define RASAUTODIALENTRYW struct tagRASAUTODIALENTRYW
RASAUTODIALENTRYW
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwDialingLocation;
    WCHAR szEntry[ RAS_MaxEntryName + 1];
};

#ifdef UNICODE
#define RASAUTODIALENTRY RASAUTODIALENTRYW
#else
#define RASAUTODIALENTRY RASAUTODIALENTRYA
#endif

#define LPRASAUTODIALENTRYW RASAUTODIALENTRYW*
#define LPRASAUTODIALENTRYA RASAUTODIALENTRYA*
#define LPRASAUTODIALENTRY  RASAUTODIALENTRY*

/* AutoDial control parameter values for
** Ras{Get,Set}AutodialParam.
*/
#define RASADP_DisableConnectionQuery           0
#define RASADP_LoginSessionDisable              1
#define RASADP_SavedAddressesLimit              2
#define RASADP_FailedConnectionTimeout          3
#define RASADP_ConnectionQueryTimeout           4

#endif // (WINVER >= 0x401)

#if (WINVER >= 0x500)

/* RasGetEapUserIdentity bit flags.
** These have the same values as the RAS_EAP_FLAG_ flags in raseapif.h
*/
#define RASEAPF_NonInteractive          0x00000002
#define RASEAPF_Logon                   0x00000004
#define RASEAPF_Preview                 0x00000008

/* RasGetEapUserIdentity structure.
*/
#define RASEAPUSERIDENTITYA struct tagRASEAPUSERIDENTITYA
RASEAPUSERIDENTITYA
{
    CHAR        szUserName[ UNLEN + 1 ];
    DWORD       dwSizeofEapInfo;
    BYTE        pbEapInfo[ 1 ];
};

#define RASEAPUSERIDENTITYW struct tagRASEAPUSERIDENTITYW
RASEAPUSERIDENTITYW
{
    WCHAR       szUserName[ UNLEN + 1 ];
    DWORD       dwSizeofEapInfo;
    BYTE        pbEapInfo[ 1 ];
};

#ifdef UNICODE
#define RASEAPUSERIDENTITY RASEAPUSERIDENTITYW
#else
#define RASEAPUSERIDENTITY RASEAPUSERIDENTITYA
#endif

#define LPRASEAPUSERIDENTITYW RASEAPUSERIDENTITYW*
#define LPRASEAPUSERIDENTITYA RASEAPUSERIDENTITYA*

typedef DWORD (WINAPI *PFNRASGETBUFFER) (
                            PBYTE *ppBuffer,
                            PDWORD pdwSize
                            );

typedef DWORD (WINAPI *PFNRASFREEBUFFER) (
                            PBYTE pBufer);

typedef DWORD (WINAPI *PFNRASSENDBUFFER) (
                            HANDLE hPort,
                            PBYTE  pBuffer,
                            DWORD  dwSize
                            );

typedef DWORD (WINAPI *PFNRASRECEIVEBUFFER) (
                            HANDLE hPort,
                            PBYTE pBuffer,
                            PDWORD pdwSize,
                            DWORD  dwTimeOut,
                            HANDLE hEvent
                            );

typedef DWORD (WINAPI *PFNRASRETRIEVEBUFFER) (
                            HANDLE hPort,
                            PBYTE pBuffer,
                            PDWORD pdwSize
                            );

typedef  DWORD (WINAPI *RasCustomScriptExecuteFn) (
                            HANDLE hPort,
                            LPCWSTR lpszPhonebook,
                            LPCWSTR lpszEntryName,
                            PFNRASGETBUFFER pfnRasGetBuffer,
                            PFNRASFREEBUFFER pfnRasFreeBuffer,
                            PFNRASSENDBUFFER pfnRasSendBuffer,
                            PFNRASRECEIVEBUFFER pfnRasReceiveBuffer,
                            PFNRASRETRIEVEBUFFER pfnRasRetrieveBuffer,
                            HWND hWnd,
                            RASDIALPARAMS *pRasDialParams,
                            PVOID pvReserved
                            );
                            
                            
                            
                            

#endif // (WINVER >= 0x500)

#if (WINVER >= 0x0501)

#define RASCOMMSETTINGS struct tagRASCOMMSETTINGS
RASCOMMSETTINGS
{
    DWORD     dwSize;
    BYTE      bParity;
    BYTE      bStop;
    BYTE      bByteSize;
    BYTE      bAlign;
};

typedef DWORD (WINAPI *PFNRASSETCOMMSETTINGS) (
                            HANDLE hPort,
                            RASCOMMSETTINGS *pRasCommSettings,
                            PVOID  pvReserved
                            );

#define RASCUSTOMSCRIPTEXTENSIONS struct tagRASCUSTOMSCRIPTEXTENSIONS
RASCUSTOMSCRIPTEXTENSIONS
{
    DWORD                    dwSize;                  
    PFNRASSETCOMMSETTINGS    pfnRasSetCommSettings;
};

#endif


/* External RAS API function prototypes.
*/
DWORD APIENTRY RasDialA( LPRASDIALEXTENSIONS, LPCSTR, LPRASDIALPARAMSA, DWORD,
                   LPVOID, LPHRASCONN );

DWORD APIENTRY RasDialW( LPRASDIALEXTENSIONS, LPCWSTR, LPRASDIALPARAMSW, DWORD,
                   LPVOID, LPHRASCONN );

DWORD APIENTRY RasEnumConnectionsA( LPRASCONNA, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumConnectionsW( LPRASCONNW, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumEntriesA( LPCSTR, LPCSTR, LPRASENTRYNAMEA, LPDWORD,
                   LPDWORD );

DWORD APIENTRY RasEnumEntriesW( LPCWSTR, LPCWSTR, LPRASENTRYNAMEW, LPDWORD,
                   LPDWORD );

DWORD APIENTRY RasGetConnectStatusA( HRASCONN, LPRASCONNSTATUSA );

DWORD APIENTRY RasGetConnectStatusW( HRASCONN, LPRASCONNSTATUSW );

DWORD APIENTRY RasGetErrorStringA( UINT, LPSTR, DWORD );

DWORD APIENTRY RasGetErrorStringW( UINT, LPWSTR, DWORD );

DWORD APIENTRY RasHangUpA( HRASCONN );

DWORD APIENTRY RasHangUpW( HRASCONN );

DWORD APIENTRY RasGetProjectionInfoA( HRASCONN, RASPROJECTION, LPVOID,
                   LPDWORD );

DWORD APIENTRY RasGetProjectionInfoW( HRASCONN, RASPROJECTION, LPVOID,
                   LPDWORD );

DWORD APIENTRY RasCreatePhonebookEntryA( HWND, LPCSTR );

DWORD APIENTRY RasCreatePhonebookEntryW( HWND, LPCWSTR );

DWORD APIENTRY RasEditPhonebookEntryA( HWND, LPCSTR, LPCSTR );

DWORD APIENTRY RasEditPhonebookEntryW( HWND, LPCWSTR, LPCWSTR );

DWORD APIENTRY RasSetEntryDialParamsA( LPCSTR, LPRASDIALPARAMSA, BOOL );

DWORD APIENTRY RasSetEntryDialParamsW( LPCWSTR, LPRASDIALPARAMSW, BOOL );

DWORD APIENTRY RasGetEntryDialParamsA( LPCSTR, LPRASDIALPARAMSA, LPBOOL );

DWORD APIENTRY RasGetEntryDialParamsW( LPCWSTR, LPRASDIALPARAMSW, LPBOOL );

DWORD APIENTRY RasEnumDevicesA( LPRASDEVINFOA, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumDevicesW( LPRASDEVINFOW, LPDWORD, LPDWORD );

DWORD APIENTRY RasGetCountryInfoA( LPRASCTRYINFOA, LPDWORD );

DWORD APIENTRY RasGetCountryInfoW( LPRASCTRYINFOW, LPDWORD );

DWORD APIENTRY RasGetEntryPropertiesA( LPCSTR, LPCSTR, LPRASENTRYA, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasGetEntryPropertiesW( LPCWSTR, LPCWSTR, LPRASENTRYW, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasSetEntryPropertiesA( LPCSTR, LPCSTR, LPRASENTRYA, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasSetEntryPropertiesW( LPCWSTR, LPCWSTR, LPRASENTRYW, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasRenameEntryA( LPCSTR, LPCSTR, LPCSTR );

DWORD APIENTRY RasRenameEntryW( LPCWSTR, LPCWSTR, LPCWSTR );

DWORD APIENTRY RasDeleteEntryA( LPCSTR, LPCSTR );

DWORD APIENTRY RasDeleteEntryW( LPCWSTR, LPCWSTR );

DWORD APIENTRY RasValidateEntryNameA( LPCSTR, LPCSTR );

DWORD APIENTRY RasValidateEntryNameW( LPCWSTR, LPCWSTR );

DWORD APIENTRY RasConnectionNotificationA( HRASCONN, HANDLE, DWORD );

DWORD APIENTRY RasConnectionNotificationW( HRASCONN, HANDLE, DWORD );

#if (WINVER >= 0x401)
DWORD APIENTRY RasGetSubEntryHandleA( HRASCONN, DWORD, LPHRASCONN );

DWORD APIENTRY RasGetSubEntryHandleW( HRASCONN, DWORD, LPHRASCONN );

DWORD APIENTRY RasGetCredentialsA( LPCSTR, LPCSTR, LPRASCREDENTIALSA);

DWORD APIENTRY RasGetCredentialsW( LPCWSTR, LPCWSTR, LPRASCREDENTIALSW );

DWORD APIENTRY RasSetCredentialsA( LPCSTR, LPCSTR, LPRASCREDENTIALSA, BOOL );

DWORD APIENTRY RasSetCredentialsW( LPCWSTR, LPCWSTR, LPRASCREDENTIALSW, BOOL );

DWORD APIENTRY RasGetSubEntryPropertiesA( LPCSTR, LPCSTR, DWORD,
                    LPRASSUBENTRYA, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasGetSubEntryPropertiesW( LPCWSTR, LPCWSTR, DWORD,
                    LPRASSUBENTRYW, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasSetSubEntryPropertiesA( LPCSTR, LPCSTR, DWORD,
                    LPRASSUBENTRYA, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasSetSubEntryPropertiesW( LPCWSTR, LPCWSTR, DWORD,
                    LPRASSUBENTRYW, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasGetAutodialAddressA( LPCSTR, LPDWORD, LPRASAUTODIALENTRYA,
                    LPDWORD, LPDWORD );

DWORD APIENTRY RasGetAutodialAddressW( LPCWSTR, LPDWORD, LPRASAUTODIALENTRYW,
                    LPDWORD, LPDWORD);

DWORD APIENTRY RasSetAutodialAddressA( LPCSTR, DWORD, LPRASAUTODIALENTRYA,
                    DWORD, DWORD );

DWORD APIENTRY RasSetAutodialAddressW( LPCWSTR, DWORD, LPRASAUTODIALENTRYW,
                    DWORD, DWORD );

DWORD APIENTRY RasEnumAutodialAddressesA( LPSTR *, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumAutodialAddressesW( LPWSTR *, LPDWORD, LPDWORD );

DWORD APIENTRY RasGetAutodialEnableA( DWORD, LPBOOL );

DWORD APIENTRY RasGetAutodialEnableW( DWORD, LPBOOL );

DWORD APIENTRY RasSetAutodialEnableA( DWORD, BOOL );

DWORD APIENTRY RasSetAutodialEnableW( DWORD, BOOL );

DWORD APIENTRY RasGetAutodialParamA( DWORD, LPVOID, LPDWORD );

DWORD APIENTRY RasGetAutodialParamW( DWORD, LPVOID, LPDWORD );

DWORD APIENTRY RasSetAutodialParamA( DWORD, LPVOID, DWORD );

DWORD APIENTRY RasSetAutodialParamW( DWORD, LPVOID, DWORD );
#endif

#if (WINVER >= 0x500)

typedef struct _RAS_STATS
{
    DWORD   dwSize;
    DWORD   dwBytesXmited;
    DWORD   dwBytesRcved;
    DWORD   dwFramesXmited;
    DWORD   dwFramesRcved;
    DWORD   dwCrcErr;
    DWORD   dwTimeoutErr;
    DWORD   dwAlignmentErr;
    DWORD   dwHardwareOverrunErr;
    DWORD   dwFramingErr;
    DWORD   dwBufferOverrunErr;
    DWORD   dwCompressionRatioIn;
    DWORD   dwCompressionRatioOut;
    DWORD   dwBps;
    DWORD   dwConnectDuration;

} RAS_STATS, *PRAS_STATS;


typedef DWORD (WINAPI *RasCustomHangUpFn) (
                            HRASCONN hRasConn
                            );

typedef DWORD (WINAPI *RasCustomDialFn) (
		HINSTANCE           hInstDll,
		LPRASDIALEXTENSIONS lpRasDialExtensions,
		LPCWSTR              lpszPhonebook,
		LPRASDIALPARAMS     lpRasDialParams,
		DWORD               dwNotifierType,
		LPVOID              lpvNotifier,
		LPHRASCONN          lphRasConn,
		DWORD               dwFlags
        );

typedef DWORD (WINAPI *RasCustomDeleteEntryNotifyFn) (
        LPCWSTR             lpszPhonebook,
        LPCWSTR             lpszEntry,
        DWORD               dwFlags);


#define RCD_SingleUser  0
#define RCD_AllUsers    0x00000001
#define RCD_Eap         0x00000002
#define RCD_Logon       0x00000004

DWORD APIENTRY RasInvokeEapUI( HRASCONN, DWORD, LPRASDIALEXTENSIONS, HWND);

DWORD APIENTRY RasGetLinkStatistics(HRASCONN hRasConn,
                                    DWORD dwSubEntry,
                                    RAS_STATS *lpStatistics);

DWORD APIENTRY RasGetConnectionStatistics(HRASCONN hRasConn,
                                          RAS_STATS *lpStatistics);

DWORD APIENTRY RasClearLinkStatistics(HRASCONN hRasConn,
                                      DWORD dwSubEntry);


DWORD APIENTRY RasClearConnectionStatistics(HRASCONN hRasConn);

DWORD APIENTRY RasGetEapUserDataA(
                   HANDLE hToken,
                   LPCSTR pszPhonebook,
                   LPCSTR pszEntry,
                   BYTE   *pbEapData,
                   DWORD  *pdwSizeofEapData);


DWORD APIENTRY RasGetEapUserDataW(
                   HANDLE  hToken,
                   LPCWSTR pszPhonebook,
                   LPCWSTR pszEntry,
                   BYTE    *pbEapData,
                   DWORD   *pdwSizeofEapData);

DWORD APIENTRY RasSetEapUserDataA(
                   HANDLE hToken,
                   LPCSTR pszPhonebook,
                   LPCSTR pszEntry,
                   BYTE   *pbEapData,
                   DWORD  dwSizeofEapData);

DWORD APIENTRY RasSetEapUserDataW(
                   HANDLE  hToken,
                   LPCWSTR pszPhonebook,
                   LPCWSTR pszEntry,
                   BYTE    *pbEapData,
                   DWORD   dwSizeofEapData);

DWORD APIENTRY RasGetCustomAuthDataA(
                   LPCSTR pszPhonebook,
                   LPCSTR pszEntry,
                   BYTE   *pbCustomAuthData,
                   DWORD  *pdwSizeofCustomAuthData);


DWORD APIENTRY RasGetCustomAuthDataW(
                   LPCWSTR pszPhonebook,
                   LPCWSTR pszEntry,
                   BYTE    *pbCustomAuthData,
                   DWORD   *pdwSizeofCustomAuthData);

DWORD APIENTRY RasSetCustomAuthDataA(
                   LPCSTR pszPhonebook,
                   LPCSTR pszEntry,
                   BYTE   *pbCustomAuthData,
                   DWORD  dwSizeofCustomAuthData
                   );

DWORD APIENTRY RasSetCustomAuthDataW(
                   LPCWSTR pszPhonebook,
                   LPCWSTR pszEntry,
                   BYTE    *pbCustomAuthData,
                   DWORD   dwSizeofCustomAuthData
                   );
DWORD APIENTRY RasGetEapUserIdentityW(
                   LPCWSTR                  pszPhonebook,
                   LPCWSTR                  pszEntry,
                   DWORD                    dwFlags,
                   HWND                     hwnd,
                   LPRASEAPUSERIDENTITYW*   ppRasEapUserIdentity
);
DWORD APIENTRY RasGetEapUserIdentityA(
                   LPCSTR                   pszPhonebook,
                   LPCSTR                   pszEntry,
                   DWORD                    dwFlags,
                   HWND                     hwnd,
                   LPRASEAPUSERIDENTITYA*   ppRasEapUserIdentity
);
VOID APIENTRY RasFreeEapUserIdentityW(
                   LPRASEAPUSERIDENTITYW    pRasEapUserIdentity
);
VOID APIENTRY RasFreeEapUserIdentityA(
                   LPRASEAPUSERIDENTITYA    pRasEapUserIdentity
);
#endif

#if (WINVER >= 0x501)

DWORD APIENTRY  RasDeleteSubEntryA(
                LPCSTR pszPhonebook,
                LPCSTR pszEntry,
                DWORD  dwSubentryId);

DWORD APIENTRY  RasDeleteSubEntryW(
                LPCWSTR pszPhonebook,
                LPCWSTR pszEntry,
                DWORD   dwSubEntryId);
#endif

#ifdef UNICODE
#define RasDial                 RasDialW
#define RasEnumConnections      RasEnumConnectionsW
#define RasEnumEntries          RasEnumEntriesW
#define RasGetConnectStatus     RasGetConnectStatusW
#define RasGetErrorString       RasGetErrorStringW
#define RasHangUp               RasHangUpW
#define RasGetProjectionInfo    RasGetProjectionInfoW
#define RasCreatePhonebookEntry RasCreatePhonebookEntryW
#define RasEditPhonebookEntry   RasEditPhonebookEntryW
#define RasSetEntryDialParams   RasSetEntryDialParamsW
#define RasGetEntryDialParams   RasGetEntryDialParamsW
#define RasEnumDevices          RasEnumDevicesW
#define RasGetCountryInfo       RasGetCountryInfoW
#define RasGetEntryProperties   RasGetEntryPropertiesW
#define RasSetEntryProperties   RasSetEntryPropertiesW
#define RasRenameEntry          RasRenameEntryW
#define RasDeleteEntry          RasDeleteEntryW
#define RasValidateEntryName    RasValidateEntryNameW
#if (WINVER >= 0x401)
#define RasGetSubEntryHandle        RasGetSubEntryHandleW
#define RasConnectionNotification   RasConnectionNotificationW
#define RasGetSubEntryProperties    RasGetSubEntryPropertiesW
#define RasSetSubEntryProperties    RasSetSubEntryPropertiesW
#define RasGetCredentials           RasGetCredentialsW
#define RasSetCredentials           RasSetCredentialsW
#define RasGetAutodialAddress       RasGetAutodialAddressW
#define RasSetAutodialAddress       RasSetAutodialAddressW
#define RasEnumAutodialAddresses    RasEnumAutodialAddressesW
#define RasGetAutodialEnable        RasGetAutodialEnableW
#define RasSetAutodialEnable        RasSetAutodialEnableW
#define RasGetAutodialParam         RasGetAutodialParamW
#define RasSetAutodialParam         RasSetAutodialParamW
#endif
#if (WINVER >= 0x500)
#define RasGetEapUserData           RasGetEapUserDataW
#define RasSetEapUserData           RasSetEapUserDataW
#define RasGetCustomAuthData        RasGetCustomAuthDataW
#define RasSetCustomAuthData        RasSetCustomAuthDataW
#define RasGetEapUserIdentity       RasGetEapUserIdentityW
#define RasFreeEapUserIdentity      RasFreeEapUserIdentityW
#endif
#if(WINVER >= 0x501)
#define RasDeleteSubEntry           RasDeleteSubEntryW
#endif
#else
#define RasDial                 RasDialA
#define RasEnumConnections      RasEnumConnectionsA
#define RasEnumEntries          RasEnumEntriesA
#define RasGetConnectStatus     RasGetConnectStatusA
#define RasGetErrorString       RasGetErrorStringA
#define RasHangUp               RasHangUpA
#define RasGetProjectionInfo    RasGetProjectionInfoA
#define RasCreatePhonebookEntry RasCreatePhonebookEntryA
#define RasEditPhonebookEntry   RasEditPhonebookEntryA
#define RasSetEntryDialParams   RasSetEntryDialParamsA
#define RasGetEntryDialParams   RasGetEntryDialParamsA
#define RasEnumDevices          RasEnumDevicesA
#define RasGetCountryInfo       RasGetCountryInfoA
#define RasGetEntryProperties   RasGetEntryPropertiesA
#define RasSetEntryProperties   RasSetEntryPropertiesA
#define RasRenameEntry          RasRenameEntryA
#define RasDeleteEntry          RasDeleteEntryA
#define RasValidateEntryName    RasValidateEntryNameA
#if (WINVER >= 0x401)
#define RasGetSubEntryHandle        RasGetSubEntryHandleA
#define RasConnectionNotification   RasConnectionNotificationA
#define RasGetSubEntryProperties    RasGetSubEntryPropertiesA
#define RasSetSubEntryProperties    RasSetSubEntryPropertiesA
#define RasGetCredentials           RasGetCredentialsA
#define RasSetCredentials           RasSetCredentialsA
#define RasGetAutodialAddress       RasGetAutodialAddressA
#define RasSetAutodialAddress       RasSetAutodialAddressA
#define RasEnumAutodialAddresses    RasEnumAutodialAddressesA
#define RasGetAutodialEnable        RasGetAutodialEnableA
#define RasSetAutodialEnable        RasSetAutodialEnableA
#define RasGetAutodialParam         RasGetAutodialParamA
#define RasSetAutodialParam         RasSetAutodialParamA
#endif
#if (WINVER >= 0x500)
#define RasGetEapUserData           RasGetEapUserDataA
#define RasSetEapUserData           RasSetEapUserDataA
#define RasGetCustomAuthData        RasGetCustomAuthDataA
#define RasSetCustomAuthData        RasSetCustomAuthDataA
#define RasGetEapUserIdentity       RasGetEapUserIdentityA
#define RasFreeEapUserIdentity      RasFreeEapUserIdentityA
#endif
#if (WINVER >= 0x501)
#define RasDeleteSubEntry           RasDeleteSubEntryA
#endif
#endif

#ifdef __cplusplus
}
#endif

#include <poppack.h>

#endif // _RAS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\qosname.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    qosname.h

Abstract:

    This module contains the type definitions for the QOS name management routines, such as
    WSAInstallQOSTemplate etc.

Author:

    Jim Stewart     July 2, 1997

Revision History:

--*/

#if _MSC_VER > 1000
#pragma once
#endif

// Built-in QoS Templates
#define QT_1        "G711"
#define QT_2        "G723.1"
#define QT_3        "G729"
#define QT_4        "H263QCIF"
#define QT_5        "H263CIF"
#define QT_6        "H261QCIF"
#define QT_7        "H261CIF"
#define QT_8        "GSM6.10"


#define WSCINSTALL_QOS_TEMPLATE     "WSCInstallQOSTemplate"
#define WSCREMOVE_QOS_TEMPLATE      "WSCRemoveQOSTemplate"
#define WPUGET_QOS_TEMPLATE         "WPUGetQOSTemplate"

typedef
BOOL
(APIENTRY * WSC_INSTALL_QOS_TEMPLATE )(
    IN  const LPGUID    Guid,
    IN  LPWSABUF        QosName,
    IN  LPQOS           Qos
    );

typedef
BOOL
(APIENTRY * WSC_REMOVE_QOS_TEMPLATE )(
    IN  const LPGUID    Guid,
    IN  LPWSABUF        QosName
    );

typedef
BOOL
(APIENTRY * WPU_GET_QOS_TEMPLATE )(
    IN  const LPGUID    Guid,
    IN  LPWSABUF        QosName,
    IN  LPQOS           Qos
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\rasdlg.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rasdlg.h

Abstract:

    Remote Access Common Dialog APIs

    These APIs live in RASDLG.DLL.

    The APIs in this header are added in Windows NT SUR and are not available
    in prior Windows NT or Windows 95 releases.
    
--*/

#ifndef _RASDLG_H_
#define _RASDLG_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <pshpack4.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <ras.h>


/* RasPhonebookDlg API callback.
*/
typedef VOID (WINAPI* RASPBDLGFUNCW)( ULONG_PTR, DWORD, LPWSTR, LPVOID );
typedef VOID (WINAPI* RASPBDLGFUNCA)( ULONG_PTR, DWORD, LPSTR, LPVOID );

#define RASPBDEVENT_AddEntry    1
#define RASPBDEVENT_EditEntry   2
#define RASPBDEVENT_RemoveEntry 3
#define RASPBDEVENT_DialEntry   4
#define RASPBDEVENT_EditGlobals 5
#define RASPBDEVENT_NoUser      6
#define RASPBDEVENT_NoUserEdit  7

#define  RASNOUSER_SmartCard    0x00000001

/* Defines the information passed in the 4th argument of RASPBDLGFUNC on
** "NoUser" and "NoUserEdit" events.  Usage shown is for "NoUser".  For
** "NoUserEdit", the timeout is ignored and the three strings are INs.
*/
#define RASNOUSERW struct tagRASNOUSERW
RASNOUSERW
{
    IN  DWORD dwSize;
    IN  DWORD dwFlags;
    OUT DWORD dwTimeoutMs;
    OUT WCHAR szUserName[ UNLEN + 1 ];
    OUT WCHAR szPassword[ PWLEN + 1 ];
    OUT WCHAR szDomain[ DNLEN + 1 ];
};

#define RASNOUSERA struct tagRASNOUSERA
RASNOUSERA
{
    IN  DWORD dwSize;
    IN  DWORD dwFlags;
    OUT DWORD dwTimeoutMs;
    OUT CHAR  szUserName[ UNLEN + 1 ];
    OUT CHAR  szPassword[ PWLEN + 1 ];
    OUT CHAR  szDomain[ DNLEN + 1 ];
};

#ifdef UNICODE
#define RASNOUSER RASNOUSERW
#else
#define RASNOUSER RASNOUSERA
#endif

#define LPRASNOUSERW RASNOUSERW*
#define LPRASNOUSERA RASNOUSERA*
#define LPRASNOUSER  RASNOUSER*


/* RasPhonebookDlg API parameters.
*/
#define RASPBDFLAG_PositionDlg      0x00000001
#define RASPBDFLAG_ForceCloseOnDial 0x00000002
#define RASPBDFLAG_NoUser           0x00000010
#define RASPBDFLAG_UpdateDefaults   0x80000000

#define RASPBDLGW struct tagRASPBDLGW
RASPBDLGW
{
    IN  DWORD         dwSize;
    IN  HWND          hwndOwner;
    IN  DWORD         dwFlags;
    IN  LONG          xDlg;
    IN  LONG          yDlg;
    IN  ULONG_PTR     dwCallbackId;
    IN  RASPBDLGFUNCW pCallback;
    OUT DWORD         dwError;
    IN  ULONG_PTR     reserved;
    IN  ULONG_PTR     reserved2;
};

#define RASPBDLGA struct tagRASPBDLGA
RASPBDLGA
{
    IN  DWORD         dwSize;
    IN  HWND          hwndOwner;
    IN  DWORD         dwFlags;
    IN  LONG          xDlg;
    IN  LONG          yDlg;
    IN  ULONG_PTR     dwCallbackId;
    IN  RASPBDLGFUNCA pCallback;
    OUT DWORD         dwError;
    IN  ULONG_PTR     reserved;
    IN  ULONG_PTR     reserved2;
};

#ifdef UNICODE
#define RASPBDLG     RASPBDLGW
#define RASPBDLGFUNC RASPBDLGFUNCW
#else
#define RASPBDLG     RASPBDLGA
#define RASPBDLGFUNC RASPBDLGFUNCA
#endif

#define LPRASPBDLGW RASPBDLGW*
#define LPRASPBDLGA RASPBDLGA*
#define LPRASPBDLG  RASPBDLG*


/* RasEntryDlg API parameters.
*/
#define RASEDFLAG_PositionDlg    0x00000001
#define RASEDFLAG_NewEntry       0x00000002
#define RASEDFLAG_CloneEntry     0x00000004
#define RASEDFLAG_NoRename       0x00000008
#define RASEDFLAG_ShellOwned     0x40000000
#define RASEDFLAG_NewPhoneEntry  0x00000010
#define RASEDFLAG_NewTunnelEntry 0x00000020
#define RASEDFLAG_NewDirectEntry 0x00000040
#define RASEDFLAG_NewBroadbandEntry  0x00000080
#define RASEDFLAG_InternetEntry  0x00000100
#define RASEDFLAG_NAT            0x00000200

#define RASENTRYDLGW struct tagRASENTRYDLGW
RASENTRYDLGW
{
    IN  DWORD dwSize;
    IN  HWND  hwndOwner;
    IN  DWORD dwFlags;
    IN  LONG  xDlg;
    IN  LONG  yDlg;
    OUT WCHAR szEntry[ RAS_MaxEntryName + 1 ];
    OUT DWORD dwError;
    IN  ULONG_PTR reserved;
    IN  ULONG_PTR reserved2;
};

#define RASENTRYDLGA struct tagRASENTRYDLGA
RASENTRYDLGA
{
    IN  DWORD dwSize;
    IN  HWND  hwndOwner;
    IN  DWORD dwFlags;
    IN  LONG  xDlg;
    IN  LONG  yDlg;
    OUT CHAR  szEntry[ RAS_MaxEntryName + 1 ];
    OUT DWORD dwError;
    IN  ULONG_PTR reserved;
    IN  ULONG_PTR reserved2;
};

#ifdef UNICODE
#define RASENTRYDLG RASENTRYDLGW
#else
#define RASENTRYDLG RASENTRYDLGA
#endif

#define LPRASENTRYDLGW RASENTRYDLGW*
#define LPRASENTRYDLGA RASENTRYDLGA*
#define LPRASENTRYDLG  RASENTRYDLG*


/* RasDialDlg API parameters.
*/
#define RASDDFLAG_PositionDlg 0x00000001
#define RASDDFLAG_NoPrompt    0x00000002
#define RASDDFLAG_LinkFailure 0x80000000

#define RASDIALDLG struct tagRASDIALDLG
RASDIALDLG
{
    IN  DWORD dwSize;
    IN  HWND  hwndOwner;
    IN  DWORD dwFlags;
    IN  LONG  xDlg;
    IN  LONG  yDlg;
    IN  DWORD dwSubEntry;
    OUT DWORD dwError;
    IN  ULONG_PTR reserved;
    IN  ULONG_PTR reserved2;
};

#define LPRASDIALDLG RASDIALDLG*


/* RasMonitorDlg API parameters.
*/
#if (WINVER <= 0x500)
#define RASMDPAGE_Status            0
#define RASMDPAGE_Summary           1
#define RASMDPAGE_Preferences       2

#define RASMDFLAG_PositionDlg       0x00000001
#define RASMDFLAG_UpdateDefaults    0x80000000

#define RASMONITORDLG struct tagRASMONITORDLG
RASMONITORDLG
{
    IN  DWORD dwSize;
    IN  HWND  hwndOwner;
    IN  DWORD dwFlags;
    IN  DWORD dwStartPage;
    IN  LONG  xDlg;
    IN  LONG  yDlg;
    OUT DWORD dwError;
    IN  ULONG_PTR reserved;
    IN  ULONG_PTR reserved2;
};

#define LPRASMONITORDLG RASMONITORDLG*
#endif

#if (WINVER >= 0x500)
typedef BOOL (WINAPI *RasCustomDialDlgFn) (
                            HINSTANCE hInstDll,
                            DWORD dwFlags,
                            LPWSTR lpszPhonebook,
                            LPWSTR lpszEntry,
                            LPWSTR lpszPhoneNumber,
                            LPRASDIALDLG lpInfo,
                            PVOID pvInfo
                            );

typedef BOOL (WINAPI *RasCustomEntryDlgFn) (
                            HINSTANCE hInstDll,
                            LPWSTR lpszPhonebook,
                            LPWSTR lpszEntry,
                            LPRASENTRYDLG lpInfo,
                            DWORD  dwFlags
                            );


#endif


/* RAS common dialog API prototypes.
*/
BOOL APIENTRY RasPhonebookDlgA(
    LPSTR lpszPhonebook, LPSTR lpszEntry, LPRASPBDLGA lpInfo );

BOOL APIENTRY RasPhonebookDlgW(
    LPWSTR lpszPhonebook, LPWSTR lpszEntry, LPRASPBDLGW lpInfo );

BOOL APIENTRY RasEntryDlgA(
    LPSTR lpszPhonebook, LPSTR lpszEntry, LPRASENTRYDLGA lpInfo );

BOOL APIENTRY RasEntryDlgW(
    LPWSTR lpszPhonebook, LPWSTR lpszEntry, LPRASENTRYDLGW lpInfo );

BOOL APIENTRY RasDialDlgA(
    LPSTR lpszPhonebook, LPSTR lpszEntry, LPSTR lpszPhoneNumber,
    LPRASDIALDLG lpInfo );

BOOL APIENTRY RasDialDlgW(
    LPWSTR lpszPhonebook, LPWSTR lpszEntry, LPWSTR lpszPhoneNumber,
    LPRASDIALDLG lpInfo );

#if (WINVER <= 0x500)
BOOL APIENTRY RasMonitorDlgA(
    LPSTR lpszDeviceName, LPRASMONITORDLG lpInfo );

BOOL APIENTRY RasMonitorDlgW(
    LPWSTR lpszDeviceName, LPRASMONITORDLG lpInfo );
#endif


#ifdef UNICODE
#define RasPhonebookDlg RasPhonebookDlgW
#define RasEntryDlg     RasEntryDlgW
#define RasDialDlg      RasDialDlgW
#if (WINVER <= 0x500)
#define RasMonitorDlg   RasMonitorDlgW
#endif
#else
#define RasPhonebookDlg RasPhonebookDlgA
#define RasEntryDlg     RasEntryDlgA
#define RasDialDlg      RasDialDlgA
#if (WINVER <= 0x500)
#define RasMonitorDlg   RasMonitorDlgA
#endif
#endif



#ifdef __cplusplus
}
#endif

#include <poppack.h>

#endif // _RASDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\qossp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    qos.h - QoS definitions for NDIS components.

Abstract:

    This module defines the type of objects that can go into the 
    ProviderSpecific buffer in the QOS structure.

Revision History:

--*/

#ifndef __QOSSP_H_
#define __QOSSP_H_

/*
 * Definition of object Types
 *
 *
 * define the values for ObjectType above - RSVP Objects ids start at an 
 * offset from zero to allow for ATM objects that might be defined in the 
 * lower number range.
 */
#define   RSVP_OBJECT_ID_BASE         1000
#define   RSVP_OBJECT_STATUS_INFO     (0x00000000 + RSVP_OBJECT_ID_BASE)
          /* RSVP_STATUS_INFO structure passed */
#define   RSVP_OBJECT_RESERVE_INFO    (0x00000001 + RSVP_OBJECT_ID_BASE)
          /* RSVP_RESERVE_INFO structure passed */
#define   RSVP_OBJECT_ADSPEC          (0x00000002 + RSVP_OBJECT_ID_BASE)
          /* RSVP_ADSPEC structure passed */
#define   RSVP_OBJECT_POLICY_INFO     (0x00000003 + RSVP_OBJECT_ID_BASE)
          /* RSVP POLICY ELEMENT(S) retrieved */
#define   RSVP_OBJECT_FILTERSPEC_LIST (0x00000004 + RSVP_OBJECT_ID_BASE)
          /* RSVP SENDER LIST returned */


/* 
 * IPV4 addressing for RSVP FILTERSPECS
 */
typedef union _IN_ADDR_IPV4 {

    ULONG  Addr;
    UCHAR  AddrBytes[4];

} IN_ADDR_IPV4, *LPIN_ADDR_IPV4;

/*
 * IPV6 addressing for RSVP FILTERSPECS
 */
typedef struct _IN_ADDR_IPV6 {

    UCHAR  Addr[16];               //IPV6 address

} IN_ADDR_IPV6, *LPIN_ADDR_IPV6;

typedef const IN_ADDR_IPV6  *LPCIN_ADDR_IPV6;

/*
 * IPV4 addressing for RSVP FILTERSPECS
 */
typedef struct _RSVP_FILTERSPEC_V4 {

    IN_ADDR_IPV4    Address;
    USHORT          Unused;
    USHORT          Port;

} RSVP_FILTERSPEC_V4, *LPRSVP_FILTERSPEC_V4;

typedef struct _RSVP_FILTERSPEC_V6 {

    IN_ADDR_IPV6    Address;
    USHORT          UnUsed;
    USHORT          Port;

} RSVP_FILTERSPEC_V6, *LPRSVP_FILTERSPEC_V6;


typedef struct _RSVP_FILTERSPEC_V6_FLOW {

    IN_ADDR_IPV6    Address;
    UCHAR           UnUsed;
    UCHAR           FlowLabel[3];

} RSVP_FILTERSPEC_V6_FLOW, *LPRSVP_FILTERSPEC_V6_FLOW;

typedef struct _RSVP_FILTERSPEC_V4_GPI {

    IN_ADDR_IPV4    Address;
    ULONG           GeneralPortId;

} RSVP_FILTERSPEC_V4_GPI, *LPRSVP_FILTERSPEC_V4_GPI;

typedef struct _RSVP_FILTERSPEC_V6_GPI {

    IN_ADDR_IPV6    Address;
    ULONG           GeneralPortId;

} RSVP_FILTERSPEC_V6_GPI, *LPRSVP_FILTERSPEC_V6_GPI;


/*
 * FILTERSPEC TYPES used in making reservations.
 */
typedef enum {

        FILTERSPECV4 = 1,
        FILTERSPECV6,
        FILTERSPECV6_FLOW,
        FILTERSPECV4_GPI,
        FILTERSPECV6_GPI,
        FILTERSPEC_END

} FilterType;

typedef struct _RSVP_FILTERSPEC {

    FilterType   Type;

    union {
        RSVP_FILTERSPEC_V4      FilterSpecV4;
        RSVP_FILTERSPEC_V6      FilterSpecV6;
        RSVP_FILTERSPEC_V6_FLOW FilterSpecV6Flow;
        RSVP_FILTERSPEC_V4_GPI  FilterSpecV4Gpi;
        RSVP_FILTERSPEC_V6_GPI  FilterSpecV6Gpi;
    };

} RSVP_FILTERSPEC, *LPRSVP_FILTERSPEC;

/*
 * FLOWDESCRIPTOR Structure used for specifying one or more
 * Filters per Flowspec.
 */
typedef struct _FLOWDESCRIPTOR {

    FLOWSPEC            FlowSpec;
    ULONG               NumFilters;
    LPRSVP_FILTERSPEC   FilterList;

} FLOWDESCRIPTOR, *LPFLOWDESCRIPTOR;

/*
 * RSVP_POLICY contains undefined policy data.  RSVP transports this
 * data on behalf of the Policy Control component.
 */
typedef struct _RSVP_POLICY {
    USHORT  Len;         /* total length of this element object */
    USHORT  Type;
    UCHAR   Info[4];
} RSVP_POLICY, *LPRSVP_POLICY;

typedef const RSVP_POLICY *LPCRSVP_POLICY;
#define RSVP_POLICY_HDR_LEN    ( sizeof(USHORT) + sizeof(USHORT) )

/*
 * RSVP_POLICY_INFO contains undefined policy element(s) retrieved from RSVP.  
 */
typedef struct _RSVP_POLICY_INFO  {

    QOS_OBJECT_HDR     ObjectHdr;
    ULONG              NumPolicyElement;         /* count of the 
                                                  * number of policy elements */
    RSVP_POLICY        PolicyElement[1];         /* a list of the policy 
                                                  * elements retrieved */

} RSVP_POLICY_INFO, *LPRSVP_POLICY_INFO;

/*
 * RSVP_RESERVE_INFO Structure used for storing RSVP specific
 * information for fine tuning interaction via the Winsock2
 * Generic QoS API via the provider specific buffer. This structure
 * includes the QOS_OBJECT_HDR structure directly
 */

typedef struct _RSVP_RESERVE_INFO {

    QOS_OBJECT_HDR      ObjectHdr;            /* type and length of this object */
    ULONG               Style;                /* RSVP Style (FF,WF,SE) */
    ULONG               ConfirmRequest;       /* Non Zero for Confirm Request (receive only) */
    LPRSVP_POLICY_INFO  PolicyElementList;    /* Points to the set of policy elements */
    ULONG               NumFlowDesc;          /* Number of FlowDesc */
    LPFLOWDESCRIPTOR    FlowDescList;         /* Points to the FlowDesc list */

} RSVP_RESERVE_INFO, *LPRSVP_RESERVE_INFO;

typedef const RSVP_RESERVE_INFO *LPCRSVP_RESERVE_INFO;

/*
 * definitions for the ulStyle in the previous structure
 */
#define RSVP_DEFAULT_STYLE            0x00000000
#define RSVP_WILDCARD_STYLE           0x00000001
#define RSVP_FIXED_FILTER_STYLE       0x00000002
#define RSVP_SHARED_EXPLICIT_STYLE    0x00000003

/*
 * RSVP_STATUS_INFO Structure used for storing RSVP specific
 * error of status indications.  This also serves as a header
 * for additional objects in the provider specific buffer when
 * interacting via Winsock2 Generic QoS API. This structure includes
 * the QOS_OBJECT_COUNT and QOS_OBJECT_HDR structures directly It is
 * expected to be the first structure in the provider specific structure
 * since it includes the QOS_OBJECT_COUNT
 */

typedef struct _RSVP_STATUS_INFO {

    QOS_OBJECT_HDR      ObjectHdr;      /* Object Hdr */
    ULONG               StatusCode;     /* Error or Status Information see 
                                         * Winsock2.h */
    ULONG               ExtendedStatus1;/* Provider specific status extension */
    ULONG               ExtendedStatus2;/* Provider specific status extension */

} RSVP_STATUS_INFO, *LPRSVP_STATUS_INFO;

typedef const RSVP_STATUS_INFO *LPCRSVP_STATUS_INFO;


/*
 * QOS_DestAddr structure -- used for WSAIoctl(SIO_SET_QOS) when we
 * do not want to issue a connect for a sending socket.  The destination
 * address is required so we can generate the session information for
 * RSVP signalling.
*/

typedef struct _QOS_DESTADDR {
    QOS_OBJECT_HDR ObjectHdr;                     /* Object header */
    const struct sockaddr *  SocketAddress;       /* Destination socket address */
    ULONG                    SocketAddressLength; /* Length of the address structure */
} QOS_DESTADDR, *LPQOS_DESTADDR;

typedef const QOS_DESTADDR * LPCQOS_DESTADDR;



/*
 * this structure defines the "General Characterization Parameters" contained in
 * the RSVP Adspec object
 */
typedef struct _AD_GENERAL_PARAMS{

    ULONG       IntServAwareHopCount;   /* number of hops that conform to
                                         * Integrated Services requirements */
    ULONG       PathBandwidthEstimate;  /* minimum bandwidth available from 
                                         * sender to receiver */
    ULONG       MinimumLatency;         /* sum of minimum latency of the packet
                                         * forwarding process in routers 
                                         * (in usec)*/
    ULONG       PathMTU;                /* max transmission unit end to end that
                                         * will not incur fragmentation */
    ULONG       Flags;                  /* used to hold break bits.*/

} AD_GENERAL_PARAMS, *LPAD_GENERAL_PARAMS;

/*
 * Minimum Latency may be set to this "undefined" value
 */
#define INDETERMINATE_LATENCY   0xFFFFFFFF;

/*
 * This Flag is used to indicate the existence of a network element not 
 * supporting  QoS control services somewhere in the data path. If this bit 
 * is set in the specific service override then it indicates that that
 * service was not supported at at least one hop.
 */
#define AD_FLAG_BREAK_BIT    0x00000001

/*
 * this structure describes the Guaranteed service parameters
 */
typedef struct _AD_GUARANTEED {

    ULONG       CTotal;
    ULONG       DTotal;
    ULONG       CSum;
    ULONG       DSum;

} AD_GUARANTEED, *LPAD_GUARANTEED;

/*
 * this structure describes the format of the parameter buffer that can be
 * included in the Service_Type structure below.  This structure allows an
 * application to include any valid Int Serv service parameter in the Buffer 
 * value, after providing the Int Serv parameter id in the ParameterId field.
 */
typedef struct _PARAM_BUFFER {

    ULONG   ParameterId;    /* Int Server parameter ID */
    ULONG   Length;         /* total length of this structure 
                             * ( 8 bytes + length of Buffer ) */
    UCHAR   Buffer[1];      /* Paramter itself */

} PARAM_BUFFER, *LPPARAM_BUFFER;

/*
 * this structure contains the service types supported
 */
typedef struct _CONTROL_SERVICE {

    /*
     * the length of this entire structure including the following buffer.  
     * This length value can be added to the ptr to the structure to get the ptr
     * to the next SERVICE_TYPE structure in the list, until the
     * NumberOfServices count has been exhausted.
     */
    ULONG               Length;

    SERVICETYPE         Service;
    AD_GENERAL_PARAMS   Overrides;

    /*
     * service specific information ( controlled load has no service specific 
     * info here )
     */
    union {
        AD_GUARANTEED   Guaranteed;
        PARAM_BUFFER    ParamBuffer[1];     /* allows for other services down 
                                             * the road */
    };

} CONTROL_SERVICE, *LPCONTROL_SERVICE;

/*
 * This structure defines the information which is carried in the Rsvp 
 * Adspec.  This Rsvp object typically indicates which service types are 
 * available ( Controlled Load and/or Guaranteed Service ), if a non-Rsvp
 * hop has been encountered by the Path message, and the minumum MTU along 
 * the path. The services array indicates which services are supported
 */
typedef struct _RSVP_ADSPEC  {

    QOS_OBJECT_HDR     ObjectHdr;
    AD_GENERAL_PARAMS  GeneralParams;      /* contains the general 
                                            * characterization paramters */
    ULONG              NumberOfServices;   /* count of the number of services */
    CONTROL_SERVICE    Services[1];        /* a list of the services 
                                            * supported/requested */

} RSVP_ADSPEC, *LPRSVP_ADSPEC;


//
// Opcode for the SIO_CHK_QOS ioctl
// (specific for the Microsoft QOS Service Provider
//
// Bascially:
//
// SIO_CHK_QOS = _WSAIORW(IOC_VENDOR,1)
//             = mIOC_IN | mIOC_OUT | mIOC_VENDOR | mCOMPANY | ioctl_code
//    where
//         mIOC_IN     = 0x80000000
//         mIOC_OUT    = 0x40000000
//         mIOC_VENDOR = 0x04000000
//         mCOMPANY    = 0x18000000
//         ioctl_code  = 0x00000001
//         
// See WSAIoctl man page for details.
//

#define    mIOC_IN       0x80000000
#define    mIOC_OUT      0x40000000
#define    mIOC_VENDOR   0x04000000
#define    mCOMPANY      0x18000000
#define    ioctl_code    0x00000001

#define SIO_CHK_QOS   mIOC_IN | mIOC_OUT | mIOC_VENDOR | mCOMPANY | ioctl_code

//
// The following may be specified in the input buffer 
// of the SIO_CHK_IOCTL ioctl call 
//

#define QOSSPBASE           50000

#define ALLOWED_TO_SEND_DATA  (QOSSPBASE+1)     // query the SBM/BEST_EFFORT limit 
                                                //   -- result is based on a comparison between
                                                //      the user-specified token rate and the
                                                //      SBM/BEST_EFFORT bandwidth parameters in
                                                //      the system
                                                //   -- result is a YES(1) or NO(0) answer
                                                //      in the output buffer 

#define ABLE_TO_RECV_RSVP     (QOSSPBASE+2)     // query the SBM/BEST_EFFORT limit 
                                                //   -- result is based on a comparison between
                                                //      the user-specified token rate and the
                                                //      SBM/BEST_EFFORT bandwidth parameters in
                                                //      the system
                                                //   -- result is a YES(1) or NO(0) answer
                                                //      in the output buffer 

#define LINE_RATE             (QOSSPBASE+3)     // query the interface capacity 
                                                //   -- result returned in the output buffer
                                                //      in kilo-bits per second

#define LOCAL_TRAFFIC_CONTROL (QOSSPBASE+4)     // check if Kernel Traffic Control is available or not
                                                //   -- 0 if not available
                                                //   -- 1 if avaiable
                                                //   -- INFO_NOT_AVAILABLE if there is no way to check

#define LOCAL_QOSABILITY      (QOSSPBASE+5)     // The followings are for 
                                                // the Discovery of Local QOSability
                                                //   -- 0 if no local QOS support
                                                //   -- 1 if local QOS support available
                                                //   -- INFO_NOT_AVAILABLE if there is no way to check

#define END_TO_END_QOSABILITY (QOSSPBASE+6)     // The followings are for 
                                                // the Discovery of End-to-End QOSability
                                                //   -- 0 if no end-to-end QOS support
                                                //   -- 1 if end-to-end QOS support available
                                                //   -- INFO_NOT_AVAILABLE if there is no way to check

#define INFO_NOT_AVAILABLE  0xFFFFFFFF          // used when LINE_RATE is not known


#define ANY_DEST_ADDR       0xFFFFFFFF          // for QOS_OBJECT_DEST_ADDR


// The followings are for Guaranteed_Service+Latency -> ISSLOW_Traffic_Class Mapping

#define MODERATELY_DELAY_SENSITIVE   0xFFFFFFFD  

#define HIGHLY_DELAY_SENSITIVE       0xFFFFFFFE

//
// QOSSP Error Code/Value
//

#define QOSSP_ERR_BASE                                 (QOSSPBASE+6000)

// No error
#define GQOS_NO_ERRORCODE                              (0)

#define GQOS_NO_ERRORVALUE                             (0)

// Unknown error
#define GQOS_ERRORCODE_UNKNOWN                         (0xFFFFFFFF)

#define GQOS_ERRORVALUE_UNKNOWN                        (0xFFFFFFFF)

// Admission (Resource) Error
#define GQOS_NET_ADMISSION                             (QOSSP_ERR_BASE+100)

#define GQOS_OTHER                                     (QOSSP_ERR_BASE+100+1)
#define GQOS_DELAYBND                                  (QOSSP_ERR_BASE+100+2)
#define GQOS_BANDWIDTH                                 (QOSSP_ERR_BASE+100+3)
#define GQOS_MTU                                       (QOSSP_ERR_BASE+100+4)
#define GQOS_FLOW_RATE                                 (QOSSP_ERR_BASE+100+5)
#define GQOS_PEAK_RATE                                 (QOSSP_ERR_BASE+100+6)
#define GQOS_AGG_PEAK_RATE                             (QOSSP_ERR_BASE+100+7)

// Policy Error
#define GQOS_NET_POLICY                                (QOSSP_ERR_BASE+200)

#define GQOS_POLICY_ERROR_UNKNOWN                      (QOSSP_ERR_BASE+200+0)

#define GQOS_POLICY_GLOBAL_DEF_FLOW_COUNT              (QOSSP_ERR_BASE+200+1)
#define GQOS_POLICY_GLOBAL_GRP_FLOW_COUNT              (QOSSP_ERR_BASE+200+2)
#define GQOS_POLICY_GLOBAL_USER_FLOW_COUNT             (QOSSP_ERR_BASE+200+3)
#define GQOS_POLICY_GLOBAL_UNK_USER_FLOW_COUNT         (QOSSP_ERR_BASE+200+4)
#define GQOS_POLICY_SUBNET_DEF_FLOW_COUNT              (QOSSP_ERR_BASE+200+5)
#define GQOS_POLICY_SUBNET_GRP_FLOW_COUNT              (QOSSP_ERR_BASE+200+6)
#define GQOS_POLICY_SUBNET_USER_FLOW_COUNT             (QOSSP_ERR_BASE+200+7)
#define GQOS_POLICY_SUBNET_UNK_USER_FLOW_COUNT         (QOSSP_ERR_BASE+200+8)

#define GQOS_POLICY_GLOBAL_DEF_FLOW_DURATION           (QOSSP_ERR_BASE+200+9)
#define GQOS_POLICY_GLOBAL_GRP_FLOW_DURATION           (QOSSP_ERR_BASE+200+10)
#define GQOS_POLICY_GLOBAL_USER_FLOW_DURATION          (QOSSP_ERR_BASE+200+11)
#define GQOS_POLICY_GLOBAL_UNK_USER_FLOW_DURATION      (QOSSP_ERR_BASE+200+12)
#define GQOS_POLICY_SUBNET_DEF_FLOW_DURATION           (QOSSP_ERR_BASE+200+13)
#define GQOS_POLICY_SUBNET_GRP_FLOW_DURATION           (QOSSP_ERR_BASE+200+14) 
#define GQOS_POLICY_SUBNET_USER_FLOW_DURATION          (QOSSP_ERR_BASE+200+15)
#define GQOS_POLICY_SUBNET_UNK_USER_FLOW_DURATION      (QOSSP_ERR_BASE+200+16)

#define GQOS_POLICY_GLOBAL_DEF_FLOW_RATE               (QOSSP_ERR_BASE+200+17)
#define GQOS_POLICY_GLOBAL_GRP_FLOW_RATE               (QOSSP_ERR_BASE+200+18)
#define GQOS_POLICY_GLOBAL_USER_FLOW_RATE              (QOSSP_ERR_BASE+200+19)
#define GQOS_POLICY_GLOBAL_UNK_USER_FLOW_RATE          (QOSSP_ERR_BASE+200+20)
#define GQOS_POLICY_SUBNET_DEF_FLOW_RATE               (QOSSP_ERR_BASE+200+21)
#define GQOS_POLICY_SUBNET_GRP_FLOW_RATE               (QOSSP_ERR_BASE+200+22)
#define GQOS_POLICY_SUBNET_USER_FLOW_RATE              (QOSSP_ERR_BASE+200+23)
#define GQOS_POLICY_SUBNET_UNK_USER_FLOW_RATE          (QOSSP_ERR_BASE+200+24)

#define GQOS_POLICY_GLOBAL_DEF_PEAK_RATE               (QOSSP_ERR_BASE+200+25)
#define GQOS_POLICY_GLOBAL_GRP_PEAK_RATE               (QOSSP_ERR_BASE+200+26)
#define GQOS_POLICY_GLOBAL_USER_PEAK_RATE              (QOSSP_ERR_BASE+200+27)
#define GQOS_POLICY_GLOBAL_UNK_USER_PEAK_RATE          (QOSSP_ERR_BASE+200+28)
#define GQOS_POLICY_SUBNET_DEF_PEAK_RATE               (QOSSP_ERR_BASE+200+29)
#define GQOS_POLICY_SUBNET_GRP_PEAK_RATE               (QOSSP_ERR_BASE+200+30)
#define GQOS_POLICY_SUBNET_USER_PEAK_RATE              (QOSSP_ERR_BASE+200+31)
#define GQOS_POLICY_SUBNET_UNK_USER_PEAK_RATE          (QOSSP_ERR_BASE+200+32)

#define GQOS_POLICY_GLOBAL_DEF_SUM_FLOW_RATE           (QOSSP_ERR_BASE+200+33)
#define GQOS_POLICY_GLOBAL_GRP_SUM_FLOW_RATE           (QOSSP_ERR_BASE+200+34)
#define GQOS_POLICY_GLOBAL_USER_SUM_FLOW_RATE          (QOSSP_ERR_BASE+200+35)
#define GQOS_POLICY_GLOBAL_UNK_USER_SUM_FLOW_RATE      (QOSSP_ERR_BASE+200+36)
#define GQOS_POLICY_SUBNET_DEF_SUM_FLOW_RATE           (QOSSP_ERR_BASE+200+37)
#define GQOS_POLICY_SUBNET_GRP_SUM_FLOW_RATE           (QOSSP_ERR_BASE+200+38)
#define GQOS_POLICY_SUBNET_USER_SUM_FLOW_RATE          (QOSSP_ERR_BASE+200+39)
#define GQOS_POLICY_SUBNET_UNK_USER_SUM_FLOW_RATE      (QOSSP_ERR_BASE+200+40)

#define GQOS_POLICY_GLOBAL_DEF_SUM_PEAK_RATE           (QOSSP_ERR_BASE+200+41)
#define GQOS_POLICY_GLOBAL_GRP_SUM_PEAK_RATE           (QOSSP_ERR_BASE+200+42)
#define GQOS_POLICY_GLOBAL_USER_SUM_PEAK_RATE          (QOSSP_ERR_BASE+200+43)
#define GQOS_POLICY_GLOBAL_UNK_USER_SUM_PEAK_RATE      (QOSSP_ERR_BASE+200+44)
#define GQOS_POLICY_SUBNET_DEF_SUM_PEAK_RATE           (QOSSP_ERR_BASE+200+45)
#define GQOS_POLICY_SUBNET_GRP_SUM_PEAK_RATE           (QOSSP_ERR_BASE+200+46)
#define GQOS_POLICY_SUBNET_USER_SUM_PEAK_RATE          (QOSSP_ERR_BASE+200+47)
#define GQOS_POLICY_SUBNET_UNK_USER_SUM_PEAK_RATE      (QOSSP_ERR_BASE+200+48)

#define GQOS_POLICY_UNKNOWN_USER                       (QOSSP_ERR_BASE+200+49)
#define GQOS_POLICY_NO_PRIVILEGES                      (QOSSP_ERR_BASE+200+50)
#define GQOS_POLICY_EXPIRED_USER_TOKEN                 (QOSSP_ERR_BASE+200+51)
#define GQOS_POLICY_NO_RESOURCES                       (QOSSP_ERR_BASE+200+52)
#define GQOS_POLICY_PRE_EMPTED                         (QOSSP_ERR_BASE+200+53)
#define GQOS_POLICY_USER_CHANGED                       (QOSSP_ERR_BASE+200+54)
#define GQOS_POLICY_NO_ACCEPTS                         (QOSSP_ERR_BASE+200+55)
#define GQOS_POLICY_NO_MEMORY                          (QOSSP_ERR_BASE+200+56)
#define GQOS_POLICY_CRAZY_FLOWSPEC                     (QOSSP_ERR_BASE+200+57)

#define GQOS_POLICY_NO_MORE_INFO                       (QOSSP_ERR_BASE+200+58)
#define GQOS_POLICY_UNSUPPORTED_CREDENTIAL_TYPE        (QOSSP_ERR_BASE+200+59)
#define GQOS_POLICY_INSUFFICIENT_PRIVILEGES            (QOSSP_ERR_BASE+200+60)
#define GQOS_POLICY_EXPIRED_CREDENTIAL                 (QOSSP_ERR_BASE+200+61)
#define GQOS_POLICY_IDENTITY_CHANGED                   (QOSSP_ERR_BASE+200+62)
#define GQOS_POLICY_NO_QOS_PROVIDED                    (QOSSP_ERR_BASE+200+63)
#define GQOS_POLICY_DO_NOT_SEND                        (QOSSP_ERR_BASE+200+64)

#define GQOS_POLICY_ERROR_USERID                       (QOSSP_ERR_BASE+200+99)

// RSVP Error
#define GQOS_RSVP                                      (QOSSP_ERR_BASE+300)

#define GQOS_NO_PATH                                   (QOSSP_ERR_BASE+300+1)
#define GQOS_NO_SENDER                                 (QOSSP_ERR_BASE+300+2)
#define GQOS_BAD_STYLE                                 (QOSSP_ERR_BASE+300+3)
#define GQOS_UNKNOWN_STYLE                             (QOSSP_ERR_BASE+300+4)
#define GQOS_BAD_DSTPORT                               (QOSSP_ERR_BASE+300+5) 
#define GQOS_BAD_SNDPORT                               (QOSSP_ERR_BASE+300+6)
#define GQOS_AMBIG_FILTER                              (QOSSP_ERR_BASE+300+7)
#define GQOS_PREEMPTED                                 (QOSSP_ERR_BASE+300+8)
#define GQOS_UNKN_OBJ_CLASS                            (QOSSP_ERR_BASE+300+9)
#define GQOS_UNKNOWN_CTYPE                             (QOSSP_ERR_BASE+300+10)
#define GQOS_INVALID                                   (QOSSP_ERR_BASE+300+11)

// API Error
#define GQOS_API                                       (QOSSP_ERR_BASE+400)

#define GQOS_API_BADSEND                               (QOSSP_ERR_BASE+400+1) /* Sender addr not my interface */
#define GQOS_API_BADRECV                               (QOSSP_ERR_BASE+400+2) /* Recv addr not my interface */
#define GQOS_API_BADSPORT                              (QOSSP_ERR_BASE+400+3) /* Sport !=0 but Dport == 0 */

// TC System Error
#define GQOS_KERNEL_TC_SYS                             (QOSSP_ERR_BASE+500)

#define GQOS_TC_GENERIC                                (QOSSP_ERR_BASE+500+1)
#define GQOS_TC_INVALID                                (QOSSP_ERR_BASE+500+2)
#define GQOS_NO_MEMORY                                 (QOSSP_ERR_BASE+500+3)
#define GQOS_BAD_ADDRESSTYPE                           (QOSSP_ERR_BASE+500+4) 
#define GQOS_BAD_DUPLICATE                             (QOSSP_ERR_BASE+500+5)
#define GQOS_CONFLICT                                  (QOSSP_ERR_BASE+500+6)
#define GQOS_NOTREADY                                  (QOSSP_ERR_BASE+500+7)
#define GQOS_WOULDBLOCK                                (QOSSP_ERR_BASE+500+8)
#define GQOS_INCOMPATIBLE                              (QOSSP_ERR_BASE+500+9)
#define GQOS_BAD_SDMODE                                (QOSSP_ERR_BASE+500+10)
#define GQOS_BAD_QOSPRIORITY                           (QOSSP_ERR_BASE+500+11)
#define GQOS_BAD_TRAFFICCLASS                          (QOSSP_ERR_BASE+500+12)
#define GQOS_NO_SYS_RESOURCES                          (QOSSP_ERR_BASE+500+13)

// RSVP System Error
#define GQOS_RSVP_SYS                                  (QOSSP_ERR_BASE+600)

#define GQOS_OTHER_SYS                                 (QOSSP_ERR_BASE+600+1)
#define GQOS_MEMORY_SYS                                (QOSSP_ERR_BASE+600+2)
#define GQOS_API_SYS                                   (QOSSP_ERR_BASE+600+3)
#define GQOS_SETQOS_NO_LOCAL_APPS                      (QOSSP_ERR_BASE+600+4)

// TC Error
#define GQOS_KERNEL_TC                                 (QOSSP_ERR_BASE+700)

#define GQOS_CONFLICT_SERV                             (QOSSP_ERR_BASE+700+1)
#define GQOS_NO_SERV                                   (QOSSP_ERR_BASE+700+2)
#define GQOS_BAD_FLOWSPEC                              (QOSSP_ERR_BASE+700+3)
#define GQOS_BAD_TSPEC                                 (QOSSP_ERR_BASE+700+4)
#define GQOS_BAD_ADSPEC                                (QOSSP_ERR_BASE+700+5)

// GQOS API ERRORS

// WSAIoctl Error

#define GQOS_IOCTL_SYSTEMFAILURE                       (QOSSP_ERR_BASE+800+1)
#define GQOS_IOCTL_NOBYTESRETURNED                     (QOSSP_ERR_BASE+800+2)
#define GQOS_IOCTL_INVALIDSOCKET                       (QOSSP_ERR_BASE+800+3)
#define GQOS_IOCTL_INV_FUNCPTR                         (QOSSP_ERR_BASE+800+4)
#define GQOS_IOCTL_INV_OVERLAPPED                      (QOSSP_ERR_BASE+800+5)

// SIO_SET_QOS error

#define GQOS_SETQOS_BADINBUFFER                        (QOSSP_ERR_BASE+810+1)
#define GQOS_SETQOS_BADFLOWSPEC                        (QOSSP_ERR_BASE+810+2)
#define GQOS_SETQOS_COLLISION                          (QOSSP_ERR_BASE+810+3)
#define GQOS_SETQOS_BADPROVSPECBUF                     (QOSSP_ERR_BASE+810+4)
#define GQOS_SETQOS_ILLEGALOP                          (QOSSP_ERR_BASE+810+5)
#define GQOS_SETQOS_INVALIDADDRESS                     (QOSSP_ERR_BASE+810+6)
#define GQOS_SETQOS_OUTOFMEMORY                        (QOSSP_ERR_BASE+810+7)
#define GQOS_SETQOS_EXCEPTION                          (QOSSP_ERR_BASE+810+8)
#define GQOS_SETQOS_BADADDRLEN                         (QOSSP_ERR_BASE+810+9)
#define GQOS_SETQOS_NOSOCKNAME                         (QOSSP_ERR_BASE+810+10)
#define GQOS_SETQOS_IPTOSFAIL                          (QOSSP_ERR_BASE+810+11)
#define GQOS_SETQOS_OPENSESSIONFAIL                    (QOSSP_ERR_BASE+810+12)
#define GQOS_SETQOS_SENDFAIL                           (QOSSP_ERR_BASE+810+13)
#define GQOS_SETQOS_RECVFAIL                           (QOSSP_ERR_BASE+810+14)
#define GQOS_SETQOS_BADPOLICYOBJECT                    (QOSSP_ERR_BASE+810+15)
#define GQOS_SETQOS_UNKNOWNFILTEROBJ                   (QOSSP_ERR_BASE+810+16)
#define GQOS_SETQOS_BADFILTERTYPE                      (QOSSP_ERR_BASE+810+17)
#define GQOS_SETQOS_BADFILTERCOUNT                     (QOSSP_ERR_BASE+810+18)
#define GQOS_SETQOS_BADOBJLENGTH                       (QOSSP_ERR_BASE+810+19)
#define GQOS_SETQOS_BADFLOWCOUNT                       (QOSSP_ERR_BASE+810+20)
#define GQOS_SETQOS_UNKNOWNPSOBJ                       (QOSSP_ERR_BASE+810+21)
#define GQOS_SETQOS_BADPOLICYOBJ                       (QOSSP_ERR_BASE+810+22)
#define GQOS_SETQOS_BADFLOWDESC                        (QOSSP_ERR_BASE+810+23)
#define GQOS_SETQOS_BADPROVSPECOBJ                     (QOSSP_ERR_BASE+810+24)
#define GQOS_SETQOS_NOLOOPBACK                         (QOSSP_ERR_BASE+810+25)
#define GQOS_SETQOS_MODENOTSUPPORTED                   (QOSSP_ERR_BASE+810+26)
#define GQOS_SETQOS_MISSINGFLOWDESC                    (QOSSP_ERR_BASE+810+27)

// SIO_GET_QOS error

#define GQOS_GETQOS_BADOUTBUFFER                       (QOSSP_ERR_BASE+840+1)
#define GQOS_GETQOS_SYSTEMFAILURE                      (QOSSP_ERR_BASE+840+2)
#define GQOS_GETQOS_EXCEPTION                          (QOSSP_ERR_BASE+840+3)
#define GQOS_GETQOS_INTERNALFAILURE                    (QOSSP_ERR_BASE+840+4)

// SIO_CHK_QOS error

#define GQOS_CHKQOS_BADINBUFFER                        (QOSSP_ERR_BASE+850+1)
#define GQOS_CHKQOS_BADOUTBUFFER                       (QOSSP_ERR_BASE+850+2)
#define GQOS_CHKQOS_SYSTEMFAILURE                      (QOSSP_ERR_BASE+850+3)
#define GQOS_CHKQOS_INTERNALFAILURE                    (QOSSP_ERR_BASE+850+4)
#define GQOS_CHKQOS_BADPARAMETER                       (QOSSP_ERR_BASE+850+5)
#define GQOS_CHKQOS_EXCEPTION                          (QOSSP_ERR_BASE+850+6)

#endif  /* __QOSSP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\query.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for query.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __query_h__
#define __query_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISearchQueryHits_FWD_DEFINED__
#define __ISearchQueryHits_FWD_DEFINED__
typedef interface ISearchQueryHits ISearchQueryHits;
#endif 	/* __ISearchQueryHits_FWD_DEFINED__ */


#ifndef __IRowsetQueryStatus_FWD_DEFINED__
#define __IRowsetQueryStatus_FWD_DEFINED__
typedef interface IRowsetQueryStatus IRowsetQueryStatus;
#endif 	/* __IRowsetQueryStatus_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "filter.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IQueryStructures_INTERFACE_DEFINED__
#define __IQueryStructures_INTERFACE_DEFINED__

/* interface IQueryStructures */
/* [auto_handle][unique][uuid] */ 

#define DBQUERYGUID  { 0x49691C90, \
                       0x7E17, 0x101A, \
                       0xA9, 0x1C, 0x08, 0x00, 0x2B, \
                       0x2E, 0xCD, 0xA9 } 
#define	DISPID_QUERY_RANKVECTOR	( 2 )

#define	DISPID_QUERY_RANK	( 3 )

#define	DISPID_QUERY_HITCOUNT	( 4 )

#define	DISPID_QUERY_WORKID	( 5 )

#define	DISPID_QUERY_ALL	( 6 )

#define	DISPID_QUERY_UNFILTERED	( 7 )

#define	DISPID_QUERY_REVNAME	( 8 )

#define	DISPID_QUERY_VIRTUALPATH	( 9 )

#define	DISPID_QUERY_LASTSEENTIME	( 10 )

#define	CQUERYDISPIDS	( 11 )

#define PSGUID_QUERY_METADATA { 0x624C9360, \
                                0x93D0, 0x11CF, \
                                0xA7, 0x87, 0x00, 0x00, 0x4C, \
                                0x75, 0x27, 0x52 } 
#define	DISPID_QUERY_METADATA_VROOTUSED	( 2 )

#define	DISPID_QUERY_METADATA_VROOTAUTOMATIC	( 3 )

#define	DISPID_QUERY_METADATA_VROOTMANUAL	( 4 )

#define	DISPID_QUERY_METADATA_PROPGUID	( 5 )

#define	DISPID_QUERY_METADATA_PROPDISPID	( 6 )

#define	DISPID_QUERY_METADATA_PROPNAME	( 7 )

#define	DISPID_QUERY_METADATA_STORELEVEL	( 8 )

#define	DISPID_QUERY_METADATA_PROPMODIFIABLE	( 9 )

#define	CQUERYMETADISPIDS	( 10 )

#define DBBMKGUID { 0xC8B52232L, \
                 0x5CF3, 0x11CE, \
                 {0xAD, 0xE5, 0x00, 0xAA, 0x00, \
                  0x44, 0x77, 0x3D } }
#define	PROPID_DBBMK_BOOKMARK	( 2 )

#define	PROPID_DBBMK_CHAPTER	( 3 )

#define	CDBBMKDISPIDS	( 8 )

#define DBSELFGUID {0xc8b52231,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
#define	PROPID_DBSELF_SELF	( 2 )

#define	CDBSELFDISPIDS	( 8 )

#define	CDBCOLDISPIDS	( 28 )

#define	CQUERYPROPERTY	( 64 )

#define PSGUID_CHARACTERIZATION { 0x560c36c0, \
                                  0x503a, 0x11cf, \
                                  0xba, 0xa1, 0x00, 0x00, \
                                  0x4c, 0x75, 0x2a, 0x9a } 
#define	QUERY_VALIDBITS	( 3 )

#define	RTNone	( 0 )

#define	RTAnd	( 1 )

#define	RTOr	( 2 )

#define	RTNot	( 3 )

#define	RTContent	( 4 )

#define	RTProperty	( 5 )

#define	RTProximity	( 6 )

#define	RTVector	( 7 )

#define	RTNatLanguage	( 8 )

typedef struct tagRESTRICTION RESTRICTION;

typedef struct tagNOTRESTRICTION
    {
    RESTRICTION *pRes;
    } 	NOTRESTRICTION;

typedef struct tagNODERESTRICTION
    {
    ULONG cRes;
    /* [size_is] */ RESTRICTION **paRes;
    ULONG reserved;
    } 	NODERESTRICTION;

#define	VECTOR_RANK_MIN	( 0 )

#define	VECTOR_RANK_MAX	( 1 )

#define	VECTOR_RANK_INNER	( 2 )

#define	VECTOR_RANK_DICE	( 3 )

#define	VECTOR_RANK_JACCARD	( 4 )

typedef struct tagVECTORRESTRICTION
    {
    NODERESTRICTION Node;
    ULONG RankMethod;
    } 	VECTORRESTRICTION;

#define	GENERATE_METHOD_EXACT	( 0 )

#define	GENERATE_METHOD_PREFIXMATCH	( 1 )

#define	GENERATE_METHOD_STEMMED	( 2 )

typedef struct tagCONTENTRESTRICTION
    {
    FULLPROPSPEC prop;
    /* [string] */ WCHAR *pwcsPhrase;
    LCID lcid;
    ULONG ulGenerateMethod;
    } 	CONTENTRESTRICTION;

typedef struct tagNATLANGUAGERESTRICTION
    {
    FULLPROPSPEC prop;
    /* [string] */ WCHAR *pwcsPhrase;
    LCID lcid;
    } 	NATLANGUAGERESTRICTION;

#define	PRLT	( 0 )

#define	PRLE	( 1 )

#define	PRGT	( 2 )

#define	PRGE	( 3 )

#define	PREQ	( 4 )

#define	PRNE	( 5 )

#define	PRRE	( 6 )

#define	PRAllBits	( 7 )

#define	PRSomeBits	( 8 )

#define	PRAll	( 0x100 )

#define	PRAny	( 0x200 )

typedef struct tagPROPERTYRESTRICTION
    {
    ULONG rel;
    FULLPROPSPEC prop;
    PROPVARIANT prval;
    } 	PROPERTYRESTRICTION;


struct tagRESTRICTION
    {
    ULONG rt;
    ULONG weight;
    /* [switch_is][switch_type] */ union _URes
        {
        /* [case()] */ NODERESTRICTION ar;
        /* [case()] */ NODERESTRICTION or;
        /* [case()] */ NODERESTRICTION pxr;
        /* [case()] */ VECTORRESTRICTION vr;
        /* [case()] */ NOTRESTRICTION nr;
        /* [case()] */ CONTENTRESTRICTION cr;
        /* [case()] */ NATLANGUAGERESTRICTION nlr;
        /* [case()] */ PROPERTYRESTRICTION pr;
        /* [default] */  /* Empty union arm */ 
        } 	res;
    } ;
typedef struct tagCOLUMNSET
    {
    ULONG cCol;
    /* [size_is] */ FULLPROPSPEC *aCol;
    } 	COLUMNSET;

#define	QUERY_SORTASCEND	( 0 )

#define	QUERY_SORTDESCEND	( 1 )

#define	QUERY_SORTXASCEND	( 2 )

#define	QUERY_SORTXDESCEND	( 3 )

#define	QUERY_SORTDEFAULT	( 4 )

typedef struct tagSORTKEY
    {
    FULLPROPSPEC propColumn;
    ULONG dwOrder;
    LCID locale;
    } 	SORTKEY;

typedef struct tagSORTSET
    {
    ULONG cCol;
    /* [size_is] */ SORTKEY *aCol;
    } 	SORTSET;

#define	CATEGORIZE_UNIQUE	( 0 )

#define	CATEGORIZE_CLUSTER	( 1 )

#define	CATEGORIZE_BUCKETS	( 2 )

#define	BUCKET_LINEAR	( 0 )

#define	BUCKET_EXPONENTIAL	( 1 )

typedef struct tagBUCKETCATEGORIZE
    {
    ULONG cBuckets;
    ULONG Distribution;
    } 	BUCKETCATEGORIZE;

#define	CATEGORIZE_RANGE	( 3 )

typedef struct tagRANGECATEGORIZE
    {
    ULONG cRange;
    /* [size_is] */ PROPVARIANT *aRangeBegin;
    } 	RANGECATEGORIZE;

typedef struct tagCATEGORIZATION
    {
    ULONG ulCatType;
    /* [switch_is][switch_type] */ union 
        {
        /* [case()] */ ULONG cClusters;
        /* [case()] */ BUCKETCATEGORIZE bucket;
        /* [case()] */ RANGECATEGORIZE range;
        /* [case()] */  /* Empty union arm */ 
        } 	;
    COLUMNSET csColumns;
    } 	CATEGORIZATION;

typedef struct tagCATEGORIZATIONSET
    {
    ULONG cCat;
    /* [size_is] */ CATEGORIZATION *aCat;
    } 	CATEGORIZATIONSET;

typedef unsigned long OCCURRENCE;

#define	OCC_INVALID	( 0xffffffff )

#define	MAX_QUERY_RANK	( 1000 )



extern RPC_IF_HANDLE IQueryStructures_v0_0_c_ifspec;
extern RPC_IF_HANDLE IQueryStructures_v0_0_s_ifspec;
#endif /* __IQueryStructures_INTERFACE_DEFINED__ */

#ifndef __ISearchQueryHits_INTERFACE_DEFINED__
#define __ISearchQueryHits_INTERFACE_DEFINED__

/* interface ISearchQueryHits */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_ISearchQueryHits;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ed8ce7e0-106c-11ce-84e2-00aa004b9986")
    ISearchQueryHits : public IUnknown
    {
    public:
        virtual SCODE STDMETHODCALLTYPE Init( 
            /* [in] */ IFilter *pflt,
            /* [in] */ ULONG ulFlags) = 0;
        
        virtual SCODE STDMETHODCALLTYPE NextHitMoniker( 
            /* [out][in] */ ULONG *pcMnk,
            /* [size_is][out] */ IMoniker ***papMnk) = 0;
        
        virtual SCODE STDMETHODCALLTYPE NextHitOffset( 
            /* [out][in] */ ULONG *pcRegion,
            /* [size_is][out] */ FILTERREGION **paRegion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISearchQueryHitsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISearchQueryHits * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISearchQueryHits * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISearchQueryHits * This);
        
        SCODE ( STDMETHODCALLTYPE *Init )( 
            ISearchQueryHits * This,
            /* [in] */ IFilter *pflt,
            /* [in] */ ULONG ulFlags);
        
        SCODE ( STDMETHODCALLTYPE *NextHitMoniker )( 
            ISearchQueryHits * This,
            /* [out][in] */ ULONG *pcMnk,
            /* [size_is][out] */ IMoniker ***papMnk);
        
        SCODE ( STDMETHODCALLTYPE *NextHitOffset )( 
            ISearchQueryHits * This,
            /* [out][in] */ ULONG *pcRegion,
            /* [size_is][out] */ FILTERREGION **paRegion);
        
        END_INTERFACE
    } ISearchQueryHitsVtbl;

    interface ISearchQueryHits
    {
        CONST_VTBL struct ISearchQueryHitsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISearchQueryHits_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISearchQueryHits_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISearchQueryHits_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISearchQueryHits_Init(This,pflt,ulFlags)	\
    (This)->lpVtbl -> Init(This,pflt,ulFlags)

#define ISearchQueryHits_NextHitMoniker(This,pcMnk,papMnk)	\
    (This)->lpVtbl -> NextHitMoniker(This,pcMnk,papMnk)

#define ISearchQueryHits_NextHitOffset(This,pcRegion,paRegion)	\
    (This)->lpVtbl -> NextHitOffset(This,pcRegion,paRegion)

#endif /* COBJMACROS */


#endif 	/* C style interface */



SCODE STDMETHODCALLTYPE ISearchQueryHits_Init_Proxy( 
    ISearchQueryHits * This,
    /* [in] */ IFilter *pflt,
    /* [in] */ ULONG ulFlags);


void __RPC_STUB ISearchQueryHits_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


SCODE STDMETHODCALLTYPE ISearchQueryHits_NextHitMoniker_Proxy( 
    ISearchQueryHits * This,
    /* [out][in] */ ULONG *pcMnk,
    /* [size_is][out] */ IMoniker ***papMnk);


void __RPC_STUB ISearchQueryHits_NextHitMoniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


SCODE STDMETHODCALLTYPE ISearchQueryHits_NextHitOffset_Proxy( 
    ISearchQueryHits * This,
    /* [out][in] */ ULONG *pcRegion,
    /* [size_is][out] */ FILTERREGION **paRegion);


void __RPC_STUB ISearchQueryHits_NextHitOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISearchQueryHits_INTERFACE_DEFINED__ */


#ifndef __IRowsetQueryStatus_INTERFACE_DEFINED__
#define __IRowsetQueryStatus_INTERFACE_DEFINED__

/* interface IRowsetQueryStatus */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IRowsetQueryStatus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a7ac77ed-f8d7-11ce-a798-0020f8008024")
    IRowsetQueryStatus : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ DWORD *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatusEx( 
            /* [out] */ DWORD *pdwStatus,
            /* [out] */ DWORD *pcFilteredDocuments,
            /* [out] */ DWORD *pcDocumentsToFilter,
            /* [out] */ ULONG_PTR *pdwRatioFinishedDenominator,
            /* [out] */ ULONG_PTR *pdwRatioFinishedNumerator,
            /* [in] */ ULONG_PTR cbBmk,
            /* [size_is][in] */ const BYTE *pBmk,
            /* [out] */ ULONG_PTR *piRowBmk,
            /* [out] */ ULONG_PTR *pcRowsTotal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowsetQueryStatusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRowsetQueryStatus * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRowsetQueryStatus * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRowsetQueryStatus * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IRowsetQueryStatus * This,
            /* [out] */ DWORD *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatusEx )( 
            IRowsetQueryStatus * This,
            /* [out] */ DWORD *pdwStatus,
            /* [out] */ DWORD *pcFilteredDocuments,
            /* [out] */ DWORD *pcDocumentsToFilter,
            /* [out] */ ULONG_PTR *pdwRatioFinishedDenominator,
            /* [out] */ ULONG_PTR *pdwRatioFinishedNumerator,
            /* [in] */ ULONG_PTR cbBmk,
            /* [size_is][in] */ const BYTE *pBmk,
            /* [out] */ ULONG_PTR *piRowBmk,
            /* [out] */ ULONG_PTR *pcRowsTotal);
        
        END_INTERFACE
    } IRowsetQueryStatusVtbl;

    interface IRowsetQueryStatus
    {
        CONST_VTBL struct IRowsetQueryStatusVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowsetQueryStatus_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowsetQueryStatus_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowsetQueryStatus_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowsetQueryStatus_GetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus)

#define IRowsetQueryStatus_GetStatusEx(This,pdwStatus,pcFilteredDocuments,pcDocumentsToFilter,pdwRatioFinishedDenominator,pdwRatioFinishedNumerator,cbBmk,pBmk,piRowBmk,pcRowsTotal)	\
    (This)->lpVtbl -> GetStatusEx(This,pdwStatus,pcFilteredDocuments,pcDocumentsToFilter,pdwRatioFinishedDenominator,pdwRatioFinishedNumerator,cbBmk,pBmk,piRowBmk,pcRowsTotal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowsetQueryStatus_GetStatus_Proxy( 
    IRowsetQueryStatus * This,
    /* [out] */ DWORD *pdwStatus);


void __RPC_STUB IRowsetQueryStatus_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowsetQueryStatus_GetStatusEx_Proxy( 
    IRowsetQueryStatus * This,
    /* [out] */ DWORD *pdwStatus,
    /* [out] */ DWORD *pcFilteredDocuments,
    /* [out] */ DWORD *pcDocumentsToFilter,
    /* [out] */ ULONG_PTR *pdwRatioFinishedDenominator,
    /* [out] */ ULONG_PTR *pdwRatioFinishedNumerator,
    /* [in] */ ULONG_PTR cbBmk,
    /* [size_is][in] */ const BYTE *pBmk,
    /* [out] */ ULONG_PTR *piRowBmk,
    /* [out] */ ULONG_PTR *pcRowsTotal);


void __RPC_STUB IRowsetQueryStatus_GetStatusEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowsetQueryStatus_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_query_0128 */
/* [local] */ 

#include <indexsrv.h>


extern RPC_IF_HANDLE __MIDL_itf_query_0128_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_query_0128_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\raseapif.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    raseapif.h

Abstract:

    Defines interface between a third party authentication module
    and the Remote Access Service PPP engine.

--*/

#ifndef _RASEAPIF_
#define _RASEAPIF_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if(WINVER >= 0x0500)

//
// Defines used for installtion of EAP DLL
//
// Custom EAP DLL (ex. Name=Sample.dll, Type=(decimal 40) regsitry installation)
//
// HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Rasman\PPP\EAP\40)
//      Path                (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      ConfigUIPath        (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      InteractiveUIPath   (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      IdentityPath        (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      FriendlyName        (REG_SZ) Sample EAP Protocol
//      RequireConfigUI     (REG_DWORD)     1
//      ConfigCLSID         (REG_SZ)        {0000031A-0000-0000-C000-000000000046}
//      StandaloneSupported (REG_DWORD)     1
//

#define RAS_EAP_REGISTRY_LOCATION   \
    TEXT("System\\CurrentControlSet\\Services\\Rasman\\PPP\\EAP")

#define RAS_EAP_VALUENAME_PATH                  TEXT("Path")
#define RAS_EAP_VALUENAME_CONFIGUI              TEXT("ConfigUIPath")
#define RAS_EAP_VALUENAME_INTERACTIVEUI         TEXT("InteractiveUIPath")
#define RAS_EAP_VALUENAME_IDENTITY              TEXT("IdentityPath")
#define RAS_EAP_VALUENAME_FRIENDLY_NAME         TEXT("FriendlyName")
#define RAS_EAP_VALUENAME_DEFAULT_DATA          TEXT("ConfigData")
#define RAS_EAP_VALUENAME_REQUIRE_CONFIGUI      TEXT("RequireConfigUI")
#define RAS_EAP_VALUENAME_ENCRYPTION            TEXT("MPPEEncryptionSupported")
#define RAS_EAP_VALUENAME_INVOKE_NAMEDLG        TEXT("InvokeUsernameDialog")
#define RAS_EAP_VALUENAME_INVOKE_PWDDLG         TEXT("InvokePasswordDialog")
#define RAS_EAP_VALUENAME_CONFIG_CLSID          TEXT("ConfigCLSID")
#define RAS_EAP_VALUENAME_STANDALONE_SUPPORTED  TEXT("StandaloneSupported")
#define RAS_EAP_VALUENAME_ROLES_SUPPORTED       TEXT("RolesSupported")
#define RAS_EAP_VALUENAME_PER_POLICY_CONFIG     TEXT("PerPolicyConfig")


// Flags for RolesSupported.
#define RAS_EAP_ROLE_AUTHENTICATOR   0x00000001
#define RAS_EAP_ROLE_AUTHENTICATEE   0x00000002

//
// Following flags describe the hosting of EAP
// methods in PEAP or in EAP.  If this role is
// missing the default behavior is to show the
// EAP method in PEAP and in EAP.
//
#define RAS_EAP_ROLE_EXCLUDE_IN_EAP  0x00000004
#define RAS_EAP_ROLE_EXCLUDE_IN_PEAP 0x00000008
#define RAS_EAP_ROLE_EXCLUDE_IN_VPN  0x00000010

typedef enum _RAS_AUTH_ATTRIBUTE_TYPE_
{
    raatMinimum = 0,                // Undefined
    raatUserName,                   // Value field is a Pointer
    raatUserPassword,               // Value field is a Pointer
    raatMD5CHAPPassword,            // Value field is a Pointer
    raatNASIPAddress,               // Value field is a 32 bit integral value
    raatNASPort,                    // Value field is a 32 bit integral value
    raatServiceType,                // Value field is a 32 bit integral value
    raatFramedProtocol,             // Value field is a 32 bit integral value
    raatFramedIPAddress,            // Value field is a 32 bit integral value
    raatFramedIPNetmask,            // Value field is a 32 bit integral value
    raatFramedRouting = 10,         // Value field is a 32 bit integral value
    raatFilterId,                   // Value field is a Pointer
    raatFramedMTU,                  // Value field is a 32 bit integral value
    raatFramedCompression,          // Value field is a 32 bit integral value
    raatLoginIPHost,                // Value field is a 32 bit integral value
    raatLoginService,               // Value field is a 32 bit integral value
    raatLoginTCPPort,               // Value field is a 32 bit integral value
    raatUnassigned17,               // Undefined
    raatReplyMessage,               // Value field is a Pointer
    raatCallbackNumber,             // Value field is a Pointer
    raatCallbackId =20,             // Value field is a Pointer
    raatUnassigned21,               // Undefined
    raatFramedRoute,                // Value field is a Pointer
    raatFramedIPXNetwork,           // Value field is a 32 bit integral value
    raatState,                      // Value field is a Pointer
    raatClass,                      // Value field is a Pointer
    raatVendorSpecific,             // Value field is a Pointer
    raatSessionTimeout,             // Value field is a 32 bit integral value
    raatIdleTimeout,                // Value field is a 32 bit integral value
    raatTerminationAction,          // Value field is a 32 bit integral value
    raatCalledStationId = 30,       // Value field is a Pointer
    raatCallingStationId,           // Value field is a Pointer
    raatNASIdentifier,              // Value field is a Pointer
    raatProxyState,                 // Value field is a Pointer
    raatLoginLATService,            // Value field is a Pointer
    raatLoginLATNode,               // Value field is a Pointer
    raatLoginLATGroup,              // Value field is a Pointer
    raatFramedAppleTalkLink,        // Value field is a 32 bit integral value
    raatFramedAppleTalkNetwork,     // Value field is a 32 bit integral value
    raatFramedAppleTalkZone,        // Value field is a Pointer
    raatAcctStatusType = 40,        // Value field is a 32 bit integral value
    raatAcctDelayTime,              // Value field is a 32 bit integral value
    raatAcctInputOctets,            // Value field is a 32 bit integral value
    raatAcctOutputOctets,           // Value field is a 32 bit integral value
    raatAcctSessionId,              // Value field is a Pointer
    raatAcctAuthentic,              // Value field is a 32 bit integral value
    raatAcctSessionTime,            // Value field is a 32 bit integral value
    raatAcctInputPackets,           // Value field is a 32 bit integral value
    raatAcctOutputPackets,          // Value field is a 32 bit integral value
    raatAcctTerminateCause,         // Value field is a 32 bit integral value
    raatAcctMultiSessionId = 50,    // Value field is a Pointer
    raatAcctLinkCount,              // Value field is a 32 bit integral value
    raatAcctEventTimeStamp = 55,    // Value field is a 32 bit integral value
    raatMD5CHAPChallenge = 60,      // Value field is a Pointer
    raatNASPortType,                // Value field is a 32 bit integral value
    raatPortLimit,                  // Value field is a 32 bit integral value
    raatLoginLATPort,               // Value field is a Pointer
    raatTunnelType,                 // Value field is a 32 bit integral value
    raatTunnelMediumType,           // Value field is a 32 bit integral value
    raatTunnelClientEndpoint,       // Value field is a Pointer
    raatTunnelServerEndpoint,       // Value field is a Pointer
    raatARAPPassword = 70,          // Value field is a Pointer
    raatARAPFeatures,               // Value field is a Pointer
    raatARAPZoneAccess,             // Value field is a 32 bit integral value
    raatARAPSecurity,               // Value field is a 32 bit integral value
    raatARAPSecurityData,           // Value field is a Pointer
    raatPasswordRetry,              // Value field is a 32 bit integral value
    raatPrompt,                     // Value field is a 32 bit integral value
    raatConnectInfo,                // Value field is a Pointer
    raatConfigurationToken,         // Value field is a Pointer
    raatEAPMessage,                 // Value field is a Pointer
    raatSignature = 80,             // Value field is a Pointer
    raatARAPChallengeResponse = 84, // Value field is a Pointer
    raatAcctInterimInterval = 85,   // Value field is a 32 bit integral value
    raatARAPGuestLogon = 8096,      // Value field is a 32 bit integral value
    raatCertificateOID,             // Value field is a Pointer
    raatEAPConfiguration,           // Value field is a Pointer
    raatPEAPEmbeddedEAPTypeId,      // Value field is a 32 bit integral value
    raatPEAPFastRoamedSession,      // Value field is a 32 bit integral value
    raatReserved = 0xFFFFFFFF       // Undefined

}RAS_AUTH_ATTRIBUTE_TYPE;


//
// VSA attribute ids for ARAP
//
#define  raatARAPChallenge              33
#define  raatARAPOldPassword            19
#define  raatARAPNewPassword            20
#define  raatARAPPasswordChangeReason   21

//
// Value is set to the 32 bit integral value or a pointer to data.
// 32 bit integral values should be in host format, not network format.
// Length for a 32 bit integral value can be 1, 2 or 4. The array of
// attributes must be terminated with an attribute of type raatMinimum.
//

typedef struct _RAS_AUTH_ATTRIBUTE
{
    RAS_AUTH_ATTRIBUTE_TYPE raaType;
    DWORD                   dwLength;
    PVOID                   Value;

}RAS_AUTH_ATTRIBUTE, *PRAS_AUTH_ATTRIBUTE;

//
// EAP packet codes from EAP spec.
//

#define EAPCODE_Request         1
#define EAPCODE_Response        2
#define EAPCODE_Success         3
#define EAPCODE_Failure         4

#define MAXEAPCODE              4

//
// Values of the fFlags field in PPP_EAP_INPUT
// These have the same values as the RASEAPF_ flags in ras.h
//

#define RAS_EAP_FLAG_ROUTER                 0x00000001  // This is a router
#define RAS_EAP_FLAG_NON_INTERACTIVE        0x00000002  // No UI should be displayed
#define RAS_EAP_FLAG_LOGON                  0x00000004  // The user data was
                                                        // obtained from Winlogon
#define RAS_EAP_FLAG_PREVIEW                0x00000008  // User has checked
                                                        // "Prompt for information
                                                        // before dialing"
#define RAS_EAP_FLAG_FIRST_LINK             0x00000010  // This is the first link
#define RAS_EAP_FLAG_MACHINE_AUTH           0x00000020  // Use the default machine cert
                                                        // or user cert based on the
                                                        // application logon context
#define RAS_EAP_FLAG_GUEST_ACCESS           0x00000040  // Request to provide guest
                                                        // access.
#define RAS_EAP_FLAG_8021X_AUTH             0x00000080  // Anything specific to 8021x
                                                        // to be done in TLS
#define RAS_EAP_FLAG_HOSTED_IN_PEAP         0x00000100  // This EAP Method is hosted
                                                        // in PEAP
#define RAS_EAP_FLAG_RESUME_FROM_HIBERNATE  0x00000200  // Indicates this is the
                                                        // first call after m/c
                                                        // resumed from hibernation.


typedef struct _PPP_EAP_PACKET
{
    BYTE    Code;       // 1-Request, 2-Response, 3-Success, 4-Failure

    BYTE    Id;         // Id of this packet

    BYTE    Length[2];  // Length of this packet

    BYTE    Data[1];    // Data - First byte is Type for Request/Response

}PPP_EAP_PACKET, *PPPP_EAP_PACKET;

#define PPP_EAP_PACKET_HDR_LEN  ( sizeof( PPP_EAP_PACKET ) - 1 )

//
// Interface structure between the engine and APs. This is passed to the
// AP's via the RasCpBegin call.
//

typedef struct _PPP_EAP_INPUT
{
    //
    // Size of this structure
    //

    DWORD       dwSizeInBytes;

    //
    // The following five fields are valid only in RasEapBegin call
    //

    DWORD       fFlags;         // See RAS_EAP_FLAG_*

    BOOL        fAuthenticator; // Act as authenticator or authenticatee

    WCHAR *     pwszIdentity;   // Users's identity

    WCHAR *     pwszPassword;   // Client's account password. Only valid when
                                // fAuthenticator is FALSE.

    BYTE        bInitialId;     // Initial packet identifier. Must be used for
                                // the first EAP packet sent by the DLL and
                                // incremented by one for each subsequent
                                // request packet.

    //
    // During the RasEapBegin call on the authenticator side, pUserAttributes
    // contains the set of attributes for the currently dialed in user, e.g.,
    // the port used, NAS IP Address, etc.
    //
    // When the fAuthenticationComplete flag is TRUE, pUserAttributes contains
    // attributes (if any) returned by the authentication provider.
    //
    // This memory is not owned by the EAP DLL and should be treated as
    // read-only.
    //

    RAS_AUTH_ATTRIBUTE * pUserAttributes;

    //
    // The next two fields are used only if the EAP DLL is using the
    // currently configured authentication provider ex: RADIUS or Windows NT
    // domain authentication, and the fAuthenticator field above is set to
    // TRUE.
    //

    //
    // Indicates that the authenticator has completed authentication.
    // Ignore this field if an authentication provider is not being used.
    //

    BOOL                fAuthenticationComplete;

    //
    // Result of the authentication process by the authentication provider.
    // NO_ERROR indicates success, otherwise it is a value from winerror.h,
    // raserror.h or mprerror.h indicating failure reason.
    //

    DWORD               dwAuthResultCode;

    //
    // Valid only on the authenticatee side. This may be used on the
    // authenticatee side to impersonate the user being authenticated.
    //

    OPTIONAL HANDLE     hTokenImpersonateUser;

    //
    // This variable should be examined only by the authenticatee side.
    // The EAP specification states that the success packet may be lost and
    // since it is a non-acknowledged packet, reception of an NCP packet should
    // be interpreted as a success packet. This varable is set to TRUE in this
    // case only on the authenticatee side
    //

    BOOL                fSuccessPacketReceived;

    //
    // Will be set to TRUE only when the user dismissed the interactive
    // UI that was invoked by the EAP dll
    //

    BOOL                fDataReceivedFromInteractiveUI;

    //
    // Data received from the Interactive UI. Will be set to
    // non-NULL when fDataReceivedFromInteractiveUI is set to TRUE and
    // RasEapInvokeInteractiveUI returned non-NULL data. This buffer will be
    // freed by the PPP engine on return from the RasEapMakeMessage call. A
    // copy of this data should be made in the EAP Dll's memory space.
    //

    OPTIONAL PBYTE      pDataFromInteractiveUI;

    //
    // Size in bytes of data pointed to by pInteractiveConnectionData. This may
    // be 0 if there was no data passed back by RasEapInvokeInteractiveUI.
    //

    DWORD               dwSizeOfDataFromInteractiveUI;

    //
    // Connection data received from the Config UI. Will be set to non-NULL
    // when the RasEapBegin call is made and the RasEapInvokeConfigUI
    // returned non-NULL data. This buffer will be freed by the PPP engine
    // on return from the RasEapBegin call. A copy of this data should
    // be made in the EAP Dll's memory space.
    //

    OPTIONAL PBYTE      pConnectionData;

    //
    // Size in bytes of data pointed to by pConnectionData. This may be
    // 0 if there was no data passed back by the RasEapInvokeConfigUI call.
    //

    DWORD               dwSizeOfConnectionData;

    //
    // User data received from the Identity UI or Interactive UI. Will be set
    // to non-NULL when the RasEapBegin call is made if such data exists.
    // This buffer will be freed by the PPP engine on return from the
    // RasEapBegin call. A copy of this data should be made in the EAP Dll's
    // memory space.
    //

    OPTIONAL PBYTE      pUserData;

    //
    // Size in bytes of data pointed to by pUserData. This may be 0 if there
    // is no data.
    //

    DWORD               dwSizeOfUserData;

    //
    // Reserved.
    //

    HANDLE              hReserved;

}PPP_EAP_INPUT, *PPPP_EAP_INPUT;

typedef enum _PPP_EAP_ACTION
{
    //
    // These actions are provided by the EAP DLL as output from the
    // RasEapMakeMessage API.  They tell the PPP engine what action (if any) to
    // take on the EAP DLL's behalf, and eventually inform the engine that the
    // EAP DLL has finished authentication.
    //

    EAPACTION_NoAction,     // Be passive, i.e. listen without timeout (default)
    EAPACTION_Authenticate, // Invoke the back-end authenticator.
    EAPACTION_Done,         // End auth session, dwAuthResultCode is set
    EAPACTION_SendAndDone,  // As above but send message without timeout first
    EAPACTION_Send,         // Send message, don't timeout waiting for reply
    EAPACTION_SendWithTimeout, // Send message, timeout if reply not received
    EAPACTION_SendWithTimeoutInteractive  // As above, but don't increment
                                          // retry count

}PPP_EAP_ACTION;

typedef struct _PPP_EAP_OUTPUT
{
    //
    // Size of this structure
    //

    DWORD                   dwSizeInBytes;

    //
    // Action that the PPP engine should take
    //

    PPP_EAP_ACTION          Action;

    //
    // dwAuthResultCode is valid only with an Action code of Done or
    // SendAndDone. Zero value indicates succesful authentication.
    // Non-zero indicates unsuccessful authentication with the value
    // indicating the reason for authentication failure.
    // Non-zero return codes should be only from winerror.h, raserror.h and
    // mprerror.h
    //

    DWORD                   dwAuthResultCode;

    //
    // When Action is EAPACTION_Authenticate, pUserAttributes may contain
    // additional attributes necessary to authenticate the user, e.g.,
    // User-Password. If no credentials are presented, the back-end
    // authenticator will assume the user is authentic and only retrieve
    // authorizations.
    //
    // When Action is EAPACTION_Done, EAPACTION_SendAndDone, or EAPACTION_Send,
    // pUserAttributes may contain additional attributes for the user. These
    // attributes will overwrite any attributes of the same type returned by
    // the back-end authenticator.
    //
    // It is up to the EAP DLL to free this memory in RasEapEnd call.
    //

    OPTIONAL RAS_AUTH_ATTRIBUTE * pUserAttributes;
    //
    // Flag set to true will cause the RasEapInvokeInteractiveUI call to be
    // made.
    //

    BOOL                    fInvokeInteractiveUI;

    //
    // Pointer to context data, if any, to be sent to the UI. The EAP dll
    // is responsible for freeing this buffer in the RasEapEnd call or when
    // a response from the user for this invocation is obtained.
    //

    OPTIONAL PBYTE          pUIContextData;

    //
    // Size in bytes of the data pointed to by pUIContextData. Ignored if
    // pUIContextData is NULL
    //

    DWORD                   dwSizeOfUIContextData;

    //
    // When set to TRUE, indicates that the information pointed to by
    // pConnectionData should be saved in the phonebook. Only valid on
    // the authenticatee side.
    //

    BOOL                    fSaveConnectionData;

    //
    // If fSaveConnectionData above is true, the data pointed to by
    // pConnectionData will be saved in the phonebook. This data
    // must be freed by the DLL when the RasEapEnd call is made.
    //

    OPTIONAL PBYTE          pConnectionData;

    //
    // Size, in bytes, of the data pointed to by pConnectionData
    //

    DWORD                   dwSizeOfConnectionData;

    //
    // When set to TRUE, indicates that the information pointed to by
    // pUserData should be saved in the registry for this user. Only valid
    // on the authenticatee side.
    //

    BOOL                    fSaveUserData;

    //
    // If fSaveUserData above is true, the data pointed to by pUserData will be
    // saved in the registry for this user. This data must be freed by the DLL
    // when the RasEapEnd call is made.
    //

    OPTIONAL PBYTE          pUserData;

    //
    // Size, in bytes, of the data pointed to by pUserData
    //

    DWORD                   dwSizeOfUserData;

}PPP_EAP_OUTPUT, *PPPP_EAP_OUTPUT;

typedef struct _PPP_EAP_INFO
{
    //
    // Size of this structure
    //

    DWORD   dwSizeInBytes;

    DWORD   dwEapTypeId;

    //
    // Called to initialize/uninitialize this module. This will be called before
    // any other call is made. fInitialize will be TRUE iff the module has to be
    // initialized. Must return errorcodes only from winerror.h, raserror.h or
    // mprerror.h
    //

    DWORD   (APIENTRY *RasEapInitialize)(   IN  BOOL        fInitialize );

    //
    // Called to get a context buffer for this EAP session and pass
    // initialization information. This will be called before any other
    // call is made, except RasEapInitialize. Must return errorcodes only from
    // winerror.h, raserror.h or mprerror.h
    //

    DWORD   (APIENTRY *RasEapBegin)( OUT VOID **             ppWorkBuffer,
                                     IN  PPP_EAP_INPUT *     pPppEapInput );

    //
    // Called to free the context buffer for this EAP session.
    // Called after this session is completed successfully or not, provided
    // the RasEapBegin call for this EAP session returned successfully.
    // Must return errorcodes only from winerror.h, raserror.h or mprerror.h
    //

    DWORD   (APIENTRY *RasEapEnd)(   IN  VOID *     pWorkBuffer );

    //
    // Called to process an incomming packet and/or send a packet.
    // cbSendPacket is the size in bytes of the buffer pointed to by
    // pSendPacket. Must return errorcodes only from winerror.h, raserror.h or
    // mprerror.h. Error return code indicates an error occurance during the
    // authentication process.
    //

    DWORD   (APIENTRY *RasEapMakeMessage)(
                            IN  VOID*               pWorkBuf,
                            IN  PPP_EAP_PACKET*     pReceivePacket,
                            OUT PPP_EAP_PACKET*     pSendPacket,
                            IN  DWORD               cbSendPacket,
                            OUT PPP_EAP_OUTPUT*     pEapOutput,
                            IN  PPP_EAP_INPUT*      pEapInput );

}PPP_EAP_INFO, *PPPP_EAP_INFO;

//
// RasEapGetInfo should be exported by the 3rd party EAP dll installed in the
// registry via the Path value.
//

DWORD APIENTRY
RasEapGetInfo(
    IN  DWORD           dwEapTypeId,
    OUT PPP_EAP_INFO*   pEapInfo
);

//
// RasEapFreeMemory should be exported by the 3rd party EAP dlls installed in
// the registry via the InteractiveUIPath, ConfigUIPath, and IdentityPath
// values.
//

DWORD APIENTRY
RasEapFreeMemory(
    IN  BYTE*           pMemory
);

//
// RasEapInvokeInteractiveUI and RasEapFreeMemory should be exported by the
// 3rd party EAP dll installed in the registry via the InteractiveUIPath
// value.
//

DWORD APIENTRY
RasEapInvokeInteractiveUI(
    IN  DWORD           dwEapTypeId,
    IN  HWND            hwndParent,
    IN  BYTE*           pUIContextData,
    IN  DWORD           dwSizeOfUIContextData,
    OUT BYTE**          ppDataFromInteractiveUI,
    OUT DWORD*          pdwSizeOfDataFromInteractiveUI
);

//
// RasEapInvokeConfigUI and RasEapFreeMemory should be exported by the
// 3rd party EAP dll installed in the registry via the ConfigUIPath value.
//

DWORD APIENTRY
RasEapInvokeConfigUI(
    IN  DWORD           dwEapTypeId,
    IN  HWND            hwndParent,
    IN  DWORD           dwFlags,
    IN  BYTE*           pConnectionDataIn,
    IN  DWORD           dwSizeOfConnectionDataIn,
    OUT BYTE**          ppConnectionDataOut,
    OUT DWORD*          pdwSizeOfConnectionDataOut
);

//
// RasEapGetIdentity and RasEapFreeMemory should be exported by the
// 3rd party EAP dll installed in the registry via the IdentityPath value.
//

DWORD APIENTRY
RasEapGetIdentity(
    IN  DWORD           dwEapTypeId,
    IN  HWND            hwndParent,
    IN  DWORD           dwFlags,
    IN  const WCHAR*    pwszPhonebook,
    IN  const WCHAR*    pwszEntry,
    IN  BYTE*           pConnectionDataIn,
    IN  DWORD           dwSizeOfConnectionDataIn,
    IN  BYTE*           pUserDataIn,
    IN  DWORD           dwSizeOfUserDataIn,
    OUT BYTE**          ppUserDataOut,
    OUT DWORD*          pdwSizeOfUserDataOut,
    OUT WCHAR**         ppwszIdentity
);

#endif /* WINVER >= 0x0500 */

#ifdef __cplusplus
}
#endif

#endif // _RASEAPIF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\raserror.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    raserror.h

Abstract:

    RAS specific error codes
    
--*/

#ifndef _RASERROR_H_
#define _RASERROR_H_

#if _MSC_VER > 1000
#pragma once
#endif

#define RASBASE 600
#define SUCCESS 0


#define PENDING                              (RASBASE+0)
/*
 * An operation is pending.%0
 */

#define ERROR_INVALID_PORT_HANDLE            (RASBASE+1)
/*
 * An invalid port handle was detected.%0
 */

#define ERROR_PORT_ALREADY_OPEN              (RASBASE+2)
/*
 * The specified port is already open.%0
 */

#define ERROR_BUFFER_TOO_SMALL               (RASBASE+3)
/*
 * The caller's buffer is too small.%0
 */

#define ERROR_WRONG_INFO_SPECIFIED           (RASBASE+4)
/*
 * Incorrect information was specified.%0
 */

#define ERROR_CANNOT_SET_PORT_INFO           (RASBASE+5)
/*
 * The port information cannot be set.%0
 */

#define ERROR_PORT_NOT_CONNECTED             (RASBASE+6)
/*
 * The specified port is not connected.%0
 */

#define ERROR_EVENT_INVALID                  (RASBASE+7)
/*
 * An invalid event was detected.%0
 */

#define ERROR_DEVICE_DOES_NOT_EXIST          (RASBASE+8)
/*
 * A device was specified that does not exist.%0
 */

#define ERROR_DEVICETYPE_DOES_NOT_EXIST      (RASBASE+9)
/*
 * A device type was specified that does not exist.%0
 */

#define ERROR_BUFFER_INVALID                 (RASBASE+10)
/*
 * An invalid buffer was specified.%0
 */

#define ERROR_ROUTE_NOT_AVAILABLE            (RASBASE+11)
/*
 * A route was specified that is not available.%0
 */

#define ERROR_ROUTE_NOT_ALLOCATED            (RASBASE+12)
/*
 * A route was specified that is not allocated.%0
 */

#define ERROR_INVALID_COMPRESSION_SPECIFIED  (RASBASE+13)
/*
 * An invalid compression was specified.%0
 */

#define ERROR_OUT_OF_BUFFERS                 (RASBASE+14)
/*
 * There were insufficient buffers available.%0
 */

#define ERROR_PORT_NOT_FOUND                 (RASBASE+15)
/*
 * The specified port was not found.%0
 */ 

#define ERROR_ASYNC_REQUEST_PENDING          (RASBASE+16)
/*
 * An asynchronous request is pending.%0
 */

#define ERROR_ALREADY_DISCONNECTING          (RASBASE+17)
/*
 * The modem (or other connecting device) is already disconnecting.%0
 */

#define ERROR_PORT_NOT_OPEN                  (RASBASE+18)
/*
 * The specified port is not open.%0
 */ 

#define ERROR_PORT_DISCONNECTED              (RASBASE+19)
/*
 * A connection to the remote computer could not be established, so the port used for this connection was closed. For further assistance, click More Info or search Help and Support Center for this error number.%0
 */

#define ERROR_NO_ENDPOINTS                   (RASBASE+20)
/*
 * No endpoints could be determined.%0
 */

#define ERROR_CANNOT_OPEN_PHONEBOOK          (RASBASE+21)
/*
 * The system could not open the phone book file.%0
 */ 

#define ERROR_CANNOT_LOAD_PHONEBOOK          (RASBASE+22)
/*
 * The system could not load the phone book file.%0
 */

#define ERROR_CANNOT_FIND_PHONEBOOK_ENTRY    (RASBASE+23)
/*
 * The system could not find the phone book entry for this connection.%0
 */

#define ERROR_CANNOT_WRITE_PHONEBOOK         (RASBASE+24)
/*
 * The system could not update the phone book file.%0
 */

#define ERROR_CORRUPT_PHONEBOOK              (RASBASE+25)
/*
 * The system found invalid information in the phone book file.%0
 */

#define ERROR_CANNOT_LOAD_STRING             (RASBASE+26)
/*
 * A string could not be loaded.%0
 */

#define ERROR_KEY_NOT_FOUND                  (RASBASE+27)
/*
 * A key could not be found.%0
 */

#define ERROR_DISCONNECTION                  (RASBASE+28)
/*
 * The connection was terminated by the remote computer before it could be completed. For further assistance, click More Info or search Help and Support Center for this error number.%0
 */ 

#define ERROR_REMOTE_DISCONNECTION           (RASBASE+29)
/*
 * The connection was closed by the remote computer.%0
 */

#define ERROR_HARDWARE_FAILURE               (RASBASE+30)
/*
 * The modem (or other connecting device) was disconnected due to hardware failure.%0
 */

#define ERROR_USER_DISCONNECTION             (RASBASE+31)
/*
 * The user disconnected the modem (or other connecting device).%0
 */

#define ERROR_INVALID_SIZE                   (RASBASE+32)
/*
 * An incorrect structure size was detected.%0
 */

#define ERROR_PORT_NOT_AVAILABLE             (RASBASE+33)
/*
 * The modem (or other connecting device) is already in use or is not configured properly.%0 
 */

#define ERROR_CANNOT_PROJECT_CLIENT          (RASBASE+34)
/*
 * Your computer could not be registered on the remote network.%0
 */ 

#define ERROR_UNKNOWN                        (RASBASE+35)
/*
 * There was an unknown error.%0
 */

#define ERROR_WRONG_DEVICE_ATTACHED          (RASBASE+36)
/*
 * The device attached to the port is not the one expected.%0
 */

#define ERROR_BAD_STRING                     (RASBASE+37)
/*
 * A string was detected that could not be converted.%0
 */

#define ERROR_REQUEST_TIMEOUT                (RASBASE+38)
/*
 * The remote server is not responding in a timely fashion. %0
 */

#define ERROR_CANNOT_GET_LANA                (RASBASE+39)
/*
 * No asynchronous net is available.%0
 */

#define ERROR_NETBIOS_ERROR                  (RASBASE+40)
/*
 * An error has occurred involving NetBIOS.%0
 */

#define ERROR_SERVER_OUT_OF_RESOURCES        (RASBASE+41)
/*
 * The server cannot allocate NetBIOS resources needed to support the client.%0
 */

#define ERROR_NAME_EXISTS_ON_NET             (RASBASE+42)
/*
 * One of your computer's NetBIOS names is already registered on the remote network.%0
 */

#define ERROR_SERVER_GENERAL_NET_FAILURE     (RASBASE+43)
/*
 * A network adapter at the server failed.%0
 */

#define WARNING_MSG_ALIAS_NOT_ADDED          (RASBASE+44)
/*
 * You will not receive network message popups.%0
 */

#define ERROR_AUTH_INTERNAL                  (RASBASE+45)
/*
 * There was an internal authentication error.%0
 */

#define ERROR_RESTRICTED_LOGON_HOURS         (RASBASE+46)
/*
 * The account is not permitted to log on at this time of day.%0
 */

#define ERROR_ACCT_DISABLED                  (RASBASE+47)
/*
 * The account is disabled.%0
 */

#define ERROR_PASSWD_EXPIRED                 (RASBASE+48)
/*
 * The password for this account has expired.%0
 */

#define ERROR_NO_DIALIN_PERMISSION           (RASBASE+49)
/*
 * The account does not have permission to dial in.%0
 */

#define ERROR_SERVER_NOT_RESPONDING          (RASBASE+50)
/*
 * The remote access server is not responding.%0
 */

#define ERROR_FROM_DEVICE                    (RASBASE+51)
/*
 * The modem (or other connecting device) has reported an error.%0
 */

#define ERROR_UNRECOGNIZED_RESPONSE          (RASBASE+52)
/*
 * There was an unrecognized response from the modem (or other connecting device).%0
 */

#define ERROR_MACRO_NOT_FOUND                (RASBASE+53)
/*
 * A macro required by the modem (or other connecting device) was not found in the device.INF file.%0
 */

#define ERROR_MACRO_NOT_DEFINED              (RASBASE+54)
/*
 * A command or response in the device.INF file section refers to an undefined macro.%0
 */

#define ERROR_MESSAGE_MACRO_NOT_FOUND        (RASBASE+55)
/*
 * The <message> macro was not found in the device.INF file section.%0
 */

#define ERROR_DEFAULTOFF_MACRO_NOT_FOUND     (RASBASE+56)
/*
 * The <defaultoff> macro in the device.INF file section contains an undefined macro.%0
 */

#define ERROR_FILE_COULD_NOT_BE_OPENED       (RASBASE+57)
/*
 * The device.INF file could not be opened.%0
 */

#define ERROR_DEVICENAME_TOO_LONG            (RASBASE+58)
/*
 * The device name in the device.INF or media.INI file is too long.%0
 */

#define ERROR_DEVICENAME_NOT_FOUND           (RASBASE+59)
/*
 * The media.INI file refers to an unknown device name.%0
 */

#define ERROR_NO_RESPONSES                   (RASBASE+60)
/*
 * The device.INF file contains no responses for the command.%0
 */

#define ERROR_NO_COMMAND_FOUND               (RASBASE+61)
/*
 * The device.INF file is missing a command.%0
 */

#define ERROR_WRONG_KEY_SPECIFIED            (RASBASE+62)
/*
 * There was an attempt to set a macro not listed in device.INF file section.%0
 */

#define ERROR_UNKNOWN_DEVICE_TYPE            (RASBASE+63)
/*
 * The media.INI file refers to an unknown device type.%0
 */

#define ERROR_ALLOCATING_MEMORY              (RASBASE+64)
/*
 * The system has run out of memory.%0
 */

#define ERROR_PORT_NOT_CONFIGURED            (RASBASE+65)
/*
 * The modem (or other connecting device) is not properly configured.%0
 */

#define ERROR_DEVICE_NOT_READY               (RASBASE+66)
/*
 * The modem (or other connecting device) is not functioning.%0
 */

#define ERROR_READING_INI_FILE               (RASBASE+67)
/*
 * The system was unable to read the media.INI file.%0
 */

#define ERROR_NO_CONNECTION                  (RASBASE+68)
/*
 * The connection was terminated.%0
 */

#define ERROR_BAD_USAGE_IN_INI_FILE          (RASBASE+69)
/*
 * The usage parameter in the media.INI file is invalid.%0
 */

#define ERROR_READING_SECTIONNAME            (RASBASE+70)
/*
 * The system was unable to read the section name from the media.INI file.%0
 */

#define ERROR_READING_DEVICETYPE             (RASBASE+71)
/*
 * The system was unable to read the device type from the media.INI file.%0
 */

#define ERROR_READING_DEVICENAME             (RASBASE+72)
/*
 * The system was unable to read the device name from the media.INI file.%0
 */

#define ERROR_READING_USAGE                  (RASBASE+73)
/*
 * The system was unable to read the usage from the media.INI file.%0
 */

#define ERROR_READING_MAXCONNECTBPS          (RASBASE+74)
/*
 * The system was unable to read the maximum connection BPS rate from the media.INI file.%0
 */

#define ERROR_READING_MAXCARRIERBPS          (RASBASE+75)
/*
 * The system was unable to read the maximum carrier connection speed from the media.INI file.%0
 */

#define ERROR_LINE_BUSY                      (RASBASE+76)
/*
 * The phone line is busy.%0
 */

#define ERROR_VOICE_ANSWER                   (RASBASE+77)
/*
 * A person answered instead of a modem (or other connecting device).%0
 */

#define ERROR_NO_ANSWER                      (RASBASE+78)
/*
 * The remote computer did not respond. For further assistance, click More Info or search Help and Support Center for this error number.%0
 */

#define ERROR_NO_CARRIER                     (RASBASE+79)
/*
 * The system could not detect the carrier.%0
 */

#define ERROR_NO_DIALTONE                    (RASBASE+80)
/*
 * There was no dial tone.%0
 */

#define ERROR_IN_COMMAND                     (RASBASE+81)
/*
 * The modem (or other connecting device) reported a general error.%0
 */

#define ERROR_WRITING_SECTIONNAME            (RASBASE+82)
/*
 * There was an error in writing the section name.%0
 */

#define ERROR_WRITING_DEVICETYPE             (RASBASE+83)
/*
 * There was an error in writing the device type.%0
 */

#define ERROR_WRITING_DEVICENAME             (RASBASE+84)
/*
 * There was an error in writing the device name.%0
 */

#define ERROR_WRITING_MAXCONNECTBPS          (RASBASE+85)
/*
 * There was an error in writing the maximum connection speed.
 */

#define ERROR_WRITING_MAXCARRIERBPS          (RASBASE+86)
/*
 * There was an error in writing the maximum carrier speed.%0
 */

#define ERROR_WRITING_USAGE                  (RASBASE+87)
/*
 * There was an error in writing the usage.%0
 */

#define ERROR_WRITING_DEFAULTOFF             (RASBASE+88)
/*
 *  There was an error in writing the default-off.%0
 */

#define ERROR_READING_DEFAULTOFF             (RASBASE+89)
/*
 *  There was an error in reading the default-off.%0
 */

#define ERROR_EMPTY_INI_FILE                 (RASBASE+90)
/*
 * ERROR_EMPTY_INI_FILE%0
 */

#define ERROR_AUTHENTICATION_FAILURE         (RASBASE+91)
/*
 * Access was denied because the username and/or password was invalid on the domain.%0
 */

#define ERROR_PORT_OR_DEVICE                 (RASBASE+92)
/*
 * There was a hardware failure in the modem (or other connecting device).%0
 */

#define ERROR_NOT_BINARY_MACRO               (RASBASE+93)
/*
 * ERROR_NOT_BINARY_MACRO%0
 */

#define ERROR_DCB_NOT_FOUND                  (RASBASE+94)
/*
 * ERROR_DCB_NOT_FOUND%0
 */

#define ERROR_STATE_MACHINES_NOT_STARTED     (RASBASE+95)
/*
 * The state machines are not started.%0
 */

#define ERROR_STATE_MACHINES_ALREADY_STARTED (RASBASE+96)
/*
 * The state machines are already started.%0
 */

#define ERROR_PARTIAL_RESPONSE_LOOPING       (RASBASE+97)
/*
 * The response looping did not complete.%0
 */

#define ERROR_UNKNOWN_RESPONSE_KEY           (RASBASE+98)
/*
 * A response keyname in the device.INF file is not in the expected format.%0
 */

#define ERROR_RECV_BUF_FULL                  (RASBASE+99)
/*
 * The modem (or other connecting device) response caused a buffer overflow.%0
 */

#define ERROR_CMD_TOO_LONG                   (RASBASE+100)
/*
 * The expanded command in the device.INF file is too long.%0
 */

#define ERROR_UNSUPPORTED_BPS                (RASBASE+101)
/*
 * The modem moved to a connection speed not supported by the COM driver.%0
 */

#define ERROR_UNEXPECTED_RESPONSE            (RASBASE+102)
/*
 * Device response received when none expected.%0
 */

#define ERROR_INTERACTIVE_MODE               (RASBASE+103)
/*
 * The connection needs information from you, but the application does not allow user interaction.%0
 */

#define ERROR_BAD_CALLBACK_NUMBER            (RASBASE+104)
/*
 * The callback number is invalid.%0
 */

#define ERROR_INVALID_AUTH_STATE             (RASBASE+105)
/*
 * The authorization state is invalid.%0
 */

#define ERROR_WRITING_INITBPS                (RASBASE+106)
/*
 * ERROR_WRITING_INITBPS%0
 */

#define ERROR_X25_DIAGNOSTIC                 (RASBASE+107)
/*
 * There was an error related to the X.25 protocol.%0
 */

#define ERROR_ACCT_EXPIRED                   (RASBASE+108)
/*
 * The account has expired.%0
 */

#define ERROR_CHANGING_PASSWORD              (RASBASE+109)
/*
 * There was an error changing the password on the domain.  The password might have been too short or might have matched a previously used password.%0
 */

#define ERROR_OVERRUN                        (RASBASE+110)
/*
 * Serial overrun errors were detected while communicating with the modem.%0
 */

#define ERROR_RASMAN_CANNOT_INITIALIZE	     (RASBASE+111)
/*
 * A configuration error on this computer is preventing this connection. For further assistance, click More Info or search Help and Support Center for this error number.%0
 */

#define ERROR_BIPLEX_PORT_NOT_AVAILABLE      (RASBASE+112)
/*
 * The two-way port is initializing.  Wait a few seconds and redial.%0
 */

#define ERROR_NO_ACTIVE_ISDN_LINES           (RASBASE+113)
/*
 * No active ISDN lines are available.%0
 */

#define ERROR_NO_ISDN_CHANNELS_AVAILABLE     (RASBASE+114)
/*
 * No ISDN channels are available to make the call.%0
 */

#define ERROR_TOO_MANY_LINE_ERRORS           (RASBASE+115)
/*
 * Too many errors occurred because of poor phone line quality.%0
 */

#define ERROR_IP_CONFIGURATION               (RASBASE+116)
/*
 * The Remote Access Service IP configuration is unusable.%0
 */

#define ERROR_NO_IP_ADDRESSES                (RASBASE+117)
/*
 * No IP addresses are available in the static pool of Remote Access Service IP addresses.%0
 */

#define ERROR_PPP_TIMEOUT                    (RASBASE+118)
/*
 * The connection was terminated because the remote computer did not respond in a timely manner. For further assistance, click More Info or search Help and Support Center for this error number.%0
 */

#define ERROR_PPP_REMOTE_TERMINATED          (RASBASE+119)
/*
 * The connection was terminated by the remote computer.%0
 */

#define ERROR_PPP_NO_PROTOCOLS_CONFIGURED    (RASBASE+120)
/*
 * A connection to the remote computer could not be established. You might need to change the network settings for this connection. For further assistance, click More Info or search Help and Support Center for this error number.%0
 */

#define ERROR_PPP_NO_RESPONSE                (RASBASE+121)
/*
 * The remote computer did not respond. For further assistance, click More Info or search Help and Support Center for this error number.%0
 */

#define ERROR_PPP_INVALID_PACKET             (RASBASE+122)
/*
 * Invalid data was received from the remote computer. This data was ignored.%0
 */

#define ERROR_PHONE_NUMBER_TOO_LONG          (RASBASE+123)
/*
 * The phone number, including prefix and suffix, is too long.%0
 */

#define ERROR_IPXCP_NO_DIALOUT_CONFIGURED    (RASBASE+124)
/*
 * The IPX protocol cannot dial out on the modem (or other connecting device) because this computer is not configured for dialing out (it is an IPX router).%0
 */

#define ERROR_IPXCP_NO_DIALIN_CONFIGURED     (RASBASE+125)
/*
 * The IPX protocol cannot dial in on the modem (or other connecting device) because this computer is not configured for dialing in (the IPX router is not installed).%0
 */

#define ERROR_IPXCP_DIALOUT_ALREADY_ACTIVE   (RASBASE+126)
/*
 * The IPX protocol cannot be used for dialing out on more than one modem (or other connecting device) at a time.%0
 */

#define ERROR_ACCESSING_TCPCFGDLL            (RASBASE+127)
/*
 * Cannot access TCPCFG.DLL.%0
 */

#define ERROR_NO_IP_RAS_ADAPTER              (RASBASE+128)
/*
 * The system cannot find an IP adapter.%0
 */

#define ERROR_SLIP_REQUIRES_IP               (RASBASE+129)
/*
 * SLIP cannot be used unless the IP protocol is installed.%0
 */

#define ERROR_PROJECTION_NOT_COMPLETE        (RASBASE+130)
/*
 * Computer registration is not complete.%0
 */

#define ERROR_PROTOCOL_NOT_CONFIGURED        (RASBASE+131)
/*
 * The protocol is not configured.%0
 */

#define ERROR_PPP_NOT_CONVERGING             (RASBASE+132)
/*
 *Your computer and the remote computer could not agree on PPP control protocols.%0
 */

#define ERROR_PPP_CP_REJECTED                (RASBASE+133)
/*
 * A connection to the remote computer could not be completed. You might need to adjust the protocols on this computer. For further assistance, click More Info or search Help and Support Center for this error number.%0
 */

#define ERROR_PPP_LCP_TERMINATED             (RASBASE+134)
/*
 * The PPP link control protocol was terminated.%0
 */

#define ERROR_PPP_REQUIRED_ADDRESS_REJECTED  (RASBASE+135)
/*
 * The requested address was rejected by the server.%0
 */

#define ERROR_PPP_NCP_TERMINATED             (RASBASE+136)
/*
 * The remote computer terminated the control protocol.%0
 */

#define ERROR_PPP_LOOPBACK_DETECTED          (RASBASE+137)
/*
 * Loopback was detected.%0
 */

#define ERROR_PPP_NO_ADDRESS_ASSIGNED        (RASBASE+138)
/*
 * The server did not assign an address.%0
 */

#define ERROR_CANNOT_USE_LOGON_CREDENTIALS   (RASBASE+139)
/*
 * The authentication protocol required by the remote server cannot use the stored password.  Redial, entering the password explicitly.%0
 */

#define ERROR_TAPI_CONFIGURATION             (RASBASE+140)
/*
 * An invalid dialing rule was detected.%0
 */

#define ERROR_NO_LOCAL_ENCRYPTION            (RASBASE+141)
/*
 * The local computer does not support the required data encryption type.%0
 */

#define ERROR_NO_REMOTE_ENCRYPTION           (RASBASE+142)
/*
 * The remote computer does not support the required data encryption type.%0
 */

#define ERROR_REMOTE_REQUIRES_ENCRYPTION     (RASBASE+143)
/*
 * The remote computer requires data encryption.%0
 */

#define ERROR_IPXCP_NET_NUMBER_CONFLICT      (RASBASE+144)
/*
 * The system cannot use the IPX network number assigned by the remote computer.  Additional information is provided in the event log.%0
 */

#define ERROR_INVALID_SMM                    (RASBASE+145)
/*
 * ERROR_INVALID_SMM%0
 */

#define ERROR_SMM_UNINITIALIZED              (RASBASE+146)
/*
 * ERROR_SMM_UNINITIALIZED%0
 */

#define ERROR_NO_MAC_FOR_PORT                (RASBASE+147)
/*
 * ERROR_NO_MAC_FOR_PORT%0
 */

#define ERROR_SMM_TIMEOUT                    (RASBASE+148)
/*
 * ERROR_SMM_TIMEOUT%0
 */

#define ERROR_BAD_PHONE_NUMBER               (RASBASE+149)
/*
 * ERROR_BAD_PHONE_NUMBER%0
 */

#define ERROR_WRONG_MODULE                   (RASBASE+150)
/*
 * ERROR_WRONG_MODULE%0
 */

#define ERROR_INVALID_CALLBACK_NUMBER        (RASBASE+151)
/*
 * The callback number contains an invalid character.  Only the following 18 characters are allowed:  0 to 9, T, P, W, (, ), -, @, and space.%0
 */

#define ERROR_SCRIPT_SYNTAX                  (RASBASE+152)
/*
 * A syntax error was encountered while processing a script.%0
 */

#define ERROR_HANGUP_FAILED                  (RASBASE+153)
/*
 * The connection could not be disconnected because it was created by the multi-protocol router.%0
 */

#define ERROR_BUNDLE_NOT_FOUND               (RASBASE+154)
/*
 * The system could not find the multi-link bundle.%0
 */

#define ERROR_CANNOT_DO_CUSTOMDIAL           (RASBASE+155)
/*
 * The system cannot perform automated dial because this connection  has a custom dialer specified.%0
 */ 

#define ERROR_DIAL_ALREADY_IN_PROGRESS      (RASBASE+156)
/*
 * This connection is already being dialed.%0
 */

#define ERROR_RASAUTO_CANNOT_INITIALIZE	    (RASBASE+157)
/*
 * Remote Access Services could not be started automatically. Additional information is provided in the event log.%0
 */

#define ERROR_CONNECTION_ALREADY_SHARED     (RASBASE+158)
/*
 * Internet Connection Sharing is already enabled on the connection.%0
 */

#define ERROR_SHARING_CHANGE_FAILED         (RASBASE+159)
/*
 * An error occurred while the existing Internet Connection Sharing settings were being changed.%0
 */

#define ERROR_SHARING_ROUTER_INSTALL        (RASBASE+160)
/*
 * An error occurred while routing capabilities were being enabled.%0
 */

#define ERROR_SHARE_CONNECTION_FAILED       (RASBASE+161)
/*
 * An error occurred while Internet Connection Sharing was being enabled for the connection.%0
 */

#define ERROR_SHARING_PRIVATE_INSTALL       (RASBASE+162)
/*
 * An error occurred while the local network was being configured for sharing.%0
 */

#define ERROR_CANNOT_SHARE_CONNECTION       (RASBASE+163)
/*
 * Internet Connection Sharing cannot be enabled.  There is more than one LAN connection other than the connection to be shared.%0
 */

#define ERROR_NO_SMART_CARD_READER          (RASBASE+164)
/*
 * No smart card reader is installed.%0
 */

#define ERROR_SHARING_ADDRESS_EXISTS        (RASBASE+165)
/*
 * Internet Connection Sharing cannot be enabled.  A LAN connection is already configured with the IP address that is required for automatic IP addressing.%0
 */

#define ERROR_NO_CERTIFICATE                (RASBASE+166)
/*
 * A certificate could not be found. Connections that use the L2TP protocol over IPSec require the installation of a machine certificate, also known as a computer certificate.%0
 */

#define ERROR_SHARING_MULTIPLE_ADDRESSES    (RASBASE+167)
/*
 * Internet Connection Sharing cannot be enabled. The LAN connection selected as the private network has more than one IP address configured.  Please reconfigure the LAN connection with a single IP address before enabling Internet Connection Sharing.%0
 */

#define ERROR_FAILED_TO_ENCRYPT             (RASBASE+168)
/*
 * The connection attempt failed because of failure to encrypt data.%0
 */

#define ERROR_BAD_ADDRESS_SPECIFIED         (RASBASE+169)
/*
 * The specified destination is not reachable.%0
 */

#define ERROR_CONNECTION_REJECT             (RASBASE+170)
/*
 * The remote computer rejected the connection attempt.%0
 */

#define ERROR_CONGESTION                    (RASBASE+171)
/*
 * The connection attempt failed because the network is busy.%0
 */

#define ERROR_INCOMPATIBLE                  (RASBASE+172)
/*
 * The remote computer's network hardware is incompatible with the type of call requested.%0
 */

#define ERROR_NUMBERCHANGED                 (RASBASE+173)
/*
 * The connection attempt failed because the destination number has changed.%0
 */

#define ERROR_TEMPFAILURE                   (RASBASE+174)
/*
 * The connection attempt failed because of a temporary failure.  Try connecting again.%0
 */ 

#define ERROR_BLOCKED                       (RASBASE+175)
/*
 * The call was blocked by the remote computer.%0
 */

#define ERROR_DONOTDISTURB                  (RASBASE+176)
/*
 * The call could not be connected because the remote computer has invoked the Do Not Disturb feature.%0
 */

#define ERROR_OUTOFORDER                    (RASBASE+177)
/*
 * The connection attempt failed because the modem (or other connecting device) on the remote computer is out of order.%0
 */

#define ERROR_UNABLE_TO_AUTHENTICATE_SERVER (RASBASE+178)
/*
 * It was not possible to verify the identity of the server.%0
 */

#define ERROR_SMART_CARD_REQUIRED           (RASBASE+179)
/*
 * To dial out using this connection you must use a smart card.%0
 */

#define ERROR_INVALID_FUNCTION_FOR_ENTRY    (RASBASE+180)
/*
 * An attempted function is not valid for this connection.%0
 */

#define ERROR_CERT_FOR_ENCRYPTION_NOT_FOUND (RASBASE+181)
/*
 * The connection requires a certificate, and no valid certificate was found. For further assistance, click More Info or search Help and Support Center for this error number.%0
 */

#define ERROR_SHARING_RRAS_CONFLICT         (RASBASE+182)
/*
 * Internet Connection Sharing (ICS) and Internet Connection Firewall (ICF) cannot be enabled because Routing and Remote Access has been enabled on this computer. To enable ICS or ICF, first disable Routing and Remote Access. For more information about Routing and Remote Access, ICS, or ICF, see Help and Support.%0
 */

#define ERROR_SHARING_NO_PRIVATE_LAN        (RASBASE+183)
/*
 * Internet Connection Sharing cannot be enabled. The LAN connection selected as the private network is either not present, or is disconnected from the network. Please ensure that the LAN adapter is connected before enabling Internet Connection Sharing.%0
 */

#define ERROR_NO_DIFF_USER_AT_LOGON         (RASBASE+184)
/*
 * You cannot dial using this connection at logon time, because it is configured to use a user name different than the one on the smart card. If you want to use it at logon time, you must configure it to use the user name on the smart card.%0
 */

#define ERROR_NO_REG_CERT_AT_LOGON          (RASBASE+185)
/*
 * You cannot dial using this connection at logon time, because it is not configured to use a smart card. If you want to use it at logon time, you must edit the properties of this connection so that it uses a smart card.%0
 */

#define ERROR_OAKLEY_NO_CERT                (RASBASE+186)
/*
 * The L2TP connection attempt failed because there is no valid machine certificate on your computer for security authentication.%0
 */

#define ERROR_OAKLEY_AUTH_FAIL              (RASBASE+187)
/*
 * The L2TP connection attempt failed because the security layer could not authenticate the remote computer.%0
 */

#define ERROR_OAKLEY_ATTRIB_FAIL            (RASBASE+188)
/*
 * The L2TP connection attempt failed because the security layer could not negotiate compatible parameters with the remote computer.%0
 */

#define ERROR_OAKLEY_GENERAL_PROCESSING     (RASBASE+189)
/*
 * The L2TP connection attempt failed because the security layer encountered a processing error during initial negotiations with the remote computer.%0
 */

#define ERROR_OAKLEY_NO_PEER_CERT           (RASBASE+190)
/*
 * The L2TP connection attempt failed because certificate validation on the remote computer failed.%0
 */

#define ERROR_OAKLEY_NO_POLICY              (RASBASE+191)
/*
 * The L2TP connection attempt failed because security policy for the connection was not found.%0
 */

#define ERROR_OAKLEY_TIMED_OUT              (RASBASE+192)
/*
 * The L2TP connection attempt failed because security negotiation timed out.%0
 */

#define ERROR_OAKLEY_ERROR                  (RASBASE+193)
/*
 * The L2TP connection attempt failed because an error occurred while negotiating security.%0
 */

#define ERROR_UNKNOWN_FRAMED_PROTOCOL       (RASBASE+194)
/*
 * The Framed Protocol RADIUS attribute for this user is not PPP.%0
 */

#define ERROR_WRONG_TUNNEL_TYPE             (RASBASE+195)
/*
 * The Tunnel Type RADIUS attribute for this user is not correct.%0
 */

#define ERROR_UNKNOWN_SERVICE_TYPE          (RASBASE+196)
/*
 * The Service Type RADIUS attribute for this user is neither Framed nor Callback Framed.%0
 */

#define ERROR_CONNECTING_DEVICE_NOT_FOUND   (RASBASE+197)
/*
 * A connection to the remote computer could not be established because the modem was not found or was busy. For further assistance, click More Info or search Help and Support Center for this error number.%0
 */

#define ERROR_NO_EAPTLS_CERTIFICATE          (RASBASE+198)
/*
 * A certificate could not be found that can be used with this Extensible Authentication Protocol.%0
 */

#define ERROR_SHARING_HOST_ADDRESS_CONFLICT (RASBASE+199)
/*
 * Internet Connection Sharing (ICS) cannot be enabled due to an IP address conflict on the network. ICS requires the host be configured to use 192.168.0.1. Please ensure that no other client on the network is configured to use 192.168.0.1.%0
 */

#define ERROR_AUTOMATIC_VPN_FAILED          (RASBASE+200)
/*
 * Unable to establish the VPN connection.  The VPN server may be unreachable, or security parameters may not be configured properly for this connection.%0
 */

#define ERROR_VALIDATING_SERVER_CERT        (RASBASE+201)
/*
* This connection is configured to validate the identity of the access server, but Windows cannot verify the digital certificate sent by the server.%0
*/

#define ERROR_READING_SCARD                 (RASBASE+202)
/*
* The card supplied was not recognized. Please check that the card is inserted correctly, and fits tightly.%0
*/

#define ERROR_INVALID_PEAP_COOKIE_CONFIG    (RASBASE+203)
/*
* The PEAP configuration stored in the session cookie does not match the current session configuration.%0
*/

#define ERROR_INVALID_PEAP_COOKIE_USER      (RASBASE+204)
/*
* The PEAP identity stored in the session cookie does not match the current identity.%0
*/

#define ERROR_INVALID_MSCHAPV2_CONFIG       (RASBASE+205)
/*
* You cannot dial using this connection at logon time, because it is configured to use logged on user's credentials.%0
*/


#define RASBASEEND                          (RASBASE+205)

#endif // _RASERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\rassapi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rassapi.h

Description:

    This file contains the RASADMIN structures, defines and
    function prototypes for the following APIs and they can
    be imported from RASSAPI.DLL:

     RasAdminServerGetInfo
     RasAdminGetUserAccountServer
     RasAdminUserSetInfo
     RasAdminUserGetInfo
     RasAdminPortEnum
     RasAdminPortGetInfo
     RasAdminPortClearStatistics
     RasAdminPortDisconnect
     RasAdminFreeBuffer

Note:

    This header file and the sources containing the APIs will work
    only with UNICODE strings.

--*/

#ifndef _RASSAPI_H_
#define _RASSAPI_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#if (WINVER < 0x502)

#ifndef UNLEN
#include <lmcons.h>
#endif // UNLEN

#define RASSAPI_MAX_PHONENUMBER_SIZE     128
#define RASSAPI_MAX_MEDIA_NAME	         16
#define RASSAPI_MAX_PORT_NAME	            16
#define RASSAPI_MAX_DEVICE_NAME          128
#define RASSAPI_MAX_DEVICETYPE_NAME       16
#define RASSAPI_MAX_PARAM_KEY_SIZE        32

// Bits indicating user's Remote Access privileges and mask to isolate
// call back privilege.
//
// Note: Bit 0 MUST represent NoCallback due to a quirk of the "userparms"
//       storage method.  When a new LAN Manager user is created, bit 0 of the
//       userparms field is set to 1 and all other bits are 0.  These bits are
//       arranged so this "no Dial-In info" state maps to the "default Dial-In
//       privilege" state.

#define RASPRIV_NoCallback        0x01
#define RASPRIV_AdminSetCallback  0x02
#define RASPRIV_CallerSetCallback 0x04
#define RASPRIV_DialinPrivilege   0x08

#define RASPRIV_CallbackType (RASPRIV_AdminSetCallback \
                              | RASPRIV_CallerSetCallback \
                              | RASPRIV_NoCallback)

//
// Modem condition codes
//
#define	RAS_MODEM_OPERATIONAL	     1	// No modem errors.
#define	RAS_MODEM_NOT_RESPONDING     2
#define	RAS_MODEM_HARDWARE_FAILURE   3
#define	RAS_MODEM_INCORRECT_RESPONSE 4
#define	RAS_MODEM_UNKNOWN 	        5
//
// Line condition codes
//
#define	RAS_PORT_NON_OPERATIONAL 1
#define	RAS_PORT_DISCONNECTED	 2
#define	RAS_PORT_CALLING_BACK    3
#define	RAS_PORT_LISTENING	    4
#define	RAS_PORT_AUTHENTICATING  5
#define	RAS_PORT_AUTHENTICATED	 6
#define	RAS_PORT_INITIALIZING	 7

// The following three structures are same as the ones
// defined in rasman.h and have been renamed to prevent
// redefinitions when both header files are included.

enum RAS_PARAMS_FORMAT {

	ParamNumber	    = 0,

	ParamString	    = 1

} ;
typedef enum RAS_PARAMS_FORMAT	RAS_PARAMS_FORMAT ;

union RAS_PARAMS_VALUE {

	DWORD	Number ;

	struct	{
		DWORD	Length ;
		PCHAR	Data ;
		} String ;
} ;
typedef union RAS_PARAMS_VALUE	RAS_PARAMS_VALUE ;

struct RAS_PARAMETERS {

    CHAR	P_Key	[RASSAPI_MAX_PARAM_KEY_SIZE] ;

    RAS_PARAMS_FORMAT	P_Type ;

    BYTE	P_Attributes ;

    RAS_PARAMS_VALUE	P_Value ;

} ;
typedef struct RAS_PARAMETERS	RAS_PARAMETERS ;

// structures used by the RASADMIN APIs

typedef struct _RAS_USER_0
{
    BYTE bfPrivilege;
    WCHAR szPhoneNumber[ RASSAPI_MAX_PHONENUMBER_SIZE + 1];
} RAS_USER_0, *PRAS_USER_0;

typedef struct _RAS_PORT_0
{
    WCHAR wszPortName[RASSAPI_MAX_PORT_NAME];
    WCHAR wszDeviceType[RASSAPI_MAX_DEVICETYPE_NAME];
    WCHAR wszDeviceName[RASSAPI_MAX_DEVICE_NAME];
    WCHAR wszMediaName[RASSAPI_MAX_MEDIA_NAME];
    DWORD reserved;
    DWORD Flags;
    WCHAR wszUserName[UNLEN + 1];
    WCHAR wszComputer[NETBIOS_NAME_LEN];
    DWORD dwStartSessionTime;          // seconds from 1/1/1970
    WCHAR wszLogonDomain[DNLEN + 1];
    BOOL fAdvancedServer;
} RAS_PORT_0, *PRAS_PORT_0;


// Possible values for MediaId

#define MEDIA_UNKNOWN       0
#define MEDIA_SERIAL        1
#define MEDIA_RAS10_SERIAL  2
#define MEDIA_X25           3
#define MEDIA_ISDN          4


// Possible bits set in Flags field

#define USER_AUTHENTICATED    0x0001
#define MESSENGER_PRESENT     0x0002
#define PPP_CLIENT            0x0004
#define GATEWAY_ACTIVE        0x0008
#define REMOTE_LISTEN         0x0010
#define PORT_MULTILINKED      0x0020


typedef ULONG IPADDR;

// The following PPP structures are same as the ones
// defined in rasppp.h and have been renamed to prevent
// redefinitions when both header files are included
// in a module.

/* Maximum length of address string, e.g. "255.255.255.255" for IP.
*/
#define RAS_IPADDRESSLEN  15
#define RAS_IPXADDRESSLEN 22
#define RAS_ATADDRESSLEN  32

typedef struct _RAS_PPP_NBFCP_RESULT
{
    DWORD dwError;
    DWORD dwNetBiosError;
    CHAR  szName[ NETBIOS_NAME_LEN + 1 ];
    WCHAR wszWksta[ NETBIOS_NAME_LEN + 1 ];
} RAS_PPP_NBFCP_RESULT;

typedef struct _RAS_PPP_IPCP_RESULT
{
    DWORD dwError;
    WCHAR wszAddress[ RAS_IPADDRESSLEN + 1 ];
} RAS_PPP_IPCP_RESULT;

typedef struct _RAS_PPP_IPXCP_RESULT
{
    DWORD dwError;
    WCHAR wszAddress[ RAS_IPXADDRESSLEN + 1 ];
} RAS_PPP_IPXCP_RESULT;

typedef struct _RAS_PPP_ATCP_RESULT
{
    DWORD dwError;
    WCHAR wszAddress[ RAS_ATADDRESSLEN + 1 ];
} RAS_PPP_ATCP_RESULT;

typedef struct _RAS_PPP_PROJECTION_RESULT
{
    RAS_PPP_NBFCP_RESULT nbf;
    RAS_PPP_IPCP_RESULT  ip;
    RAS_PPP_IPXCP_RESULT ipx;
    RAS_PPP_ATCP_RESULT  at;
} RAS_PPP_PROJECTION_RESULT;

typedef struct _RAS_PORT_1
{
    RAS_PORT_0                 rasport0;
    DWORD                      LineCondition;
    DWORD                      HardwareCondition;
    DWORD                      LineSpeed;        // in bits/second
    WORD                       NumStatistics;
    WORD                       NumMediaParms;
    DWORD                      SizeMediaParms;
    RAS_PPP_PROJECTION_RESULT  ProjResult;
} RAS_PORT_1, *PRAS_PORT_1;

typedef struct _RAS_PORT_STATISTICS
{
    // The connection statistics are followed by port statistics
    // A connection is across multiple ports.
    DWORD   dwBytesXmited;
    DWORD   dwBytesRcved;
    DWORD   dwFramesXmited;
    DWORD   dwFramesRcved;
    DWORD   dwCrcErr;
    DWORD   dwTimeoutErr;
    DWORD   dwAlignmentErr;
    DWORD   dwHardwareOverrunErr;
    DWORD   dwFramingErr;
    DWORD   dwBufferOverrunErr;
    DWORD   dwBytesXmitedUncompressed;
    DWORD   dwBytesRcvedUncompressed;
    DWORD   dwBytesXmitedCompressed;
    DWORD   dwBytesRcvedCompressed;

    // the following are the port statistics
    DWORD   dwPortBytesXmited;
    DWORD   dwPortBytesRcved;
    DWORD   dwPortFramesXmited;
    DWORD   dwPortFramesRcved;
    DWORD   dwPortCrcErr;
    DWORD   dwPortTimeoutErr;
    DWORD   dwPortAlignmentErr;
    DWORD   dwPortHardwareOverrunErr;
    DWORD   dwPortFramingErr;
    DWORD   dwPortBufferOverrunErr;
    DWORD   dwPortBytesXmitedUncompressed;
    DWORD   dwPortBytesRcvedUncompressed;
    DWORD   dwPortBytesXmitedCompressed;
    DWORD   dwPortBytesRcvedCompressed;

} RAS_PORT_STATISTICS, *PRAS_PORT_STATISTICS;

//
// Server version numbers
//
#define RASDOWNLEVEL       10    // identifies a LM RAS 1.0 server
#define RASADMIN_35        35    // Identifies a NT RAS 3.5 server or client
#define RASADMIN_CURRENT   40    // Identifies a NT RAS 4.0 server or client


typedef struct _RAS_SERVER_0
{
    WORD TotalPorts;             // Total ports configured on the server
    WORD PortsInUse;             // Ports currently in use by remote clients
    DWORD RasVersion;            // version of RAS server
} RAS_SERVER_0, *PRAS_SERVER_0;


//
// function prototypes
//

DWORD APIENTRY RasAdminServerGetInfo(
    IN const WCHAR *  lpszServer,
    OUT PRAS_SERVER_0 pRasServer0
    );

DWORD APIENTRY RasAdminGetUserAccountServer(
    IN const WCHAR * lpszDomain,
    IN const WCHAR * lpszServer,
    OUT LPWSTR       lpszUserAccountServer
    );

DWORD APIENTRY RasAdminUserGetInfo(
    IN const WCHAR   * lpszUserAccountServer,
    IN const WCHAR   * lpszUser,
    OUT PRAS_USER_0    pRasUser0
    );

DWORD APIENTRY RasAdminUserSetInfo(
    IN const WCHAR       * lpszUserAccountServer,
    IN const WCHAR       * lpszUser,
    IN const PRAS_USER_0   pRasUser0
    );

DWORD APIENTRY RasAdminPortEnum(
    IN  const WCHAR * lpszServer,
    OUT PRAS_PORT_0 * ppRasPort0,
    OUT WORD *        pcEntriesRead
    );

DWORD APIENTRY RasAdminPortGetInfo(
    IN const WCHAR *            lpszServer,
    IN const WCHAR *            lpszPort,
    OUT RAS_PORT_1 *            pRasPort1,
    OUT RAS_PORT_STATISTICS *   pRasStats,
    OUT RAS_PARAMETERS **       ppRasParams
    );

DWORD APIENTRY RasAdminPortClearStatistics(
    IN const WCHAR * lpszServer,
    IN const WCHAR * lpszPort
    );

DWORD APIENTRY RasAdminPortDisconnect(
    IN const WCHAR * lpszServer,
    IN const WCHAR * lpszPort
    );

DWORD APIENTRY RasAdminFreeBuffer(
    PVOID Pointer
    );

BOOL APIENTRY RasAdminAcceptNewConnection (
	IN 		RAS_PORT_1 *		      pRasPort1,
    IN      RAS_PORT_STATISTICS *   pRasStats,
    IN      RAS_PARAMETERS *        pRasParams
	);

VOID APIENTRY RasAdminConnectionHangupNotification (
	IN 		RAS_PORT_1 *		      pRasPort1,
    IN      RAS_PORT_STATISTICS *   pRasStats,
    IN      RAS_PARAMETERS *        pRasParams
	);

DWORD APIENTRY RasAdminGetIpAddressForUser (
	IN 		WCHAR  *		lpszUserName,
	IN 		WCHAR  *		lpszPortName,
	IN OUT 	IPADDR *	   pipAddress,
	OUT		BOOL	 *    bNotifyRelease
	);

VOID APIENTRY RasAdminReleaseIpAddress (
	IN 		WCHAR  *		lpszUserName,
	IN 		WCHAR  *		lpszPortName,
	IN 		IPADDR *	   pipAddress
	);

#endif // (WINVER < 0x502)

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _RASSAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\ratings.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*        Copyright (c) Microsoft Corporation. All rights reserved. **
//*********************************************************************

#ifndef _RATINGS_H_
#define _RATINGS_H_

#include <winerror.h>
#include <shlwapi.h>

STDAPI RatingEnable(HWND hwndParent, LPCSTR pszUsername, BOOL fEnable);
STDAPI RatingCheckUserAccess(LPCSTR pszUsername, LPCSTR pszURL,
                             LPCSTR pszRatingInfo, LPBYTE pData,
                             DWORD cbData, void **ppRatingDetails);
STDAPI RatingAccessDeniedDialog(HWND hDlg, LPCSTR pszUsername, LPCSTR pszContentDescription, void *pRatingDetails);
STDAPI RatingAccessDeniedDialog2(HWND hDlg, LPCSTR pszUsername, void *pRatingDetails);
STDAPI RatingFreeDetails(void *pRatingDetails);
STDAPI RatingObtainCancel(HANDLE hRatingObtainQuery);
STDAPI RatingObtainQuery(LPCSTR pszTargetUrl, DWORD dwUserData, void (*fCallback)(DWORD dwUserData, HRESULT hr, LPCSTR pszRating, void *lpvRatingDetails), HANDLE *phRatingObtainQuery);
STDAPI RatingSetupUI(HWND hDlg, LPCSTR pszUsername);
#ifdef _INC_COMMCTRL
STDAPI RatingAddPropertyPage(PROPSHEETHEADER *ppsh);
#endif

STDAPI RatingEnabledQuery();
STDAPI RatingInit();
STDAPI_(void) RatingTerm();

// A way to check if ratings are installed. We still need to calling
// ratings dll to find out for sure but this allows us to delay load ratings.
_inline BOOL IS_RATINGS_ENABLED()
{
    TCHAR szSup[200];
    DWORD dwType;
    DWORD cbSize = sizeof(szSup);

    return (SHGetValue(HKEY_LOCAL_MACHINE,
                       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Ratings"),
                       TEXT("Key"),
                       &dwType, &szSup, &cbSize) == ERROR_SUCCESS);
}

#define S_RATING_ALLOW		S_OK
#define S_RATING_DENY		S_FALSE
#define S_RATING_FOUND		0x00000002
#define E_RATING_NOT_FOUND	0x80000001

/************************************************************************

IObtainRating interface

This interface is used to obtain the rating (PICS label) for a URL.
It is entirely up to the server to determine how to come up with the
label.  The ObtainRating call may be synchronous.

GetSortOrder returns a ULONG which is used to sort this rating helper
into the list of installed helpers.  The helpers are sorted in ascending
order, so a lower numbered helper will be called before a higher numbered
one.

************************************************************************/

DECLARE_INTERFACE_(IObtainRating, IUnknown)
{
	// *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

	STDMETHOD(ObtainRating) (THIS_ LPCSTR pszTargetUrl, HANDLE hAbortEvent,
							 IMalloc *pAllocator, LPSTR *ppRatingOut) PURE;

	STDMETHOD_(ULONG,GetSortOrder) (THIS) PURE;
};

#define RATING_ORDER_REMOTESITE		0x80000000
#define RATING_ORDER_LOCALLIST		0xC0000000


#endif
// _RATINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\recguids.h ===
// Copyright (C) Microsoft Corporation, 1990-1999
#if _MSC_VER > 1000
#pragma once
#endif

/*
 * recguids.h - OLE reconciliation interface GUID definitions.
 */


/* GUIDs
 ********/

DEFINE_GUID(IID_IReconcileInitiator, 0x99180161L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
DEFINE_GUID(IID_IReconcilableObject, 0x99180162L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
DEFINE_GUID(IID_INotifyReplica,      0x99180163L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
DEFINE_GUID(IID_IBriefcaseInitiator, 0x99180164L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\reason.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:        reason.h
//
//  Contents:    Shutdown reason code values.
//
//  History:     8-00        Created         Hughleat
//
//--------------------------------------------------------------------
#if !defined SENTINEL_Reason
# define SENTINEL_Reason

// Reason flags

// Flags used by the various UIs.
#define SHTDN_REASON_FLAG_COMMENT_REQUIRED          0x01000000
#define SHTDN_REASON_FLAG_DIRTY_PROBLEM_ID_REQUIRED 0x02000000
#define SHTDN_REASON_FLAG_CLEAN_UI                  0x04000000
#define SHTDN_REASON_FLAG_DIRTY_UI                  0x08000000

// Flags that end up in the event log code.
#define SHTDN_REASON_FLAG_USER_DEFINED          0x40000000
#define SHTDN_REASON_FLAG_PLANNED               0x80000000

// Microsoft major reasons.
#define SHTDN_REASON_MAJOR_OTHER                0x00000000
#define SHTDN_REASON_MAJOR_NONE                 0x00000000
#define SHTDN_REASON_MAJOR_HARDWARE             0x00010000
#define SHTDN_REASON_MAJOR_OPERATINGSYSTEM      0x00020000
#define SHTDN_REASON_MAJOR_SOFTWARE             0x00030000
#define SHTDN_REASON_MAJOR_APPLICATION          0x00040000
#define SHTDN_REASON_MAJOR_SYSTEM               0x00050000
#define SHTDN_REASON_MAJOR_POWER                0x00060000
#define SHTDN_REASON_MAJOR_LEGACY_API           0x00070000

// Microsoft minor reasons.
#define SHTDN_REASON_MINOR_OTHER                0x00000000
#define SHTDN_REASON_MINOR_NONE                 0x000000ff
#define SHTDN_REASON_MINOR_MAINTENANCE          0x00000001
#define SHTDN_REASON_MINOR_INSTALLATION         0x00000002
#define SHTDN_REASON_MINOR_UPGRADE              0x00000003
#define SHTDN_REASON_MINOR_RECONFIG             0x00000004
#define SHTDN_REASON_MINOR_HUNG                 0x00000005
#define SHTDN_REASON_MINOR_UNSTABLE             0x00000006
#define SHTDN_REASON_MINOR_DISK                 0x00000007
#define SHTDN_REASON_MINOR_PROCESSOR            0x00000008
#define SHTDN_REASON_MINOR_NETWORKCARD          0x00000009
#define SHTDN_REASON_MINOR_POWER_SUPPLY         0x0000000a
#define SHTDN_REASON_MINOR_CORDUNPLUGGED        0x0000000b
#define SHTDN_REASON_MINOR_ENVIRONMENT          0x0000000c
#define SHTDN_REASON_MINOR_HARDWARE_DRIVER      0x0000000d
#define SHTDN_REASON_MINOR_OTHERDRIVER          0x0000000e
#define SHTDN_REASON_MINOR_BLUESCREEN           0x0000000F
#define SHTDN_REASON_MINOR_SERVICEPACK          0x00000010
#define SHTDN_REASON_MINOR_HOTFIX               0x00000011
#define SHTDN_REASON_MINOR_SECURITYFIX          0x00000012
#define SHTDN_REASON_MINOR_SECURITY             0x00000013
#define SHTDN_REASON_MINOR_NETWORK_CONNECTIVITY 0x00000014
#define SHTDN_REASON_MINOR_WMI                  0x00000015 
#define SHTDN_REASON_MINOR_SERVICEPACK_UNINSTALL 0x00000016
#define SHTDN_REASON_MINOR_HOTFIX_UNINSTALL     0x00000017
#define SHTDN_REASON_MINOR_SECURITYFIX_UNINSTALL 0x00000018
#define SHTDN_REASON_MINOR_MMC                  0x00000019
#define SHTDN_REASON_MINOR_TERMSRV              0x00000020
#define SHTDN_REASON_MINOR_DC_PROMOTION         0x00000021
#define SHTDN_REASON_MINOR_DC_DEMOTION          0x00000022

#define SHTDN_REASON_UNKNOWN                    SHTDN_REASON_MINOR_NONE
#define SHTDN_REASON_LEGACY_API                 (SHTDN_REASON_MAJOR_LEGACY_API | SHTDN_REASON_FLAG_PLANNED)

// This mask cuts out UI flags.
#define SHTDN_REASON_VALID_BIT_MASK             0xc0ffffff

// Convenience flags.
#define PCLEANUI                (SHTDN_REASON_FLAG_PLANNED | SHTDN_REASON_FLAG_CLEAN_UI)
#define UCLEANUI                (SHTDN_REASON_FLAG_CLEAN_UI)
#define PDIRTYUI                (SHTDN_REASON_FLAG_PLANNED | SHTDN_REASON_FLAG_DIRTY_UI)
#define UDIRTYUI                (SHTDN_REASON_FLAG_DIRTY_UI)

/*
 * Maximum character lengths for reason name, description, problem id, and
 * comment respectively.
 */
#define MAX_REASON_NAME_LEN  64
#define MAX_REASON_DESC_LEN  256
#define MAX_REASON_BUGID_LEN 32
#define MAX_REASON_COMMENT_LEN  512
#define SHUTDOWN_TYPE_LEN 32

/*
 *	S.E.T. policy value
 *
 */
#define POLICY_SHOWREASONUI_NEVER				0
#define POLICY_SHOWREASONUI_ALWAYS				1
#define POLICY_SHOWREASONUI_WORKSTATIONONLY		2
#define POLICY_SHOWREASONUI_SERVERONLY			3


/*
 * Snapshot policy values
 */
#define SNAPSHOT_POLICY_NEVER            0
#define SNAPSHOT_POLICY_ALWAYS           1
#define SNAPSHOT_POLICY_UNPLANNED        2

/*
 * Maximue user defined reasons
 */
#define MAX_NUM_REASONS 256

#endif // !defined SENTINEL_Reason
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\rasshost.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rasshost.h

Abstract:

    This header defines the interface between third party security
    DLLs and the RAS server.
    
--*/

#ifndef _RASSHOST_
#define _RASSHOST_

#if _MSC_VER > 1000
#pragma once
#endif

#include <mprapi.h>

typedef DWORD  HPORT;

typedef struct _SECURITY_MESSAGE
{
    DWORD dwMsgId;

    HPORT hPort;

    DWORD dwError;                  // Should be non-zero only if error
                                    // occurred during the security dialog.
                                    // Should contain errors from winerror.h
                                    // or raserror.h
    CHAR  UserName[UNLEN+1];        // Should always contain username if
                                    // dwMsgId is SUCCESS/FAILURE

    CHAR  Domain[DNLEN+1];          // Should always contain domain if
                                    // dwMsgId is SUCCESS/FAILURE

} SECURITY_MESSAGE, *PSECURITY_MESSAGE;


// Values for dwMsgId in SECURITY_MESSAGE structure

#define SECURITYMSG_SUCCESS     1
#define SECURITYMSG_FAILURE     2
#define SECURITYMSG_ERROR       3

// Used by RasSecurityGetInfo call

typedef struct _RAS_SECURITY_INFO
{

    DWORD LastError;                    // SUCCESS = receive completed
                                        // PENDING = receive pending
                                        // else completed with error

    DWORD BytesReceived;                // only valid if LastError == SUCCESS

    CHAR  DeviceName[MAX_DEVICE_NAME+1];


}RAS_SECURITY_INFO,*PRAS_SECURITY_INFO;

typedef DWORD (WINAPI *RASSECURITYPROC)();

//
// Called by third party DLL to notify the supervisor of termination of
// the security dialog
//

VOID WINAPI
RasSecurityDialogComplete(
    IN SECURITY_MESSAGE * pSecMsg       // Pointer to the above info. structure
);

//
// Called by supervisor into the security DLL to notify it to begin the
// security dialog for a client.
//
// Should return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogBegin(
    IN HPORT  hPort,        // RAS handle to port
    IN PBYTE  pSendBuf,     // Pointer to the buffer used in
                            // RasSecurityDialogSend
    IN DWORD  SendBufSize,  // Size of above bufer in bytes
    IN PBYTE  pRecvBuf,     // Pointer to the buffer used in
                            // RasSecurityDialogReceive
    IN DWORD  RecvBufSize,  // Size of above buffer
    IN VOID  (WINAPI *RasSecurityDialogComplete)( SECURITY_MESSAGE* )
                            // Pointer to function RasSecurityDialogComplete.
                            // Guaranteed to be the same on every call.
);

//
// Called by supervisor into the security DLL to notify it to stop the
// security dialog for a client. If this call returns an error, then it is not
// neccesary for the dll to call RasSecurityDialogComplete. Otherwise the DLL
// must call RasSecurityDialogComplete.
//
// Should return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogEnd(
    IN HPORT    hPort           // RAS handle to port.
);

//
// The following entrypoints should be loaded by calling GetProcAddress from
// RasMan.lib
//
// Called to send data to remote host
// Will return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogSend(
    IN HPORT    hPort,          // RAS handle to port.
    IN PBYTE    pBuffer,        // Pointer to buffer containing data to send
    IN WORD     BufferLength    // Length of above buffer.
);

//
// Called to receive data from remote host
// Will return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogReceive(
    IN HPORT    hPort,          // RAS handle to port.
    IN PBYTE    pBuffer,        // Pointer to buffer to receive data
    IN PWORD    pBufferLength,  // length of data received in bytes.
    IN DWORD    Timeout,        // in seconds
    IN HANDLE   hEvent          // Event to set when receive completes or
                                // timeouts
);

//
// Called to get Information about port.
// Will return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogGetInfo(
    IN HPORT                hPort,      // RAS handle to port.
    IN RAS_SECURITY_INFO*   pBuffer     // Pointer to get info structure.
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\reconcil.h ===
/*
 * Copyright (C) Microsoft Corporation, 1990-1999
 * reconcil.h - OLE reconciliation interface definitions.
 */


#ifndef __RECONCIL_H__
#define __RECONCIL_H__

#if _MSC_VER > 1000
#pragma once
#endif

/* Headers
 **********/

#include <recguids.h>


#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Constants
 ************/

/* for use in IStorage::SetStateBits() */

#define STATEBITS_FLAT                 (0x0001)

/* reconciliation SCODEs */

#define REC_S_IDIDTHEUPDATES           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x1000)
#define REC_S_NOTCOMPLETE              MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x1001)
#define REC_S_NOTCOMPLETEBUTPROPAGATE  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x1002)

#define REC_E_ABORTED                  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1000)
#define REC_E_NOCALLBACK               MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1001)
#define REC_E_NORESIDUES               MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1002)
#define REC_E_TOODIFFERENT             MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1003)
#define REC_E_INEEDTODOTHEUPDATES      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1004)


/* Interfaces
 *************/

#undef  INTERFACE
#define INTERFACE INotifyReplica

DECLARE_INTERFACE_(INotifyReplica, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* INotifyReplica methods */

   STDMETHOD(YouAreAReplica)(THIS_
                             ULONG ulcOtherReplicas,
                             IMoniker **rgpmkOtherReplicas) PURE;
};

#undef  INTERFACE
#define INTERFACE IReconcileInitiator

DECLARE_INTERFACE_(IReconcileInitiator, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* IReconcileInitiator methods */

   STDMETHOD(SetAbortCallback)(THIS_
                               IUnknown *punkForAbort) PURE;

   STDMETHOD(SetProgressFeedback)(THIS_
                                  ULONG ulProgress,
                                  ULONG ulProgressMax) PURE;
};

/* IReconcilableObject::Reconcile() flags */

typedef enum _reconcilef
{
   /* interaction with the user is allowed */

   RECONCILEF_MAYBOTHERUSER         = 0x0001,

   /*
    * hwndProgressFeedback may be used to provide reconciliation progress
    * feedback to the user.
    */

   RECONCILEF_FEEDBACKWINDOWVALID   = 0x0002,

   /* residue support not required */

   RECONCILEF_NORESIDUESOK          = 0x0004,

   /* caller not interested in callee's residues */

   RECONCILEF_OMITSELFRESIDUE       = 0x0008,

   /*
    * Reconcile() call resuming after a previous Reconcile() call returned
    * REC_E_NOTCOMPLETE
    */

   RECONCILEF_RESUMERECONCILIATION  = 0x0010,

   /* Object may perform all updates. */

   RECONCILEF_YOUMAYDOTHEUPDATES    = 0x0020,

   /* Only this object has been changed. */

   RECONCILEF_ONLYYOUWERECHANGED    = 0x0040,

   /* flag combinations */

   ALL_RECONCILE_FLAGS              = (RECONCILEF_MAYBOTHERUSER |
                                       RECONCILEF_FEEDBACKWINDOWVALID |
                                       RECONCILEF_NORESIDUESOK |
                                       RECONCILEF_OMITSELFRESIDUE |
                                       RECONCILEF_RESUMERECONCILIATION |
                                       RECONCILEF_YOUMAYDOTHEUPDATES |
                                       RECONCILEF_ONLYYOUWERECHANGED)
}
RECONCILEF;

#undef  INTERFACE
#define INTERFACE IReconcilableObject

DECLARE_INTERFACE_(IReconcilableObject, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* IReconcilableObject methods */

   STDMETHOD(Reconcile)(THIS_
                        IReconcileInitiator *pInitiator,
                        DWORD dwFlags,
                        HWND hwndOwner,
                        HWND hwndProgressFeedback,
                        ULONG ulcInput,
                        IMoniker **rgpmkOtherInput,
                        PLONG plOutIndex,
                        IStorage *pstgNewResidues,
                        PVOID pvReserved) PURE;

   STDMETHOD(GetProgressFeedbackMaxEstimate)(THIS_
                                             PULONG pulProgressMax) PURE;
};

#undef  INTERFACE
#define INTERFACE IBriefcaseInitiator

DECLARE_INTERFACE_(IBriefcaseInitiator, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* IBriefcaseInitiator methods */

   STDMETHOD(IsMonikerInBriefcase)(THIS_
                                   IMoniker *pmk) PURE;
};


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */


#endif   /* ! __RECONCIL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\recalc.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for recalc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __recalc_h__
#define __recalc_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IRecalcEngine_FWD_DEFINED__
#define __IRecalcEngine_FWD_DEFINED__
typedef interface IRecalcEngine IRecalcEngine;
#endif 	/* __IRecalcEngine_FWD_DEFINED__ */


#ifndef __IRecalcHost_FWD_DEFINED__
#define __IRecalcHost_FWD_DEFINED__
typedef interface IRecalcHost IRecalcHost;
#endif 	/* __IRecalcHost_FWD_DEFINED__ */


#ifndef __IRecalcProperty_FWD_DEFINED__
#define __IRecalcProperty_FWD_DEFINED__
typedef interface IRecalcProperty IRecalcProperty;
#endif 	/* __IRecalcProperty_FWD_DEFINED__ */


#ifndef __IRecalcHostDebug_FWD_DEFINED__
#define __IRecalcHostDebug_FWD_DEFINED__
typedef interface IRecalcHostDebug IRecalcHostDebug;
#endif 	/* __IRecalcHostDebug_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "oleidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_recalc_0000 */
/* [local] */ 

#define SID_SRecalcEngine IID_IRecalcEngine




extern RPC_IF_HANDLE __MIDL_itf_recalc_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_recalc_0000_v0_0_s_ifspec;

#ifndef __IRecalcEngine_INTERFACE_DEFINED__
#define __IRecalcEngine_INTERFACE_DEFINED__

/* interface IRecalcEngine */
/* [version][local][unique][uuid][object] */ 


EXTERN_C const IID IID_IRecalcEngine;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f496-98b5-11cf-bb82-00aa00bdce0b")
    IRecalcEngine : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RecalcAll( 
            /* [in] */ BOOL fForce) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnNameSpaceChange( 
            /* [in] */ IUnknown *pUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExpression( 
            /* [in] */ IUnknown *pUnk,
            /* [in] */ DISPID dispid,
            /* [in] */ LPOLESTR strExpression,
            LPOLESTR language) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExpression( 
            /* [in] */ IUnknown *pUnk,
            /* [in] */ DISPID dispid,
            /* [out] */ BSTR *pstrExpression,
            /* [out] */ BSTR *pstrLanguage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearExpression( 
            /* [in] */ IUnknown *pUnk,
            /* [in] */ DISPID dispid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginStyle( 
            /* [in] */ IUnknown *pObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndStyle( 
            /* [in] */ IUnknown *pObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRecalcEngineVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRecalcEngine * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRecalcEngine * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRecalcEngine * This);
        
        HRESULT ( STDMETHODCALLTYPE *RecalcAll )( 
            IRecalcEngine * This,
            /* [in] */ BOOL fForce);
        
        HRESULT ( STDMETHODCALLTYPE *OnNameSpaceChange )( 
            IRecalcEngine * This,
            /* [in] */ IUnknown *pUnk);
        
        HRESULT ( STDMETHODCALLTYPE *SetExpression )( 
            IRecalcEngine * This,
            /* [in] */ IUnknown *pUnk,
            /* [in] */ DISPID dispid,
            /* [in] */ LPOLESTR strExpression,
            LPOLESTR language);
        
        HRESULT ( STDMETHODCALLTYPE *GetExpression )( 
            IRecalcEngine * This,
            /* [in] */ IUnknown *pUnk,
            /* [in] */ DISPID dispid,
            /* [out] */ BSTR *pstrExpression,
            /* [out] */ BSTR *pstrLanguage);
        
        HRESULT ( STDMETHODCALLTYPE *ClearExpression )( 
            IRecalcEngine * This,
            /* [in] */ IUnknown *pUnk,
            /* [in] */ DISPID dispid);
        
        HRESULT ( STDMETHODCALLTYPE *BeginStyle )( 
            IRecalcEngine * This,
            /* [in] */ IUnknown *pObject);
        
        HRESULT ( STDMETHODCALLTYPE *EndStyle )( 
            IRecalcEngine * This,
            /* [in] */ IUnknown *pObject);
        
        END_INTERFACE
    } IRecalcEngineVtbl;

    interface IRecalcEngine
    {
        CONST_VTBL struct IRecalcEngineVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRecalcEngine_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRecalcEngine_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRecalcEngine_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRecalcEngine_RecalcAll(This,fForce)	\
    (This)->lpVtbl -> RecalcAll(This,fForce)

#define IRecalcEngine_OnNameSpaceChange(This,pUnk)	\
    (This)->lpVtbl -> OnNameSpaceChange(This,pUnk)

#define IRecalcEngine_SetExpression(This,pUnk,dispid,strExpression,language)	\
    (This)->lpVtbl -> SetExpression(This,pUnk,dispid,strExpression,language)

#define IRecalcEngine_GetExpression(This,pUnk,dispid,pstrExpression,pstrLanguage)	\
    (This)->lpVtbl -> GetExpression(This,pUnk,dispid,pstrExpression,pstrLanguage)

#define IRecalcEngine_ClearExpression(This,pUnk,dispid)	\
    (This)->lpVtbl -> ClearExpression(This,pUnk,dispid)

#define IRecalcEngine_BeginStyle(This,pObject)	\
    (This)->lpVtbl -> BeginStyle(This,pObject)

#define IRecalcEngine_EndStyle(This,pObject)	\
    (This)->lpVtbl -> EndStyle(This,pObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRecalcEngine_RecalcAll_Proxy( 
    IRecalcEngine * This,
    /* [in] */ BOOL fForce);


void __RPC_STUB IRecalcEngine_RecalcAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecalcEngine_OnNameSpaceChange_Proxy( 
    IRecalcEngine * This,
    /* [in] */ IUnknown *pUnk);


void __RPC_STUB IRecalcEngine_OnNameSpaceChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecalcEngine_SetExpression_Proxy( 
    IRecalcEngine * This,
    /* [in] */ IUnknown *pUnk,
    /* [in] */ DISPID dispid,
    /* [in] */ LPOLESTR strExpression,
    LPOLESTR language);


void __RPC_STUB IRecalcEngine_SetExpression_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecalcEngine_GetExpression_Proxy( 
    IRecalcEngine * This,
    /* [in] */ IUnknown *pUnk,
    /* [in] */ DISPID dispid,
    /* [out] */ BSTR *pstrExpression,
    /* [out] */ BSTR *pstrLanguage);


void __RPC_STUB IRecalcEngine_GetExpression_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecalcEngine_ClearExpression_Proxy( 
    IRecalcEngine * This,
    /* [in] */ IUnknown *pUnk,
    /* [in] */ DISPID dispid);


void __RPC_STUB IRecalcEngine_ClearExpression_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecalcEngine_BeginStyle_Proxy( 
    IRecalcEngine * This,
    /* [in] */ IUnknown *pObject);


void __RPC_STUB IRecalcEngine_BeginStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecalcEngine_EndStyle_Proxy( 
    IRecalcEngine * This,
    /* [in] */ IUnknown *pObject);


void __RPC_STUB IRecalcEngine_EndStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRecalcEngine_INTERFACE_DEFINED__ */


#ifndef __IRecalcHost_INTERFACE_DEFINED__
#define __IRecalcHost_INTERFACE_DEFINED__

/* interface IRecalcHost */
/* [version][local][unique][uuid][object] */ 


EXTERN_C const IID IID_IRecalcHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f497-98b5-11cf-bb82-00aa00bdce0b")
    IRecalcHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CompileExpression( 
            /* [in] */ IUnknown *pUnk,
            /* [in] */ DISPID dispid,
            /* [in] */ LPOLESTR strExpression,
            /* [in] */ LPOLESTR strLanguage,
            /* [out] */ IDispatch **ppExpressionObject,
            /* [out] */ IDispatch **ppThis) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EvalExpression( 
            /* [in] */ IUnknown *pUnk,
            /* [in] */ DISPID dispid,
            /* [in] */ LPOLESTR strExpression,
            /* [in] */ LPOLESTR strLanguage,
            /* [out] */ VARIANT *pvResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResolveNames( 
            /* [in] */ IUnknown *pUnk,
            /* [in] */ DISPID dispid,
            /* [in] */ unsigned int cNames,
            /* [in] */ BSTR *pstrNames,
            /* [out] */ IDispatch **ppObjects,
            /* [out] */ DISPID *pDispids) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestRecalc( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ IUnknown *pUnk,
            /* [in] */ DISPID dispid,
            /* [in] */ VARIANT *pv,
            /* [in] */ BOOL fStyle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveValue( 
            /* [in] */ IUnknown *pUnk,
            /* [in] */ DISPID dispid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptTextAttributes( 
            /* [in] */ LPCOLESTR szLanguage,
            /* [in] */ LPCOLESTR pchCode,
            /* [in] */ ULONG cchCode,
            /* [in] */ LPCOLESTR szDelim,
            /* [in] */ DWORD dwFlags,
            /* [out] */ WORD *pwAttr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRecalcHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRecalcHost * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRecalcHost * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRecalcHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *CompileExpression )( 
            IRecalcHost * This,
            /* [in] */ IUnknown *pUnk,
            /* [in] */ DISPID dispid,
            /* [in] */ LPOLESTR strExpression,
            /* [in] */ LPOLESTR strLanguage,
            /* [out] */ IDispatch **ppExpressionObject,
            /* [out] */ IDispatch **ppThis);
        
        HRESULT ( STDMETHODCALLTYPE *EvalExpression )( 
            IRecalcHost * This,
            /* [in] */ IUnknown *pUnk,
            /* [in] */ DISPID dispid,
            /* [in] */ LPOLESTR strExpression,
            /* [in] */ LPOLESTR strLanguage,
            /* [out] */ VARIANT *pvResult);
        
        HRESULT ( STDMETHODCALLTYPE *ResolveNames )( 
            IRecalcHost * This,
            /* [in] */ IUnknown *pUnk,
            /* [in] */ DISPID dispid,
            /* [in] */ unsigned int cNames,
            /* [in] */ BSTR *pstrNames,
            /* [out] */ IDispatch **ppObjects,
            /* [out] */ DISPID *pDispids);
        
        HRESULT ( STDMETHODCALLTYPE *RequestRecalc )( 
            IRecalcHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            IRecalcHost * This,
            /* [in] */ IUnknown *pUnk,
            /* [in] */ DISPID dispid,
            /* [in] */ VARIANT *pv,
            /* [in] */ BOOL fStyle);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveValue )( 
            IRecalcHost * This,
            /* [in] */ IUnknown *pUnk,
            /* [in] */ DISPID dispid);
        
        HRESULT ( STDMETHODCALLTYPE *GetScriptTextAttributes )( 
            IRecalcHost * This,
            /* [in] */ LPCOLESTR szLanguage,
            /* [in] */ LPCOLESTR pchCode,
            /* [in] */ ULONG cchCode,
            /* [in] */ LPCOLESTR szDelim,
            /* [in] */ DWORD dwFlags,
            /* [out] */ WORD *pwAttr);
        
        END_INTERFACE
    } IRecalcHostVtbl;

    interface IRecalcHost
    {
        CONST_VTBL struct IRecalcHostVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRecalcHost_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRecalcHost_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRecalcHost_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRecalcHost_CompileExpression(This,pUnk,dispid,strExpression,strLanguage,ppExpressionObject,ppThis)	\
    (This)->lpVtbl -> CompileExpression(This,pUnk,dispid,strExpression,strLanguage,ppExpressionObject,ppThis)

#define IRecalcHost_EvalExpression(This,pUnk,dispid,strExpression,strLanguage,pvResult)	\
    (This)->lpVtbl -> EvalExpression(This,pUnk,dispid,strExpression,strLanguage,pvResult)

#define IRecalcHost_ResolveNames(This,pUnk,dispid,cNames,pstrNames,ppObjects,pDispids)	\
    (This)->lpVtbl -> ResolveNames(This,pUnk,dispid,cNames,pstrNames,ppObjects,pDispids)

#define IRecalcHost_RequestRecalc(This)	\
    (This)->lpVtbl -> RequestRecalc(This)

#define IRecalcHost_SetValue(This,pUnk,dispid,pv,fStyle)	\
    (This)->lpVtbl -> SetValue(This,pUnk,dispid,pv,fStyle)

#define IRecalcHost_RemoveValue(This,pUnk,dispid)	\
    (This)->lpVtbl -> RemoveValue(This,pUnk,dispid)

#define IRecalcHost_GetScriptTextAttributes(This,szLanguage,pchCode,cchCode,szDelim,dwFlags,pwAttr)	\
    (This)->lpVtbl -> GetScriptTextAttributes(This,szLanguage,pchCode,cchCode,szDelim,dwFlags,pwAttr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRecalcHost_CompileExpression_Proxy( 
    IRecalcHost * This,
    /* [in] */ IUnknown *pUnk,
    /* [in] */ DISPID dispid,
    /* [in] */ LPOLESTR strExpression,
    /* [in] */ LPOLESTR strLanguage,
    /* [out] */ IDispatch **ppExpressionObject,
    /* [out] */ IDispatch **ppThis);


void __RPC_STUB IRecalcHost_CompileExpression_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecalcHost_EvalExpression_Proxy( 
    IRecalcHost * This,
    /* [in] */ IUnknown *pUnk,
    /* [in] */ DISPID dispid,
    /* [in] */ LPOLESTR strExpression,
    /* [in] */ LPOLESTR strLanguage,
    /* [out] */ VARIANT *pvResult);


void __RPC_STUB IRecalcHost_EvalExpression_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecalcHost_ResolveNames_Proxy( 
    IRecalcHost * This,
    /* [in] */ IUnknown *pUnk,
    /* [in] */ DISPID dispid,
    /* [in] */ unsigned int cNames,
    /* [in] */ BSTR *pstrNames,
    /* [out] */ IDispatch **ppObjects,
    /* [out] */ DISPID *pDispids);


void __RPC_STUB IRecalcHost_ResolveNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecalcHost_RequestRecalc_Proxy( 
    IRecalcHost * This);


void __RPC_STUB IRecalcHost_RequestRecalc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecalcHost_SetValue_Proxy( 
    IRecalcHost * This,
    /* [in] */ IUnknown *pUnk,
    /* [in] */ DISPID dispid,
    /* [in] */ VARIANT *pv,
    /* [in] */ BOOL fStyle);


void __RPC_STUB IRecalcHost_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecalcHost_RemoveValue_Proxy( 
    IRecalcHost * This,
    /* [in] */ IUnknown *pUnk,
    /* [in] */ DISPID dispid);


void __RPC_STUB IRecalcHost_RemoveValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecalcHost_GetScriptTextAttributes_Proxy( 
    IRecalcHost * This,
    /* [in] */ LPCOLESTR szLanguage,
    /* [in] */ LPCOLESTR pchCode,
    /* [in] */ ULONG cchCode,
    /* [in] */ LPCOLESTR szDelim,
    /* [in] */ DWORD dwFlags,
    /* [out] */ WORD *pwAttr);


void __RPC_STUB IRecalcHost_GetScriptTextAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRecalcHost_INTERFACE_DEFINED__ */


#ifndef __IRecalcProperty_INTERFACE_DEFINED__
#define __IRecalcProperty_INTERFACE_DEFINED__

/* interface IRecalcProperty */
/* [version][local][unique][uuid][object] */ 


EXTERN_C const IID IID_IRecalcProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f5d6-98b5-11cf-bb82-00aa00bdce0b")
    IRecalcProperty : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCanonicalProperty( 
            DISPID dispid,
            IUnknown **ppUnk,
            DISPID *pdispid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRecalcPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRecalcProperty * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRecalcProperty * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRecalcProperty * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCanonicalProperty )( 
            IRecalcProperty * This,
            DISPID dispid,
            IUnknown **ppUnk,
            DISPID *pdispid);
        
        END_INTERFACE
    } IRecalcPropertyVtbl;

    interface IRecalcProperty
    {
        CONST_VTBL struct IRecalcPropertyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRecalcProperty_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRecalcProperty_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRecalcProperty_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRecalcProperty_GetCanonicalProperty(This,dispid,ppUnk,pdispid)	\
    (This)->lpVtbl -> GetCanonicalProperty(This,dispid,ppUnk,pdispid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRecalcProperty_GetCanonicalProperty_Proxy( 
    IRecalcProperty * This,
    DISPID dispid,
    IUnknown **ppUnk,
    DISPID *pdispid);


void __RPC_STUB IRecalcProperty_GetCanonicalProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRecalcProperty_INTERFACE_DEFINED__ */


#ifndef __IRecalcHostDebug_INTERFACE_DEFINED__
#define __IRecalcHostDebug_INTERFACE_DEFINED__

/* interface IRecalcHostDebug */
/* [version][local][unique][uuid][object] */ 


EXTERN_C const IID IID_IRecalcHostDebug;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f5f7-98b5-11cf-bb82-00aa00bdce0b")
    IRecalcHostDebug : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetObjectInfo( 
            /* [in] */ IUnknown *pUnk,
            /* [in] */ DISPID dispid,
            /* [out] */ BSTR *pbstrID,
            /* [out] */ BSTR *pbstrMember,
            /* [out] */ BSTR *pbstrTag) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRecalcHostDebugVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRecalcHostDebug * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRecalcHostDebug * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRecalcHostDebug * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectInfo )( 
            IRecalcHostDebug * This,
            /* [in] */ IUnknown *pUnk,
            /* [in] */ DISPID dispid,
            /* [out] */ BSTR *pbstrID,
            /* [out] */ BSTR *pbstrMember,
            /* [out] */ BSTR *pbstrTag);
        
        END_INTERFACE
    } IRecalcHostDebugVtbl;

    interface IRecalcHostDebug
    {
        CONST_VTBL struct IRecalcHostDebugVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRecalcHostDebug_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRecalcHostDebug_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRecalcHostDebug_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRecalcHostDebug_GetObjectInfo(This,pUnk,dispid,pbstrID,pbstrMember,pbstrTag)	\
    (This)->lpVtbl -> GetObjectInfo(This,pUnk,dispid,pbstrID,pbstrMember,pbstrTag)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRecalcHostDebug_GetObjectInfo_Proxy( 
    IRecalcHostDebug * This,
    /* [in] */ IUnknown *pUnk,
    /* [in] */ DISPID dispid,
    /* [out] */ BSTR *pbstrID,
    /* [out] */ BSTR *pbstrMember,
    /* [out] */ BSTR *pbstrTag);


void __RPC_STUB IRecalcHostDebug_GetObjectInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRecalcHostDebug_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\refptrco.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  RefPtrCo.h
//
//  Purpose: definition of TRefPointerCollection template
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __REFPTRCOLLECTION_H__
#define __REFPTRCOLLECTION_H__

#include <chptrarr.h>

// Enumeration helpers
typedef	DWORD	REFPTRCOLLECTION_POSITION;
#define	REFPTRCOLLECTION_START	0xFFFFFFFF;

template <class TYPED_PTR> class TRefPointerCollection : public CThreadBase
{
public:

	// Construction/Destruction
	TRefPointerCollection();
	~TRefPointerCollection();
    TRefPointerCollection(const TRefPointerCollection& trpc);

	// Allows addition and enumeration of collection
	BOOL	Add( TYPED_PTR* ptr );

	BOOL		BeginEnum( REFPTRCOLLECTION_POSITION& pos );
	TYPED_PTR*	GetNext( REFPTRCOLLECTION_POSITION& pos );
	void		EndEnum( void );

	void		Empty( void );
    int         GetSize( void ) const;

protected:

	// Allows easy and quick transference of data (it was =, but
	// because we'll inherit classes off the template, we won't
	// inherit that particular overload (some C++ thingie)

	const TRefPointerCollection<TYPED_PTR>& Copy( const TRefPointerCollection<TYPED_PTR>& );


private:

	CHPtrArray		m_ptrArray;

};

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::TRefPointerCollection
//
//	Class Constructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
TRefPointerCollection<TYPED_PTR>::TRefPointerCollection( void )
:	CThreadBase(),
	m_ptrArray()
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CRefPointerCollection::~CRefPointerCollection
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
TRefPointerCollection<TYPED_PTR>::~TRefPointerCollection( void )
{
	Empty();
}


////////////////////////////////////////////////////////////////////////
//
//	Function:	CRefPointerCollection::CRefPointerCollection
//              Copy constructor
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////
template <class TYPED_PTR>
TRefPointerCollection<TYPED_PTR>::TRefPointerCollection(
    const TRefPointerCollection& trpc)
{
    Copy(trpc);	
}


////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::Add
//
//	Adds a new referenced pointer to the collection.
//
//	Inputs:		T*				ptr - Pointer to add.
//
//	Outputs:	None.
//
//	Return:		TRUE/FALSE		Success/Failure of Add.
//
//	Comments:	AddRefs the pointer, then adds it to the array.  We
//				will need Write Access to do this.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
BOOL TRefPointerCollection<TYPED_PTR>::Add( TYPED_PTR* ptr )
{
	BOOL	fReturn = FALSE;

	if ( NULL != ptr )
	{
		// Get write access
		if ( BeginWrite() )
		{
            try
            {
			    // If Add succeeds, the pointer will be released when it
			    // is removed.

			    ptr->AddRef();

			    if ( m_ptrArray.Add( (void*) ptr ) >= 0 )
			    {
				    fReturn = TRUE;
			    }
			    else
			    {
				    ptr->Release();	// Add failed, so Release the AddRef
			    }
            }
            catch ( ... )
            {
    	        EndWrite() ;
                throw;
            }

			EndWrite();	// Release the BeginWrite()
		}
	}

	return fReturn;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::BeginEnum
//
//	Gains Read Access to the collection, then returns an appropriate
//	REFPTRCOLLECTION_POSITION to get the first index in the array.
//
//	Inputs:		None.
//
//	Outputs:	REFPTRCOLLECTION_POSITION&	pos - Position we retrieved.
//
//	Return:		BOOL		TRUE/FALSE - Access was granted
//
//	Comments:	We need Read Access to do this.  This can effectively
//				lock out other threads.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
BOOL TRefPointerCollection<TYPED_PTR>::BeginEnum( REFPTRCOLLECTION_POSITION& pos )
{
	BOOL	fReturn	=	FALSE;

	if ( BeginRead() )
	{
		pos = REFPTRCOLLECTION_START;
		fReturn = TRUE;
	}

	return fReturn;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::EndEnum
//
//	Signals the end of an enumeration.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		BOOL		TRUE/FALSE - Access was granted
//
//	Comments:	Ends Read Access granted by calling BeginEnum().
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
void TRefPointerCollection<TYPED_PTR>::EndEnum( void )
{
	EndRead();
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::GetNext
//
//	Uses the REFPTRCOLLECTION_POSITION to get the next index in the
//	collection.
//
//	Inputs:		None.
//
//	Outputs:	REFPTRCOLLECTION_POSITION&	pos - Position we retrieved.
//
//	Return:		T*		NULL if failure.
//
//	Comments:	We need Read Access to do this.  The pointer is AddRef'd
//				on the way out.  User must Release the pointer himself.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
TYPED_PTR* TRefPointerCollection<TYPED_PTR>::GetNext( REFPTRCOLLECTION_POSITION& pos )
{
	TYPED_PTR*	ptr = NULL;

	if ( BeginRead() )
	{
		if ( ++pos < (DWORD) m_ptrArray.GetSize() )
		{
			ptr = (TYPED_PTR*) m_ptrArray.GetAt( pos );

			if ( NULL != ptr )
			{
				ptr->AddRef();
			}
		}

		EndRead();
	}

	return ptr;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::Empty
//
//	Empties out the collection, Releasing Pointers as it does do.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	We need Write Access to do this.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
void TRefPointerCollection<TYPED_PTR>::Empty( void )
{
	// By default this is an infinite wait, so it best come back

	BeginWrite();

    try
    {

	    int	nSize	=	m_ptrArray.GetSize();

	    // Only empty it if it is not empty
	    if ( nSize > 0 )
	    {
		    TYPED_PTR*	ptr		=	NULL;

		    for ( int nCtr = 0; nCtr < nSize; nCtr++ )
		    {
			    ptr = (TYPED_PTR*) m_ptrArray[nCtr];

			    if ( NULL != ptr )
			    {
				    ptr->Release();	// AddRef we did when we added it
			    }
		    }

		    // Now dump the array
		    m_ptrArray.RemoveAll();

	    }	// IF nSize > 0

    }
    catch ( ... )
    {
    	EndWrite() ;
        throw;
    }

	EndWrite();
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::Copy
//
//	Empties out the collection, copies in another one, addrefing
//	pointers as we go.
//
//	Inputs:		const T&	collection
//
//	Outputs:	None.
//
//	Return:		const T&	this
//
//	Comments:	We need Write Access to do this.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
const TRefPointerCollection<TYPED_PTR>& TRefPointerCollection<TYPED_PTR>::Copy( const TRefPointerCollection<TYPED_PTR>& collection )
{
	// By default this is an infinite wait, so it best come back
	BeginWrite();

    try
    {

	    // Dump out the array
	    Empty();

	    int	nSize = collection.m_ptrArray.GetSize();

	    for ( int nCount = 0; nCount < nSize; nCount++ )
	    {
		    TYPED_PTR*	ptr = (TYPED_PTR*) collection.m_ptrArray[nCount];

		    // Add will automatically AddRef the pointer again.
		    Add( ptr );
	    }
    }
    catch ( ... )
    {
    	EndWrite() ;
        throw;
    }

	EndWrite();

	return *this;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::GetSize
//
//	Inputs:		None.
//
//	Outputs:	Number of elements in the collection
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
int TRefPointerCollection<TYPED_PTR>::GetSize(void) const
{
    return m_ptrArray.GetSize();
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\regbag.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for regbag.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __regbag_h__
#define __regbag_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICreatePropBagOnRegKey_FWD_DEFINED__
#define __ICreatePropBagOnRegKey_FWD_DEFINED__
typedef interface ICreatePropBagOnRegKey ICreatePropBagOnRegKey;
#endif 	/* __ICreatePropBagOnRegKey_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_regbag_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999-2000.
//
//--------------------------------------------------------------------------
#pragma once


extern RPC_IF_HANDLE __MIDL_itf_regbag_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_regbag_0000_v0_0_s_ifspec;

#ifndef __ICreatePropBagOnRegKey_INTERFACE_DEFINED__
#define __ICreatePropBagOnRegKey_INTERFACE_DEFINED__

/* interface ICreatePropBagOnRegKey */
/* [local][unique][helpstring][uuid][restricted][hidden][object] */ 


EXTERN_C const IID IID_ICreatePropBagOnRegKey;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8A674B48-1F63-11d3-B64C-00C04F79498E")
    ICreatePropBagOnRegKey : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ HKEY hkey,
            /* [in] */ LPCOLESTR subkey,
            /* [in] */ DWORD ulOptions,
            /* [in] */ DWORD samDesired,
            REFIID iid,
            /* [out] */ LPVOID *ppBag) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICreatePropBagOnRegKeyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICreatePropBagOnRegKey * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICreatePropBagOnRegKey * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICreatePropBagOnRegKey * This);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            ICreatePropBagOnRegKey * This,
            /* [in] */ HKEY hkey,
            /* [in] */ LPCOLESTR subkey,
            /* [in] */ DWORD ulOptions,
            /* [in] */ DWORD samDesired,
            REFIID iid,
            /* [out] */ LPVOID *ppBag);
        
        END_INTERFACE
    } ICreatePropBagOnRegKeyVtbl;

    interface ICreatePropBagOnRegKey
    {
        CONST_VTBL struct ICreatePropBagOnRegKeyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICreatePropBagOnRegKey_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICreatePropBagOnRegKey_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICreatePropBagOnRegKey_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICreatePropBagOnRegKey_Create(This,hkey,subkey,ulOptions,samDesired,iid,ppBag)	\
    (This)->lpVtbl -> Create(This,hkey,subkey,ulOptions,samDesired,iid,ppBag)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICreatePropBagOnRegKey_Create_Proxy( 
    ICreatePropBagOnRegKey * This,
    /* [in] */ HKEY hkey,
    /* [in] */ LPCOLESTR subkey,
    /* [in] */ DWORD ulOptions,
    /* [in] */ DWORD samDesired,
    REFIID iid,
    /* [out] */ LPVOID *ppBag);


void __RPC_STUB ICreatePropBagOnRegKey_Create_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICreatePropBagOnRegKey_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\regapix.h ===
//
//  REGAPIX.H
//
//  Copyright (C) Microsoft Corporation, 1995-1999
//
//  Public definitions for the VMM registry library (all modes).
//

#ifndef _REGAPIX_
#define _REGAPIX_

#if _MSC_VER > 1000
#pragma once
#endif

/*XLATOFF*/
#ifdef __cplusplus
extern "C" {
#endif
/*XLATON*/

/*XLATOFF*/
#if defined(_INC_WINDOWS) && !defined(VXD) && !defined(REALMODE)
#define REGAPI                      WINAPI
#else
#if defined(IS_32)
#ifndef FAR
#define FAR
#endif
#define REGAPI                      __cdecl
#else
#ifndef FAR
#define FAR                         _far
#endif
#define REGAPI                      _far _cdecl
#endif // defined(IS_32)
#endif // defined(_INC_WINDOWS) && !defined(VXD) && !defined(REALMODE)
/*XLATON*/

#ifndef _REGPRIV_
#ifndef _INC_WINDOWS
typedef DWORD HKEY;
#endif
#endif
typedef HKEY FAR* LPHKEY;

//
//  Predefined key handles.
//

#ifndef HKEY_LOCAL_MACHINE
#define HKEY_CLASSES_ROOT           ((HKEY) 0x80000000)
#define HKEY_CURRENT_USER           ((HKEY) 0x80000001)
#define HKEY_LOCAL_MACHINE          ((HKEY) 0x80000002)
#define HKEY_USERS                  ((HKEY) 0x80000003)
#define HKEY_PERFORMANCE_DATA       ((HKEY) 0x80000004)
#define HKEY_CURRENT_CONFIG         ((HKEY) 0x80000005)
#define HKEY_DYN_DATA               ((HKEY) 0x80000006)
#define HKEY_PREDEF_KEYS            7
#endif

//
//  Maximum size of registry data elements.
//

#define MAXIMUM_SUB_KEY_LENGTH      256
#define MAXIMUM_VALUE_NAME_LENGTH   256
#define MAXIMUM_DATA_LENGTH         16384

//
//  Standard data types.
//

#ifndef REG_SZ
#define REG_SZ                      1
#endif

#ifndef REG_BINARY
#define REG_BINARY                  3
#endif

#ifndef REG_DWORD
#define REG_DWORD                   4
#endif

//
//  Registry error codes.
//

#ifndef ERROR_SUCCESS
#define ERROR_SUCCESS               0
#endif

#ifndef ERROR_INVALID_FUNCTION
#define ERROR_INVALID_FUNCTION      1
#endif

#ifndef ERROR_FILE_NOT_FOUND
#define ERROR_FILE_NOT_FOUND        2
#endif

#ifndef ERROR_ACCESS_DENIED
#define ERROR_ACCESS_DENIED         5
#endif

#ifndef ERROR_OUTOFMEMORY
#define ERROR_OUTOFMEMORY           14
#endif

#ifndef ERROR_INVALID_PARAMETER
#define ERROR_INVALID_PARAMETER     87
#endif

#ifndef ERROR_LOCK_FAILED
#define ERROR_LOCK_FAILED           167
#endif

#ifndef ERROR_MORE_DATA
#define ERROR_MORE_DATA             234
#endif

#ifndef ERROR_NO_MORE_ITEMS
#define ERROR_NO_MORE_ITEMS         259
#endif

#ifndef ERROR_BADDB
#define ERROR_BADDB                 1009
#endif

#ifndef ERROR_BADKEY
#define ERROR_BADKEY                1010
#endif

#ifndef ERROR_CANTOPEN
#define ERROR_CANTOPEN              1011
#endif

#ifndef ERROR_CANTREAD
#define ERROR_CANTREAD              1012
#endif

#ifndef ERROR_CANTWRITE
#define ERROR_CANTWRITE             1013
#endif

#ifndef ERROR_REGISTRY_IO_FAILED
#define ERROR_REGISTRY_IO_FAILED    1016
#endif

#ifndef ERROR_KEY_DELETED
#define ERROR_KEY_DELETED           1018
#endif

//  Internal registry error codes.  Not exposed to most clients.
#if defined(VXD)
#define ERROR_CANTOPEN16_FILENOTFOUND32 ((ERROR_CANTOPEN << 16) | ERROR_FILE_NOT_FOUND)
#define ERROR_CANTREAD16_FILENOTFOUND32 ((ERROR_CANTREAD << 16) | ERROR_FILE_NOT_FOUND)
#else
#if defined(WIN32)
#define ERROR_CANTOPEN16_FILENOTFOUND32 ERROR_FILE_NOT_FOUND
#define ERROR_CANTREAD16_FILENOTFOUND32 ERROR_FILE_NOT_FOUND
#else
#define ERROR_CANTOPEN16_FILENOTFOUND32 ERROR_CANTOPEN
#define ERROR_CANTREAD16_FILENOTFOUND32 ERROR_CANTREAD
#endif
#endif

//
//  Registry application interfaces.
//

/*XLATOFF*/

LONG
REGAPI
VMMRegLibAttach(
    UINT Flags
    );

VOID
REGAPI
VMMRegLibDetach(
    VOID
    );

/*XLATON*/
#define GRFT_SYSTEM                 0       //  SYSTEM.DAT
#define GRFT_USER                   1       //  USER.DAT
/*XLATOFF*/

BOOL
REGAPI
VMMRegGetRegistryFile(
    char FAR* lpBuffer,
    UINT BufferSize,
    UINT FileType
    );

//  Creates a new registry file.  Fails if the specified file already exists.
#define MPKF_CREATENEW              0x0001

//  If MPKF_VERSION20 is specified, create the file using compact keynodes.
//  Such a file will only be readable by users of this library, not Win95
//  clients.  Use only for system registries (SYSTEM.DAT, USER.DAT).
#define MPKF_VERSION20              0x0002

LONG
REGAPI
VMMRegMapPredefKeyToFile(
    HKEY hKey,
    const char FAR* lpFileName,
    UINT Flags
    );

LONG
REGAPI
VMMRegMapPredefKeyToKey(
    HKEY hSourceKey,
    HKEY hPredefKey
    );

LONG
REGAPI
VMMRegCreateKey(
    HKEY hKey,
    const char FAR* lpSubKey,
    LPHKEY lphSubKey
    );

LONG
REGAPI
VMMRegOpenKey(
    HKEY hKey,
    const char FAR* lpSubKey,
    LPHKEY lphSubKey
    );

LONG
REGAPI
VMMRegCloseKey(
    HKEY hKey
    );

LONG
REGAPI
VMMRegFlushKey(
    HKEY hKey
    );

LONG
REGAPI
VMMRegQueryValue(
    HKEY hKey,
    const char FAR* lpSubKey,
    BYTE FAR* lpData,
    DWORD FAR* lpcbData
    );

LONG
REGAPI
VMMRegQueryValueEx(
    HKEY hKey,
    const char FAR* lpValueName,
    DWORD FAR* lpReserved,
    DWORD FAR* lpType,
    BYTE FAR* lpData,
    DWORD FAR* lpcbData
    );

LONG
REGAPI
VMMRegQueryMultipleValues(
    HKEY hKey,
    void FAR* val_list,
    DWORD num_vals,
    char FAR* lpValueBuffer,
    DWORD FAR* lpdwTotalSize
    );

LONG
REGAPI
VMMRegSetValue(
    HKEY hKey,
    const char FAR* lpSubKey,
    DWORD Type,
    BYTE FAR* lpData,
    DWORD cbData
    );

LONG
REGAPI
VMMRegSetValueEx(
    HKEY hKey,
    const char FAR* lpValueName,
    DWORD Reserved,
    DWORD Type,
    BYTE FAR* lpData,
    DWORD cbData
    );

LONG
REGAPI
VMMRegDeleteKey(
    HKEY hKey,
    const char FAR* lpSubKey
    );

LONG
REGAPI
VMMRegDeleteValue(
    HKEY hKey,
    const char FAR* lpValueName
    );

LONG
REGAPI
VMMRegEnumKey(
    HKEY hKey,
    DWORD Index,
    char FAR* lpKeyName,
    DWORD cbKeyName
    );

LONG
REGAPI
VMMRegEnumValue(
    HKEY hKey,
    DWORD Index,
    char FAR* lpValueName,
    DWORD FAR* lpcbValueName,
    DWORD FAR* lpReserved,
    DWORD FAR* lpType,
    BYTE FAR* lpData,
    DWORD FAR* lpcbData
    );

#ifdef VXD
LONG
REGAPI
VMMRegQueryInfoKey(
    HKEY hKey,
    DWORD FAR* lpcSubKeys,
    DWORD FAR* lpcbMaxSubKeyLen,
    DWORD FAR* lpcValues,
    DWORD FAR* lpcbMaxValueName,
    DWORD FAR* lpcbMaxValueData
    );
#else
LONG
REGAPI
VMMRegQueryInfoKey(
    HKEY hKey,
    char FAR* lpClass,
    DWORD FAR* lpcbClass,
    DWORD FAR* lpReserved,
    DWORD FAR* lpcSubKeys,
    DWORD FAR* lpcbMaxSubKeyLen,
    DWORD FAR* lpcbMaxClassLen,
    DWORD FAR* lpcValues,
    DWORD FAR* lpcbMaxValueName,
    DWORD FAR* lpcbMaxValueData,
    void FAR* lpcbSecurityDescriptor,
    void FAR* lpftLastWriteTime
    );
#endif

LONG
REGAPI
VMMRegLoadKey(
    HKEY hKey,
    const char FAR* lpSubKey,
    const char FAR* lpFileName
    );

LONG
REGAPI
VMMRegUnLoadKey(
    HKEY hKey,
    const char FAR* lpSubKey
    );

LONG
REGAPI
VMMRegSaveKey(
    HKEY hKey,
    const char FAR* lpFileName,
    void FAR* lpSecurityAttributes
    );

LONG
REGAPI
VMMRegReplaceKey(
    HKEY hKey,
    const char FAR* lpSubKey,
    const char FAR* lpNewFileName,
    const char FAR* lpOldFileName
    );

//
//  Optional macros for callers (typically 16-bit) that map the registry APIs
//  to the equivalent Win32 API name.
//

#if defined(IS_16) || defined(WANTREGAPIMACROS)
#if !defined(NOREGAPIMACROS) && !defined(SETUPX_INC)
#define RegCreateKey                VMMRegCreateKey
#define RegOpenKey                  VMMRegOpenKey
#define RegCloseKey                 VMMRegCloseKey
#define RegFlushKey                 VMMRegFlushKey
#define RegQueryValue               VMMRegQueryValue
#define RegQueryValueEx             VMMRegQueryValueEx
#define RegQueryMultipleValues      VMMRegQueryMultipleValues
#define RegSetValue                 VMMRegSetValue
#define RegSetValueEx               VMMRegSetValueEx
#define RegDeleteKey                VMMRegDeleteKey
#define RegDeleteValue              VMMRegDeleteValue
#define RegEnumKey                  VMMRegEnumKey
#define RegEnumValue                VMMRegEnumValue
#define RegQueryInfoKey             VMMRegQueryInfoKey
#define RegLoadKey                  VMMRegLoadKey
#define RegUnLoadKey                VMMRegUnLoadKey
#define RegSaveKey                  VMMRegSaveKey
#define RegReplaceKey               VMMRegReplaceKey
#endif
#endif

/*XLATON*/

//
//  Registry services available via VMM's interrupt 2Fh handler.
//

#define RegOpenKey_Idx              0x0100
#define RegCreateKey_Idx            0x0101
#define RegCloseKey_Idx             0x0102
#define RegDeleteKey_Idx            0x0103
#define RegSetValue_Idx             0x0104
#define RegQueryValue_Idx           0x0105
#define RegEnumKey_Idx              0x0106
#define RegDeleteValue_Idx          0x0107
#define RegEnumValue_Idx            0x0108
#define RegQueryValueEx_Idx         0x0109
#define RegSetValueEx_Idx           0x010A
#define RegFlushKey_Idx             0x010B
#define RegLoadKey_Idx              0x010C
#define RegUnLoadKey_Idx            0x010D
#define RegSaveKey_Idx              0x010E
#define RegRestore_Idx              0x010F
#define RegRemapPreDefKey_Idx       0x0110

/*XLATOFF*/
#ifdef __cplusplus
}
#endif
/*XLATON*/

#endif // _REGAPIX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\regia64.h ===
/**
***  Copyright  (C) 1996-99 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

#if defined(__assembler)

//
// Define standard integer registers.
//

        zero        = r0                        // always 0
        gp          = r1                        // global pointer
        v0          = r8                        // return value
        sp          = r12                       // stack pointer
        s0          = r4                        // saved (preserved) integer registers
        s1          = r5
        s2          = r6
        s3          = r7

//
// temporary (volatile) integer registers
//

        t0          = r2
        t1          = r3
        t2          = r9
        t3          = r10
        t4          = r11
        t5          = r14
        t6          = r15
        t7          = r16
        t8          = r17
        t9          = r18
        t10         = r19
        t11         = r20
        t12         = r21
        t13         = r22
        t14         = r23
        t15         = r24
        t16         = r25
        t17         = r26
        t18         = r27
        t19         = r28
        t20         = r29
        t21         = r30
        t22         = r31

//
// Floating point saved (preserved) registers
//

        fs0         = f2
        fs1         = f3
        fs2         = f4
        fs3         = f5
        fs4         = f16
        fs5         = f17
        fs6         = f18
        fs7         = f19
        fs8         = f20
        fs9         = f21
        fs10        = f22
        fs11        = f23
        fs12        = f24
        fs13        = f25
        fs14        = f26
        fs15        = f27
        fs16        = f28
        fs17        = f29
        fs18        = f30
        fs19        = f31

//
// Low floating point temporary (volatile) registers
//

        ft0         = f6
        ft1         = f7
        ft2         = f8
        ft3         = f9
        ft4         = f10
        ft5         = f11
        ft6         = f12
        ft7         = f13
        ft8         = f14
        ft9         = f15

//
// input arguments
// Should be:
// a0  = in0
// a1  = in1
// a2  = in2
// a3  = in3
// a4  = in4
// a5  = in5
// a6  = in6
// a7  = in7
//

        a0          = r32
        a1          = r33
        a2          = r34
        a3          = r35
        a4          = r36
        a5          = r37
        a6          = r38
        a7          = r39

//
// branch return pointer (b0)
//

        brp         = rp

//
// branch saved (preserved)
//

        bs0         = b1
        bs1         = b2
        bs2         = b3
        bs3         = b4
        bs4         = b5

//
// branch temporary (volatile) registers
//

        bt0         = b6
        bt1         = b7

//
// predicate registers
//
// p0 predicate register always 1
//

        ps0         = p1                        // saved (preserved) predicate registers
        ps1         = p2
        ps2         = p3
        ps3         = p4
        ps4         = p5
        ps5         = p16                       // Predicates p16-p63 are also preserved
        ps6         = p17
        ps7         = p18
        ps8         = p19
        ps9         = p20

        pt0         = p6                        // temporary (volatile) predicate registers
        pt1         = p7
        pt2         = p8
        pt3         = p9
        pt4         = p10
        pt5         = p11
        pt6         = p12
        pt7         = p13
        pt8         = p14
        pt9         = p15

//
// Kernel registers
//

        k0          = ar.k0
        k1          = ar.k1
        k2          = ar.k2
        k3          = ar.k3
        k4          = ar.k4
        k5          = ar.k5
        k6          = ar.k6
        k7          = ar.k7

        ia32dr67    = ar.k5                    // dr6/dr7 for iA32

        ia32fcr     = ar21                     // FCR for iA32
        ia32eflag   = ar24                     // EFLAG for iA32
        ia32csd     = ar25                     // CSD for iA32
        ia32ssd     = ar26                     // SSD for iA32
        ia32cflag   = ar27                     // CFLG (cr0/cr4) for iA32
        ia32fsr     = ar28                     // FSR for iA32
        ia32fir     = ar29                     // FIR for iA32
        ia32fdr     = ar30                     // FDR for iA32

//
// Define iA32 constants, to be used by ISA transition code
//
        _DataSelector       ==  0x23
        _CodeSelector       ==  0x1b
        _FsSelector         ==  0x3b
        _LdtSelector        ==  0x4b

//
// Define the IA-32 registers
//
        rEax        =   r8             // v0
        rEcx        =   r9             // t2
        rEdx        =   r10            // t3
        rEbx        =   r11            // t4
        rEsp        =   r12            // sp
        rEbp        =   r13            // teb
        rEsi        =   r14            // t5
        rEdi        =   r15            // t6


//
//  Define iA-32 Segment Registers mapping
//
        rDSESFSGS     =   r16     // ES selector register (t7)
        rCSSSLDTTSS     =   r17     // CS selector register (t8)
        rEFLAG      =   ar24        // Eflag register
        rESD        =   r24     // ES Descriptor register (t15)
        rCSD        =   ar25        // CS Descriptor register
        rSSD        =   ar26        // SS Descriptor register
        rDSD        =   r27     // DS Descriptor register (t18)
        rFSD        =   r28     // FS Descriptor register (t19)
        rGSD        =   r29     // GS Descriptor register (t20)
        rLDTD       =   r30     // LDT Descriptor register (t21)
        rGDTD       =   r31     // GDT Descriptor register (t22)

//
// pointer to thread environment block
//

        teb         = r13        // per s/w convention
        kteb        = ar.k3      // known "true" value (changed only by kernel)

//
// kernel bank shadow (hidden) registers
//

        h16         = r16
        h17         = r17
        h18         = r18
        h19         = r19
        h20         = r20
        h21         = r21
        h22         = r22
        h23         = r23
        h24         = r24
        h25         = r25
        h26         = r26
        h27         = r27
        h28         = r28
        h29         = r29
        h30         = r30
        h31         = r31

// Standard register aliases for procedure entry/exit

// Should be:
// savedpfs = loc0
// savedbrp = loc1

#define savedpfs    loc0
#define savedbrp    loc1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\rend.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for rend.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __rend_h__
#define __rend_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITDirectoryObjectConference_FWD_DEFINED__
#define __ITDirectoryObjectConference_FWD_DEFINED__
typedef interface ITDirectoryObjectConference ITDirectoryObjectConference;
#endif 	/* __ITDirectoryObjectConference_FWD_DEFINED__ */


#ifndef __ITDirectoryObjectUser_FWD_DEFINED__
#define __ITDirectoryObjectUser_FWD_DEFINED__
typedef interface ITDirectoryObjectUser ITDirectoryObjectUser;
#endif 	/* __ITDirectoryObjectUser_FWD_DEFINED__ */


#ifndef __IEnumDialableAddrs_FWD_DEFINED__
#define __IEnumDialableAddrs_FWD_DEFINED__
typedef interface IEnumDialableAddrs IEnumDialableAddrs;
#endif 	/* __IEnumDialableAddrs_FWD_DEFINED__ */


#ifndef __ITDirectoryObject_FWD_DEFINED__
#define __ITDirectoryObject_FWD_DEFINED__
typedef interface ITDirectoryObject ITDirectoryObject;
#endif 	/* __ITDirectoryObject_FWD_DEFINED__ */


#ifndef __IEnumDirectoryObject_FWD_DEFINED__
#define __IEnumDirectoryObject_FWD_DEFINED__
typedef interface IEnumDirectoryObject IEnumDirectoryObject;
#endif 	/* __IEnumDirectoryObject_FWD_DEFINED__ */


#ifndef __ITILSConfig_FWD_DEFINED__
#define __ITILSConfig_FWD_DEFINED__
typedef interface ITILSConfig ITILSConfig;
#endif 	/* __ITILSConfig_FWD_DEFINED__ */


#ifndef __ITDirectory_FWD_DEFINED__
#define __ITDirectory_FWD_DEFINED__
typedef interface ITDirectory ITDirectory;
#endif 	/* __ITDirectory_FWD_DEFINED__ */


#ifndef __IEnumDirectory_FWD_DEFINED__
#define __IEnumDirectory_FWD_DEFINED__
typedef interface IEnumDirectory IEnumDirectory;
#endif 	/* __IEnumDirectory_FWD_DEFINED__ */


#ifndef __ITRendezvous_FWD_DEFINED__
#define __ITRendezvous_FWD_DEFINED__
typedef interface ITRendezvous ITRendezvous;
#endif 	/* __ITRendezvous_FWD_DEFINED__ */


#ifndef __ITRendezvous_FWD_DEFINED__
#define __ITRendezvous_FWD_DEFINED__
typedef interface ITRendezvous ITRendezvous;
#endif 	/* __ITRendezvous_FWD_DEFINED__ */


#ifndef __ITDirectoryObjectConference_FWD_DEFINED__
#define __ITDirectoryObjectConference_FWD_DEFINED__
typedef interface ITDirectoryObjectConference ITDirectoryObjectConference;
#endif 	/* __ITDirectoryObjectConference_FWD_DEFINED__ */


#ifndef __ITDirectoryObjectUser_FWD_DEFINED__
#define __ITDirectoryObjectUser_FWD_DEFINED__
typedef interface ITDirectoryObjectUser ITDirectoryObjectUser;
#endif 	/* __ITDirectoryObjectUser_FWD_DEFINED__ */


#ifndef __ITDirectoryObject_FWD_DEFINED__
#define __ITDirectoryObject_FWD_DEFINED__
typedef interface ITDirectoryObject ITDirectoryObject;
#endif 	/* __ITDirectoryObject_FWD_DEFINED__ */


#ifndef __ITILSConfig_FWD_DEFINED__
#define __ITILSConfig_FWD_DEFINED__
typedef interface ITILSConfig ITILSConfig;
#endif 	/* __ITILSConfig_FWD_DEFINED__ */


#ifndef __ITDirectory_FWD_DEFINED__
#define __ITDirectory_FWD_DEFINED__
typedef interface ITDirectory ITDirectory;
#endif 	/* __ITDirectory_FWD_DEFINED__ */


#ifndef __Rendezvous_FWD_DEFINED__
#define __Rendezvous_FWD_DEFINED__

#ifdef __cplusplus
typedef class Rendezvous Rendezvous;
#else
typedef struct Rendezvous Rendezvous;
#endif /* __cplusplus */

#endif 	/* __Rendezvous_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "tapi3if.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_rend_0000 */
/* [local] */ 

/* Copyright (c) Microsoft Corporation. All rights reserved. */
#define	IDISPDIROBJECT	( 0x10000 )

#define	IDISPDIROBJCONFERENCE	( 0x20000 )

#define	IDISPDIROBJUSER	( 0x30000 )

#define	IDISPDIRECTORY	( 0x10000 )

#define	IDISPILSCONFIG	( 0x20000 )

typedef 
enum DIRECTORY_TYPE
    {	DT_NTDS	= 1,
	DT_ILS	= 2
    } 	DIRECTORY_TYPE;

typedef 
enum DIRECTORY_OBJECT_TYPE
    {	OT_CONFERENCE	= 1,
	OT_USER	= 2
    } 	DIRECTORY_OBJECT_TYPE;

typedef 
enum RND_ADVERTISING_SCOPE
    {	RAS_LOCAL	= 1,
	RAS_SITE	= 2,
	RAS_REGION	= 3,
	RAS_WORLD	= 4
    } 	RND_ADVERTISING_SCOPE;



extern RPC_IF_HANDLE __MIDL_itf_rend_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rend_0000_v0_0_s_ifspec;

#ifndef __ITDirectoryObjectConference_INTERFACE_DEFINED__
#define __ITDirectoryObjectConference_INTERFACE_DEFINED__

/* interface ITDirectoryObjectConference */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ITDirectoryObjectConference;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F1029E5D-CB5B-11D0-8D59-00C04FD91AC0")
    ITDirectoryObjectConference : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Protocol( 
            /* [retval][out] */ BSTR *ppProtocol) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Originator( 
            /* [retval][out] */ BSTR *ppOriginator) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Originator( 
            /* [in] */ BSTR pOriginator) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AdvertisingScope( 
            /* [retval][out] */ RND_ADVERTISING_SCOPE *pAdvertisingScope) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AdvertisingScope( 
            /* [in] */ RND_ADVERTISING_SCOPE AdvertisingScope) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Url( 
            /* [retval][out] */ BSTR *ppUrl) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Url( 
            /* [in] */ BSTR pUrl) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR *ppDescription) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR pDescription) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsEncrypted( 
            /* [retval][out] */ VARIANT_BOOL *pfEncrypted) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_IsEncrypted( 
            /* [in] */ VARIANT_BOOL fEncrypted) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StartTime( 
            /* [retval][out] */ DATE *pDate) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_StartTime( 
            /* [in] */ DATE Date) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StopTime( 
            /* [retval][out] */ DATE *pDate) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_StopTime( 
            /* [in] */ DATE Date) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITDirectoryObjectConferenceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITDirectoryObjectConference * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITDirectoryObjectConference * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITDirectoryObjectConference * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITDirectoryObjectConference * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITDirectoryObjectConference * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITDirectoryObjectConference * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITDirectoryObjectConference * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Protocol )( 
            ITDirectoryObjectConference * This,
            /* [retval][out] */ BSTR *ppProtocol);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Originator )( 
            ITDirectoryObjectConference * This,
            /* [retval][out] */ BSTR *ppOriginator);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Originator )( 
            ITDirectoryObjectConference * This,
            /* [in] */ BSTR pOriginator);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AdvertisingScope )( 
            ITDirectoryObjectConference * This,
            /* [retval][out] */ RND_ADVERTISING_SCOPE *pAdvertisingScope);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AdvertisingScope )( 
            ITDirectoryObjectConference * This,
            /* [in] */ RND_ADVERTISING_SCOPE AdvertisingScope);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Url )( 
            ITDirectoryObjectConference * This,
            /* [retval][out] */ BSTR *ppUrl);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Url )( 
            ITDirectoryObjectConference * This,
            /* [in] */ BSTR pUrl);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            ITDirectoryObjectConference * This,
            /* [retval][out] */ BSTR *ppDescription);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            ITDirectoryObjectConference * This,
            /* [in] */ BSTR pDescription);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsEncrypted )( 
            ITDirectoryObjectConference * This,
            /* [retval][out] */ VARIANT_BOOL *pfEncrypted);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_IsEncrypted )( 
            ITDirectoryObjectConference * This,
            /* [in] */ VARIANT_BOOL fEncrypted);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartTime )( 
            ITDirectoryObjectConference * This,
            /* [retval][out] */ DATE *pDate);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StartTime )( 
            ITDirectoryObjectConference * This,
            /* [in] */ DATE Date);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StopTime )( 
            ITDirectoryObjectConference * This,
            /* [retval][out] */ DATE *pDate);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StopTime )( 
            ITDirectoryObjectConference * This,
            /* [in] */ DATE Date);
        
        END_INTERFACE
    } ITDirectoryObjectConferenceVtbl;

    interface ITDirectoryObjectConference
    {
        CONST_VTBL struct ITDirectoryObjectConferenceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITDirectoryObjectConference_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITDirectoryObjectConference_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITDirectoryObjectConference_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITDirectoryObjectConference_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITDirectoryObjectConference_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITDirectoryObjectConference_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITDirectoryObjectConference_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITDirectoryObjectConference_get_Protocol(This,ppProtocol)	\
    (This)->lpVtbl -> get_Protocol(This,ppProtocol)

#define ITDirectoryObjectConference_get_Originator(This,ppOriginator)	\
    (This)->lpVtbl -> get_Originator(This,ppOriginator)

#define ITDirectoryObjectConference_put_Originator(This,pOriginator)	\
    (This)->lpVtbl -> put_Originator(This,pOriginator)

#define ITDirectoryObjectConference_get_AdvertisingScope(This,pAdvertisingScope)	\
    (This)->lpVtbl -> get_AdvertisingScope(This,pAdvertisingScope)

#define ITDirectoryObjectConference_put_AdvertisingScope(This,AdvertisingScope)	\
    (This)->lpVtbl -> put_AdvertisingScope(This,AdvertisingScope)

#define ITDirectoryObjectConference_get_Url(This,ppUrl)	\
    (This)->lpVtbl -> get_Url(This,ppUrl)

#define ITDirectoryObjectConference_put_Url(This,pUrl)	\
    (This)->lpVtbl -> put_Url(This,pUrl)

#define ITDirectoryObjectConference_get_Description(This,ppDescription)	\
    (This)->lpVtbl -> get_Description(This,ppDescription)

#define ITDirectoryObjectConference_put_Description(This,pDescription)	\
    (This)->lpVtbl -> put_Description(This,pDescription)

#define ITDirectoryObjectConference_get_IsEncrypted(This,pfEncrypted)	\
    (This)->lpVtbl -> get_IsEncrypted(This,pfEncrypted)

#define ITDirectoryObjectConference_put_IsEncrypted(This,fEncrypted)	\
    (This)->lpVtbl -> put_IsEncrypted(This,fEncrypted)

#define ITDirectoryObjectConference_get_StartTime(This,pDate)	\
    (This)->lpVtbl -> get_StartTime(This,pDate)

#define ITDirectoryObjectConference_put_StartTime(This,Date)	\
    (This)->lpVtbl -> put_StartTime(This,Date)

#define ITDirectoryObjectConference_get_StopTime(This,pDate)	\
    (This)->lpVtbl -> get_StopTime(This,pDate)

#define ITDirectoryObjectConference_put_StopTime(This,Date)	\
    (This)->lpVtbl -> put_StopTime(This,Date)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_get_Protocol_Proxy( 
    ITDirectoryObjectConference * This,
    /* [retval][out] */ BSTR *ppProtocol);


void __RPC_STUB ITDirectoryObjectConference_get_Protocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_get_Originator_Proxy( 
    ITDirectoryObjectConference * This,
    /* [retval][out] */ BSTR *ppOriginator);


void __RPC_STUB ITDirectoryObjectConference_get_Originator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_put_Originator_Proxy( 
    ITDirectoryObjectConference * This,
    /* [in] */ BSTR pOriginator);


void __RPC_STUB ITDirectoryObjectConference_put_Originator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_get_AdvertisingScope_Proxy( 
    ITDirectoryObjectConference * This,
    /* [retval][out] */ RND_ADVERTISING_SCOPE *pAdvertisingScope);


void __RPC_STUB ITDirectoryObjectConference_get_AdvertisingScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_put_AdvertisingScope_Proxy( 
    ITDirectoryObjectConference * This,
    /* [in] */ RND_ADVERTISING_SCOPE AdvertisingScope);


void __RPC_STUB ITDirectoryObjectConference_put_AdvertisingScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_get_Url_Proxy( 
    ITDirectoryObjectConference * This,
    /* [retval][out] */ BSTR *ppUrl);


void __RPC_STUB ITDirectoryObjectConference_get_Url_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_put_Url_Proxy( 
    ITDirectoryObjectConference * This,
    /* [in] */ BSTR pUrl);


void __RPC_STUB ITDirectoryObjectConference_put_Url_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_get_Description_Proxy( 
    ITDirectoryObjectConference * This,
    /* [retval][out] */ BSTR *ppDescription);


void __RPC_STUB ITDirectoryObjectConference_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_put_Description_Proxy( 
    ITDirectoryObjectConference * This,
    /* [in] */ BSTR pDescription);


void __RPC_STUB ITDirectoryObjectConference_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_get_IsEncrypted_Proxy( 
    ITDirectoryObjectConference * This,
    /* [retval][out] */ VARIANT_BOOL *pfEncrypted);


void __RPC_STUB ITDirectoryObjectConference_get_IsEncrypted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_put_IsEncrypted_Proxy( 
    ITDirectoryObjectConference * This,
    /* [in] */ VARIANT_BOOL fEncrypted);


void __RPC_STUB ITDirectoryObjectConference_put_IsEncrypted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_get_StartTime_Proxy( 
    ITDirectoryObjectConference * This,
    /* [retval][out] */ DATE *pDate);


void __RPC_STUB ITDirectoryObjectConference_get_StartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_put_StartTime_Proxy( 
    ITDirectoryObjectConference * This,
    /* [in] */ DATE Date);


void __RPC_STUB ITDirectoryObjectConference_put_StartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_get_StopTime_Proxy( 
    ITDirectoryObjectConference * This,
    /* [retval][out] */ DATE *pDate);


void __RPC_STUB ITDirectoryObjectConference_get_StopTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_put_StopTime_Proxy( 
    ITDirectoryObjectConference * This,
    /* [in] */ DATE Date);


void __RPC_STUB ITDirectoryObjectConference_put_StopTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITDirectoryObjectConference_INTERFACE_DEFINED__ */


#ifndef __ITDirectoryObjectUser_INTERFACE_DEFINED__
#define __ITDirectoryObjectUser_INTERFACE_DEFINED__

/* interface ITDirectoryObjectUser */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ITDirectoryObjectUser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34621D6F-6CFF-11d1-AFF7-00C04FC31FEE")
    ITDirectoryObjectUser : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IPPhonePrimary( 
            /* [retval][out] */ BSTR *ppName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_IPPhonePrimary( 
            /* [in] */ BSTR pName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITDirectoryObjectUserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITDirectoryObjectUser * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITDirectoryObjectUser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITDirectoryObjectUser * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITDirectoryObjectUser * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITDirectoryObjectUser * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITDirectoryObjectUser * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITDirectoryObjectUser * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IPPhonePrimary )( 
            ITDirectoryObjectUser * This,
            /* [retval][out] */ BSTR *ppName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_IPPhonePrimary )( 
            ITDirectoryObjectUser * This,
            /* [in] */ BSTR pName);
        
        END_INTERFACE
    } ITDirectoryObjectUserVtbl;

    interface ITDirectoryObjectUser
    {
        CONST_VTBL struct ITDirectoryObjectUserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITDirectoryObjectUser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITDirectoryObjectUser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITDirectoryObjectUser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITDirectoryObjectUser_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITDirectoryObjectUser_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITDirectoryObjectUser_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITDirectoryObjectUser_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITDirectoryObjectUser_get_IPPhonePrimary(This,ppName)	\
    (This)->lpVtbl -> get_IPPhonePrimary(This,ppName)

#define ITDirectoryObjectUser_put_IPPhonePrimary(This,pName)	\
    (This)->lpVtbl -> put_IPPhonePrimary(This,pName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectUser_get_IPPhonePrimary_Proxy( 
    ITDirectoryObjectUser * This,
    /* [retval][out] */ BSTR *ppName);


void __RPC_STUB ITDirectoryObjectUser_get_IPPhonePrimary_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectUser_put_IPPhonePrimary_Proxy( 
    ITDirectoryObjectUser * This,
    /* [in] */ BSTR pName);


void __RPC_STUB ITDirectoryObjectUser_put_IPPhonePrimary_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITDirectoryObjectUser_INTERFACE_DEFINED__ */


#ifndef __IEnumDialableAddrs_INTERFACE_DEFINED__
#define __IEnumDialableAddrs_INTERFACE_DEFINED__

/* interface IEnumDialableAddrs */
/* [object][unique][restricted][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumDialableAddrs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34621D70-6CFF-11d1-AFF7-00C04FC31FEE")
    IEnumDialableAddrs : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][out] */ BSTR *ppElements,
            /* [full][out][in] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumDialableAddrs **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDialableAddrsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDialableAddrs * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDialableAddrs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDialableAddrs * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDialableAddrs * This,
            /* [in] */ ULONG celt,
            /* [size_is][out] */ BSTR *ppElements,
            /* [full][out][in] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDialableAddrs * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDialableAddrs * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDialableAddrs * This,
            /* [retval][out] */ IEnumDialableAddrs **ppEnum);
        
        END_INTERFACE
    } IEnumDialableAddrsVtbl;

    interface IEnumDialableAddrs
    {
        CONST_VTBL struct IEnumDialableAddrsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDialableAddrs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDialableAddrs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDialableAddrs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDialableAddrs_Next(This,celt,ppElements,pcFetched)	\
    (This)->lpVtbl -> Next(This,celt,ppElements,pcFetched)

#define IEnumDialableAddrs_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDialableAddrs_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDialableAddrs_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDialableAddrs_Next_Proxy( 
    IEnumDialableAddrs * This,
    /* [in] */ ULONG celt,
    /* [size_is][out] */ BSTR *ppElements,
    /* [full][out][in] */ ULONG *pcFetched);


void __RPC_STUB IEnumDialableAddrs_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDialableAddrs_Reset_Proxy( 
    IEnumDialableAddrs * This);


void __RPC_STUB IEnumDialableAddrs_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDialableAddrs_Skip_Proxy( 
    IEnumDialableAddrs * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDialableAddrs_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDialableAddrs_Clone_Proxy( 
    IEnumDialableAddrs * This,
    /* [retval][out] */ IEnumDialableAddrs **ppEnum);


void __RPC_STUB IEnumDialableAddrs_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDialableAddrs_INTERFACE_DEFINED__ */


#ifndef __ITDirectoryObject_INTERFACE_DEFINED__
#define __ITDirectoryObject_INTERFACE_DEFINED__

/* interface ITDirectoryObject */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ITDirectoryObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34621D6E-6CFF-11d1-AFF7-00C04FC31FEE")
    ITDirectoryObject : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ObjectType( 
            /* [retval][out] */ DIRECTORY_OBJECT_TYPE *pObjectType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *ppName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR pName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DialableAddrs( 
            /* [in] */ long dwAddressType,
            /* [retval][out] */ VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateDialableAddrs( 
            /* [in] */ DWORD dwAddressType,
            /* [out] */ IEnumDialableAddrs **ppEnumDialableAddrs) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SecurityDescriptor( 
            /* [retval][out] */ IDispatch **ppSecDes) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SecurityDescriptor( 
            /* [in] */ IDispatch *pSecDes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITDirectoryObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITDirectoryObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITDirectoryObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITDirectoryObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITDirectoryObject * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITDirectoryObject * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITDirectoryObject * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITDirectoryObject * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ObjectType )( 
            ITDirectoryObject * This,
            /* [retval][out] */ DIRECTORY_OBJECT_TYPE *pObjectType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            ITDirectoryObject * This,
            /* [retval][out] */ BSTR *ppName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            ITDirectoryObject * This,
            /* [in] */ BSTR pName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DialableAddrs )( 
            ITDirectoryObject * This,
            /* [in] */ long dwAddressType,
            /* [retval][out] */ VARIANT *pVariant);
        
        /* [helpstring][restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateDialableAddrs )( 
            ITDirectoryObject * This,
            /* [in] */ DWORD dwAddressType,
            /* [out] */ IEnumDialableAddrs **ppEnumDialableAddrs);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SecurityDescriptor )( 
            ITDirectoryObject * This,
            /* [retval][out] */ IDispatch **ppSecDes);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SecurityDescriptor )( 
            ITDirectoryObject * This,
            /* [in] */ IDispatch *pSecDes);
        
        END_INTERFACE
    } ITDirectoryObjectVtbl;

    interface ITDirectoryObject
    {
        CONST_VTBL struct ITDirectoryObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITDirectoryObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITDirectoryObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITDirectoryObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITDirectoryObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITDirectoryObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITDirectoryObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITDirectoryObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITDirectoryObject_get_ObjectType(This,pObjectType)	\
    (This)->lpVtbl -> get_ObjectType(This,pObjectType)

#define ITDirectoryObject_get_Name(This,ppName)	\
    (This)->lpVtbl -> get_Name(This,ppName)

#define ITDirectoryObject_put_Name(This,pName)	\
    (This)->lpVtbl -> put_Name(This,pName)

#define ITDirectoryObject_get_DialableAddrs(This,dwAddressType,pVariant)	\
    (This)->lpVtbl -> get_DialableAddrs(This,dwAddressType,pVariant)

#define ITDirectoryObject_EnumerateDialableAddrs(This,dwAddressType,ppEnumDialableAddrs)	\
    (This)->lpVtbl -> EnumerateDialableAddrs(This,dwAddressType,ppEnumDialableAddrs)

#define ITDirectoryObject_get_SecurityDescriptor(This,ppSecDes)	\
    (This)->lpVtbl -> get_SecurityDescriptor(This,ppSecDes)

#define ITDirectoryObject_put_SecurityDescriptor(This,pSecDes)	\
    (This)->lpVtbl -> put_SecurityDescriptor(This,pSecDes)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectoryObject_get_ObjectType_Proxy( 
    ITDirectoryObject * This,
    /* [retval][out] */ DIRECTORY_OBJECT_TYPE *pObjectType);


void __RPC_STUB ITDirectoryObject_get_ObjectType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectoryObject_get_Name_Proxy( 
    ITDirectoryObject * This,
    /* [retval][out] */ BSTR *ppName);


void __RPC_STUB ITDirectoryObject_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITDirectoryObject_put_Name_Proxy( 
    ITDirectoryObject * This,
    /* [in] */ BSTR pName);


void __RPC_STUB ITDirectoryObject_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectoryObject_get_DialableAddrs_Proxy( 
    ITDirectoryObject * This,
    /* [in] */ long dwAddressType,
    /* [retval][out] */ VARIANT *pVariant);


void __RPC_STUB ITDirectoryObject_get_DialableAddrs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE ITDirectoryObject_EnumerateDialableAddrs_Proxy( 
    ITDirectoryObject * This,
    /* [in] */ DWORD dwAddressType,
    /* [out] */ IEnumDialableAddrs **ppEnumDialableAddrs);


void __RPC_STUB ITDirectoryObject_EnumerateDialableAddrs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectoryObject_get_SecurityDescriptor_Proxy( 
    ITDirectoryObject * This,
    /* [retval][out] */ IDispatch **ppSecDes);


void __RPC_STUB ITDirectoryObject_get_SecurityDescriptor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITDirectoryObject_put_SecurityDescriptor_Proxy( 
    ITDirectoryObject * This,
    /* [in] */ IDispatch *pSecDes);


void __RPC_STUB ITDirectoryObject_put_SecurityDescriptor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITDirectoryObject_INTERFACE_DEFINED__ */


#ifndef __IEnumDirectoryObject_INTERFACE_DEFINED__
#define __IEnumDirectoryObject_INTERFACE_DEFINED__

/* interface IEnumDirectoryObject */
/* [unique][restricted][hidden][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumDirectoryObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("06C9B64A-306D-11D1-9774-00C04FD91AC0")
    IEnumDirectoryObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][out] */ ITDirectoryObject **pVal,
            /* [full][out][in] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumDirectoryObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDirectoryObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDirectoryObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDirectoryObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDirectoryObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDirectoryObject * This,
            /* [in] */ ULONG celt,
            /* [size_is][out] */ ITDirectoryObject **pVal,
            /* [full][out][in] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDirectoryObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDirectoryObject * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDirectoryObject * This,
            /* [retval][out] */ IEnumDirectoryObject **ppEnum);
        
        END_INTERFACE
    } IEnumDirectoryObjectVtbl;

    interface IEnumDirectoryObject
    {
        CONST_VTBL struct IEnumDirectoryObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDirectoryObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDirectoryObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDirectoryObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDirectoryObject_Next(This,celt,pVal,pcFetched)	\
    (This)->lpVtbl -> Next(This,celt,pVal,pcFetched)

#define IEnumDirectoryObject_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDirectoryObject_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDirectoryObject_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDirectoryObject_Next_Proxy( 
    IEnumDirectoryObject * This,
    /* [in] */ ULONG celt,
    /* [size_is][out] */ ITDirectoryObject **pVal,
    /* [full][out][in] */ ULONG *pcFetched);


void __RPC_STUB IEnumDirectoryObject_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDirectoryObject_Reset_Proxy( 
    IEnumDirectoryObject * This);


void __RPC_STUB IEnumDirectoryObject_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDirectoryObject_Skip_Proxy( 
    IEnumDirectoryObject * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDirectoryObject_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDirectoryObject_Clone_Proxy( 
    IEnumDirectoryObject * This,
    /* [retval][out] */ IEnumDirectoryObject **ppEnum);


void __RPC_STUB IEnumDirectoryObject_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDirectoryObject_INTERFACE_DEFINED__ */


#ifndef __ITILSConfig_INTERFACE_DEFINED__
#define __ITILSConfig_INTERFACE_DEFINED__

/* interface ITILSConfig */
/* [helpstring][dual][uuid][public][object] */ 


EXTERN_C const IID IID_ITILSConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34621D72-6CFF-11d1-AFF7-00C04FC31FEE")
    ITILSConfig : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Port( 
            /* [retval][out] */ long *pPort) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Port( 
            /* [in] */ long Port) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITILSConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITILSConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITILSConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITILSConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITILSConfig * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITILSConfig * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITILSConfig * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITILSConfig * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Port )( 
            ITILSConfig * This,
            /* [retval][out] */ long *pPort);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Port )( 
            ITILSConfig * This,
            /* [in] */ long Port);
        
        END_INTERFACE
    } ITILSConfigVtbl;

    interface ITILSConfig
    {
        CONST_VTBL struct ITILSConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITILSConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITILSConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITILSConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITILSConfig_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITILSConfig_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITILSConfig_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITILSConfig_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITILSConfig_get_Port(This,pPort)	\
    (This)->lpVtbl -> get_Port(This,pPort)

#define ITILSConfig_put_Port(This,Port)	\
    (This)->lpVtbl -> put_Port(This,Port)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITILSConfig_get_Port_Proxy( 
    ITILSConfig * This,
    /* [retval][out] */ long *pPort);


void __RPC_STUB ITILSConfig_get_Port_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITILSConfig_put_Port_Proxy( 
    ITILSConfig * This,
    /* [in] */ long Port);


void __RPC_STUB ITILSConfig_put_Port_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITILSConfig_INTERFACE_DEFINED__ */


#ifndef __ITDirectory_INTERFACE_DEFINED__
#define __ITDirectory_INTERFACE_DEFINED__

/* interface ITDirectory */
/* [helpstring][dual][uuid][public][object] */ 


EXTERN_C const IID IID_ITDirectory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34621D6C-6CFF-11d1-AFF7-00C04FC31FEE")
    ITDirectory : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DirectoryType( 
            /* [retval][out] */ DIRECTORY_TYPE *pDirectoryType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DisplayName( 
            /* [retval][out] */ BSTR *pName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsDynamic( 
            /* [retval][out] */ VARIANT_BOOL *pfDynamic) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultObjectTTL( 
            /* [retval][out] */ long *pTTL) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DefaultObjectTTL( 
            /* [in] */ long TTL) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnableAutoRefresh( 
            /* [in] */ VARIANT_BOOL fEnable) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ VARIANT_BOOL fSecure) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Bind( 
            /* [in] */ BSTR pDomainName,
            /* [in] */ BSTR pUserName,
            /* [in] */ BSTR pPassword,
            /* [in] */ long lFlags) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddDirectoryObject( 
            /* [in] */ ITDirectoryObject *pDirectoryObject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ModifyDirectoryObject( 
            /* [in] */ ITDirectoryObject *pDirectoryObject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RefreshDirectoryObject( 
            /* [in] */ ITDirectoryObject *pDirectoryObject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeleteDirectoryObject( 
            /* [in] */ ITDirectoryObject *pDirectoryObject) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DirectoryObjects( 
            /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
            /* [in] */ BSTR pName,
            /* [retval][out] */ VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateDirectoryObjects( 
            /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
            /* [in] */ BSTR pName,
            /* [out] */ IEnumDirectoryObject **ppEnumObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITDirectoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITDirectory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITDirectory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITDirectory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITDirectory * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITDirectory * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITDirectory * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITDirectory * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DirectoryType )( 
            ITDirectory * This,
            /* [retval][out] */ DIRECTORY_TYPE *pDirectoryType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayName )( 
            ITDirectory * This,
            /* [retval][out] */ BSTR *pName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsDynamic )( 
            ITDirectory * This,
            /* [retval][out] */ VARIANT_BOOL *pfDynamic);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultObjectTTL )( 
            ITDirectory * This,
            /* [retval][out] */ long *pTTL);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultObjectTTL )( 
            ITDirectory * This,
            /* [in] */ long TTL);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnableAutoRefresh )( 
            ITDirectory * This,
            /* [in] */ VARIANT_BOOL fEnable);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Connect )( 
            ITDirectory * This,
            /* [in] */ VARIANT_BOOL fSecure);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Bind )( 
            ITDirectory * This,
            /* [in] */ BSTR pDomainName,
            /* [in] */ BSTR pUserName,
            /* [in] */ BSTR pPassword,
            /* [in] */ long lFlags);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddDirectoryObject )( 
            ITDirectory * This,
            /* [in] */ ITDirectoryObject *pDirectoryObject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ModifyDirectoryObject )( 
            ITDirectory * This,
            /* [in] */ ITDirectoryObject *pDirectoryObject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RefreshDirectoryObject )( 
            ITDirectory * This,
            /* [in] */ ITDirectoryObject *pDirectoryObject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DeleteDirectoryObject )( 
            ITDirectory * This,
            /* [in] */ ITDirectoryObject *pDirectoryObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DirectoryObjects )( 
            ITDirectory * This,
            /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
            /* [in] */ BSTR pName,
            /* [retval][out] */ VARIANT *pVariant);
        
        /* [helpstring][restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateDirectoryObjects )( 
            ITDirectory * This,
            /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
            /* [in] */ BSTR pName,
            /* [out] */ IEnumDirectoryObject **ppEnumObject);
        
        END_INTERFACE
    } ITDirectoryVtbl;

    interface ITDirectory
    {
        CONST_VTBL struct ITDirectoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITDirectory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITDirectory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITDirectory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITDirectory_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITDirectory_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITDirectory_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITDirectory_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITDirectory_get_DirectoryType(This,pDirectoryType)	\
    (This)->lpVtbl -> get_DirectoryType(This,pDirectoryType)

#define ITDirectory_get_DisplayName(This,pName)	\
    (This)->lpVtbl -> get_DisplayName(This,pName)

#define ITDirectory_get_IsDynamic(This,pfDynamic)	\
    (This)->lpVtbl -> get_IsDynamic(This,pfDynamic)

#define ITDirectory_get_DefaultObjectTTL(This,pTTL)	\
    (This)->lpVtbl -> get_DefaultObjectTTL(This,pTTL)

#define ITDirectory_put_DefaultObjectTTL(This,TTL)	\
    (This)->lpVtbl -> put_DefaultObjectTTL(This,TTL)

#define ITDirectory_EnableAutoRefresh(This,fEnable)	\
    (This)->lpVtbl -> EnableAutoRefresh(This,fEnable)

#define ITDirectory_Connect(This,fSecure)	\
    (This)->lpVtbl -> Connect(This,fSecure)

#define ITDirectory_Bind(This,pDomainName,pUserName,pPassword,lFlags)	\
    (This)->lpVtbl -> Bind(This,pDomainName,pUserName,pPassword,lFlags)

#define ITDirectory_AddDirectoryObject(This,pDirectoryObject)	\
    (This)->lpVtbl -> AddDirectoryObject(This,pDirectoryObject)

#define ITDirectory_ModifyDirectoryObject(This,pDirectoryObject)	\
    (This)->lpVtbl -> ModifyDirectoryObject(This,pDirectoryObject)

#define ITDirectory_RefreshDirectoryObject(This,pDirectoryObject)	\
    (This)->lpVtbl -> RefreshDirectoryObject(This,pDirectoryObject)

#define ITDirectory_DeleteDirectoryObject(This,pDirectoryObject)	\
    (This)->lpVtbl -> DeleteDirectoryObject(This,pDirectoryObject)

#define ITDirectory_get_DirectoryObjects(This,DirectoryObjectType,pName,pVariant)	\
    (This)->lpVtbl -> get_DirectoryObjects(This,DirectoryObjectType,pName,pVariant)

#define ITDirectory_EnumerateDirectoryObjects(This,DirectoryObjectType,pName,ppEnumObject)	\
    (This)->lpVtbl -> EnumerateDirectoryObjects(This,DirectoryObjectType,pName,ppEnumObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectory_get_DirectoryType_Proxy( 
    ITDirectory * This,
    /* [retval][out] */ DIRECTORY_TYPE *pDirectoryType);


void __RPC_STUB ITDirectory_get_DirectoryType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectory_get_DisplayName_Proxy( 
    ITDirectory * This,
    /* [retval][out] */ BSTR *pName);


void __RPC_STUB ITDirectory_get_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectory_get_IsDynamic_Proxy( 
    ITDirectory * This,
    /* [retval][out] */ VARIANT_BOOL *pfDynamic);


void __RPC_STUB ITDirectory_get_IsDynamic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectory_get_DefaultObjectTTL_Proxy( 
    ITDirectory * This,
    /* [retval][out] */ long *pTTL);


void __RPC_STUB ITDirectory_get_DefaultObjectTTL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITDirectory_put_DefaultObjectTTL_Proxy( 
    ITDirectory * This,
    /* [in] */ long TTL);


void __RPC_STUB ITDirectory_put_DefaultObjectTTL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITDirectory_EnableAutoRefresh_Proxy( 
    ITDirectory * This,
    /* [in] */ VARIANT_BOOL fEnable);


void __RPC_STUB ITDirectory_EnableAutoRefresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITDirectory_Connect_Proxy( 
    ITDirectory * This,
    /* [in] */ VARIANT_BOOL fSecure);


void __RPC_STUB ITDirectory_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITDirectory_Bind_Proxy( 
    ITDirectory * This,
    /* [in] */ BSTR pDomainName,
    /* [in] */ BSTR pUserName,
    /* [in] */ BSTR pPassword,
    /* [in] */ long lFlags);


void __RPC_STUB ITDirectory_Bind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITDirectory_AddDirectoryObject_Proxy( 
    ITDirectory * This,
    /* [in] */ ITDirectoryObject *pDirectoryObject);


void __RPC_STUB ITDirectory_AddDirectoryObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITDirectory_ModifyDirectoryObject_Proxy( 
    ITDirectory * This,
    /* [in] */ ITDirectoryObject *pDirectoryObject);


void __RPC_STUB ITDirectory_ModifyDirectoryObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITDirectory_RefreshDirectoryObject_Proxy( 
    ITDirectory * This,
    /* [in] */ ITDirectoryObject *pDirectoryObject);


void __RPC_STUB ITDirectory_RefreshDirectoryObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITDirectory_DeleteDirectoryObject_Proxy( 
    ITDirectory * This,
    /* [in] */ ITDirectoryObject *pDirectoryObject);


void __RPC_STUB ITDirectory_DeleteDirectoryObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectory_get_DirectoryObjects_Proxy( 
    ITDirectory * This,
    /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
    /* [in] */ BSTR pName,
    /* [retval][out] */ VARIANT *pVariant);


void __RPC_STUB ITDirectory_get_DirectoryObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE ITDirectory_EnumerateDirectoryObjects_Proxy( 
    ITDirectory * This,
    /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
    /* [in] */ BSTR pName,
    /* [out] */ IEnumDirectoryObject **ppEnumObject);


void __RPC_STUB ITDirectory_EnumerateDirectoryObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITDirectory_INTERFACE_DEFINED__ */


#ifndef __IEnumDirectory_INTERFACE_DEFINED__
#define __IEnumDirectory_INTERFACE_DEFINED__

/* interface IEnumDirectory */
/* [object][unique][restricted][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumDirectory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34621D6D-6CFF-11d1-AFF7-00C04FC31FEE")
    IEnumDirectory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ITDirectory **ppElements,
            /* [full][out][in] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumDirectory **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDirectoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDirectory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDirectory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDirectory * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDirectory * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ITDirectory **ppElements,
            /* [full][out][in] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDirectory * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDirectory * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDirectory * This,
            /* [retval][out] */ IEnumDirectory **ppEnum);
        
        END_INTERFACE
    } IEnumDirectoryVtbl;

    interface IEnumDirectory
    {
        CONST_VTBL struct IEnumDirectoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDirectory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDirectory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDirectory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDirectory_Next(This,celt,ppElements,pcFetched)	\
    (This)->lpVtbl -> Next(This,celt,ppElements,pcFetched)

#define IEnumDirectory_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDirectory_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDirectory_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDirectory_Next_Proxy( 
    IEnumDirectory * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ITDirectory **ppElements,
    /* [full][out][in] */ ULONG *pcFetched);


void __RPC_STUB IEnumDirectory_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDirectory_Reset_Proxy( 
    IEnumDirectory * This);


void __RPC_STUB IEnumDirectory_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDirectory_Skip_Proxy( 
    IEnumDirectory * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDirectory_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDirectory_Clone_Proxy( 
    IEnumDirectory * This,
    /* [retval][out] */ IEnumDirectory **ppEnum);


void __RPC_STUB IEnumDirectory_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDirectory_INTERFACE_DEFINED__ */


#ifndef __ITRendezvous_INTERFACE_DEFINED__
#define __ITRendezvous_INTERFACE_DEFINED__

/* interface ITRendezvous */
/* [helpstring][dual][uuid][public][object] */ 


EXTERN_C const IID IID_ITRendezvous;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34621D6B-6CFF-11d1-AFF7-00C04FC31FEE")
    ITRendezvous : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultDirectories( 
            /* [retval][out] */ VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateDefaultDirectories( 
            /* [out] */ IEnumDirectory **ppEnumDirectory) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateDirectory( 
            /* [in] */ DIRECTORY_TYPE DirectoryType,
            /* [in] */ BSTR pName,
            /* [retval][out] */ ITDirectory **ppDir) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateDirectoryObject( 
            /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
            /* [in] */ BSTR pName,
            /* [retval][out] */ ITDirectoryObject **ppDirectoryObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITRendezvousVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITRendezvous * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITRendezvous * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITRendezvous * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITRendezvous * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITRendezvous * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITRendezvous * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITRendezvous * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultDirectories )( 
            ITRendezvous * This,
            /* [retval][out] */ VARIANT *pVariant);
        
        /* [helpstring][restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateDefaultDirectories )( 
            ITRendezvous * This,
            /* [out] */ IEnumDirectory **ppEnumDirectory);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateDirectory )( 
            ITRendezvous * This,
            /* [in] */ DIRECTORY_TYPE DirectoryType,
            /* [in] */ BSTR pName,
            /* [retval][out] */ ITDirectory **ppDir);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateDirectoryObject )( 
            ITRendezvous * This,
            /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
            /* [in] */ BSTR pName,
            /* [retval][out] */ ITDirectoryObject **ppDirectoryObject);
        
        END_INTERFACE
    } ITRendezvousVtbl;

    interface ITRendezvous
    {
        CONST_VTBL struct ITRendezvousVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITRendezvous_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITRendezvous_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITRendezvous_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITRendezvous_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITRendezvous_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITRendezvous_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITRendezvous_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITRendezvous_get_DefaultDirectories(This,pVariant)	\
    (This)->lpVtbl -> get_DefaultDirectories(This,pVariant)

#define ITRendezvous_EnumerateDefaultDirectories(This,ppEnumDirectory)	\
    (This)->lpVtbl -> EnumerateDefaultDirectories(This,ppEnumDirectory)

#define ITRendezvous_CreateDirectory(This,DirectoryType,pName,ppDir)	\
    (This)->lpVtbl -> CreateDirectory(This,DirectoryType,pName,ppDir)

#define ITRendezvous_CreateDirectoryObject(This,DirectoryObjectType,pName,ppDirectoryObject)	\
    (This)->lpVtbl -> CreateDirectoryObject(This,DirectoryObjectType,pName,ppDirectoryObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITRendezvous_get_DefaultDirectories_Proxy( 
    ITRendezvous * This,
    /* [retval][out] */ VARIANT *pVariant);


void __RPC_STUB ITRendezvous_get_DefaultDirectories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE ITRendezvous_EnumerateDefaultDirectories_Proxy( 
    ITRendezvous * This,
    /* [out] */ IEnumDirectory **ppEnumDirectory);


void __RPC_STUB ITRendezvous_EnumerateDefaultDirectories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITRendezvous_CreateDirectory_Proxy( 
    ITRendezvous * This,
    /* [in] */ DIRECTORY_TYPE DirectoryType,
    /* [in] */ BSTR pName,
    /* [retval][out] */ ITDirectory **ppDir);


void __RPC_STUB ITRendezvous_CreateDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITRendezvous_CreateDirectoryObject_Proxy( 
    ITRendezvous * This,
    /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
    /* [in] */ BSTR pName,
    /* [retval][out] */ ITDirectoryObject **ppDirectoryObject);


void __RPC_STUB ITRendezvous_CreateDirectoryObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITRendezvous_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_rend_0503 */
/* [local] */ 



/***************************************************************/
/* Rend constants -- defined here for C apps                   */
/* The subsequent definitions that MIDL generates from the     */
/* module declaration are not used. The module declaration is  */
/* retained, however, so that the constants show up in the     */
/* type library.                                               */
/***************************************************************/

#define RENDBIND_AUTHENTICATE       0x00000001
#define RENDBIND_DEFAULTDOMAINNAME  0x00000002
#define RENDBIND_DEFAULTUSERNAME    0x00000004
#define RENDBIND_DEFAULTPASSWORD    0x00000008
/* this is just the previous three |'ed together for convenience. */
#define RENDBIND_DEFAULTCREDENTIALS 0x0000000e

#define __RendConstants_MODULE_DEFINED__

/***************************************************************/
/* end of rend constants section                               */
/***************************************************************/




extern RPC_IF_HANDLE __MIDL_itf_rend_0503_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rend_0503_v0_0_s_ifspec;


#ifndef __RENDLib_LIBRARY_DEFINED__
#define __RENDLib_LIBRARY_DEFINED__

/* library RENDLib */
/* [helpstring][version][uuid] */ 








EXTERN_C const IID LIBID_RENDLib;

EXTERN_C const CLSID CLSID_Rendezvous;

#ifdef __cplusplus

class DECLSPEC_UUID("F1029E5B-CB5B-11D0-8D59-00C04FD91AC0")
Rendezvous;
#endif


#ifndef __RendConstants_MODULE_DEFINED__
#define __RendConstants_MODULE_DEFINED__


/* module RendConstants */
/* [helpstring][dllname][uuid] */ 

const long RENDBIND_AUTHENTICATE	=	0x1;

const long RENDBIND_DEFAULTDOMAINNAME	=	0x2;

const long RENDBIND_DEFAULTUSERNAME	=	0x4;

const long RENDBIND_DEFAULTPASSWORD	=	0x8;

const long RENDBIND_DEFAULTCREDENTIALS	=	0xe;

#endif /* __RendConstants_MODULE_DEFINED__ */
#endif /* __RENDLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\regstr.h ===
/*** regstr.h - Registry string definitions
 *
 *  This module contains public registry string definitions.
 *
 *  Copyright (c) Microsoft Corporation.  All rights reserved.
 *  Created     12/10/92
 *
 *  MODIFICATION HISTORY
 */


#ifndef _INC_REGSTR
#define _INC_REGSTR

#if _MSC_VER > 1000
#pragma once
#endif


/*** Public registry key names
 */

#define REGSTR_KEY_CLASS        TEXT("Class")      // under LOCAL_MACHINE
#define REGSTR_KEY_CONFIG       TEXT("Config")     // under LOCAL_MACHINE
#define REGSTR_KEY_ENUM         TEXT("Enum")       // under LOCAL_MACHINE
#define REGSTR_KEY_ROOTENUM     TEXT("Root")       // child of ENUM
#define REGSTR_KEY_BIOSENUM     TEXT("BIOS")       // child of ENUM
#define REGSTR_KEY_ACPIENUM     TEXT("ACPI")       // child of ENUM
#define REGSTR_KEY_PCMCIAENUM   TEXT("PCMCIA")     // child of ENUM
#define REGSTR_KEY_PCIENUM      TEXT("PCI")        // child of ENUM
#define REGSTR_KEY_VPOWERDENUM  TEXT("VPOWERD")    // child of ENUM
#ifndef NEC_98
#define REGSTR_KEY_ISAENUM      TEXT("ISAPnP")     // child of ENUM
#define REGSTR_KEY_EISAENUM     TEXT("EISA")       // child of ENUM
#else // ifdef NEC_98
#define REGSTR_KEY_ISAENUM      TEXT("C98PnP")     // child of ENUM
#define REGSTR_KEY_EISAENUM     TEXT("NESA")       // child of ENUM
#endif // ifdef NEC_98
#define REGSTR_KEY_LOGCONFIG    TEXT("LogConfig")  // child of enum\<enumerator>\<deviceid>\<instanceid>
#define REGSTR_KEY_SYSTEMBOARD  TEXT("*PNP0C01")   // child of enum\root
#define REGSTR_KEY_APM          TEXT("*PNP0C05")   // child of enum\root

#define REGSTR_KEY_INIUPDATE    TEXT("IniUpdate")
#define REG_KEY_INSTDEV         TEXT("Installed")  // child of hklm\class\classname (Win98-only)

#define REGSTR_KEY_DOSOPTCDROM  TEXT("CD-ROM")
#define REGSTR_KEY_DOSOPTMOUSE  TEXT("MOUSE")

#define REGSTR_KEY_KNOWNDOCKINGSTATES TEXT("Hardware Profiles")
#define REGSTR_KEY_DEVICEPARAMETERS   TEXT("Device Parameters")


/*** Public registry paths
 */

#define REGSTR_DEFAULT_INSTANCE          TEXT("0000")
#define REGSTR_PATH_MOTHERBOARD          REGSTR_KEY_SYSTEMBOARD TEXT("\\") REGSTR_DEFAULT_INSTANCE
#define REGSTR_PATH_SETUP                TEXT("Software\\Microsoft\\Windows\\CurrentVersion")
#define REGSTR_PATH_DRIVERSIGN           TEXT("Software\\Microsoft\\Driver Signing")
#define REGSTR_PATH_NONDRIVERSIGN        TEXT("Software\\Microsoft\\Non-Driver Signing")
#define REGSTR_PATH_DRIVERSIGN_POLICY    TEXT("Software\\Policies\\Microsoft\\Windows NT\\Driver Signing")
#define REGSTR_PATH_NONDRIVERSIGN_POLICY TEXT("Software\\Policies\\Microsoft\\Windows NT\\Non-Driver Signing")
#define REGSTR_PATH_PIFCONVERT           TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\PIFConvert")
#define REGSTR_PATH_MSDOSOPTS            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\MS-DOSOptions")
#define REGSTR_PATH_NOSUGGMSDOS          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\NoMSDOSWarn")
#define REGSTR_PATH_NEWDOSBOX            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\MS-DOSSpecialConfig")
#define REGSTR_PATH_RUNONCE              TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce")
#define REGSTR_PATH_RUNONCEEX            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx")
#define REGSTR_PATH_RUN                  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run")
#define REGSTR_PATH_RUNSERVICESONCE      TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce")
#define REGSTR_PATH_RUNSERVICES          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunServices")
#define REGSTR_PATH_EXPLORER             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer")
#define REGSTR_PATH_DETECT               TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Detect")
#define REGSTR_PATH_APPPATHS             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths")
#define REGSTR_PATH_UNINSTALL            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall")
#define REGSTR_PATH_REALMODENET          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Network\\Real Mode Net")
#define REGSTR_PATH_NETEQUIV             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Network\\Equivalent")
#define REGSTR_PATH_CVNETWORK            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Network")
#define REGSTR_PATH_WMI_SECURITY         TEXT("System\\CurrentControlSet\\Control\\Wmi\\Security")
#define REGSTR_PATH_RELIABILITY          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Reliability")
#define REGSTR_PATH_RELIABILITY_POLICY   TEXT("Software\\Policies\\Microsoft\\Windows NT\\Reliability")
#define REGSTR_PATH_RELIABILITY_POLICY_SHUTDOWNREASONUI TEXT("ShutdownReasonUI")
#define REGSTR_PATH_RELIABILITY_POLICY_SNAPSHOT         TEXT("Snapshot")
#define REGSTR_PATH_RELIABILITY_POLICY_REPORTSNAPSHOT   TEXT("ReportSnapshot")

#define REGSTR_PATH_REINSTALL            TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Reinstall")
#define REGSTR_PATH_NT_CURRENTVERSION TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion")

#define REGSTR_PATH_VOLUMECACHE TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VolumeCaches")
#define REGSTR_VAL_DISPLAY      TEXT("display")


#define REGSTR_PATH_IDCONFIGDB  TEXT("System\\CurrentControlSet\\Control\\IDConfigDB")
#define REGSTR_PATH_CRITICALDEVICEDATABASE  TEXT("System\\CurrentControlSet\\Control\\CriticalDeviceDatabase")
#define REGSTR_PATH_CLASS       TEXT("System\\CurrentControlSet\\Services\\Class")
#define REGSTR_PATH_DISPLAYSETTINGS TEXT("Display\\Settings")
#define REGSTR_PATH_FONTS           TEXT("Display\\Fonts")
#define REGSTR_PATH_ENUM        TEXT("Enum")
#define REGSTR_PATH_ROOT        TEXT("Enum\\Root")

#define REGSTR_PATH_CURRENTCONTROLSET TEXT("System\\CurrentControlSet")
#define REGSTR_PATH_SYSTEMENUM  TEXT("System\\CurrentControlSet\\Enum")
#define REGSTR_PATH_HWPROFILES  TEXT("System\\CurrentControlSet\\Hardware Profiles")
#define REGSTR_PATH_HWPROFILESCURRENT TEXT("System\\CurrentControlSet\\Hardware Profiles\\Current")
#define REGSTR_PATH_CLASS_NT    TEXT("System\\CurrentControlSet\\Control\\Class")
#define REGSTR_PATH_PER_HW_ID_STORAGE TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\PerHwIdStorage")

#define REGSTR_PATH_DEVICE_CLASSES TEXT("System\\CurrentControlSet\\Control\\DeviceClasses")

#define REGSTR_PATH_CODEVICEINSTALLERS TEXT("System\\CurrentControlSet\\Control\\CoDeviceInstallers")
#define REGSTR_PATH_BUSINFORMATION TEXT("System\\CurrentControlSet\\Control\\PnP\\BusInformation")

#define REGSTR_PATH_SERVICES    TEXT("System\\CurrentControlSet\\Services")
#define REGSTR_PATH_VXD         TEXT("System\\CurrentControlSet\\Services\\VxD")
#define REGSTR_PATH_IOS     TEXT("System\\CurrentControlSet\\Services\\VxD\\IOS")
#define REGSTR_PATH_VMM         TEXT("System\\CurrentControlSet\\Services\\VxD\\VMM")
#define REGSTR_PATH_VPOWERD     TEXT("System\\CurrentControlSet\\Services\\VxD\\VPOWERD")
#define REGSTR_PATH_VNETSUP     TEXT("System\\CurrentControlSet\\Services\\VxD\\VNETSUP")
#define REGSTR_PATH_NWREDIR     TEXT("System\\CurrentControlSet\\Services\\VxD\\NWREDIR")
#define REGSTR_PATH_NCPSERVER   TEXT("System\\CurrentControlSet\\Services\\NcpServer\\Parameters")
#define REGSTR_PATH_VCOMM       TEXT("System\\CurrentControlSet\\Services\\VxD\\VCOMM")

#define REGSTR_PATH_IOARB       TEXT("System\\CurrentControlSet\\Services\\Arbitrators\\IOArb")
#define REGSTR_PATH_ADDRARB     TEXT("System\\CurrentControlSet\\Services\\Arbitrators\\AddrArb")
#define REGSTR_PATH_DMAARB      TEXT("System\\CurrentControlSet\\Services\\Arbitrators\\DMAArb")
#define REGSTR_PATH_IRQARB      TEXT("System\\CurrentControlSet\\Services\\Arbitrators\\IRQArb")

#define REGSTR_PATH_CODEPAGE                            TEXT("System\\CurrentControlSet\\Control\\Nls\\Codepage")
#define REGSTR_PATH_FILESYSTEM                          TEXT("System\\CurrentControlSet\\Control\\FileSystem")
#define REGSTR_PATH_FILESYSTEM_NOVOLTRACK       TEXT("System\\CurrentControlSet\\Control\\FileSystem\\NoVolTrack")
#define REGSTR_PATH_CDFS                                        TEXT("System\\CurrentControlSet\\Control\\FileSystem\\CDFS")
#define REGSTR_PATH_WINBOOT                                 TEXT("System\\CurrentControlSet\\Control\\WinBoot")
#define REGSTR_PATH_INSTALLEDFILES                      TEXT("System\\CurrentControlSet\\Control\\InstalledFiles")
#define REGSTR_PATH_VMM32FILES                          TEXT("System\\CurrentControlSet\\Control\\VMM32Files")

//
// Reasonable Limit for Values Names
//
#define REGSTR_MAX_VALUE_LENGTH     256

//
// Values used by user mode Pnp Manager
//
#define REGSTR_KEY_DEVICE_PROPERTIES               TEXT("Properties")
#define REGSTR_VAL_SLOTNUMBER                      TEXT("SlotNumber")
#define REGSTR_VAL_ATTACHEDCOMPONENTS              TEXT("AttachedComponents")
#define REGSTR_VAL_BASEDEVICEPATH                  TEXT("BaseDevicePath")
#define REGSTR_VAL_SYSTEMBUSNUMBER                 TEXT("SystemBusNumber")
#define REGSTR_VAL_BUSDATATYPE                     TEXT("BusDataType")
#define REGSTR_VAL_INTERFACETYPE                   TEXT("InterfaceType")
#define REGSTR_VAL_SERVICE                         TEXT("Service")
#define REGSTR_VAL_DETECTSIGNATURE                 TEXT("DetectSignature")
#define REGSTR_VAL_CLASSGUID                       TEXT("ClassGUID")
#define REGSTR_VAL_INSTANCEIDENTIFIER              TEXT("InstanceIdentifier")
#define REGSTR_VAL_DUPLICATEOF                     TEXT("DuplicateOf")
#define REGSTR_VAL_STATUSFLAGS                     TEXT("StatusFlags")
#define REGSTR_VAL_DISABLECOUNT                    TEXT("DisableCount")
#define REGSTR_VAL_UNKNOWNPROBLEMS                 TEXT("UnknownProblem")
#define REGSTR_VAL_DOCKSTATE                       TEXT("DockState")
#define REGSTR_VAL_PREFERENCEORDER                 TEXT("PreferenceOrder")
#define REGSTR_VAL_USERWAITINTERVAL                TEXT("UserWaitInterval")
#define REGSTR_VAL_DEVICE_INSTANCE                 TEXT("DeviceInstance")
#define REGSTR_VAL_SYMBOLIC_LINK                   TEXT("SymbolicLink")
#define REGSTR_VAL_DEFAULT                         TEXT("Default")
#define REGSTR_VAL_LOWERFILTERS                    TEXT("LowerFilters")
#define REGSTR_VAL_UPPERFILTERS                    TEXT("UpperFilters")
#define REGSTR_VAL_LOCATION_INFORMATION            TEXT("LocationInformation")
#define REGSTR_VAL_UI_NUMBER                       TEXT("UINumber")
#define REGSTR_VAL_UI_NUMBER_DESC_FORMAT           TEXT("UINumberDescFormat")
#define REGSTR_VAL_CAPABILITIES                    TEXT("Capabilities")
#define REGSTR_VAL_DEVICE_TYPE                     TEXT("DeviceType")
#define REGSTR_VAL_DEVICE_CHARACTERISTICS          TEXT("DeviceCharacteristics")
#define REGSTR_VAL_DEVICE_SECURITY_DESCRIPTOR      TEXT("Security")
#define REGSTR_VAL_DEVICE_EXCLUSIVE                TEXT("Exclusive")
#define REGSTR_VAL_RESOURCE_PICKER_TAGS            TEXT("ResourcePickerTags")
#define REGSTR_VAL_RESOURCE_PICKER_EXCEPTIONS      TEXT("ResourcePickerExceptions")
#define REGSTR_VAL_CUSTOM_PROPERTY_CACHE_DATE      TEXT("CustomPropertyCacheDate")
#define REGSTR_VAL_CUSTOM_PROPERTY_HW_ID_KEY       TEXT("CustomPropertyHwIdKey")
#define REGSTR_VAL_LAST_UPDATE_TIME                TEXT("LastUpdateTime")

//
// Values used by kernel mode Pnp Manager
//
#define REGSTR_VALUE_DEVICE_OBJECT_NAME            TEXT("DeviceObjectName")
#define REGSTR_VALUE_DEVICE_SYMBOLIC_NAME          TEXT("DeviceSymbolicName")
#define REGSTR_VAL_EJECT_PRIORITY                  TEXT("EjectPriority")

//
// Values used by both kernel-mode and user-mode PnP Managers
//
#define REGSTR_KEY_CONTROL                         TEXT("Control")
#define REGSTR_VAL_ACTIVESERVICE                   TEXT("ActiveService")
#define REGSTR_VAL_LINKED                          TEXT("Linked")
#define REGSTR_VAL_PHYSICALDEVICEOBJECT            TEXT("PhysicalDeviceObject")
#define REGSTR_VAL_REMOVAL_POLICY                  TEXT("RemovalPolicy")

//
// Values under REGSTR_PATH_NT_CURRENTVERSION
//
#define REGSTR_VAL_CURRENT_VERSION  TEXT("CurrentVersion")
#define REGSTR_VAL_CURRENT_BUILD    TEXT("CurrentBuildNumber")
#define REGSTR_VAL_CURRENT_CSDVERSION TEXT("CSDVersion")
#define REGSTR_VAL_CURRENT_TYPE     TEXT("CurrentType")

//
// Values under REGSTR_PATH_DISPLAYSETTINGS
//

#define REGSTR_VAL_BITSPERPIXEL  TEXT("BitsPerPixel")
#define REGSTR_VAL_RESOLUTION    TEXT("Resolution")
#define REGSTR_VAL_DPILOGICALX   TEXT("DPILogicalX")
#define REGSTR_VAL_DPILOGICALY   TEXT("DPILogicalY")
#define REGSTR_VAL_DPIPHYSICALX  TEXT("DPIPhysicalX")
#define REGSTR_VAL_DPIPHYSICALY  TEXT("DPIPhysicalY")
#define REGSTR_VAL_REFRESHRATE   TEXT("RefreshRate")
#define REGSTR_VAL_DISPLAYFLAGS  TEXT("DisplayFlags")


// under HKEY_CURRENT_USER
#define REGSTR_PATH_CONTROLPANEL    TEXT("Control Panel")

// under HKEY_LOCAL_MACHINE
#define REGSTR_PATH_CONTROLSFOLDER  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Controls Folder")

//
// Entries under REGSTR_PATH_CODEPAGE
//

#define REGSTR_VAL_DOSCP        TEXT("OEMCP")
#define REGSTR_VAL_WINCP        TEXT("ACP")

#define REGSTR_PATH_DYNA_ENUM   TEXT("Config Manager\\Enum")

//
// Entries under REGSTR_PATH_DYNA_ENUM
//
#define REGSTR_VAL_HARDWARE_KEY TEXT("HardWareKey")
#define REGSTR_VAL_ALLOCATION   TEXT("Allocation")
#define REGSTR_VAL_PROBLEM      TEXT("Problem")
#define REGSTR_VAL_STATUS       TEXT("Status")

//
//  Used by address arbitrator
//
#define REGSTR_VAL_DONTUSEMEM   TEXT("DontAllocLastMem")

//
//  Entries under REGSTR_PATH_SETUP
//
#define REGSTR_VAL_SYSTEMROOT           TEXT("SystemRoot")
#define REGSTR_VAL_BOOTCOUNT            TEXT("BootCount")
#define REGSTR_VAL_REALNETSTART         TEXT("RealNetStart")
#define REGSTR_VAL_MEDIA                TEXT("MediaPath")
#define REGSTR_VAL_CONFIG               TEXT("ConfigPath")
#define REGSTR_VAL_DEVICEPATH           TEXT("DevicePath")      //default search path for .INFs
#define REGSTR_VAL_SRCPATH              TEXT("SourcePath")      //last source files path during setup.
#define REGSTR_VAL_SVCPAKSRCPATH        TEXT("ServicePackSourcePath") //last service pack source path
#define REGSTR_VAL_DRIVERCACHEPATH      TEXT("DriverCachePath") //location of driver cache

#define REGSTR_VAL_OLDWINDIR            TEXT("OldWinDir")       //old windows location
#define REGSTR_VAL_SETUPFLAGS           TEXT("SetupFlags")      //flags that setup passes on after install.
#define REGSTR_VAL_REGOWNER             TEXT("RegisteredOwner")
#define REGSTR_VAL_REGORGANIZATION      TEXT("RegisteredOrganization")
#define REGSTR_VAL_LICENSINGINFO        TEXT("LicensingInfo")
#define REGSTR_VAL_OLDMSDOSVER          TEXT("OldMSDOSVer") // will be DOS ver < 7 (when Setup run)
#define REGSTR_VAL_FIRSTINSTALLDATETIME TEXT("FirstInstallDateTime") // will Win 95 install date-time

#define REGSTR_VAL_INSTALLTYPE          TEXT("InstallType")
//  Values for InstallType
#define IT_COMPACT          0x0000
#define IT_TYPICAL          0x0001
#define IT_PORTABLE         0x0002
#define IT_CUSTOM           0x0003

#define REGSTR_VAL_WRAPPER              TEXT("Wrapper")

#define REGSTR_VAL_LASTALIVEINTERVAL    TEXT("TimeStampInterval")
#define REGSTR_VAL_LASTALIVESTAMP       TEXT("LastAliveStamp")
#define REGSTR_VAL_LASTALIVEUPTIME      TEXT("LastAliveUptime")
#define REGSTR_VAL_SHUTDOWNREASON       TEXT("ShutdownReason")
#define REGSTR_VAL_SHUTDOWNREASON_CODE          TEXT("ShutdownReasonCode")
#define REGSTR_VAL_SHUTDOWNREASON_COMMENT       TEXT("ShutdownReasonComment")
#define REGSTR_VAL_SHUTDOWNREASON_PROCESS       TEXT("ShutdownReasonProcess")
#define REGSTR_VAL_SHUTDOWNREASON_USERNAME      TEXT("ShutdownReasonUserName")
#define REGSTR_VAL_SHOWREASONUI                 TEXT("ShutdownReasonUI")
#define REGSTR_VAL_SHUTDOWN_IGNORE_PREDEFINED   TEXT("ShutdownIgnorePredefinedReasons")
#define REGSTR_VAL_SHUTDOWN_STATE_SNAPSHOT      TEXT("ShutdownStateSnapshot")

#define REGSTR_KEY_SETUP                TEXT("\\Setup")
#define REGSTR_VAL_BOOTDIR              TEXT("BootDir")
#define REGSTR_VAL_WINBOOTDIR           TEXT("WinbootDir")
#define REGSTR_VAL_WINDIR               TEXT("WinDir")

#define REGSTR_VAL_APPINSTPATH          TEXT("AppInstallPath")    // Used by install wizard

// Values for international startup disk
#define REGSTR_PATH_EBD          REGSTR_PATH_SETUP REGSTR_KEY_SETUP TEXT("\\EBD")
// Keys under REGSTR_KEY_EBD
#define REGSTR_KEY_EBDFILESLOCAL     TEXT("EBDFilesLocale")
#define REGSTR_KEY_EBDFILESKEYBOARD     TEXT("EBDFilesKeyboard")
#define REGSTR_KEY_EBDAUTOEXECBATLOCAL TEXT("EBDAutoexecBatLocale")
#define REGSTR_KEY_EBDAUTOEXECBATKEYBOARD TEXT("EBDAutoexecBatKeyboard")
#define REGSTR_KEY_EBDCONFIGSYSLOCAL   TEXT("EBDConfigSysLocale")
#define REGSTR_KEY_EBDCONFIGSYSKEYBOARD   TEXT("EBDConfigSysKeyboard")


// Values under REGSTR_PATH_DRIVERSIGN and REGSTR_PATH_NONDRIVERSIGN
#define REGSTR_VAL_POLICY                     TEXT("Policy")

// Values under REGSTR_PATH_DRIVERSIGN_POLICY and REGSTR_PATH_NONDRIVERSIGN_POLICY
#define REGSTR_VAL_BEHAVIOR_ON_FAILED_VERIFY  TEXT("BehaviorOnFailedVerify")

// Types of driver signing policies (apply to both preference and policy values
// defined above)
#define DRIVERSIGN_NONE             0x00000000
#define DRIVERSIGN_WARNING          0x00000001
#define DRIVERSIGN_BLOCKING         0x00000002

//
//  Entries under REGSTR_PATH_PIFCONVERT
//
#define REGSTR_VAL_MSDOSMODE            TEXT("MSDOSMode")
#define REGSTR_VAL_MSDOSMODEDISCARD     TEXT("Discard")

//
//  Entries under REGSTR_PATH_MSDOSOPTS (global settings)
//
#define REGSTR_VAL_DOSOPTGLOBALFLAGS    TEXT("GlobalFlags")
//  Flags for GlobalFlags
#define DOSOPTGF_DEFCLEAN   0x00000001L // Default action is clean config

//
//  Entries under REGSTR_PATH_MSDOSOPTS \ OptionSubkey
//
#define REGSTR_VAL_DOSOPTFLAGS          TEXT("Flags")
#define REGSTR_VAL_OPTORDER             TEXT("Order")
#define REGSTR_VAL_CONFIGSYS            TEXT("Config.Sys")
#define REGSTR_VAL_AUTOEXEC             TEXT("Autoexec.Bat")
#define REGSTR_VAL_STDDOSOPTION         TEXT("StdOption")
#define REGSTR_VAL_DOSOPTTIP            TEXT("TipText")

//  Flags for DOSOPTFLAGS
#define DOSOPTF_DEFAULT     0x00000001L // Default enabled for clean config
#define DOSOPTF_SUPPORTED   0x00000002L // Option actually supported
#define DOSOPTF_ALWAYSUSE   0x00000004L // Always use this option
#define DOSOPTF_USESPMODE   0x00000008L // Option puts machine in Prot Mode
#define DOSOPTF_PROVIDESUMB 0x00000010L // Can load drivers high
#define DOSOPTF_NEEDSETUP   0x00000020L // Need to configure option
#define DOSOPTF_INDOSSTART  0x00000040L // Suppored by DOSSTART.BAT
#define DOSOPTF_MULTIPLE    0x00000080L // Load multiple configuration lines

//
//  Flags returned by SUGetSetSetupFlags and in the registry
//
#define SUF_FIRSTTIME   0x00000001L // First boot into Win95.
#define SUF_EXPRESS     0x00000002L // User Setup via express mode (vs customize).
#define SUF_BATCHINF    0x00000004L // Setup using batch file (MSBATCH.INF).
#define SUF_CLEAN       0x00000008L // Setup was done to a clean directory.
#define SUF_INSETUP     0x00000010L // You're in Setup.
#define SUF_NETSETUP    0x00000020L // Doing a net (workstation) setup.
#define SUF_NETHDBOOT   0x00000040L // Workstation boots from local harddrive
#define SUF_NETRPLBOOT  0x00000080L // Workstation boots via RPL (vs floppy)
#define SUF_SBSCOPYOK   0x00000100L // Can copy to LDID_SHARED (SBS)

//
//  Entries under REGSTR_PATH_VMM
//
#define REGSTR_VAL_DOSPAGER     TEXT("DOSPager")
#define REGSTR_VAL_VXDGROUPS    TEXT("VXDGroups")

//
//  Entries under REGSTR_PATH_VPOWERD
//
#define REGSTR_VAL_VPOWERDFLAGS TEXT("Flags")
#define VPDF_DISABLEPWRMGMT         0x00000001  // Don't load device
#define VPDF_FORCEAPM10MODE         0x00000002  // Always go into 1.0 mode
#define VPDF_SKIPINTELSLCHECK       0x00000004  // Don't detect Intel SL chipset
#define VPDF_DISABLEPWRSTATUSPOLL   0x00000008  // Don't poll power status
#define VPDF_DISABLERINGRESUME      0x00000010  // Don't let the modem wake the machine (APM 1.2 only)
#define VPDF_SHOWMULTIBATT          0x00000020  // Show all batteries checkbox in power control panel

//
// Entries under REGSTR_PATH_BUSINFORMATION
//
#define BIF_SHOWSIMILARDRIVERS      0x00000001  // Show similar drivers instead of all class drivers in UI.
#define BIF_RAWDEVICENEEDSDRIVER    0x00000002  // RAW device needs a driver installed.

//
//  Entries under REGSTR_PATH_VNETSUP
//
#define REGSTR_VAL_WORKGROUP TEXT("Workgroup")
#define REGSTR_VAL_DIRECTHOST TEXT("DirectHost")
#define REGSTR_VAL_FILESHARING          TEXT("FileSharing")
#define REGSTR_VAL_PRINTSHARING         TEXT("PrintSharing")

//
//  Entries under REGSTR_PATH_NWREDIR
//
#define REGSTR_VAL_FIRSTNETDRIVE        TEXT("FirstNetworkDrive")
#define REGSTR_VAL_MAXCONNECTIONS       TEXT("MaxConnections")
#define REGSTR_VAL_APISUPPORT           TEXT("APISupport")
#define REGSTR_VAL_MAXRETRY             TEXT("MaxRetry")
#define REGSTR_VAL_MINRETRY             TEXT("MinRetry")
#define REGSTR_VAL_SUPPORTLFN           TEXT("SupportLFN")
#define REGSTR_VAL_SUPPORTBURST         TEXT("SupportBurst")
#define REGSTR_VAL_SUPPORTTUNNELLING    TEXT("SupportTunnelling")
#define REGSTR_VAL_FULLTRACE            TEXT("FullTrace")
#define REGSTR_VAL_READCACHING          TEXT("ReadCaching")
#define REGSTR_VAL_SHOWDOTS             TEXT("ShowDots")
#define REGSTR_VAL_GAPTIME              TEXT("GapTime")
#define REGSTR_VAL_SEARCHMODE           TEXT("SearchMode")
#define REGSTR_VAL_SHELLVERSION     TEXT("ShellVersion")
#define REGSTR_VAL_MAXLIP           TEXT("MaxLIP")
#define REGSTR_VAL_PRESERVECASE     TEXT("PreserveCase")
#define REGSTR_VAL_OPTIMIZESFN      TEXT("OptimizeSFN")

//
//  Entries under REGSTR_PATH_NCPSERVER
//
#define REGSTR_VAL_NCP_BROWSEMASTER     TEXT("BrowseMaster")
#define REGSTR_VAL_NCP_USEPEERBROWSING  TEXT("Use_PeerBrowsing")
#define REGSTR_VAL_NCP_USESAP           TEXT("Use_Sap")

//
// Entries under REGSTR_PATH_VCOMM
//

#define REGSTR_VAL_PCCARD_POWER         TEXT("EnablePowerManagement")

//
//  Entries under REGSTR_PATH_FILESYSTEM
//
#define REGSTR_VAL_WIN31FILESYSTEM              TEXT("Win31FileSystem")
#define REGSTR_VAL_PRESERVELONGNAMES            TEXT("PreserveLongNames")
#define REGSTR_VAL_DRIVEWRITEBEHIND             TEXT("DriveWriteBehind")
#define REGSTR_VAL_ASYNCFILECOMMIT              TEXT("AsyncFileCommit")
#define REGSTR_VAL_PATHCACHECOUNT               TEXT("PathCache")
#define REGSTR_VAL_NAMECACHECOUNT               TEXT("NameCache")
#define REGSTR_VAL_CONTIGFILEALLOC              TEXT("ContigFileAllocSize")
#define REGSTR_VAL_FREESPACERATIO               TEXT("FreeSpaceRatio")
#define REGSTR_VAL_VOLIDLETIMEOUT               TEXT("VolumeIdleTimeout")
#define REGSTR_VAL_BUFFIDLETIMEOUT              TEXT("BufferIdleTimeout")
#define REGSTR_VAL_BUFFAGETIMEOUT               TEXT("BufferAgeTimeout")
#define REGSTR_VAL_NAMENUMERICTAIL              TEXT("NameNumericTail")
#define REGSTR_VAL_READAHEADTHRESHOLD           TEXT("ReadAheadThreshold")
#define REGSTR_VAL_DOUBLEBUFFER                 TEXT("DoubleBuffer")
#define REGSTR_VAL_SOFTCOMPATMODE               TEXT("SoftCompatMode")
#define REGSTR_VAL_DRIVESPINDOWN                TEXT("DriveSpinDown")
#define REGSTR_VAL_FORCEPMIO                    TEXT("ForcePMIO")
#define REGSTR_VAL_FORCERMIO                    TEXT("ForceRMIO")
#define REGSTR_VAL_LASTBOOTPMDRVS               TEXT("LastBootPMDrvs")
#define REGSTR_VAL_ACSPINDOWNPREVIOUS           TEXT("ACSpinDownPrevious")
#define REGSTR_VAL_BATSPINDOWNPREVIOUS          TEXT("BatSpinDownPrevious")
#define REGSTR_VAL_VIRTUALHDIRQ                 TEXT("VirtualHDIRQ")
#define REGSTR_VAL_SRVNAMECACHECOUNT            TEXT("ServerNameCacheMax")
#define REGSTR_VAL_SRVNAMECACHE                 TEXT("ServerNameCache")
#define REGSTR_VAL_SRVNAMECACHENETPROV          TEXT("ServerNameCacheNumNets")
#define REGSTR_VAL_AUTOMOUNT                    TEXT("AutoMountDrives")
#define REGSTR_VAL_COMPRESSIONMETHOD            TEXT("CompressionAlgorithm")
#define REGSTR_VAL_COMPRESSIONTHRESHOLD         TEXT("CompressionThreshold")
#define REGSTR_VAL_ACDRIVESPINDOWN              TEXT("ACDriveSpinDown")
#define REGSTR_VAL_BATDRIVESPINDOWN             TEXT("BatDriveSpinDown")

//
//      Entries under REGSTR_PATH_FILESYSTEM_NOVOLTRACK
//
//      A sub-key under which a variable number of variable length structures are stored.
//
//      Each structure contains an offset followed by a number of pattern bytes.
//      The pattern in each structure is compared at the specified offset within
//      the boot record at the time a volume is mounted.  If any pattern in this
//      set of patterns matches a pattern already in the boot record, VFAT will not
//      write a volume tracking serial number in the OEM_SerialNum field of the
//      boot record on the volume being mounted.
//

//
//  Entries under REGSTR_PATH_CDFS
//
#define REGSTR_VAL_CDCACHESIZE  TEXT("CacheSize")       // Number of 2K cache sectors
#define REGSTR_VAL_CDPREFETCH   TEXT("Prefetch")        // Number of 2K cache sectors for prefetching
#define REGSTR_VAL_CDPREFETCHTAIL TEXT("PrefetchTail")// Number of LRU1 prefetch sectors
#define REGSTR_VAL_CDRAWCACHE   TEXT("RawCache")        // Number of 2352-byte cache sectors
#define REGSTR_VAL_CDEXTERRORS  TEXT("ExtendedErrors")// Return extended error codes
#define REGSTR_VAL_CDSVDSENSE   TEXT("SVDSense")        // 0=PVD, 1=Kanji, 2=Unicode
#define REGSTR_VAL_CDSHOWVERSIONS TEXT("ShowVersions")// Show file version numbers
#define REGSTR_VAL_CDCOMPATNAMES TEXT("MSCDEXCompatNames")// Disable Numeric Tails on long file names
#define REGSTR_VAL_CDNOREADAHEAD TEXT("NoReadAhead")    // Disable Read Ahead if set to 1

//
//      define values for IOS devices
//
#define REGSTR_VAL_SCSI TEXT("SCSI\\")
#define REGSTR_VAL_ESDI TEXT("ESDI\\")
#define REGSTR_VAL_FLOP TEXT("FLOP\\")

//
// define defs for IOS device types and values for IOS devices
//

#define REGSTR_VAL_DISK TEXT("GenDisk")
#define REGSTR_VAL_CDROM        TEXT("GenCD")
#define REGSTR_VAL_TAPE TEXT("TAPE")
#define REGSTR_VAL_SCANNER TEXT("SCANNER")
#define REGSTR_VAL_FLOPPY       TEXT("FLOPPY")

#define REGSTR_VAL_SCSITID TEXT("SCSITargetID")
#define REGSTR_VAL_SCSILUN TEXT("SCSILUN")
#define REGSTR_VAL_REVLEVEL TEXT("RevisionLevel")
#define REGSTR_VAL_PRODUCTID TEXT("ProductId")
#define REGSTR_VAL_PRODUCTTYPE TEXT("ProductType")
#define REGSTR_VAL_DEVTYPE TEXT("DeviceType")
#define REGSTR_VAL_REMOVABLE TEXT("Removable")
#define  REGSTR_VAL_CURDRVLET TEXT("CurrentDriveLetterAssignment")
#define REGSTR_VAL_USRDRVLET TEXT("UserDriveLetterAssignment")
#define REGSTR_VAL_SYNCDATAXFER TEXT("SyncDataXfer")
#define REGSTR_VAL_AUTOINSNOTE  TEXT("AutoInsertNotification")
#define REGSTR_VAL_DISCONNECT TEXT("Disconnect")
#define REGSTR_VAL_INT13 TEXT("Int13")
#define REGSTR_VAL_PMODE_INT13 TEXT("PModeInt13")
#define REGSTR_VAL_USERSETTINGS TEXT("AdapterSettings")
#define REGSTR_VAL_NOIDE TEXT("NoIDE")

// The foll. clase name definitions should be the same as in dirkdrv.inx and
// cdrom.inx
#define REGSTR_VAL_DISKCLASSNAME        TEXT("DiskDrive")
#define REGSTR_VAL_CDROMCLASSNAME       TEXT("CDROM")

// The foll. value determines whether a port driver should be force loaded
// or not.

#define REGSTR_VAL_FORCELOAD    TEXT("ForceLoadPD")

// The foll. value determines whether or not the FIFO is used on the Floppy
// controller.

#define REGSTR_VAL_FORCEFIFO    TEXT("ForceFIFO")
#define REGSTR_VAL_FORCECL              TEXT("ForceChangeLine")

//
// Generic CLASS Entries
//
#define REGSTR_VAL_NOUSECLASS       TEXT("NoUseClass")            // Don't include this class in PnP functions
#define REGSTR_VAL_NOINSTALLCLASS   TEXT("NoInstallClass")        // Don't include this class in New Device Wizard
#define REGSTR_VAL_NODISPLAYCLASS   TEXT("NoDisplayClass")        // Don't include this class in Device Manager
#define REGSTR_VAL_SILENTINSTALL    TEXT("SilentInstall")         // Always Silent Install devices of this class.
//
//  Class Names
//
#define REGSTR_KEY_PCMCIA_CLASS     TEXT("PCMCIA")              //child of PATH_CLASS
#define REGSTR_KEY_SCSI_CLASS       TEXT("SCSIAdapter")
#define REGSTR_KEY_PORTS_CLASS      TEXT("ports")
#define REGSTR_KEY_MEDIA_CLASS      TEXT("MEDIA")
#define REGSTR_KEY_DISPLAY_CLASS    TEXT("Display")
#define REGSTR_KEY_KEYBOARD_CLASS   TEXT("Keyboard")
#define REGSTR_KEY_MOUSE_CLASS      TEXT("Mouse")
#define REGSTR_KEY_MONITOR_CLASS    TEXT("Monitor")
#define REGSTR_KEY_MODEM_CLASS      TEXT("Modem")

//
//  Values under PATH_CLASS\PCMCIA
//
#define REGSTR_VAL_PCMCIA_OPT   TEXT("Options")
#define PCMCIA_OPT_HAVE_SOCKET  0x00000001l
//#define PCMCIA_OPT_ENABLED    0x00000002l
#define PCMCIA_OPT_AUTOMEM      0x00000004l
#define PCMCIA_OPT_NO_SOUND     0x00000008l
#define PCMCIA_OPT_NO_AUDIO     0x00000010l
#define PCMCIA_OPT_NO_APMREMOVE 0x00000020l

#define REGSTR_VAL_PCMCIA_MEM   TEXT("Memory")  // Card services shared mem range
#define PCMCIA_DEF_MEMBEGIN     0x000C0000      // default 0xC0000 - 0x00FFFFFF
#define PCMCIA_DEF_MEMEND       0x00FFFFFF      // (0 - 16meg)
#define PCMCIA_DEF_MEMLEN       0x00001000      // default 4k window

#define REGSTR_VAL_PCMCIA_ALLOC TEXT("AllocMemWin")     // PCCard alloced memory Window
#define REGSTR_VAL_PCMCIA_ATAD  TEXT("ATADelay")        // ATA device config start delay

#define REGSTR_VAL_PCMCIA_SIZ   TEXT("MinRegionSize") // Minimum region size
#define PCMCIA_DEF_MIN_REGION   0x00010000      // 64K minimum region size

// Values in LPTENUM keys
#define REGSTR_VAL_P1284MDL     TEXT("Model")
#define REGSTR_VAL_P1284MFG     TEXT("Manufacturer")

//
//  Values under PATH_CLASS\ISAPNP
//
#define REGSTR_VAL_ISAPNP               TEXT("ISAPNP")  // ISAPNP VxD name
#define REGSTR_VAL_ISAPNP_RDP_OVERRIDE  TEXT("RDPOverRide")     // ReadDataPort OverRide

//
//  Values under PATH_CLASS\PCI
//
#define REGSTR_VAL_PCI                  TEXT("PCI")             // PCI VxD name
#define REGSTR_PCI_OPTIONS              TEXT("Options") // Possible PCI options
#define REGSTR_PCI_DUAL_IDE             TEXT("PCIDualIDE")      // Dual IDE flag
#define PCI_OPTIONS_USE_BIOS            0x00000001l
#define PCI_OPTIONS_USE_IRQ_STEERING    0x00000002l

//
//  Values under PATH_CLASS\AGPxxxx
//
//  note:  These flags affect standard AGP capabilities,
//         and are set in agplib
//
#define AGP_FLAG_NO_1X_RATE             0x00000001l
#define AGP_FLAG_NO_2X_RATE             0x00000002l
#define AGP_FLAG_NO_4X_RATE             0x00000004l
#define AGP_FLAG_NO_8X_RATE             0x00000008l
#define AGP_FLAG_REVERSE_INITIALIZATION 0x00000080l

#define AGP_FLAG_NO_SBA_ENABLE          0x00000100l

//
// AGP flags > AGP_SPECIAL_TARGET are platform specific
//
#define AGP_FLAG_SPECIAL_TARGET         0x000FFFFFl
#define AGP_FLAG_SPECIAL_RESERVE        0x000F0000l

//
// Detection related values
//
#define REGSTR_KEY_CRASHES      TEXT("Crashes") // key of REGSTR_PATH_DETECT
#define REGSTR_KEY_DANGERS      TEXT("Dangers") // key of REGSTR_PATH_DETECT
#define REGSTR_KEY_DETMODVARS   TEXT("DetModVars")      // key of REGSTR_PATH_DETECT
#define REGSTR_KEY_NDISINFO     TEXT("NDISInfo")        // key of netcard hw entry
#define REGSTR_VAL_PROTINIPATH  TEXT("ProtIniPath")     // protocol.ini path
#define REGSTR_VAL_RESOURCES    TEXT("Resources")       // resources of crash func.
#define REGSTR_VAL_CRASHFUNCS   TEXT("CrashFuncs")      // detfunc caused the crash
#define REGSTR_VAL_CLASS        TEXT("Class")   // device class
#define REGSTR_VAL_DEVDESC      TEXT("DeviceDesc")      // device description
#define REGSTR_VAL_BOOTCONFIG   TEXT("BootConfig")      // detected configuration
#define REGSTR_VAL_DETFUNC      TEXT("DetFunc") // specifies detect mod/func.
#define REGSTR_VAL_DETFLAGS     TEXT("DetFlags")        // detection flags
#define REGSTR_VAL_COMPATIBLEIDS TEXT("CompatibleIDs") //value of enum\dev\inst
#define REGSTR_VAL_DETCONFIG    TEXT("DetConfig")       // detected configuration
#define REGSTR_VAL_VERIFYKEY    TEXT("VerifyKey")       // key used in verify mode
#define REGSTR_VAL_COMINFO      TEXT("ComInfo") // com info. for serial mouse
#define REGSTR_VAL_INFNAME      TEXT("InfName") // INF filename
#define REGSTR_VAL_CARDSPECIFIC TEXT("CardSpecific")    // Netcard specific info (WORD)
#define REGSTR_VAL_NETOSTYPE    TEXT("NetOSType")       // NetOS type associate w/ card
#define REGSTR_DATA_NETOS_NDIS  TEXT("NDIS")            // Data of REGSTR_VAL_NETOSTYPE
#define REGSTR_DATA_NETOS_ODI   TEXT("ODI")             // Data of REGSTR_VAL_NETOSTYPE
#define REGSTR_DATA_NETOS_IPX   TEXT("IPX")             // Data of REGSTR_VAL_NETOSTYPE
#define REGSTR_VAL_MFG      TEXT("Mfg")
#define REGSTR_VAL_SCAN_ONLY_FIRST      TEXT("ScanOnlyFirstDrive")      // used with IDE driver
#define REGSTR_VAL_SHARE_IRQ    TEXT("ForceIRQSharing") // used with IDE driver
#define REGSTR_VAL_NONSTANDARD_ATAPI    TEXT("NonStandardATAPI")        // used with IDE driver
#define REGSTR_VAL_IDE_FORCE_SERIALIZE  TEXT("ForceSerialization")      // used with IDE driver
#define REGSTR_VAL_MAX_HCID_LEN 1024            // Maximum hardware/compat ID len
#define REGSTR_VAL_HWREV            TEXT("HWRevision")
#define REGSTR_VAL_ENABLEINTS  TEXT("EnableInts")
//
// Bit values of REGSTR_VAL_DETFLAGS
//
#define REGDF_NOTDETIO          0x00000001      //cannot detect I/O resource
#define REGDF_NOTDETMEM         0x00000002      //cannot detect mem resource
#define REGDF_NOTDETIRQ         0x00000004      //cannot detect IRQ resource
#define REGDF_NOTDETDMA         0x00000008      //cannot detect DMA resource
#define REGDF_NOTDETALL         (REGDF_NOTDETIO | REGDF_NOTDETMEM | REGDF_NOTDETIRQ | REGDF_NOTDETDMA)
#define REGDF_NEEDFULLCONFIG    0x00000010      //stop devnode if lack resource
#define REGDF_GENFORCEDCONFIG   0x00000020      //also generate forceconfig
#define REGDF_NODETCONFIG       0x00008000      //don't write detconfig to reg.
#define REGDF_CONFLICTIO        0x00010000      //I/O res. in conflict
#define REGDF_CONFLICTMEM       0x00020000      //mem res. in conflict
#define REGDF_CONFLICTIRQ       0x00040000      //IRQ res. in conflict
#define REGDF_CONFLICTDMA       0x00080000      //DMA res. in conflict
#define REGDF_CONFLICTALL       (REGDF_CONFLICTIO | REGDF_CONFLICTMEM | REGDF_CONFLICTIRQ | REGDF_CONFLICTDMA)
#define REGDF_MAPIRQ2TO9        0x00100000      //IRQ2 has been mapped to 9
#define REGDF_NOTVERIFIED       0x80000000      //previous device unverified

//
//  Values in REGSTR_KEY_SYSTEMBOARD
//
#define REGSTR_VAL_APMBIOSVER           TEXT("APMBiosVer")
#define REGSTR_VAL_APMFLAGS             TEXT("APMFlags")
#define REGSTR_VAL_SLSUPPORT            TEXT("SLSupport")
#define REGSTR_VAL_MACHINETYPE          TEXT("MachineType")
#define REGSTR_VAL_SETUPMACHINETYPE TEXT("SetupMachineType")
#define REGSTR_MACHTYPE_UNKNOWN         TEXT("Unknown")
#define REGSTR_MACHTYPE_IBMPC           TEXT("IBM PC")
#define REGSTR_MACHTYPE_IBMPCJR         TEXT("IBM PCjr")
#define REGSTR_MACHTYPE_IBMPCCONV       TEXT("IBM PC Convertible")
#define REGSTR_MACHTYPE_IBMPCXT         TEXT("IBM PC/XT")
#define REGSTR_MACHTYPE_IBMPCXT_286     TEXT("IBM PC/XT 286")
#define REGSTR_MACHTYPE_IBMPCAT         TEXT("IBM PC/AT")
#define REGSTR_MACHTYPE_IBMPS2_25       TEXT("IBM PS/2-25")
#define REGSTR_MACHTYPE_IBMPS2_30_286   TEXT("IBM PS/2-30 286")
#define REGSTR_MACHTYPE_IBMPS2_30       TEXT("IBM PS/2-30")
#define REGSTR_MACHTYPE_IBMPS2_50       TEXT("IBM PS/2-50")
#define REGSTR_MACHTYPE_IBMPS2_50Z      TEXT("IBM PS/2-50Z")
#define REGSTR_MACHTYPE_IBMPS2_55SX     TEXT("IBM PS/2-55SX")
#define REGSTR_MACHTYPE_IBMPS2_60       TEXT("IBM PS/2-60")
#define REGSTR_MACHTYPE_IBMPS2_65SX     TEXT("IBM PS/2-65SX")
#define REGSTR_MACHTYPE_IBMPS2_70       TEXT("IBM PS/2-70")
#define REGSTR_MACHTYPE_IBMPS2_P70      TEXT("IBM PS/2-P70")
#define REGSTR_MACHTYPE_IBMPS2_70_80    TEXT("IBM PS/2-70/80")
#define REGSTR_MACHTYPE_IBMPS2_80       TEXT("IBM PS/2-80")
#define REGSTR_MACHTYPE_IBMPS2_90       TEXT("IBM PS/2-90")
#define REGSTR_MACHTYPE_IBMPS1          TEXT("IBM PS/1")
#define REGSTR_MACHTYPE_PHOENIX_PCAT    TEXT("Phoenix PC/AT Compatible")
#define REGSTR_MACHTYPE_HP_VECTRA       TEXT("HP Vectra")
#define REGSTR_MACHTYPE_ATT_PC          TEXT("AT&T PC")
#define REGSTR_MACHTYPE_ZENITH_PC       TEXT("Zenith PC")

#define REGSTR_VAL_APMMENUSUSPEND       TEXT("APMMenuSuspend")
#define APMMENUSUSPEND_DISABLED         0                   // always disabled
#define APMMENUSUSPEND_ENABLED          1                   // always enabled
#define APMMENUSUSPEND_UNDOCKED         2                   // enabled undocked
#define APMMENUSUSPEND_NOCHANGE     0x80        // bitflag - cannot change setting via UI

#define REGSTR_VAL_APMACTIMEOUT         TEXT("APMACTimeout")
#define REGSTR_VAL_APMBATTIMEOUT        TEXT("APMBatTimeout")
#define APMTIMEOUT_DISABLED             0

#define REGSTR_VAL_APMSHUTDOWNPOWER TEXT("APMShutDownPower")

#define REGSTR_VAL_BUSTYPE          TEXT("BusType")
#define REGSTR_VAL_CPU              TEXT("CPU")
#define REGSTR_VAL_NDP              TEXT("NDP")
#define REGSTR_VAL_PNPBIOSVER       TEXT("PnPBIOSVer")
#define REGSTR_VAL_PNPSTRUCOFFSET   TEXT("PnPStrucOffset")
#define REGSTR_VAL_PCIBIOSVER       TEXT("PCIBIOSVer")
#define REGSTR_VAL_HWMECHANISM      TEXT("HWMechanism")
#define REGSTR_VAL_LASTPCIBUSNUM    TEXT("LastPCIBusNum")
#define REGSTR_VAL_CONVMEM          TEXT("ConvMem")
#define REGSTR_VAL_EXTMEM           TEXT("ExtMem")
#define REGSTR_VAL_COMPUTERNAME     TEXT("ComputerName")
#define REGSTR_VAL_BIOSNAME         TEXT("BIOSName")
#define REGSTR_VAL_BIOSVERSION      TEXT("BIOSVersion")
#define REGSTR_VAL_BIOSDATE         TEXT("BIOSDate")
#define REGSTR_VAL_MODEL            TEXT("Model")
#define REGSTR_VAL_SUBMODEL         TEXT("Submodel")
#define REGSTR_VAL_REVISION         TEXT("Revision")

//
//  Values used in the LPT(ECP) device entry
//
#define REGSTR_VAL_FIFODEPTH            TEXT("FIFODepth")
#define REGSTR_VAL_RDINTTHRESHOLD       TEXT("RDIntThreshold")
#define REGSTR_VAL_WRINTTHRESHOLD       TEXT("WRIntThreshold")

//used in enum\xxx\<devname>\<instname>
#define REGSTR_VAL_PRIORITY     TEXT("Priority")
#define REGSTR_VAL_DRIVER       TEXT("Driver")          //
#define REGSTR_VAL_FUNCDESC     TEXT("FunctionDesc")            //
#define REGSTR_VAL_FORCEDCONFIG TEXT("ForcedConfig")            //
#define REGSTR_VAL_CONFIGFLAGS  TEXT("ConfigFlags")             // (binary ULONG)
#define REGSTR_VAL_CSCONFIGFLAGS TEXT("CSConfigFlags")  // (binary ULONG)

#define CONFIGFLAG_DISABLED             0x00000001      // Set if disabled
#define CONFIGFLAG_REMOVED              0x00000002      // Set if a present hardware enum device deleted
#define CONFIGFLAG_MANUAL_INSTALL       0x00000004      // Set if the devnode was manually installed
#define CONFIGFLAG_IGNORE_BOOT_LC       0x00000008      // Set if skip the boot config
#define CONFIGFLAG_NET_BOOT             0x00000010      // Load this devnode when in net boot
#define CONFIGFLAG_REINSTALL            0x00000020      // Redo install
#define CONFIGFLAG_FAILEDINSTALL        0x00000040      // Failed the install
#define CONFIGFLAG_CANTSTOPACHILD       0x00000080      // Can't stop/remove a single child
#define CONFIGFLAG_OKREMOVEROM          0x00000100      // Can remove even if rom.
#define CONFIGFLAG_NOREMOVEEXIT         0x00000200      // Don't remove at exit.
#define CONFIGFLAG_FINISH_INSTALL       0x00000400      // Complete install for devnode running 'raw'
#define CONFIGFLAG_NEEDS_FORCED_CONFIG  0x00000800      // This devnode requires a forced config
#if defined(REMOTE_BOOT)
#define CONFIGFLAG_NETBOOT_CARD         0x00001000      // This is the remote boot network card
#endif // defined(REMOTE_BOOT)
#define CONFIGFLAG_PARTIAL_LOG_CONF     0x00002000      // This device has a partial logconfig
#define CONFIGFLAG_SUPPRESS_SURPRISE    0x00004000      // Set if unsafe removals should be ignored
#define CONFIGFLAG_VERIFY_HARDWARE      0x00008000      // Set if hardware should be tested for logo failures

#define CSCONFIGFLAG_BITS               0x00000007      // OR of below bits
#define CSCONFIGFLAG_DISABLED           0x00000001      // Set if
#define CSCONFIGFLAG_DO_NOT_CREATE      0x00000002      // Set if
#define CSCONFIGFLAG_DO_NOT_START       0x00000004      // Set if

#define DMSTATEFLAG_APPLYTOALL      0x00000001  // Set if Apply To All check box is checked

//
// Special devnodes name
//
#define REGSTR_VAL_ROOT_DEVNODE         TEXT("HTREE\\ROOT\\0")
#define REGSTR_VAL_RESERVED_DEVNODE     TEXT("HTREE\\RESERVED\\0")
#define REGSTR_PATH_READDATAPORT        REGSTR_KEY_ISAENUM TEXT("\\ReadDataPort\\0")

//
// Multifunction definitions
//
#define REGSTR_PATH_MULTI_FUNCTION              TEXT("MF")
#define REGSTR_VAL_RESOURCE_MAP                 TEXT("ResourceMap")
#define REGSTR_PATH_CHILD_PREFIX                TEXT("Child")
#define NUM_RESOURCE_MAP                        256
#define REGSTR_VAL_MF_FLAGS                     TEXT("MFFlags")
#define MF_FLAGS_EVEN_IF_NO_RESOURCE            0x00000001
#define MF_FLAGS_NO_CREATE_IF_NO_RESOURCE       0x00000002
#define MF_FLAGS_FILL_IN_UNKNOWN_RESOURCE       0x00000004
#define MF_FLAGS_CREATE_BUT_NO_SHOW_DISABLED    0x00000008

//
// EISA multi functions add-on
//
#ifndef NEC_98
#define REGSTR_VAL_EISA_RANGES          TEXT("EISARanges")
#define REGSTR_VAL_EISA_FUNCTIONS       TEXT("EISAFunctions")
#define REGSTR_VAL_EISA_FUNCTIONS_MASK  TEXT("EISAFunctionsMask")
#define REGSTR_VAL_EISA_FLAGS           TEXT("EISAFlags")
#define REGSTR_VAL_EISA_SIMULATE_INT15  TEXT("EISASimulateInt15")
#else // ifdef NEC_98
#define REGSTR_VAL_EISA_RANGES          TEXT("NESARanges")
#define REGSTR_VAL_EISA_FUNCTIONS       TEXT("NESAFunctions")
#define REGSTR_VAL_EISA_FUNCTIONS_MASK  TEXT("NESAFunctionsMask")
#define REGSTR_VAL_EISA_FLAGS           TEXT("NESAFlags")
#define REGSTR_VAL_EISA_SIMULATE_INT15  TEXT("NESASimulateInt15")
#endif // ifdef NEC_98
#define EISAFLAG_NO_IO_MERGE            0x00000001
#define EISAFLAG_SLOT_IO_FIRST          0x00000002
#define EISA_NO_MAX_FUNCTION            0xFF
#define NUM_EISA_RANGES                 4


//
//  Driver entries
//
#define REGSTR_VAL_DRVDESC      TEXT("DriverDesc")      // value of enum\dev\inst\DRV
#define REGSTR_VAL_DEVLOADER    TEXT("DevLoader")       // value of DRV
#define REGSTR_VAL_STATICVXD    TEXT("StaticVxD")       // value of DRV
#define REGSTR_VAL_PROPERTIES   TEXT("Properties")      // value of DRV
#define REGSTR_VAL_MANUFACTURER TEXT("Manufacturer")
#define REGSTR_VAL_EXISTS       TEXT("Exists")  // value of HCC\HW\ENUM\ROOT\dev\inst
#define REGSTR_VAL_CMENUMFLAGS  TEXT("CMEnumFlags")     // (binary ULONG)
#define REGSTR_VAL_CMDRIVFLAGS  TEXT("CMDrivFlags")     // (binary ULONG)
#define REGSTR_VAL_ENUMERATOR   TEXT("Enumerator")      // value of DRV
#define REGSTR_VAL_DEVICEDRIVER TEXT("DeviceDriver")    // value of DRV
#define REGSTR_VAL_PORTNAME     TEXT("PortName")        // VCOMM uses this for it's port names
#define REGSTR_VAL_INFPATH      TEXT("InfPath")
#define REGSTR_VAL_INFSECTION   TEXT("InfSection")
#define REGSTR_VAL_INFSECTIONEXT TEXT("InfSectionExt")
#define REGSTR_VAL_POLLING      TEXT("Polling")             // SCSI specific
#define REGSTR_VAL_DONTLOADIFCONFLICT TEXT("DontLoadIfConflict")  // SCSI specific
#define REGSTR_VAL_PORTSUBCLASS TEXT("PortSubClass")
#define REGSTR_VAL_NETCLEAN TEXT("NetClean") // Driver required for NetClean boot
#define REGSTR_VAL_IDE_NO_SERIALIZE TEXT("IDENoSerialize") // IDE specific
#define REGSTR_VAL_NOCMOSORFDPT TEXT("NoCMOSorFDPT")       // IDE specific
#define REGSTR_VAL_COMVERIFYBASE TEXT("COMVerifyBase")     // VCD specific
#define REGSTR_VAL_MATCHINGDEVID TEXT("MatchingDeviceId")
#define REGSTR_VAL_DRIVERDATE   TEXT("DriverDate")      // value of DRV
#define REGSTR_VAL_DRIVERDATEDATA TEXT("DriverDateData")// value of DRV
#define REGSTR_VAL_DRIVERVERSION TEXT("DriverVersion")  // value of DRV
#define REGSTR_VAL_LOCATION_INFORMATION_OVERRIDE    TEXT("LocationInformationOverride")  // value of DRV


//
//  Driver keys
//
#define REGSTR_KEY_OVERRIDE     TEXT("Override")        // key under the software section

//used by CONFIGMG
#define REGSTR_VAL_CONFIGMG     TEXT("CONFIGMG")        // Config Manager VxD name
#define REGSTR_VAL_SYSDM        TEXT("SysDM")           // The device installer DLL
#define REGSTR_VAL_SYSDMFUNC    TEXT("SysDMFunc")       // The device installer DLL function
#define REGSTR_VAL_PRIVATE      TEXT("Private") // The private library
#define REGSTR_VAL_PRIVATEFUNC  TEXT("PrivateFunc")     // The private library function
#define REGSTR_VAL_DETECT       TEXT("Detect")  // The detection library
#define REGSTR_VAL_DETECTFUNC   TEXT("DetectFunc")      // The detection library function
#define REGSTR_VAL_ASKFORCONFIG TEXT("AskForConfig")    // The AskForConfig library
#define REGSTR_VAL_ASKFORCONFIGFUNC TEXT("AskForConfigFunc") // The AskForConfig library function
#define REGSTR_VAL_WAITFORUNDOCK TEXT("WaitForUndock")  // The WaitForUndock library
#define REGSTR_VAL_WAITFORUNDOCKFUNC TEXT("WaitForUndockFunc") // The WaitForUndock library function
#define REGSTR_VAL_REMOVEROMOKAY TEXT("RemoveRomOkay")  // The RemoveRomOkay library
#define REGSTR_VAL_REMOVEROMOKAYFUNC TEXT("RemoveRomOkayFunc") // The RemoveRomOkay library function

//used in IDCONFIGDB
#define REGSTR_VAL_CURCONFIG    TEXT("CurrentConfig")           //value of idconfigdb
#define REGSTR_VAL_FRIENDLYNAME TEXT("FriendlyName")            //value of idconfigdb
#define REGSTR_VAL_CURRENTCONFIG TEXT("CurrentConfig")  //value of idconfigdb
#define REGSTR_VAL_MAP          TEXT("Map")                     //value of idconfigdb
#define REGSTR_VAL_ID           TEXT("CurrentID")               //value of idconfigdb
#define REGSTR_VAL_DOCKED       TEXT("CurrentDockedState")      //value of idconfigdb
#define REGSTR_VAL_CHECKSUM     TEXT("CurrentChecksum") //value of idconfigdb
#define REGSTR_VAL_HWDETECT     TEXT("HardwareDetect")  //value of idconfigdb
#define REGSTR_VAL_INHIBITRESULTS TEXT("InhibitResults")        //value of idconfigdb

//used in HKEY_CURRENT_CONFIG
#define REGSTR_VAL_PROFILEFLAGS TEXT("ProfileFlags")    // value of HKEY_CURRENT_CONFIG

//used in PCMCIA
#define REGSTR_KEY_PCMCIA       TEXT("PCMCIA\\")        //PCMCIA dev ID prefix
#define REGSTR_KEY_PCUNKNOWN    TEXT("UNKNOWN_MANUFACTURER")    //PCMCIA dev ID manuf
#define REGSTR_VAL_PCSSDRIVER   TEXT("Driver")  //value of DRV
#define REGSTR_KEY_PCMTD        TEXT("MTD-")            //MTD dev ID component
#define REGSTR_VAL_PCMTDRIVER   TEXT("MTD")             //value of Mem Tech DRV

//used in hardware\enum\dev\inst by Device Installer
#define REGSTR_VAL_HARDWAREID    TEXT("HardwareID")      //value of enum\dev\inst

//value names under class brach REGSTR_KEY_CLASS + class name
// and for the drivers REGSTR_KEY_CLASS\classname\xxxx
#define REGSTR_VAL_INSTALLER          TEXT("Installer")         // 16-bit class installer module/entry point
#define REGSTR_VAL_INSTALLER_32       TEXT("Installer32")       // 32-bit class installer module/entry point
#define REGSTR_VAL_INSICON            TEXT("Icon")              // value of class\name
#define REGSTR_VAL_ENUMPROPPAGES      TEXT("EnumPropPages")     // For Class/Device Properties (16-bit)
#define REGSTR_VAL_ENUMPROPPAGES_32   TEXT("EnumPropPages32")   // For Class/Device Properties (32-bit)
#define REGSTR_VAL_BASICPROPERTIES    TEXT("BasicProperties")   // For CPL basic Properties (16-bit)
#define REGSTR_VAL_BASICPROPERTIES_32 TEXT("BasicProperties32") // For CPL basic Properties (32-bit)
#define REGSTR_VAL_COINSTALLERS_32    TEXT("CoInstallers32")    // Device-specific co-installer multi-sz list (32-bit)
#define REGSTR_VAL_PRIVATEPROBLEM     TEXT("PrivateProblem")    // For Handling Private Problems

// names used for display driver set information
#define REGSTR_KEY_CURRENT      TEXT("Current") // current mode information
#define REGSTR_KEY_DEFAULT      TEXT("Default") // default configuration
#define REGSTR_KEY_MODES        TEXT("Modes")   // modes subtree

#define REGSTR_VAL_MODE         TEXT("Mode")            // default mode
#define REGSTR_VAL_BPP          TEXT("BPP")             // bits per pixel
#define REGSTR_VAL_HRES         TEXT("HRes")            // horizontal resolution
#define REGSTR_VAL_VRES         TEXT("VRes")            // vertical resolution
#define REGSTR_VAL_FONTSIZE     TEXT("FontSize")        // used in default or override
#define REGSTR_VAL_DRV          TEXT("drv")             // the driver file
#define REGSTR_VAL_GRB          TEXT("grb")             // the grabber file
#define REGSTR_VAL_VDD          TEXT("vdd")             // vdds used here
#define REGSTR_VAL_VER          TEXT("Ver")
#define REGSTR_VAL_MAXRES       TEXT("MaxResolution") // max res for monitors
#define REGSTR_VAL_DPMS         TEXT("DPMS")            // DPMS enabled
#define REGSTR_VAL_RESUMERESET  TEXT("ResumeReset")   // need reset on resume

#define REGSTR_VAL_DESCRIPTION TEXT("Description")

// keys in fontsize tree
#define REGSTR_KEY_SYSTEM       TEXT("System")  // entries for system.ini
#define REGSTR_KEY_USER         TEXT("User")            // entries for win.ini
#define REGSTR_VAL_DPI          TEXT("dpi")             // dpi of fontsize

//
// Used by PCIC socket services
//
#define REGSTR_VAL_PCICOPTIONS  TEXT("PCICOptions")     // Binary DWORD.  IRQ mask in
                                                // low word.  # skts in high
#ifndef NEC_98
#define PCIC_DEFAULT_IRQMASK    0x4EB8          // Default IRQ masks
#else // ifdef NEC_98
#define PCIC_DEFAULT_IRQMASK    0x1468          // Default IRQ masks
#endif // ifdef NEC_98
#define PCIC_DEFAULT_NUMSOCKETS 0               // 0 = Automatic detection
#define REGSTR_VAL_PCICIRQMAP   TEXT("PCICIRQMap")      // Binary 16 byte IRQ map table

// names used for control panel entries
#define REGSTR_PATH_APPEARANCE  TEXT("Control Panel\\Appearance")
#define REGSTR_PATH_LOOKSCHEMES TEXT("Control Panel\\Appearance\\Schemes")
#define REGSTR_VAL_CUSTOMCOLORS TEXT("CustomColors")

#define REGSTR_PATH_SCREENSAVE          TEXT("Control Panel\\Desktop")
#define REGSTR_VALUE_USESCRPASSWORD TEXT("ScreenSaveUsePassword")
#define REGSTR_VALUE_SCRPASSWORD    TEXT("ScreenSave_Data")

#define REGSTR_VALUE_LOWPOWERTIMEOUT    TEXT("ScreenSaveLowPowerTimeout")
#define REGSTR_VALUE_POWEROFFTIMEOUT    TEXT("ScreenSavePowerOffTimeout")
#define REGSTR_VALUE_LOWPOWERACTIVE     TEXT("ScreenSaveLowPowerActive")
#define REGSTR_VALUE_POWEROFFACTIVE     TEXT("ScreenSavePowerOffActive")

// used for Windows applets
#define REGSTR_PATH_WINDOWSAPPLETS TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets")

//
// system tray.  Flag values defined in systrap.h
//
#define REGSTR_PATH_SYSTRAY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\SysTray")
#define REGSTR_VAL_SYSTRAYSVCS TEXT("Services")
#define REGSTR_VAL_SYSTRAYBATFLAGS TEXT("PowerFlags")
#define REGSTR_VAL_SYSTRAYPCCARDFLAGS TEXT("PCMCIAFlags")

//
// Used by system networking components to store per-user values.
// All keys here are under HKCU.
//
#define REGSTR_PATH_NETWORK_USERSETTINGS        TEXT("Network")

#define REGSTR_KEY_NETWORK_PERSISTENT           TEXT("\\Persistent")
#define REGSTR_KEY_NETWORK_RECENT               TEXT("\\Recent")
#define REGSTR_VAL_REMOTE_PATH                  TEXT("RemotePath")
#define REGSTR_VAL_USER_NAME                    TEXT("UserName")
#define REGSTR_VAL_PROVIDER_NAME                TEXT("ProviderName")
#define REGSTR_VAL_CONNECTION_TYPE              TEXT("ConnectionType")
#define REGSTR_VAL_UPGRADE                      TEXT("Upgrade")

#define REGSTR_KEY_LOGON TEXT("\\Logon")
#define REGSTR_VAL_MUSTBEVALIDATED  TEXT("MustBeValidated")
#define REGSTR_VAL_RUNLOGINSCRIPT       TEXT("ProcessLoginScript")

//
// NetworkProvider entries. These entries are under
// REGSTR_PATH_SERVICES\\xxx\\NetworkProvider
//
#define REGSTR_KEY_NETWORKPROVIDER TEXT("\\NetworkProvider")
#define REGSTR_PATH_NW32NETPROVIDER REGSTR_PATH_SERVICES TEXT("\\NWNP32") REGSTR_KEY_NETWORKPROVIDER
#define REGSTR_PATH_MS32NETPROVIDER REGSTR_PATH_SERVICES TEXT("\\MSNP32") REGSTR_KEY_NETWORKPROVIDER
#define REGSTR_VAL_AUTHENT_AGENT TEXT("AuthenticatingAgent")

//
// Entries under REGSTR_PATH_REALMODENET
//
#define REGSTR_VAL_PREFREDIR TEXT("PreferredRedir")
#define REGSTR_VAL_AUTOSTART TEXT("AutoStart")
#define REGSTR_VAL_AUTOLOGON TEXT("AutoLogon")
#define REGSTR_VAL_NETCARD TEXT("Netcard")
#define REGSTR_VAL_TRANSPORT TEXT("Transport")
#define REGSTR_VAL_DYNAMIC TEXT("Dynamic")
#define REGSTR_VAL_TRANSITION TEXT("Transition")
#define REGSTR_VAL_STATICDRIVE TEXT("StaticDrive")
#define REGSTR_VAL_LOADHI TEXT("LoadHi")
#define REGSTR_VAL_LOADRMDRIVERS TEXT("LoadRMDrivers")
#define REGSTR_VAL_SETUPN TEXT("SetupN")
#define REGSTR_VAL_SETUPNPATH TEXT("SetupNPath")

//
// Entries under REGSTR_PATH_CVNETWORK
//
#define REGSTR_VAL_WRKGRP_FORCEMAPPING TEXT("WrkgrpForceMapping")
#define REGSTR_VAL_WRKGRP_REQUIRED TEXT("WrkgrpRequired")

//
// NT-compatible place where the name of the currently logged-on user is stored.
//
#define REGSTR_PATH_CURRENT_CONTROL_SET TEXT("System\\CurrentControlSet\\Control")
#define REGSTR_VAL_CURRENT_USER                 TEXT("Current User")

// section where password providers are installed (each provider has subkey under this key)
#define REGSTR_PATH_PWDPROVIDER         TEXT("System\\CurrentControlSet\\Control\\PwdProvider")
#define REGSTR_VAL_PWDPROVIDER_PATH TEXT("ProviderPath")
#define REGSTR_VAL_PWDPROVIDER_DESC TEXT("Description")
#define REGSTR_VAL_PWDPROVIDER_CHANGEPWD TEXT("ChangePassword")
#define REGSTR_VAL_PWDPROVIDER_CHANGEPWDHWND TEXT("ChangePasswordHwnd")
#define REGSTR_VAL_PWDPROVIDER_GETPWDSTATUS TEXT("GetPasswordStatus")
#define REGSTR_VAL_PWDPROVIDER_ISNP TEXT("NetworkProvider")
#define REGSTR_VAL_PWDPROVIDER_CHANGEORDER TEXT("ChangeOrder")

//
// Used by administrator configuration tool and various components who enforce
// policies.
//
#define REGSTR_PATH_POLICIES    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies")

// used to control remote update of administrator policies
#define REGSTR_PATH_UPDATE              TEXT("System\\CurrentControlSet\\Control\\Update")
#define REGSTR_VALUE_ENABLE             TEXT("Enable")
#define REGSTR_VALUE_VERBOSE    TEXT("Verbose")
#define REGSTR_VALUE_NETPATH    TEXT("NetworkPath")
#define REGSTR_VALUE_DEFAULTLOC TEXT("UseDefaultNetLocation")

//
//      Entries under REGSTR_PATH_POLICIES
//
#define REGSTR_KEY_NETWORK              TEXT("Network")
#define REGSTR_KEY_SYSTEM               TEXT("System")
#define REGSTR_KEY_PRINTERS             TEXT("Printers")
#define REGSTR_KEY_WINOLDAPP            TEXT("WinOldApp")

// (following are values REG_DWORD, legal values 0 or 1, treat as TEXT("0") if value not present)
// policies under NETWORK key
#define REGSTR_VAL_NOFILESHARING                TEXT("NoFileSharing") // TEXT("1") prevents server from loading
#define REGSTR_VAL_NOPRINTSHARING               TEXT("NoPrintSharing")
#define REGSTR_VAL_NOFILESHARINGCTRL    TEXT("NoFileSharingControl") // TEXT("1") removes sharing ui
#define REGSTR_VAL_NOPRINTSHARINGCTRL   TEXT("NoPrintSharingControl")
#define REGSTR_VAL_HIDESHAREPWDS                TEXT("HideSharePwds") // TEXT("1") hides share passwords with asterisks
#define REGSTR_VAL_DISABLEPWDCACHING    TEXT("DisablePwdCaching") // TEXT("1") disables caching
#define REGSTR_VAL_ALPHANUMPWDS                 TEXT("AlphanumPwds") // TEXT("1") forces alphanumeric passwords
#define REGSTR_VAL_NETSETUP_DISABLE                     TEXT("NoNetSetup")
#define REGSTR_VAL_NETSETUP_NOCONFIGPAGE        TEXT("NoNetSetupConfigPage")
#define REGSTR_VAL_NETSETUP_NOIDPAGE            TEXT("NoNetSetupIDPage")
#define REGSTR_VAL_NETSETUP_NOSECURITYPAGE      TEXT("NoNetSetupSecurityPage")
#define REGSTR_VAL_SYSTEMCPL_NOVIRTMEMPAGE  TEXT("NoVirtMemPage")
#define REGSTR_VAL_SYSTEMCPL_NODEVMGRPAGE   TEXT("NoDevMgrPage")
#define REGSTR_VAL_SYSTEMCPL_NOCONFIGPAGE       TEXT("NoConfigPage")
#define REGSTR_VAL_SYSTEMCPL_NOFILESYSPAGE      TEXT("NoFileSysPage")
#define REGSTR_VAL_DISPCPL_NODISPCPL            TEXT("NoDispCPL")
#define REGSTR_VAL_DISPCPL_NOBACKGROUNDPAGE TEXT("NoDispBackgroundPage")
#define REGSTR_VAL_DISPCPL_NOSCRSAVPAGE TEXT("NoDispScrSavPage")
#define REGSTR_VAL_DISPCPL_NOAPPEARANCEPAGE TEXT("NoDispAppearancePage")
#define REGSTR_VAL_DISPCPL_NOSETTINGSPAGE TEXT("NoDispSettingsPage")
#define REGSTR_VAL_SECCPL_NOSECCPL                      TEXT("NoSecCPL")
#define REGSTR_VAL_SECCPL_NOPWDPAGE                     TEXT("NoPwdPage")
#define REGSTR_VAL_SECCPL_NOADMINPAGE           TEXT("NoAdminPage")
#define REGSTR_VAL_SECCPL_NOPROFILEPAGE         TEXT("NoProfilePage")
#define REGSTR_VAL_PRINTERS_HIDETABS            TEXT("NoPrinterTabs")
#define REGSTR_VAL_PRINTERS_NODELETE            TEXT("NoDeletePrinter")
#define REGSTR_VAL_PRINTERS_NOADD                       TEXT("NoAddPrinter")
#define REGSTR_VAL_WINOLDAPP_DISABLED           TEXT("Disabled")
#define REGSTR_VAL_WINOLDAPP_NOREALMODE         TEXT("NoRealMode")
#define REGSTR_VAL_NOENTIRENETWORK                      TEXT("NoEntireNetwork")
#define REGSTR_VAL_NOWORKGROUPCONTENTS          TEXT("NoWorkgroupContents")

// (following are values REG_DWORD, legal values 0 or 1, treat as TEXT("1") if value not present)
// policies under Policies\SYSTEM key
#define REGSTR_VAL_UNDOCK_WITHOUT_LOGON         TEXT("UndockWithoutLogon")

// REG_DWORD, 0=off, otherwise value is minimum # of chars to allow in password
#define REGSTR_VAL_MINPWDLEN                    TEXT("MinPwdLen")
// REG_DWORD, 0=off, otherwise value is # of days for pwd to expire
#define REGSTR_VAL_PWDEXPIRATION                TEXT("PwdExpiration")

#define REGSTR_VAL_WIN31PROVIDER                TEXT("Win31Provider") // REG_SZ

// policies under SYSTEM key
#define REGSTR_VAL_DISABLEREGTOOLS              TEXT("DisableRegistryTools")

#define REGSTR_PATH_WINLOGON    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Winlogon")
#define REGSTR_VAL_LEGALNOTICECAPTION   TEXT("LegalNoticeCaption")      // REG_SZ
#define REGSTR_VAL_LEGALNOTICETEXT              TEXT("LegalNoticeText")         // REG_SZ
#define REGSTR_VAL_DRIVE_SPINDOWN               TEXT("NoDispSpinDown")

#define REGSTR_VAL_RESTRICTRUN  TEXT("RestrictRun")
//
//  Entries in policy file.  (Won't be in local registry, only policy hive)
#define REGSTR_KEY_POL_USERS            TEXT("Users")
#define REGSTR_KEY_POL_COMPUTERS        TEXT("Computers")
#define REGSTR_KEY_POL_USERGROUPS       TEXT("UserGroups")
#define REGSTR_KEY_POL_DEFAULT          TEXT(".default")
#define REGSTR_KEY_POL_USERGROUPDATA TEXT("GroupData\\UserGroups\\Priority")

//
//      Entries for time zone information under LOCAL_MACHINE
//
#define REGSTR_PATH_TIMEZONE        TEXT("System\\CurrentControlSet\\Control\\TimeZoneInformation")
#define REGSTR_VAL_TZBIAS           TEXT("Bias")
#define REGSTR_VAL_TZDLTBIAS        TEXT("DaylightBias")
#define REGSTR_VAL_TZSTDBIAS        TEXT("StandardBias")
#define REGSTR_VAL_TZACTBIAS        TEXT("ActiveTimeBias")
#define REGSTR_VAL_TZDLTFLAG        TEXT("DaylightFlag")
#define REGSTR_VAL_TZSTDSTART       TEXT("StandardStart")
#define REGSTR_VAL_TZDLTSTART       TEXT("DaylightStart")
#define REGSTR_VAL_TZDLTNAME        TEXT("DaylightName")
#define REGSTR_VAL_TZSTDNAME        TEXT("StandardName")
#define REGSTR_VAL_TZNOCHANGESTART  TEXT("NoChangeStart")
#define REGSTR_VAL_TZNOCHANGEEND    TEXT("NoChangeEnd")
#define REGSTR_VAL_TZNOAUTOTIME     TEXT("DisableAutoDaylightTimeSet")

//
//      Entries for floating point processor existence under LOCAL_MACHINE
//
#define REGSTR_PATH_FLOATINGPOINTPROCESSOR TEXT("HARDWARE\\DESCRIPTION\\System\\FloatingPointProcessor")
#define REGSTR_PATH_FLOATINGPOINTPROCESSOR0 TEXT("HARDWARE\\DESCRIPTION\\System\\FloatingPointProcessor\\0")


//
//      Entries for computer name under LOCAL_MACHINE
//
#define REGSTR_PATH_COMPUTRNAME TEXT("System\\CurrentControlSet\\Control\\ComputerName\\ComputerName")
#define REGSTR_VAL_COMPUTRNAME TEXT("ComputerName")

//      Entry so that we force a reboot on shutdown / single instance dos app
#define REGSTR_PATH_SHUTDOWN TEXT("System\\CurrentControlSet\\Control\\Shutdown")
#define REGSTR_VAL_FORCEREBOOT     TEXT("ForceReboot")
#define REGSTR_VAL_SETUPPROGRAMRAN TEXT("SetupProgramRan")
#define REGSTR_VAL_DOES_POLLING    TEXT("PollingSupportNeeded")

//
//      Entries for known system DLLs under LOCAL_MACHINE
//
//      The VAL keys here are the actual DLL names (FOO.DLL)
//
#define REGSTR_PATH_KNOWNDLLS   TEXT("System\\CurrentControlSet\\Control\\SessionManager\\KnownDLLs")
#define REGSTR_PATH_KNOWN16DLLS TEXT("System\\CurrentControlSet\\Control\\SessionManager\\Known16DLLs")

//      Entries here for system dlls we need to version check in case overwritten
#define REGSTR_PATH_CHECKVERDLLS TEXT("System\\CurrentControlSet\\Control\\SessionManager\\CheckVerDLLs")
#define REGSTR_PATH_WARNVERDLLS  TEXT("System\\CurrentControlSet\\Control\\SessionManager\\WarnVerDLLs")

//      Entries here for app ini files we (msgsrv32) need to hack
#define REGSTR_PATH_HACKINIFILE  TEXT("System\\CurrentControlSet\\Control\\SessionManager\\HackIniFiles")

//      Keys here for bad applications we want to warn the user about before running
#define REGSTR_PATH_CHECKBADAPPS TEXT("System\\CurrentControlSet\\Control\\SessionManager\\CheckBadApps")

//      Keys here for applications we need to patch
#define REGSTR_PATH_APPPATCH TEXT("System\\CurrentControlSet\\Control\\SessionManager\\AppPatches")

#define REGSTR_PATH_CHECKBADAPPS400 TEXT("System\\CurrentControlSet\\Control\\SessionManager\\CheckBadApps400")

#define REGSTR_PATH_SHELLSERVICEOBJECT          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObject")
#define REGSTR_PATH_SHELLSERVICEOBJECTDELAYED   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObjectDelayLoad")

//
//      Entries for known system VxDs under LOCAL_MACHINE
//
//      The VAL keys here are the full path names of VxDs (c:\app\vapp.vxd)
//      It is suggested that the keynames be the same as the module name of
//      the VxD.
//      This section is used to dyna-load VxDs with
//      CreateFile(\\.\vxd_regstr_keyname).
//

#define REGSTR_PATH_KNOWNVXDS   TEXT("System\\CurrentControlSet\\Control\\SessionManager\\KnownVxDs")

//
// Entries for values in uninstaller keys under REGSTR_PATH_UNINSTALL \ appname
//
#define REGSTR_VAL_UNINSTALLER_DISPLAYNAME     TEXT("DisplayName")
#define REGSTR_VAL_UNINSTALLER_COMMANDLINE     TEXT("UninstallString")

//
// Entries for values in uninstaller keys under REGSTR_PATH_REINSTALL \ instanceid
//
#define REGSTR_VAL_REINSTALL_DISPLAYNAME        TEXT("DisplayName")
#define REGSTR_VAL_REINSTALL_STRING             TEXT("ReinstallString")
#define REGSTR_VAL_REINSTALL_DEVICEINSTANCEIDS  TEXT("DeviceInstanceIds")

//
//      Entries for known per user settings: Under HKEY_CURRENT_USER
//
#define REGSTR_PATH_DESKTOP     REGSTR_PATH_SCREENSAVE
#define REGSTR_PATH_MOUSE           TEXT("Control Panel\\Mouse")
#define REGSTR_PATH_KEYBOARD    TEXT("Control Panel\\Keyboard")
#define REGSTR_PATH_COLORS          TEXT("Control Panel\\Colors")
#define REGSTR_PATH_SOUND           TEXT("Control Panel\\Sound")
#define REGSTR_PATH_METRICS         TEXT("Control Panel\\Desktop\\WindowMetrics")
#define REGSTR_PATH_ICONS       TEXT("Control Panel\\Icons")
#define REGSTR_PATH_CURSORS     TEXT("Control Panel\\Cursors")
#define REGSTR_PATH_CHECKDISK   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\Check Drive")
#define REGSTR_PATH_CHECKDISKSET    TEXT("Settings")
#define REGSTR_PATH_CHECKDISKUDRVS  TEXT("NoUnknownDDErrDrvs")
//
//  Entries under REGSTR_PATH_FAULT
//
#define REGSTR_PATH_FAULT               TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Fault")
#define REGSTR_VAL_FAULT_LOGFILE        TEXT("LogFile")

//
//  Entries under REGSTR_PATH_AEDEBUG
//
#define REGSTR_PATH_AEDEBUG             TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug")
#define REGSTR_VAL_AEDEBUG_DEBUGGER     TEXT("Debugger")
#define REGSTR_VAL_AEDEBUG_AUTO         TEXT("Auto")

//
//  Entries under REGSTR_PATH_GRPCONV
//
#define REGSTR_PATH_GRPCONV     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\GrpConv")

//
//  Entries under the RegItem key in a shell namespace
//
#define REGSTR_VAL_REGITEMDELETEMESSAGE TEXT("Removal Message")

//
//  Entries for the Drives Tools page
//
//  NOTE that these items are not recorded for removable drives. These
//  keys record X=DSKTLSYSTEMTIME where X is the drive letter. Since
//  these tools actually work on the disk in the drive, as opposed to
//  the drive itself, it is pointless to record them on a removable media
//  since if a different disk is inserted in the drive, the data is
//  meaningless.
//
#define REGSTR_PATH_LASTCHECK           TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\LastCheck")
#define REGSTR_PATH_LASTOPTIMIZE        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\LastOptimize")
#define REGSTR_PATH_LASTBACKUP          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\LastBackup")
//
// The above 3 keys record with the registry value of the drive letter
// a SYSTEMTIME structure
//

//
// Entries under HKEY_LOCAL_MACHINE for Check Drive specific stuff
//
#define REGSTR_PATH_CHKLASTCHECK        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\Check Drive\\LastCheck")
#define REGSTR_PATH_CHKLASTSURFAN       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\Check Drive\\LastSurfaceAnalysis")

#ifndef _IN_KERNEL_

//
// The above 2 keys record the following binary structure which is
// a system time structure with the addition of a result code field.
// Note that the time part of REGSTR_PATH_CHKLASTCHECK is effectively
// identical to REGSTR_PATH_LASTCHECK under the explorer key
//
typedef struct _DSKTLSYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
    WORD wResult;
} DSKTLSYSTEMTIME, *PDSKTLSYSTEMTIME, *LPDSKTLSYSTEMTIME;

#endif

//
// The following are defines for the wResult field
//
#define DTRESULTOK      0       // Operation was successful, no errors
#define DTRESULTFIX     1       // Operation was successful, errors were found
                                //   but all were fixed.
#define DTRESULTPROB    2       // Operation was not successful or errors
                                //   were found and some or all were not fixed.
#define DTRESULTPART    3       // Operation was partially completed but was
                                //   terminated either by the user or an error.

//
//  Entries for persistent shares
//
#define REGSTR_KEY_SHARES             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Network\\LanMan")
#define REGSTR_VAL_SHARES_FLAGS   TEXT("Flags")
#define REGSTR_VAL_SHARES_TYPE    TEXT("Type")
#define REGSTR_VAL_SHARES_PATH    TEXT("Path")
#define REGSTR_VAL_SHARES_REMARK  TEXT("Remark")
#define REGSTR_VAL_SHARES_RW_PASS TEXT("Parm1")
#define REGSTR_VAL_SHARES_RO_PASS TEXT("Parm2")

//
//      Entries for printer settings under LOCAL_MACHINE
//
#define REGSTR_PATH_PRINT           TEXT("System\\CurrentControlSet\\Control\\Print")
#define REGSTR_PATH_PRINTERS        TEXT("System\\CurrentControlSet\\Control\\Print\\Printers")
#define REGSTR_PATH_PROVIDERS       TEXT("System\\CurrentControlSet\\Control\\Print\\Providers")
#define REGSTR_PATH_MONITORS        TEXT("System\\CurrentControlSet\\Control\\Print\\Monitors")
#define REGSTR_PATH_ENVIRONMENTS    TEXT("System\\CurrentControlSet\\Control\\Print\\Environments")
#define REGSTR_VAL_START_ON_BOOT    TEXT("StartOnBoot")
#define REGSTR_VAL_PRINTERS_MASK    TEXT("PrintersMask")
#define REGSTR_VAL_DOS_SPOOL_MASK   TEXT("DOSSpoolMask")
#define REGSTR_KEY_CURRENT_ENV      TEXT("\\Windows 4.0")
#define REGSTR_KEY_DRIVERS          TEXT("\\Drivers")
#define REGSTR_KEY_PRINT_PROC       TEXT("\\Print Processors")

//
// Entries for MultiMedia under HKEY_CURRENT_USER
//
#define REGSTR_PATH_EVENTLABELS     TEXT("AppEvents\\EventLabels")
#define REGSTR_PATH_SCHEMES         TEXT("AppEvents\\Schemes")
#define REGSTR_PATH_APPS            REGSTR_PATH_SCHEMES TEXT("\\Apps")
#define REGSTR_PATH_APPS_DEFAULT    REGSTR_PATH_SCHEMES TEXT("\\Apps\\.Default")
#define REGSTR_PATH_NAMES           REGSTR_PATH_SCHEMES TEXT("\\Names")
#define REGSTR_PATH_MULTIMEDIA      REGSTR_PATH_SETUP TEXT("\\Multimedia")
#define REGSTR_PATH_MULTIMEDIA_AUDIO TEXT("Software\\Microsoft\\Multimedia\\Audio")
#define REGSTR_PATH_MULTIMEDIA_AUDIO_IMAGES REGSTR_PATH_MULTIMEDIA_AUDIO TEXT("\\Images")

//
// Entries for MultiMedia under HKEY_LOCAL_MACHINE
//
#define REGSTR_PATH_MEDIARESOURCES  REGSTR_PATH_CURRENT_CONTROL_SET TEXT("\\MediaResources")
#define REGSTR_PATH_MEDIAPROPERTIES REGSTR_PATH_CURRENT_CONTROL_SET TEXT("\\MediaProperties")
#define REGSTR_PATH_PRIVATEPROPERTIES REGSTR_PATH_MEDIAPROPERTIES TEXT("\\PrivateProperties")
#define REGSTR_PATH_PUBLICPROPERTIES REGSTR_PATH_MEDIAPROPERTIES TEXT("\\PublicProperties")

// joysticks
#define REGSTR_PATH_JOYOEM           REGSTR_PATH_PRIVATEPROPERTIES TEXT("\\Joystick\\OEM")
#define REGSTR_PATH_JOYCONFIG        REGSTR_PATH_MEDIARESOURCES TEXT("\\Joystick")
#define REGSTR_KEY_JOYCURR           TEXT("CurrentJoystickSettings")
#define REGSTR_KEY_JOYSETTINGS       TEXT("JoystickSettings")

// joystick values found under REGSTR_PATH_JOYCONFIG
#define REGSTR_VAL_JOYUSERVALUES     TEXT("JoystickUserValues")
#define REGSTR_VAL_JOYCALLOUT        TEXT("JoystickCallout")

// joystick values found under REGSTR_KEY_JOYCURR and REGSTR_KEY_JOYSETTINGS
#define REGSTR_VAL_JOYNCONFIG        TEXT("Joystick%dConfiguration")
#define REGSTR_VAL_JOYNOEMNAME       TEXT("Joystick%dOEMName")
#define REGSTR_VAL_JOYNOEMCALLOUT    TEXT("Joystick%dOEMCallout")

// joystick values found under keys under REGSTR_PATH_JOYOEM
#define REGSTR_VAL_JOYOEMCALLOUT        TEXT("OEMCallout")
#define REGSTR_VAL_JOYOEMNAME           TEXT("OEMName")
#define REGSTR_VAL_JOYOEMDATA           TEXT("OEMData")
#define REGSTR_VAL_JOYOEMXYLABEL        TEXT("OEMXYLabel")
#define REGSTR_VAL_JOYOEMZLABEL         TEXT("OEMZLabel")
#define REGSTR_VAL_JOYOEMRLABEL         TEXT("OEMRLabel")
#define REGSTR_VAL_JOYOEMPOVLABEL       TEXT("OEMPOVLabel")
#define REGSTR_VAL_JOYOEMULABEL         TEXT("OEMULabel")
#define REGSTR_VAL_JOYOEMVLABEL         TEXT("OEMVLabel")
#define REGSTR_VAL_JOYOEMTESTMOVEDESC   TEXT("OEMTestMoveDesc")
#define REGSTR_VAL_JOYOEMTESTBUTTONDESC TEXT("OEMTestButtonDesc")
#define REGSTR_VAL_JOYOEMTESTMOVECAP    TEXT("OEMTestMoveCap")
#define REGSTR_VAL_JOYOEMTESTBUTTONCAP  TEXT("OEMTestButtonCap")
#define REGSTR_VAL_JOYOEMTESTWINCAP     TEXT("OEMTestWinCap")
#define REGSTR_VAL_JOYOEMCALCAP         TEXT("OEMCalCap")
#define REGSTR_VAL_JOYOEMCALWINCAP      TEXT("OEMCalWinCap")
#define REGSTR_VAL_JOYOEMCAL1           TEXT("OEMCal1")
#define REGSTR_VAL_JOYOEMCAL2           TEXT("OEMCal2")
#define REGSTR_VAL_JOYOEMCAL3           TEXT("OEMCal3")
#define REGSTR_VAL_JOYOEMCAL4           TEXT("OEMCal4")
#define REGSTR_VAL_JOYOEMCAL5           TEXT("OEMCal5")
#define REGSTR_VAL_JOYOEMCAL6           TEXT("OEMCal6")
#define REGSTR_VAL_JOYOEMCAL7           TEXT("OEMCal7")
#define REGSTR_VAL_JOYOEMCAL8           TEXT("OEMCal8")
#define REGSTR_VAL_JOYOEMCAL9           TEXT("OEMCal9")
#define REGSTR_VAL_JOYOEMCAL10          TEXT("OEMCal10")
#define REGSTR_VAL_JOYOEMCAL11          TEXT("OEMCal11")
#define REGSTR_VAL_JOYOEMCAL12          TEXT("OEMCal12")

// Image values under REGSTR_PATH_MULTIMEDIA_AUDIO_IMAGES
#define REGSTR_VAL_AUDIO_BITMAP TEXT("bitmap")
#define REGSTR_VAL_AUDIO_ICON TEXT("icon")

//
// Entries for Device Installer under HKEY_CURRENT_USER
//
#define REGSTR_PATH_DEVICEINSTALLER     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Device Installer")

// Device Installer values found under REGSTR_PATH_DEVICEINSTALLER
#define REGSTR_VAL_SEARCHOPTIONS        TEXT("SearchOptions")

// BiosInfo defines.
#ifndef _IN_KERNEL_

#define REGSTR_PATH_BIOSINFO            TEXT("System\\CurrentControlSet\\Control\\BiosInfo")

#else

#define REGSTR_PATH_BIOSINFO            L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\BiosInfo"

#endif

// Pci Irq Routing registry defines.
#ifndef _IN_KERNEL_

#define REGSTR_PATH_PCIIR               TEXT("System\\CurrentControlSet\\Control\\Pnp\\PciIrqRouting")
#define REGSTR_VAL_OPTIONS              TEXT("Options")
#define REGSTR_VAL_STAT                 TEXT("Status")
#define REGSTR_VAL_TABLE_STAT           TEXT("TableStatus")
#define REGSTR_VAL_MINIPORT_STAT        TEXT("MiniportStatus")

#else

#define REGSTR_PATH_PCIIR               L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Pnp\\PciIrqRouting"
#define REGSTR_VAL_OPTIONS              L"Options"
#define REGSTR_VAL_STAT                 L"Status"
#define REGSTR_VAL_TABLE_STAT           L"TableStatus"
#define REGSTR_VAL_MINIPORT_STAT        L"MiniportStatus"

#endif

// Pci Irq Routing Option values.
#define PIR_OPTION_ENABLED                  0x00000001
#define PIR_OPTION_REGISTRY                 0x00000002
#define PIR_OPTION_MSSPEC                   0x00000004
#define PIR_OPTION_REALMODE                 0x00000008
#define PIR_OPTION_DEFAULT                  0x0000000f

// Pci Irq Routing Status values.
#define PIR_STATUS_ERROR                    0x00000000
#define PIR_STATUS_ENABLED                  0x00000001
#define PIR_STATUS_DISABLED                 0x00000002
#define PIR_STATUS_MAX                      0x00000003

#define PIR_STATUS_TABLE_REGISTRY           0x00000000
#define PIR_STATUS_TABLE_MSSPEC                     0x00000001
#define PIR_STATUS_TABLE_REALMODE                   0x00000002
#define PIR_STATUS_TABLE_NONE                   0x00000003
#define PIR_STATUS_TABLE_ERROR                      0x00000004
#define PIR_STATUS_TABLE_BAD                        0x00000005
#define PIR_STATUS_TABLE_SUCCESS            0x00000006
#define PIR_STATUS_TABLE_MAX                0x00000007

#define PIR_STATUS_MINIPORT_NORMAL                  0x00000000
#define PIR_STATUS_MINIPORT_COMPATIBLE      0x00000001
#define PIR_STATUS_MINIPORT_OVERRIDE        0x00000002
#define PIR_STATUS_MINIPORT_NONE                    0x00000003
#define PIR_STATUS_MINIPORT_ERROR                   0x00000004
#define PIR_STATUS_MINIPORT_NOKEY                   0x00000005
#define PIR_STATUS_MINIPORT_SUCCESS                 0x00000006
#define PIR_STATUS_MINIPORT_INVALID                 0x00000007
#define PIR_STATUS_MINIPORT_MAX             0x00000008

//
// entries for LastKnownGood
// each value name under this key is SubPath/File (note reversal of '\\' to '/')
// each value is an indication of post-processing to be done after files have been recovered
// LASTGOOD_OPERATION bits indicate the primary post-processing operation
// remaining bits may be used as flags (allocate flags from highest bits first)
// a value of 0 is the same as the value being omitted, ie, no post processing.
//

#define REGSTR_PATH_LASTGOOD            TEXT("System\\LastKnownGoodRecovery\\LastGood")
#define REGSTR_PATH_LASTGOODTMP         TEXT("System\\LastKnownGoodRecovery\\LastGood.Tmp")

#define LASTGOOD_OPERATION              0x000000FF // operation to perform
#define LASTGOOD_OPERATION_NOPOSTPROC   0x00000000 // no post-processing
#define LASTGOOD_OPERATION_DELETE       0x00000001 // Delete file during recovery

#endif  //_INC_REGSTR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\replapi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993-1999.
//
//  File:       ReplAPI.h
//
//  Contents:   Public Replication APIs and Structures.
//
//  History:    15-jul-93  PeterCo     created
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifndef _REPLAPI_H_
#define _REPLAPI_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

EXPORTDEF STDAPI ReplCreateObject(
    const WCHAR *pwszMachine,
    const WCHAR *pwszOraRelativeName,
    const CLSID& clsid,
    REFIID itf,
    PSECURITY_ATTRIBUTES psa,
    void** ppitf);

EXPORTDEF STDAPI ReplDeleteObject(
    const WCHAR *pwszMachine,
    const WCHAR *pwszOraRelativeName);

#define REPL_REPLICATE_NONE             (0x00)
#define REPL_REPLICATE_ASYNC            (0x01)  // replicate asynchronously
#define REPL_REPLICATE_META_DATA_ONLY   (0x02)  // replicate meta data only
                                                // until all urgent changes
                                                // have been applied.

#define REPL_REPLICATE_ALL_FLAGS ( REPL_REPLICATE_ASYNC | \
                                   REPL_REPLICATE_META_DATA_ONLY )

EXPORTDEF STDAPI ReplReplicate(
    const WCHAR *pwszMachine,
    const WCHAR *pwszOraRelativeReplicaConnection,
    DWORD       options);

EXPORTDEF STDAPI ReplReplicateSingleObject(
    const WCHAR *pDfsPathOraMachine,
    const WCHAR *pDfsPathSrcObj,
    const WCHAR *pDfsPathSrcMachine,
    const WCHAR *pDfsPathDstObject,
    const WCHAR *pDfsPathDstMachine,
    BOOL         bCreateDstIfRequired);

EXPORTDEF STDAPI ReplMetaDataReplicate(
    const WCHAR *pwszMachine,                   // ORA to pull to
    const WCHAR *pwszSource,                    // ORA to pull from
    const WCHAR *pwszOraRelativeReplicaSet);

#define REPL_URGENT_NONE              (0x00)    // no flags
#define REPL_URGENT_NO_HYSTERESIS     (0x01)    // exclude from hysteresis calc.
#define REPL_URGENT_TRIGGER_IMMEDIATE (0x02)    // force immediate urgent cycle

#define REPL_URGENT_ALL_FLAGS ( REPL_URGENT_NONE |                   \
                                REPL_URGENT_NO_HYSTERESIS |          \
                                REPL_URGENT_TRIGGER_IMMEDIATE )

EXPORTDEF STDAPI ReplUrgentChangeNotify(
    REFCLSID     clsid,                     // should match CLSID on root IStg
    DWORD        flags,                     // ORing of URGENT_NOTIFY_*
    PVOID        reserved,                  // must be NULL
    IStorage     *pRootStorage);            // must have STGM_READWRITE access

EXPORTDEF STDAPI ReplValidatePath(
    const WCHAR *pDfsPathMachine,   // in
    const WCHAR *pLocalWin32Path,   // in
    WCHAR       **ppDfsPath,        // out - Dfs path to stuff into replica
                                    // object's "root" field
    HRESULT     *phr);              // out - S_OK indicates path is valid,
                                    // FAILED(*phr) identifies why if invalid

EXPORTDEF STDAPI ReplPropagateMetaData(
    const WCHAR *pDfsPathMachine,   // in - which ORA is to do the propagating
                                    // i.e. machine where changes were made
    const WCHAR *pwszRSet);         // in - name of replica set where changes
                                    // were made - NULL means check all RSets

#ifdef __cplusplus
}
#endif

#endif  // _REPLAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\resapi.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    resapi.h

Abstract:

    This module defines the interface exported by Windows Clusters resources.

Revision History:

--*/

#ifndef _RESAPI_DEFINES_
#define _RESAPI_DEFINES_

#if _MSC_VER > 1000
#pragma once
#endif

#include <windows.h>
#include <winsvc.h>
#include <clusapi.h>
#include <stdio.h>

#ifdef __cplusplus
extern "C" {
#endif

#define IN
#define OUT

//
// Definitions for entrypoints exported by a resource DLL.
//
#define STARTUP_ROUTINE "Startup"

#define CLRES_V1_FUNCTION_SIZE   sizeof(CLRES_V1_FUNCTIONS)
#define CLRES_VERSION_V1_00    0x100

#define CLRES_V1_FUNCTION_TABLE( _Name,                     \
                                 _Version,                  \
                                 _Prefix,                   \
                                 _Arbitrate,                \
                                 _Release,                  \
                                 _ResControl,               \
                                 _ResTypeControl            \
                                 )                          \
CLRES_FUNCTION_TABLE _Name = { CLRES_V1_FUNCTION_SIZE,      \
                               _Version,                    \
                               _Prefix##Open,               \
                               _Prefix##Close,              \
                               _Prefix##Online,             \
                               _Prefix##Offline,            \
                               _Prefix##Terminate,          \
                               _Prefix##LooksAlive,         \
                               _Prefix##IsAlive,            \
                               _Arbitrate,                  \
                               _Release,                    \
                               _ResControl,                 \
                               _ResTypeControl }

#endif // ifndef _RESAPI_DEFINES_

#ifndef _RESAPI_
#define _RESAPI_

//
// Define a RESID
//

typedef PVOID RESID;

//
// Define a RESOURCE_HANDLE
//

typedef HANDLE   RESOURCE_HANDLE;

//
// Define the Resource Status structure.
//

typedef struct RESOURCE_STATUS {
    CLUSTER_RESOURCE_STATE  ResourceState;
    DWORD           CheckPoint;
    DWORD           WaitHint;
    HANDLE          EventHandle;
} RESOURCE_STATUS, *PRESOURCE_STATUS;


#define ResUtilInitializeResourceStatus( _resource_status_ ) \
    ZeroMemory( _resource_status_, sizeof(RESOURCE_STATUS) )

//
// Define Resource DLL callback method for updating the state of a resource.
//

typedef
DWORD
(_stdcall *PSET_RESOURCE_STATUS_ROUTINE) (
    IN RESOURCE_HANDLE ResourceHandle,
    IN PRESOURCE_STATUS ResourceStatus
    );

//
// Define Resource DLL callback method for notifying that a quorum
// resource DLL failed to hold the quorum resource.
//
typedef
VOID
(_stdcall *PQUORUM_RESOURCE_LOST) (
    IN RESOURCE_HANDLE Resource
    );

//
// Define Resource DLL callback method for logging events.
//
typedef enum LOG_LEVEL {
    LOG_INFORMATION,
    LOG_WARNING,
    LOG_ERROR,
    LOG_SEVERE
} LOG_LEVEL, *PLOG_LEVEL;

typedef
VOID
(_stdcall *PLOG_EVENT_ROUTINE) (
    IN RESOURCE_HANDLE ResourceHandle,
    IN LOG_LEVEL LogLevel,
    IN LPCWSTR FormatString,
    ...
    );

typedef
RESID
(_stdcall *POPEN_ROUTINE) (
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    );

typedef
VOID
(_stdcall *PCLOSE_ROUTINE) (
    IN RESID Resource
    );

typedef
DWORD
(_stdcall *PONLINE_ROUTINE) (
    IN RESID Resource,
    IN OUT LPHANDLE EventHandle
    );

typedef
DWORD
(_stdcall *POFFLINE_ROUTINE) (
    IN RESID Resource
    );

typedef
VOID
(_stdcall *PTERMINATE_ROUTINE) (
    IN RESID Resource
    );

typedef
BOOL
(_stdcall *PIS_ALIVE_ROUTINE) (
    IN RESID Resource
    );

typedef
BOOL
(_stdcall *PLOOKS_ALIVE_ROUTINE) (
    IN RESID Resource
    );

typedef
DWORD
(_stdcall *PARBITRATE_ROUTINE) (
    IN RESID Resource,
    IN PQUORUM_RESOURCE_LOST LostQuorumResource
    );

typedef
DWORD
(_stdcall *PRELEASE_ROUTINE) (
    IN RESID Resource
    );

typedef
DWORD
(_stdcall *PRESOURCE_CONTROL_ROUTINE) (
    IN RESID Resource,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

typedef
DWORD
(_stdcall *PRESOURCE_TYPE_CONTROL_ROUTINE) (
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

typedef enum _RESOURCE_EXIT_STATE {
    ResourceExitStateContinue,
    ResourceExitStateTerminate,
    ResourceExitStateMax
} RESOURCE_EXIT_STATE;


//***************************************************************
//
// Define the Function Table Format
//
//***************************************************************

//
// Version 1 Resource DLL Interface definition
//
typedef struct CLRES_V1_FUNCTIONS {
    POPEN_ROUTINE Open;
    PCLOSE_ROUTINE Close;
    PONLINE_ROUTINE Online;
    POFFLINE_ROUTINE Offline;
    PTERMINATE_ROUTINE Terminate;
    PLOOKS_ALIVE_ROUTINE LooksAlive;
    PIS_ALIVE_ROUTINE IsAlive;
    PARBITRATE_ROUTINE Arbitrate;
    PRELEASE_ROUTINE Release;
    PRESOURCE_CONTROL_ROUTINE ResourceControl;
    PRESOURCE_TYPE_CONTROL_ROUTINE ResourceTypeControl;
} CLRES_V1_FUNCTIONS, *PCLRES_V1_FUNCTIONS;

//
// Resource DLL Function Table definition
//
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union
typedef struct CLRES_FUNCTION_TABLE {
    DWORD   TableSize;
    DWORD   Version;
    union {
        CLRES_V1_FUNCTIONS V1Functions;
    };
} CLRES_FUNCTION_TABLE, *PCLRES_FUNCTION_TABLE;
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default : 4201 ) // nonstandard extension used : nameless struct/union
#endif

//
// Define the Resource DLL Startup routine. This is the only routine
// that should be exported from a resource DLL.
//

//
// Calculate the byte offset of a field in a structure of type type.
//

#ifndef FIELD_OFFSET
#define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
#endif

//
// large ints need more space than what was originally allocated.
//
typedef struct RESUTIL_LARGEINT_DATA {
    LARGE_INTEGER   Default;
    LARGE_INTEGER   Minimum;
    LARGE_INTEGER   Maximum;
} RESUTIL_LARGEINT_DATA, *PRESUTIL_LARGEINT_DATA;

typedef struct RESUTIL_ULARGEINT_DATA {
    ULARGE_INTEGER  Default;
    ULARGE_INTEGER  Minimum;
    ULARGE_INTEGER  Maximum;
} RESUTIL_ULARGEINT_DATA, *PRESUTIL_ULARGEINT_DATA;

//
// Property list structures and functions
//
typedef struct RESUTIL_PROPERTY_ITEM {
    LPWSTR  Name;               // Property name
    LPWSTR  KeyName;            // Name of value in cluster database
    DWORD   Format;             // Format: REG_SZ, REG_DWORD, etc.
    union {
        DWORD_PTR               DefaultPtr;
        DWORD                   Default;     // Default value
        LPVOID                  lpDefault;
        PRESUTIL_LARGEINT_DATA  LargeIntData;
        PRESUTIL_ULARGEINT_DATA ULargeIntData;
    };
    DWORD   Minimum;            // Minimum value
    DWORD   Maximum;            // Maximum value
    DWORD   Flags;              // Flags for this item
#define RESUTIL_PROPITEM_READ_ONLY  0x00000001  // Property is read-only
#define RESUTIL_PROPITEM_REQUIRED   0x00000002  // Property is required
#define RESUTIL_PROPITEM_SIGNED     0x00000004  // Numeric property is signed (defaults to unsigned)

    DWORD   Offset;             // Byte offset to value in parameter block
                                //   Assumes MULTI_SZ and BINARY parameters
                                //   are LPWSTRs followed by DWORDs for length
} RESUTIL_PROPERTY_ITEM, *PRESUTIL_PROPERTY_ITEM;


typedef
DWORD
(_stdcall *PSTARTUP_ROUTINE) (
    IN LPCWSTR ResourceType,
    IN DWORD MinVersionSupported,
    IN DWORD MaxVersionSupported,
    IN PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus,
    IN PLOG_EVENT_ROUTINE LogEvent,
    OUT PCLRES_FUNCTION_TABLE *FunctionTable
    );

//
// Define layout of shared memory used for tracking Resource Monitor state.
//
typedef enum RESOURCE_MONITOR_STATE {
    RmonInitializing,
    RmonIdle,
    RmonStartingResource,
    RmonInitializingResource,
    RmonOnlineResource,
    RmonOfflineResource,
    RmonShutdownResource,
    RmonDeletingResource,
    RmonIsAlivePoll,
    RmonLooksAlivePoll,
    RmonArbitrateResource,
    RmonReleaseResource,
    RmonResourceControl,
    RmonResourceTypeControl,
    RmonTerminateResource,
    RmonDeadlocked
} RESOURCE_MONITOR_STATE;

typedef struct MONITOR_STATE {
    LARGE_INTEGER LastUpdate;
    RESOURCE_MONITOR_STATE State;
    HANDLE ActiveResource;
    BOOL   ResmonStop;
} MONITOR_STATE, *PMONITOR_STATE;


//
// Resource Utility Routines
//

DWORD
WINAPI
ResUtilStartResourceService(
    IN LPCWSTR pszServiceName,
    OUT LPSC_HANDLE phServiceHandle
    );

DWORD
WINAPI
ResUtilVerifyResourceService(
    IN LPCWSTR pszServiceName
    );

DWORD
WINAPI
ResUtilStopResourceService(
    IN LPCWSTR pszServiceName
    );

DWORD
WINAPI
ResUtilVerifyService(
    IN SC_HANDLE hServiceHandle
    );

DWORD
WINAPI
ResUtilStopService(
    IN SC_HANDLE hServiceHandle
    );

DWORD
WINAPI
ResUtilCreateDirectoryTree(
    IN LPCWSTR pszPath
    );

BOOL
WINAPI
ResUtilIsPathValid(
    IN LPCWSTR pszPath
    );

DWORD
WINAPI
ResUtilEnumProperties(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT LPWSTR pszOutProperties,
    IN DWORD cbOutPropertiesSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ResUtilEnumPrivateProperties(
    IN HKEY hkeyClusterKey,
    OUT LPWSTR pszOutProperties,
    IN DWORD cbOutPropertiesSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ResUtilGetProperties(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID pOutPropertyList,
    IN DWORD cbOutPropertyListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ResUtilGetAllProperties(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID pOutPropertyList,
    IN DWORD cbOutPropertyListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ResUtilGetPrivateProperties(
    IN HKEY hkeyClusterKey,
    OUT PVOID pOutPropertyList,
    IN DWORD cbOutPropertyListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ResUtilGetPropertySize(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    IN OUT LPDWORD pcbOutPropertyListSize,
    IN OUT LPDWORD pnPropertyCount
    );

DWORD
WINAPI
ResUtilGetProperty(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    OUT PVOID * pOutPropertyItem,
    IN OUT LPDWORD pcbOutPropertyItemSize
    );

DWORD
WINAPI
ResUtilVerifyPropertyTable(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN BOOL bAllowUnknownProperties,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    OUT OPTIONAL LPBYTE pOutParams
    );

DWORD
WINAPI
ResUtilSetPropertyTable(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN BOOL bAllowUnknownProperties,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    OUT OPTIONAL LPBYTE pOutParams
    );

DWORD
WINAPI
ResUtilSetPropertyTableEx(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN BOOL bAllowUnknownProperties,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    IN BOOL bForceWrite,
    OUT OPTIONAL LPBYTE pOutParams
    );

DWORD
WINAPI
ResUtilSetPropertyParameterBlock(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN const LPBYTE pInParams,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    OUT OPTIONAL LPBYTE pOutParams
    );

DWORD
WINAPI
ResUtilSetPropertyParameterBlockEx(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN const LPBYTE pInParams,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    IN BOOL bForceWrite,
    OUT OPTIONAL LPBYTE pOutParams
    );

DWORD
WINAPI
ResUtilSetUnknownProperties(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize
    );

DWORD
WINAPI
ResUtilGetPropertiesToParameterBlock(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT LPBYTE pOutParams,
    IN BOOL bCheckForRequiredProperties,
    OUT OPTIONAL LPWSTR * pszNameOfPropInError
    );

DWORD
WINAPI
ResUtilPropertyListFromParameterBlock(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID  pOutPropertyList,
    IN OUT LPDWORD pcbOutPropertyListSize,
    IN const LPBYTE pInParams,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ResUtilDupParameterBlock(
    OUT LPBYTE pOutParams,
    IN const LPBYTE pInParams,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable
    );

void
WINAPI
ResUtilFreeParameterBlock(
    IN OUT LPBYTE pOutParams,
    IN const LPBYTE pInParams,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable
    );

DWORD
WINAPI
ResUtilAddUnknownProperties(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN OUT PVOID pOutPropertyList,
    IN DWORD pcbOutPropertyListSize,
    IN OUT LPDWORD pcbBytesReturned,
    IN OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ResUtilSetPrivatePropertyList(
    IN HKEY hkeyClusterKey,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize
    );

DWORD
WINAPI
ResUtilVerifyPrivatePropertyList(
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize
    );

PWSTR
WINAPI
ResUtilDupString(
    IN LPCWSTR pszInString
    );

DWORD
WINAPI
ResUtilGetBinaryValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    OUT LPBYTE * ppbOutValue,
    OUT DWORD * pcbOutValueSize
    );

LPWSTR
WINAPI
ResUtilGetSzValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName
    );

LPWSTR
WINAPI
ResUtilGetExpandSzValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN BOOL bExpand
    );

FORCEINLINE
DWORD
WINAPI
ResUtilGetMultiSzValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    OUT LPWSTR * ppszOutValue,
    OUT LPDWORD pcbOutValueSize
    )
{
    return ResUtilGetBinaryValue( hkeyClusterKey, pszValueName, (LPBYTE *) ppszOutValue, pcbOutValueSize );
}

DWORD
WINAPI
ResUtilGetDwordValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    OUT LPDWORD pdwOutValue,
    IN DWORD dwDefaultValue OPTIONAL
    );

DWORD
WINAPI
ResUtilSetBinaryValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN const LPBYTE pbNewValue,
    IN DWORD cbNewValueSize,
    IN OUT LPBYTE * ppbOutValue,
    IN OUT LPDWORD pcbOutValueSize
    );

DWORD
WINAPI
ResUtilSetSzValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN LPCWSTR pszNewValue,
    IN OUT LPWSTR * ppszOutString
    );

DWORD
WINAPI
ResUtilSetExpandSzValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN LPCWSTR pszNewValue,
    IN OUT LPWSTR * ppszOutString
    );

DWORD
WINAPI
ResUtilSetMultiSzValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN LPCWSTR pszNewValue,
    IN DWORD cbNewValueSize,
    IN OUT LPWSTR * ppszOutValue,
    IN OUT LPDWORD pcbOutValueSize
    );

DWORD
WINAPI
ResUtilSetDwordValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN DWORD dwNewValue,
    IN OUT LPDWORD pdwOutValue
    );

DWORD
WINAPI
ResUtilGetBinaryProperty(
    OUT LPBYTE * ppbOutValue,
    OUT LPDWORD pcbOutValueSize,
    IN const PCLUSPROP_BINARY pValueStruct,
    IN const LPBYTE pbOldValue,
    IN DWORD cbOldValueSize,
    OUT LPBYTE * ppPropertyList,
    OUT LPDWORD pcbPropertyListSize
    );

DWORD
WINAPI
ResUtilGetSzProperty(
    OUT LPWSTR * ppszOutValue,
    IN const PCLUSPROP_SZ pValueStruct,
    IN LPCWSTR pszOldValue,
    OUT LPBYTE * ppPropertyList,
    OUT LPDWORD pcbPropertyListSize
    );

DWORD
WINAPI
ResUtilGetMultiSzProperty(
    OUT LPWSTR * ppszOutValue,
    OUT LPDWORD pcbOutValueSize,
    IN const PCLUSPROP_SZ pValueStruct,
    IN LPCWSTR pszOldValue,
    IN DWORD cbOldValueSize,
    OUT LPBYTE * ppPropertyList,
    OUT LPDWORD pcbPropertyListSize
    );

DWORD
WINAPI
ResUtilGetDwordProperty(
    OUT LPDWORD pdwOutValue,
    IN const PCLUSPROP_DWORD pValueStruct,
    IN DWORD dwOldValue,
    IN DWORD dwMinimum,
    IN DWORD dwMaximum,
    OUT LPBYTE * ppPropertyList,
    OUT LPDWORD pcbPropertyListSize
    );

LPVOID
WINAPI
ResUtilGetEnvironmentWithNetName(
    IN HRESOURCE hResource
    );

DWORD
WINAPI
ResUtilFreeEnvironment(
    IN LPVOID lpEnvironment
    );

LPWSTR
WINAPI
ResUtilExpandEnvironmentStrings(
    IN LPCWSTR pszSrc
    );

DWORD
WINAPI
ResUtilSetResourceServiceEnvironment(
    IN LPCWSTR pszServiceName,
    IN HRESOURCE hResource,
    IN PLOG_EVENT_ROUTINE pfnLogEvent,
    IN RESOURCE_HANDLE hResourceHandle
    );

DWORD
WINAPI
ResUtilRemoveResourceServiceEnvironment(
    IN  LPCWSTR             pszServiceName,
    IN  PLOG_EVENT_ROUTINE  pfnLogEvent,
    IN  RESOURCE_HANDLE     hResourceHandle
    );

DWORD
WINAPI
ResUtilSetResourceServiceStartParameters(
    IN LPCWSTR pszServiceName,
    IN SC_HANDLE schSCMHandle,
    IN OUT LPSC_HANDLE phService,
    IN PLOG_EVENT_ROUTINE pfnLogEvent,
    IN RESOURCE_HANDLE hResourceHandle
    );

DWORD
WINAPI
ResUtilFindSzProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue
    );

DWORD
WINAPI
ResUtilFindExpandSzProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue
    );

DWORD
WINAPI
ResUtilFindExpandedSzProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue
    );

DWORD
WINAPI
ResUtilFindDwordProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPDWORD pdwPropertyValue
    );

DWORD
WINAPI
ResUtilFindBinaryProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPBYTE * pbPropertyValue,
    OUT LPDWORD pcbPropertyValueSize
    );

DWORD
WINAPI
ResUtilFindMultiSzProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue,
    OUT LPDWORD pcbPropertyValueSize
    );

DWORD
WINAPI
ResUtilFindLongProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPLONG plPropertyValueSize
    );


//
// Common worker thread routines that allow a pending operation to
// be cancelled with CORRECT synchronization.
//
typedef struct CLUS_WORKER {
    HANDLE hThread;
    BOOL Terminate;
} CLUS_WORKER, *PCLUS_WORKER;

typedef DWORD (WINAPI *PWORKER_START_ROUTINE)(
    PCLUS_WORKER pWorker,
    LPVOID lpThreadParameter
    );

DWORD
WINAPI
ClusWorkerCreate(
    OUT PCLUS_WORKER lpWorker,
    IN PWORKER_START_ROUTINE lpStartAddress,
    IN PVOID lpParameter
    );

BOOL
WINAPI
ClusWorkerCheckTerminate(
    IN PCLUS_WORKER lpWorker
    );

VOID
WINAPI
ClusWorkerTerminate(
    IN PCLUS_WORKER lpWorker
    );


//Define enumerate resource callback function. This gets called for each resource enumerated
//by ResUtilEnumResources
typedef   DWORD (*LPRESOURCE_CALLBACK)( HRESOURCE, HRESOURCE , PVOID );
typedef   DWORD (*LPRESOURCE_CALLBACK_EX)( HCLUSTER, HRESOURCE, HRESOURCE , PVOID );


BOOL
WINAPI
ResUtilResourcesEqual(
    IN HRESOURCE    hSelf,
    IN HRESOURCE    hResource
    );


BOOL
WINAPI
ResUtilResourceTypesEqual(
    IN LPCWSTR      lpszResourceTypeName,
    IN HRESOURCE    hResource
    );

BOOL
WINAPI
ResUtilIsResourceClassEqual(
    IN PCLUS_RESOURCE_CLASS_INFO    prci,
    IN HRESOURCE                    hResource
    );

DWORD
WINAPI
ResUtilEnumResources(
    IN HRESOURCE            hSelf,
    IN LPCWSTR              lpszResTypeName,
    IN LPRESOURCE_CALLBACK  pResCallBack,
    IN PVOID                pParameter
    );

DWORD
WINAPI
ResUtilEnumResourcesEx(
    IN HCLUSTER                 hCluster,
    IN HRESOURCE                hSelf,
    IN LPCWSTR                  lpszResTypeName,
    IN LPRESOURCE_CALLBACK_EX   pResCallBack,
    IN PVOID                    pParameter
    );

HRESOURCE
WINAPI
ResUtilGetResourceDependency(
    IN HANDLE       hSelf,
    IN LPCWSTR      lpszResourceType
    );

HRESOURCE
WINAPI
ResUtilGetResourceDependencyByName(
    IN HCLUSTER hCluster,
    IN HANDLE   hSelf,
    IN LPCWSTR  lpszResourceType,
    IN BOOL     bRecurse
    );

HRESOURCE
WINAPI
ResUtilGetResourceDependencyByClass(
    IN HCLUSTER                     hCluster,
    IN HANDLE                       hSelf,
    IN PCLUS_RESOURCE_CLASS_INFO    prci,
    IN BOOL                         bRecurse
    );

HRESOURCE
WINAPI
ResUtilGetResourceNameDependency(
    IN LPCWSTR      lpszResourceName,
    IN LPCWSTR      lpszResourceType
    );

DWORD
WINAPI
ResUtilGetResourceDependentIPAddressProps(
    IN      HRESOURCE   hResource,
    OUT     LPWSTR      pszAddress,
    IN OUT  DWORD *     pcchAddress,
    OUT     LPWSTR      pszSubnetMask,
    IN OUT  DWORD *     pcchSubnetMask,
    OUT     LPWSTR      pszNetwork,
    IN OUT  DWORD *     pcchNetwork
    );

DWORD
WINAPI
ResUtilFindDependentDiskResourceDriveLetter(
    IN     HCLUSTER  hCluster,             // handle to cluster
    IN     HRESOURCE hResource,            // handle to resource to query for dependencies
    IN     LPWSTR    pszDriveLetter,       // buffer to store drive letter (ex. "X:\0")
    IN OUT DWORD *   pcchDriveLetter       // IN size of the pszDriveLetter buffer, OUT size of buffer required
    );

DWORD
WINAPI
ResUtilTerminateServiceProcessFromResDll(
    IN  DWORD               dwServicePid,
    IN  BOOL                bOffline,
    OUT PDWORD              pdwResourceState,
    IN  PLOG_EVENT_ROUTINE  pfnLogEvent,
    IN  RESOURCE_HANDLE     hResourceHandle
    );

DWORD
WINAPI
ResUtilGetPropertyFormats(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID                       pOutPropertyFormatList,
    IN DWORD                        cbPropertyFormatListSize,
    OUT LPDWORD                     pcbBytesReturned,
    OUT LPDWORD                     pcbRequired
    );


DWORD
WINAPI
ResUtilGetCoreClusterResources(
      IN    HCLUSTER      hCluster
    , OUT   HRESOURCE *   phClusterNameResource
    , OUT   HRESOURCE *   phClusterIPAddressResource
    , OUT   HRESOURCE *   phClusterQuorumResource
    );

DWORD
WINAPI
ResUtilGetResourceName(
      IN        HRESOURCE hResource
    , OUT       WCHAR *   pszResourceName
    , IN OUT    DWORD *   pcchResourceName
    );

#ifdef __cplusplus
}
#endif


#endif // ifdef _RESAPI_DEFINES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\rkeysvcc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       rkeysvcc.h
//
//--------------------------------------------------------------------------


#ifndef __rkeysvcc_h__
#define __rkeysvcc_h__

#ifdef __cplusplus
extern "C"{
#endif 

typedef void *KEYSVCC_HANDLE;

typedef enum _KEYSVC_TYPE {
    KeySvcMachine,
    KeySvcService
} KEYSVC_TYPE;

typedef struct _KEYSVC_UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef KEYSVC_MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] 
#endif // KEYSVC_MIDL_PASS
    USHORT *Buffer;
} KEYSVC_UNICODE_STRING, *PKEYSVC_UNICODE_STRING;


typedef struct _KEYSVC_BLOB {
    ULONG               cb;
#ifdef KEYSVC_MIDL_PASS
    [size_is(cb), length_is(cb)]
#endif // KEYSVC_MIDL_PASS
    BYTE                *pb;
} KEYSVC_BLOB, *PKEYSVC_BLOB;

//--------------------------------------------------------------------------------
// Define flags for use with RKeyOpenKeyService(). 
// 
// RKEYSVC_CONNECT_SECURE_ONLY - client will require mutual authentication to prevent
//     spoofing.  While more secure, this will cause the call to fail in situations when
//     fallback to NTLM would otherwise have been possible. 
// 
#ifndef KEYSVC_MIDL_PASS
#define RKEYSVC_CONNECT_SECURE_ONLY 0x00000001
#endif // #ifndef KEYSVC_MIDL_PASS

ULONG RKeyOpenKeyService
( /* [in] */       LPSTR            pszMachineName,
  /* [in] */       KEYSVC_TYPE      OwnerType,
  /* [in] */       LPWSTR           pwszOwnerName,
  /* [in] */       void            *pAuthentication,
  /* [out][in] */  void            *pReserved,
  /* [out] */      KEYSVCC_HANDLE  *phKeySvcCli);

ULONG RKeyCloseKeyService
(/* [in] */ KEYSVCC_HANDLE hKeySvcCli,
 /* [out][in] */ void *pReserved);

ULONG RKeyPFXInstall
(/* [in] */ KEYSVCC_HANDLE          hKeySvcCli,
 /* [in] */ PKEYSVC_BLOB            pPFX,
 /* [in] */ PKEYSVC_UNICODE_STRING  pPassword,
 /* [in] */ ULONG                   ulFlags);



#ifdef __cplusplus
}
#endif

#endif // #ifndef __rkeysvcc_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\richole.h ===
#ifndef _RICHOLE_
#define _RICHOLE_

#if _MSC_VER > 1000
#pragma once
#endif

/*
 *	RICHOLE.H
 *
 *	Purpose:
 *		OLE Extensions to the Rich Text Editor
 *
 *	Copyright (c) 1985-1999, Microsoft Corporation
 */

// Structure passed to GetObject and InsertObject
typedef struct _reobject
{
	DWORD			cbStruct;			// Size of structure
	LONG			cp;					// Character position of object
	CLSID			clsid;				// Class ID of object
	LPOLEOBJECT		poleobj;			// OLE object interface
	LPSTORAGE		pstg;				// Associated storage interface
	LPOLECLIENTSITE	polesite;			// Associated client site interface
	SIZEL			sizel;				// Size of object (may be 0,0)
	DWORD			dvaspect;			// Display aspect to use
	DWORD			dwFlags;			// Object status flags
	DWORD			dwUser;				// Dword for user's use
} REOBJECT;

// Flags to specify which interfaces should be returned in the structure above
#define REO_GETOBJ_NO_INTERFACES	(0x00000000L)
#define REO_GETOBJ_POLEOBJ			(0x00000001L)
#define REO_GETOBJ_PSTG				(0x00000002L)
#define REO_GETOBJ_POLESITE			(0x00000004L)
#define REO_GETOBJ_ALL_INTERFACES	(0x00000007L)

// Place object at selection
#define REO_CP_SELECTION ((ULONG) -1L)

// Use character position to specify object instead of index
#define REO_IOB_SELECTION ((ULONG) -1L)
#define REO_IOB_USE_CP ((ULONG) -2L)

// Object flags
#define REO_NULL			(0x00000000L)	// No flags
#define REO_READWRITEMASK	(0x0000003FL)	// Mask out RO bits
#define REO_DONTNEEDPALETTE	(0x00000020L)	// Object doesn't need palette
#define REO_BLANK			(0x00000010L)	// Object is blank
#define REO_DYNAMICSIZE		(0x00000008L)	// Object defines size always
#define REO_INVERTEDSELECT	(0x00000004L)	// Object drawn all inverted if sel
#define REO_BELOWBASELINE	(0x00000002L)	// Object sits below the baseline
#define REO_RESIZABLE		(0x00000001L)	// Object may be resized
#define REO_LINK			(0x80000000L)	// Object is a link (RO)
#define REO_STATIC			(0x40000000L)	// Object is static (RO)
#define REO_SELECTED		(0x08000000L)	// Object selected (RO)
#define REO_OPEN			(0x04000000L)	// Object open in its server (RO)
#define REO_INPLACEACTIVE	(0x02000000L)	// Object in place active (RO)
#define REO_HILITED			(0x01000000L)	// Object is to be hilited (RO)
#define REO_LINKAVAILABLE	(0x00800000L)	// Link believed available (RO)
#define REO_GETMETAFILE		(0x00400000L)	// Object requires metafile (RO)

// flags for IRichEditOle::GetClipboardData(),
// IRichEditOleCallback::GetClipboardData() and
// IRichEditOleCallback::QueryAcceptData()
#define RECO_PASTE			(0x00000000L)	// paste from clipboard
#define RECO_DROP			(0x00000001L)	// drop
#define RECO_COPY			(0x00000002L)	// copy to the clipboard
#define RECO_CUT			(0x00000003L)	// cut to the clipboard
#define RECO_DRAG			(0x00000004L)	// drag

/*
 *	IRichEditOle
 *
 *	Purpose:
 *		Interface used by the client of RichEdit to perform OLE-related
 *		operations.
 *
 *	//$ REVIEW:
 *		The methods herein may just want to be regular Windows messages.
 */
#undef INTERFACE
#define INTERFACE   IRichEditOle

DECLARE_INTERFACE_(IRichEditOle, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lplpObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRichEditOle methods ***
    STDMETHOD(GetClientSite) (THIS_ LPOLECLIENTSITE FAR * lplpolesite) PURE;
	STDMETHOD_(LONG,GetObjectCount) (THIS) PURE;
	STDMETHOD_(LONG,GetLinkCount) (THIS) PURE;
	STDMETHOD(GetObject) (THIS_ LONG iob, REOBJECT FAR * lpreobject,
						  DWORD dwFlags) PURE;
    STDMETHOD(InsertObject) (THIS_ REOBJECT FAR * lpreobject) PURE;
	STDMETHOD(ConvertObject) (THIS_ LONG iob, REFCLSID rclsidNew,
							  LPCSTR lpstrUserTypeNew) PURE;
	STDMETHOD(ActivateAs) (THIS_ REFCLSID rclsid, REFCLSID rclsidAs) PURE;
	STDMETHOD(SetHostNames) (THIS_ LPCSTR lpstrContainerApp,
							 LPCSTR lpstrContainerObj) PURE;
	STDMETHOD(SetLinkAvailable) (THIS_ LONG iob, BOOL fAvailable) PURE;
	STDMETHOD(SetDvaspect) (THIS_ LONG iob, DWORD dvaspect) PURE;
	STDMETHOD(HandsOffStorage) (THIS_ LONG iob) PURE;
	STDMETHOD(SaveCompleted) (THIS_ LONG iob, LPSTORAGE lpstg) PURE;
	STDMETHOD(InPlaceDeactivate) (THIS) PURE;
	STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;
	STDMETHOD(GetClipboardData) (THIS_ CHARRANGE FAR * lpchrg, DWORD reco,
									LPDATAOBJECT FAR * lplpdataobj) PURE;
	STDMETHOD(ImportDataObject) (THIS_ LPDATAOBJECT lpdataobj,
									CLIPFORMAT cf, HGLOBAL hMetaPict) PURE;
};
typedef         IRichEditOle FAR * LPRICHEDITOLE;

/*
 *	IRichEditOleCallback
 *
 *	Purpose:
 *		Interface used by the RichEdit to get OLE-related stuff from the
 *		application using RichEdit.
 */
#undef INTERFACE
#define INTERFACE   IRichEditOleCallback

DECLARE_INTERFACE_(IRichEditOleCallback, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lplpObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRichEditOleCallback methods ***
	STDMETHOD(GetNewStorage) (THIS_ LPSTORAGE FAR * lplpstg) PURE;
    STDMETHOD(GetInPlaceContext) (THIS_ LPOLEINPLACEFRAME FAR * lplpFrame,
								  LPOLEINPLACEUIWINDOW FAR * lplpDoc,
								  LPOLEINPLACEFRAMEINFO lpFrameInfo) PURE;
	STDMETHOD(ShowContainerUI) (THIS_ BOOL fShow) PURE;
	STDMETHOD(QueryInsertObject) (THIS_ LPCLSID lpclsid, LPSTORAGE lpstg,
									LONG cp) PURE;
	STDMETHOD(DeleteObject) (THIS_ LPOLEOBJECT lpoleobj) PURE;
	STDMETHOD(QueryAcceptData) (THIS_ LPDATAOBJECT lpdataobj,
								CLIPFORMAT FAR * lpcfFormat, DWORD reco,
								BOOL fReally, HGLOBAL hMetaPict) PURE;
	STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;
	STDMETHOD(GetClipboardData) (THIS_ CHARRANGE FAR * lpchrg, DWORD reco,
									LPDATAOBJECT FAR * lplpdataobj) PURE;
	STDMETHOD(GetDragDropEffect) (THIS_ BOOL fDrag, DWORD grfKeyState,
									LPDWORD pdwEffect) PURE;
	STDMETHOD(GetContextMenu) (THIS_ WORD seltype, LPOLEOBJECT lpoleobj,
									CHARRANGE FAR * lpchrg,
									HMENU FAR * lphmenu) PURE;
};
typedef         IRichEditOleCallback FAR * LPRICHEDITOLECALLBACK;

#ifndef MAC
// RichEdit interface GUIDs
DEFINE_GUID(IID_IRichEditOle,         0x00020D00, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IRichEditOleCallback, 0x00020D03, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
#endif // !MAC

#endif // _RICHOLE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\richedit.h ===
/*
 *	RICHEDIT.H
 *	
 *	Purpose:
 *		RICHEDIT v2.0/3.0/4.0 public definitions
 *		functionality available for v2.0 and 3.0 that is not in the original
 *		Windows 95 release.
 *	
 *	Copyright (c) Microsoft Corporation. All rights reserved.
 */

#ifndef _RICHEDIT_
#define	_RICHEDIT_

#ifdef _WIN32
#include <pshpack4.h>
#elif !defined(RC_INVOKED)
#pragma pack(4)
#endif

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// To mimic older RichEdit behavior, set _RICHEDIT_VER to appropriate value
//		Version 1.0		0x0100	
//		Version 2.0		0x0200	
//		Version 2.1		0x0210	
#ifndef _RICHEDIT_VER
#define _RICHEDIT_VER	0x0300
#endif

#define cchTextLimitDefault 32767

#define MSFTEDIT_CLASS		L"RICHEDIT50W"
// NOTE:  MSFTEDIT.DLL only registers MSFTEDIT_CLASS.  If an application wants
// to use the following Richedit classes, it needs to load the riched20.dll.
// Otherwise, CreateWindow with RICHEDIT_CLASS would fail.
// This also applies to any dialog that uses RICHEDIT_CLASS, 

// RichEdit 2.0 Window Class 
// On Windows CE, avoid possible conflicts on Win95
#define CERICHEDIT_CLASSA	"RichEditCEA"
#define CERICHEDIT_CLASSW	L"RichEditCEW"

#define RICHEDIT_CLASSA		"RichEdit20A"
#define RICHEDIT_CLASS10A	"RICHEDIT"			// Richedit 1.0

#ifndef MACPORT
#define RICHEDIT_CLASSW		L"RichEdit20W"
#else	//----------------------MACPORT 
#define RICHEDIT_CLASSW		TEXT("RichEdit20W")	// MACPORT change 
#endif // MACPORT  

#if (_RICHEDIT_VER >= 0x0200 )
#ifdef UNICODE
#define RICHEDIT_CLASS		RICHEDIT_CLASSW
#else
#define RICHEDIT_CLASS		RICHEDIT_CLASSA
#endif // UNICODE 
#else
#define RICHEDIT_CLASS		RICHEDIT_CLASS10A
#endif // _RICHEDIT_VER >= 0x0200 

// RichEdit messages 

#ifndef WM_CONTEXTMENU
#define WM_CONTEXTMENU			0x007B
#endif

#ifndef WM_UNICHAR
#define WM_UNICHAR				0x0109
#endif

#ifndef WM_PRINTCLIENT
#define WM_PRINTCLIENT			0x0318
#endif

#ifndef EM_GETLIMITTEXT
#define EM_GETLIMITTEXT			(WM_USER + 37)
#endif

#ifndef EM_POSFROMCHAR	
#define EM_POSFROMCHAR			(WM_USER + 38)
#define EM_CHARFROMPOS			(WM_USER + 39)
#endif

#ifndef EM_SCROLLCARET
#define EM_SCROLLCARET			(WM_USER + 49)
#endif
#define EM_CANPASTE				(WM_USER + 50)
#define EM_DISPLAYBAND			(WM_USER + 51)
#define EM_EXGETSEL				(WM_USER + 52)
#define EM_EXLIMITTEXT			(WM_USER + 53)
#define EM_EXLINEFROMCHAR		(WM_USER + 54)
#define EM_EXSETSEL				(WM_USER + 55)
#define EM_FINDTEXT				(WM_USER + 56)
#define EM_FORMATRANGE			(WM_USER + 57)
#define EM_GETCHARFORMAT		(WM_USER + 58)
#define EM_GETEVENTMASK			(WM_USER + 59)
#define EM_GETOLEINTERFACE		(WM_USER + 60)
#define EM_GETPARAFORMAT		(WM_USER + 61)
#define EM_GETSELTEXT			(WM_USER + 62)
#define EM_HIDESELECTION		(WM_USER + 63)
#define EM_PASTESPECIAL			(WM_USER + 64)
#define EM_REQUESTRESIZE		(WM_USER + 65)
#define EM_SELECTIONTYPE		(WM_USER + 66)
#define EM_SETBKGNDCOLOR		(WM_USER + 67)
#define EM_SETCHARFORMAT		(WM_USER + 68)
#define EM_SETEVENTMASK			(WM_USER + 69)
#define EM_SETOLECALLBACK		(WM_USER + 70)
#define EM_SETPARAFORMAT		(WM_USER + 71)
#define EM_SETTARGETDEVICE		(WM_USER + 72)
#define EM_STREAMIN				(WM_USER + 73)
#define EM_STREAMOUT			(WM_USER + 74)
#define EM_GETTEXTRANGE			(WM_USER + 75)
#define EM_FINDWORDBREAK		(WM_USER + 76)
#define EM_SETOPTIONS			(WM_USER + 77)
#define EM_GETOPTIONS			(WM_USER + 78)
#define EM_FINDTEXTEX			(WM_USER + 79)
#ifdef _WIN32
#define EM_GETWORDBREAKPROCEX	(WM_USER + 80)
#define EM_SETWORDBREAKPROCEX	(WM_USER + 81)
#endif

// RichEdit 2.0 messages 
#define	EM_SETUNDOLIMIT			(WM_USER + 82)
#define EM_REDO					(WM_USER + 84)
#define EM_CANREDO				(WM_USER + 85)
#define EM_GETUNDONAME			(WM_USER + 86)
#define EM_GETREDONAME			(WM_USER + 87)
#define EM_STOPGROUPTYPING		(WM_USER + 88)

#define EM_SETTEXTMODE			(WM_USER + 89)
#define EM_GETTEXTMODE			(WM_USER + 90)

// enum for use with EM_GET/SETTEXTMODE 
typedef enum tagTextMode
{
	TM_PLAINTEXT			= 1,
	TM_RICHTEXT				= 2,	// Default behavior 
	TM_SINGLELEVELUNDO		= 4,
	TM_MULTILEVELUNDO		= 8,	// Default behavior 
	TM_SINGLECODEPAGE		= 16,
	TM_MULTICODEPAGE		= 32	// Default behavior 
} TEXTMODE;

#define EM_AUTOURLDETECT		(WM_USER + 91)
#define EM_GETAUTOURLDETECT		(WM_USER + 92)
#define EM_SETPALETTE			(WM_USER + 93)
#define EM_GETTEXTEX			(WM_USER + 94)
#define EM_GETTEXTLENGTHEX		(WM_USER + 95)
#define EM_SHOWSCROLLBAR		(WM_USER + 96)
#define EM_SETTEXTEX			(WM_USER + 97)

// East Asia specific messages 
#define EM_SETPUNCTUATION		(WM_USER + 100)
#define EM_GETPUNCTUATION		(WM_USER + 101)
#define EM_SETWORDWRAPMODE		(WM_USER + 102)
#define EM_GETWORDWRAPMODE		(WM_USER + 103)
#define EM_SETIMECOLOR			(WM_USER + 104)
#define EM_GETIMECOLOR			(WM_USER + 105)
#define EM_SETIMEOPTIONS		(WM_USER + 106)
#define EM_GETIMEOPTIONS		(WM_USER + 107)
#define EM_CONVPOSITION 		(WM_USER + 108)

#define EM_SETLANGOPTIONS		(WM_USER + 120)
#define EM_GETLANGOPTIONS		(WM_USER + 121)
#define EM_GETIMECOMPMODE		(WM_USER + 122)

#define EM_FINDTEXTW			(WM_USER + 123)
#define EM_FINDTEXTEXW			(WM_USER + 124)

// RE3.0 FE messages 
#define EM_RECONVERSION			(WM_USER + 125)
#define EM_SETIMEMODEBIAS		(WM_USER + 126)	
#define EM_GETIMEMODEBIAS		(WM_USER + 127)

// BiDi specific messages 
#define EM_SETBIDIOPTIONS		(WM_USER + 200)
#define EM_GETBIDIOPTIONS		(WM_USER + 201)

#define EM_SETTYPOGRAPHYOPTIONS	(WM_USER + 202)
#define EM_GETTYPOGRAPHYOPTIONS	(WM_USER + 203)

// Extended edit style specific messages 
#define EM_SETEDITSTYLE			(WM_USER + 204)
#define EM_GETEDITSTYLE			(WM_USER + 205)

// Extended edit style masks 
#define	SES_EMULATESYSEDIT		1
#define SES_BEEPONMAXTEXT		2
#define	SES_EXTENDBACKCOLOR		4
#define SES_MAPCPS				8
#define SES_EMULATE10			16
#define	SES_USECRLF				32
#define SES_USEAIMM				64
#define SES_NOIME				128

#define SES_ALLOWBEEPS			256
#define SES_UPPERCASE			512
#define	SES_LOWERCASE			1024
#define SES_NOINPUTSEQUENCECHK	2048
#define SES_BIDI				4096
#define SES_SCROLLONKILLFOCUS	8192
#define	SES_XLTCRCRLFTOCR		16384
#define SES_DRAFTMODE			32768

#define	SES_USECTF				0x0010000
#define SES_HIDEGRIDLINES		0x0020000
#define SES_USEATFONT			0x0040000
#define SES_CUSTOMLOOK			0x0080000
#define SES_LBSCROLLNOTIFY		0x0100000
#define SES_CTFALLOWEMBED		0x0200000
#define SES_CTFALLOWSMARTTAG	0x0400000
#define SES_CTFALLOWPROOFING	0x0800000

// Options for EM_SETLANGOPTIONS and EM_GETLANGOPTIONS 
#define IMF_AUTOKEYBOARD		0x0001
#define IMF_AUTOFONT			0x0002
#define IMF_IMECANCELCOMPLETE	0x0004	// High completes comp string when aborting, low cancels
#define IMF_IMEALWAYSSENDNOTIFY 0x0008
#define IMF_AUTOFONTSIZEADJUST	0x0010
#define IMF_UIFONTS				0x0020
#define IMF_DUALFONT			0x0080

// Values for EM_GETIMECOMPMODE 
#define ICM_NOTOPEN				0x0000
#define ICM_LEVEL3				0x0001
#define ICM_LEVEL2				0x0002
#define ICM_LEVEL2_5			0x0003
#define ICM_LEVEL2_SUI			0x0004
#define ICM_CTF					0x0005

// Options for EM_SETTYPOGRAPHYOPTIONS 
#define	TO_ADVANCEDTYPOGRAPHY	1
#define	TO_SIMPLELINEBREAK		2
#define TO_DISABLECUSTOMTEXTOUT	4
#define TO_ADVANCEDLAYOUT		8

// Pegasus outline mode messages (RE 3.0) 

// Outline mode message
#define EM_OUTLINE              (WM_USER + 220)
// Message for getting and restoring scroll pos
#define EM_GETSCROLLPOS         (WM_USER + 221)
#define EM_SETSCROLLPOS         (WM_USER + 222)
// Change fontsize in current selection by wParam
#define EM_SETFONTSIZE          (WM_USER + 223)
#define EM_GETZOOM				(WM_USER + 224)
#define EM_SETZOOM				(WM_USER + 225)
#define EM_GETVIEWKIND			(WM_USER + 226)
#define EM_SETVIEWKIND			(WM_USER + 227)

// RichEdit 4.0 messages
#define EM_GETPAGE				(WM_USER + 228)
#define EM_SETPAGE				(WM_USER + 229)
#define EM_GETHYPHENATEINFO		(WM_USER + 230)
#define EM_SETHYPHENATEINFO		(WM_USER + 231)
#define EM_GETPAGEROTATE		(WM_USER + 235)
#define EM_SETPAGEROTATE		(WM_USER + 236)
#define EM_GETCTFMODEBIAS		(WM_USER + 237)
#define EM_SETCTFMODEBIAS		(WM_USER + 238)
#define EM_GETCTFOPENSTATUS		(WM_USER + 240)
#define EM_SETCTFOPENSTATUS		(WM_USER + 241)
#define EM_GETIMECOMPTEXT		(WM_USER + 242)
#define EM_ISIME				(WM_USER + 243)
#define EM_GETIMEPROPERTY		(WM_USER + 244)

// EM_SETPAGEROTATE wparam values
#define EPR_0					0		// Text flows left to right and top to bottom
#define EPR_270					1		// Text flows top to bottom and right to left
#define EPR_180					2		// Text flows right to left and bottom to top
#define	EPR_90					3		// Text flows bottom to top and left to right

// EM_SETCTFMODEBIAS wparam values
#define CTFMODEBIAS_DEFAULT					0x0000
#define CTFMODEBIAS_FILENAME				0x0001
#define CTFMODEBIAS_NAME					0x0002
#define CTFMODEBIAS_READING					0x0003
#define CTFMODEBIAS_DATETIME				0x0004
#define CTFMODEBIAS_CONVERSATION			0x0005
#define CTFMODEBIAS_NUMERIC					0x0006
#define CTFMODEBIAS_HIRAGANA				0x0007
#define CTFMODEBIAS_KATAKANA				0x0008
#define CTFMODEBIAS_HANGUL					0x0009
#define CTFMODEBIAS_HALFWIDTHKATAKANA		0x000A
#define CTFMODEBIAS_FULLWIDTHALPHANUMERIC	0x000B
#define CTFMODEBIAS_HALFWIDTHALPHANUMERIC	0x000C

// EM_SETIMEMODEBIAS lparam values
#define IMF_SMODE_PLAURALCLAUSE	0x0001
#define IMF_SMODE_NONE			0x0002

// EM_GETIMECOMPTEXT wparam structure
typedef struct _imecomptext {
	LONG	cb;			// count of bytes in the output buffer.
	DWORD	flags;		// value specifying the composition string type.
						//	Currently only support ICT_RESULTREADSTR
} IMECOMPTEXT;
#define ICT_RESULTREADSTR		1

// Outline mode wparam values
#define EMO_EXIT                0       // Enter normal mode,  lparam ignored
#define EMO_ENTER               1       // Enter outline mode, lparam ignored
#define EMO_PROMOTE             2       // LOWORD(lparam) == 0 ==>
                                        //  promote  to body-text
                                        // LOWORD(lparam) != 0 ==>
                                        //  promote/demote current selection
                                        //  by indicated number of levels
#define EMO_EXPAND              3       // HIWORD(lparam) = EMO_EXPANDSELECTION
                                        //  -> expands selection to level
                                        //  indicated in LOWORD(lparam)
                                        //  LOWORD(lparam) = -1/+1 corresponds
                                        //  to collapse/expand button presses
                                        //  in winword (other values are
                                        //  equivalent to having pressed these
                                        //  buttons more than once)
                                        //  HIWORD(lparam) = EMO_EXPANDDOCUMENT
                                        //  -> expands whole document to
                                        //  indicated level
#define EMO_MOVESELECTION       4       // LOWORD(lparam) != 0 -> move current
                                        //  selection up/down by indicated amount
#define EMO_GETVIEWMODE			5		// Returns VM_NORMAL or VM_OUTLINE

// EMO_EXPAND options
#define EMO_EXPANDSELECTION     0
#define EMO_EXPANDDOCUMENT      1

#define VM_NORMAL				4		// Agrees with RTF \viewkindN
#define VM_OUTLINE				2
#define VM_PAGE					9		// Screen page view (not print layout)

// New notifications 
#define EN_MSGFILTER			0x0700
#define EN_REQUESTRESIZE		0x0701
#define EN_SELCHANGE			0x0702
#define EN_DROPFILES			0x0703
#define EN_PROTECTED			0x0704
#define EN_CORRECTTEXT			0x0705			// PenWin specific 
#define EN_STOPNOUNDO			0x0706
#define EN_IMECHANGE			0x0707			// East Asia specific 
#define EN_SAVECLIPBOARD		0x0708
#define EN_OLEOPFAILED			0x0709
#define EN_OBJECTPOSITIONS		0x070a
#define EN_LINK					0x070b
#define EN_DRAGDROPDONE			0x070c
#define EN_PARAGRAPHEXPANDED	0x070d
#define EN_PAGECHANGE			0x070e
#define EN_LOWFIRTF				0x070f
#define EN_ALIGNLTR				0x0710			// BiDi specific notification
#define EN_ALIGNRTL				0x0711			// BiDi specific notification

// Event notification masks 
#define ENM_NONE				0x00000000
#define ENM_CHANGE				0x00000001
#define ENM_UPDATE				0x00000002
#define ENM_SCROLL				0x00000004
#define ENM_SCROLLEVENTS		0x00000008
#define ENM_DRAGDROPDONE		0x00000010
#define ENM_PARAGRAPHEXPANDED	0x00000020
#define ENM_PAGECHANGE			0x00000040
#define ENM_KEYEVENTS			0x00010000
#define ENM_MOUSEEVENTS			0x00020000
#define ENM_REQUESTRESIZE		0x00040000
#define ENM_SELCHANGE			0x00080000
#define ENM_DROPFILES			0x00100000
#define ENM_PROTECTED			0x00200000
#define ENM_CORRECTTEXT			0x00400000		// PenWin specific 
#define ENM_IMECHANGE			0x00800000		// Used by RE1.0 compatibility
#define ENM_LANGCHANGE			0x01000000
#define ENM_OBJECTPOSITIONS		0x02000000
#define ENM_LINK				0x04000000
#define ENM_LOWFIRTF			0x08000000


// New edit control styles 
#define ES_SAVESEL				0x00008000
#define ES_SUNKEN				0x00004000
#define ES_DISABLENOSCROLL		0x00002000
// Same as WS_MAXIMIZE, but that doesn't make sense so we re-use the value 
#define ES_SELECTIONBAR			0x01000000
// Same as ES_UPPERCASE, but re-used to completely disable OLE drag'n'drop 
#define ES_NOOLEDRAGDROP		0x00000008

// New edit control extended style 
#if (_WIN32_WINNT > 0x0400) || (WINVER > 0x0400)
#define ES_EX_NOCALLOLEINIT		0x00000000		// Not supported in RE 2.0/3.0 
#else
#ifdef	_WIN32
#define ES_EX_NOCALLOLEINIT		0x01000000
#endif	
#endif

// These flags are used in FE Windows 
#define ES_VERTICAL				0x00400000		// Not supported in RE 2.0/3.0 
#define	ES_NOIME				0x00080000
#define ES_SELFIME				0x00040000

// Edit control options 
#define ECO_AUTOWORDSELECTION	0x00000001
#define ECO_AUTOVSCROLL			0x00000040
#define ECO_AUTOHSCROLL			0x00000080
#define ECO_NOHIDESEL			0x00000100
#define ECO_READONLY			0x00000800
#define ECO_WANTRETURN			0x00001000
#define ECO_SAVESEL				0x00008000
#define ECO_SELECTIONBAR		0x01000000
#define ECO_VERTICAL			0x00400000		// FE specific 


// ECO operations 
#define ECOOP_SET				0x0001
#define ECOOP_OR				0x0002
#define ECOOP_AND				0x0003
#define ECOOP_XOR				0x0004

// New word break function actions 
#define WB_CLASSIFY			3
#define WB_MOVEWORDLEFT		4
#define WB_MOVEWORDRIGHT	5
#define WB_LEFTBREAK		6
#define WB_RIGHTBREAK		7

// East Asia specific flags 
#define WB_MOVEWORDPREV		4
#define WB_MOVEWORDNEXT		5
#define WB_PREVBREAK		6
#define WB_NEXTBREAK		7

#define PC_FOLLOWING		1
#define	PC_LEADING			2
#define	PC_OVERFLOW			3
#define	PC_DELIMITER		4
#define WBF_WORDWRAP		0x010
#define WBF_WORDBREAK		0x020
#define	WBF_OVERFLOW		0x040	
#define WBF_LEVEL1			0x080
#define	WBF_LEVEL2			0x100
#define	WBF_CUSTOM			0x200

// East Asia specific flags 
#define IMF_FORCENONE           0x0001
#define IMF_FORCEENABLE         0x0002
#define IMF_FORCEDISABLE        0x0004
#define IMF_CLOSESTATUSWINDOW   0x0008
#define IMF_VERTICAL            0x0020
#define IMF_FORCEACTIVE         0x0040
#define IMF_FORCEINACTIVE       0x0080
#define IMF_FORCEREMEMBER       0x0100
#define IMF_MULTIPLEEDIT        0x0400

// Word break flags (used with WB_CLASSIFY) 
#define WBF_CLASS			((BYTE) 0x0F)
#define WBF_ISWHITE			((BYTE) 0x10)
#define WBF_BREAKLINE		((BYTE) 0x20)
#define WBF_BREAKAFTER		((BYTE) 0x40)


// Data types 

#ifdef _WIN32
// Extended edit word break proc (character set aware) 
typedef LONG (*EDITWORDBREAKPROCEX)(char *pchText, LONG cchText, BYTE bCharSet, INT action);
#endif

// All character format measurements are in twips 
typedef struct _charformat
{
	UINT		cbSize;
	DWORD		dwMask;
	DWORD		dwEffects;
	LONG		yHeight;
	LONG		yOffset;
	COLORREF	crTextColor;
	BYTE		bCharSet;
	BYTE		bPitchAndFamily;
	char		szFaceName[LF_FACESIZE];
} CHARFORMATA;

typedef struct _charformatw
{
	UINT		cbSize;
	DWORD		dwMask;
	DWORD		dwEffects;
	LONG		yHeight;
	LONG		yOffset;
	COLORREF	crTextColor;
	BYTE		bCharSet;
	BYTE		bPitchAndFamily;
	WCHAR		szFaceName[LF_FACESIZE];
} CHARFORMATW;

#if (_RICHEDIT_VER >= 0x0200)
#ifdef UNICODE
#define CHARFORMAT CHARFORMATW
#else
#define CHARFORMAT CHARFORMATA
#endif // UNICODE 
#else
#define CHARFORMAT CHARFORMATA
#endif // _RICHEDIT_VER >= 0x0200 

// CHARFORMAT2 structure 

#ifdef __cplusplus

struct CHARFORMAT2W : _charformatw
{
	WORD		wWeight;			// Font weight (LOGFONT value)
	SHORT		sSpacing;			// Amount to space between letters
	COLORREF	crBackColor;		// Background color
	LCID		lcid;				// Locale ID
	DWORD		dwReserved;			// Reserved. Must be 0
	SHORT		sStyle;				// Style handle
	WORD		wKerning;			// Twip size above which to kern char pair
	BYTE		bUnderlineType;		// Underline type
	BYTE		bAnimation;			// Animated text like marching ants
	BYTE		bRevAuthor;			// Revision author index
};

struct CHARFORMAT2A : _charformat
{
	WORD		wWeight;			// Font weight (LOGFONT value)
	SHORT		sSpacing;			// Amount to space between letters
	COLORREF	crBackColor;		// Background color
	LCID		lcid;				// Locale ID
	DWORD		dwReserved;			// Reserved. Must be 0
	SHORT		sStyle;				// Style handle
	WORD		wKerning;			// Twip size above which to kern char pair
	BYTE		bUnderlineType;		// Underline type
	BYTE		bAnimation;			// Animated text like marching ants
	BYTE		bRevAuthor;			// Revision author index
};

#else	// regular C-style  

typedef struct _charformat2w
{
	UINT		cbSize;
	DWORD		dwMask;
	DWORD		dwEffects;
	LONG		yHeight;
	LONG		yOffset;			// > 0 for superscript, < 0 for subscript 
	COLORREF	crTextColor;
	BYTE		bCharSet;
	BYTE		bPitchAndFamily;
	WCHAR		szFaceName[LF_FACESIZE];
	WORD		wWeight;			// Font weight (LOGFONT value)		
	SHORT		sSpacing;			// Amount to space between letters	
	COLORREF	crBackColor;		// Background color					
	LCID		lcid;				// Locale ID						
	DWORD		dwReserved;			// Reserved. Must be 0				
	SHORT		sStyle;				// Style handle						
	WORD		wKerning;			// Twip size above which to kern char pair
	BYTE		bUnderlineType;		// Underline type					
	BYTE		bAnimation;			// Animated text like marching ants	
	BYTE		bRevAuthor;			// Revision author index			
	BYTE		bReserved1;
} CHARFORMAT2W;

typedef struct _charformat2a
{
	UINT		cbSize;
	DWORD		dwMask;
	DWORD		dwEffects;
	LONG		yHeight;
	LONG		yOffset;			// > 0 for superscript, < 0 for subscript 
	COLORREF	crTextColor;
	BYTE		bCharSet;
	BYTE		bPitchAndFamily;
	char		szFaceName[LF_FACESIZE];
	WORD		wWeight;			// Font weight (LOGFONT value)		
	SHORT		sSpacing;			// Amount to space between letters	
	COLORREF	crBackColor;		// Background color					
	LCID		lcid;				// Locale ID						
	DWORD		dwReserved;			// Reserved. Must be 0				
	SHORT		sStyle;				// Style handle						
	WORD		wKerning;			// Twip size above which to kern char pair
	BYTE		bUnderlineType;		// Underline type					
	BYTE		bAnimation;			// Animated text like marching ants	
	BYTE		bRevAuthor;			// Revision author index			
} CHARFORMAT2A;

#endif // C++ 

#ifdef UNICODE
#define CHARFORMAT2	CHARFORMAT2W
#else
#define CHARFORMAT2 CHARFORMAT2A
#endif

#define CHARFORMATDELTA		(sizeof(CHARFORMAT2) - sizeof(CHARFORMAT))


// CFM_COLOR mirrors CFE_AUTOCOLOR, a little hack to easily deal with autocolor

// CHARFORMAT masks 
#define CFM_BOLD		0x00000001
#define CFM_ITALIC		0x00000002
#define CFM_UNDERLINE	0x00000004
#define CFM_STRIKEOUT	0x00000008
#define CFM_PROTECTED	0x00000010
#define CFM_LINK		0x00000020			// Exchange hyperlink extension 
#define CFM_SIZE		0x80000000
#define CFM_COLOR		0x40000000
#define CFM_FACE		0x20000000
#define CFM_OFFSET		0x10000000
#define CFM_CHARSET		0x08000000

// CHARFORMAT effects 
#define CFE_BOLD		0x0001
#define CFE_ITALIC		0x0002
#define CFE_UNDERLINE	0x0004
#define CFE_STRIKEOUT	0x0008
#define CFE_PROTECTED	0x0010
#define CFE_LINK		0x0020
#define CFE_AUTOCOLOR	0x40000000			// NOTE: this corresponds to 
											// CFM_COLOR, which controls it 
// Masks and effects defined for CHARFORMAT2 -- an (*) indicates
// that the data is stored by RichEdit 2.0/3.0, but not displayed
#define CFM_SMALLCAPS		0x0040			// (*)	
#define	CFM_ALLCAPS			0x0080			// Displayed by 3.0	
#define	CFM_HIDDEN			0x0100			// Hidden by 3.0 
#define	CFM_OUTLINE			0x0200			// (*)	
#define	CFM_SHADOW			0x0400			// (*)	
#define	CFM_EMBOSS			0x0800			// (*)	
#define	CFM_IMPRINT			0x1000			// (*)	
#define CFM_DISABLED		0x2000
#define	CFM_REVISED			0x4000

#define CFM_BACKCOLOR		0x04000000
#define CFM_LCID			0x02000000
#define	CFM_UNDERLINETYPE	0x00800000		// Many displayed by 3.0 
#define	CFM_WEIGHT			0x00400000
#define CFM_SPACING			0x00200000		// Displayed by 3.0	
#define CFM_KERNING			0x00100000		// (*)	
#define CFM_STYLE			0x00080000		// (*)	
#define CFM_ANIMATION		0x00040000		// (*)	
#define CFM_REVAUTHOR		0x00008000

#define CFE_SUBSCRIPT		0x00010000		// Superscript and subscript are 
#define CFE_SUPERSCRIPT		0x00020000		//  mutually exclusive			 

#define CFM_SUBSCRIPT		CFE_SUBSCRIPT | CFE_SUPERSCRIPT
#define CFM_SUPERSCRIPT		CFM_SUBSCRIPT

// CHARFORMAT "ALL" masks
#define CFM_EFFECTS (CFM_BOLD | CFM_ITALIC | CFM_UNDERLINE | CFM_COLOR | \
					 CFM_STRIKEOUT | CFE_PROTECTED | CFM_LINK)
#define CFM_ALL (CFM_EFFECTS | CFM_SIZE | CFM_FACE | CFM_OFFSET | CFM_CHARSET)

#define	CFM_EFFECTS2 (CFM_EFFECTS | CFM_DISABLED | CFM_SMALLCAPS | CFM_ALLCAPS \
					| CFM_HIDDEN  | CFM_OUTLINE | CFM_SHADOW | CFM_EMBOSS \
					| CFM_IMPRINT | CFM_DISABLED | CFM_REVISED \
					| CFM_SUBSCRIPT | CFM_SUPERSCRIPT | CFM_BACKCOLOR)

#define CFM_ALL2	 (CFM_ALL | CFM_EFFECTS2 | CFM_BACKCOLOR | CFM_LCID \
					| CFM_UNDERLINETYPE | CFM_WEIGHT | CFM_REVAUTHOR \
					| CFM_SPACING | CFM_KERNING | CFM_STYLE | CFM_ANIMATION)

#define	CFE_SMALLCAPS		CFM_SMALLCAPS
#define	CFE_ALLCAPS			CFM_ALLCAPS
#define	CFE_HIDDEN			CFM_HIDDEN
#define	CFE_OUTLINE			CFM_OUTLINE
#define	CFE_SHADOW			CFM_SHADOW
#define	CFE_EMBOSS			CFM_EMBOSS
#define	CFE_IMPRINT			CFM_IMPRINT
#define	CFE_DISABLED		CFM_DISABLED
#define	CFE_REVISED			CFM_REVISED

// CFE_AUTOCOLOR and CFE_AUTOBACKCOLOR correspond to CFM_COLOR and
// CFM_BACKCOLOR, respectively, which control them
#define CFE_AUTOBACKCOLOR	CFM_BACKCOLOR

// Underline types. RE 1.0 displays only CFU_UNDERLINE
#define CFU_CF1UNDERLINE	0xFF	// Map charformat's bit underline to CF2
#define CFU_INVERT			0xFE	// For IME composition fake a selection
#define CFU_UNDERLINETHICKLONGDASH		18	// (*) display as dash
#define CFU_UNDERLINETHICKDOTTED		17	// (*) display as dot
#define CFU_UNDERLINETHICKDASHDOTDOT	16	// (*) display as dash dot dot
#define CFU_UNDERLINETHICKDASHDOT		15	// (*) display as dash dot
#define CFU_UNDERLINETHICKDASH			14	// (*) display as dash
#define CFU_UNDERLINELONGDASH			13	// (*) display as dash
#define CFU_UNDERLINEHEAVYWAVE			12	// (*) display as wave
#define CFU_UNDERLINEDOUBLEWAVE			11	// (*) display as wave
#define CFU_UNDERLINEHAIRLINE			10	// (*) display as single	
#define CFU_UNDERLINETHICK				9
#define CFU_UNDERLINEWAVE				8
#define	CFU_UNDERLINEDASHDOTDOT			7
#define	CFU_UNDERLINEDASHDOT			6
#define	CFU_UNDERLINEDASH				5
#define	CFU_UNDERLINEDOTTED				4
#define	CFU_UNDERLINEDOUBLE				3	// (*) display as single
#define CFU_UNDERLINEWORD				2	// (*) display as single	
#define CFU_UNDERLINE					1
#define CFU_UNDERLINENONE				0

#define yHeightCharPtsMost 1638

// EM_SETCHARFORMAT wParam masks 
#define SCF_SELECTION		0x0001
#define SCF_WORD			0x0002
#define SCF_DEFAULT			0x0000	// Set default charformat or paraformat
#define SCF_ALL				0x0004	// Not valid with SCF_SELECTION or SCF_WORD
#define SCF_USEUIRULES		0x0008	// Modifier for SCF_SELECTION; says that
									//  format came from a toolbar, etc., and
									//  hence UI formatting rules should be
									//  used instead of literal formatting
#define SCF_ASSOCIATEFONT	0x0010	// Associate fontname with bCharSet (one
									//  possible for each of Western, ME, FE,
									//  Thai)
#define SCF_NOKBUPDATE		0x0020	// Do not update KB layput for this change
									//  even if autokeyboard is on
#define SCF_ASSOCIATEFONT2	0x0040	// Associate plane-2 (surrogate) font

typedef struct _charrange
{
	LONG	cpMin;
	LONG	cpMax;
} CHARRANGE;

typedef struct _textrange
{
	CHARRANGE chrg;
	LPSTR lpstrText;	// Allocated by caller, zero terminated by RichEdit 
} TEXTRANGEA;

typedef struct _textrangew
{
	CHARRANGE chrg;
	LPWSTR lpstrText;	// Allocated by caller, zero terminated by RichEdit 
} TEXTRANGEW;

#if (_RICHEDIT_VER >= 0x0200)
#ifdef UNICODE
#define TEXTRANGE 	TEXTRANGEW
#else
#define TEXTRANGE	TEXTRANGEA
#endif // UNICODE 
#else
#define TEXTRANGE	TEXTRANGEA
#endif // _RICHEDIT_VER >= 0x0200 

typedef DWORD (CALLBACK *EDITSTREAMCALLBACK)(DWORD_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb);

typedef struct _editstream
{
	DWORD_PTR dwCookie;		// User value passed to callback as first parameter 
	DWORD	  dwError;		// Last error 
	EDITSTREAMCALLBACK pfnCallback;
} EDITSTREAM;

// Stream formats. Flags are all in low word, since high word
// gives possible codepage choice. 
#define SF_TEXT			0x0001
#define SF_RTF			0x0002
#define SF_RTFNOOBJS	0x0003		// Write only 
#define SF_TEXTIZED		0x0004		// Write only 

#define SF_UNICODE		0x0010		// Unicode file (UCS2 little endian) 
#define SF_USECODEPAGE	0x0020		// CodePage given by high word 
#define SF_NCRFORNONASCII 0x40		// Output /uN for nonASCII 
#define	SFF_WRITEXTRAPAR  0x80		// Output \par at end

// Flag telling stream operations to operate on selection only 
// EM_STREAMIN  replaces current selection 
// EM_STREAMOUT streams out current selection 
#define SFF_SELECTION	0x8000

// Flag telling stream operations to ignore some FE control words 
// having to do with FE word breaking and horiz vs vertical text. 
// Not used in RichEdit 2.0 and later	
#define SFF_PLAINRTF	0x4000

// Flag telling file stream output (SFF_SELECTION flag not set) to persist 
// \viewscaleN control word. 
#define SFF_PERSISTVIEWSCALE 0x2000

// Flag telling file stream input with SFF_SELECTION flag not set not to 
// close the document 
#define SFF_KEEPDOCINFO	0x1000

// Flag telling stream operations to output in Pocket Word format 
#define SFF_PWD			0x0800

// 3-bit field specifying the value of N - 1 to use for \rtfN or \pwdN 
#define SF_RTFVAL		0x0700

typedef struct _findtext
{
	CHARRANGE chrg;
	LPCSTR lpstrText;
} FINDTEXTA;

typedef struct _findtextw
{
	CHARRANGE chrg;
	LPCWSTR lpstrText;
} FINDTEXTW;

#if (_RICHEDIT_VER >= 0x0200)
#ifdef UNICODE
#define FINDTEXT	FINDTEXTW
#else
#define FINDTEXT	FINDTEXTA
#endif	// UNICODE 
#else
#define FINDTEXT	FINDTEXTA
#endif // _RICHEDIT_VER >= 0x0200 

typedef struct _findtextexa
{
	CHARRANGE chrg;
	LPCSTR	  lpstrText;
	CHARRANGE chrgText;
} FINDTEXTEXA;

typedef struct _findtextexw
{
	CHARRANGE chrg;
	LPCWSTR	  lpstrText;
	CHARRANGE chrgText;
} FINDTEXTEXW;

#if (_RICHEDIT_VER >= 0x0200)
#ifdef UNICODE
#define FINDTEXTEX	FINDTEXTEXW
#else
#define FINDTEXTEX	FINDTEXTEXA
#endif // UNICODE 
#else
#define FINDTEXTEX	FINDTEXTEXA
#endif // _RICHEDIT_VER >= 0x0200 


typedef struct _formatrange
{
	HDC hdc;
	HDC hdcTarget;
	RECT rc;
	RECT rcPage;
	CHARRANGE chrg;
} FORMATRANGE;

// All paragraph measurements are in twips 

#define MAX_TAB_STOPS 32
#define lDefaultTab 720
#define MAX_TABLE_CELLS 63

// This is a hack to make PARAFORMAT compatible with RE 1.0 
#define	wReserved	wEffects

typedef struct _paraformat
{
	UINT	cbSize;
	DWORD	dwMask;
	WORD	wNumbering;
	WORD	wEffects;
	LONG	dxStartIndent;
	LONG	dxRightIndent;
	LONG	dxOffset;
	WORD	wAlignment;
	SHORT	cTabCount;
	LONG	rgxTabs[MAX_TAB_STOPS];
} PARAFORMAT;

#ifdef __cplusplus
struct PARAFORMAT2 : _paraformat
{
	LONG	dySpaceBefore;			// Vertical spacing before para
	LONG	dySpaceAfter;			// Vertical spacing after para
	LONG	dyLineSpacing;			// Line spacing depending on Rule
	SHORT	sStyle;					// Style handle
	BYTE	bLineSpacingRule;		// Rule for line spacing (see tom.doc)
	BYTE	bOutlineLevel;			// Outline level
	WORD	wShadingWeight;			// Shading in hundredths of a per cent
	WORD	wShadingStyle;			// Nibble 0: style, 1: cfpat, 2: cbpat
	WORD	wNumberingStart;		// Starting value for numbering
	WORD	wNumberingStyle;		// Alignment, roman/arabic, (), ), ., etc.
	WORD	wNumberingTab;			// Space bet FirstIndent & 1st-line text
	WORD	wBorderSpace;			// Border-text spaces (nbl/bdr in pts)
	WORD	wBorderWidth;			// Pen widths (nbl/bdr in half pts)
	WORD	wBorders;				// Border styles (nibble/border)
};

#else	// Regular C-style	

typedef struct _paraformat2
{
	UINT	cbSize;
	DWORD	dwMask;
	WORD	wNumbering;
	WORD	wReserved;
	LONG	dxStartIndent;
	LONG	dxRightIndent;
	LONG	dxOffset;
	WORD	wAlignment;
	SHORT	cTabCount;
	LONG	rgxTabs[MAX_TAB_STOPS];
 	LONG	dySpaceBefore;			// Vertical spacing before para			
	LONG	dySpaceAfter;			// Vertical spacing after para			
	LONG	dyLineSpacing;			// Line spacing depending on Rule		
	SHORT	sStyle;					// Style handle							
	BYTE	bLineSpacingRule;		// Rule for line spacing (see tom.doc)	
	BYTE	bOutlineLevel;			// Outline Level						
	WORD	wShadingWeight;			// Shading in hundredths of a per cent	
	WORD	wShadingStyle;			// Byte 0: style, nib 2: cfpat, 3: cbpat
	WORD	wNumberingStart;		// Starting value for numbering				
	WORD	wNumberingStyle;		// Alignment, Roman/Arabic, (), ), ., etc.
	WORD	wNumberingTab;			// Space bet 1st indent and 1st-line text
	WORD	wBorderSpace;			// Border-text spaces (nbl/bdr in pts)	
	WORD	wBorderWidth;			// Pen widths (nbl/bdr in half twips)	
	WORD	wBorders;				// Border styles (nibble/border)		
} PARAFORMAT2;

#endif // C++	


// PARAFORMAT mask values 
#define PFM_STARTINDENT			0x00000001
#define PFM_RIGHTINDENT			0x00000002
#define PFM_OFFSET				0x00000004
#define PFM_ALIGNMENT			0x00000008
#define PFM_TABSTOPS			0x00000010
#define PFM_NUMBERING			0x00000020
#define PFM_OFFSETINDENT		0x80000000

// PARAFORMAT 2.0 masks and effects 
#define PFM_SPACEBEFORE			0x00000040
#define PFM_SPACEAFTER			0x00000080
#define PFM_LINESPACING			0x00000100
#define	PFM_STYLE				0x00000400
#define PFM_BORDER				0x00000800	// (*)	
#define PFM_SHADING				0x00001000	// (*)	
#define PFM_NUMBERINGSTYLE		0x00002000	// RE 3.0	
#define PFM_NUMBERINGTAB		0x00004000	// RE 3.0	
#define PFM_NUMBERINGSTART		0x00008000	// RE 3.0	

#define PFM_RTLPARA				0x00010000
#define PFM_KEEP				0x00020000	// (*)	
#define PFM_KEEPNEXT			0x00040000	// (*)	
#define PFM_PAGEBREAKBEFORE		0x00080000	// (*)	
#define PFM_NOLINENUMBER		0x00100000	// (*)	
#define PFM_NOWIDOWCONTROL		0x00200000	// (*)	
#define PFM_DONOTHYPHEN			0x00400000	// (*)	
#define PFM_SIDEBYSIDE			0x00800000	// (*)	
#define PFM_TABLE				0x40000000	// RE 3.0 
#define PFM_TEXTWRAPPINGBREAK	0x20000000	// RE 3.0 
#define PFM_TABLEROWDELIMITER	0x10000000	// RE 4.0 

// The following three properties are read only
#define PFM_COLLAPSED			0x01000000	// RE 3.0 
#define PFM_OUTLINELEVEL		0x02000000	// RE 3.0 
#define PFM_BOX					0x04000000	// RE 3.0 
#define PFM_RESERVED2			0x08000000	// RE 4.0 


// PARAFORMAT "ALL" masks
#define	PFM_ALL (PFM_STARTINDENT | PFM_RIGHTINDENT | PFM_OFFSET	| \
				 PFM_ALIGNMENT   | PFM_TABSTOPS    | PFM_NUMBERING | \
				 PFM_OFFSETINDENT| PFM_RTLPARA)

// Note: PARAFORMAT has no effects (BiDi RichEdit 1.0 does have PFE_RTLPARA)
#define PFM_EFFECTS (PFM_RTLPARA | PFM_KEEP | PFM_KEEPNEXT | PFM_TABLE \
					| PFM_PAGEBREAKBEFORE | PFM_NOLINENUMBER  \
					| PFM_NOWIDOWCONTROL | PFM_DONOTHYPHEN | PFM_SIDEBYSIDE \
					| PFM_TABLE | PFM_TABLEROWDELIMITER)

#define PFM_ALL2	(PFM_ALL | PFM_EFFECTS | PFM_SPACEBEFORE | PFM_SPACEAFTER \
					| PFM_LINESPACING | PFM_STYLE | PFM_SHADING | PFM_BORDER \
					| PFM_NUMBERINGTAB | PFM_NUMBERINGSTART | PFM_NUMBERINGSTYLE)

#define PFE_RTLPARA				(PFM_RTLPARA		 >> 16)
#define PFE_KEEP				(PFM_KEEP			 >> 16)	// (*)	
#define PFE_KEEPNEXT			(PFM_KEEPNEXT		 >> 16)	// (*)	
#define PFE_PAGEBREAKBEFORE		(PFM_PAGEBREAKBEFORE >> 16)	// (*)	
#define PFE_NOLINENUMBER		(PFM_NOLINENUMBER	 >> 16)	// (*)	
#define PFE_NOWIDOWCONTROL		(PFM_NOWIDOWCONTROL	 >> 16)	// (*)	
#define PFE_DONOTHYPHEN			(PFM_DONOTHYPHEN 	 >> 16)	// (*)	
#define PFE_SIDEBYSIDE			(PFM_SIDEBYSIDE		 >> 16)	// (*)	
#define PFE_TEXTWRAPPINGBREAK	(PFM_TEXTWRAPPINGBREAK>>16) // (*)	

// The following four effects are read only
#define PFE_COLLAPSED			(PFM_COLLAPSED		 >> 16)	// (+)	
#define PFE_BOX					(PFM_BOX			 >> 16)	// (+)	
#define PFE_TABLE				(PFM_TABLE			 >> 16)	// Inside table row. RE 3.0 
#define PFE_TABLEROWDELIMITER	(PFM_TABLEROWDELIMITER>>16)	// Table row start. RE 4.0 

// PARAFORMAT numbering options 
#define PFN_BULLET		1		// tomListBullet

// PARAFORMAT2 wNumbering options 
#define PFN_ARABIC		2		// tomListNumberAsArabic:   0, 1, 2,	...
#define PFN_LCLETTER	3		// tomListNumberAsLCLetter: a, b, c,	...
#define	PFN_UCLETTER	4		// tomListNumberAsUCLetter: A, B, C,	...
#define	PFN_LCROMAN		5		// tomListNumberAsLCRoman:  i, ii, iii,	...
#define	PFN_UCROMAN		6		// tomListNumberAsUCRoman:  I, II, III,	...

// PARAFORMAT2 wNumberingStyle options 
#define PFNS_PAREN		0x000	// default, e.g.,				  1)	
#define	PFNS_PARENS		0x100	// tomListParentheses/256, e.g., (1)	
#define PFNS_PERIOD		0x200	// tomListPeriod/256, e.g.,		  1.	
#define PFNS_PLAIN		0x300	// tomListPlain/256, e.g.,		  1		
#define PFNS_NONUMBER	0x400	// Used for continuation w/o number

#define PFNS_NEWNUMBER	0x8000	// Start new number with wNumberingStart		
								// (can be combined with other PFNS_xxx)
// PARAFORMAT alignment options 
#define PFA_LEFT			 1
#define PFA_RIGHT			 2
#define PFA_CENTER			 3

// PARAFORMAT2 alignment options 
#define	PFA_JUSTIFY			 4	// New paragraph-alignment option 2.0 (*) 
#define PFA_FULL_INTERWORD	 4	// These are supported in 3.0 with advanced
#define PFA_FULL_INTERLETTER 5	//  typography enabled
#define PFA_FULL_SCALED		 6
#define	PFA_FULL_GLYPHS		 7
#define	PFA_SNAP_GRID		 8


// Notification structures 
#ifndef WM_NOTIFY
#define WM_NOTIFY		0x004E

typedef struct _nmhdr
{
	HWND	hwndFrom;
	UINT	idFrom;
	UINT	code;
} NMHDR;
#endif  // !WM_NOTIFY 

typedef struct _msgfilter
{
	NMHDR	nmhdr;
	UINT	msg;
	WPARAM	wParam;
	LPARAM	lParam;
} MSGFILTER;

typedef struct _reqresize
{
	NMHDR nmhdr;
	RECT rc;
} REQRESIZE;

typedef struct _selchange
{
	NMHDR nmhdr;
	CHARRANGE chrg;
	WORD seltyp;
} SELCHANGE;


#define SEL_EMPTY		0x0000
#define SEL_TEXT		0x0001
#define SEL_OBJECT		0x0002
#define SEL_MULTICHAR	0x0004
#define SEL_MULTIOBJECT	0x0008

// Used with IRichEditOleCallback::GetContextMenu, this flag will be
// passed as a "selection type".  It indicates that a context menu for
// a right-mouse drag drop should be generated.  The IOleObject parameter
// will really be the IDataObject for the drop
#define GCM_RIGHTMOUSEDROP  0x8000

typedef struct _endropfiles
{
	NMHDR nmhdr;
	HANDLE hDrop;
	LONG cp;
	BOOL fProtected;
} ENDROPFILES;

typedef struct _enprotected
{
	NMHDR nmhdr;
	UINT msg;
	WPARAM wParam;
	LPARAM lParam;
	CHARRANGE chrg;
} ENPROTECTED;

typedef struct _ensaveclipboard
{
	NMHDR nmhdr;
	LONG cObjectCount;
    LONG cch;
} ENSAVECLIPBOARD;

#ifndef MACPORT
typedef struct _enoleopfailed
{
	NMHDR nmhdr;
	LONG iob;
	LONG lOper;
	HRESULT hr;
} ENOLEOPFAILED;
#endif

#define	OLEOP_DOVERB	1

typedef struct _objectpositions
{
    NMHDR nmhdr;
    LONG cObjectCount;
    LONG *pcpPositions;
} OBJECTPOSITIONS;

typedef struct _enlink
{
    NMHDR nmhdr;
    UINT msg;
    WPARAM wParam;
    LPARAM lParam;
    CHARRANGE chrg;
} ENLINK;

typedef struct _enlowfirtf
{
    NMHDR nmhdr;
	char *szControl;
} ENLOWFIRTF;

// PenWin specific 
typedef struct _encorrecttext
{
	NMHDR nmhdr;
	CHARRANGE chrg;
	WORD seltyp;
} ENCORRECTTEXT;

// East Asia specific 
typedef struct _punctuation
{
	UINT	iSize;
	LPSTR	szPunctuation;
} PUNCTUATION;

// East Asia specific 
typedef struct _compcolor
{
	COLORREF crText;
	COLORREF crBackground;
	DWORD dwEffects;
}COMPCOLOR;


// Clipboard formats - use as parameter to RegisterClipboardFormat() 
#define CF_RTF 			TEXT("Rich Text Format")
#define CF_RTFNOOBJS 	TEXT("Rich Text Format Without Objects")
#define CF_RETEXTOBJ 	TEXT("RichEdit Text and Objects")

// Paste Special 
typedef struct _repastespecial
{
	DWORD		dwAspect;
	DWORD_PTR	dwParam;
} REPASTESPECIAL;

//	UndoName info 
typedef enum _undonameid
{
    UID_UNKNOWN     = 0,
	UID_TYPING		= 1,
	UID_DELETE 		= 2,
	UID_DRAGDROP	= 3,
	UID_CUT			= 4,
	UID_PASTE		= 5,
	UID_AUTOCORRECT = 6
} UNDONAMEID;

// Flags for the SETEXTEX data structure 
#define ST_DEFAULT		0
#define ST_KEEPUNDO		1
#define ST_SELECTION	2
#define ST_NEWCHARS 	4

// EM_SETTEXTEX info; this struct is passed in the wparam of the message 
typedef struct _settextex
{
	DWORD	flags;			// Flags (see the ST_XXX defines)			
	UINT	codepage;		// Code page for translation (CP_ACP for sys default,
						    //  1200 for Unicode, -1 for control default)	
} SETTEXTEX;

// Flags for the GETEXTEX data structure 
#define GT_DEFAULT		0
#define GT_USECRLF		1
#define GT_SELECTION	2
#define GT_RAWTEXT		4
#define GT_NOHIDDENTEXT	8

// EM_GETTEXTEX info; this struct is passed in the wparam of the message 
typedef struct _gettextex
{
	DWORD	cb;				// Count of bytes in the string				
	DWORD	flags;			// Flags (see the GT_XXX defines			
	UINT	codepage;		// Code page for translation (CP_ACP for sys default,
						    //  1200 for Unicode, -1 for control default)	
	LPCSTR	lpDefaultChar;	// Replacement for unmappable chars			
	LPBOOL	lpUsedDefChar;	// Pointer to flag set when def char used	
} GETTEXTEX;

// Flags for the GETTEXTLENGTHEX data structure							
#define GTL_DEFAULT		0	// Do default (return # of chars)		
#define GTL_USECRLF		1	// Compute answer using CRLFs for paragraphs
#define GTL_PRECISE		2	// Compute a precise answer					
#define GTL_CLOSE		4	// Fast computation of a "close" answer		
#define GTL_NUMCHARS	8	// Return number of characters			
#define GTL_NUMBYTES	16	// Return number of _bytes_				

// EM_GETTEXTLENGTHEX info; this struct is passed in the wparam of the msg 
typedef struct _gettextlengthex
{
	DWORD	flags;			// Flags (see GTL_XXX defines)				
	UINT	codepage;		// Code page for translation (CP_ACP for default,
							//  1200 for Unicode)							
} GETTEXTLENGTHEX;
	
// BiDi specific features 
typedef struct _bidioptions
{
	UINT	cbSize;
	WORD	wMask;
	WORD	wEffects; 
} BIDIOPTIONS;

// BIDIOPTIONS masks 
#if (_RICHEDIT_VER == 0x0100)
#define BOM_DEFPARADIR			0x0001	// Default paragraph direction (implies alignment) (obsolete) 
#define BOM_PLAINTEXT			0x0002	// Use plain text layout (obsolete) 
#endif // _RICHEDIT_VER == 0x0100 
#define BOM_NEUTRALOVERRIDE		0x0004	// Override neutral layout (obsolete) 
#define BOM_CONTEXTREADING		0x0008	// Context reading order 
#define BOM_CONTEXTALIGNMENT	0x0010	// Context alignment 

// BIDIOPTIONS effects 
#if (_RICHEDIT_VER == 0x0100)
#define BOE_RTLDIR				0x0001	// Default paragraph direction (implies alignment) (obsolete) 
#define BOE_PLAINTEXT			0x0002	// Use plain text layout (obsolete) 
#endif // _RICHEDIT_VER == 0x0100 
#define BOE_NEUTRALOVERRIDE		0x0004	// Override neutral layout (obsolete) 
#define BOE_CONTEXTREADING		0x0008	// Context reading order 
#define BOE_CONTEXTALIGNMENT	0x0010	// Context alignment 

// Additional EM_FINDTEXT[EX] flags 
#define FR_MATCHDIAC                    0x20000000
#define FR_MATCHKASHIDA                 0x40000000
#define FR_MATCHALEFHAMZA               0x80000000
	
// UNICODE embedding character 
#ifndef WCH_EMBEDDING
#define WCH_EMBEDDING (WCHAR)0xFFFC
#endif // WCH_EMBEDDING 
		
// khyph - Kind of hyphenation
typedef enum tagKHYPH
{
	khyphNil,				// No Hyphenation
	khyphNormal,			// Normal Hyphenation
	khyphAddBefore,			// Add letter before hyphen
	khyphChangeBefore,		// Change letter before hyphen
	khyphDeleteBefore,		// Delete letter before hyphen
	khyphChangeAfter,		// Change letter after hyphen
	khyphDelAndChange		// Delete letter before hyphen and change
							//  letter preceding hyphen
} KHYPH;

typedef struct hyphresult
{
	KHYPH khyph;			// Kind of hyphenation
	long  ichHyph;			// Character which was hyphenated
	WCHAR chHyph;			// Depending on hyphenation type, character added, changed, etc.
} HYPHRESULT;

void WINAPI HyphenateProc(WCHAR *pszWord, LANGID langid, long ichExceed, HYPHRESULT *phyphresult);
typedef struct tagHyphenateInfo
{
	SHORT cbSize;			// Size of HYPHENATEINFO structure
	SHORT dxHyphenateZone;	// If a space character is closer to the margin
							//  than this value, don't hyphenate (in TWIPs)
	void (WINAPI* pfnHyphenate)(WCHAR*, LANGID, long, HYPHRESULT*);
} HYPHENATEINFO;

#ifdef _WIN32
#include <poppack.h>
#elif !defined(RC_INVOKED)
#pragma pack()
#endif

#ifdef __cplusplus
}
#endif  // __cplusplus 

#endif // !_RICHEDIT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\rmxftmpl.h ===
/* D3DRM XFile templates in binary form */

#ifndef _RMXFTMPL_H_
#define _RMXFTMPL_H_

unsigned char D3DRM_XTEMPLATES[] = {
	0x78, 0x6f, 0x66, 0x20, 0x30, 0x33, 0x30, 0x32, 0x62, 
	0x69, 0x6e, 0x20, 0x30, 0x30, 0x36, 0x34, 0x1f, 0, 0x1, 
	0, 0x6, 0, 0, 0, 0x48, 0x65, 0x61, 0x64, 0x65, 
	0x72, 0xa, 0, 0x5, 0, 0x43, 0xab, 0x82, 0x3d, 0xda, 
	0x62, 0xcf, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 
	0x33, 0x28, 0, 0x1, 0, 0x5, 0, 0, 0, 0x6d, 
	0x61, 0x6a, 0x6f, 0x72, 0x14, 0, 0x28, 0, 0x1, 0, 
	0x5, 0, 0, 0, 0x6d, 0x69, 0x6e, 0x6f, 0x72, 0x14, 
	0, 0x29, 0, 0x1, 0, 0x5, 0, 0, 0, 0x66, 
	0x6c, 0x61, 0x67, 0x73, 0x14, 0, 0xb, 0, 0x1f, 0, 
	0x1, 0, 0x6, 0, 0, 0, 0x56, 0x65, 0x63, 0x74, 
	0x6f, 0x72, 0xa, 0, 0x5, 0, 0x5e, 0xab, 0x82, 0x3d, 
	0xda, 0x62, 0xcf, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 
	0xe4, 0x33, 0x2a, 0, 0x1, 0, 0x1, 0, 0, 0, 
	0x78, 0x14, 0, 0x2a, 0, 0x1, 0, 0x1, 0, 0, 
	0, 0x79, 0x14, 0, 0x2a, 0, 0x1, 0, 0x1, 0, 
	0, 0, 0x7a, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 
	0, 0x8, 0, 0, 0, 0x43, 0x6f, 0x6f, 0x72, 0x64, 
	0x73, 0x32, 0x64, 0xa, 0, 0x5, 0, 0x44, 0x3f, 0xf2, 
	0xf6, 0x86, 0x76, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 
	0x35, 0x94, 0xa3, 0x2a, 0, 0x1, 0, 0x1, 0, 0, 
	0, 0x75, 0x14, 0, 0x2a, 0, 0x1, 0, 0x1, 0, 
	0, 0, 0x76, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 
	0, 0x9, 0, 0, 0, 0x4d, 0x61, 0x74, 0x72, 0x69, 
	0x78, 0x34, 0x78, 0x34, 0xa, 0, 0x5, 0, 0x45, 0x3f, 
	0xf2, 0xf6, 0x86, 0x76, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 
	0x33, 0x35, 0x94, 0xa3, 0x34, 0, 0x2a, 0, 0x1, 0, 
	0x6, 0, 0, 0, 0x6d, 0x61, 0x74, 0x72, 0x69, 0x78, 
	0xe, 0, 0x3, 0, 0x10, 0, 0, 0, 0xf, 0, 
	0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 0x9, 0, 
	0, 0, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 
	0x41, 0xa, 0, 0x5, 0, 0xe0, 0x44, 0xff, 0x35, 0x7c, 
	0x6c, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 
	0xa3, 0x2a, 0, 0x1, 0, 0x3, 0, 0, 0, 0x72, 
	0x65, 0x64, 0x14, 0, 0x2a, 0, 0x1, 0, 0x5, 0, 
	0, 0, 0x67, 0x72, 0x65, 0x65, 0x6e, 0x14, 0, 0x2a, 
	0, 0x1, 0, 0x4, 0, 0, 0, 0x62, 0x6c, 0x75, 
	0x65, 0x14, 0, 0x2a, 0, 0x1, 0, 0x5, 0, 0, 
	0, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x14, 0, 0xb, 0, 
	0x1f, 0, 0x1, 0, 0x8, 0, 0, 0, 0x43, 0x6f, 
	0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 0xa, 0, 0x5, 0, 
	0x81, 0x6e, 0xe1, 0xd3, 0x35, 0x78, 0xcf, 0x11, 0x8f, 0x52, 
	0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x2a, 0, 0x1, 0, 
	0x3, 0, 0, 0, 0x72, 0x65, 0x64, 0x14, 0, 0x2a, 
	0, 0x1, 0, 0x5, 0, 0, 0, 0x67, 0x72, 0x65, 
	0x65, 0x6e, 0x14, 0, 0x2a, 0, 0x1, 0, 0x4, 0, 
	0, 0, 0x62, 0x6c, 0x75, 0x65, 0x14, 0, 0xb, 0, 
	0x1f, 0, 0x1, 0, 0xc, 0, 0, 0, 0x49, 0x6e, 
	0x64, 0x65, 0x78, 0x65, 0x64, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 
	0xa, 0, 0x5, 0, 0x20, 0xb8, 0x30, 0x16, 0x42, 0x78, 
	0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 
	0x29, 0, 0x1, 0, 0x5, 0, 0, 0, 0x69, 0x6e, 
	0x64, 0x65, 0x78, 0x14, 0, 0x1, 0, 0x9, 0, 0, 
	0, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 0x41, 
	0x1, 0, 0xa, 0, 0, 0, 0x69, 0x6e, 0x64, 0x65, 
	0x78, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x14, 0, 0xb, 0, 
	0x1f, 0, 0x1, 0, 0x7, 0, 0, 0, 0x42, 0x6f, 
	0x6f, 0x6c, 0x65, 0x61, 0x6e, 0xa, 0, 0x5, 0, 0xa0, 
	0xa6, 0x7d, 0x53, 0x37, 0xca, 0xd0, 0x11, 0x94, 0x1c, 0, 
	0x80, 0xc8, 0xc, 0xfa, 0x7b, 0x29, 0, 0x1, 0, 0x9, 
	0, 0, 0, 0x74, 0x72, 0x75, 0x65, 0x66, 0x61, 0x6c, 
	0x73, 0x65, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
	0x9, 0, 0, 0, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 
	0x6e, 0x32, 0x64, 0xa, 0, 0x5, 0, 0x63, 0xae, 0x85, 
	0x48, 0xe8, 0x78, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 
	0x35, 0x94, 0xa3, 0x1, 0, 0x7, 0, 0, 0, 0x42, 
	0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x1, 0, 0x1, 0, 
	0, 0, 0x75, 0x14, 0, 0x1, 0, 0x7, 0, 0, 
	0, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x1, 0, 
	0x1, 0, 0, 0, 0x76, 0x14, 0, 0xb, 0, 0x1f, 
	0, 0x1, 0, 0xc, 0, 0, 0, 0x4d, 0x61, 0x74, 
	0x65, 0x72, 0x69, 0x61, 0x6c, 0x57, 0x72, 0x61, 0x70, 0xa, 
	0, 0x5, 0, 0x60, 0xae, 0x85, 0x48, 0xe8, 0x78, 0xcf, 
	0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x1, 
	0, 0x7, 0, 0, 0, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 
	0x61, 0x6e, 0x1, 0, 0x1, 0, 0, 0, 0x75, 0x14, 
	0, 0x1, 0, 0x7, 0, 0, 0, 0x42, 0x6f, 0x6f, 
	0x6c, 0x65, 0x61, 0x6e, 0x1, 0, 0x1, 0, 0, 0, 
	0x76, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 0xf, 
	0, 0, 0, 0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 
	0x46, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0xa, 0, 
	0x5, 0, 0xe1, 0x90, 0x27, 0xa4, 0x10, 0x78, 0xcf, 0x11, 
	0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x31, 0, 
	0x1, 0, 0x8, 0, 0, 0, 0x66, 0x69, 0x6c, 0x65, 
	0x6e, 0x61, 0x6d, 0x65, 0x14, 0, 0xb, 0, 0x1f, 0, 
	0x1, 0, 0x8, 0, 0, 0, 0x4d, 0x61, 0x74, 0x65, 
	0x72, 0x69, 0x61, 0x6c, 0xa, 0, 0x5, 0, 0x4d, 0xab, 
	0x82, 0x3d, 0xda, 0x62, 0xcf, 0x11, 0xab, 0x39, 0, 0x20, 
	0xaf, 0x71, 0xe4, 0x33, 0x1, 0, 0x9, 0, 0, 0, 
	0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 0x41, 0x1, 
	0, 0x9, 0, 0, 0, 0x66, 0x61, 0x63, 0x65, 0x43, 
	0x6f, 0x6c, 0x6f, 0x72, 0x14, 0, 0x2a, 0, 0x1, 0, 
	0x5, 0, 0, 0, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x14, 
	0, 0x1, 0, 0x8, 0, 0, 0, 0x43, 0x6f, 0x6c, 
	0x6f, 0x72, 0x52, 0x47, 0x42, 0x1, 0, 0xd, 0, 0, 
	0, 0x73, 0x70, 0x65, 0x63, 0x75, 0x6c, 0x61, 0x72, 0x43, 
	0x6f, 0x6c, 0x6f, 0x72, 0x14, 0, 0x1, 0, 0x8, 0, 
	0, 0, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 
	0x1, 0, 0xd, 0, 0, 0, 0x65, 0x6d, 0x69, 0x73, 
	0x73, 0x69, 0x76, 0x65, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x14, 
	0, 0xe, 0, 0x12, 0, 0x12, 0, 0x12, 0, 0xf, 
	0, 0xb, 0, 0x1f, 0, 0x1, 0, 0x8, 0, 0, 
	0, 0x4d, 0x65, 0x73, 0x68, 0x46, 0x61, 0x63, 0x65, 0xa, 
	0, 0x5, 0, 0x5f, 0xab, 0x82, 0x3d, 0xda, 0x62, 0xcf, 
	0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 0x29, 
	0, 0x1, 0, 0x12, 0, 0, 0, 0x6e, 0x46, 0x61, 
	0x63, 0x65, 0x56, 0x65, 0x72, 0x74, 0x65, 0x78, 0x49, 0x6e, 
	0x64, 0x69, 0x63, 0x65, 0x73, 0x14, 0, 0x34, 0, 0x29, 
	0, 0x1, 0, 0x11, 0, 0, 0, 0x66, 0x61, 0x63, 
	0x65, 0x56, 0x65, 0x72, 0x74, 0x65, 0x78, 0x49, 0x6e, 0x64, 
	0x69, 0x63, 0x65, 0x73, 0xe, 0, 0x1, 0, 0x12, 0, 
	0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 0x56, 0x65, 0x72, 
	0x74, 0x65, 0x78, 0x49, 0x6e, 0x64, 0x69, 0x63, 0x65, 0x73, 
	0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
	0xd, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 0x46, 0x61, 
	0x63, 0x65, 0x57, 0x72, 0x61, 0x70, 0x73, 0xa, 0, 0x5, 
	0, 0xc0, 0xc5, 0x1e, 0xed, 0xa8, 0xc0, 0xd0, 0x11, 0x94, 
	0x1c, 0, 0x80, 0xc8, 0xc, 0xfa, 0x7b, 0x29, 0, 0x1, 
	0, 0xf, 0, 0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 
	0x57, 0x72, 0x61, 0x70, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 
	0x14, 0, 0x34, 0, 0x1, 0, 0x9, 0, 0, 0, 
	0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x32, 0x64, 0x1, 
	0, 0xe, 0, 0, 0, 0x66, 0x61, 0x63, 0x65, 0x57, 
	0x72, 0x61, 0x70, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0xe, 
	0, 0x1, 0, 0xf, 0, 0, 0, 0x6e, 0x46, 0x61, 
	0x63, 0x65, 0x57, 0x72, 0x61, 0x70, 0x56, 0x61, 0x6c, 0x75, 
	0x65, 0x73, 0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 
	0x1, 0, 0x11, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 
	0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x43, 0x6f, 0x6f, 
	0x72, 0x64, 0x73, 0xa, 0, 0x5, 0, 0x40, 0x3f, 0xf2, 
	0xf6, 0x86, 0x76, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 
	0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0xe, 0, 0, 
	0, 0x6e, 0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x43, 
	0x6f, 0x6f, 0x72, 0x64, 0x73, 0x14, 0, 0x34, 0, 0x1, 
	0, 0x8, 0, 0, 0, 0x43, 0x6f, 0x6f, 0x72, 0x64, 
	0x73, 0x32, 0x64, 0x1, 0, 0xd, 0, 0, 0, 0x74, 
	0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x43, 0x6f, 0x6f, 0x72, 
	0x64, 0x73, 0xe, 0, 0x1, 0, 0xe, 0, 0, 0, 
	0x6e, 0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x43, 0x6f, 
	0x6f, 0x72, 0x64, 0x73, 0xf, 0, 0x14, 0, 0xb, 0, 
	0x1f, 0, 0x1, 0, 0x10, 0, 0, 0, 0x4d, 0x65, 
	0x73, 0x68, 0x4d, 0x61, 0x74, 0x65, 0x72, 0x69, 0x61, 0x6c, 
	0x4c, 0x69, 0x73, 0x74, 0xa, 0, 0x5, 0, 0x42, 0x3f, 
	0xf2, 0xf6, 0x86, 0x76, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 
	0x33, 0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0xa, 0, 
	0, 0, 0x6e, 0x4d, 0x61, 0x74, 0x65, 0x72, 0x69, 0x61, 
	0x6c, 0x73, 0x14, 0, 0x29, 0, 0x1, 0, 0xc, 0, 
	0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 0x49, 0x6e, 0x64, 
	0x65, 0x78, 0x65, 0x73, 0x14, 0, 0x34, 0, 0x29, 0, 
	0x1, 0, 0xb, 0, 0, 0, 0x66, 0x61, 0x63, 0x65, 
	0x49, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x73, 0xe, 0, 0x1, 
	0, 0xc, 0, 0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 
	0x49, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x73, 0xf, 0, 0x14, 
	0, 0xe, 0, 0x1, 0, 0x8, 0, 0, 0, 0x4d, 
	0x61, 0x74, 0x65, 0x72, 0x69, 0x61, 0x6c, 0xf, 0, 0xb, 
	0, 0x1f, 0, 0x1, 0, 0xb, 0, 0, 0, 0x4d, 
	0x65, 0x73, 0x68, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x73, 
	0xa, 0, 0x5, 0, 0x43, 0x3f, 0xf2, 0xf6, 0x86, 0x76, 
	0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 
	0x29, 0, 0x1, 0, 0x8, 0, 0, 0, 0x6e, 0x4e, 
	0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x73, 0x14, 0, 0x34, 0, 
	0x1, 0, 0x6, 0, 0, 0, 0x56, 0x65, 0x63, 0x74, 
	0x6f, 0x72, 0x1, 0, 0x7, 0, 0, 0, 0x6e, 0x6f, 
	0x72, 0x6d, 0x61, 0x6c, 0x73, 0xe, 0, 0x1, 0, 0x8, 
	0, 0, 0, 0x6e, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 
	0x73, 0xf, 0, 0x14, 0, 0x29, 0, 0x1, 0, 0xc, 
	0, 0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 0x4e, 0x6f, 
	0x72, 0x6d, 0x61, 0x6c, 0x73, 0x14, 0, 0x34, 0, 0x1, 
	0, 0x8, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 0x46, 
	0x61, 0x63, 0x65, 0x1, 0, 0xb, 0, 0, 0, 0x66, 
	0x61, 0x63, 0x65, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x73, 
	0xe, 0, 0x1, 0, 0xc, 0, 0, 0, 0x6e, 0x46, 
	0x61, 0x63, 0x65, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x73, 
	0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
	0x10, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 0x56, 0x65, 
	0x72, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x73, 
	0xa, 0, 0x5, 0, 0x21, 0xb8, 0x30, 0x16, 0x42, 0x78, 
	0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 
	0x29, 0, 0x1, 0, 0xd, 0, 0, 0, 0x6e, 0x56, 
	0x65, 0x72, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 
	0x73, 0x14, 0, 0x34, 0, 0x1, 0, 0xc, 0, 0, 
	0, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x64, 0x43, 0x6f, 
	0x6c, 0x6f, 0x72, 0x1, 0, 0xc, 0, 0, 0, 0x76, 
	0x65, 0x72, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 
	0x73, 0xe, 0, 0x1, 0, 0xd, 0, 0, 0, 0x6e, 
	0x56, 0x65, 0x72, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6f, 
	0x72, 0x73, 0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 
	0x1, 0, 0x4, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 
	0xa, 0, 0x5, 0, 0x44, 0xab, 0x82, 0x3d, 0xda, 0x62, 
	0xcf, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 
	0x29, 0, 0x1, 0, 0x9, 0, 0, 0, 0x6e, 0x56, 
	0x65, 0x72, 0x74, 0x69, 0x63, 0x65, 0x73, 0x14, 0, 0x34, 
	0, 0x1, 0, 0x6, 0, 0, 0, 0x56, 0x65, 0x63, 
	0x74, 0x6f, 0x72, 0x1, 0, 0x8, 0, 0, 0, 0x76, 
	0x65, 0x72, 0x74, 0x69, 0x63, 0x65, 0x73, 0xe, 0, 0x1, 
	0, 0x9, 0, 0, 0, 0x6e, 0x56, 0x65, 0x72, 0x74, 
	0x69, 0x63, 0x65, 0x73, 0xf, 0, 0x14, 0, 0x29, 0, 
	0x1, 0, 0x6, 0, 0, 0, 0x6e, 0x46, 0x61, 0x63, 
	0x65, 0x73, 0x14, 0, 0x34, 0, 0x1, 0, 0x8, 0, 
	0, 0, 0x4d, 0x65, 0x73, 0x68, 0x46, 0x61, 0x63, 0x65, 
	0x1, 0, 0x5, 0, 0, 0, 0x66, 0x61, 0x63, 0x65, 
	0x73, 0xe, 0, 0x1, 0, 0x6, 0, 0, 0, 0x6e, 
	0x46, 0x61, 0x63, 0x65, 0x73, 0xf, 0, 0x14, 0, 0xe, 
	0, 0x12, 0, 0x12, 0, 0x12, 0, 0xf, 0, 0xb, 
	0, 0x1f, 0, 0x1, 0, 0x14, 0, 0, 0, 0x46, 
	0x72, 0x61, 0x6d, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 
	0x6f, 0x72, 0x6d, 0x4d, 0x61, 0x74, 0x72, 0x69, 0x78, 0xa, 
	0, 0x5, 0, 0x41, 0x3f, 0xf2, 0xf6, 0x86, 0x76, 0xcf, 
	0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x1, 
	0, 0x9, 0, 0, 0, 0x4d, 0x61, 0x74, 0x72, 0x69, 
	0x78, 0x34, 0x78, 0x34, 0x1, 0, 0xb, 0, 0, 0, 
	0x66, 0x72, 0x61, 0x6d, 0x65, 0x4d, 0x61, 0x74, 0x72, 0x69, 
	0x78, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 0x5, 
	0, 0, 0, 0x46, 0x72, 0x61, 0x6d, 0x65, 0xa, 0, 
	0x5, 0, 0x46, 0xab, 0x82, 0x3d, 0xda, 0x62, 0xcf, 0x11, 
	0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 0xe, 0, 
	0x12, 0, 0x12, 0, 0x12, 0, 0xf, 0, 0xb, 0, 
	0x1f, 0, 0x1, 0, 0x9, 0, 0, 0, 0x46, 0x6c, 
	0x6f, 0x61, 0x74, 0x4b, 0x65, 0x79, 0x73, 0xa, 0, 0x5, 
	0, 0xa9, 0x46, 0xdd, 0x10, 0x5b, 0x77, 0xcf, 0x11, 0x8f, 
	0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x29, 0, 0x1, 
	0, 0x7, 0, 0, 0, 0x6e, 0x56, 0x61, 0x6c, 0x75, 
	0x65, 0x73, 0x14, 0, 0x34, 0, 0x2a, 0, 0x1, 0, 
	0x6, 0, 0, 0, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 
	0xe, 0, 0x1, 0, 0x7, 0, 0, 0, 0x6e, 0x56, 
	0x61, 0x6c, 0x75, 0x65, 0x73, 0xf, 0, 0x14, 0, 0xb, 
	0, 0x1f, 0, 0x1, 0, 0xe, 0, 0, 0, 0x54, 
	0x69, 0x6d, 0x65, 0x64, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x4b, 
	0x65, 0x79, 0x73, 0xa, 0, 0x5, 0, 0x80, 0xb1, 0x6, 
	0xf4, 0x3b, 0x7b, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 
	0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0x4, 0, 0, 
	0, 0x74, 0x69, 0x6d, 0x65, 0x14, 0, 0x1, 0, 0x9, 
	0, 0, 0, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x4b, 0x65, 
	0x79, 0x73, 0x1, 0, 0x6, 0, 0, 0, 0x74, 0x66, 
	0x6b, 0x65, 0x79, 0x73, 0x14, 0, 0xb, 0, 0x1f, 0, 
	0x1, 0, 0xc, 0, 0, 0, 0x41, 0x6e, 0x69, 0x6d, 
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4b, 0x65, 0x79, 0xa, 0, 
	0x5, 0, 0xa8, 0x46, 0xdd, 0x10, 0x5b, 0x77, 0xcf, 0x11, 
	0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x29, 0, 
	0x1, 0, 0x7, 0, 0, 0, 0x6b, 0x65, 0x79, 0x54, 
	0x79, 0x70, 0x65, 0x14, 0, 0x29, 0, 0x1, 0, 0x5, 
	0, 0, 0, 0x6e, 0x4b, 0x65, 0x79, 0x73, 0x14, 0, 
	0x34, 0, 0x1, 0, 0xe, 0, 0, 0, 0x54, 0x69, 
	0x6d, 0x65, 0x64, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x4b, 0x65, 
	0x79, 0x73, 0x1, 0, 0x4, 0, 0, 0, 0x6b, 0x65, 
	0x79, 0x73, 0xe, 0, 0x1, 0, 0x5, 0, 0, 0, 
	0x6e, 0x4b, 0x65, 0x79, 0x73, 0xf, 0, 0x14, 0, 0xb, 
	0, 0x1f, 0, 0x1, 0, 0x10, 0, 0, 0, 0x41, 
	0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4f, 0x70, 
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0xa, 0, 0x5, 0, 0xc0, 
	0x56, 0xbf, 0xe2, 0xf, 0x84, 0xcf, 0x11, 0x8f, 0x52, 0, 
	0x40, 0x33, 0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0xa, 
	0, 0, 0, 0x6f, 0x70, 0x65, 0x6e, 0x63, 0x6c, 0x6f, 
	0x73, 0x65, 0x64, 0x14, 0, 0x29, 0, 0x1, 0, 0xf, 
	0, 0, 0, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 
	0x6e, 0x71, 0x75, 0x61, 0x6c, 0x69, 0x74, 0x79, 0x14, 0, 
	0xb, 0, 0x1f, 0, 0x1, 0, 0x9, 0, 0, 0, 
	0x41, 0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0xa, 
	0, 0x5, 0, 0x4f, 0xab, 0x82, 0x3d, 0xda, 0x62, 0xcf, 
	0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 0xe, 
	0, 0x12, 0, 0x12, 0, 0x12, 0, 0xf, 0, 0xb, 
	0, 0x1f, 0, 0x1, 0, 0xc, 0, 0, 0, 0x41, 
	0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x65, 
	0x74, 0xa, 0, 0x5, 0, 0x50, 0xab, 0x82, 0x3d, 0xda, 
	0x62, 0xcf, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 
	0x33, 0xe, 0, 0x1, 0, 0x9, 0, 0, 0, 0x41, 
	0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0xf, 0, 
	0xb, 0, 0x1f, 0, 0x1, 0, 0xa, 0, 0, 0, 
	0x49, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x44, 0x61, 0x74, 0x61, 
	0xa, 0, 0x5, 0, 0xa0, 0xee, 0x23, 0x3a, 0xb1, 0x94, 
	0xd0, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 
	0xe, 0, 0x1, 0, 0x6, 0, 0, 0, 0x42, 0x49, 
	0x4e, 0x41, 0x52, 0x59, 0xf, 0, 0xb, 0, 0x1f, 0, 
	0x1, 0, 0x3, 0, 0, 0, 0x55, 0x72, 0x6c, 0xa, 
	0, 0x5, 0, 0xa1, 0xee, 0x23, 0x3a, 0xb1, 0x94, 0xd0, 
	0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 0x29, 
	0, 0x1, 0, 0x5, 0, 0, 0, 0x6e, 0x55, 0x72, 
	0x6c, 0x73, 0x14, 0, 0x34, 0, 0x31, 0, 0x1, 0, 
	0x4, 0, 0, 0, 0x75, 0x72, 0x6c, 0x73, 0xe, 0, 
	0x1, 0, 0x5, 0, 0, 0, 0x6e, 0x55, 0x72, 0x6c, 
	0x73, 0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 
	0, 0xf, 0, 0, 0, 0x50, 0x72, 0x6f, 0x67, 0x72, 
	0x65, 0x73, 0x73, 0x69, 0x76, 0x65, 0x4d, 0x65, 0x73, 0x68, 
	0xa, 0, 0x5, 0, 0x60, 0xc3, 0x63, 0x8a, 0x7d, 0x99, 
	0xd0, 0x11, 0x94, 0x1c, 0, 0x80, 0xc8, 0xc, 0xfa, 0x7b, 
	0xe, 0, 0x1, 0, 0x3, 0, 0, 0, 0x55, 0x72, 
	0x6c, 0x13, 0, 0x1, 0, 0xa, 0, 0, 0, 0x49, 
	0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x44, 0x61, 0x74, 0x61, 0xf, 
	0, 0xb, 0, 0x1f, 0, 0x1, 0, 0x4, 0, 0, 
	0, 0x47, 0x75, 0x69, 0x64, 0xa, 0, 0x5, 0, 0xe0, 
	0x90, 0x27, 0xa4, 0x10, 0x78, 0xcf, 0x11, 0x8f, 0x52, 0, 
	0x40, 0x33, 0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0x5, 
	0, 0, 0, 0x64, 0x61, 0x74, 0x61, 0x31, 0x14, 0, 
	0x28, 0, 0x1, 0, 0x5, 0, 0, 0, 0x64, 0x61, 
	0x74, 0x61, 0x32, 0x14, 0, 0x28, 0, 0x1, 0, 0x5, 
	0, 0, 0, 0x64, 0x61, 0x74, 0x61, 0x33, 0x14, 0, 
	0x34, 0, 0x2d, 0, 0x1, 0, 0x5, 0, 0, 0, 
	0x64, 0x61, 0x74, 0x61, 0x34, 0xe, 0, 0x3, 0, 0x8, 
	0, 0, 0, 0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 
	0, 0x1, 0, 0xe, 0, 0, 0, 0x53, 0x74, 0x72, 
	0x69, 0x6e, 0x67, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 
	0x79, 0xa, 0, 0x5, 0, 0xe0, 0x21, 0xf, 0x7f, 0xe1, 
	0xbf, 0xd1, 0x11, 0x82, 0xc0, 0, 0xa0, 0xc9, 0x69, 0x72, 
	0x71, 0x31, 0, 0x1, 0, 0x3, 0, 0, 0, 0x6b, 
	0x65, 0x79, 0x14, 0, 0x31, 0, 0x1, 0, 0x5, 0, 
	0, 0, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x14, 0, 0xb, 
	0, 0x1f, 0, 0x1, 0, 0xb, 0, 0, 0, 0x50, 
	0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0x42, 0x61, 0x67, 
	0xa, 0, 0x5, 0, 0xe1, 0x21, 0xf, 0x7f, 0xe1, 0xbf, 
	0xd1, 0x11, 0x82, 0xc0, 0, 0xa0, 0xc9, 0x69, 0x72, 0x71, 
	0xe, 0, 0x1, 0, 0xe, 0, 0, 0, 0x53, 0x74, 
	0x72, 0x69, 0x6e, 0x67, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 
	0x74, 0x79, 0xf, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
	0xe, 0, 0, 0, 0x45, 0x78, 0x74, 0x65, 0x72, 0x6e, 
	0x61, 0x6c, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0xa, 0, 
	0x5, 0, 0xa0, 0x6a, 0x11, 0x98, 0xba, 0xbd, 0xd1, 0x11, 
	0x82, 0xc0, 0, 0xa0, 0xc9, 0x69, 0x72, 0x71, 0x1, 0, 
	0x4, 0, 0, 0, 0x47, 0x75, 0x69, 0x64, 0x1, 0, 
	0x12, 0, 0, 0, 0x67, 0x75, 0x69, 0x64, 0x45, 0x78, 
	0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x56, 0x69, 0x73, 0x75, 
	0x61, 0x6c, 0x14, 0, 0xe, 0, 0x12, 0, 0x12, 0, 
	0x12, 0, 0xf, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
	0xb, 0, 0, 0, 0x52, 0x69, 0x67, 0x68, 0x74, 0x48, 
	0x61, 0x6e, 0x64, 0x65, 0x64, 0xa, 0, 0x5, 0, 0xa0, 
	0x5e, 0x5d, 0x7f, 0x3a, 0xd5, 0xd1, 0x11, 0x82, 0xc0, 0, 
	0xa0, 0xc9, 0x69, 0x72, 0x71, 0x29, 0, 0x1, 0, 0xc, 
	0, 0, 0, 0x62, 0x52, 0x69, 0x67, 0x68, 0x74, 0x48, 
	0x61, 0x6e, 0x64, 0x65, 0x64, 0x14, 0, 0xb, 0
};

#define D3DRM_XTEMPLATE_BYTES 3278

#endif /* _RMXFTMPL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\rmxfguid.h ===
/***************************************************************************
 *
 *  Copyright (C) 1998-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       rmxfguid.h
 *
 *  Content:    Defines GUIDs of D3DRM's templates.
 *
 ***************************************************************************/

#ifndef __RMXFGUID_H_
#define __RMXFGUID_H_

/* {2B957100-9E9A-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMInfo,
0x2b957100, 0x9e9a, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB44-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMMesh,
0x3d82ab44, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB5E-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMVector,
0x3d82ab5e, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB5F-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMMeshFace,
0x3d82ab5f, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB4D-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMMaterial,
0x3d82ab4d, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {35FF44E1-6C7C-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialArray,
0x35ff44e1, 0x6c7c, 0x11cf, 0x8F, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {3D82AB46-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMFrame,
0x3d82ab46, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {F6F23F41-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMFrameTransformMatrix,
0xf6f23f41, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F6F23F42-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMeshMaterialList,
0xf6f23f42, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F6F23F40-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMeshTextureCoords,
0xf6f23f40, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F6F23F43-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMeshNormals,
0xf6f23f43, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F6F23F44-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMCoords2d,
0xf6f23f44, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F6F23F45-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMatrix4x4,
0xf6f23f45, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {3D82AB4F-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMAnimation,
0x3d82ab4f, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB50-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMAnimationSet,
0x3d82ab50, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {10DD46A8-775B-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMAnimationKey,
0x10dd46a8, 0x775b, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {10DD46A9-775B-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMFloatKeys,
0x10dd46a9, 0x775b, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {01411840-7786-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialAmbientColor,
0x01411840, 0x7786, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {01411841-7786-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialDiffuseColor,
0x01411841, 0x7786, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {01411842-7786-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialSpecularColor,
0x01411842, 0x7786, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {D3E16E80-7835-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialEmissiveColor,
0xd3e16e80, 0x7835, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {01411843-7786-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialPower,
0x01411843, 0x7786, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {35FF44E0-6C7C-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMColorRGBA,
0x35ff44e0, 0x6c7c, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {D3E16E81-7835-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMColorRGB,
0xd3e16e81, 0x7835, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {A42790E0-7810-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMGuid,
0xa42790e0, 0x7810, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {A42790E1-7810-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMTextureFilename,
0xa42790e1, 0x7810, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {A42790E2-7810-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMTextureReference,
0xa42790e2, 0x7810, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {1630B820-7842-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMIndexedColor,
0x1630b820, 0x7842, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {1630B821-7842-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMeshVertexColors,
0x1630b821, 0x7842, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {4885AE60-78E8-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialWrap,
0x4885ae60, 0x78e8, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {537DA6A0-CA37-11d0-941C-0080C80CFA7B} */
DEFINE_GUID(TID_D3DRMBoolean,
0x537da6a0, 0xca37, 0x11d0, 0x94, 0x1c, 0x0, 0x80, 0xc8, 0xc, 0xfa, 0x7b);

/* {ED1EC5C0-C0A8-11d0-941C-0080C80CFA7B} */
DEFINE_GUID(TID_D3DRMMeshFaceWraps,
0xed1ec5c0, 0xc0a8, 0x11d0, 0x94, 0x1c, 0x0, 0x80, 0xc8, 0xc, 0xfa, 0x7b);

/* {4885AE63-78E8-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMBoolean2d,
0x4885ae63, 0x78e8, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F406B180-7B3B-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMTimedFloatKeys,
0xf406b180, 0x7b3b, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {E2BF56C0-840F-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMAnimationOptions,
0xe2bf56c0, 0x840f, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {E2BF56C1-840F-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMFramePosition,
0xe2bf56c1, 0x840f, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {E2BF56C2-840F-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMFrameVelocity,
0xe2bf56c2, 0x840f, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {E2BF56C3-840F-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMFrameRotation,
0xe2bf56c3, 0x840f, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {3D82AB4A-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMLight,
0x3d82ab4a, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB51-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMCamera,
0x3d82ab51, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {E5745280-B24F-11cf-9DD5-00AA00A71A2F} */
DEFINE_GUID(TID_D3DRMAppData,
0xe5745280, 0xb24f, 0x11cf, 0x9d, 0xd5, 0x0, 0xaa, 0x0, 0xa7, 0x1a, 0x2f);

/* {AED22740-B31F-11cf-9DD5-00AA00A71A2F} */
DEFINE_GUID(TID_D3DRMLightUmbra,
0xaed22740, 0xb31f, 0x11cf, 0x9d, 0xd5, 0x0, 0xaa, 0x0, 0xa7, 0x1a, 0x2f);

/* {AED22742-B31F-11cf-9DD5-00AA00A71A2F} */
DEFINE_GUID(TID_D3DRMLightRange,
0xaed22742, 0xb31f, 0x11cf, 0x9d, 0xd5, 0x0, 0xaa, 0x0, 0xa7, 0x1a, 0x2f);

/* {AED22741-B31F-11cf-9DD5-00AA00A71A2F} */
DEFINE_GUID(TID_D3DRMLightPenumbra,
0xaed22741, 0xb31f, 0x11cf, 0x9d, 0xd5, 0x0, 0xaa, 0x0, 0xa7, 0x1a, 0x2f);

/* {A8A98BA0-C5E5-11cf-B941-0080C80CFA7B} */
DEFINE_GUID(TID_D3DRMLightAttenuation,
0xa8a98ba0, 0xc5e5, 0x11cf, 0xb9, 0x41, 0x0, 0x80, 0xc8, 0xc, 0xfa, 0x7b);

/* {3A23EEA0-94B1-11d0-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMInlineData,
0x3a23eea0, 0x94b1, 0x11d0, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3A23EEA1-94B1-11d0-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMUrl,
0x3a23eea1, 0x94b1, 0x11d0, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {8A63C360-997D-11d0-941C-0080C80CFA7B} */
DEFINE_GUID(TID_D3DRMProgressiveMesh,
0x8A63C360, 0x997D, 0x11d0, 0x94, 0x1C, 0x0, 0x80, 0xC8, 0x0C, 0xFA, 0x7B);

/* {98116AA0-BDBA-11d1-82C0-00A0C9697271} */
DEFINE_GUID(TID_D3DRMExternalVisual,
0x98116AA0, 0xBDBA, 0x11d1, 0x82, 0xC0, 0x00, 0xA0, 0xC9, 0x69, 0x72, 0x71);

/* {7F0F21E0-BFE1-11d1-82C0-00A0C9697271} */
DEFINE_GUID(TID_D3DRMStringProperty, 
0x7f0f21e0, 0xbfe1, 0x11d1, 0x82, 0xc0, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x71);

/* {7F0F21E1-BFE1-11d1-82C0-00A0C9697271} */
DEFINE_GUID(TID_D3DRMPropertyBag, 
0x7f0f21e1, 0xbfe1, 0x11d1, 0x82, 0xc0, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x71);

// {7F5D5EA0-D53A-11d1-82C0-00A0C9697271}
DEFINE_GUID(TID_D3DRMRightHanded, 
0x7f5d5ea0, 0xd53a, 0x11d1, 0x82, 0xc0, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x71);

#endif /* __RMXFGUID_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\rnderr.h ===
/*

    Copyright (c) Microsoft Corporation. All rights reserved.

    Module Name:
        rnderr.h

*/

#ifndef __RND_ERROR_CODES__
#define __RND_ERROR_CODES__

#include <blberr.h>


// rendezvous component error codes

// First four bits - SEVERITY(11), CUSTOMER FLAG(1), RESERVED(0)
#define RND_INVALID_TIME                  0xe0000200
#define RND_NULL_SERVER_NAME              0xe0000201
#define RND_ALREADY_CONNECTED             0xe0000202
#define RND_NOT_CONNECTED                 0xe0000203

#endif // __RND_ERROR_CODES__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\rowpos.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu May 22 17:20:43 1997
 */
/* Compiler settings for msdadc.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __rowpos_h__
#define __rowpos_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IRowPosition_FWD_DEFINED__
#define __IRowPosition_FWD_DEFINED__
typedef interface IRowPosition IRowPosition;
#endif 	/* __IRowPosition_FWD_DEFINED__ */


#ifndef __IRowPositionChange_FWD_DEFINED__
#define __IRowPositionChange_FWD_DEFINED__
typedef interface IRowPositionChange IRowPositionChange;
#endif 	/* __IRowPositionChange_FWD_DEFINED__ */


#ifndef __RowPosition_FWD_DEFINED__
#define __RowPosition_FWD_DEFINED__

#ifdef __cplusplus
typedef class RowPosition RowPosition;
#else
typedef struct RowPosition RowPosition;
#endif /* __cplusplus */

#endif 	/* __RowPosition_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __IRowPosition_INTERFACE_DEFINED__
#define __IRowPosition_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowPosition
 * at Thu May 22 17:20:43 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 


typedef DWORD DBPOSITIONFLAGS;


enum DBPOSITIONFLAGSENUM
    {	DBPOSITION_OK	= 0,
	DBPOSITION_NOROW	= DBPOSITION_OK + 1,
	DBPOSITION_BOF	= DBPOSITION_NOROW + 1,
	DBPOSITION_EOF	= DBPOSITION_BOF + 1
    };

EXTERN_C const IID IID_IRowPosition;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a94-2a1c-11ce-ade5-00aa0044773d")
    IRowPosition : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ClearRowPosition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRowPosition( 
            /* [out] */ HCHAPTER __RPC_FAR *phChapter,
            /* [out] */ HROW __RPC_FAR *phRow,
            /* [out] */ DBPOSITIONFLAGS __RPC_FAR *pdwPositionFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRowset( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPUNKNOWN __RPC_FAR *ppRowset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IUnknown __RPC_FAR *pRowset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRowPosition( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ HROW hRow,
            /* [in] */ DBPOSITIONFLAGS dwPositionFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowPositionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRowPosition __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRowPosition __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRowPosition __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearRowPosition )( 
            IRowPosition __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRowPosition )( 
            IRowPosition __RPC_FAR * This,
            /* [out] */ HCHAPTER __RPC_FAR *phChapter,
            /* [out] */ HROW __RPC_FAR *phRow,
            /* [out] */ DBPOSITIONFLAGS __RPC_FAR *pdwPositionFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRowset )( 
            IRowPosition __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPUNKNOWN __RPC_FAR *ppRowset);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IRowPosition __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pRowset);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRowPosition )( 
            IRowPosition __RPC_FAR * This,
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ HROW hRow,
            /* [in] */ DBPOSITIONFLAGS dwPositionFlags);
        
        END_INTERFACE
    } IRowPositionVtbl;

    interface IRowPosition
    {
        CONST_VTBL struct IRowPositionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowPosition_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowPosition_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowPosition_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowPosition_ClearRowPosition(This)	\
    (This)->lpVtbl -> ClearRowPosition(This)

#define IRowPosition_GetRowPosition(This,phChapter,phRow,pdwPositionFlags)	\
    (This)->lpVtbl -> GetRowPosition(This,phChapter,phRow,pdwPositionFlags)

#define IRowPosition_GetRowset(This,riid,ppRowset)	\
    (This)->lpVtbl -> GetRowset(This,riid,ppRowset)

#define IRowPosition_Initialize(This,pRowset)	\
    (This)->lpVtbl -> Initialize(This,pRowset)

#define IRowPosition_SetRowPosition(This,hChapter,hRow,dwPositionFlags)	\
    (This)->lpVtbl -> SetRowPosition(This,hChapter,hRow,dwPositionFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowPosition_ClearRowPosition_Proxy( 
    IRowPosition __RPC_FAR * This);


void __RPC_STUB IRowPosition_ClearRowPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowPosition_GetRowPosition_Proxy( 
    IRowPosition __RPC_FAR * This,
    /* [out] */ HCHAPTER __RPC_FAR *phChapter,
    /* [out] */ HROW __RPC_FAR *phRow,
    /* [out] */ DBPOSITIONFLAGS __RPC_FAR *pdwPositionFlags);


void __RPC_STUB IRowPosition_GetRowPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowPosition_GetRowset_Proxy( 
    IRowPosition __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ LPUNKNOWN __RPC_FAR *ppRowset);


void __RPC_STUB IRowPosition_GetRowset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowPosition_Initialize_Proxy( 
    IRowPosition __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pRowset);


void __RPC_STUB IRowPosition_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowPosition_SetRowPosition_Proxy( 
    IRowPosition __RPC_FAR * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ HROW hRow,
    /* [in] */ DBPOSITIONFLAGS dwPositionFlags);


void __RPC_STUB IRowPosition_SetRowPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowPosition_INTERFACE_DEFINED__ */


#ifndef __IRowPositionChange_INTERFACE_DEFINED__
#define __IRowPositionChange_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowPositionChange
 * at Thu May 22 17:20:43 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



enum DBREASONPOSITIONENUM
    {	DBREASON_ROWPOSITION_CHANGED	= DBREASON_ROWSET_CHANGED + 1,
	DBREASON_ROWPOSITION_CHAPTERCHANGED	= DBREASON_ROWPOSITION_CHANGED + 1,
	DBREASON_ROWPOSITION_CLEARED	= DBREASON_ROWPOSITION_CHAPTERCHANGED + 1
    };

EXTERN_C const IID IID_IRowPositionChange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0997a571-126e-11d0-9f8a-00a0c9a0631e")
    IRowPositionChange : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnRowPositionChange( 
            /* [in] */ DBREASON eReason,
            /* [in] */ DBEVENTPHASE ePhase,
            /* [in] */ BOOL fCantDeny) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowPositionChangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRowPositionChange __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRowPositionChange __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRowPositionChange __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnRowPositionChange )( 
            IRowPositionChange __RPC_FAR * This,
            /* [in] */ DBREASON eReason,
            /* [in] */ DBEVENTPHASE ePhase,
            /* [in] */ BOOL fCantDeny);
        
        END_INTERFACE
    } IRowPositionChangeVtbl;

    interface IRowPositionChange
    {
        CONST_VTBL struct IRowPositionChangeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowPositionChange_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowPositionChange_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowPositionChange_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowPositionChange_OnRowPositionChange(This,eReason,ePhase,fCantDeny)	\
    (This)->lpVtbl -> OnRowPositionChange(This,eReason,ePhase,fCantDeny)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowPositionChange_OnRowPositionChange_Proxy( 
    IRowPositionChange __RPC_FAR * This,
    /* [in] */ DBREASON eReason,
    /* [in] */ DBEVENTPHASE ePhase,
    /* [in] */ BOOL fCantDeny);


void __RPC_STUB IRowPositionChange_OnRowPositionChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowPositionChange_INTERFACE_DEFINED__ */



#ifndef __MSDAUTILLib_LIBRARY_DEFINED__
#define __MSDAUTILLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: MSDAUTILLib
 * at Thu May 22 17:20:43 1997
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_RowPosition;

class DECLSPEC_UUID("2048EEE6-7FA2-11D0-9E6A-00A0C9138C29")
RowPosition;

DEFINE_GUID(CLSID_RowPosition, 0x2048eee6, 0x7fa2, 0x11d0, 0x9e, 0x6a, 0x0, 0xa0, 0xc9, 0x13, 0x8c, 0x29);
DEFINE_GUID(IID_IRowPosition,  0x0c733a94, 0x2a1c, 0x11ce, 0xad, 0xe5, 0x0, 0xaa, 0x0, 0x44, 0x77, 0x3d);
DEFINE_GUID(IID_IRowPositionChange,  0x0997a571, 0x126e, 0x11d0, 0x9f, 0x8a, 0x0, 0xa0, 0xc9, 0xa0, 0x63, 0x1e);


#endif
#endif /* __MSDAUTILLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\rpc.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpc.h

Abstract:

    Master include file for RPC applications.

--*/

#if !defined( RPC_NO_WINDOWS_H ) && !defined( MAC ) && !defined( _MAC )
#include <windows.h>
#endif // RPC_NO_WINDOWS_H

#ifndef __RPC_H__
#define __RPC_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------------------------
// platform specific defines
//-------------------------------------------------------------

//-------------------  MAC ---------------------------
#if defined( MAC ) || defined( _MAC )

#define __RPC_MAC__
// Set the packing level for RPC structures.

#include <pshpack2.h>

//-------------------  WIN32 ---------------------------
#else // win32 platforms

#include <basetsd.h>

#if defined(_M_IA64) || defined(_M_AMD64)
#define __RPC_WIN64__
#else
#define __RPC_WIN32__
#endif

#endif

#if defined(__RPC_WIN64__)
#include <pshpack8.h>
#endif

#ifndef __MIDL_USER_DEFINED
#define midl_user_allocate MIDL_user_allocate
#define midl_user_free     MIDL_user_free
#define __MIDL_USER_DEFINED
#endif

typedef void * I_RPC_HANDLE;
typedef long RPC_STATUS;

#if defined(__RPC_WIN32__) || defined(__RPC_WIN64__)
#define RPC_UNICODE_SUPPORTED
#endif

#if !defined(_M_AMD64) && !defined(__RPC_MAC__) && ( (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED) )
#	define __RPC_API  __stdcall
#	define __RPC_USER __stdcall
#	define __RPC_STUB __stdcall
#	define  RPC_ENTRY __stdcall
#else // Not Win32/Win64
#	define __RPC_API
#	define __RPC_USER
#	define __RPC_STUB
#	define RPC_ENTRY
#endif

#define __RPC_FAR

// Some RPC platforms don't define DECLSPEC_IMPORT
#if !defined(DECLSPEC_IMPORT)
#if (defined(_M_MRX000) || defined(_M_IX86) || defined(_M_IA64) || defined(_M_AMD64)) && !defined(MIDL_PASS)
#define DECLSPEC_IMPORT __declspec(dllimport)
#else
#define DECLSPEC_IMPORT
#endif
#endif

#if !defined(_RPCRT4_)
#define RPCRTAPI DECLSPEC_IMPORT
#else
#define RPCRTAPI
#endif

#if !defined(_RPCNS4_)
#define RPCNSAPI DECLSPEC_IMPORT
#else
#define RPCNSAPI
#endif

#ifdef __RPC_MAC__

#include <setjmp.h>

#define RPCXCWORD (sizeof(jmp_buf)/sizeof(int))

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning( disable: 4005 )
#include <rpcdce.h>
#include <rpcnsi.h>
#include <rpcerr.h>
#include <rpcmac.h>
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default :  4005 )
#endif

typedef void  (RPC_ENTRY *MACYIELDCALLBACK)(/*OSErr*/ short *) ;
RPC_STATUS RPC_ENTRY
RpcMacSetYieldInfo(
	MACYIELDCALLBACK pfnCallback) ;

#if !defined(UNALIGNED)
#define UNALIGNED
#endif

#include <poppack.h>

#else // __RPC_MAC__

#include <rpcdce.h>
#include <rpcnsi.h>
#include <rpcnterr.h>
#include <excpt.h>
#include <winerror.h>

#define RpcTryExcept \
    __try \
        {

// trystmts

#define RpcExcept(expr) \
        } \
    __except (expr) \
        {

// exceptstmts

#define RpcEndExcept \
        }

#define RpcTryFinally \
    __try \
        {

// trystmts

#define RpcFinally \
        } \
    __finally \
        {

// finallystmts

#define RpcEndFinally \
        }

#define RpcExceptionCode() GetExceptionCode()
#define RpcAbnormalTermination() AbnormalTermination()

#endif // __RPC_MAC__

// Definitions which depend on windows.h
#if !defined( RPC_NO_WINDOWS_H ) && !defined(__RPC_MAC__)

#include <rpcasync.h>

#endif // RPC_NO_WINDOWS_H

#if defined(__RPC_WIN64__)
#include <poppack.h>
#endif

#ifdef __cplusplus
}
#endif

#endif // __RPC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\rpcdce.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpcdce.h

Abstract:

    This module contains the DCE RPC runtime APIs.

--*/

#ifndef __RPCDCE_H__
#define __RPCDCE_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#ifndef DECLSPEC_NORETURN
#if (_MSC_VER >= 1200) && !defined(MIDL_PASS)
#define DECLSPEC_NORETURN   __declspec(noreturn)
#else
#define DECLSPEC_NORETURN
#endif
#endif

/*typedef char small;*/
/*typedef unsigned char byte;*/
/*typedef unsigned char boolean;*/

typedef I_RPC_HANDLE RPC_BINDING_HANDLE;
typedef RPC_BINDING_HANDLE handle_t;
#define rpc_binding_handle_t RPC_BINDING_HANDLE

#ifndef GUID_DEFINED
#include <guiddef.h>
#endif /* GUID_DEFINED */

#ifndef UUID_DEFINED
#define UUID_DEFINED
typedef GUID UUID;
#ifndef uuid_t
#define uuid_t UUID
#endif
#endif

typedef struct _RPC_BINDING_VECTOR
{
    unsigned long Count;
    RPC_BINDING_HANDLE BindingH[1];
} RPC_BINDING_VECTOR;
#ifndef rpc_binding_vector_t
#define rpc_binding_vector_t RPC_BINDING_VECTOR
#endif

typedef struct _UUID_VECTOR
{
  unsigned long Count;
  UUID *Uuid[1];
} UUID_VECTOR;
#ifndef uuid_vector_t
#define uuid_vector_t UUID_VECTOR
#endif

typedef void __RPC_FAR * RPC_IF_HANDLE;

#ifndef IFID_DEFINED
#define IFID_DEFINED
typedef struct _RPC_IF_ID
{
    UUID Uuid;
    unsigned short VersMajor;
    unsigned short VersMinor;
} RPC_IF_ID;
#endif

#define RPC_C_BINDING_INFINITE_TIMEOUT 10
#define RPC_C_BINDING_MIN_TIMEOUT 0
#define RPC_C_BINDING_DEFAULT_TIMEOUT 5
#define RPC_C_BINDING_MAX_TIMEOUT 9

#define RPC_C_CANCEL_INFINITE_TIMEOUT -1

#define RPC_C_LISTEN_MAX_CALLS_DEFAULT 1234
#define RPC_C_PROTSEQ_MAX_REQS_DEFAULT 10

// RPC_POLICY EndpointFlags.
#define RPC_C_BIND_TO_ALL_NICS          1
#define RPC_C_USE_INTERNET_PORT         0x1
#define RPC_C_USE_INTRANET_PORT         0x2
#define RPC_C_DONT_FAIL                          0x4

// RPC_POLICY EndpointFlags specific to the Falcon/RPC transport:
#define RPC_C_MQ_TEMPORARY                  0x0000
#define RPC_C_MQ_PERMANENT                  0x0001
#define RPC_C_MQ_CLEAR_ON_OPEN              0x0002
#define RPC_C_MQ_USE_EXISTING_SECURITY      0x0004
#define RPC_C_MQ_AUTHN_LEVEL_NONE           0x0000
#define RPC_C_MQ_AUTHN_LEVEL_PKT_INTEGRITY  0x0008
#define RPC_C_MQ_AUTHN_LEVEL_PKT_PRIVACY    0x0010

// Client: RpcBindingSetOption() values for the Falcon/RPC transport:
#define RPC_C_OPT_MQ_DELIVERY            1
#define RPC_C_OPT_MQ_PRIORITY            2
#define RPC_C_OPT_MQ_JOURNAL             3
#define RPC_C_OPT_MQ_ACKNOWLEDGE         4
#define RPC_C_OPT_MQ_AUTHN_SERVICE       5
#define RPC_C_OPT_MQ_AUTHN_LEVEL         6
#define RPC_C_OPT_MQ_TIME_TO_REACH_QUEUE 7
#define RPC_C_OPT_MQ_TIME_TO_BE_RECEIVED 8
#define RPC_C_OPT_BINDING_NONCAUSAL      9
#define RPC_C_OPT_SECURITY_CALLBACK      10
#define RPC_C_OPT_UNIQUE_BINDING         11
#define RPC_C_OPT_CALL_TIMEOUT           12
#define RPC_C_OPT_DONT_LINGER            13
#define RPC_C_OPT_MAX_OPTIONS            14

#define RPC_C_MQ_EXPRESS                0  // Client: RPC_C_MQ_DELIVERY.
#define RPC_C_MQ_RECOVERABLE            1

#define RPC_C_MQ_JOURNAL_NONE           0  // Client: RPC_C_MQ_JOURNAL.
#define RPC_C_MQ_JOURNAL_DEADLETTER     1
#define RPC_C_MQ_JOURNAL_ALWAYS         2

// flags for RpcServerInqAuthClientEx
//
#define RPC_C_FULL_CERT_CHAIN 0x0001



#ifdef RPC_UNICODE_SUPPORTED
typedef struct _RPC_PROTSEQ_VECTORA
{
    unsigned int Count;
    unsigned char __RPC_FAR * Protseq[1];
} RPC_PROTSEQ_VECTORA;

typedef struct _RPC_PROTSEQ_VECTORW
{
    unsigned int Count;
    unsigned short __RPC_FAR * Protseq[1];
} RPC_PROTSEQ_VECTORW;

#ifdef UNICODE
#define RPC_PROTSEQ_VECTOR RPC_PROTSEQ_VECTORW
#else /* UNICODE */
#define RPC_PROTSEQ_VECTOR RPC_PROTSEQ_VECTORA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

typedef struct _RPC_PROTSEQ_VECTOR
{
    unsigned int Count;
    unsigned char __RPC_FAR * Protseq[1];
} RPC_PROTSEQ_VECTOR;

#endif /* RPC_UNICODE_SUPPORTED */
typedef struct _RPC_POLICY {
    unsigned int Length ;
    unsigned long EndpointFlags ;
    unsigned long NICFlags ;
    } RPC_POLICY,  __RPC_FAR *PRPC_POLICY ;

typedef void __RPC_USER
RPC_OBJECT_INQ_FN (
    IN UUID __RPC_FAR * ObjectUuid,
    OUT UUID __RPC_FAR * TypeUuid,
    OUT RPC_STATUS __RPC_FAR * Status
    );

typedef RPC_STATUS RPC_ENTRY
RPC_IF_CALLBACK_FN (
    IN RPC_IF_HANDLE  InterfaceUuid,
    IN void *Context
    ) ;

typedef void RPC_ENTRY
RPC_SECURITY_CALLBACK_FN (
    IN void *Context
    ) ;

#define RPC_MGR_EPV void

typedef struct
{
    unsigned int Count;
    unsigned long Stats[1];
} RPC_STATS_VECTOR;

#define RPC_C_STATS_CALLS_IN 0
#define RPC_C_STATS_CALLS_OUT 1
#define RPC_C_STATS_PKTS_IN 2
#define RPC_C_STATS_PKTS_OUT 3

typedef struct
{
  unsigned long Count;
  RPC_IF_ID __RPC_FAR * IfId[1];
} RPC_IF_ID_VECTOR;

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingCopy (
    IN RPC_BINDING_HANDLE SourceBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * DestinationBinding
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingFree (
    IN OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetOption( IN RPC_BINDING_HANDLE hBinding,
                     IN unsigned long      option,
                     IN ULONG_PTR          optionValue );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqOption( IN  RPC_BINDING_HANDLE hBinding,
                     IN  unsigned long      option,
                     OUT ULONG_PTR         *pOptionValue );

/* client */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingFromStringBindingA (
    IN unsigned char __RPC_FAR * StringBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingFromStringBindingW (
    IN unsigned short __RPC_FAR * StringBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

#ifdef UNICODE
#define RpcBindingFromStringBinding RpcBindingFromStringBindingW
#else /* UNICODE */
#define RpcBindingFromStringBinding RpcBindingFromStringBindingA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingFromStringBinding (
    IN unsigned char __RPC_FAR * StringBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSsGetContextBinding (
    IN void *ContextHandle,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqObject (
    IN RPC_BINDING_HANDLE Binding,
    OUT UUID __RPC_FAR * ObjectUuid
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingReset (
    IN RPC_BINDING_HANDLE Binding
    );

/* RpcBindingServerFromClient : UNSUPPORTED */
/* RpcBindingSetAuthInfo */

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetObject (
    IN RPC_BINDING_HANDLE Binding,
    IN UUID __RPC_FAR * ObjectUuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqDefaultProtectLevel(
    IN  unsigned long AuthnSvc,
    OUT unsigned long __RPC_FAR *AuthnLevel
    );

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingToStringBindingA (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringBinding
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingToStringBindingW (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short __RPC_FAR * __RPC_FAR * StringBinding
    );

#ifdef UNICODE
#define RpcBindingToStringBinding RpcBindingToStringBindingW
#else /* UNICODE */
#define RpcBindingToStringBinding RpcBindingToStringBindingA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingToStringBinding (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringBinding
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingVectorFree (
    IN OUT RPC_BINDING_VECTOR __RPC_FAR * __RPC_FAR * BindingVector
    );

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingComposeA (
    IN unsigned char __RPC_FAR * ObjUuid OPTIONAL,
    IN unsigned char __RPC_FAR * Protseq OPTIONAL,
    IN unsigned char __RPC_FAR * NetworkAddr OPTIONAL,
    IN unsigned char __RPC_FAR * Endpoint OPTIONAL,
    IN unsigned char __RPC_FAR * Options OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringBinding OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingComposeW (
    IN unsigned short __RPC_FAR * ObjUuid OPTIONAL,
    IN unsigned short __RPC_FAR * Protseq OPTIONAL,
    IN unsigned short __RPC_FAR * NetworkAddr OPTIONAL,
    IN unsigned short __RPC_FAR * Endpoint OPTIONAL,
    IN unsigned short __RPC_FAR * Options OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * StringBinding OPTIONAL
    );

#ifdef UNICODE
#define RpcStringBindingCompose RpcStringBindingComposeW
#else /* UNICODE */
#define RpcStringBindingCompose RpcStringBindingComposeA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingCompose (
    IN unsigned char __RPC_FAR * ObjUuid OPTIONAL,
    IN unsigned char __RPC_FAR * Protseq OPTIONAL,
    IN unsigned char __RPC_FAR * NetworkAddr OPTIONAL,
    IN unsigned char __RPC_FAR * Endpoint OPTIONAL,
    IN unsigned char __RPC_FAR * Options OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringBinding OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingParseA (
    IN unsigned char __RPC_FAR * StringBinding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ObjUuid OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Protseq OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * NetworkAddr OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Endpoint OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * NetworkOptions OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingParseW (
    IN unsigned short __RPC_FAR * StringBinding,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ObjUuid OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * Protseq OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * NetworkAddr OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * Endpoint OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * NetworkOptions OPTIONAL
    );

#ifdef UNICODE
#define RpcStringBindingParse RpcStringBindingParseW
#else /* UNICODE */
#define RpcStringBindingParse RpcStringBindingParseA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingParse (
    IN unsigned char __RPC_FAR * StringBinding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ObjUuid OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Protseq OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * NetworkAddr OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Endpoint OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * NetworkOptions OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringFreeA (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR * String
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringFreeW (
    IN OUT unsigned short __RPC_FAR * __RPC_FAR * String
    );

#ifdef UNICODE
#define RpcStringFree RpcStringFreeW
#else /* UNICODE */
#define RpcStringFree RpcStringFreeA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringFree (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR * String
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcIfInqId (
    IN RPC_IF_HANDLE RpcIfHandle,
    OUT RPC_IF_ID __RPC_FAR * RpcIfId
    );

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkIsProtseqValidA (
    IN unsigned char __RPC_FAR * Protseq
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkIsProtseqValidW (
    IN unsigned short __RPC_FAR * Protseq
    );

#ifdef UNICODE
#define RpcNetworkIsProtseqValid RpcNetworkIsProtseqValidW
#else /* UNICODE */
#define RpcNetworkIsProtseqValid RpcNetworkIsProtseqValidA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkIsProtseqValid (
    IN unsigned char __RPC_FAR * Protseq
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqComTimeout (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned int __RPC_FAR * Timeout
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtSetComTimeout (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned int Timeout
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtSetCancelTimeout(
    long Timeout
    );


/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkInqProtseqsA (
    OUT RPC_PROTSEQ_VECTORA __RPC_FAR * __RPC_FAR * ProtseqVector
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkInqProtseqsW (
    OUT RPC_PROTSEQ_VECTORW __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#ifdef UNICODE
#define RpcNetworkInqProtseqs RpcNetworkInqProtseqsW
#else /* UNICODE */
#define RpcNetworkInqProtseqs RpcNetworkInqProtseqsA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkInqProtseqs (
    OUT RPC_PROTSEQ_VECTOR __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcObjectInqType (
    IN UUID __RPC_FAR * ObjUuid,
    OUT UUID __RPC_FAR * TypeUuid OPTIONAL
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcObjectSetInqFn (
    IN RPC_OBJECT_INQ_FN __RPC_FAR * InquiryFn
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcObjectSetType (
    IN UUID __RPC_FAR * ObjUuid,
    IN UUID __RPC_FAR * TypeUuid OPTIONAL
    );

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcProtseqVectorFreeA (
    IN OUT RPC_PROTSEQ_VECTORA __RPC_FAR * __RPC_FAR * ProtseqVector
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcProtseqVectorFreeW (
    IN OUT RPC_PROTSEQ_VECTORW __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#ifdef UNICODE
#define RpcProtseqVectorFree RpcProtseqVectorFreeW
#else /* UNICODE */
#define RpcProtseqVectorFree RpcProtseqVectorFreeA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcProtseqVectorFree (
    IN OUT RPC_PROTSEQ_VECTOR __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqBindings (
    OUT RPC_BINDING_VECTOR __RPC_FAR * __RPC_FAR * BindingVector
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqIf (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID __RPC_FAR * MgrTypeUuid, OPTIONAL
    OUT RPC_MGR_EPV __RPC_FAR * __RPC_FAR * MgrEpv
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerListen (
    IN unsigned int MinimumCallThreads,
    IN unsigned int MaxCalls,
    IN unsigned int DontWait
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterIf (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID __RPC_FAR * MgrTypeUuid OPTIONAL,
    IN RPC_MGR_EPV __RPC_FAR * MgrEpv OPTIONAL
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterIfEx (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID __RPC_FAR * MgrTypeUuid,
    IN RPC_MGR_EPV __RPC_FAR * MgrEpv,
    IN unsigned int Flags,
    IN unsigned int MaxCalls,
    IN RPC_IF_CALLBACK_FN __RPC_FAR *IfCallback
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterIf2 (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID * MgrTypeUuid,
    IN RPC_MGR_EPV * MgrEpv,
    IN unsigned int Flags,
    IN unsigned int MaxCalls,
    IN unsigned int MaxRpcSize,
    IN RPC_IF_CALLBACK_FN *IfCallbackFn
    );


/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUnregisterIf (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID __RPC_FAR * MgrTypeUuid, OPTIONAL
    IN unsigned int WaitForCallsToComplete
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUnregisterIfEx (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID __RPC_FAR * MgrTypeUuid, OPTIONAL
    IN int RundownContextHandles
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseAllProtseqs (
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseAllProtseqsEx (
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseAllProtseqsIf (
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseAllProtseqsIfEx (
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );


/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqA (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqExA (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqW (
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqExW (
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

#ifdef UNICODE
#define RpcServerUseProtseq RpcServerUseProtseqW
#define RpcServerUseProtseqEx RpcServerUseProtseqExW
#else /* UNICODE */
#define RpcServerUseProtseq RpcServerUseProtseqA
#define RpcServerUseProtseqEx RpcServerUseProtseqExA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseq (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEx (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpA (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned char __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpExA (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned char __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpW (
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned short __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpExW (
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned short __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

#ifdef UNICODE
#define RpcServerUseProtseqEp RpcServerUseProtseqEpW
#define RpcServerUseProtseqEpEx RpcServerUseProtseqEpExW
#else /* UNICODE */
#define RpcServerUseProtseqEp RpcServerUseProtseqEpA
#define RpcServerUseProtseqEpEx RpcServerUseProtseqEpExA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEp (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned char __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpEx (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned char __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfA (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfExA (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfW (
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfExW (
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

#ifdef UNICODE
#define RpcServerUseProtseqIf RpcServerUseProtseqIfW
#define RpcServerUseProtseqIfEx RpcServerUseProtseqIfExW
#else /* UNICODE */
#define RpcServerUseProtseqIf RpcServerUseProtseqIfA
#define RpcServerUseProtseqIfEx RpcServerUseProtseqIfExA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIf (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfEx (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

#endif /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
void
RPC_ENTRY
RpcServerYield (
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtStatsVectorFree (
    IN RPC_STATS_VECTOR ** StatsVector
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqStats (
    IN RPC_BINDING_HANDLE Binding,
    OUT RPC_STATS_VECTOR ** Statistics
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtIsServerListening (
    IN RPC_BINDING_HANDLE Binding
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtStopServerListening (
    IN RPC_BINDING_HANDLE Binding
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtWaitServerListen (
    void
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtSetServerStackSize (
    IN unsigned long ThreadStackSize
    );

/* server */
RPCRTAPI
void
RPC_ENTRY
RpcSsDontSerializeContext (
    void
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEnableIdleCleanup (
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqIfIds (
    IN RPC_BINDING_HANDLE Binding,
    OUT RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVector
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcIfIdVectorFree (
    IN OUT RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVector
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqServerPrincNameA (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long AuthnSvc,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqServerPrincNameW (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long AuthnSvc,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName
    );

#ifdef UNICODE
#define RpcMgmtInqServerPrincName RpcMgmtInqServerPrincNameW
#else /* UNICODE */
#define RpcMgmtInqServerPrincName RpcMgmtInqServerPrincNameA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqServerPrincName (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long AuthnSvc,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName
    );

#endif /* RPC_UNICODE_SUPPORTED */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqDefaultPrincNameA (
    IN unsigned long AuthnSvc,
    OUT unsigned char __RPC_FAR * __RPC_FAR * PrincName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqDefaultPrincNameW (
    IN unsigned long AuthnSvc,
    OUT unsigned short __RPC_FAR * __RPC_FAR * PrincName
    );

#ifdef UNICODE
#define RpcServerInqDefaultPrincName RpcServerInqDefaultPrincNameW
#else /* UNICODE */
#define RpcServerInqDefaultPrincName RpcServerInqDefaultPrincNameA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqDefaultPrincName (
    IN unsigned long AuthnSvc,
    OUT unsigned char __RPC_FAR * __RPC_FAR * PrincName
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpResolveBinding (
    IN RPC_BINDING_HANDLE Binding,
    IN RPC_IF_HANDLE IfSpec
    );

/* client */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNsBindingInqEntryNameA (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    OUT unsigned char __RPC_FAR * __RPC_FAR * EntryName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNsBindingInqEntryNameW (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    OUT unsigned short __RPC_FAR * __RPC_FAR * EntryName
    );

#ifdef UNICODE
#define RpcNsBindingInqEntryName RpcNsBindingInqEntryNameW
#else /* UNICODE */
#define RpcNsBindingInqEntryName RpcNsBindingInqEntryNameA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNsBindingInqEntryName (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    OUT unsigned char __RPC_FAR * __RPC_FAR * EntryName
    );

#endif /* RPC_UNICODE_SUPPORTED */

typedef void __RPC_FAR * RPC_AUTH_IDENTITY_HANDLE;
typedef void __RPC_FAR * RPC_AUTHZ_HANDLE;

#define RPC_C_AUTHN_LEVEL_DEFAULT       0
#define RPC_C_AUTHN_LEVEL_NONE          1
#define RPC_C_AUTHN_LEVEL_CONNECT       2
#define RPC_C_AUTHN_LEVEL_CALL          3
#define RPC_C_AUTHN_LEVEL_PKT           4
#define RPC_C_AUTHN_LEVEL_PKT_INTEGRITY 5
#define RPC_C_AUTHN_LEVEL_PKT_PRIVACY   6

#define RPC_C_IMP_LEVEL_DEFAULT      0
#define RPC_C_IMP_LEVEL_ANONYMOUS    1
#define RPC_C_IMP_LEVEL_IDENTIFY     2
#define RPC_C_IMP_LEVEL_IMPERSONATE  3
#define RPC_C_IMP_LEVEL_DELEGATE     4

#define RPC_C_QOS_IDENTITY_STATIC    0
#define RPC_C_QOS_IDENTITY_DYNAMIC   1

#define RPC_C_QOS_CAPABILITIES_DEFAULT                        0x0
#define RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH                    0x1
#define RPC_C_QOS_CAPABILITIES_MAKE_FULLSIC                   0x2
#define RPC_C_QOS_CAPABILITIES_ANY_AUTHORITY                  0x4
#define RPC_C_QOS_CAPABILITIES_IGNORE_DELEGATE_FAILURE        0x8
#define RPC_C_QOS_CAPABILITIES_LOCAL_MA_HINT                 0x10

#define RPC_C_PROTECT_LEVEL_DEFAULT       (RPC_C_AUTHN_LEVEL_DEFAULT)
#define RPC_C_PROTECT_LEVEL_NONE          (RPC_C_AUTHN_LEVEL_NONE)
#define RPC_C_PROTECT_LEVEL_CONNECT       (RPC_C_AUTHN_LEVEL_CONNECT)
#define RPC_C_PROTECT_LEVEL_CALL          (RPC_C_AUTHN_LEVEL_CALL)
#define RPC_C_PROTECT_LEVEL_PKT           (RPC_C_AUTHN_LEVEL_PKT)
#define RPC_C_PROTECT_LEVEL_PKT_INTEGRITY (RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
#define RPC_C_PROTECT_LEVEL_PKT_PRIVACY   (RPC_C_AUTHN_LEVEL_PKT_PRIVACY)

#define RPC_C_AUTHN_NONE          0
#define RPC_C_AUTHN_DCE_PRIVATE   1
#define RPC_C_AUTHN_DCE_PUBLIC    2
#define RPC_C_AUTHN_DEC_PUBLIC    4
#define RPC_C_AUTHN_GSS_NEGOTIATE 9
#define RPC_C_AUTHN_WINNT        10
#define RPC_C_AUTHN_GSS_SCHANNEL 14
#define RPC_C_AUTHN_GSS_KERBEROS 16
#define RPC_C_AUTHN_DPA          17
#define RPC_C_AUTHN_MSN          18
#define RPC_C_AUTHN_DIGEST       21
#define RPC_C_AUTHN_MQ          100
#define RPC_C_AUTHN_DEFAULT     0xFFFFFFFFL

#define RPC_C_NO_CREDENTIALS ((RPC_AUTH_IDENTITY_HANDLE) MAXUINT_PTR)

#define RPC_C_SECURITY_QOS_VERSION  1L
#define RPC_C_SECURITY_QOS_VERSION_1  1L

typedef struct _RPC_SECURITY_QOS {
  unsigned long Version;
  unsigned long Capabilities;
  unsigned long IdentityTracking;
  unsigned long ImpersonationType;
} RPC_SECURITY_QOS, *PRPC_SECURITY_QOS;

#ifndef _AUTH_IDENTITY_DEFINED
#define _AUTH_IDENTITY_DEFINED

#define SEC_WINNT_AUTH_IDENTITY_ANSI    0x1
#define SEC_WINNT_AUTH_IDENTITY_UNICODE 0x2

typedef struct _SEC_WINNT_AUTH_IDENTITY_W {
  unsigned short __RPC_FAR *User;
  unsigned long UserLength;
  unsigned short __RPC_FAR *Domain;
  unsigned long DomainLength;
  unsigned short __RPC_FAR *Password;
  unsigned long PasswordLength;
  unsigned long Flags;
} SEC_WINNT_AUTH_IDENTITY_W, *PSEC_WINNT_AUTH_IDENTITY_W;

typedef struct _SEC_WINNT_AUTH_IDENTITY_A {
  unsigned char __RPC_FAR *User;
  unsigned long UserLength;
  unsigned char __RPC_FAR *Domain;
  unsigned long DomainLength;
  unsigned char __RPC_FAR *Password;
  unsigned long PasswordLength;
  unsigned long Flags;
} SEC_WINNT_AUTH_IDENTITY_A, *PSEC_WINNT_AUTH_IDENTITY_A;

#ifdef UNICODE
#define SEC_WINNT_AUTH_IDENTITY SEC_WINNT_AUTH_IDENTITY_W
#define PSEC_WINNT_AUTH_IDENTITY PSEC_WINNT_AUTH_IDENTITY_W
#define _SEC_WINNT_AUTH_IDENTITY _SEC_WINNT_AUTH_IDENTITY_W
#else // UNICODE
#define SEC_WINNT_AUTH_IDENTITY SEC_WINNT_AUTH_IDENTITY_A
#define PSEC_WINNT_AUTH_IDENTITY PSEC_WINNT_AUTH_IDENTITY_A
#define _SEC_WINNT_AUTH_IDENTITY _SEC_WINNT_AUTH_IDENTITY_A
#endif // UNICODE

#define RPC_C_SECURITY_QOS_VERSION_2 2L

#define RPC_C_AUTHN_INFO_TYPE_HTTP                  1

#define RPC_C_HTTP_AUTHN_TARGET_SERVER              1
#define RPC_C_HTTP_AUTHN_TARGET_PROXY               2

#define RPC_C_HTTP_AUTHN_SCHEME_BASIC      0x00000001
#define RPC_C_HTTP_AUTHN_SCHEME_NTLM       0x00000002
#define RPC_C_HTTP_AUTHN_SCHEME_PASSPORT   0x00000004
#define RPC_C_HTTP_AUTHN_SCHEME_DIGEST     0x00000008
#define RPC_C_HTTP_AUTHN_SCHEME_NEGOTIATE  0x00000010

#define RPC_C_HTTP_FLAG_USE_SSL                     1
#define RPC_C_HTTP_FLAG_USE_FIRST_AUTH_SCHEME       2

typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_W
{
    SEC_WINNT_AUTH_IDENTITY_W *TransportCredentials;
    unsigned long Flags;
    unsigned long AuthenticationTarget;
    unsigned long NumberOfAuthnSchemes;
    unsigned long *AuthnSchemes;
    unsigned short __RPC_FAR *ServerCertificateSubject;
} RPC_HTTP_TRANSPORT_CREDENTIALS_W, *PRPC_HTTP_TRANSPORT_CREDENTIALS_W;

typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_A
{
    SEC_WINNT_AUTH_IDENTITY_A *TransportCredentials;
    unsigned long Flags;
    unsigned long AuthenticationTarget;
    unsigned long NumberOfAuthnSchemes;
    unsigned long *AuthnSchemes;
    unsigned char __RPC_FAR *ServerCertificateSubject;
} RPC_HTTP_TRANSPORT_CREDENTIALS_A, *PRPC_HTTP_TRANSPORT_CREDENTIALS_A;

typedef struct _RPC_SECURITY_QOS_V2_W {
  unsigned long Version;
  unsigned long Capabilities;
  unsigned long IdentityTracking;
  unsigned long ImpersonationType;
  unsigned long AdditionalSecurityInfoType;
  union 
      {
      RPC_HTTP_TRANSPORT_CREDENTIALS_W *HttpCredentials;
      } u;
} RPC_SECURITY_QOS_V2_W, *PRPC_SECURITY_QOS_V2_W;

typedef struct _RPC_SECURITY_QOS_V2_A {
  unsigned long Version;
  unsigned long Capabilities;
  unsigned long IdentityTracking;
  unsigned long ImpersonationType;
  unsigned long AdditionalSecurityInfoType;
  union 
      {
      RPC_HTTP_TRANSPORT_CREDENTIALS_A *HttpCredentials;
      } u;
} RPC_SECURITY_QOS_V2_A, *PRPC_SECURITY_QOS_V2_A;

#define RPC_C_SECURITY_QOS_VERSION_3 3L

typedef struct _RPC_SECURITY_QOS_V3_W {
  unsigned long Version;
  unsigned long Capabilities;
  unsigned long IdentityTracking;
  unsigned long ImpersonationType;
  unsigned long AdditionalSecurityInfoType;
  union 
      {
      RPC_HTTP_TRANSPORT_CREDENTIALS_W *HttpCredentials;
      } u;
  void *Sid;
} RPC_SECURITY_QOS_V3_W, *PRPC_SECURITY_QOS_V3_W;

typedef struct _RPC_SECURITY_QOS_V3_A {
  unsigned long Version;
  unsigned long Capabilities;
  unsigned long IdentityTracking;
  unsigned long ImpersonationType;
  unsigned long AdditionalSecurityInfoType;
  union 
      {
      RPC_HTTP_TRANSPORT_CREDENTIALS_A *HttpCredentials;
      } u;
  void *Sid;
} RPC_SECURITY_QOS_V3_A, *PRPC_SECURITY_QOS_V3_A;

#endif //_AUTH_IDENTITY_DEFINED

#ifdef UNICODE

#define RPC_SECURITY_QOS_V2 RPC_SECURITY_QOS_V2_W
#define PRPC_SECURITY_QOS_V2 PRPC_SECURITY_QOS_V2_W
#define _RPC_SECURITY_QOS_V2 _RPC_SECURITY_QOS_V2_W

#define RPC_HTTP_TRANSPORT_CREDENTIALS RPC_HTTP_TRANSPORT_CREDENTIALS_W
#define PRPC_HTTP_TRANSPORT_CREDENTIALS PRPC_HTTP_TRANSPORT_CREDENTIALS_W
#define _RPC_HTTP_TRANSPORT_CREDENTIALS _RPC_HTTP_TRANSPORT_CREDENTIALS_W

#define RPC_SECURITY_QOS_V3 RPC_SECURITY_QOS_V3_W
#define PRPC_SECURITY_QOS_V3 PRPC_SECURITY_QOS_V3_W
#define _RPC_SECURITY_QOS_V3 _RPC_SECURITY_QOS_V3_W

#else // UNICODE

#define RPC_SECURITY_QOS_V2 RPC_SECURITY_QOS_V2_A
#define PRPC_SECURITY_QOS_V2 PRPC_SECURITY_QOS_V2_A
#define _RPC_SECURITY_QOS_V2 _RPC_SECURITY_QOS_V2_A

#define RPC_HTTP_TRANSPORT_CREDENTIALS RPC_HTTP_TRANSPORT_CREDENTIALS_A
#define PRPC_HTTP_TRANSPORT_CREDENTIALS PRPC_HTTP_TRANSPORT_CREDENTIALS_A
#define _RPC_HTTP_TRANSPORT_CREDENTIALS _RPC_HTTP_TRANSPORT_CREDENTIALS_A

#define RPC_SECURITY_QOS_V3 RPC_SECURITY_QOS_V3_A
#define PRPC_SECURITY_QOS_V3 PRPC_SECURITY_QOS_V3_A
#define _RPC_SECURITY_QOS_V3 _RPC_SECURITY_QOS_V3_A

#endif // UNICODE

typedef RPC_STATUS
(__RPC_USER * RPC_NEW_HTTP_PROXY_CHANNEL) (
    IN unsigned short __RPC_FAR *ServerName,
    IN unsigned short __RPC_FAR *ServerPort,
    IN unsigned char __RPC_FAR *RemoteUser,
    OUT unsigned short __RPC_FAR **NewServerName
    );

typedef void
(__RPC_USER * RPC_HTTP_PROXY_FREE_STRING) (
    IN unsigned short __RPC_FAR *ServerName
    );

#define RPC_C_AUTHZ_NONE    0
#define RPC_C_AUTHZ_NAME    1
#define RPC_C_AUTHZ_DCE     2
#define RPC_C_AUTHZ_DEFAULT 0xffffffff

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcImpersonateClient (
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcRevertToSelfEx (
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcRevertToSelf (
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClientA (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClientW (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClientExA (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc, OPTIONAL
    IN  unsigned long             Flags
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClientExW (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc, OPTIONAL
    IN  unsigned long             Flags
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthInfoA (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthInfoW (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPri