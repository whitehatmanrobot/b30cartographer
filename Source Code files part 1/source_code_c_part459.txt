define TRACE_EVENT( a )

#endif


#include "resource.h"
#include <oblist.h>
#include "ms_util.h"
#include "wboblist.hpp"
#include "ccl32.hpp"
#include "page.hpp"
#include "cgrp.hpp"
#include "wgrp.hpp"
#include "agrp.hpp"
#include "tool.hpp"
#include "twnd.hpp"
#include "t126.h"
#include "coder.hpp"
#include "t126obj.hpp"
#include "drawobj.hpp"
#include "textobj.hpp"
#include "txted.hpp"
#include "draw.hpp"
#include "wrkspobj.hpp"
#include "bmpobj.hpp"
#include "mcshelp.h"
#include "mwnd.hpp"
#include "gcchelp.h"
#include "globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\psdlg.hpp ===
//
// PSDLG.HPP
// Page Sorter Dialog
//
// Copyright Microsoft 1998-
//

#ifndef __PSDLG_HPP_
#define __PSDLG_HPP_



#define INSERT_BEFORE 1
#define INSERT_AFTER  2

#define WM_LBTRACKPOINT     0x0131

#define RENDERED_WIDTH      (DRAW_WIDTH / 16)
#define RENDERED_HEIGHT     (DRAW_HEIGHT / 16)

//
// Data we store in the GWL_USERDATA of the dialog.  Some is passed in
// by the DialogBox caller.  Some is used just by the dialog.  Some is
// returned back to the DialogBox caller.
//
typedef struct tagPAGESORT
{
    UINT        hCurPage;
    BOOL        fPageOpsAllowed;
    BOOL        fChanged;
    BOOL        fDragging;
    HWND        hwnd;
    int         iCurPageNo;
    int         iPageDragging;
    HCURSOR     hCursorCurrent;
    HCURSOR     hCursorDrag;
    HCURSOR     hCursorNoDrop;
    HCURSOR     hCursorNormal;
}
PAGESORT;


//
// Messages the caller can send to the page sort dialog
//
enum
{
    WM_PS_GETCURRENTPAGE    = WM_APP,
    WM_PS_HASCHANGED,
    WM_PS_ENABLEPAGEOPS,    // wParam == TRUE or FALSE
    WM_PS_LOCKCHANGE,
    WM_PS_PAGECLEARIND,     // wParam == hPage
    WM_PS_PAGEDELIND,       // wParam == hPage
    WM_PS_PAGEORDERUPD
};

//
// The page sorter dialog uses a horizontal listbox to display the
// thumbnail views of pages.  Each item holds a bitmap of data for the
// page.  We render this bitmap the first time the item is painted.  The
// listbox takes care of scrolling and keyboard navigation for us.
//

BOOL CALLBACK PageSortDlgProc(HWND, UINT, WPARAM, LPARAM);

void    OnInitDialog(HWND hwndPS, PAGESORT * pps);
void    OnMeasureItem(HWND hwndPS, UINT id, LPMEASUREITEMSTRUCT lpmi);
void    OnDeleteItem(HWND hwndPS, UINT id, LPDELETEITEMSTRUCT lpdi);
void    OnDrawItem(HWND hwndPS, UINT id, LPDRAWITEMSTRUCT lpdi);
void    OnCommand(PAGESORT * pps, UINT id, UINT code, HWND hwndCtl);
BOOL    OnSetCursor(PAGESORT * pps, HWND hwnd, UINT ht, UINT msg);
void    OnDelete(PAGESORT * pps);
void    InsertPage(PAGESORT * pps, UINT uiBeforeAfter);

void    OnPageClearInd(PAGESORT * pps, WB_PAGE_HANDLE hPage);
void    OnPageDeleteInd(PAGESORT * pps, WB_PAGE_HANDLE hPage);
void    OnPageOrderUpdated(PAGESORT * pps);

void    OnStartDragDrop(PAGESORT * pps, UINT iItem, int x, int y);
void    WhileDragging(PAGESORT * pps, int x, int y);
void    OnEndDragDrop(PAGESORT * pps, BOOL fComplete, int x, int y);

void    EnableButtons(PAGESORT * pps);
void    MovePage(PAGESORT * pps, int iOldPageNo, int iNewPageNo);


#endif // __PSDLG_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\resource.h ===
#define IDI_APP                           1
#define WARNSELECTWINDOW                103
#define WARNSELECTAREA                  104
#define IDR_TOOLS                       118
#define IDR_NMWBOBJ                     120
#define ABOUTBOX                        130
#define PRINTCANCEL                     131
#define PAGESORTERDIALOG                132
#define LOCKDIALOG                      133
#define INVISIBLEDIALOG                 134
#define QUERYSAVEDIALOG                 135
#define QUERYSAVEDIALOGCANCEL           136

#define IDR_MENU_WB                     137
#define CONTEXTMENU                     138
#define GROBJMENU                       139

#define MAINACCELTABLE                  140
#define TEXTEDITACCELTABLE              141
#define PAGESGROUPACCELTABLE            142

#define REMOTEPOINTERANDMASK            143
#define REMOTEPOINTERXORDATA            144
#define LOCKCURSOR                      145
#define TEXTCURSOR                      146
#define PENCURSOR                       147
#define PENFREEHANDCURSOR               148
#define HIGHLIGHTFREEHANDCURSOR         149
#define GRABCURSOR                      150
#define DRAGPAGECURSOR                  151
#define DELETECURSOR                    152

#define IM_INITIALIZING                 161
#define IDS_OBJECTSARELOCKED            716
#define IDS_CANTCLOSE                   875
#define IDS_CANTGETBMP                  876
#define IDS_LOCKEDTITLE                 884
#define IDS_MSG_USERSMIGHTLOSE          885

#define IDR_MENU_WB_WITHFILE            900


#define IDC_SWWARN_NOTAGAIN             1001
#define IDC_SAWARN_NOTAGAIN             1002
#define IDC_TOOLBAR                     1003
#define IDS_FONTOPTIONS                 1004


#define IDS_T126_EXT        		1234

//
// Page sorter dialog
//
#define IDC_PS_GOTO                     300
#define IDC_PS_DELETE                   301
#define IDC_PS_INSERT_AFTER             303
#define IDC_PS_THUMBNAILS               304

#define IDB_LGCHAT_TB_DISABLED_ICON     3000
#define IDB_LGCHAT_TB_ICON              3001
#define IDB_LGCHAT_TB_HOT_ICON          3002
#define IDB_LGCHATACTIVE_TB_ICON        3003
#define IDB_LGCHATACTIVE_TB_HOT_ICON    3004
#define IDB_LGCHATACTIVE_TB_DISABLED_ICON 3005

#define IDS_WB_STATUS_WB_NOT_ACTIVE   2000
#define IDS_WB_STATUS_WB_ACTIVE         2001
#define IDS_WB_NOT_IN_CALL_WINDOW_CAPTION 2002
#define IDS_WB_IN_CALL_WINDOW_CAPTION   2003

#define IDC_ABOUTVERSION                1041
#define IDC_INITIALIZING_ANIMATION      1042

#define IDM_EDITCOLOR                   40024
#define IDM_SELECTALL                   40025








//
// Accelerators
//
#define IDVK_HELP                       50

#define IDD_PRINT_PAGE                  101
#define IDD_DEVICE_NAME                 102

#define IDM_ABOUT                       0x3000
#define IDM_HELP                        0x3001



//
// Tools menu ids
//
#define IDM_TOOLS_START                 0x3100
#define IDM_SELECT                      IDM_TOOLS_START
#define IDM_ERASER                      0x3101
#define IDM_TEXT                        0x3102
#define IDM_HIGHLIGHT                   0x3103
#define IDM_PEN                         0x3104
#define IDM_LINE                        0x3105
#define IDM_BOX                         0x3106
#define IDM_FILLED_BOX                  0x3107
#define IDM_ELLIPSE                     0x3108
#define IDM_FILLED_ELLIPSE              0x3109
#define IDM_TOOLS_MAX                   0x310A

#define IDM_COLOR                       0x3300

#define IDM_WIDTH                      0x3400
#define IDM_WIDTH_1                    0x3401
#define IDM_WIDTHS_START               IDM_WIDTH_1
#define IDM_WIDTH_2                    0x3402
#define IDM_WIDTH_3                    0x3403
#define IDM_WIDTH_4                    0x3404
#define IDM_WIDTHS_END                 0x3405

#define IDM_PAGE_FIRST                  0x3500
#define IDM_PAGE_PREV                   0x3501
#define IDM_PAGE_ANY                    0x3502
#define IDM_PAGE_NEXT                   0x3503
#define IDM_PAGE_LAST                   0x3504
#define IDM_PAGE_GOTO                   0x3505

#define IDM_EXIT                       0x3600
#define IDM_CLEAR_PAGE                 0x3601
#define IDM_FONT                       0x3602
#define IDM_SAVE                       0x3604
#define IDM_SAVE_AS                    0x3605
#define IDM_TOOL_BAR_TOGGLE            0x3606
#define IDM_STATUS_BAR_TOGGLE          0x3608
#define IDM_OPEN                       0x360b
#define IDM_CUT                        0x360c
#define IDM_COPY                       0x360d
#define IDM_PASTE                      0x360e
#define IDM_NEW                        0x360f
#define IDM_GRAB_AREA                  0x3610
#define IDM_GRAB_WINDOW                0x3611
#define IDM_PRINT                      0x3613
#define IDM_BRING_TO_TOP               0x3614
#define IDM_SEND_TO_BACK               0x3615
#define IDM_DELETE                     0x3617
#define IDM_UNDELETE                   0x3618
#define IDM_PAGE_INSERT_AFTER          0x361c
#define IDM_DELETE_PAGE                0x361d
#define IDM_REMOTE                     0x361e
#define IDM_SYNC                       0x361f
#define IDM_LOCK                       0x3620
#define IDM_WIDTHS                     0x3622
#define IDM_PAGES                      0x3623
#define IDM_GOTO_USER_POSITION         0x3624
#define IDM_GOTO_USER_POINTER          0x3625
#define IDM_ZOOM                       0x3626

#define ID_NAV_SHIFT_TAB               0x3627
#define ID_NAV_TAB                     0x3628


//
// Scroll accelerators
//
#define IDM_PAGEUP                     0x3700
#define IDM_PAGEDOWN                   0x3701
#define IDM_SHIFTPAGEUP                0x3702
#define IDM_SHIFTPAGEDOWN              0x3703
#define IDM_LINEUP                     0x3704
#define IDM_HOME                       0x3705
#define IDM_END                        0x3706
#define IDM_LINEDOWN                   0x3707
#define IDM_SHIFTLINEUP                0x3708
#define IDM_SHIFTLINEDOWN              0x3709
#define IDM_SCROLL_END                 0x370a
#define IDM_NEXT_SHEET                 0x370b
#define IDM_PREV_SHEET                 0x370c

//
// Text Edit accelerators
//
#define IDM_DELETECHAR                 0x3800

//
// String table entry IDs
//
#define MAKE_STRING_ID(N)              (700 + N)

#define IDS_DEFAULT                    MAKE_STRING_ID(  1)

#define IDS_MENU_SYSTEM                MAKE_STRING_ID(  2)
#define IDS_MENU_FILE                  MAKE_STRING_ID(  3)
#define IDS_MENU_EDIT                  MAKE_STRING_ID(  4)
#define IDS_MENU_VIEW                  MAKE_STRING_ID(  5)
#define IDS_MENU_TOOLS                 MAKE_STRING_ID(  6)
#define IDS_MENU_HELP                  MAKE_STRING_ID(  7)
#define IDS_MENU_WIDTH                 MAKE_STRING_ID(  8)

#define IDS_CLEAR_CAPTION              MAKE_STRING_ID( 13)
#define IDS_CLEAR_MESSAGE              MAKE_STRING_ID( 14)
#define IDS_ERROR_CAPTION              MAKE_STRING_ID( 15)
#define IDS_WINDOW_CLOSED              MAKE_STRING_ID( 16)
#define IDS_PRINT_NAME                 MAKE_STRING_ID( 17)

#define IDS_UNTITLED                   MAKE_STRING_ID( 21)
#define IDS_IN_CALL                    MAKE_STRING_ID( 22)
#define IDS_NOT_IN_CALL                MAKE_STRING_ID( 23)
#define IDS_TITLE_SEPARATOR            MAKE_STRING_ID( 24)
#define IDS_PASTE                      MAKE_STRING_ID( 29)
#define IDS_PASTE_ERROR                MAKE_STRING_ID( 30)
#define IDS_SAVE                       MAKE_STRING_ID( 31)
#define IDS_SAVE_ERROR                 MAKE_STRING_ID( 32)
#define IDS_LOCK                       MAKE_STRING_ID( 33)
#define IDS_LOCK_ERROR                 MAKE_STRING_ID( 34)
#define IDS_DELETE_PAGE                MAKE_STRING_ID( 35)
#define IDS_DELETE_PAGE_MESSAGE        MAKE_STRING_ID( 36)

#define IDS_FONT_SAMPLE                MAKE_STRING_ID( 42)
#define IDS_COPY                       MAKE_STRING_ID( 48)
#define IDS_COPY_ERROR                 MAKE_STRING_ID( 49)
#define IDS_SAVE_READ_ONLY             MAKE_STRING_ID( 50)
#define IDS_JOINING                    MAKE_STRING_ID( 51)
#define IDS_INITIALIZING               MAKE_STRING_ID( 52)

//
// File extension filters
//
#define IDS_FILTER_ALL              MAKE_STRING_ID(100)
#define IDS_FILTER_ALL_SPEC         MAKE_STRING_ID(101)
#define IDS_FILTER_WHT              MAKE_STRING_ID(102)
#define IDS_FILTER_WHT_SPEC         MAKE_STRING_ID(103)
#define IDS_EXT_WHT                 MAKE_STRING_ID(104)
#define IDS_WHT_SAVE_FILTER_STRING  MAKE_STRING_ID(105)


//
// Error and information messages
//
#define IDS_MSG_TOO_MANY_PAGES         MAKE_STRING_ID(150)
#define IDS_MSG_CAPTION                MAKE_STRING_ID(151)
#define IDS_MSG_DEFAULT                MAKE_STRING_ID(152)
#define IDS_MSG_JOIN_CALL_FAILED       MAKE_STRING_ID(154)
#define IDS_MSG_WINDOWS_RESOURCES      MAKE_STRING_ID(158)
#define IDS_MSG_LOCKED                 MAKE_STRING_ID(159)
#define IDS_MSG_GRAPHIC_LOCKED         MAKE_STRING_ID(160)
#define IDS_MSG_NOT_LOCKED             MAKE_STRING_ID(161)
#define IDS_MSG_BAD_STATE_TO_LOAD_FILE MAKE_STRING_ID(162)
#define IDS_MSG_BAD_FILE_FORMAT        MAKE_STRING_ID(163)
#define IDS_MSG_BUSY                   MAKE_STRING_ID(165)
#define IDS_MSG_CM_ERROR               MAKE_STRING_ID(166)
#define IDS_MSG_AL_ERROR               MAKE_STRING_ID(167)
#define IDS_MSG_PRINTER_ERROR          MAKE_STRING_ID(169)
#define IDS_MSG_LOAD_FAIL_NO_FP        MAKE_STRING_ID(171)
#define IDS_MSG_LOAD_FAIL_NO_EXE       MAKE_STRING_ID(172)
#define IDS_MSG_LOAD_FAIL_BAD_EXE      MAKE_STRING_ID(173)
#define IDS_MSG_LOAD_FAIL_LOW_MEM      MAKE_STRING_ID(174)

//
// String IDs for hint windows associated with buttons
//

// TOOLBAR
#define IDS_HINT_SELECT                 MAKE_STRING_ID(200)
#define IDS_HINT_ERASER                 MAKE_STRING_ID(201)
#define IDS_HINT_TEXT                   MAKE_STRING_ID(202)
#define IDS_HINT_HIGHLIGHT              MAKE_STRING_ID(203)
#define IDS_HINT_PEN                    MAKE_STRING_ID(204)
#define IDS_HINT_LINE                   MAKE_STRING_ID(205)
#define IDS_HINT_BOX                    MAKE_STRING_ID(206)
#define IDS_HINT_FBOX                   MAKE_STRING_ID(207)
#define IDS_HINT_ELLIPSE                MAKE_STRING_ID(208)
#define IDS_HINT_FELLIPSE               MAKE_STRING_ID(209)
#define IDS_HINT_ZOOM_UP                MAKE_STRING_ID(210)
#define IDS_HINT_ZOOM_DOWN              MAKE_STRING_ID(211)
#define IDS_HINT_REMOTE_UP              MAKE_STRING_ID(212)
#define IDS_HINT_REMOTE_DOWN            MAKE_STRING_ID(213)
#define IDS_HINT_LOCK_UP                MAKE_STRING_ID(214)
#define IDS_HINT_LOCK_DOWN              MAKE_STRING_ID(215)
#define IDS_HINT_SYNC_UP                MAKE_STRING_ID(216)
#define IDS_HINT_SYNC_DOWN              MAKE_STRING_ID(217)
#define IDS_HINT_GRAB_AREA              MAKE_STRING_ID(218)
#define IDS_HINT_GRAB_WINDOW            MAKE_STRING_ID(219)

// WIDTHBAR
#define IDS_HINT_WIDTH_1                MAKE_STRING_ID(230)
#define IDS_HINT_WIDTH_2                MAKE_STRING_ID(231)
#define IDS_HINT_WIDTH_3                MAKE_STRING_ID(232)
#define IDS_HINT_WIDTH_4                MAKE_STRING_ID(233)

// PAGEBAR
#define IDS_HINT_PAGE_FIRST             MAKE_STRING_ID(240)
#define IDS_HINT_PAGE_PREVIOUS          MAKE_STRING_ID(241)
#define IDS_HINT_PAGE_ANY               MAKE_STRING_ID(242)
#define IDS_HINT_PAGE_NEXT              MAKE_STRING_ID(243)
#define IDS_HINT_PAGE_LAST              MAKE_STRING_ID(244)
#define IDS_HINT_PAGE_INSERT            MAKE_STRING_ID(245)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\t126obj.cpp ===
//
// T126OBJ.CPP
// T126 objects: point, openpolyline, closepolyline, ellipse, bitmaps, workspaces
//
// Copyright Microsoft 1998-
//
#include "precomp.h"
#include "NMWbObj.h"

void T126Obj::AddToWorkspace()
{

	ULONG gccHandle;

	UINT neededHandles = 1;
	if(GetType() == workspaceCreatePDU_chosen)
	{
		neededHandles = 2;
	}
	
	if(g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount >= neededHandles)
	{
		gccHandle = g_GCCPreallocHandles[g_iGCCHandleIndex].InitialGCCHandle + g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount - neededHandles;
		g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount = g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount - neededHandles;

		//
		// We got a handle  no need to ask for another one
		//
		GotGCCHandle(gccHandle);

		TimeToGetGCCHandles(PREALLOC_GCC_HANDLES);
		
		return;
	}
	else
	{

		TRACE_MSG(("GCC Tank %d has not enough handles, we needed %d and we have %d",
			g_iGCCHandleIndex, neededHandles, g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount));

		//
		// Not enough handles 
		//
		g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount = 0;
		TRACE_MSG(("GCC Tank %d is now empty, switching to other GCC tank", g_iGCCHandleIndex));

		//
		// Switch gcc handles
		//
		g_iGCCHandleIndex = g_iGCCHandleIndex ? 0 : 1;


		//
		// Try again
		//
		if(g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount >= neededHandles)
		{
			gccHandle = g_GCCPreallocHandles[g_iGCCHandleIndex].InitialGCCHandle + g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount - neededHandles;
			g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount = g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount - neededHandles;

			//
			// We got a handle  no need to ask for another one
			//
			GotGCCHandle(gccHandle);
	
			TimeToGetGCCHandles(PREALLOC_GCC_HANDLES);
		
			return;
		}
	}
	

	//
	// Save this object in our list of DrawingObjects
	//
	g_pListOfObjectsThatRequestedHandles->AddHead(this);

	//
	// Ask GCC to give us an unique handle
	//
	T120Error rc = g_pNMWBOBJ->AllocateHandles(neededHandles);

	//
	// If we are not in a conference RegistryAllocateHandle will not work,
	// so we need to create a fake confirm to remove the object from the list
	//
	if (T120_NO_ERROR != rc)
	{
		//
		// Fake a GCCAllocateHandleConfim
		//
		T126_GCCAllocateHandleConfirm(AllocateFakeGCCHandle(),neededHandles);
	}
}


//
//
// Function:    T126Obj::NormalizeRect
//
// Purpose:     Normalize a rectangle ensuring that the top left is above
//              and to the left of the bottom right.
//
//
void NormalizeRect(LPRECT lprc)
{
    int tmp;

    if (lprc->right < lprc->left)
    {
        tmp = lprc->left;
        lprc->left = lprc->right;
        lprc->right = tmp;
    }

    if (lprc->bottom < lprc->top)
    {
        tmp = lprc->top;
        lprc->top = lprc->bottom;
        lprc->bottom = tmp;
    }
}

void T126Obj::SetRect(LPCRECT lprc)
{
    m_rect.top = lprc->top;
    m_rect.bottom = lprc->bottom;
    m_rect.left = lprc->left;
    m_rect.right = lprc->right;
}

void T126Obj::SetBoundsRect(LPCRECT lprc)
{
	m_boundsRect.top = lprc->top;
	m_boundsRect.bottom = lprc->bottom;
	m_boundsRect.left = lprc->left;
	m_boundsRect.right = lprc->right;
}

void T126Obj::SetRectPts(POINT point1, POINT point2)
{
    RECT    rc;

    rc.left = point1.x;
    rc.top  = point1.y;
    rc.right = point2.x;
    rc.bottom = point2.y;

    SetRect(&rc);
}

void T126Obj::SetBoundRectPts(POINT point1, POINT point2)
{
    RECT    rc;

    rc.left = point1.x;
    rc.top  = point1.y;
    rc.right = point2.x;
    rc.bottom = point2.y;

    SetBoundsRect(&rc);
}

void T126Obj::GetRect(LPRECT lprc)
{ 
	lprc->top = m_rect.top;
	lprc->bottom = m_rect.bottom;
	lprc->left = m_rect.left;
	lprc->right = m_rect.right;
}


void T126Obj::GetBoundsRect(LPRECT lprc)
{
	if(GraphicTool() == TOOLTYPE_HIGHLIGHT || GraphicTool() == TOOLTYPE_PEN)
	{
		lprc->top = m_boundsRect.top;
		lprc->bottom = m_boundsRect.bottom;
		lprc->left = m_boundsRect.left;
		lprc->right = m_boundsRect.right;
	}
	else
	{
		GetRect(lprc);
		::InflateRect(lprc, m_penThickness/2, m_penThickness/2);
	}
	NormalizeRect(lprc);
}


BOOL T126Obj::PointInBounds(POINT point)
{
	RECT rect;
	GetBoundsRect(&rect);
	return ::PtInRect(&rect, point);
}


void T126Obj::MoveBy(int cx, int cy)
{
    // Move the bounding rectangle
    ::OffsetRect(&m_rect, cx, cy);
}

void T126Obj::MoveTo(int x, int y)
{
    // Calculate the offset needed to translate the object from its current
    // position to the required position.
    x -= m_rect.left;
    y -= m_rect.top;

    MoveBy(x, y);
}

//
// Select a drawing and add the rectangle sizes to the selector size rectangle
//
void T126Obj::SelectDrawingObject(void)
{

	if(GraphicTool() == TOOLTYPE_REMOTEPOINTER && GetOwnerID() != GET_NODE_ID_FROM_MEMBER_ID(g_MyMemberID))
	{
		return;
	}

	//
	// Mark it as selected locally
	//
	SelectedLocally();

	//
	// Calculate the size of the rectangle to be invalidated.
	//
	CalculateInvalidationRect();

	//
	// Draw the selection rectangle
	// 
	DrawRect();
}

void T126Obj::UnselectDrawingObject(void)
{
	//
	// Erase selection rect
	//
	DrawRect();

	if(GraphicTool() == TOOLTYPE_REMOTEPOINTER && GetOwnerID() != GET_NODE_ID_FROM_MEMBER_ID(g_MyMemberID))
	{
		return;
	}

    ClearSelectionFlags();

	//
	// Don't even bother sending selection changes if we were deleted
	// or if this was a remote that unselected us.
	//
	if(WasDeletedLocally() || WasSelectedRemotely())
	{
		return;
	}

	ResetAttrib();
	SetViewState(unselected_chosen);

	//
	// We are going to send a new view state, mark it as edited locally
	//
	EditedLocally();

	//
	// Sends the change in the view state to the other nodes
	//
	OnObjectEdit();
	ClearEditionFlags();
	
}


void T126Obj::DrawRect(void)
{
	if(GraphicTool() == TOOLTYPE_REMOTEPOINTER)
	{
		return;
	}

	RECT rect;
	GetBoundsRect(&rect);
	::DrawFocusRect(g_pDraw->m_hDCCached,&rect);
  
}
void T126Obj::SelectedLocally(void)
{
	m_bSelectedLocally = TRUE;
	m_bSelectedRemotely = FALSE;
	
	SetViewState(selected_chosen);

	//
	// We are going to send a new view state, mark it as edited locally
	//
	EditedLocally();

	ResetAttrib();
	ChangedViewState();

	//
	// Sends the change in the view state to the other nodes
	//
	OnObjectEdit();
}

void T126Obj::SelectedRemotely(void)
{
	m_bSelectedLocally = FALSE;
	m_bSelectedRemotely = TRUE; 
	SetViewState(selected_chosen);
}




void T126Obj::MoveBy(LONG x , LONG y)
{

	//
	// Erase the old one
	// 
	if(GraphicTool() == TOOLTYPE_REMOTEPOINTER)
	{
		UnDraw();
	}

	DrawRect();

	RECT rect;
	
	if(GraphicTool() == TOOLTYPE_PEN || GraphicTool() == TOOLTYPE_HIGHLIGHT)
	{
		GetBoundsRect(&rect);
	}
	else
	{
		GetRect(&rect);
	}
	
	::OffsetRect(&rect, x, y);
	
	if(GraphicTool() == TOOLTYPE_PEN || GraphicTool() == TOOLTYPE_HIGHLIGHT)
	{
		SetBoundsRect(&rect);
	}
	else
	{
		SetRect(&rect);
	}

	POINT anchorPoint;
	GetAnchorPoint(&anchorPoint);
	SetAnchorPoint(anchorPoint.x + x ,anchorPoint.y + y);
		
	//
	// Draw the new one
	//
	if(GraphicTool() == TOOLTYPE_REMOTEPOINTER)
	{
		Draw();
	}

	DrawRect();
	
	CalculateInvalidationRect();

	
}

void T126Obj::CalculateInvalidationRect(void)
{

	RECT rect;
	UINT penThickness = GetPenThickness();


	TRACE_DEBUG(("Invalidation Rect (%d,%d) (%d,%d)", g_pDraw->m_selectorRect.left,g_pDraw->m_selectorRect.top, g_pDraw->m_selectorRect.right, g_pDraw->m_selectorRect.bottom ));
	GetBoundsRect(&rect);
	::UnionRect(&g_pDraw->m_selectorRect,&g_pDraw->m_selectorRect,&rect);
	TRACE_DEBUG(("Invalidation Rect (%d,%d) (%d,%d)", g_pDraw->m_selectorRect.left,g_pDraw->m_selectorRect.top, g_pDraw->m_selectorRect.right, g_pDraw->m_selectorRect.bottom ));
}




//
// Checks object for an actual overlap with pRectHit. This 
// function assumes that the boundingRect has already been
// compared with pRectHit.
//
BOOL T126Obj::RectangleHit(BOOL borderHit, LPCRECT pRectHit)
{
	RECT rectEdge;
	RECT rectHit;
	RECT rect;

	//
	// If we are filled do the simple thing
	//
	if(!borderHit)
	{
		POINT point;
		point.x = (pRectHit->left + pRectHit->right) / 2;
		point.y = (pRectHit->top + pRectHit->bottom) / 2;
		if(PointInBounds(point))
		{
			return TRUE;
		}
	}


	GetRect(&rect);

	NormalizeRect(&rect);
	
	// check left edge
    rectEdge.left   = rect.left - GetPenThickness()/2;
    rectEdge.top    = rect.top -  GetPenThickness()/2;
    rectEdge.right  = rect.left + GetPenThickness()/2 ;
    rectEdge.bottom = rect.bottom + GetPenThickness()/2;

    if (::IntersectRect(&rectHit, &rectEdge, pRectHit))
		return( TRUE );

	// check right edge
	rectEdge.left =     rect.right - GetPenThickness()/2;
	rectEdge.right =    rect.right + GetPenThickness()/2;

    if (::IntersectRect(&rectHit, &rectEdge, pRectHit))
		return( TRUE );


	// check top edge
	rectEdge.left =     rect.left;
	rectEdge.right =    rect.right;
	rectEdge.top = rect.top - GetPenThickness()/2;
	rectEdge.bottom = rect.top + GetPenThickness()/2;

    if (::IntersectRect(&rectHit, &rectEdge, pRectHit))
		return( TRUE );


	// check bottom edge
	rectEdge.top = rect.bottom - GetPenThickness()/2;
	rectEdge.bottom = rect.bottom + GetPenThickness()/2;

    if (::IntersectRect(&rectHit, &rectEdge, pRectHit))
		return( TRUE );

	return( FALSE );
}

void T126Obj::SetAnchorPoint(LONG x, LONG y)
{
	if(m_anchorPoint.x != x || m_anchorPoint.y != y)
	{
		ChangedAnchorPoint();
		m_anchorPoint.x = x;
		m_anchorPoint.y = y;
	}
}


void T126Obj::SetZOrder(ZOrder zorder)
{
	m_zOrder = zorder;
	ChangedZOrder();
}



#define ARRAY_INCREMENT 0x200

DCDWordArray::DCDWordArray()
{
	MLZ_EntryOut(ZONE_FUNCTION, "DCDWordArray::DCDWordArray");
	m_Size = 0;
	m_MaxSize = ARRAY_INCREMENT;
	DBG_SAVE_FILE_LINE
	m_pData = new POINT[ARRAY_INCREMENT];
	ASSERT(m_pData);
}

DCDWordArray::~DCDWordArray()
{
	MLZ_EntryOut(ZONE_FUNCTION, "DCDWordArray::~DCDWordArray");

	delete[] m_pData;
}

//
// We need to increase the size of the array
//
BOOL DCDWordArray::ReallocateArray(void)
{
	POINT *pOldArray =  m_pData;
	DBG_SAVE_FILE_LINE
	m_pData = new POINT[m_MaxSize];
	
	ASSERT(m_pData);
	if(m_pData)
	{
		TRACE_DEBUG((">>>>>Increasing size of array to hold %d points", m_MaxSize));
	
		// copy new data from old
		memcpy( m_pData, pOldArray, (m_Size) * sizeof(POINT));

		TRACE_DEBUG(("Deleting array of points %x", pOldArray));
		delete[] pOldArray;
		return TRUE;
	}
	else
	{
		m_pData = pOldArray;
		return FALSE;
	}
}

//
// Add a new point to the array
//
void DCDWordArray::Add(POINT point)
{

	MLZ_EntryOut(ZONE_FUNCTION, "DCDWordArray::Add");
	TRACE_DEBUG(("Adding point(%d,%d) at %d", point.x, point.y, m_Size));
	TRACE_DEBUG(("Adding point at %x", &m_pData[m_Size]));

	if(m_pData == NULL)
	{
		return;
	}
	
	m_pData[m_Size].x = point.x;
	m_pData[m_Size].y = point.y;
	m_Size++;

	//
	// if we want more points, we need to re allocate the array
	//
	if(m_Size == m_MaxSize)
	{
		m_MaxSize +=ARRAY_INCREMENT;
		if(ReallocateArray() == FALSE)
		{
			m_Size--;
		}
	}
}

//
// Return the number of points in the array
//    
UINT DCDWordArray::GetSize(void)
{
	return m_Size;
}

//
// Sets the size of the array
//
void DCDWordArray::SetSize(UINT size)
{
	int newSize;
	//
	// if we want more points, we need to re allocate the array
	//
	if (size > m_MaxSize)
	{
		m_MaxSize= ((size/ARRAY_INCREMENT)+1)*ARRAY_INCREMENT;
		if(ReallocateArray() == FALSE)
		{
			return;
		}
	}
	m_Size = size;
}

void T126Obj::SetPenThickness(UINT penThickness)
{
	m_penThickness = penThickness;
	ChangedPenThickness();
}

void T126Obj::GotGCCHandle(ULONG gccHandle)
{
	//
	// Save this objects handle
	//
	SetThisObjectHandle(gccHandle);
	
	//
	// It was created locally
	//
	CreatedLocally();

	switch(GetType())
	{
		//
		// New drawing requested a unique handle
		//
		case(bitmapCreatePDU_chosen):
		case(drawingCreatePDU_chosen):
		{

			WorkspaceObj * pWorkspace =	GetWorkspace(GetWorkspaceHandle());
			if(pWorkspace && !pWorkspace->IsObjectInWorkspace(this))
			{		
				//
				// Add a this drawing to the correct workspace
				//
				if(!AddT126ObjectToWorkspace(this))
				{
					return;
				}
			}

			break;
		}

		//
		// New workspace requested a unique handle
		//
		case(workspaceCreatePDU_chosen):
		{
			
			//
			// Save this objects handle
			//
			SetViewHandle(gccHandle + 1);
			SetWorkspaceHandle(gccHandle);

			if(!IsWorkspaceListed(this))
			{
				AddNewWorkspace((WorkspaceObj*) this);
			}


			break;
		}
	}

	//
	// Send it to T126 apps
	//
	SendNewObjectToT126Apps();

}


//
// Create the nonstandard pdu header
//
void CreateNonStandardPDU(NonStandardParameter * sipdu, LPSTR NonStandardString)
{
		PT126_VENDORINFO vendorInfo;
		sipdu->nonStandardIdentifier.choice = h221nonStandard_chosen;
		vendorInfo = (PT126_VENDORINFO) &sipdu->nonStandardIdentifier.u.h221nonStandard.value;
		vendorInfo->bCountryCode =	USA_H221_COUNTRY_CODE;
		vendorInfo->bExtension = USA_H221_COUNTRY_EXTENSION;
		vendorInfo->wManufacturerCode = MICROSOFT_H_221_MFG_CODE;
		lstrcpy((LPSTR)&vendorInfo->nonstandardString,NonStandardString);
		sipdu->nonStandardIdentifier.u.h221nonStandard.length =  sizeof(T126_VENDORINFO) -sizeof(vendorInfo->nonstandardString) + lstrlen(NonStandardString);
		sipdu->data.value = NULL;
}


void TimeToGetGCCHandles(ULONG numberOfGccHandles)
{

	

	TRACE_MSG(("Using GCC Tank %d ", g_iGCCHandleIndex));
	TRACE_MSG(("GCC Tank 0 has %d GCC handles ", g_GCCPreallocHandles[0].GccHandleCount));
	TRACE_MSG(("GCC Tank 1 has %d GCC handles ", g_GCCPreallocHandles[1].GccHandleCount));


	//
	// If we have half a tank of GCC handles, it is time to fill up the spare tank
	//
	if(g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount <= PREALLOC_GCC_HANDLES / 2 &&
		g_GCCPreallocHandles[g_iGCCHandleIndex ? 0 : 1].GccHandleCount == 0 &&
		!g_WaitingForGCCHandles)
	{

		TRACE_MSG(("GCC Tank %d is half full, time to get more GCC handles", g_iGCCHandleIndex));

		g_pNMWBOBJ->AllocateHandles(numberOfGccHandles);
		g_WaitingForGCCHandles = TRUE;
	}

	//
	// If we ran out of handles, it is time to switch tanks
	//
	if(g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount == 0)
	{
		TRACE_MSG(("GCC Tank %d is empty, switching to other GCC tank", g_iGCCHandleIndex));
		g_iGCCHandleIndex = g_iGCCHandleIndex ? 0 : 1;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\t126obj.hpp ===
//
// T126OBJ.HPP
// Drawing objects: point, openpolyline, closepolyline, ellipse
//
// Copyright Microsoft 1998-
//


void GetDestinationAddress(DrawingDestinationAddress *DestinationAddress, PUINT workspaceHandle, PUINT planeID);
void NormalizeRect(LPRECT lprc);
void CreateNonStandardPDU(NonStandardParameter * sipdu, LPSTR NonStandardString);
void TimeToGetGCCHandles(ULONG numberOfGccHandles);

//
// Member ID
//
#define MAKE_MEMBER_ID(nid,uid)			(MAKELONG((nid),(uid)))
#define GET_NODE_ID_FROM_MEMBER_ID(id)	(LOWORD(id))
#define GET_USER_ID_FROM_MEMBER_ID(id)	(HIWORD(id))
typedef ULONG	MEMBER_ID;				// loword = node_id, hiword = user_id


extern ULONG g_MyMemberID;

typedef struct
{
    BYTE                    bCountryCode;
    BYTE                    bExtension;
    WORD                    wManufacturerCode;
    BYTE					nonstandardString;
} T126_VENDORINFO, *PT126_VENDORINFO;


class T126Obj
{

public:

	virtual ~T126Obj(){};

	virtual void Draw(HDC hdc = NULL, BOOL bForcedDraw = FALSE, BOOL bPrinting = FALSE) = 0;
	virtual void UnDraw(void) = 0;
	virtual BOOL CheckReallyHit(LPCRECT pRectHit) = 0;
	BOOL 	RectangleHit(BOOL borderHit, LPCRECT pRectHit);

	virtual void SetPenColor(COLORREF rgb, BOOL isPresent) = 0;
    virtual BOOL GetPenColor(COLORREF * pcr) = 0;
    virtual BOOL GetPenColor(RGBTRIPLE * prgb) = 0;

	virtual BOOL HasFillColor(void) = 0;
	virtual void SetFillColor(COLORREF rgb, BOOL isPresent) = 0;
    virtual BOOL GetFillColor(COLORREF * pcr) = 0;
    virtual BOOL GetFillColor(RGBTRIPLE * prgb) = 0;

    virtual UINT GraphicTool(void) { return m_ToolType;}
    virtual void SetViewHandle(UINT viewHandle) = 0;



	//
	// Edit stuff
	//
	virtual void ChangedAnchorPoint(void) = 0;
	virtual BOOL HasAnchorPointChanged(void) = 0;
	virtual void ChangedZOrder(void) = 0;
	virtual BOOL HasZOrderChanged(void) = 0;
	virtual void ChangedViewState(void) = 0;
	virtual BOOL HasViewStateChanged(void) = 0;
	virtual void ResetAttrib(void) = 0;
	virtual void SetAllAttribs(void) = 0;
	virtual void ChangedPenThickness(void) = 0;

	virtual void OnObjectEdit(void) = 0;
	virtual void OnObjectDelete(void) = 0;
	virtual void SendNewObjectToT126Apps(void) = 0;
	virtual void GetEncodedCreatePDU(ASN1_BUF *pBuf) = 0;
	void 	GotGCCHandle(ULONG gccHandle);



	//
	// Draw, bitmap, or workspace object
	//
	UINT GetType(void){return m_T126ObjectType;};
	void SetType(UINT type){m_T126ObjectType = type;};

	//
	// Workspace stuff
	//
	UINT GetWorkspaceHandle(void) {return m_workspaceHandle;};
	void SetWorkspaceHandle(UINT handle) {m_workspaceHandle = handle;};

	//
	// Get/set plane id
	//
    void SetPlaneID(UINT planeID){m_planeID = planeID;}
    UINT  GetPlaneID(void) { return m_planeID; }

	//
	// This object's handle
	//
	UINT GetThisObjectHandle(void) {return m_thisObjectHandle;};
	void SetThisObjectHandle(UINT handle) {m_thisObjectHandle = handle; TRACE_DEBUG(("Object 0x%08x Handle = %d", this, handle));};

	//
	// Get/set view state
	//
    void SetViewState(UINT viewState){m_viewState = viewState; ChangedViewState();}
    UINT  GetViewState(void) { return m_viewState;}

	//
	// Get/set zorder
	//
    void SetZOrder(ZOrder zorder);
    ZOrder  GetZOrder(void) { return m_zOrder; }

	//
	// Get/set anchor Point
	//
    void SetAnchorPoint(LONG x, LONG y);
    void GetAnchorPoint(LPPOINT lpPoint) { *lpPoint = m_anchorPoint; }

    //
    // Get/set the bounding rectangle of the graphic object (in logical
    // co-ordinates).
    //

	void	SetRect(LPCRECT lprc);
    void    GetRect(LPRECT lprc);
	void	SetRectPts(POINT point1, POINT point2);
	void	SetBoundRectPts(POINT point1, POINT point2);
    void    GetBoundsRect(LPRECT lprc);
	void 	SetBoundsRect(LPCRECT lprc);
	BOOL 	PointInBounds(POINT point);

    //
    // Get/set the width of the pen used to draw the object
    //
    void SetPenThickness(UINT penThickness);
    UINT GetPenThickness(void) { return m_penThickness;}

	//
	// Get/set penROP
	//
	void SetROP(UINT penROP) {m_penROP = penROP;}
	UINT GetROP(void){return m_penROP;}


	void MoveBy(int cx, int cy);
	void MoveTo(int x, int y);

	WBPOSITION	m_MyPosition;			// Returns this objects position in the list it is located
	WBPOSITION	GetMyPosition(void){return m_MyPosition;}
	void SetMyPosition(WBPOSITION pos){m_MyPosition = pos;}

	WorkspaceObj * m_pMyWorkspace;
	WorkspaceObj * GetMyWorkspace(void){return m_pMyWorkspace;}
	void SetMyWorkspace(WorkspaceObj * pWorkspace){m_pMyWorkspace = pWorkspace;}

	
	void CalculateInvalidationRect(void);
	void DrawMarker(LPCRECT pMarkerRect );
	void DrawRect(void);
	void SelectDrawingObject(void);
	void UndrawMarker(LPCRECT pMarkerRect );
	void UnselectDrawingObject(void);
	void MoveBy(LONG x , LONG y);


	void CreatedLocally(void){m_bCreatedLocally = TRUE;}
	BOOL WasCreatedLocally(void){return m_bCreatedLocally;}
	void ClearCreationFlags(void){m_bCreatedLocally = FALSE;}

	void SelectedLocally(void);
	void SelectedRemotely(void);
	BOOL WasSelectedLocally(){return m_bSelectedLocally;}
	BOOL WasSelectedRemotely(){return m_bSelectedRemotely;}
	BOOL IsSelected(void){return (m_bSelectedLocally || m_bSelectedRemotely);}
	void ClearSelectionFlags(void){m_bSelectedLocally = FALSE; m_bSelectedRemotely = FALSE;}
	
	void EditedLocally(void){m_bEditedLocally = TRUE;}
	BOOL WasEditedLocally(void){return m_bEditedLocally;}
	void ClearEditionFlags(void){m_bEditedLocally = FALSE;}
	
	void DeletedLocally(void){m_bDeleteLocally = TRUE;}
	BOOL WasDeletedLocally(void){return m_bDeleteLocally;}
	void ClearDeletionFlags(void){m_bDeleteLocally = FALSE;}
	void SetOwnerID(ULONG ID){
								m_OwnerID = GET_NODE_ID_FROM_MEMBER_ID(ID);
								TRACE_DEBUG(("SetOwnerID ID= %x",m_OwnerID));
								}
	ULONG GetOwnerID(void){return m_OwnerID;}
	BOOL IAmTheOwner(void){return m_OwnerID == GET_NODE_ID_FROM_MEMBER_ID(g_MyMemberID);}
	
	void AddToWorkspace();

	protected:
		UINT			m_ToolType;				// Tool type from UI

		BOOL m_bCreatedLocally;
		BOOL m_bSelectedLocally;
		BOOL m_bSelectedRemotely;
		BOOL m_bEditedLocally;
		BOOL m_bDeleteLocally;
		RECT m_boundsRect;
		RECT m_rect;



	private:
		ULONG			m_OwnerID;				// The owner of this selected object
		UINT			m_T126ObjectType;
		UINT        	m_planeID;				// Destination plane in workspace
		UINT			m_workspaceHandle;		// Destination workspace for this object
		UINT			m_thisObjectHandle;		// My own handle assigned by GCC
		UINT			m_viewState;
		ZOrder			m_zOrder;
		POINT			m_anchorPoint;
		UINT			m_penThickness;
		UINT			m_penROP;
};


class DCDWordArray
{

  public:
	DCDWordArray(void);
	~DCDWordArray(void);
	
    void Add(POINT point);
	BOOL ReallocateArray(void);
	POINT* GetBuffer(void) { return m_pData; }
    void SetSize(UINT size);
	UINT GetSize(void);

    POINT* operator[](UINT index){return &(m_pData[index]);}
	
  private:

	POINT*  m_pData;
	UINT	m_Size;
	UINT	m_MaxSize;

  
    
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\twnd.hpp ===
//
// TWND.HPP
// Tool Window Class
//
// Copyright Microsoft 1998-
//
#ifndef __TWND_HPP_
#define __TWND_HPP_


//
// Our toolbar has three sections:
//      5 rows of exclusive tools 
//      SEPARATOR
//      2 rows of options
//      SEPARATOR
//      1 row of other commands (screen grabbing)
//      


#define TOOLBAR_NUMROWS			8
#define TOOLBAR_NUMSEPARATORS	2
#define TOOLBAR_NUMCOLS			2

#define TOOLBAR_FIRSTBUTTON     0
#define TOOLBAR_MAXBUTTON       18
#define TOOLBAR_LASTBUTTON      (TOOLBAR_MAXBUTTON - 1)


#define TOOLBAR_IMAGEWIDTH      16
#define TOOLBAR_IMAGEHEIGHT     15    
#define TOOLBAR_BTNEXTRA        7
#define TOOLBAR_BTNWIDTH        (TOOLBAR_IMAGEWIDTH + TOOLBAR_BTNEXTRA)
#define TOOLBAR_BTNHEIGHT       (TOOLBAR_IMAGEHEIGHT + TOOLBAR_BTNEXTRA)
#define TOOLBAR_MARGINX         (::GetSystemMetrics(SM_CXEDGE))
#define TOOLBAR_SEPARATORY      8
#define TOOLBAR_WIDTH           (2 * TOOLBAR_BTNWIDTH + 3 * TOOLBAR_MARGINX)


//
//
// Class:   WbToolBar
//
// Purpose: Define Whiteboard tool-bar window
//
//
class WbToolBar
{
public:
    //
    // Construction
    //
    WbToolBar();
    ~WbToolBar();

    //
    // Window creation
    //
    BOOL Create(HWND hwndParent);

    //
    // Button manipulation
    //
    BOOL PushDown(UINT uiId);
    BOOL PopUp(UINT uiId);

    BOOL Enable(UINT uiId);
    BOOL Disable(UINT uiId);

    //
    // Resizing functions
    //
    void    GetNaturalSize(LPSIZE lpsize);
    UINT    WidthFromHeight(UINT height);

    void    RecolorButtonImages(void);

    HWND    m_hwnd;

protected:
    HBITMAP m_hbmImages;
};


#endif // __TWND_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\t126.h ===
/* Copyright (C) Microsoft Corporation, 1998-1999. All rights reserved. */
/* ASN.1 definitions for Whiteboard */

#ifndef _T126_Module_H_
#define _T126_Module_H_

#include "msper.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes * PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes;

typedef struct WorkspaceEditPDU_planeEdits * PWorkspaceEditPDU_planeEdits;

typedef struct WorkspaceCreatePDU_viewParameters * PWorkspaceCreatePDU_viewParameters;

typedef struct WorkspaceCreatePDU_planeParameters * PWorkspaceCreatePDU_planeParameters;

typedef struct WorkspaceCreatePDU_protectedPlaneAccessList * PWorkspaceCreatePDU_protectedPlaneAccessList;

typedef struct BitmapCreatePDU_checkpoints * PBitmapCreatePDU_checkpoints;

typedef struct BitmapCheckpointPDU_passedCheckpoints * PBitmapCheckpointPDU_passedCheckpoints;

typedef struct EditablePlaneCopyDescriptor_objectList * PEditablePlaneCopyDescriptor_objectList;

typedef struct BitmapData_dataCheckpoint * PBitmapData_dataCheckpoint;

typedef struct ColorIndexTable * PColorIndexTable;

typedef struct WorkspaceCreatePDU_planeParameters_Seq_usage * PWorkspaceCreatePDU_planeParameters_Seq_usage;

typedef struct ColorPalette_colorLookUpTable_paletteRGB_palette * PColorPalette_colorLookUpTable_paletteRGB_palette;

typedef struct ColorPalette_colorLookUpTable_paletteCIELab_palette * PColorPalette_colorLookUpTable_paletteCIELab_palette;

typedef struct ColorPalette_colorLookUpTable_paletteYCbCr_palette * PColorPalette_colorLookUpTable_paletteYCbCr_palette;

typedef struct WorkspaceRefreshStatusPDU_nonStandardParameters * PWorkspaceRefreshStatusPDU_nonStandardParameters;

typedef struct WorkspaceReadyPDU_nonStandardParameters * PWorkspaceReadyPDU_nonStandardParameters;

typedef struct WorkspacePlaneCopyPDU_nonStandardParameters * PWorkspacePlaneCopyPDU_nonStandardParameters;

typedef struct WorkspaceEditPDU_nonStandardParameters * PWorkspaceEditPDU_nonStandardParameters;

typedef struct WorkspaceEditPDU_viewEdits * PWorkspaceEditPDU_viewEdits;

typedef struct WorkspaceDeletePDU_nonStandardParameters * PWorkspaceDeletePDU_nonStandardParameters;

typedef struct WorkspaceCreateAcknowledgePDU_nonStandardParameters * PWorkspaceCreateAcknowledgePDU_nonStandardParameters;

typedef struct WorkspaceCreatePDU_nonStandardParameters * PWorkspaceCreatePDU_nonStandardParameters;

typedef struct TextEditPDU_nonStandardParameters * PTextEditPDU_nonStandardParameters;

typedef struct TextDeletePDU_nonStandardParameters * PTextDeletePDU_nonStandardParameters;

typedef struct TextCreatePDU_nonStandardParameters * PTextCreatePDU_nonStandardParameters;

typedef struct RemotePrintPDU_nonStandardParameters * PRemotePrintPDU_nonStandardParameters;

typedef struct RemotePointingDeviceEventPDU_nonStandardParameters * PRemotePointingDeviceEventPDU_nonStandardParameters;

typedef struct RemoteKeyboardEventPDU_nonStandardParameters * PRemoteKeyboardEventPDU_nonStandardParameters;

typedef struct RemoteEventPermissionRequestPDU_nonStandardParameters * PRemoteEventPermissionRequestPDU_nonStandardParameters;

typedef struct RemoteEventPermissionRequestPDU_remoteEventPermissionList * PRemoteEventPermissionRequestPDU_remoteEventPermissionList;

typedef struct RemoteEventPermissionGrantPDU_nonStandardParameters * PRemoteEventPermissionGrantPDU_nonStandardParameters;

typedef struct RemoteEventPermissionGrantPDU_remoteEventPermissionList * PRemoteEventPermissionGrantPDU_remoteEventPermissionList;

typedef struct FontPDU_nonStandardParameters * PFontPDU_nonStandardParameters;

typedef struct DrawingEditPDU_nonStandardParameters * PDrawingEditPDU_nonStandardParameters;

typedef struct DrawingDeletePDU_nonStandardParameters * PDrawingDeletePDU_nonStandardParameters;

typedef struct DrawingCreatePDU_nonStandardParameters * PDrawingCreatePDU_nonStandardParameters;

typedef struct ConductorPrivilegeRequestPDU_nonStandardParameters * PConductorPrivilegeRequestPDU_nonStandardParameters;

typedef struct ConductorPrivilegeGrantPDU_nonStandardParameters * PConductorPrivilegeGrantPDU_nonStandardParameters;

typedef struct BitmapEditPDU_nonStandardParameters * PBitmapEditPDU_nonStandardParameters;

typedef struct BitmapDeletePDU_nonStandardParameters * PBitmapDeletePDU_nonStandardParameters;

typedef struct BitmapCreateContinuePDU_nonStandardParameters * PBitmapCreateContinuePDU_nonStandardParameters;

typedef struct BitmapCreatePDU_nonStandardParameters * PBitmapCreatePDU_nonStandardParameters;

typedef struct BitmapCheckpointPDU_nonStandardParameters * PBitmapCheckpointPDU_nonStandardParameters;

typedef struct BitmapAbortPDU_nonStandardParameters * PBitmapAbortPDU_nonStandardParameters;

typedef struct ArchiveOpenPDU_nonStandardParameters * PArchiveOpenPDU_nonStandardParameters;

typedef struct ArchiveErrorPDU_nonStandardParameters * PArchiveErrorPDU_nonStandardParameters;

typedef struct ArchiveClosePDU_nonStandardParameters * PArchiveClosePDU_nonStandardParameters;

typedef struct ArchiveAcknowledgePDU_nonStandardParameters * PArchiveAcknowledgePDU_nonStandardParameters;

typedef struct VideoWindowEditPDU_nonStandardParameters * PVideoWindowEditPDU_nonStandardParameters;

typedef struct VideoWindowDeletePDU_nonStandardParameters * PVideoWindowDeletePDU_nonStandardParameters;

typedef struct VideoWindowCreatePDU_nonStandardParameters * PVideoWindowCreatePDU_nonStandardParameters;

typedef struct VideoSourceIdentifier_dSMCCConnBinder * PVideoSourceIdentifier_dSMCCConnBinder;

typedef struct TransparencyMask_nonStandardParameters * PTransparencyMask_nonStandardParameters;

typedef struct PointList_pointsDiff16 * PPointList_pointsDiff16;

typedef struct PointList_pointsDiff8 * PPointList_pointsDiff8;

typedef struct PointList_pointsDiff4 * PPointList_pointsDiff4;

typedef struct WorkspaceEditPDU_viewEdits_Set_action_editView * PWorkspaceEditPDU_viewEdits_Set_action_editView;

typedef struct WorkspaceEditPDU_viewEdits_Set_action_createNewView * PWorkspaceEditPDU_viewEdits_Set_action_createNewView;

typedef struct WorkspaceEditPDU_planeEdits_Set_planeAttributes * PWorkspaceEditPDU_planeEdits_Set_planeAttributes;

typedef struct WorkspaceCreatePDU_viewParameters_Set_viewAttributes * PWorkspaceCreatePDU_viewParameters_Set_viewAttributes;

typedef struct WorkspaceCreatePDU_planeParameters_Seq_planeAttributes * PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes;

typedef struct WorkspaceEditPDU_attributeEdits * PWorkspaceEditPDU_attributeEdits;

typedef struct WorkspaceCreatePDU_workspaceAttributes * PWorkspaceCreatePDU_workspaceAttributes;

typedef struct RemoteKeyboardEventPDU_keyModifierStates * PRemoteKeyboardEventPDU_keyModifierStates;

typedef struct ConductorPrivilegeRequestPDU_privilegeList * PConductorPrivilegeRequestPDU_privilegeList;

typedef struct ConductorPrivilegeGrantPDU_privilegeList * PConductorPrivilegeGrantPDU_privilegeList;

typedef struct VideoWindowEditPDU_attributeEdits * PVideoWindowEditPDU_attributeEdits;

typedef struct VideoWindowCreatePDU_attributes * PVideoWindowCreatePDU_attributes;

typedef struct DrawingEditPDU_attributeEdits * PDrawingEditPDU_attributeEdits;

typedef struct DrawingCreatePDU_attributes * PDrawingCreatePDU_attributes;

typedef struct BitmapEditPDU_attributeEdits * PBitmapEditPDU_attributeEdits;

typedef struct BitmapCreatePDU_attributes * PBitmapCreatePDU_attributes;

typedef ASN1uint16_t ColorIndexTable_Seq;

typedef ASN1char16string_t ArchiveEntryName;

typedef ASN1char16string_t ArchiveName;

typedef ASN1uint16_t DataPlaneID;

typedef ASN1uint32_t Handle;

typedef ASN1uint16_t MCSUserID;

typedef struct H221NonStandardIdentifier {
    ASN1uint32_t length;
    ASN1octet_t value[255];
} H221NonStandardIdentifier;

typedef ASN1uint16_t PenThickness;

typedef ASN1uint16_t TokenID;

typedef ASN1int32_t WorkspaceCoordinate;

typedef enum ZOrder {
    front = 0,
    back = 1,
} ZOrder;

typedef struct BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes {
    PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes next;
    PColorIndexTable value;
} BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes_Element;

typedef struct BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode {
    ASN1choice_t choice;
    union {
#	define progressivePalettes_chosen 1
	PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes progressivePalettes;
#	define selfProgressive_chosen 2
    } u;
} BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode;

typedef struct ColorAccuracyEnhancementCIELab_generalCIELabParameters_gamut {
    ASN1int16_t lSpan;
    ASN1int16_t lOffset;
    ASN1int16_t aSpan;
    ASN1int16_t aOffset;
    ASN1int16_t bSpan;
    ASN1int16_t bOffset;
} ColorAccuracyEnhancementCIELab_generalCIELabParameters_gamut;

typedef struct EditablePlaneCopyDescriptor_objectList_Seq {
    Handle sourceObjectHandle;
    Handle destinationObjectHandle;
} EditablePlaneCopyDescriptor_objectList_Seq;

typedef struct WorkspaceCreatePDU_planeParameters_Seq {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t editable;
    PWorkspaceCreatePDU_planeParameters_Seq_usage usage;
#   define planeAttributes_present 0x80
    PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes planeAttributes;
} WorkspaceCreatePDU_planeParameters_Seq;

typedef struct WorkspaceCreatePDU_viewParameters_Set {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle viewHandle;
#   define viewAttributes_present 0x80
    PWorkspaceCreatePDU_viewParameters_Set_viewAttributes viewAttributes;
} WorkspaceCreatePDU_viewParameters_Set;

typedef struct WorkspaceEditPDU_planeEdits_Set {
    DataPlaneID plane;
    PWorkspaceEditPDU_planeEdits_Set_planeAttributes planeAttributes;
} WorkspaceEditPDU_planeEdits_Set;

typedef struct WorkspaceEditPDU_planeEdits {
    PWorkspaceEditPDU_planeEdits next;
    WorkspaceEditPDU_planeEdits_Set value;
} WorkspaceEditPDU_planeEdits_Element;

typedef struct WorkspaceCreatePDU_viewParameters {
    PWorkspaceCreatePDU_viewParameters next;
    WorkspaceCreatePDU_viewParameters_Set value;
} WorkspaceCreatePDU_viewParameters_Element;

typedef struct WorkspaceCreatePDU_planeParameters {
    PWorkspaceCreatePDU_planeParameters next;
    WorkspaceCreatePDU_planeParameters_Seq value;
} WorkspaceCreatePDU_planeParameters_Element;

typedef struct WorkspaceCreatePDU_protectedPlaneAccessList {
    PWorkspaceCreatePDU_protectedPlaneAccessList next;
    MCSUserID value;
} WorkspaceCreatePDU_protectedPlaneAccessList_Element;

typedef struct BitmapCreatePDU_checkpoints {
    PBitmapCreatePDU_checkpoints next;
    TokenID value;
} BitmapCreatePDU_checkpoints_Element;

typedef struct BitmapCheckpointPDU_passedCheckpoints {
    PBitmapCheckpointPDU_passedCheckpoints next;
    TokenID value;
} BitmapCheckpointPDU_passedCheckpoints_Element;

typedef struct WorkspaceIdentifier_archiveWorkspace {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle archiveHandle;
    ArchiveEntryName entryName;
#   define modificationTime_present 0x80
    ASN1generalizedtime_t modificationTime;
} WorkspaceIdentifier_archiveWorkspace;

typedef struct PixelAspectRatio_general {
    ASN1uint16_t numerator;
    ASN1uint16_t denominator;
} PixelAspectRatio_general;

typedef struct EditablePlaneCopyDescriptor_objectList {
    PEditablePlaneCopyDescriptor_objectList next;
    EditablePlaneCopyDescriptor_objectList_Seq value;
} EditablePlaneCopyDescriptor_objectList_Element;

typedef struct ColorAccuracyEnhancementGreyscale_generalGreyscaleParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ColorAccuracyEnhancementGreyscale_generalGreyscaleParameters_gamma_present 0x80
    double gamma;
} ColorAccuracyEnhancementGreyscale_generalGreyscaleParameters;

typedef struct ColorAccuracyEnhancementCIELab_generalCIELabParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ColorAccuracyEnhancementCIELab_generalCIELabParameters_colorTemperature_present 0x80
    ASN1uint32_t colorTemperature;
#   define gamut_present 0x40
    ColorAccuracyEnhancementCIELab_generalCIELabParameters_gamut gamut;
} ColorAccuracyEnhancementCIELab_generalCIELabParameters;

typedef struct BitmapRegion_lowerRight {
    ASN1uint16_t xCoordinate;
    ASN1uint16_t yCoordinate;
} BitmapRegion_lowerRight;

typedef struct BitmapRegion_upperLeft {
    ASN1uint16_t xCoordinate;
    ASN1uint16_t yCoordinate;
} BitmapRegion_upperLeft;

typedef struct BitmapData_dataCheckpoint {
    PBitmapData_dataCheckpoint next;
    TokenID value;
} BitmapData_dataCheckpoint_Element;

typedef struct ArchiveHeader {
    ArchiveName archiveName;
    ASN1generalizedtime_t archiveCreationTime;
    ASN1generalizedtime_t archiveModificationTime;
} ArchiveHeader;

typedef struct ArchiveMode {
    ASN1bool_t create;
    ASN1bool_t read;
    ASN1bool_t write;
} ArchiveMode;

typedef struct BitmapData {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define dataCheckpoint_present 0x80
    PBitmapData_dataCheckpoint dataCheckpoint;
#   define padBits_present 0x40
    ASN1uint16_t padBits;
    struct BitmapData_data_data {
	ASN1uint32_t length;
	ASN1octet_t value[8192];
    } data;
} BitmapData;

typedef struct BitmapHeaderT4 {
    ASN1bool_t twoDimensionalEncoding;
} BitmapHeaderT4;

typedef struct BitmapHeaderT6 {
    char placeholder;
} BitmapHeaderT6;

typedef struct BitmapRegion {
    BitmapRegion_upperLeft upperLeft;
    BitmapRegion_lowerRight lowerRight;
} BitmapRegion;

typedef struct BitmapSize {
    ASN1uint32_t width;
    ASN1uint32_t height;
} BitmapSize;

typedef struct ColorCIELab {
    ASN1uint16_t l;
    ASN1uint16_t a;
    ASN1uint16_t b;
} ColorCIELab;

typedef struct ColorCIExyChromaticity {
    double x;
    double y;
} ColorCIExyChromaticity;

typedef struct ColorIndexTable {
    PColorIndexTable next;
    ColorIndexTable_Seq value;
} ColorIndexTable_Element;

typedef struct ColorRGB {
    ASN1uint16_t r;
    ASN1uint16_t g;
    ASN1uint16_t b;
} ColorRGB;

typedef struct ColorYCbCr {
    ASN1uint16_t y;
    ASN1uint16_t cb;
    ASN1uint16_t cr;
} ColorYCbCr;

typedef struct DSMCCTap {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t use;
    ASN1uint16_t id;
    ASN1uint16_t associationTag;
#   define selector_present 0x80
    struct DSMCCTap_selector_selector {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } selector;
} DSMCCTap;

typedef struct NonStandardIdentifier {
    ASN1choice_t choice;
    union {
#	define object_chosen 1
	ASN1objectidentifier_t object;
#	define h221nonStandard_chosen 2
	H221NonStandardIdentifier h221nonStandard;
    } u;
} NonStandardIdentifier;

typedef struct NonStandardParameter {
    NonStandardIdentifier nonStandardIdentifier;
    ASN1octetstring_t data;
} NonStandardParameter;

typedef struct PenNib {
    ASN1choice_t choice;
    union {
#	define circular_chosen 1
#	define PenNib_square_chosen 2
#	define nonStandardNib_chosen 3
	NonStandardIdentifier nonStandardNib;
    } u;
} PenNib;

typedef struct PixelAspectRatio {
    ASN1choice_t choice;
    union {
#	define PixelAspectRatio_square_chosen 1
#	define cif_chosen 2
#	define fax1_chosen 3
#	define fax2_chosen 4
#	define general_chosen 5
	PixelAspectRatio_general general;
#	define nonStandardAspectRatio_chosen 6
	NonStandardIdentifier nonStandardAspectRatio;
    } u;
} PixelAspectRatio;

typedef struct PlaneProtection {
    ASN1bool_t protectedplane;
} PlaneProtection;

typedef struct PlaneUsage {
    ASN1choice_t choice;
    union {
#	define annotation_chosen 1
#	define image_chosen 2
#	define nonStandardPlaneUsage_chosen 3
	NonStandardIdentifier nonStandardPlaneUsage;
    } u;
} PlaneUsage;

typedef struct PointList {
    ASN1choice_t choice;
    union {
#	define pointsDiff4_chosen 1
	PPointList_pointsDiff4 pointsDiff4;
#	define pointsDiff8_chosen 2
	PPointList_pointsDiff8 pointsDiff8;
#	define pointsDiff16_chosen 3
	PPointList_pointsDiff16 pointsDiff16;
    } u;
} PointList;

typedef struct PointDiff4 {
    ASN1int8_t xCoordinate;
    ASN1int8_t yCoordinate;
} PointDiff4;

typedef struct PointDiff8 {
    ASN1int8_t xCoordinate;
    ASN1int8_t yCoordinate;
} PointDiff8;

typedef struct PointDiff16 {
    ASN1int16_t xCoordinate;
    ASN1int16_t yCoordinate;
} PointDiff16;

typedef struct RemoteEventDestinationAddress {
    ASN1choice_t choice;
    union {
#	define softCopyWorkspace_chosen 1
	Handle softCopyWorkspace;
#	define RemoteEventDestinationAddress_nonStandardDestination_chosen 2
	NonStandardParameter nonStandardDestination;
    } u;
} RemoteEventDestinationAddress;

typedef struct RemoteEventPermission {
    ASN1choice_t choice;
    union {
#	define keyboardEvent_chosen 1
#	define pointingDeviceEvent_chosen 2
#	define nonStandardEvent_chosen 3
	NonStandardIdentifier nonStandardEvent;
    } u;
} RemoteEventPermission;

typedef struct RotationSpecifier {
    ASN1uint16_t rotationAngle;
    PointDiff16 rotationAxis;
} RotationSpecifier;

typedef struct SoftCopyDataPlaneAddress {
    Handle workspaceHandle;
    DataPlaneID plane;
} SoftCopyDataPlaneAddress;

typedef struct SoftCopyPointerPlaneAddress {
    Handle workspaceHandle;
} SoftCopyPointerPlaneAddress;

typedef struct SourceDisplayIndicator {
    double displayAspectRatio;
    double horizontalSizeRatio;
    double horizontalPosition;
    double verticalPosition;
} SourceDisplayIndicator;

typedef struct VideoWindowDestinationAddress {
    ASN1choice_t choice;
    union {
#	define VideoWindowDestinationAddress_softCopyImagePlane_chosen 1
	SoftCopyDataPlaneAddress softCopyImagePlane;
#	define VideoWindowDestinationAddress_nonStandardDestination_chosen 2
	NonStandardParameter nonStandardDestination;
    } u;
} VideoWindowDestinationAddress;

typedef struct VideoSourceIdentifier {
    ASN1choice_t choice;
    union {
#	define VideoSourceIdentifier_default_chosen 1
#	define h243SourceIdentifier_chosen 2
	struct VideoSourceIdentifier_h243SourceIdentifier_h243SourceIdentifier {
	    ASN1uint32_t length;
	    ASN1octet_t value[2];
	} h243SourceIdentifier;
#	define h245SourceIdentifier_chosen 3
	ASN1uint16_t h245SourceIdentifier;
#	define dSMCCConnBinder_chosen 4
	PVideoSourceIdentifier_dSMCCConnBinder dSMCCConnBinder;
#	define videoIdentifier_chosen 5
	struct VideoSourceIdentifier_videoIdentifier_videoIdentifier {
	    ASN1uint32_t length;
	    ASN1octet_t value[256];
	} videoIdentifier;
#	define nonStandardSourceIdentifier_chosen 6
	NonStandardParameter nonStandardSourceIdentifier;
    } u;
} VideoSourceIdentifier;

typedef struct VideoWindowDeletePDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle videoWindowHandle;
#   define VideoWindowDeletePDU_nonStandardParameters_present 0x80
    PVideoWindowDeletePDU_nonStandardParameters nonStandardParameters;
} VideoWindowDeletePDU;

typedef struct ViewState {
    ASN1choice_t choice;
    union {
#	define unselected_chosen 1
#	define selected_chosen 2
#	define ViewState_hidden_chosen 3
#	define nonStandardViewState_chosen 4
	NonStandardIdentifier nonStandardViewState;
    } u;
} ViewState;

typedef struct WorkspaceColor {
    ASN1choice_t choice;
    union {
#	define workspacePaletteIndex_chosen 1
	ASN1uint16_t workspacePaletteIndex;
#	define rgbTrueColor_chosen 2
	ColorRGB rgbTrueColor;
#	define transparent_chosen 3
    } u;
} WorkspaceColor;

typedef struct WorkspaceDeleteReason {
    ASN1choice_t choice;
    union {
#	define userInitiated_chosen 1
#	define insufficientStorage_chosen 2
#	define WorkspaceDeleteReason_nonStandardReason_chosen 3
	NonStandardParameter nonStandardReason;
    } u;
} WorkspaceDeleteReason;

typedef struct WorkspaceIdentifier {
    ASN1choice_t choice;
    union {
#	define activeWorkspace_chosen 1
	Handle activeWorkspace;
#	define archiveWorkspace_chosen 2
	WorkspaceIdentifier_archiveWorkspace archiveWorkspace;
    } u;
} WorkspaceIdentifier;

typedef struct WorkspacePoint {
    WorkspaceCoordinate xCoordinate;
    WorkspaceCoordinate yCoordinate;
} WorkspacePoint;

typedef struct WorkspaceRegion {
    WorkspacePoint upperLeft;
    WorkspacePoint lowerRight;
} WorkspaceRegion;

typedef struct WorkspaceSize {
    ASN1uint16_t width;
    ASN1uint16_t height;
} WorkspaceSize;

typedef struct WorkspaceViewState {
    ASN1choice_t choice;
    union {
#	define WorkspaceViewState_hidden_chosen 1
#	define background_chosen 2
#	define foreground_chosen 3
#	define focus_chosen 4
#	define nonStandardState_chosen 5
	NonStandardIdentifier nonStandardState;
    } u;
} WorkspaceViewState;

typedef struct ArchiveClosePDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle archiveHandle;
#   define ArchiveClosePDU_nonStandardParameters_present 0x80
    PArchiveClosePDU_nonStandardParameters nonStandardParameters;
} ArchiveClosePDU;

typedef struct ArchiveOpenPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle archiveHandle;
    ArchiveMode mode;
    ArchiveHeader header;
#   define maxEntries_present 0x80
    ASN1uint16_t maxEntries;
#   define ArchiveOpenPDU_nonStandardParameters_present 0x40
    PArchiveOpenPDU_nonStandardParameters nonStandardParameters;
} ArchiveOpenPDU;

typedef struct BitmapCheckpointPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle bitmapHandle;
    PBitmapCheckpointPDU_passedCheckpoints passedCheckpoints;
    ASN1uint16_t percentComplete;
#   define BitmapCheckpointPDU_nonStandardParameters_present 0x80
    PBitmapCheckpointPDU_nonStandardParameters nonStandardParameters;
} BitmapCheckpointPDU;

typedef struct BitmapCreateContinuePDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle bitmapHandle;
    BitmapData bitmapData;
    ASN1bool_t moreToFollow;
#   define BitmapCreateContinuePDU_nonStandardParameters_present 0x80
    PBitmapCreateContinuePDU_nonStandardParameters nonStandardParameters;
} BitmapCreateContinuePDU;

typedef struct BitmapDeletePDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle bitmapHandle;
#   define BitmapDeletePDU_nonStandardParameters_present 0x80
    PBitmapDeletePDU_nonStandardParameters nonStandardParameters;
} BitmapDeletePDU;

typedef struct BitmapEditPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle bitmapHandle;
#   define BitmapEditPDU_attributeEdits_present 0x80
    PBitmapEditPDU_attributeEdits attributeEdits;
#   define BitmapEditPDU_anchorPointEdit_present 0x40
    WorkspacePoint anchorPointEdit;
#   define bitmapRegionOfInterestEdit_present 0x20
    BitmapRegion bitmapRegionOfInterestEdit;
#   define BitmapEditPDU_scalingEdit_present 0x10
    PointDiff16 scalingEdit;
#   define BitmapEditPDU_nonStandardParameters_present 0x8
    PBitmapEditPDU_nonStandardParameters nonStandardParameters;
} BitmapEditPDU;

typedef struct ConductorPrivilegeGrantPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    MCSUserID destinationUserID;
    PConductorPrivilegeGrantPDU_privilegeList privilegeList;
#   define ConductorPrivilegeGrantPDU_nonStandardParameters_present 0x80
    PConductorPrivilegeGrantPDU_nonStandardParameters nonStandardParameters;
} ConductorPrivilegeGrantPDU;

typedef struct ConductorPrivilegeRequestPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PConductorPrivilegeRequestPDU_privilegeList privilegeList;
#   define ConductorPrivilegeRequestPDU_nonStandardParameters_present 0x80
    PConductorPrivilegeRequestPDU_nonStandardParameters nonStandardParameters;
} ConductorPrivilegeRequestPDU;

typedef struct DrawingDeletePDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle drawingHandle;
#   define DrawingDeletePDU_nonStandardParameters_present 0x80
    PDrawingDeletePDU_nonStandardParameters nonStandardParameters;
} DrawingDeletePDU;

typedef struct FontPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define FontPDU_nonStandardParameters_present 0x80
    PFontPDU_nonStandardParameters nonStandardParameters;
} FontPDU;

typedef struct RemoteEventPermissionGrantPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RemoteEventDestinationAddress destinationAddress;
    MCSUserID destinationUserID;
    PRemoteEventPermissionGrantPDU_remoteEventPermissionList remoteEventPermissionList;
#   define RemoteEventPermissionGrantPDU_nonStandardParameters_present 0x80
    PRemoteEventPermissionGrantPDU_nonStandardParameters nonStandardParameters;
} RemoteEventPermissionGrantPDU;

typedef struct RemoteEventPermissionRequestPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RemoteEventDestinationAddress destinationAddress;
    PRemoteEventPermissionRequestPDU_remoteEventPermissionList remoteEventPermissionList;
#   define RemoteEventPermissionRequestPDU_nonStandardParameters_present 0x80
    PRemoteEventPermissionRequestPDU_nonStandardParameters nonStandardParameters;
} RemoteEventPermissionRequestPDU;

typedef struct RemotePrintPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RemoteEventDestinationAddress destinationAddress;
#   define numberOfCopies_present 0x80
    ASN1uint32_t numberOfCopies;
#   define portrait_present 0x40
    ASN1bool_t portrait;
#   define regionOfInterest_present 0x20
    WorkspaceRegion regionOfInterest;
#   define RemotePrintPDU_nonStandardParameters_present 0x10
    PRemotePrintPDU_nonStandardParameters nonStandardParameters;
} RemotePrintPDU;

typedef struct SINonStandardPDU {
    NonStandardParameter nonStandardTransaction;
} SINonStandardPDU;

typedef struct TextCreatePDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define TextCreatePDU_nonStandardParameters_present 0x80
    PTextCreatePDU_nonStandardParameters nonStandardParameters;
} TextCreatePDU;

typedef struct TextDeletePDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define TextDeletePDU_nonStandardParameters_present 0x80
    PTextDeletePDU_nonStandardParameters nonStandardParameters;
} TextDeletePDU;

typedef struct TextEditPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define TextEditPDU_nonStandardParameters_present 0x80
    PTextEditPDU_nonStandardParameters nonStandardParameters;
} TextEditPDU;

typedef struct WorkspaceCreatePDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    WorkspaceIdentifier workspaceIdentifier;
    ASN1uint16_t appRosterInstance;
    ASN1bool_t synchronized;
    ASN1bool_t acceptKeyboardEvents;
    ASN1bool_t acceptPointingDeviceEvents;
#   define protectedPlaneAccessList_present 0x80
    PWorkspaceCreatePDU_protectedPlaneAccessList protectedPlaneAccessList;
    WorkspaceSize workspaceSize;
#   define workspaceAttributes_present 0x40
    PWorkspaceCreatePDU_workspaceAttributes workspaceAttributes;
    PWorkspaceCreatePDU_planeParameters planeParameters;
#   define viewParameters_present 0x20
    PWorkspaceCreatePDU_viewParameters viewParameters;
#   define WorkspaceCreatePDU_nonStandardParameters_present 0x10
    PWorkspaceCreatePDU_nonStandardParameters nonStandardParameters;
} WorkspaceCreatePDU;

typedef struct WorkspaceCreateAcknowledgePDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    WorkspaceIdentifier workspaceIdentifier;
#   define WorkspaceCreateAcknowledgePDU_nonStandardParameters_present 0x80
    PWorkspaceCreateAcknowledgePDU_nonStandardParameters nonStandardParameters;
} WorkspaceCreateAcknowledgePDU;

typedef struct WorkspaceDeletePDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    WorkspaceIdentifier workspaceIdentifier;
    WorkspaceDeleteReason reason;
#   define WorkspaceDeletePDU_nonStandardParameters_present 0x80
    PWorkspaceDeletePDU_nonStandardParameters nonStandardParameters;
} WorkspaceDeletePDU;

typedef struct WorkspaceEditPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    WorkspaceIdentifier workspaceIdentifier;
#   define WorkspaceEditPDU_attributeEdits_present 0x80
    PWorkspaceEditPDU_attributeEdits attributeEdits;
#   define planeEdits_present 0x40
    PWorkspaceEditPDU_planeEdits planeEdits;
#   define viewEdits_present 0x20
    PWorkspaceEditPDU_viewEdits viewEdits;
#   define WorkspaceEditPDU_nonStandardParameters_present 0x10
    PWorkspaceEditPDU_nonStandardParameters nonStandardParameters;
} WorkspaceEditPDU;

typedef struct WorkspaceReadyPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    WorkspaceIdentifier workspaceIdentifier;
#   define WorkspaceReadyPDU_nonStandardParameters_present 0x80
    PWorkspaceReadyPDU_nonStandardParameters nonStandardParameters;
} WorkspaceReadyPDU;

typedef struct WorkspaceRefreshStatusPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t refreshStatus;
#   define WorkspaceRefreshStatusPDU_nonStandardParameters_present 0x80
    PWorkspaceRefreshStatusPDU_nonStandardParameters nonStandardParameters;
} WorkspaceRefreshStatusPDU;

typedef struct WorkspaceEditPDU_viewEdits_Set_action {
    ASN1choice_t choice;
    union {
#	define createNewView_chosen 1
	PWorkspaceEditPDU_viewEdits_Set_action_createNewView createNewView;
#	define editView_chosen 2
	PWorkspaceEditPDU_viewEdits_Set_action_editView editView;
#	define deleteView_chosen 3
#	define nonStandardAction_chosen 4
	NonStandardParameter nonStandardAction;
    } u;
} WorkspaceEditPDU_viewEdits_Set_action;

typedef struct WorkspaceCreatePDU_planeParameters_Seq_usage {
    PWorkspaceCreatePDU_planeParameters_Seq_usage next;
    PlaneUsage value;
} WorkspaceCreatePDU_planeParameters_Seq_usage_Element;

typedef struct ColorPalette_colorLookUpTable_paletteRGB_palette {
    PColorPalette_colorLookUpTable_paletteRGB_palette next;
    ColorRGB value;
} ColorPalette_colorLookUpTable_paletteRGB_palette_Element;

typedef struct ColorPalette_colorLookUpTable_paletteCIELab_palette {
    PColorPalette_colorLookUpTable_paletteCIELab_palette next;
    ColorCIELab value;
} ColorPalette_colorLookUpTable_paletteCIELab_palette_Element;

typedef struct ColorPalette_colorLookUpTable_paletteYCbCr_palette {
    PColorPalette_colorLookUpTable_paletteYCbCr_palette next;
    ColorYCbCr value;
} ColorPalette_colorLookUpTable_paletteYCbCr_palette_Element;

typedef struct ColorAccuracyEnhancementRGB_generalRGBParameters_primaries {
    ColorCIExyChromaticity red;
    ColorCIExyChromaticity green;
    ColorCIExyChromaticity blue;
} ColorAccuracyEnhancementRGB_generalRGBParameters_primaries;

typedef struct ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_primaries {
    ColorCIExyChromaticity red;
    ColorCIExyChromaticity green;
    ColorCIExyChromaticity blue;
} ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_primaries;

typedef struct WorkspaceEditPDU_viewEdits_Set {
    Handle viewHandle;
    WorkspaceEditPDU_viewEdits_Set_action action;
} WorkspaceEditPDU_viewEdits_Set;

typedef struct WorkspaceRefreshStatusPDU_nonStandardParameters {
    PWorkspaceRefreshStatusPDU_nonStandardParameters next;
    NonStandardParameter value;
} WorkspaceRefreshStatusPDU_nonStandardParameters_Element;

typedef struct WorkspaceReadyPDU_nonStandardParameters {
    PWorkspaceReadyPDU_nonStandardParameters next;
    NonStandardParameter value;
} WorkspaceReadyPDU_nonStandardParameters_Element;

typedef struct WorkspacePlaneCopyPDU_nonStandardParameters {
    PWorkspacePlaneCopyPDU_nonStandardParameters next;
    NonStandardParameter value;
} WorkspacePlaneCopyPDU_nonStandardParameters_Element;

typedef struct WorkspaceEditPDU_nonStandardParameters {
    PWorkspaceEditPDU_nonStandardParameters next;
    NonStandardParameter value;
} WorkspaceEditPDU_nonStandardParameters_Element;

typedef struct WorkspaceEditPDU_viewEdits {
    PWorkspaceEditPDU_viewEdits next;
    WorkspaceEditPDU_viewEdits_Set value;
} WorkspaceEditPDU_viewEdits_Element;

typedef struct WorkspaceDeletePDU_nonStandardParameters {
    PWorkspaceDeletePDU_nonStandardParameters next;
    NonStandardParameter value;
} WorkspaceDeletePDU_nonStandardParameters_Element;

typedef struct WorkspaceCreateAcknowledgePDU_nonStandardParameters {
    PWorkspaceCreateAcknowledgePDU_nonStandardParameters next;
    NonStandardParameter value;
} WorkspaceCreateAcknowledgePDU_nonStandardParameters_Element;

typedef struct WorkspaceCreatePDU_nonStandardParameters {
    PWorkspaceCreatePDU_nonStandardParameters next;
    NonStandardParameter value;
} WorkspaceCreatePDU_nonStandardParameters_Element;

typedef struct TextEditPDU_nonStandardParameters {
    PTextEditPDU_nonStandardParameters next;
    NonStandardParameter value;
} TextEditPDU_nonStandardParameters_Element;

typedef struct TextDeletePDU_nonStandardParameters {
    PTextDeletePDU_nonStandardParameters next;
    NonStandardParameter value;
} TextDeletePDU_nonStandardParameters_Element;

typedef struct TextCreatePDU_nonStandardParameters {
    PTextCreatePDU_nonStandardParameters next;
    NonStandardParameter value;
} TextCreatePDU_nonStandardParameters_Element;

typedef struct RemotePrintPDU_nonStandardParameters {
    PRemotePrintPDU_nonStandardParameters next;
    NonStandardParameter value;
} RemotePrintPDU_nonStandardParameters_Element;

typedef struct RemotePointingDeviceEventPDU_nonStandardParameters {
    PRemotePointingDeviceEventPDU_nonStandardParameters next;
    NonStandardParameter value;
} RemotePointingDeviceEventPDU_nonStandardParameters_Element;

typedef struct RemoteKeyboardEventPDU_nonStandardParameters {
    PRemoteKeyboardEventPDU_nonStandardParameters next;
    NonStandardParameter value;
} RemoteKeyboardEventPDU_nonStandardParameters_Element;

typedef struct RemoteEventPermissionRequestPDU_nonStandardParameters {
    PRemoteEventPermissionRequestPDU_nonStandardParameters next;
    NonStandardParameter value;
} RemoteEventPermissionRequestPDU_nonStandardParameters_Element;

typedef struct RemoteEventPermissionRequestPDU_remoteEventPermissionList {
    PRemoteEventPermissionRequestPDU_remoteEventPermissionList next;
    RemoteEventPermission value;
} RemoteEventPermissionRequestPDU_remoteEventPermissionList_Element;

typedef struct RemoteEventPermissionGrantPDU_nonStandardParameters {
    PRemoteEventPermissionGrantPDU_nonStandardParameters next;
    NonStandardParameter value;
} RemoteEventPermissionGrantPDU_nonStandardParameters_Element;

typedef struct RemoteEventPermissionGrantPDU_remoteEventPermissionList {
    PRemoteEventPermissionGrantPDU_remoteEventPermissionList next;
    RemoteEventPermission value;
} RemoteEventPermissionGrantPDU_remoteEventPermissionList_Element;

typedef struct FontPDU_nonStandardParameters {
    PFontPDU_nonStandardParameters next;
    NonStandardParameter value;
} FontPDU_nonStandardParameters_Element;

typedef struct DrawingEditPDU_nonStandardParameters {
    PDrawingEditPDU_nonStandardParameters next;
    NonStandardParameter value;
} DrawingEditPDU_nonStandardParameters_Element;

typedef struct DrawingDeletePDU_nonStandardParameters {
    PDrawingDeletePDU_nonStandardParameters next;
    NonStandardParameter value;
} DrawingDeletePDU_nonStandardParameters_Element;

typedef struct DrawingCreatePDU_nonStandardParameters {
    PDrawingCreatePDU_nonStandardParameters next;
    NonStandardParameter value;
} DrawingCreatePDU_nonStandardParameters_Element;

typedef struct ConductorPrivilegeRequestPDU_nonStandardParameters {
    PConductorPrivilegeRequestPDU_nonStandardParameters next;
    NonStandardParameter value;
} ConductorPrivilegeRequestPDU_nonStandardParameters_Element;

typedef struct ConductorPrivilegeGrantPDU_nonStandardParameters {
    PConductorPrivilegeGrantPDU_nonStandardParameters next;
    NonStandardParameter value;
} ConductorPrivilegeGrantPDU_nonStandardParameters_Element;

typedef struct BitmapEditPDU_nonStandardParameters {
    PBitmapEditPDU_nonStandardParameters next;
    NonStandardParameter value;
} BitmapEditPDU_nonStandardParameters_Element;

typedef struct BitmapDeletePDU_nonStandardParameters {
    PBitmapDeletePDU_nonStandardParameters next;
    NonStandardParameter value;
} BitmapDeletePDU_nonStandardParameters_Element;

typedef struct BitmapCreateContinuePDU_nonStandardParameters {
    PBitmapCreateContinuePDU_nonStandardParameters next;
    NonStandardParameter value;
} BitmapCreateContinuePDU_nonStandardParameters_Element;

typedef struct BitmapCreatePDU_nonStandardParameters {
    PBitmapCreatePDU_nonStandardParameters next;
    NonStandardParameter value;
} BitmapCreatePDU_nonStandardParameters_Element;

typedef struct BitmapCheckpointPDU_nonStandardParameters {
    PBitmapCheckpointPDU_nonStandardParameters next;
    NonStandardParameter value;
} BitmapCheckpointPDU_nonStandardParameters_Element;

typedef struct BitmapAbortPDU_nonStandardParameters {
    PBitmapAbortPDU_nonStandardParameters next;
    NonStandardParameter value;
} BitmapAbortPDU_nonStandardParameters_Element;

typedef struct ArchiveOpenPDU_nonStandardParameters {
    PArchiveOpenPDU_nonStandardParameters next;
    NonStandardParameter value;
} ArchiveOpenPDU_nonStandardParameters_Element;

typedef struct ArchiveErrorPDU_nonStandardParameters {
    PArchiveErrorPDU_nonStandardParameters next;
    NonStandardParameter value;
} ArchiveErrorPDU_nonStandardParameters_Element;

typedef struct ArchiveClosePDU_nonStandardParameters {
    PArchiveClosePDU_nonStandardParameters next;
    NonStandardParameter value;
} ArchiveClosePDU_nonStandardParameters_Element;

typedef struct ArchiveAcknowledgePDU_nonStandardParameters {
    PArchiveAcknowledgePDU_nonStandardParameters next;
    NonStandardParameter value;
} ArchiveAcknowledgePDU_nonStandardParameters_Element;

typedef struct WorkspaceViewAttribute_viewRegion {
    ASN1choice_t choice;
    union {
#	define fullWorkspace_chosen 1
#	define partialWorkspace_chosen 2
	WorkspaceRegion partialWorkspace;
    } u;
} WorkspaceViewAttribute_viewRegion;

typedef struct VideoWindowEditPDU_nonStandardParameters {
    PVideoWindowEditPDU_nonStandardParameters next;
    NonStandardParameter value;
} VideoWindowEditPDU_nonStandardParameters_Element;

typedef struct VideoWindowDeletePDU_nonStandardParameters {
    PVideoWindowDeletePDU_nonStandardParameters next;
    NonStandardParameter value;
} VideoWindowDeletePDU_nonStandardParameters_Element;

typedef struct VideoWindowCreatePDU_nonStandardParameters {
    PVideoWindowCreatePDU_nonStandardParameters next;
    NonStandardParameter value;
} VideoWindowCreatePDU_nonStandardParameters_Element;

typedef struct VideoSourceIdentifier_dSMCCConnBinder {
    PVideoSourceIdentifier_dSMCCConnBinder next;
    DSMCCTap value;
} VideoSourceIdentifier_dSMCCConnBinder_Element;

typedef struct TransparencyMask_nonStandardParameters {
    PTransparencyMask_nonStandardParameters next;
    NonStandardParameter value;
} TransparencyMask_nonStandardParameters_Element;

typedef struct TransparencyMask_bitMask {
    ASN1choice_t choice;
    union {
#	define uncompressed_chosen 1
	ASN1octetstring_t uncompressed;
#	define jbigCompressed_chosen 2
	ASN1octetstring_t jbigCompressed;
#	define nonStandardFormat_chosen 3
	NonStandardParameter nonStandardFormat;
    } u;
} TransparencyMask_bitMask;

typedef struct PointListEdits_Seq {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t initialIndex;
    PointDiff16 initialPointEdit;
#   define subsequentPointEdits_present 0x80
    PointList subsequentPointEdits;
} PointListEdits_Seq;

typedef struct PointList_pointsDiff16 {
    PPointList_pointsDiff16 next;
    PointDiff16 value;
} PointList_pointsDiff16_Element;

typedef struct PointList_pointsDiff8 {
    PPointList_pointsDiff8 next;
    PointDiff8 value;
} PointList_pointsDiff8_Element;

typedef struct PointList_pointsDiff4 {
    PPointList_pointsDiff4 next;
    PointDiff4 value;
} PointList_pointsDiff4_Element;

typedef struct ColorAccuracyEnhancementYCbCr_generalYCbCrParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_gamma_present 0x80
    double gamma;
#   define ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_colorTemperature_present 0x40
    ASN1uint32_t colorTemperature;
#   define ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_primaries_present 0x20
    ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_primaries primaries;
} ColorAccuracyEnhancementYCbCr_generalYCbCrParameters;

typedef struct ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace {
    ASN1choice_t choice;
    union {
#	define cCIR709_chosen 1
#	define ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace_nonStandardRGBSpace_chosen 2
	NonStandardParameter nonStandardRGBSpace;
    } u;
} ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace;

typedef struct ColorAccuracyEnhancementRGB_generalRGBParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ColorAccuracyEnhancementRGB_generalRGBParameters_gamma_present 0x80
    double gamma;
#   define ColorAccuracyEnhancementRGB_generalRGBParameters_colorTemperature_present 0x40
    ASN1uint32_t colorTemperature;
#   define ColorAccuracyEnhancementRGB_generalRGBParameters_primaries_present 0x20
    ColorAccuracyEnhancementRGB_generalRGBParameters_primaries primaries;
} ColorAccuracyEnhancementRGB_generalRGBParameters;

typedef struct ColorAccuracyEnhancementRGB_predefinedRGBSpace {
    ASN1choice_t choice;
    union {
#	define ColorAccuracyEnhancementRGB_predefinedRGBSpace_nonStandardRGBSpace_chosen 1
	NonStandardParameter nonStandardRGBSpace;
    } u;
} ColorAccuracyEnhancementRGB_predefinedRGBSpace;

typedef struct ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace {
    ASN1choice_t choice;
    union {
#	define nonStandardGreyscaleSpace_chosen 1
	NonStandardParameter nonStandardGreyscaleSpace;
    } u;
} ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace;

typedef struct ColorAccuracyEnhancementCIELab_predefinedCIELabSpace {
    ASN1choice_t choice;
    union {
#	define nonStandardCIELabSpace_chosen 1
	NonStandardParameter nonStandardCIELabSpace;
    } u;
} ColorAccuracyEnhancementCIELab_predefinedCIELabSpace;

typedef struct ArchiveError {
    ASN1choice_t choice;
    union {
#	define entryNotFound_chosen 1
#	define entryExists_chosen 2
#	define ArchiveError_storageExceeded_chosen 3
#	define archiveNoLongerAvailable_chosen 4
#	define ArchiveError_unspecifiedError_chosen 5
#	define nonStandardError_chosen 6
	NonStandardIdentifier nonStandardError;
    } u;
} ArchiveError;

typedef struct ArchiveOpenResult {
    ASN1choice_t choice;
    union {
#	define archiveOpenSuccessful_chosen 1
#	define archiveNotFound_chosen 2
#	define archiveTimeIncorrect_chosen 3
	ArchiveHeader archiveTimeIncorrect;
#	define archiveExists_chosen 4
#	define archiveOpenForWriting_chosen 5
#	define ArchiveOpenResult_storageExceeded_chosen 6
#	define ArchiveOpenResult_unspecifiedError_chosen 7
#	define nonStandardResult_chosen 8
	NonStandardIdentifier nonStandardResult;
    } u;
} ArchiveOpenResult;

typedef struct BitmapAbortReason {
    ASN1choice_t choice;
    union {
#	define unspecified_chosen 1
#	define noResources_chosen 2
#	define outOfPaper_chosen 3
#	define BitmapAbortReason_nonStandardReason_chosen 4
	NonStandardParameter nonStandardReason;
    } u;
} BitmapAbortReason;

typedef struct BitmapDestinationAddress {
    ASN1choice_t choice;
    union {
#	define hardCopyDevice_chosen 1
#	define BitmapDestinationAddress_softCopyImagePlane_chosen 2
	SoftCopyDataPlaneAddress softCopyImagePlane;
#	define BitmapDestinationAddress_softCopyAnnotationPlane_chosen 3
	SoftCopyDataPlaneAddress softCopyAnnotationPlane;
#	define softCopyPointerPlane_chosen 4
	SoftCopyPointerPlaneAddress softCopyPointerPlane;
#	define BitmapDestinationAddress_nonStandardDestination_chosen 5
	NonStandardParameter nonStandardDestination;
    } u;
} BitmapDestinationAddress;

typedef struct ButtonEvent {
    ASN1choice_t choice;
    union {
#	define buttonUp_chosen 1
#	define buttonDown_chosen 2
#	define buttonDoubleClick_chosen 3
#	define buttonTripleClick_chosen 4
#	define buttonQuadClick_chosen 5
#	define nonStandardButtonEvent_chosen 6
	NonStandardIdentifier nonStandardButtonEvent;
    } u;
} ButtonEvent;

typedef struct ColorAccuracyEnhancementCIELab {
    ASN1choice_t choice;
    union {
#	define predefinedCIELabSpace_chosen 1
	ColorAccuracyEnhancementCIELab_predefinedCIELabSpace predefinedCIELabSpace;
#	define generalCIELabParameters_chosen 2
	ColorAccuracyEnhancementCIELab_generalCIELabParameters generalCIELabParameters;
    } u;
} ColorAccuracyEnhancementCIELab;

typedef struct ColorAccuracyEnhancementGreyscale {
    ASN1choice_t choice;
    union {
#	define predefinedGreyscaleSpace_chosen 1
	ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace predefinedGreyscaleSpace;
#	define generalGreyscaleParameters_chosen 2
	ColorAccuracyEnhancementGreyscale_generalGreyscaleParameters generalGreyscaleParameters;
    } u;
} ColorAccuracyEnhancementGreyscale;

typedef struct ColorAccuracyEnhancementRGB {
    ASN1choice_t choice;
    union {
#	define predefinedRGBSpace_chosen 1
	ColorAccuracyEnhancementRGB_predefinedRGBSpace predefinedRGBSpace;
#	define generalRGBParameters_chosen 2
	ColorAccuracyEnhancementRGB_generalRGBParameters generalRGBParameters;
    } u;
} ColorAccuracyEnhancementRGB;

typedef struct ColorAccuracyEnhancementYCbCr {
    ASN1choice_t choice;
    union {
#	define predefinedYCbCrSpace_chosen 1
	ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace predefinedYCbCrSpace;
#	define generalYCbCrParameters_chosen 2
	ColorAccuracyEnhancementYCbCr_generalYCbCrParameters generalYCbCrParameters;
    } u;
} ColorAccuracyEnhancementYCbCr;

typedef struct ColorResolutionModeSpecifier {
    ASN1choice_t choice;
    union {
#	define resolution4_4_4_chosen 1
#	define resolution_4_2_2_chosen 2
#	define resolution_4_2_0_chosen 3
#	define nonStandardResolutionMode_chosen 4
	NonStandardIdentifier nonStandardResolutionMode;
    } u;
} ColorResolutionModeSpecifier;

typedef struct ConductorPrivilege {
    ASN1choice_t choice;
    union {
#	define workspacePrivilege_chosen 1
#	define annotationPrivilege_chosen 2
#	define imagePrivilege_chosen 3
#	define pointingPrivilege_chosen 4
#	define remoteKeyEventPrivilege_chosen 5
#	define remotePointingEventPrivilege_chosen 6
#	define remotePrintingPrivilege_chosen 7
#	define archiveCreateWritePrivilege_chosen 8
#	define nonStandardPrivilege_chosen 9
	NonStandardIdentifier nonStandardPrivilege;
    } u;
} ConductorPrivilege;

typedef struct DrawingDestinationAddress {
    ASN1choice_t choice;
    union {
#	define DrawingDestinationAddress_softCopyAnnotationPlane_chosen 1
	SoftCopyDataPlaneAddress softCopyAnnotationPlane;
#	define DrawingDestinationAddress_nonStandardDestination_chosen 2
	NonStandardParameter nonStandardDestination;
    } u;
} DrawingDestinationAddress;

typedef struct DrawingType {
    ASN1choice_t choice;
    union {
#	define point_chosen 1
#	define openPolyLine_chosen 2
#	define closedPolyLine_chosen 3
#	define rectangle_chosen 4
#	define ellipse_chosen 5
#	define nonStandardDrawingType_chosen 6
	NonStandardIdentifier nonStandardDrawingType;
    } u;
} DrawingType;

typedef struct EditablePlaneCopyDescriptor {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PEditablePlaneCopyDescriptor_objectList objectList;
#   define destinationOffset_present 0x80
    PointDiff16 destinationOffset;
    ASN1bool_t planeClearFlag;
} EditablePlaneCopyDescriptor;

typedef struct KeyCode {
    ASN1choice_t choice;
    union {
#	define character_chosen 1
	ASN1char16string_t character;
#	define fkey_chosen 2
	ASN1uint16_t fkey;
#	define upArrow_chosen 3
#	define downArrow_chosen 4
#	define leftArrow_chosen 5
#	define rightArrow_chosen 6
#	define pageUp_chosen 7
#	define pageDown_chosen 8
#	define home_chosen 9
#	define end_chosen 10
#	define insert_chosen 11
#	define KeyCode_delete_chosen 12
#	define nonStandardKey_chosen 13
	NonStandardIdentifier nonStandardKey;
    } u;
} KeyCode;

typedef struct KeyModifier {
    ASN1choice_t choice;
    union {
#	define leftAlt_chosen 1
#	define rightAlt_chosen 2
#	define leftShift_chosen 3
#	define rightShift_chosen 4
#	define leftControl_chosen 5
#	define rightControl_chosen 6
#	define leftSpecial_chosen 7
#	define rightSpecial_chosen 8
#	define numberPad_chosen 9
#	define scrollLock_chosen 10
#	define nonStandardModifier_chosen 11
	NonStandardIdentifier nonStandardModifier;
    } u;
} KeyModifier;

typedef struct KeyPressState {
    ASN1choice_t choice;
    union {
#	define none_chosen 1
#	define keyPress_chosen 2
#	define keyDown_chosen 3
#	define keyUp_chosen 4
#	define nonStandardKeyPressState_chosen 5
	NonStandardIdentifier nonStandardKeyPressState;
    } u;
} KeyPressState;

typedef struct LineStyle {
    ASN1choice_t choice;
    union {
#	define solid_chosen 1
#	define dashed_chosen 2
#	define dotted_chosen 3
#	define dash_dot_chosen 4
#	define dash_dot_dot_chosen 5
#	define two_tone_chosen 6
#	define nonStandardStyle_chosen 7
	NonStandardIdentifier nonStandardStyle;
    } u;
} LineStyle;

typedef struct PermanentPlaneCopyDescriptor {
    WorkspaceRegion sourceRegion;
    WorkspaceRegion destinationRegion;
} PermanentPlaneCopyDescriptor;

typedef struct PlaneAttribute {
    ASN1choice_t choice;
    union {
#	define protection_chosen 1
	PlaneProtection protection;
#	define PlaneAttribute_nonStandardAttribute_chosen 2
	NonStandardParameter nonStandardAttribute;
    } u;
} PlaneAttribute;

typedef struct PointListEdits {
    ASN1uint32_t count;
    PointListEdits_Seq value[255];
} PointListEdits;

typedef struct TransparencyMask {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    TransparencyMask_bitMask bitMask;
#   define TransparencyMask_nonStandardParameters_present 0x80
    PTransparencyMask_nonStandardParameters nonStandardParameters;
} TransparencyMask;

typedef struct VideoWindowAttribute {
    ASN1choice_t choice;
    union {
#	define VideoWindowAttribute_transparencyMask_chosen 1
	TransparencyMask transparencyMask;
#	define VideoWindowAttribute_nonStandardAttribute_chosen 2
	NonStandardParameter nonStandardAttribute;
    } u;
} VideoWindowAttribute;

typedef struct VideoWindowCreatePDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle videoWindowHandle;
    VideoWindowDestinationAddress destinationAddress;
    VideoSourceIdentifier videoSourceIdentifier;
#   define VideoWindowCreatePDU_attributes_present 0x80
    PVideoWindowCreatePDU_attributes attributes;
#   define VideoWindowCreatePDU_anchorPoint_present 0x40
    WorkspacePoint anchorPoint;
    BitmapSize videoWindowSize;
#   define videoWindowRegionOfInterest_present 0x20
    BitmapRegion videoWindowRegionOfInterest;
    PixelAspectRatio pixelAspectRatio;
#   define VideoWindowCreatePDU_scaling_present 0x10
    PointDiff16 scaling;
#   define VideoWindowCreatePDU_nonStandardParameters_present 0x8
    PVideoWindowCreatePDU_nonStandardParameters nonStandardParameters;
} VideoWindowCreatePDU;

typedef struct VideoWindowEditPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle videoWindowHandle;
#   define videoSourceIdentifierEdit_present 0x80
    VideoSourceIdentifier videoSourceIdentifierEdit;
#   define VideoWindowEditPDU_attributeEdits_present 0x40
    PVideoWindowEditPDU_attributeEdits attributeEdits;
#   define VideoWindowEditPDU_anchorPointEdit_present 0x20
    WorkspacePoint anchorPointEdit;
    BitmapSize videoWindowSize;
#   define videoWindowRegionOfInterestEdit_present 0x10
    BitmapRegion videoWindowRegionOfInterestEdit;
#   define pixelAspectRatioEdit_present 0x8
    PixelAspectRatio pixelAspectRatioEdit;
#   define VideoWindowEditPDU_scalingEdit_present 0x4
    PointDiff16 scalingEdit;
#   define VideoWindowEditPDU_nonStandardParameters_present 0x2
    PVideoWindowEditPDU_nonStandardParameters nonStandardParameters;
} VideoWindowEditPDU;

typedef struct WorkspaceAttribute {
    ASN1choice_t choice;
    union {
#	define backgroundColor_chosen 1
	WorkspaceColor backgroundColor;
#	define preserve_chosen 2
	ASN1bool_t preserve;
#	define WorkspaceAttribute_nonStandardAttribute_chosen 3
	NonStandardParameter nonStandardAttribute;
    } u;
} WorkspaceAttribute;

typedef struct WorkspaceViewAttribute {
    ASN1choice_t choice;
    union {
#	define viewRegion_chosen 1
	WorkspaceViewAttribute_viewRegion viewRegion;
#	define WorkspaceViewAttribute_viewState_chosen 2
	WorkspaceViewState viewState;
#	define updatesEnabled_chosen 3
	ASN1bool_t updatesEnabled;
#	define sourceDisplayIndicator_chosen 4
	SourceDisplayIndicator sourceDisplayIndicator;
#	define WorkspaceViewAttribute_nonStandardAttribute_chosen 5
	NonStandardParameter nonStandardAttribute;
    } u;
} WorkspaceViewAttribute;

typedef struct ArchiveAcknowledgePDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle archiveHandle;
    ArchiveOpenResult result;
#   define ArchiveAcknowledgePDU_nonStandardParameters_present 0x80
    PArchiveAcknowledgePDU_nonStandardParameters nonStandardParameters;
} ArchiveAcknowledgePDU;

typedef struct ArchiveErrorPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle archiveHandle;
#   define entryName_present 0x80
    ArchiveEntryName entryName;
    ArchiveError errorCode;
#   define ArchiveErrorPDU_nonStandardParameters_present 0x40
    PArchiveErrorPDU_nonStandardParameters nonStandardParameters;
} ArchiveErrorPDU;

typedef struct BitmapAbortPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle bitmapHandle;
#   define userID_present 0x80
    MCSUserID userID;
#   define reason_present 0x40
    BitmapAbortReason reason;
#   define message_present 0x20
    ASN1char16string_t message;
#   define BitmapAbortPDU_nonStandardParameters_present 0x10
    PBitmapAbortPDU_nonStandardParameters nonStandardParameters;
} BitmapAbortPDU;

typedef struct DrawingCreatePDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define drawingHandle_present 0x80
    Handle drawingHandle;
    DrawingDestinationAddress destinationAddress;
    DrawingType drawingType;
#   define DrawingCreatePDU_attributes_present 0x40
    PDrawingCreatePDU_attributes attributes;
    WorkspacePoint anchorPoint;
#   define rotation_present 0x20
    RotationSpecifier rotation;
#   define DrawingCreatePDU_sampleRate_present 0x10
    ASN1uint16_t sampleRate;
    PointList pointList;
#   define DrawingCreatePDU_nonStandardParameters_present 0x8
    PDrawingCreatePDU_nonStandardParameters nonStandardParameters;
} DrawingCreatePDU;

typedef struct DrawingEditPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle drawingHandle;
#   define DrawingEditPDU_attributeEdits_present 0x80
    PDrawingEditPDU_attributeEdits attributeEdits;
#   define DrawingEditPDU_anchorPointEdit_present 0x40
    WorkspacePoint anchorPointEdit;
#   define rotationEdit_present 0x20
    RotationSpecifier rotationEdit;
#   define pointListEdits_present 0x10
    PointListEdits pointListEdits;
#   define DrawingEditPDU_nonStandardParameters_present 0x8
    PDrawingEditPDU_nonStandardParameters nonStandardParameters;
} DrawingEditPDU;

typedef struct RemoteKeyboardEventPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RemoteEventDestinationAddress destinationAddress;
#   define keyModifierStates_present 0x80
    PRemoteKeyboardEventPDU_keyModifierStates keyModifierStates;
    KeyPressState keyPressState;
    KeyCode keyCode;
#   define RemoteKeyboardEventPDU_nonStandardParameters_present 0x40
    PRemoteKeyboardEventPDU_nonStandardParameters nonStandardParameters;
} RemoteKeyboardEventPDU;

typedef struct RemotePointingDeviceEventPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RemoteEventDestinationAddress destinationAddress;
    ButtonEvent leftButtonState;
    ButtonEvent middleButtonState;
    ButtonEvent rightButtonState;
    WorkspacePoint initialPoint;
#   define RemotePointingDeviceEventPDU_sampleRate_present 0x80
    ASN1uint16_t sampleRate;
#   define pointList_present 0x40
    PointList pointList;
#   define RemotePointingDeviceEventPDU_nonStandardParameters_present 0x20
    PRemotePointingDeviceEventPDU_nonStandardParameters nonStandardParameters;
} RemotePointingDeviceEventPDU;

typedef struct WorkspaceEditPDU_viewEdits_Set_action_editView {
    PWorkspaceEditPDU_viewEdits_Set_action_editView next;
    WorkspaceViewAttribute value;
} WorkspaceEditPDU_viewEdits_Set_action_editView_Element;

typedef struct WorkspaceEditPDU_viewEdits_Set_action_createNewView {
    PWorkspaceEditPDU_viewEdits_Set_action_createNewView next;
    WorkspaceViewAttribute value;
} WorkspaceEditPDU_viewEdits_Set_action_createNewView_Element;

typedef struct WorkspaceEditPDU_planeEdits_Set_planeAttributes {
    PWorkspaceEditPDU_planeEdits_Set_planeAttributes next;
    PlaneAttribute value;
} WorkspaceEditPDU_planeEdits_Set_planeAttributes_Element;

typedef struct WorkspaceCreatePDU_viewParameters_Set_viewAttributes {
    PWorkspaceCreatePDU_viewParameters_Set_viewAttributes next;
    WorkspaceViewAttribute value;
} WorkspaceCreatePDU_viewParameters_Set_viewAttributes_Element;

typedef struct WorkspaceCreatePDU_planeParameters_Seq_planeAttributes {
    PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes next;
    PlaneAttribute value;
} WorkspaceCreatePDU_planeParameters_Seq_planeAttributes_Element;

typedef struct ColorPalette_colorLookUpTable_paletteYCbCr {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PColorPalette_colorLookUpTable_paletteYCbCr_palette palette;
#   define ColorPalette_colorLookUpTable_paletteYCbCr_enhancement_present 0x80
    ColorAccuracyEnhancementYCbCr enhancement;
} ColorPalette_colorLookUpTable_paletteYCbCr;

typedef struct ColorPalette_colorLookUpTable_paletteCIELab {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PColorPalette_colorLookUpTable_paletteCIELab_palette palette;
#   define ColorPalette_colorLookUpTable_paletteCIELab_enhancement_present 0x80
    ColorAccuracyEnhancementCIELab enhancement;
} ColorPalette_colorLookUpTable_paletteCIELab;

typedef struct ColorPalette_colorLookUpTable_paletteRGB {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PColorPalette_colorLookUpTable_paletteRGB_palette palette;
#   define ColorPalette_colorLookUpTable_paletteRGB_enhancement_present 0x80
    ColorAccuracyEnhancementRGB enhancement;
} ColorPalette_colorLookUpTable_paletteRGB;

typedef struct WorkspacePlaneCopyPDU_copyDescriptor {
    ASN1choice_t choice;
    union {
#	define permanentPlaneCopyDescriptor_chosen 1
	PermanentPlaneCopyDescriptor permanentPlaneCopyDescriptor;
#	define editablePlaneCopyDescriptor_chosen 2
	EditablePlaneCopyDescriptor editablePlaneCopyDescriptor;
    } u;
} WorkspacePlaneCopyPDU_copyDescriptor;

typedef struct WorkspaceEditPDU_attributeEdits {
    PWorkspaceEditPDU_attributeEdits next;
    WorkspaceAttribute value;
} WorkspaceEditPDU_attributeEdits_Element;

typedef struct WorkspaceCreatePDU_workspaceAttributes {
    PWorkspaceCreatePDU_workspaceAttributes next;
    WorkspaceAttribute value;
} WorkspaceCreatePDU_workspaceAttributes_Element;

typedef struct RemoteKeyboardEventPDU_keyModifierStates {
    PRemoteKeyboardEventPDU_keyModifierStates next;
    KeyModifier value;
} RemoteKeyboardEventPDU_keyModifierStates_Element;

typedef struct ConductorPrivilegeRequestPDU_privilegeList {
    PConductorPrivilegeRequestPDU_privilegeList next;
    ConductorPrivilege value;
} ConductorPrivilegeRequestPDU_privilegeList_Element;

typedef struct ConductorPrivilegeGrantPDU_privilegeList {
    PConductorPrivilegeGrantPDU_privilegeList next;
    ConductorPrivilege value;
} ConductorPrivilegeGrantPDU_privilegeList_Element;

typedef struct VideoWindowEditPDU_attributeEdits {
    PVideoWindowEditPDU_attributeEdits next;
    VideoWindowAttribute value;
} VideoWindowEditPDU_attributeEdits_Element;

typedef struct VideoWindowCreatePDU_attributes {
    PVideoWindowCreatePDU_attributes next;
    VideoWindowAttribute value;
} VideoWindowCreatePDU_attributes_Element;

typedef struct ColorSpaceSpecifier_cieLab {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ColorSpaceSpecifier_cieLab_accuracyEnhancement_present 0x80
    ColorAccuracyEnhancementCIELab accuracyEnhancement;
} ColorSpaceSpecifier_cieLab;

typedef struct ColorSpaceSpecifier_rgb {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ColorSpaceSpecifier_rgb_accuracyEnhancement_present 0x80
    ColorAccuracyEnhancementRGB accuracyEnhancement;
} ColorSpaceSpecifier_rgb;

typedef struct ColorSpaceSpecifier_yCbCr {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ColorSpaceSpecifier_yCbCr_accuracyEnhancement_present 0x80
    ColorAccuracyEnhancementYCbCr accuracyEnhancement;
} ColorSpaceSpecifier_yCbCr;

typedef struct ColorSpaceSpecifier_greyscale {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ColorSpaceSpecifier_greyscale_accuracyEnhancement_present 0x80
    ColorAccuracyEnhancementGreyscale accuracyEnhancement;
} ColorSpaceSpecifier_greyscale;

typedef struct ColorPalette_colorLookUpTable {
    ASN1choice_t choice;
    union {
#	define paletteRGB_chosen 1
	ColorPalette_colorLookUpTable_paletteRGB paletteRGB;
#	define paletteCIELab_chosen 2
	ColorPalette_colorLookUpTable_paletteCIELab paletteCIELab;
#	define paletteYCbCr_chosen 3
	ColorPalette_colorLookUpTable_paletteYCbCr paletteYCbCr;
#	define nonStandardPalette_chosen 4
	NonStandardParameter nonStandardPalette;
    } u;
} ColorPalette_colorLookUpTable;

typedef struct BitmapAttribute {
    ASN1choice_t choice;
    union {
#	define BitmapAttribute_viewState_chosen 1
	ViewState viewState;
#	define BitmapAttribute_zOrder_chosen 2
	ZOrder zOrder;
#	define BitmapAttribute_nonStandardAttribute_chosen 3
	NonStandardParameter nonStandardAttribute;
#	define BitmapAttribute_transparencyMask_chosen 4
	TransparencyMask transparencyMask;
    } u;
} BitmapAttribute;

typedef struct ColorPalette {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ColorPalette_colorLookUpTable colorLookUpTable;
#   define transparentEntry_present 0x80
    ASN1uint16_t transparentEntry;
} ColorPalette;

typedef struct ColorSpaceSpecifier {
    ASN1choice_t choice;
    union {
#	define greyscale_chosen 1
	ColorSpaceSpecifier_greyscale greyscale;
#	define yCbCr_chosen 2
	ColorSpaceSpecifier_yCbCr yCbCr;
#	define rgb_chosen 3
	ColorSpaceSpecifier_rgb rgb;
#	define cieLab_chosen 4
	ColorSpaceSpecifier_cieLab cieLab;
#	define nonStandardColorSpace_chosen 5
	NonStandardIdentifier nonStandardColorSpace;
    } u;
} ColorSpaceSpecifier;

typedef struct DrawingAttribute {
    ASN1choice_t choice;
    union {
#	define penColor_chosen 1
	WorkspaceColor penColor;
#	define fillColor_chosen 2
	WorkspaceColor fillColor;
#	define penThickness_chosen 3
	PenThickness penThickness;
#	define penNib_chosen 4
	PenNib penNib;
#	define lineStyle_chosen 5
	LineStyle lineStyle;
#	define highlight_chosen 6
	ASN1bool_t highlight;
#	define DrawingAttribute_viewState_chosen 7
	ViewState viewState;
#	define DrawingAttribute_zOrder_chosen 8
	ZOrder zOrder;
#	define DrawingAttribute_nonStandardAttribute_chosen 9
	NonStandardParameter nonStandardAttribute;
    } u;
} DrawingAttribute;

typedef struct WorkspacePlaneCopyPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    WorkspaceIdentifier sourceWorkspaceIdentifier;
    DataPlaneID sourcePlane;
    WorkspaceIdentifier destinationWorkspaceIdentifier;
    DataPlaneID destinationPlane;
    WorkspacePlaneCopyPDU_copyDescriptor copyDescriptor;
#   define WorkspacePlaneCopyPDU_nonStandardParameters_present 0x80
    PWorkspacePlaneCopyPDU_nonStandardParameters nonStandardParameters;
} WorkspacePlaneCopyPDU;

typedef struct BitmapHeaderUncompressed_colorMappingMode_paletteMap {
    ColorPalette colorPalette;
    ASN1uint16_t bitsPerPixel;
} BitmapHeaderUncompressed_colorMappingMode_paletteMap;

typedef struct BitmapHeaderUncompressed_colorMappingMode_directMap {
    ColorSpaceSpecifier colorSpace;
    ColorResolutionModeSpecifier resolutionMode;
} BitmapHeaderUncompressed_colorMappingMode_directMap;

typedef struct BitmapHeaderT82_colorMappingMode_paletteMap {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ColorPalette bitmapPalette;
#   define progressiveMode_present 0x80
    BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode progressiveMode;
} BitmapHeaderT82_colorMappingMode_paletteMap;

typedef struct DrawingEditPDU_attributeEdits {
    PDrawingEditPDU_attributeEdits next;
    DrawingAttribute value;
} DrawingEditPDU_attributeEdits_Element;

typedef struct DrawingCreatePDU_attributes {
    PDrawingCreatePDU_attributes next;
    DrawingAttribute value;
} DrawingCreatePDU_attributes_Element;

typedef struct BitmapEditPDU_attributeEdits {
    PBitmapEditPDU_attributeEdits next;
    BitmapAttribute value;
} BitmapEditPDU_attributeEdits_Element;

typedef struct BitmapCreatePDU_attributes {
    PBitmapCreatePDU_attributes next;
    BitmapAttribute value;
} BitmapCreatePDU_attributes_Element;

typedef struct BitmapHeaderT82_colorMappingMode {
    ASN1choice_t choice;
    union {
#	define BitmapHeaderT82_colorMappingMode_directMap_chosen 1
	ColorSpaceSpecifier directMap;
#	define BitmapHeaderT82_colorMappingMode_paletteMap_chosen 2
	BitmapHeaderT82_colorMappingMode_paletteMap paletteMap;
    } u;
} BitmapHeaderT82_colorMappingMode;

typedef struct BitmapHeaderUncompressed_colorMappingMode {
    ASN1choice_t choice;
    union {
#	define BitmapHeaderUncompressed_colorMappingMode_directMap_chosen 1
	BitmapHeaderUncompressed_colorMappingMode_directMap directMap;
#	define BitmapHeaderUncompressed_colorMappingMode_paletteMap_chosen 2
	BitmapHeaderUncompressed_colorMappingMode_paletteMap paletteMap;
    } u;
} BitmapHeaderUncompressed_colorMappingMode;

typedef struct BitmapHeaderUncompressed {
    BitmapHeaderUncompressed_colorMappingMode colorMappingMode;
} BitmapHeaderUncompressed;

typedef struct BitmapHeaderT81 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ColorSpaceSpecifier colorSpace;
    ColorResolutionModeSpecifier resolutionMode;
#   define colorPalette_present 0x80
    ColorPalette colorPalette;
} BitmapHeaderT81;

typedef struct BitmapHeaderT82 {
    BitmapHeaderT82_colorMappingMode colorMappingMode;
} BitmapHeaderT82;

typedef struct BitmapCreatePDU_bitmapFormatHeader {
    ASN1choice_t choice;
    union {
#	define bitmapHeaderUncompressed_chosen 1
	BitmapHeaderUncompressed bitmapHeaderUncompressed;
#	define bitmapHeaderT4_chosen 2
	BitmapHeaderT4 bitmapHeaderT4;
#	define bitmapHeaderT6_chosen 3
	BitmapHeaderT6 bitmapHeaderT6;
#	define bitmapHeaderT81_chosen 4
	BitmapHeaderT81 bitmapHeaderT81;
#	define bitmapHeaderT82_chosen 5
	BitmapHeaderT82 bitmapHeaderT82;
#	define bitmapHeaderNonStandard_chosen 6
	NonStandardParameter bitmapHeaderNonStandard;
    } u;
} BitmapCreatePDU_bitmapFormatHeader;

typedef struct BitmapCreatePDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle bitmapHandle;
    BitmapDestinationAddress destinationAddress;
#   define BitmapCreatePDU_attributes_present 0x80
    PBitmapCreatePDU_attributes attributes;
#   define BitmapCreatePDU_anchorPoint_present 0x40
    WorkspacePoint anchorPoint;
    BitmapSize bitmapSize;
#   define bitmapRegionOfInterest_present 0x20
    BitmapRegion bitmapRegionOfInterest;
    PixelAspectRatio pixelAspectRatio;
#   define BitmapCreatePDU_scaling_present 0x10
    PointDiff16 scaling;
#   define checkpoints_present 0x8
    PBitmapCreatePDU_checkpoints checkpoints;
    BitmapCreatePDU_bitmapFormatHeader bitmapFormatHeader;
#   define bitmapData_present 0x4
    BitmapData bitmapData;
    ASN1bool_t moreToFollow;
#   define BitmapCreatePDU_nonStandardParameters_present 0x2
    PBitmapCreatePDU_nonStandardParameters nonStandardParameters;
} BitmapCreatePDU;

typedef struct SIPDU {
    ASN1choice_t choice;
    union {
#	define archiveAcknowledgePDU_chosen 1
	ArchiveAcknowledgePDU archiveAcknowledgePDU;
#	define archiveClosePDU_chosen 2
	ArchiveClosePDU archiveClosePDU;
#	define archiveErrorPDU_chosen 3
	ArchiveErrorPDU archiveErrorPDU;
#	define archiveOpenPDU_chosen 4
	ArchiveOpenPDU archiveOpenPDU;
#	define bitmapAbortPDU_chosen 5
	BitmapAbortPDU bitmapAbortPDU;
#	define bitmapCheckpointPDU_chosen 6
	BitmapCheckpointPDU bitmapCheckpointPDU;
#	define bitmapCreatePDU_chosen 7
	BitmapCreatePDU bitmapCreatePDU;
#	define bitmapCreateContinuePDU_chosen 8
	BitmapCreateContinuePDU bitmapCreateContinuePDU;
#	define bitmapDeletePDU_chosen 9
	BitmapDeletePDU bitmapDeletePDU;
#	define bitmapEditPDU_chosen 10
	BitmapEditPDU bitmapEditPDU;
#	define conductorPrivilegeGrantPDU_chosen 11
	ConductorPrivilegeGrantPDU conductorPrivilegeGrantPDU;
#	define conductorPrivilegeRequestPDU_chosen 12
	ConductorPrivilegeRequestPDU conductorPrivilegeRequestPDU;
#	define drawingCreatePDU_chosen 13
	DrawingCreatePDU drawingCreatePDU;
#	define drawingDeletePDU_chosen 14
	DrawingDeletePDU drawingDeletePDU;
#	define drawingEditPDU_chosen 15
	DrawingEditPDU drawingEditPDU;
#	define remoteEventPermissionGrantPDU_chosen 16
	RemoteEventPermissionGrantPDU remoteEventPermissionGrantPDU;
#	define remoteEventPermissionRequestPDU_chosen 17
	RemoteEventPermissionRequestPDU remoteEventPermissionRequestPDU;
#	define remoteKeyboardEventPDU_chosen 18
	RemoteKeyboardEventPDU remoteKeyboardEventPDU;
#	define remotePointingDeviceEventPDU_chosen 19
	RemotePointingDeviceEventPDU remotePointingDeviceEventPDU;
#	define remotePrintPDU_chosen 20
	RemotePrintPDU remotePrintPDU;
#	define siNonStandardPDU_chosen 21
	SINonStandardPDU siNonStandardPDU;
#	define workspaceCreatePDU_chosen 22
	WorkspaceCreatePDU workspaceCreatePDU;
#	define workspaceCreateAcknowledgePDU_chosen 23
	WorkspaceCreateAcknowledgePDU workspaceCreateAcknowledgePDU;
#	define workspaceDeletePDU_chosen 24
	WorkspaceDeletePDU workspaceDeletePDU;
#	define workspaceEditPDU_chosen 25
	WorkspaceEditPDU workspaceEditPDU;
#	define workspacePlaneCopyPDU_chosen 26
	WorkspacePlaneCopyPDU workspacePlaneCopyPDU;
#	define workspaceReadyPDU_chosen 27
	WorkspaceReadyPDU workspaceReadyPDU;
#	define workspaceRefreshStatusPDU_chosen 28
	WorkspaceRefreshStatusPDU workspaceRefreshStatusPDU;
#	define fontPDU_chosen 29
	FontPDU fontPDU;
#	define textCreatePDU_chosen 30
	TextCreatePDU textCreatePDU;
#	define textDeletePDU_chosen 31
	TextDeletePDU textDeletePDU;
#	define textEditPDU_chosen 32
	TextEditPDU textEditPDU;
#	define videoWindowCreatePDU_chosen 33
	VideoWindowCreatePDU videoWindowCreatePDU;
#	define videoWindowDeleatePDU_chosen 34
	VideoWindowDeletePDU videoWindowDeleatePDU;
#	define videoWindowEditPDU_chosen 35
	VideoWindowEditPDU videoWindowEditPDU;
    } u;
} SIPDU;
#define SIPDU_PDU 0
#define SIZE_T126_Module_PDU_0 sizeof(SIPDU)

extern double one;

extern ASN1module_t T126_Module;
extern void ASN1CALL T126_Module_Startup(void);
extern void ASN1CALL T126_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */
    extern int ASN1CALL ASN1Enc_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes_ElmFn(ASN1encoding_t enc, PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes val);
    extern int ASN1CALL ASN1Dec_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes_ElmFn(ASN1decoding_t dec, PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes val);
	extern void ASN1CALL ASN1Free_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes_ElmFn(PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes val);
    extern int ASN1CALL ASN1Enc_WorkspaceEditPDU_planeEdits_ElmFn(ASN1encoding_t enc, PWorkspaceEditPDU_planeEdits val);
    extern int ASN1CALL ASN1Dec_WorkspaceEditPDU_planeEdits_ElmFn(ASN1decoding_t dec, PWorkspaceEditPDU_planeEdits val);
	extern void ASN1CALL ASN1Free_WorkspaceEditPDU_planeEdits_ElmFn(PWorkspaceEditPDU_planeEdits val);
    extern int ASN1CALL ASN1Enc_WorkspaceCreatePDU_viewParameters_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_viewParameters val);
    extern int ASN1CALL ASN1Dec_WorkspaceCreatePDU_viewParameters_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_viewParameters val);
	extern void ASN1CALL ASN1Free_WorkspaceCreatePDU_viewParameters_ElmFn(PWorkspaceCreatePDU_viewParameters val);
    extern int ASN1CALL ASN1Enc_WorkspaceCreatePDU_planeParameters_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_planeParameters val);
    extern int ASN1CALL ASN1Dec_WorkspaceCreatePDU_planeParameters_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_planeParameters val);
	extern void ASN1CALL ASN1Free_WorkspaceCreatePDU_planeParameters_ElmFn(PWorkspaceCreatePDU_planeParameters val);
    extern int ASN1CALL ASN1Enc_WorkspaceCreatePDU_protectedPlaneAccessList_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_protectedPlaneAccessList val);
    extern int ASN1CALL ASN1Dec_WorkspaceCreatePDU_protectedPlaneAccessList_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_protectedPlaneAccessList val);
	extern void ASN1CALL ASN1Free_WorkspaceCreatePDU_protectedPlaneAccessList_ElmFn(PWorkspaceCreatePDU_protectedPlaneAccessList val);
    extern int ASN1CALL ASN1Enc_BitmapCreatePDU_checkpoints_ElmFn(ASN1encoding_t enc, PBitmapCreatePDU_checkpoints val);
    extern int ASN1CALL ASN1Dec_BitmapCreatePDU_checkpoints_ElmFn(ASN1decoding_t dec, PBitmapCreatePDU_checkpoints val);
	extern void ASN1CALL ASN1Free_BitmapCreatePDU_checkpoints_ElmFn(PBitmapCreatePDU_checkpoints val);
    extern int ASN1CALL ASN1Enc_BitmapCheckpointPDU_passedCheckpoints_ElmFn(ASN1encoding_t enc, PBitmapCheckpointPDU_passedCheckpoints val);
    extern int ASN1CALL ASN1Dec_BitmapCheckpointPDU_passedCheckpoints_ElmFn(ASN1decoding_t dec, PBitmapCheckpointPDU_passedCheckpoints val);
	extern void ASN1CALL ASN1Free_BitmapCheckpointPDU_passedCheckpoints_ElmFn(PBitmapCheckpointPDU_passedCheckpoints val);
    extern int ASN1CALL ASN1Enc_EditablePlaneCopyDescriptor_objectList_ElmFn(ASN1encoding_t enc, PEditablePlaneCopyDescriptor_objectList val);
    extern int ASN1CALL ASN1Dec_EditablePlaneCopyDescriptor_objectList_ElmFn(ASN1decoding_t dec, PEditablePlaneCopyDescriptor_objectList val);
	extern void ASN1CALL ASN1Free_EditablePlaneCopyDescriptor_objectList_ElmFn(PEditablePlaneCopyDescriptor_objectList val);
    extern int ASN1CALL ASN1Enc_BitmapData_dataCheckpoint_ElmFn(ASN1encoding_t enc, PBitmapData_dataCheckpoint val);
    extern int ASN1CALL ASN1Dec_BitmapData_dataCheckpoint_ElmFn(ASN1decoding_t dec, PBitmapData_dataCheckpoint val);
	extern void ASN1CALL ASN1Free_BitmapData_dataCheckpoint_ElmFn(PBitmapData_dataCheckpoint val);
    extern int ASN1CALL ASN1Enc_ColorIndexTable_ElmFn(ASN1encoding_t enc, PColorIndexTable val);
    extern int ASN1CALL ASN1Dec_ColorIndexTable_ElmFn(ASN1decoding_t dec, PColorIndexTable val);
	extern void ASN1CALL ASN1Free_ColorIndexTable_ElmFn(PColorIndexTable val);
    extern int ASN1CALL ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq_usage_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_planeParameters_Seq_usage val);
    extern int ASN1CALL ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq_usage_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_planeParameters_Seq_usage val);
	extern void ASN1CALL ASN1Free_WorkspaceCreatePDU_planeParameters_Seq_usage_ElmFn(PWorkspaceCreatePDU_planeParameters_Seq_usage val);
    extern int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteRGB_palette_ElmFn(ASN1encoding_t enc, PColorPalette_colorLookUpTable_paletteRGB_palette val);
    extern int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteRGB_palette_ElmFn(ASN1decoding_t dec, PColorPalette_colorLookUpTable_paletteRGB_palette val);
	extern void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteRGB_palette_ElmFn(PColorPalette_colorLookUpTable_paletteRGB_palette val);
    extern int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteCIELab_palette_ElmFn(ASN1encoding_t enc, PColorPalette_colorLookUpTable_paletteCIELab_palette val);
    extern int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteCIELab_palette_ElmFn(ASN1decoding_t dec, PColorPalette_colorLookUpTable_paletteCIELab_palette val);
	extern void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteCIELab_palette_ElmFn(PColorPalette_colorLookUpTable_paletteCIELab_palette val);
    extern int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteYCbCr_palette_ElmFn(ASN1encoding_t enc, PColorPalette_colorLookUpTable_paletteYCbCr_palette val);
    extern int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteYCbCr_palette_ElmFn(ASN1decoding_t dec, PColorPalette_colorLookUpTable_paletteYCbCr_palette val);
	extern void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteYCbCr_palette_ElmFn(PColorPalette_colorLookUpTable_paletteYCbCr_palette val);
    extern int ASN1CALL ASN1Enc_WorkspaceRefreshStatusPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PWorkspaceRefreshStatusPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_WorkspaceRefreshStatusPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PWorkspaceRefreshStatusPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_WorkspaceRefreshStatusPDU_nonStandardParameters_ElmFn(PWorkspaceRefreshStatusPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_WorkspaceReadyPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PWorkspaceReadyPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_WorkspaceReadyPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PWorkspaceReadyPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_WorkspaceReadyPDU_nonStandardParameters_ElmFn(PWorkspaceReadyPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_WorkspacePlaneCopyPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PWorkspacePlaneCopyPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_WorkspacePlaneCopyPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PWorkspacePlaneCopyPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_WorkspacePlaneCopyPDU_nonStandardParameters_ElmFn(PWorkspacePlaneCopyPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_WorkspaceEditPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PWorkspaceEditPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_WorkspaceEditPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PWorkspaceEditPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_WorkspaceEditPDU_nonStandardParameters_ElmFn(PWorkspaceEditPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits_ElmFn(ASN1encoding_t enc, PWorkspaceEditPDU_viewEdits val);
    extern int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits_ElmFn(ASN1decoding_t dec, PWorkspaceEditPDU_viewEdits val);
	extern void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits_ElmFn(PWorkspaceEditPDU_viewEdits val);
    extern int ASN1CALL ASN1Enc_WorkspaceDeletePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PWorkspaceDeletePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_WorkspaceDeletePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PWorkspaceDeletePDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_WorkspaceDeletePDU_nonStandardParameters_ElmFn(PWorkspaceDeletePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_WorkspaceCreateAcknowledgePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PWorkspaceCreateAcknowledgePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_WorkspaceCreateAcknowledgePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PWorkspaceCreateAcknowledgePDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_WorkspaceCreateAcknowledgePDU_nonStandardParameters_ElmFn(PWorkspaceCreateAcknowledgePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_WorkspaceCreatePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_WorkspaceCreatePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_WorkspaceCreatePDU_nonStandardParameters_ElmFn(PWorkspaceCreatePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_TextEditPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PTextEditPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_TextEditPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PTextEditPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_TextEditPDU_nonStandardParameters_ElmFn(PTextEditPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_TextDeletePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PTextDeletePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_TextDeletePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PTextDeletePDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_TextDeletePDU_nonStandardParameters_ElmFn(PTextDeletePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_TextCreatePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PTextCreatePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_TextCreatePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PTextCreatePDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_TextCreatePDU_nonStandardParameters_ElmFn(PTextCreatePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_RemotePrintPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PRemotePrintPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_RemotePrintPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PRemotePrintPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_RemotePrintPDU_nonStandardParameters_ElmFn(PRemotePrintPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_RemotePointingDeviceEventPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PRemotePointingDeviceEventPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_RemotePointingDeviceEventPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PRemotePointingDeviceEventPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_RemotePointingDeviceEventPDU_nonStandardParameters_ElmFn(PRemotePointingDeviceEventPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_RemoteKeyboardEventPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PRemoteKeyboardEventPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_RemoteKeyboardEventPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PRemoteKeyboardEventPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_RemoteKeyboardEventPDU_nonStandardParameters_ElmFn(PRemoteKeyboardEventPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_RemoteEventPermissionRequestPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PRemoteEventPermissionRequestPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_RemoteEventPermissionRequestPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PRemoteEventPermissionRequestPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_RemoteEventPermissionRequestPDU_nonStandardParameters_ElmFn(PRemoteEventPermissionRequestPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_RemoteEventPermissionRequestPDU_remoteEventPermissionList_ElmFn(ASN1encoding_t enc, PRemoteEventPermissionRequestPDU_remoteEventPermissionList val);
    extern int ASN1CALL ASN1Dec_RemoteEventPermissionRequestPDU_remoteEventPermissionList_ElmFn(ASN1decoding_t dec, PRemoteEventPermissionRequestPDU_remoteEventPermissionList val);
	extern void ASN1CALL ASN1Free_RemoteEventPermissionRequestPDU_remoteEventPermissionList_ElmFn(PRemoteEventPermissionRequestPDU_remoteEventPermissionList val);
    extern int ASN1CALL ASN1Enc_RemoteEventPermissionGrantPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PRemoteEventPermissionGrantPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_RemoteEventPermissionGrantPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PRemoteEventPermissionGrantPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_RemoteEventPermissionGrantPDU_nonStandardParameters_ElmFn(PRemoteEventPermissionGrantPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_RemoteEventPermissionGrantPDU_remoteEventPermissionList_ElmFn(ASN1encoding_t enc, PRemoteEventPermissionGrantPDU_remoteEventPermissionList val);
    extern int ASN1CALL ASN1Dec_RemoteEventPermissionGrantPDU_remoteEventPermissionList_ElmFn(ASN1decoding_t dec, PRemoteEventPermissionGrantPDU_remoteEventPermissionList val);
	extern void ASN1CALL ASN1Free_RemoteEventPermissionGrantPDU_remoteEventPermissionList_ElmFn(PRemoteEventPermissionGrantPDU_remoteEventPermissionList val);
    extern int ASN1CALL ASN1Enc_FontPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PFontPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_FontPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PFontPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_FontPDU_nonStandardParameters_ElmFn(PFontPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_DrawingEditPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PDrawingEditPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_DrawingEditPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PDrawingEditPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_DrawingEditPDU_nonStandardParameters_ElmFn(PDrawingEditPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_DrawingDeletePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PDrawingDeletePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_DrawingDeletePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PDrawingDeletePDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_DrawingDeletePDU_nonStandardParameters_ElmFn(PDrawingDeletePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_DrawingCreatePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PDrawingCreatePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_DrawingCreatePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PDrawingCreatePDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_DrawingCreatePDU_nonStandardParameters_ElmFn(PDrawingCreatePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_ConductorPrivilegeRequestPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PConductorPrivilegeRequestPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_ConductorPrivilegeRequestPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PConductorPrivilegeRequestPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_ConductorPrivilegeRequestPDU_nonStandardParameters_ElmFn(PConductorPrivilegeRequestPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_ConductorPrivilegeGrantPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PConductorPrivilegeGrantPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_ConductorPrivilegeGrantPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PConductorPrivilegeGrantPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_ConductorPrivilegeGrantPDU_nonStandardParameters_ElmFn(PConductorPrivilegeGrantPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_BitmapEditPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PBitmapEditPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_BitmapEditPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PBitmapEditPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_BitmapEditPDU_nonStandardParameters_ElmFn(PBitmapEditPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_BitmapDeletePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PBitmapDeletePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_BitmapDeletePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PBitmapDeletePDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_BitmapDeletePDU_nonStandardParameters_ElmFn(PBitmapDeletePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_BitmapCreateContinuePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PBitmapCreateContinuePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_BitmapCreateContinuePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PBitmapCreateContinuePDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_BitmapCreateContinuePDU_nonStandardParameters_ElmFn(PBitmapCreateContinuePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_BitmapCreatePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PBitmapCreatePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_BitmapCreatePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PBitmapCreatePDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_BitmapCreatePDU_nonStandardParameters_ElmFn(PBitmapCreatePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_BitmapCheckpointPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PBitmapCheckpointPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_BitmapCheckpointPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PBitmapCheckpointPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_BitmapCheckpointPDU_nonStandardParameters_ElmFn(PBitmapCheckpointPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_BitmapAbortPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PBitmapAbortPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_BitmapAbortPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PBitmapAbortPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_BitmapAbortPDU_nonStandardParameters_ElmFn(PBitmapAbortPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_ArchiveOpenPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PArchiveOpenPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_ArchiveOpenPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PArchiveOpenPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_ArchiveOpenPDU_nonStandardParameters_ElmFn(PArchiveOpenPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_ArchiveErrorPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PArchiveErrorPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_ArchiveErrorPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PArchiveErrorPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_ArchiveErrorPDU_nonStandardParameters_ElmFn(PArchiveErrorPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_ArchiveClosePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PArchiveClosePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_ArchiveClosePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PArchiveClosePDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_ArchiveClosePDU_nonStandardParameters_ElmFn(PArchiveClosePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_ArchiveAcknowledgePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PArchiveAcknowledgePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_ArchiveAcknowledgePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PArchiveAcknowledgePDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_ArchiveAcknowledgePDU_nonStandardParameters_ElmFn(PArchiveAcknowledgePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_VideoWindowEditPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PVideoWindowEditPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_VideoWindowEditPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PVideoWindowEditPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_VideoWindowEditPDU_nonStandardParameters_ElmFn(PVideoWindowEditPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_VideoWindowDeletePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PVideoWindowDeletePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_VideoWindowDeletePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PVideoWindowDeletePDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_VideoWindowDeletePDU_nonStandardParameters_ElmFn(PVideoWindowDeletePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_VideoWindowCreatePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PVideoWindowCreatePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_VideoWindowCreatePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PVideoWindowCreatePDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_VideoWindowCreatePDU_nonStandardParameters_ElmFn(PVideoWindowCreatePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_VideoSourceIdentifier_dSMCCConnBinder_ElmFn(ASN1encoding_t enc, PVideoSourceIdentifier_dSMCCConnBinder val);
    extern int ASN1CALL ASN1Dec_VideoSourceIdentifier_dSMCCConnBinder_ElmFn(ASN1decoding_t dec, PVideoSourceIdentifier_dSMCCConnBinder val);
	extern void ASN1CALL ASN1Free_VideoSourceIdentifier_dSMCCConnBinder_ElmFn(PVideoSourceIdentifier_dSMCCConnBinder val);
    extern int ASN1CALL ASN1Enc_TransparencyMask_nonStandardParameters_ElmFn(ASN1encoding_t enc, PTransparencyMask_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_TransparencyMask_nonStandardParameters_ElmFn(ASN1decoding_t dec, PTransparencyMask_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_TransparencyMask_nonStandardParameters_ElmFn(PTransparencyMask_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_PointList_pointsDiff16_ElmFn(ASN1encoding_t enc, PPointList_pointsDiff16 val);
    extern int ASN1CALL ASN1Dec_PointList_pointsDiff16_ElmFn(ASN1decoding_t dec, PPointList_pointsDiff16 val);
	extern void ASN1CALL ASN1Free_PointList_pointsDiff16_ElmFn(PPointList_pointsDiff16 val);
    extern int ASN1CALL ASN1Enc_PointList_pointsDiff8_ElmFn(ASN1encoding_t enc, PPointList_pointsDiff8 val);
    extern int ASN1CALL ASN1Dec_PointList_pointsDiff8_ElmFn(ASN1decoding_t dec, PPointList_pointsDiff8 val);
	extern void ASN1CALL ASN1Free_PointList_pointsDiff8_ElmFn(PPointList_pointsDiff8 val);
    extern int ASN1CALL ASN1Enc_PointList_pointsDiff4_ElmFn(ASN1encoding_t enc, PPointList_pointsDiff4 val);
    extern int ASN1CALL ASN1Dec_PointList_pointsDiff4_ElmFn(ASN1decoding_t dec, PPointList_pointsDiff4 val);
	extern void ASN1CALL ASN1Free_PointList_pointsDiff4_ElmFn(PPointList_pointsDiff4 val);
    extern int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action_editView_ElmFn(ASN1encoding_t enc, PWorkspaceEditPDU_viewEdits_Set_action_editView val);
    extern int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action_editView_ElmFn(ASN1decoding_t dec, PWorkspaceEditPDU_viewEdits_Set_action_editView val);
	extern void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits_Set_action_editView_ElmFn(PWorkspaceEditPDU_viewEdits_Set_action_editView val);
    extern int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action_createNewView_ElmFn(ASN1encoding_t enc, PWorkspaceEditPDU_viewEdits_Set_action_createNewView val);
    extern int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action_createNewView_ElmFn(ASN1decoding_t dec, PWorkspaceEditPDU_viewEdits_Set_action_createNewView val);
	extern void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits_Set_action_createNewView_ElmFn(PWorkspaceEditPDU_viewEdits_Set_action_createNewView val);
    extern int ASN1CALL ASN1Enc_WorkspaceEditPDU_planeEdits_Set_planeAttributes_ElmFn(ASN1encoding_t enc, PWorkspaceEditPDU_planeEdits_Set_planeAttributes val);
    extern int ASN1CALL ASN1Dec_WorkspaceEditPDU_planeEdits_Set_planeAttributes_ElmFn(ASN1decoding_t dec, PWorkspaceEditPDU_planeEdits_Set_planeAttributes val);
	extern void ASN1CALL ASN1Free_WorkspaceEditPDU_planeEdits_Set_planeAttributes_ElmFn(PWorkspaceEditPDU_planeEdits_Set_planeAttributes val);
    extern int ASN1CALL ASN1Enc_WorkspaceCreatePDU_viewParameters_Set_viewAttributes_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_viewParameters_Set_viewAttributes val);
    extern int ASN1CALL ASN1Dec_WorkspaceCreatePDU_viewParameters_Set_viewAttributes_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_viewParameters_Set_viewAttributes val);
	extern void ASN1CALL ASN1Free_WorkspaceCreatePDU_viewParameters_Set_viewAttributes_ElmFn(PWorkspaceCreatePDU_viewParameters_Set_viewAttributes val);
    extern int ASN1CALL ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes val);
    extern int ASN1CALL ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes val);
	extern void ASN1CALL ASN1Free_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes_ElmFn(PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes val);
    extern int ASN1CALL ASN1Enc_WorkspaceEditPDU_attributeEdits_ElmFn(ASN1encoding_t enc, PWorkspaceEditPDU_attributeEdits val);
    extern int ASN1CALL ASN1Dec_WorkspaceEditPDU_attributeEdits_ElmFn(ASN1decoding_t dec, PWorkspaceEditPDU_attributeEdits val);
	extern void ASN1CALL ASN1Free_WorkspaceEditPDU_attributeEdits_ElmFn(PWorkspaceEditPDU_attributeEdits val);
    extern int ASN1CALL ASN1Enc_WorkspaceCreatePDU_workspaceAttributes_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_workspaceAttributes val);
    extern int ASN1CALL ASN1Dec_WorkspaceCreatePDU_workspaceAttributes_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_workspaceAttributes val);
	extern void ASN1CALL ASN1Free_WorkspaceCreatePDU_workspaceAttributes_ElmFn(PWorkspaceCreatePDU_workspaceAttributes val);
    extern int ASN1CALL ASN1Enc_RemoteKeyboardEventPDU_keyModifierStates_ElmFn(ASN1encoding_t enc, PRemoteKeyboardEventPDU_keyModifierStates val);
    extern int ASN1CALL ASN1Dec_RemoteKeyboardEventPDU_keyModifierStates_ElmFn(ASN1decoding_t dec, PRemoteKeyboardEventPDU_keyModifierStates val);
	extern void ASN1CALL ASN1Free_RemoteKeyboardEventPDU_keyModifierStates_ElmFn(PRemoteKeyboardEventPDU_keyModifierStates val);
    extern int ASN1CALL ASN1Enc_ConductorPrivilegeRequestPDU_privilegeList_ElmFn(ASN1encoding_t enc, PConductorPrivilegeRequestPDU_privilegeList val);
    extern int ASN1CALL ASN1Dec_ConductorPrivilegeRequestPDU_privilegeList_ElmFn(ASN1decoding_t dec, PConductorPrivilegeRequestPDU_privilegeList val);
	extern void ASN1CALL ASN1Free_ConductorPrivilegeRequestPDU_privilegeList_ElmFn(PConductorPrivilegeRequestPDU_privilegeList val);
    extern int ASN1CALL ASN1Enc_ConductorPrivilegeGrantPDU_privilegeList_ElmFn(ASN1encoding_t enc, PConductorPrivilegeGrantPDU_privilegeList val);
    extern int ASN1CALL ASN1Dec_ConductorPrivilegeGrantPDU_privilegeList_ElmFn(ASN1decoding_t dec, PConductorPrivilegeGrantPDU_privilegeList val);
	extern void ASN1CALL ASN1Free_ConductorPrivilegeGrantPDU_privilegeList_ElmFn(PConductorPrivilegeGrantPDU_privilegeList val);
    extern int ASN1CALL ASN1Enc_VideoWindowEditPDU_attributeEdits_ElmFn(ASN1encoding_t enc, PVideoWindowEditPDU_attributeEdits val);
    extern int ASN1CALL ASN1Dec_VideoWindowEditPDU_attributeEdits_ElmFn(ASN1decoding_t dec, PVideoWindowEditPDU_attributeEdits val);
	extern void ASN1CALL ASN1Free_VideoWindowEditPDU_attributeEdits_ElmFn(PVideoWindowEditPDU_attributeEdits val);
    extern int ASN1CALL ASN1Enc_VideoWindowCreatePDU_attributes_ElmFn(ASN1encoding_t enc, PVideoWindowCreatePDU_attributes val);
    extern int ASN1CALL ASN1Dec_VideoWindowCreatePDU_attributes_ElmFn(ASN1decoding_t dec, PVideoWindowCreatePDU_attributes val);
	extern void ASN1CALL ASN1Free_VideoWindowCreatePDU_attributes_ElmFn(PVideoWindowCreatePDU_attributes val);
    extern int ASN1CALL ASN1Enc_DrawingEditPDU_attributeEdits_ElmFn(ASN1encoding_t enc, PDrawingEditPDU_attributeEdits val);
    extern int ASN1CALL ASN1Dec_DrawingEditPDU_attributeEdits_ElmFn(ASN1decoding_t dec, PDrawingEditPDU_attributeEdits val);
	extern void ASN1CALL ASN1Free_DrawingEditPDU_attributeEdits_ElmFn(PDrawingEditPDU_attributeEdits val);
    extern int ASN1CALL ASN1Enc_DrawingCreatePDU_attributes_ElmFn(ASN1encoding_t enc, PDrawingCreatePDU_attributes val);
    extern int ASN1CALL ASN1Dec_DrawingCreatePDU_attributes_ElmFn(ASN1decoding_t dec, PDrawingCreatePDU_attributes val);
	extern void ASN1CALL ASN1Free_DrawingCreatePDU_attributes_ElmFn(PDrawingCreatePDU_attributes val);
    extern int ASN1CALL ASN1Enc_BitmapEditPDU_attributeEdits_ElmFn(ASN1encoding_t enc, PBitmapEditPDU_attributeEdits val);
    extern int ASN1CALL ASN1Dec_BitmapEditPDU_attributeEdits_ElmFn(ASN1decoding_t dec, PBitmapEditPDU_attributeEdits val);
	extern void ASN1CALL ASN1Free_BitmapEditPDU_attributeEdits_ElmFn(PBitmapEditPDU_attributeEdits val);
    extern int ASN1CALL ASN1Enc_BitmapCreatePDU_attributes_ElmFn(ASN1encoding_t enc, PBitmapCreatePDU_attributes val);
    extern int ASN1CALL ASN1Dec_BitmapCreatePDU_attributes_ElmFn(ASN1decoding_t dec, PBitmapCreatePDU_attributes val);
	extern void ASN1CALL ASN1Free_BitmapCreatePDU_attributes_ElmFn(PBitmapCreatePDU_attributes val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _T126_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\textobj.hpp ===
//
// TEXTOBJ.HPP
// Text object
//
// Copyright Microsoft 1998-
//
#ifndef __TEXTOBJ_HPP_
#define __TEXTOBJ_HPP_

#include <common.h>

#define NonStandardTextID "Text2\0"

void GetTextDestinationAddress(SINonStandardPDU *destinationAddress, PUINT workspaceHandle, PUINT planeID);

//
// Definitions for text objects
//
#define LAST_LINE -1
#define LAST_CHAR -2

#ifdef _DEBUG
#define DBG_UNINIT  -1
#endif // _DEBUG

//
// Definitions for debug stuff
//
typedef struct tagVARIABLE_STRING_HEADER
{
    ULONG	len;	// length of this structure + string length
	POINT	start;  // starting X(column) Y(line) inside the previous text
}VARIABLE_STRING_HEADER;

typedef struct tagVARIABLE_STRING
{
	VARIABLE_STRING_HEADER header;
    CHAR	string;
} VARIABLE_STRING;

typedef struct tagTEXTPDU_HEADER
{
	UINT nonStandardPDU;
	UINT textHandle;
	UINT workspaceHandle;
}TEXTPDU_HEADER;

typedef struct tagTEXTPDU_ATTRIB {
	DWORD attributesFlag;	// flag with the attributes that changed
	COLORREF textPenColor;
	COLORREF textFillColor;
	UINT textViewState;
	UINT textZOrder;
	POINT textAnchorPoint;
	LOGFONT textFont;
	UINT numberOfLines;
	VARIABLE_STRING textString;
} TEXTPDU_ATTRIB;


typedef struct tagMSTextPDU
{
	TEXTPDU_HEADER header;
	TEXTPDU_ATTRIB attrib;
}MSTextPDU;


typedef struct tagMSTextDeletePDU
{
	TEXTPDU_HEADER header;
}MSTextDeletePDU;


class TextObj : public T126Obj
{

  // Friend declaration for text editing
  friend class WbTextEditor;


public:

	TextObj (void);
	void TextEditObj (TEXTPDU_ATTRIB*  pEditPDU );

	~TextObj( void );

	void Draw(HDC hDC = NULL, BOOL bForcedDraw = FALSE, BOOL bPrinting = FALSE);
	void UnDraw(void);
	BOOL CheckReallyHit(LPCRECT pRectHit){return RectangleHit(FALSE, pRectHit);}
    void SetViewHandle(UINT viewHandle){};

	//
	// PDU stuff
	//
	void CreateTextPDU(ASN1octetstring_t*, UINT);
	void SetTextAttrib(TEXTPDU_ATTRIB * pattributes);
	void GetTextAttrib(TEXTPDU_ATTRIB * pattributes);


	//
	// Get/set pen Color
	//
    void SetPenColor(COLORREF rgb, BOOL isPresent);
    BOOL GetPenColor(COLORREF * pcr);
	BOOL GetPenColor(RGBTRIPLE* rgb);

	//
	// Get/set fill Color
	//
	BOOL HasFillColor(void){return m_bIsFillColorPresent;}
    void SetFillColor(COLORREF rgb, BOOL isPresent);
    BOOL GetFillColor(COLORREF * rgb);
	BOOL GetFillColor(RGBTRIPLE* rgb);

    //
    // Set the text of the object
    //
    void SetText(TCHAR * strText);
    void SetText(const StrArray& strTextArray);

    //
    // Get/Set the font for drawing the text
    //
    virtual void SetFont(HFONT hFont);
    virtual void SetFont(LOGFONT *pLogFont, BOOL bReCalc=TRUE );
    HFONT GetFont(void) {return m_hFont;};
	HFONT GetFontThumb(void){return m_hFontThumb;}


	//
	// Get the UI tool from a drawing pdu
	//
	void SetUIToolType(void);

	//
	// Mask 0x0000001F
	//
	void ChangedPenColor(void){m_dwChangedAttrib	|= 0x00000001;}
	void ChangedFillColor(void){m_dwChangedAttrib	|= 0x00000002;}
	void ChangedViewState(void){m_dwChangedAttrib	|= 0x00000004;}
	void ChangedZOrder(void){m_dwChangedAttrib		|= 0x00000008;}
	void ChangedAnchorPoint(void) { m_dwChangedAttrib |= 0x00000010;}
	void ChangedFont(void) { m_dwChangedAttrib |= 0x00000020;}
	void ChangedText(void) { m_dwChangedAttrib |= 0x00000040;}

	BOOL HasPenColorChanged(void){return (m_dwChangedAttrib & 0x00000001);}
	BOOL HasFillColorChanged(void){return (m_dwChangedAttrib & 0x00000002);}
	BOOL HasViewStateChanged(void){return (m_dwChangedAttrib & 0x00000004);}
	BOOL HasZOrderChanged(void){return (m_dwChangedAttrib & 0x00000008);}
	BOOL HasAnchorPointChanged(void) { return (m_dwChangedAttrib & 0x00000010);}
	BOOL HasFontChanged(void) { return m_dwChangedAttrib & 0x00000020;}
	BOOL HasTextChanged(void) { return m_dwChangedAttrib & 0x00000040;}
	
	DWORD GetPresentAttribs(void){return (m_dwChangedAttrib & 0x0000007F);}
	void ResetAttrib(void){m_dwChangedAttrib = 0;}
	void SetAllAttribs(void){m_dwChangedAttrib = 0x0000007F;}

	void ChangedPenThickness(void){};

	void CalculateBoundsRect(void);
	void CalculateRect(int iStartX, int iStartY, int iStopX, int iStopY, LPRECT lprcResult);
	ABC GetTextABC( LPCTSTR pText, int iStartX, int iStopX);
	void GetTextRectangle(int iStartY, int iStartX, int iStopX, LPRECT lprc);

	void SendTextPDU(UINT choice);
	void	OnObjectEdit(void);
	void	OnObjectDelete(void);
	void	SendNewObjectToT126Apps(void);
	void GetEncodedCreatePDU(ASN1_BUF *pBuf);

	TEXTMETRIC   m_textMetrics;

	//
    // Array for storing text
	//
    StrArray    strTextArray;
   	HFONT       m_hFont;

		
protected:

		DWORD		m_dwChangedAttrib;
		BOOL		m_bIsPenColorPresent;
		BOOL		m_bIsFillColorPresent;
		RGBTRIPLE	m_penColor;
		RGBTRIPLE	m_fillColor;

	    //
	    // Font details
	    //
	    HFONT       m_hFontThumb;
		BOOL		m_bFirstSetFontCall;
		LONG		m_nKerningOffset;


};

#endif // __TEXTOBJ_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\t126.c ===
/* Copyright (C) Microsoft Corporation, 1998-1999. All rights reserved. */
/* ASN.1 definitions for Whiteboard */

#include <windows.h>
#include "t126.h"

ASN1module_t T126_Module = NULL;

static int ASN1CALL ASN1Enc_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes(ASN1encoding_t enc, PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes *val);
static int ASN1CALL ASN1Enc_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode(ASN1encoding_t enc, BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementCIELab_generalCIELabParameters_gamut(ASN1encoding_t enc, ColorAccuracyEnhancementCIELab_generalCIELabParameters_gamut *val);
static int ASN1CALL ASN1Enc_EditablePlaneCopyDescriptor_objectList_Seq(ASN1encoding_t enc, EditablePlaneCopyDescriptor_objectList_Seq *val);
static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq(ASN1encoding_t enc, WorkspaceCreatePDU_planeParameters_Seq *val);
static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_viewParameters_Set(ASN1encoding_t enc, WorkspaceCreatePDU_viewParameters_Set *val);
static int ASN1CALL ASN1Enc_WorkspaceEditPDU_planeEdits_Set(ASN1encoding_t enc, WorkspaceEditPDU_planeEdits_Set *val);
static int ASN1CALL ASN1Enc_WorkspaceEditPDU_planeEdits(ASN1encoding_t enc, PWorkspaceEditPDU_planeEdits *val);
static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_viewParameters(ASN1encoding_t enc, PWorkspaceCreatePDU_viewParameters *val);
static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_planeParameters(ASN1encoding_t enc, PWorkspaceCreatePDU_planeParameters *val);
static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_protectedPlaneAccessList(ASN1encoding_t enc, PWorkspaceCreatePDU_protectedPlaneAccessList *val);
static int ASN1CALL ASN1Enc_BitmapCreatePDU_checkpoints(ASN1encoding_t enc, PBitmapCreatePDU_checkpoints *val);
static int ASN1CALL ASN1Enc_BitmapCheckpointPDU_passedCheckpoints(ASN1encoding_t enc, PBitmapCheckpointPDU_passedCheckpoints *val);
static int ASN1CALL ASN1Enc_WorkspaceIdentifier_archiveWorkspace(ASN1encoding_t enc, WorkspaceIdentifier_archiveWorkspace *val);
static int ASN1CALL ASN1Enc_PixelAspectRatio_general(ASN1encoding_t enc, PixelAspectRatio_general *val);
static int ASN1CALL ASN1Enc_EditablePlaneCopyDescriptor_objectList(ASN1encoding_t enc, PEditablePlaneCopyDescriptor_objectList *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementGreyscale_generalGreyscaleParameters(ASN1encoding_t enc, ColorAccuracyEnhancementGreyscale_generalGreyscaleParameters *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementCIELab_generalCIELabParameters(ASN1encoding_t enc, ColorAccuracyEnhancementCIELab_generalCIELabParameters *val);
static int ASN1CALL ASN1Enc_BitmapRegion_lowerRight(ASN1encoding_t enc, BitmapRegion_lowerRight *val);
static int ASN1CALL ASN1Enc_BitmapRegion_upperLeft(ASN1encoding_t enc, BitmapRegion_upperLeft *val);
static int ASN1CALL ASN1Enc_BitmapData_dataCheckpoint(ASN1encoding_t enc, PBitmapData_dataCheckpoint *val);
#define ASN1Enc_ArchiveHeader(x,y)      0
#define ASN1Enc_ArchiveMode(x,y)      0
static int ASN1CALL ASN1Enc_BitmapData(ASN1encoding_t enc, BitmapData *val);
static int ASN1CALL ASN1Enc_BitmapHeaderT4(ASN1encoding_t enc, BitmapHeaderT4 *val);
static int ASN1CALL ASN1Enc_BitmapHeaderT6(ASN1encoding_t enc, BitmapHeaderT6 *val);
static int ASN1CALL ASN1Enc_BitmapRegion(ASN1encoding_t enc, BitmapRegion *val);
static int ASN1CALL ASN1Enc_BitmapSize(ASN1encoding_t enc, BitmapSize *val);
static int ASN1CALL ASN1Enc_ColorCIELab(ASN1encoding_t enc, ColorCIELab *val);
static int ASN1CALL ASN1Enc_ColorCIExyChromaticity(ASN1encoding_t enc, ColorCIExyChromaticity *val);
static int ASN1CALL ASN1Enc_ColorIndexTable(ASN1encoding_t enc, PColorIndexTable *val);
static int ASN1CALL ASN1Enc_ColorRGB(ASN1encoding_t enc, ColorRGB *val);
static int ASN1CALL ASN1Enc_ColorYCbCr(ASN1encoding_t enc, ColorYCbCr *val);
static int ASN1CALL ASN1Enc_DSMCCTap(ASN1encoding_t enc, DSMCCTap *val);
static int ASN1CALL ASN1Enc_NonStandardIdentifier(ASN1encoding_t enc, NonStandardIdentifier *val);
static int ASN1CALL ASN1Enc_NonStandardParameter(ASN1encoding_t enc, NonStandardParameter *val);
static int ASN1CALL ASN1Enc_PenNib(ASN1encoding_t enc, PenNib *val);
static int ASN1CALL ASN1Enc_PixelAspectRatio(ASN1encoding_t enc, PixelAspectRatio *val);
static int ASN1CALL ASN1Enc_PlaneProtection(ASN1encoding_t enc, PlaneProtection *val);
static int ASN1CALL ASN1Enc_PlaneUsage(ASN1encoding_t enc, PlaneUsage *val);
static int ASN1CALL ASN1Enc_PointList(ASN1encoding_t enc, PointList *val);
static int ASN1CALL ASN1Enc_PointDiff4(ASN1encoding_t enc, PointDiff4 *val);
static int ASN1CALL ASN1Enc_PointDiff8(ASN1encoding_t enc, PointDiff8 *val);
static int ASN1CALL ASN1Enc_PointDiff16(ASN1encoding_t enc, PointDiff16 *val);
static int ASN1CALL ASN1Enc_RemoteEventDestinationAddress(ASN1encoding_t enc, RemoteEventDestinationAddress *val);
static int ASN1CALL ASN1Enc_RemoteEventPermission(ASN1encoding_t enc, RemoteEventPermission *val);
static int ASN1CALL ASN1Enc_RotationSpecifier(ASN1encoding_t enc, RotationSpecifier *val);
static int ASN1CALL ASN1Enc_SoftCopyDataPlaneAddress(ASN1encoding_t enc, SoftCopyDataPlaneAddress *val);
static int ASN1CALL ASN1Enc_SoftCopyPointerPlaneAddress(ASN1encoding_t enc, SoftCopyPointerPlaneAddress *val);
static int ASN1CALL ASN1Enc_SourceDisplayIndicator(ASN1encoding_t enc, SourceDisplayIndicator *val);
#define ASN1Enc_VideoWindowDestinationAddress(x,y)      0
#define ASN1Enc_VideoSourceIdentifier(x,y)      0
#define ASN1Enc_VideoWindowDeletePDU(x,y)      0
static int ASN1CALL ASN1Enc_ViewState(ASN1encoding_t enc, ViewState *val);
static int ASN1CALL ASN1Enc_WorkspaceColor(ASN1encoding_t enc, WorkspaceColor *val);
static int ASN1CALL ASN1Enc_WorkspaceDeleteReason(ASN1encoding_t enc, WorkspaceDeleteReason *val);
static int ASN1CALL ASN1Enc_WorkspaceIdentifier(ASN1encoding_t enc, WorkspaceIdentifier *val);
static int ASN1CALL ASN1Enc_WorkspacePoint(ASN1encoding_t enc, WorkspacePoint *val);
static int ASN1CALL ASN1Enc_WorkspaceRegion(ASN1encoding_t enc, WorkspaceRegion *val);
static int ASN1CALL ASN1Enc_WorkspaceSize(ASN1encoding_t enc, WorkspaceSize *val);
static int ASN1CALL ASN1Enc_WorkspaceViewState(ASN1encoding_t enc, WorkspaceViewState *val);
#define ASN1Enc_ArchiveClosePDU(x,y)      0
#define ASN1Enc_ArchiveOpenPDU(x,y)      0
static int ASN1CALL ASN1Enc_BitmapCheckpointPDU(ASN1encoding_t enc, BitmapCheckpointPDU *val);
static int ASN1CALL ASN1Enc_BitmapCreateContinuePDU(ASN1encoding_t enc, BitmapCreateContinuePDU *val);
static int ASN1CALL ASN1Enc_BitmapDeletePDU(ASN1encoding_t enc, BitmapDeletePDU *val);
static int ASN1CALL ASN1Enc_BitmapEditPDU(ASN1encoding_t enc, BitmapEditPDU *val);
static int ASN1CALL ASN1Enc_ConductorPrivilegeGrantPDU(ASN1encoding_t enc, ConductorPrivilegeGrantPDU *val);
static int ASN1CALL ASN1Enc_ConductorPrivilegeRequestPDU(ASN1encoding_t enc, ConductorPrivilegeRequestPDU *val);
static int ASN1CALL ASN1Enc_DrawingDeletePDU(ASN1encoding_t enc, DrawingDeletePDU *val);
static int ASN1CALL ASN1Enc_FontPDU(ASN1encoding_t enc, FontPDU *val);
static int ASN1CALL ASN1Enc_RemoteEventPermissionGrantPDU(ASN1encoding_t enc, RemoteEventPermissionGrantPDU *val);
static int ASN1CALL ASN1Enc_RemoteEventPermissionRequestPDU(ASN1encoding_t enc, RemoteEventPermissionRequestPDU *val);
static int ASN1CALL ASN1Enc_RemotePrintPDU(ASN1encoding_t enc, RemotePrintPDU *val);
static int ASN1CALL ASN1Enc_SINonStandardPDU(ASN1encoding_t enc, SINonStandardPDU *val);
#define ASN1Enc_TextCreatePDU(x,y)      0
#define ASN1Enc_TextDeletePDU(x,y)      0
#define ASN1Enc_TextEditPDU(x,y)      0
static int ASN1CALL ASN1Enc_WorkspaceCreatePDU(ASN1encoding_t enc, WorkspaceCreatePDU *val);
static int ASN1CALL ASN1Enc_WorkspaceCreateAcknowledgePDU(ASN1encoding_t enc, WorkspaceCreateAcknowledgePDU *val);
static int ASN1CALL ASN1Enc_WorkspaceDeletePDU(ASN1encoding_t enc, WorkspaceDeletePDU *val);
static int ASN1CALL ASN1Enc_WorkspaceEditPDU(ASN1encoding_t enc, WorkspaceEditPDU *val);
static int ASN1CALL ASN1Enc_WorkspaceReadyPDU(ASN1encoding_t enc, WorkspaceReadyPDU *val);
static int ASN1CALL ASN1Enc_WorkspaceRefreshStatusPDU(ASN1encoding_t enc, WorkspaceRefreshStatusPDU *val);
static int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action(ASN1encoding_t enc, WorkspaceEditPDU_viewEdits_Set_action *val);
static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq_usage(ASN1encoding_t enc, PWorkspaceCreatePDU_planeParameters_Seq_usage *val);
static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteRGB_palette(ASN1encoding_t enc, PColorPalette_colorLookUpTable_paletteRGB_palette *val);
static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteCIELab_palette(ASN1encoding_t enc, PColorPalette_colorLookUpTable_paletteCIELab_palette *val);
static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteYCbCr_palette(ASN1encoding_t enc, PColorPalette_colorLookUpTable_paletteYCbCr_palette *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementRGB_generalRGBParameters_primaries(ASN1encoding_t enc, ColorAccuracyEnhancementRGB_generalRGBParameters_primaries *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_primaries(ASN1encoding_t enc, ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_primaries *val);
static int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits_Set(ASN1encoding_t enc, WorkspaceEditPDU_viewEdits_Set *val);
static int ASN1CALL ASN1Enc_WorkspaceRefreshStatusPDU_nonStandardParameters(ASN1encoding_t enc, PWorkspaceRefreshStatusPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_WorkspaceReadyPDU_nonStandardParameters(ASN1encoding_t enc, PWorkspaceReadyPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_WorkspacePlaneCopyPDU_nonStandardParameters(ASN1encoding_t enc, PWorkspacePlaneCopyPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_WorkspaceEditPDU_nonStandardParameters(ASN1encoding_t enc, PWorkspaceEditPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits(ASN1encoding_t enc, PWorkspaceEditPDU_viewEdits *val);
static int ASN1CALL ASN1Enc_WorkspaceDeletePDU_nonStandardParameters(ASN1encoding_t enc, PWorkspaceDeletePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_WorkspaceCreateAcknowledgePDU_nonStandardParameters(ASN1encoding_t enc, PWorkspaceCreateAcknowledgePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_nonStandardParameters(ASN1encoding_t enc, PWorkspaceCreatePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_TextEditPDU_nonStandardParameters(ASN1encoding_t enc, PTextEditPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_TextDeletePDU_nonStandardParameters(ASN1encoding_t enc, PTextDeletePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_TextCreatePDU_nonStandardParameters(ASN1encoding_t enc, PTextCreatePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_RemotePrintPDU_nonStandardParameters(ASN1encoding_t enc, PRemotePrintPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_RemotePointingDeviceEventPDU_nonStandardParameters(ASN1encoding_t enc, PRemotePointingDeviceEventPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_RemoteKeyboardEventPDU_nonStandardParameters(ASN1encoding_t enc, PRemoteKeyboardEventPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_RemoteEventPermissionRequestPDU_nonStandardParameters(ASN1encoding_t enc, PRemoteEventPermissionRequestPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_RemoteEventPermissionRequestPDU_remoteEventPermissionList(ASN1encoding_t enc, PRemoteEventPermissionRequestPDU_remoteEventPermissionList *val);
static int ASN1CALL ASN1Enc_RemoteEventPermissionGrantPDU_nonStandardParameters(ASN1encoding_t enc, PRemoteEventPermissionGrantPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_RemoteEventPermissionGrantPDU_remoteEventPermissionList(ASN1encoding_t enc, PRemoteEventPermissionGrantPDU_remoteEventPermissionList *val);
static int ASN1CALL ASN1Enc_FontPDU_nonStandardParameters(ASN1encoding_t enc, PFontPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_DrawingEditPDU_nonStandardParameters(ASN1encoding_t enc, PDrawingEditPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_DrawingDeletePDU_nonStandardParameters(ASN1encoding_t enc, PDrawingDeletePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_DrawingCreatePDU_nonStandardParameters(ASN1encoding_t enc, PDrawingCreatePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_ConductorPrivilegeRequestPDU_nonStandardParameters(ASN1encoding_t enc, PConductorPrivilegeRequestPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_ConductorPrivilegeGrantPDU_nonStandardParameters(ASN1encoding_t enc, PConductorPrivilegeGrantPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_BitmapEditPDU_nonStandardParameters(ASN1encoding_t enc, PBitmapEditPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_BitmapDeletePDU_nonStandardParameters(ASN1encoding_t enc, PBitmapDeletePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_BitmapCreateContinuePDU_nonStandardParameters(ASN1encoding_t enc, PBitmapCreateContinuePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_BitmapCreatePDU_nonStandardParameters(ASN1encoding_t enc, PBitmapCreatePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_BitmapCheckpointPDU_nonStandardParameters(ASN1encoding_t enc, PBitmapCheckpointPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_BitmapAbortPDU_nonStandardParameters(ASN1encoding_t enc, PBitmapAbortPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_ArchiveOpenPDU_nonStandardParameters(ASN1encoding_t enc, PArchiveOpenPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_ArchiveErrorPDU_nonStandardParameters(ASN1encoding_t enc, PArchiveErrorPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_ArchiveClosePDU_nonStandardParameters(ASN1encoding_t enc, PArchiveClosePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_ArchiveAcknowledgePDU_nonStandardParameters(ASN1encoding_t enc, PArchiveAcknowledgePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_WorkspaceViewAttribute_viewRegion(ASN1encoding_t enc, WorkspaceViewAttribute_viewRegion *val);
static int ASN1CALL ASN1Enc_VideoWindowEditPDU_nonStandardParameters(ASN1encoding_t enc, PVideoWindowEditPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_VideoWindowDeletePDU_nonStandardParameters(ASN1encoding_t enc, PVideoWindowDeletePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_VideoWindowCreatePDU_nonStandardParameters(ASN1encoding_t enc, PVideoWindowCreatePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_VideoSourceIdentifier_dSMCCConnBinder(ASN1encoding_t enc, PVideoSourceIdentifier_dSMCCConnBinder *val);
static int ASN1CALL ASN1Enc_TransparencyMask_nonStandardParameters(ASN1encoding_t enc, PTransparencyMask_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_TransparencyMask_bitMask(ASN1encoding_t enc, TransparencyMask_bitMask *val);
static int ASN1CALL ASN1Enc_PointListEdits_Seq(ASN1encoding_t enc, PointListEdits_Seq *val);
static int ASN1CALL ASN1Enc_PointList_pointsDiff16(ASN1encoding_t enc, PPointList_pointsDiff16 *val);
static int ASN1CALL ASN1Enc_PointList_pointsDiff8(ASN1encoding_t enc, PPointList_pointsDiff8 *val);
static int ASN1CALL ASN1Enc_PointList_pointsDiff4(ASN1encoding_t enc, PPointList_pointsDiff4 *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementYCbCr_generalYCbCrParameters(ASN1encoding_t enc, ColorAccuracyEnhancementYCbCr_generalYCbCrParameters *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace(ASN1encoding_t enc, ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementRGB_generalRGBParameters(ASN1encoding_t enc, ColorAccuracyEnhancementRGB_generalRGBParameters *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementRGB_predefinedRGBSpace(ASN1encoding_t enc, ColorAccuracyEnhancementRGB_predefinedRGBSpace *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace(ASN1encoding_t enc, ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementCIELab_predefinedCIELabSpace(ASN1encoding_t enc, ColorAccuracyEnhancementCIELab_predefinedCIELabSpace *val);
#define ASN1Enc_ArchiveError(x,y)      0
#define ASN1Enc_ArchiveOpenResult(x,y)      0
static int ASN1CALL ASN1Enc_BitmapAbortReason(ASN1encoding_t enc, BitmapAbortReason *val);
static int ASN1CALL ASN1Enc_BitmapDestinationAddress(ASN1encoding_t enc, BitmapDestinationAddress *val);
static int ASN1CALL ASN1Enc_ButtonEvent(ASN1encoding_t enc, ButtonEvent *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementCIELab(ASN1encoding_t enc, ColorAccuracyEnhancementCIELab *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementGreyscale(ASN1encoding_t enc, ColorAccuracyEnhancementGreyscale *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementRGB(ASN1encoding_t enc, ColorAccuracyEnhancementRGB *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementYCbCr(ASN1encoding_t enc, ColorAccuracyEnhancementYCbCr *val);
static int ASN1CALL ASN1Enc_ColorResolutionModeSpecifier(ASN1encoding_t enc, ColorResolutionModeSpecifier *val);
static int ASN1CALL ASN1Enc_ConductorPrivilege(ASN1encoding_t enc, ConductorPrivilege *val);
static int ASN1CALL ASN1Enc_DrawingDestinationAddress(ASN1encoding_t enc, DrawingDestinationAddress *val);
static int ASN1CALL ASN1Enc_DrawingType(ASN1encoding_t enc, DrawingType *val);
static int ASN1CALL ASN1Enc_EditablePlaneCopyDescriptor(ASN1encoding_t enc, EditablePlaneCopyDescriptor *val);
#define ASN1Enc_KeyCode(x,y)      0
static int ASN1CALL ASN1Enc_KeyModifier(ASN1encoding_t enc, KeyModifier *val);
#define ASN1Enc_KeyPressState(x,y)      0
static int ASN1CALL ASN1Enc_LineStyle(ASN1encoding_t enc, LineStyle *val);
static int ASN1CALL ASN1Enc_PermanentPlaneCopyDescriptor(ASN1encoding_t enc, PermanentPlaneCopyDescriptor *val);
static int ASN1CALL ASN1Enc_PlaneAttribute(ASN1encoding_t enc, PlaneAttribute *val);
static int ASN1CALL ASN1Enc_PointListEdits(ASN1encoding_t enc, PointListEdits *val);
static int ASN1CALL ASN1Enc_TransparencyMask(ASN1encoding_t enc, TransparencyMask *val);
#define ASN1Enc_VideoWindowAttribute(x,y)      0
#define ASN1Enc_VideoWindowCreatePDU(x,y)      0
#define ASN1Enc_VideoWindowEditPDU(x,y)      0
static int ASN1CALL ASN1Enc_WorkspaceAttribute(ASN1encoding_t enc, WorkspaceAttribute *val);
static int ASN1CALL ASN1Enc_WorkspaceViewAttribute(ASN1encoding_t enc, WorkspaceViewAttribute *val);
#define ASN1Enc_ArchiveAcknowledgePDU(x,y)      0
#define ASN1Enc_ArchiveErrorPDU(x,y)      0
static int ASN1CALL ASN1Enc_BitmapAbortPDU(ASN1encoding_t enc, BitmapAbortPDU *val);
static int ASN1CALL ASN1Enc_DrawingCreatePDU(ASN1encoding_t enc, DrawingCreatePDU *val);
static int ASN1CALL ASN1Enc_DrawingEditPDU(ASN1encoding_t enc, DrawingEditPDU *val);
#define ASN1Enc_RemoteKeyboardEventPDU(x,y)      0
static int ASN1CALL ASN1Enc_RemotePointingDeviceEventPDU(ASN1encoding_t enc, RemotePointingDeviceEventPDU *val);
static int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action_editView(ASN1encoding_t enc, PWorkspaceEditPDU_viewEdits_Set_action_editView *val);
static int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action_createNewView(ASN1encoding_t enc, PWorkspaceEditPDU_viewEdits_Set_action_createNewView *val);
static int ASN1CALL ASN1Enc_WorkspaceEditPDU_planeEdits_Set_planeAttributes(ASN1encoding_t enc, PWorkspaceEditPDU_planeEdits_Set_planeAttributes *val);
static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_viewParameters_Set_viewAttributes(ASN1encoding_t enc, PWorkspaceCreatePDU_viewParameters_Set_viewAttributes *val);
static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes(ASN1encoding_t enc, PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes *val);
static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteYCbCr(ASN1encoding_t enc, ColorPalette_colorLookUpTable_paletteYCbCr *val);
static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteCIELab(ASN1encoding_t enc, ColorPalette_colorLookUpTable_paletteCIELab *val);
static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteRGB(ASN1encoding_t enc, ColorPalette_colorLookUpTable_paletteRGB *val);
static int ASN1CALL ASN1Enc_WorkspacePlaneCopyPDU_copyDescriptor(ASN1encoding_t enc, WorkspacePlaneCopyPDU_copyDescriptor *val);
static int ASN1CALL ASN1Enc_WorkspaceEditPDU_attributeEdits(ASN1encoding_t enc, PWorkspaceEditPDU_attributeEdits *val);
static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_workspaceAttributes(ASN1encoding_t enc, PWorkspaceCreatePDU_workspaceAttributes *val);
static int ASN1CALL ASN1Enc_RemoteKeyboardEventPDU_keyModifierStates(ASN1encoding_t enc, PRemoteKeyboardEventPDU_keyModifierStates *val);
static int ASN1CALL ASN1Enc_ConductorPrivilegeRequestPDU_privilegeList(ASN1encoding_t enc, PConductorPrivilegeRequestPDU_privilegeList *val);
static int ASN1CALL ASN1Enc_ConductorPrivilegeGrantPDU_privilegeList(ASN1encoding_t enc, PConductorPrivilegeGrantPDU_privilegeList *val);
static int ASN1CALL ASN1Enc_VideoWindowEditPDU_attributeEdits(ASN1encoding_t enc, PVideoWindowEditPDU_attributeEdits *val);
static int ASN1CALL ASN1Enc_VideoWindowCreatePDU_attributes(ASN1encoding_t enc, PVideoWindowCreatePDU_attributes *val);
static int ASN1CALL ASN1Enc_ColorSpaceSpecifier_cieLab(ASN1encoding_t enc, ColorSpaceSpecifier_cieLab *val);
static int ASN1CALL ASN1Enc_ColorSpaceSpecifier_rgb(ASN1encoding_t enc, ColorSpaceSpecifier_rgb *val);
static int ASN1CALL ASN1Enc_ColorSpaceSpecifier_yCbCr(ASN1encoding_t enc, ColorSpaceSpecifier_yCbCr *val);
static int ASN1CALL ASN1Enc_ColorSpaceSpecifier_greyscale(ASN1encoding_t enc, ColorSpaceSpecifier_greyscale *val);
static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable(ASN1encoding_t enc, ColorPalette_colorLookUpTable *val);
static int ASN1CALL ASN1Enc_BitmapAttribute(ASN1encoding_t enc, BitmapAttribute *val);
static int ASN1CALL ASN1Enc_ColorPalette(ASN1encoding_t enc, ColorPalette *val);
static int ASN1CALL ASN1Enc_ColorSpaceSpecifier(ASN1encoding_t enc, ColorSpaceSpecifier *val);
static int ASN1CALL ASN1Enc_DrawingAttribute(ASN1encoding_t enc, DrawingAttribute *val);
static int ASN1CALL ASN1Enc_WorkspacePlaneCopyPDU(ASN1encoding_t enc, WorkspacePlaneCopyPDU *val);
static int ASN1CALL ASN1Enc_BitmapHeaderUncompressed_colorMappingMode_paletteMap(ASN1encoding_t enc, BitmapHeaderUncompressed_colorMappingMode_paletteMap *val);
static int ASN1CALL ASN1Enc_BitmapHeaderUncompressed_colorMappingMode_directMap(ASN1encoding_t enc, BitmapHeaderUncompressed_colorMappingMode_directMap *val);
static int ASN1CALL ASN1Enc_BitmapHeaderT82_colorMappingMode_paletteMap(ASN1encoding_t enc, BitmapHeaderT82_colorMappingMode_paletteMap *val);
static int ASN1CALL ASN1Enc_DrawingEditPDU_attributeEdits(ASN1encoding_t enc, PDrawingEditPDU_attributeEdits *val);
static int ASN1CALL ASN1Enc_DrawingCreatePDU_attributes(ASN1encoding_t enc, PDrawingCreatePDU_attributes *val);
static int ASN1CALL ASN1Enc_BitmapEditPDU_attributeEdits(ASN1encoding_t enc, PBitmapEditPDU_attributeEdits *val);
static int ASN1CALL ASN1Enc_BitmapCreatePDU_attributes(ASN1encoding_t enc, PBitmapCreatePDU_attributes *val);
static int ASN1CALL ASN1Enc_BitmapHeaderT82_colorMappingMode(ASN1encoding_t enc, BitmapHeaderT82_colorMappingMode *val);
static int ASN1CALL ASN1Enc_BitmapHeaderUncompressed_colorMappingMode(ASN1encoding_t enc, BitmapHeaderUncompressed_colorMappingMode *val);
static int ASN1CALL ASN1Enc_BitmapHeaderUncompressed(ASN1encoding_t enc, BitmapHeaderUncompressed *val);
static int ASN1CALL ASN1Enc_BitmapHeaderT81(ASN1encoding_t enc, BitmapHeaderT81 *val);
static int ASN1CALL ASN1Enc_BitmapHeaderT82(ASN1encoding_t enc, BitmapHeaderT82 *val);
static int ASN1CALL ASN1Enc_BitmapCreatePDU_bitmapFormatHeader(ASN1encoding_t enc, BitmapCreatePDU_bitmapFormatHeader *val);
static int ASN1CALL ASN1Enc_BitmapCreatePDU(ASN1encoding_t enc, BitmapCreatePDU *val);
static int ASN1CALL ASN1Enc_SIPDU(ASN1encoding_t enc, SIPDU *val);
static int ASN1CALL ASN1Dec_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes(ASN1decoding_t dec, PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes *val);
static int ASN1CALL ASN1Dec_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode(ASN1decoding_t dec, BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementCIELab_generalCIELabParameters_gamut(ASN1decoding_t dec, ColorAccuracyEnhancementCIELab_generalCIELabParameters_gamut *val);
static int ASN1CALL ASN1Dec_EditablePlaneCopyDescriptor_objectList_Seq(ASN1decoding_t dec, EditablePlaneCopyDescriptor_objectList_Seq *val);
static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq(ASN1decoding_t dec, WorkspaceCreatePDU_planeParameters_Seq *val);
static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_viewParameters_Set(ASN1decoding_t dec, WorkspaceCreatePDU_viewParameters_Set *val);
static int ASN1CALL ASN1Dec_WorkspaceEditPDU_planeEdits_Set(ASN1decoding_t dec, WorkspaceEditPDU_planeEdits_Set *val);
static int ASN1CALL ASN1Dec_WorkspaceEditPDU_planeEdits(ASN1decoding_t dec, PWorkspaceEditPDU_planeEdits *val);
static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_viewParameters(ASN1decoding_t dec, PWorkspaceCreatePDU_viewParameters *val);
static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_planeParameters(ASN1decoding_t dec, PWorkspaceCreatePDU_planeParameters *val);
static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_protectedPlaneAccessList(ASN1decoding_t dec, PWorkspaceCreatePDU_protectedPlaneAccessList *val);
static int ASN1CALL ASN1Dec_BitmapCreatePDU_checkpoints(ASN1decoding_t dec, PBitmapCreatePDU_checkpoints *val);
static int ASN1CALL ASN1Dec_BitmapCheckpointPDU_passedCheckpoints(ASN1decoding_t dec, PBitmapCheckpointPDU_passedCheckpoints *val);
static int ASN1CALL ASN1Dec_WorkspaceIdentifier_archiveWorkspace(ASN1decoding_t dec, WorkspaceIdentifier_archiveWorkspace *val);
static int ASN1CALL ASN1Dec_PixelAspectRatio_general(ASN1decoding_t dec, PixelAspectRatio_general *val);
static int ASN1CALL ASN1Dec_EditablePlaneCopyDescriptor_objectList(ASN1decoding_t dec, PEditablePlaneCopyDescriptor_objectList *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementGreyscale_generalGreyscaleParameters(ASN1decoding_t dec, ColorAccuracyEnhancementGreyscale_generalGreyscaleParameters *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementCIELab_generalCIELabParameters(ASN1decoding_t dec, ColorAccuracyEnhancementCIELab_generalCIELabParameters *val);
static int ASN1CALL ASN1Dec_BitmapRegion_lowerRight(ASN1decoding_t dec, BitmapRegion_lowerRight *val);
static int ASN1CALL ASN1Dec_BitmapRegion_upperLeft(ASN1decoding_t dec, BitmapRegion_upperLeft *val);
static int ASN1CALL ASN1Dec_BitmapData_dataCheckpoint(ASN1decoding_t dec, PBitmapData_dataCheckpoint *val);
#define ASN1Dec_ArchiveHeader(x,y)      0
#define ASN1Dec_ArchiveMode(x,y)      0
static int ASN1CALL ASN1Dec_BitmapData(ASN1decoding_t dec, BitmapData *val);
static int ASN1CALL ASN1Dec_BitmapHeaderT4(ASN1decoding_t dec, BitmapHeaderT4 *val);
static int ASN1CALL ASN1Dec_BitmapHeaderT6(ASN1decoding_t dec, BitmapHeaderT6 *val);
static int ASN1CALL ASN1Dec_BitmapRegion(ASN1decoding_t dec, BitmapRegion *val);
static int ASN1CALL ASN1Dec_BitmapSize(ASN1decoding_t dec, BitmapSize *val);
static int ASN1CALL ASN1Dec_ColorCIELab(ASN1decoding_t dec, ColorCIELab *val);
static int ASN1CALL ASN1Dec_ColorCIExyChromaticity(ASN1decoding_t dec, ColorCIExyChromaticity *val);
static int ASN1CALL ASN1Dec_ColorIndexTable(ASN1decoding_t dec, PColorIndexTable *val);
static int ASN1CALL ASN1Dec_ColorRGB(ASN1decoding_t dec, ColorRGB *val);
static int ASN1CALL ASN1Dec_ColorYCbCr(ASN1decoding_t dec, ColorYCbCr *val);
static int ASN1CALL ASN1Dec_DSMCCTap(ASN1decoding_t dec, DSMCCTap *val);
static int ASN1CALL ASN1Dec_NonStandardIdentifier(ASN1decoding_t dec, NonStandardIdentifier *val);
static int ASN1CALL ASN1Dec_NonStandardParameter(ASN1decoding_t dec, NonStandardParameter *val);
static int ASN1CALL ASN1Dec_PenNib(ASN1decoding_t dec, PenNib *val);
static int ASN1CALL ASN1Dec_PixelAspectRatio(ASN1decoding_t dec, PixelAspectRatio *val);
static int ASN1CALL ASN1Dec_PlaneProtection(ASN1decoding_t dec, PlaneProtection *val);
static int ASN1CALL ASN1Dec_PlaneUsage(ASN1decoding_t dec, PlaneUsage *val);
static int ASN1CALL ASN1Dec_PointList(ASN1decoding_t dec, PointList *val);
static int ASN1CALL ASN1Dec_PointDiff4(ASN1decoding_t dec, PointDiff4 *val);
static int ASN1CALL ASN1Dec_PointDiff8(ASN1decoding_t dec, PointDiff8 *val);
static int ASN1CALL ASN1Dec_PointDiff16(ASN1decoding_t dec, PointDiff16 *val);
static int ASN1CALL ASN1Dec_RemoteEventDestinationAddress(ASN1decoding_t dec, RemoteEventDestinationAddress *val);
static int ASN1CALL ASN1Dec_RemoteEventPermission(ASN1decoding_t dec, RemoteEventPermission *val);
static int ASN1CALL ASN1Dec_RotationSpecifier(ASN1decoding_t dec, RotationSpecifier *val);
static int ASN1CALL ASN1Dec_SoftCopyDataPlaneAddress(ASN1decoding_t dec, SoftCopyDataPlaneAddress *val);
static int ASN1CALL ASN1Dec_SoftCopyPointerPlaneAddress(ASN1decoding_t dec, SoftCopyPointerPlaneAddress *val);
static int ASN1CALL ASN1Dec_SourceDisplayIndicator(ASN1decoding_t dec, SourceDisplayIndicator *val);
#define ASN1Dec_VideoWindowDestinationAddress(x,y)      0
#define ASN1Dec_VideoSourceIdentifier(x,y)      0
#define ASN1Dec_VideoWindowDeletePDU(x,y)      0
static int ASN1CALL ASN1Dec_ViewState(ASN1decoding_t dec, ViewState *val);
static int ASN1CALL ASN1Dec_WorkspaceColor(ASN1decoding_t dec, WorkspaceColor *val);
static int ASN1CALL ASN1Dec_WorkspaceDeleteReason(ASN1decoding_t dec, WorkspaceDeleteReason *val);
static int ASN1CALL ASN1Dec_WorkspaceIdentifier(ASN1decoding_t dec, WorkspaceIdentifier *val);
static int ASN1CALL ASN1Dec_WorkspacePoint(ASN1decoding_t dec, WorkspacePoint *val);
static int ASN1CALL ASN1Dec_WorkspaceRegion(ASN1decoding_t dec, WorkspaceRegion *val);
static int ASN1CALL ASN1Dec_WorkspaceSize(ASN1decoding_t dec, WorkspaceSize *val);
static int ASN1CALL ASN1Dec_WorkspaceViewState(ASN1decoding_t dec, WorkspaceViewState *val);
#define ASN1Dec_ArchiveClosePDU(x,y)      0
#define ASN1Dec_ArchiveOpenPDU(x,y)      0
static int ASN1CALL ASN1Dec_BitmapCheckpointPDU(ASN1decoding_t dec, BitmapCheckpointPDU *val);
static int ASN1CALL ASN1Dec_BitmapCreateContinuePDU(ASN1decoding_t dec, BitmapCreateContinuePDU *val);
static int ASN1CALL ASN1Dec_BitmapDeletePDU(ASN1decoding_t dec, BitmapDeletePDU *val);
static int ASN1CALL ASN1Dec_BitmapEditPDU(ASN1decoding_t dec, BitmapEditPDU *val);
static int ASN1CALL ASN1Dec_ConductorPrivilegeGrantPDU(ASN1decoding_t dec, ConductorPrivilegeGrantPDU *val);
static int ASN1CALL ASN1Dec_ConductorPrivilegeRequestPDU(ASN1decoding_t dec, ConductorPrivilegeRequestPDU *val);
static int ASN1CALL ASN1Dec_DrawingDeletePDU(ASN1decoding_t dec, DrawingDeletePDU *val);
static int ASN1CALL ASN1Dec_FontPDU(ASN1decoding_t dec, FontPDU *val);
static int ASN1CALL ASN1Dec_RemoteEventPermissionGrantPDU(ASN1decoding_t dec, RemoteEventPermissionGrantPDU *val);
static int ASN1CALL ASN1Dec_RemoteEventPermissionRequestPDU(ASN1decoding_t dec, RemoteEventPermissionRequestPDU *val);
static int ASN1CALL ASN1Dec_RemotePrintPDU(ASN1decoding_t dec, RemotePrintPDU *val);
static int ASN1CALL ASN1Dec_SINonStandardPDU(ASN1decoding_t dec, SINonStandardPDU *val);
#define ASN1Dec_TextCreatePDU(x,y)      0
#define ASN1Dec_TextDeletePDU(x,y)      0
#define ASN1Dec_TextEditPDU(x,y)      0
static int ASN1CALL ASN1Dec_WorkspaceCreatePDU(ASN1decoding_t dec, WorkspaceCreatePDU *val);
static int ASN1CALL ASN1Dec_WorkspaceCreateAcknowledgePDU(ASN1decoding_t dec, WorkspaceCreateAcknowledgePDU *val);
static int ASN1CALL ASN1Dec_WorkspaceDeletePDU(ASN1decoding_t dec, WorkspaceDeletePDU *val);
static int ASN1CALL ASN1Dec_WorkspaceEditPDU(ASN1decoding_t dec, WorkspaceEditPDU *val);
static int ASN1CALL ASN1Dec_WorkspaceReadyPDU(ASN1decoding_t dec, WorkspaceReadyPDU *val);
static int ASN1CALL ASN1Dec_WorkspaceRefreshStatusPDU(ASN1decoding_t dec, WorkspaceRefreshStatusPDU *val);
static int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action(ASN1decoding_t dec, WorkspaceEditPDU_viewEdits_Set_action *val);
static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq_usage(ASN1decoding_t dec, PWorkspaceCreatePDU_planeParameters_Seq_usage *val);
static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteRGB_palette(ASN1decoding_t dec, PColorPalette_colorLookUpTable_paletteRGB_palette *val);
static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteCIELab_palette(ASN1decoding_t dec, PColorPalette_colorLookUpTable_paletteCIELab_palette *val);
static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteYCbCr_palette(ASN1decoding_t dec, PColorPalette_colorLookUpTable_paletteYCbCr_palette *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementRGB_generalRGBParameters_primaries(ASN1decoding_t dec, ColorAccuracyEnhancementRGB_generalRGBParameters_primaries *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_primaries(ASN1decoding_t dec, ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_primaries *val);
static int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits_Set(ASN1decoding_t dec, WorkspaceEditPDU_viewEdits_Set *val);
static int ASN1CALL ASN1Dec_WorkspaceRefreshStatusPDU_nonStandardParameters(ASN1decoding_t dec, PWorkspaceRefreshStatusPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_WorkspaceReadyPDU_nonStandardParameters(ASN1decoding_t dec, PWorkspaceReadyPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_WorkspacePlaneCopyPDU_nonStandardParameters(ASN1decoding_t dec, PWorkspacePlaneCopyPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_WorkspaceEditPDU_nonStandardParameters(ASN1decoding_t dec, PWorkspaceEditPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits(ASN1decoding_t dec, PWorkspaceEditPDU_viewEdits *val);
static int ASN1CALL ASN1Dec_WorkspaceDeletePDU_nonStandardParameters(ASN1decoding_t dec, PWorkspaceDeletePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_WorkspaceCreateAcknowledgePDU_nonStandardParameters(ASN1decoding_t dec, PWorkspaceCreateAcknowledgePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_nonStandardParameters(ASN1decoding_t dec, PWorkspaceCreatePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_TextEditPDU_nonStandardParameters(ASN1decoding_t dec, PTextEditPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_TextDeletePDU_nonStandardParameters(ASN1decoding_t dec, PTextDeletePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_TextCreatePDU_nonStandardParameters(ASN1decoding_t dec, PTextCreatePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_RemotePrintPDU_nonStandardParameters(ASN1decoding_t dec, PRemotePrintPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_RemotePointingDeviceEventPDU_nonStandardParameters(ASN1decoding_t dec, PRemotePointingDeviceEventPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_RemoteKeyboardEventPDU_nonStandardParameters(ASN1decoding_t dec, PRemoteKeyboardEventPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_RemoteEventPermissionRequestPDU_nonStandardParameters(ASN1decoding_t dec, PRemoteEventPermissionRequestPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_RemoteEventPermissionRequestPDU_remoteEventPermissionList(ASN1decoding_t dec, PRemoteEventPermissionRequestPDU_remoteEventPermissionList *val);
static int ASN1CALL ASN1Dec_RemoteEventPermissionGrantPDU_nonStandardParameters(ASN1decoding_t dec, PRemoteEventPermissionGrantPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_RemoteEventPermissionGrantPDU_remoteEventPermissionList(ASN1decoding_t dec, PRemoteEventPermissionGrantPDU_remoteEventPermissionList *val);
static int ASN1CALL ASN1Dec_FontPDU_nonStandardParameters(ASN1decoding_t dec, PFontPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_DrawingEditPDU_nonStandardParameters(ASN1decoding_t dec, PDrawingEditPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_DrawingDeletePDU_nonStandardParameters(ASN1decoding_t dec, PDrawingDeletePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_DrawingCreatePDU_nonStandardParameters(ASN1decoding_t dec, PDrawingCreatePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_ConductorPrivilegeRequestPDU_nonStandardParameters(ASN1decoding_t dec, PConductorPrivilegeRequestPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_ConductorPrivilegeGrantPDU_nonStandardParameters(ASN1decoding_t dec, PConductorPrivilegeGrantPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_BitmapEditPDU_nonStandardParameters(ASN1decoding_t dec, PBitmapEditPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_BitmapDeletePDU_nonStandardParameters(ASN1decoding_t dec, PBitmapDeletePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_BitmapCreateContinuePDU_nonStandardParameters(ASN1decoding_t dec, PBitmapCreateContinuePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_BitmapCreatePDU_nonStandardParameters(ASN1decoding_t dec, PBitmapCreatePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_BitmapCheckpointPDU_nonStandardParameters(ASN1decoding_t dec, PBitmapCheckpointPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_BitmapAbortPDU_nonStandardParameters(ASN1decoding_t dec, PBitmapAbortPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_ArchiveOpenPDU_nonStandardParameters(ASN1decoding_t dec, PArchiveOpenPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_ArchiveErrorPDU_nonStandardParameters(ASN1decoding_t dec, PArchiveErrorPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_ArchiveClosePDU_nonStandardParameters(ASN1decoding_t dec, PArchiveClosePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_ArchiveAcknowledgePDU_nonStandardParameters(ASN1decoding_t dec, PArchiveAcknowledgePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_WorkspaceViewAttribute_viewRegion(ASN1decoding_t dec, WorkspaceViewAttribute_viewRegion *val);
static int ASN1CALL ASN1Dec_VideoWindowEditPDU_nonStandardParameters(ASN1decoding_t dec, PVideoWindowEditPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_VideoWindowDeletePDU_nonStandardParameters(ASN1decoding_t dec, PVideoWindowDeletePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_VideoWindowCreatePDU_nonStandardParameters(ASN1decoding_t dec, PVideoWindowCreatePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_VideoSourceIdentifier_dSMCCConnBinder(ASN1decoding_t dec, PVideoSourceIdentifier_dSMCCConnBinder *val);
static int ASN1CALL ASN1Dec_TransparencyMask_nonStandardParameters(ASN1decoding_t dec, PTransparencyMask_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_TransparencyMask_bitMask(ASN1decoding_t dec, TransparencyMask_bitMask *val);
static int ASN1CALL ASN1Dec_PointListEdits_Seq(ASN1decoding_t dec, PointListEdits_Seq *val);
static int ASN1CALL ASN1Dec_PointList_pointsDiff16(ASN1decoding_t dec, PPointList_pointsDiff16 *val);
static int ASN1CALL ASN1Dec_PointList_pointsDiff8(ASN1decoding_t dec, PPointList_pointsDiff8 *val);
static int ASN1CALL ASN1Dec_PointList_pointsDiff4(ASN1decoding_t dec, PPointList_pointsDiff4 *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementYCbCr_generalYCbCrParameters(ASN1decoding_t dec, ColorAccuracyEnhancementYCbCr_generalYCbCrParameters *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace(ASN1decoding_t dec, ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementRGB_generalRGBParameters(ASN1decoding_t dec, ColorAccuracyEnhancementRGB_generalRGBParameters *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementRGB_predefinedRGBSpace(ASN1decoding_t dec, ColorAccuracyEnhancementRGB_predefinedRGBSpace *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace(ASN1decoding_t dec, ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementCIELab_predefinedCIELabSpace(ASN1decoding_t dec, ColorAccuracyEnhancementCIELab_predefinedCIELabSpace *val);
#define ASN1Dec_ArchiveError(x,y)      0
#define ASN1Dec_ArchiveOpenResult(x,y)      0
static int ASN1CALL ASN1Dec_BitmapAbortReason(ASN1decoding_t dec, BitmapAbortReason *val);
static int ASN1CALL ASN1Dec_BitmapDestinationAddress(ASN1decoding_t dec, BitmapDestinationAddress *val);
static int ASN1CALL ASN1Dec_ButtonEvent(ASN1decoding_t dec, ButtonEvent *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementCIELab(ASN1decoding_t dec, ColorAccuracyEnhancementCIELab *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementGreyscale(ASN1decoding_t dec, ColorAccuracyEnhancementGreyscale *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementRGB(ASN1decoding_t dec, ColorAccuracyEnhancementRGB *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementYCbCr(ASN1decoding_t dec, ColorAccuracyEnhancementYCbCr *val);
static int ASN1CALL ASN1Dec_ColorResolutionModeSpecifier(ASN1decoding_t dec, ColorResolutionModeSpecifier *val);
static int ASN1CALL ASN1Dec_ConductorPrivilege(ASN1decoding_t dec, ConductorPrivilege *val);
static int ASN1CALL ASN1Dec_DrawingDestinationAddress(ASN1decoding_t dec, DrawingDestinationAddress *val);
static int ASN1CALL ASN1Dec_DrawingType(ASN1decoding_t dec, DrawingType *val);
static int ASN1CALL ASN1Dec_EditablePlaneCopyDescriptor(ASN1decoding_t dec, EditablePlaneCopyDescriptor *val);
#define ASN1Dec_KeyCode(x,y)      0
static int ASN1CALL ASN1Dec_KeyModifier(ASN1decoding_t dec, KeyModifier *val);
#define ASN1Dec_KeyPressState(x,y)      0
static int ASN1CALL ASN1Dec_LineStyle(ASN1decoding_t dec, LineStyle *val);
static int ASN1CALL ASN1Dec_PermanentPlaneCopyDescriptor(ASN1decoding_t dec, PermanentPlaneCopyDescriptor *val);
static int ASN1CALL ASN1Dec_PlaneAttribute(ASN1decoding_t dec, PlaneAttribute *val);
static int ASN1CALL ASN1Dec_PointListEdits(ASN1decoding_t dec, PointListEdits *val);
static int ASN1CALL ASN1Dec_TransparencyMask(ASN1decoding_t dec, TransparencyMask *val);
#define ASN1Dec_VideoWindowAttribute(x,y)      0
#define ASN1Dec_VideoWindowCreatePDU(x,y)      0
#define ASN1Dec_VideoWindowEditPDU(x,y)      0
static int ASN1CALL ASN1Dec_WorkspaceAttribute(ASN1decoding_t dec, WorkspaceAttribute *val);
static int ASN1CALL ASN1Dec_WorkspaceViewAttribute(ASN1decoding_t dec, WorkspaceViewAttribute *val);
#define ASN1Dec_ArchiveAcknowledgePDU(x,y)      0
#define ASN1Dec_ArchiveErrorPDU(x,y)      0
static int ASN1CALL ASN1Dec_BitmapAbortPDU(ASN1decoding_t dec, BitmapAbortPDU *val);
static int ASN1CALL ASN1Dec_DrawingCreatePDU(ASN1decoding_t dec, DrawingCreatePDU *val);
static int ASN1CALL ASN1Dec_DrawingEditPDU(ASN1decoding_t dec, DrawingEditPDU *val);
#define ASN1Dec_RemoteKeyboardEventPDU(x,y)      0
static int ASN1CALL ASN1Dec_RemotePointingDeviceEventPDU(ASN1decoding_t dec, RemotePointingDeviceEventPDU *val);
static int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action_editView(ASN1decoding_t dec, PWorkspaceEditPDU_viewEdits_Set_action_editView *val);
static int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action_createNewView(ASN1decoding_t dec, PWorkspaceEditPDU_viewEdits_Set_action_createNewView *val);
static int ASN1CALL ASN1Dec_WorkspaceEditPDU_planeEdits_Set_planeAttributes(ASN1decoding_t dec, PWorkspaceEditPDU_planeEdits_Set_planeAttributes *val);
static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_viewParameters_Set_viewAttributes(ASN1decoding_t dec, PWorkspaceCreatePDU_viewParameters_Set_viewAttributes *val);
static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes(ASN1decoding_t dec, PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes *val);
static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteYCbCr(ASN1decoding_t dec, ColorPalette_colorLookUpTable_paletteYCbCr *val);
static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteCIELab(ASN1decoding_t dec, ColorPalette_colorLookUpTable_paletteCIELab *val);
static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteRGB(ASN1decoding_t dec, ColorPalette_colorLookUpTable_paletteRGB *val);
static int ASN1CALL ASN1Dec_WorkspacePlaneCopyPDU_copyDescriptor(ASN1decoding_t dec, WorkspacePlaneCopyPDU_copyDescriptor *val);
static int ASN1CALL ASN1Dec_WorkspaceEditPDU_attributeEdits(ASN1decoding_t dec, PWorkspaceEditPDU_attributeEdits *val);
static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_workspaceAttributes(ASN1decoding_t dec, PWorkspaceCreatePDU_workspaceAttributes *val);
static int ASN1CALL ASN1Dec_RemoteKeyboardEventPDU_keyModifierStates(ASN1decoding_t dec, PRemoteKeyboardEventPDU_keyModifierStates *val);
static int ASN1CALL ASN1Dec_ConductorPrivilegeRequestPDU_privilegeList(ASN1decoding_t dec, PConductorPrivilegeRequestPDU_privilegeList *val);
static int ASN1CALL ASN1Dec_ConductorPrivilegeGrantPDU_privilegeList(ASN1decoding_t dec, PConductorPrivilegeGrantPDU_privilegeList *val);
static int ASN1CALL ASN1Dec_VideoWindowEditPDU_attributeEdits(ASN1decoding_t dec, PVideoWindowEditPDU_attributeEdits *val);
static int ASN1CALL ASN1Dec_VideoWindowCreatePDU_attributes(ASN1decoding_t dec, PVideoWindowCreatePDU_attributes *val);
static int ASN1CALL ASN1Dec_ColorSpaceSpecifier_cieLab(ASN1decoding_t dec, ColorSpaceSpecifier_cieLab *val);
static int ASN1CALL ASN1Dec_ColorSpaceSpecifier_rgb(ASN1decoding_t dec, ColorSpaceSpecifier_rgb *val);
static int ASN1CALL ASN1Dec_ColorSpaceSpecifier_yCbCr(ASN1decoding_t dec, ColorSpaceSpecifier_yCbCr *val);
static int ASN1CALL ASN1Dec_ColorSpaceSpecifier_greyscale(ASN1decoding_t dec, ColorSpaceSpecifier_greyscale *val);
static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable(ASN1decoding_t dec, ColorPalette_colorLookUpTable *val);
static int ASN1CALL ASN1Dec_BitmapAttribute(ASN1decoding_t dec, BitmapAttribute *val);
static int ASN1CALL ASN1Dec_ColorPalette(ASN1decoding_t dec, ColorPalette *val);
static int ASN1CALL ASN1Dec_ColorSpaceSpecifier(ASN1decoding_t dec, ColorSpaceSpecifier *val);
static int ASN1CALL ASN1Dec_DrawingAttribute(ASN1decoding_t dec, DrawingAttribute *val);
static int ASN1CALL ASN1Dec_WorkspacePlaneCopyPDU(ASN1decoding_t dec, WorkspacePlaneCopyPDU *val);
static int ASN1CALL ASN1Dec_BitmapHeaderUncompressed_colorMappingMode_paletteMap(ASN1decoding_t dec, BitmapHeaderUncompressed_colorMappingMode_paletteMap *val);
static int ASN1CALL ASN1Dec_BitmapHeaderUncompressed_colorMappingMode_directMap(ASN1decoding_t dec, BitmapHeaderUncompressed_colorMappingMode_directMap *val);
static int ASN1CALL ASN1Dec_BitmapHeaderT82_colorMappingMode_paletteMap(ASN1decoding_t dec, BitmapHeaderT82_colorMappingMode_paletteMap *val);
static int ASN1CALL ASN1Dec_DrawingEditPDU_attributeEdits(ASN1decoding_t dec, PDrawingEditPDU_attributeEdits *val);
static int ASN1CALL ASN1Dec_DrawingCreatePDU_attributes(ASN1decoding_t dec, PDrawingCreatePDU_attributes *val);
static int ASN1CALL ASN1Dec_BitmapEditPDU_attributeEdits(ASN1decoding_t dec, PBitmapEditPDU_attributeEdits *val);
static int ASN1CALL ASN1Dec_BitmapCreatePDU_attributes(ASN1decoding_t dec, PBitmapCreatePDU_attributes *val);
static int ASN1CALL ASN1Dec_BitmapHeaderT82_colorMappingMode(ASN1decoding_t dec, BitmapHeaderT82_colorMappingMode *val);
static int ASN1CALL ASN1Dec_BitmapHeaderUncompressed_colorMappingMode(ASN1decoding_t dec, BitmapHeaderUncompressed_colorMappingMode *val);
static int ASN1CALL ASN1Dec_BitmapHeaderUncompressed(ASN1decoding_t dec, BitmapHeaderUncompressed *val);
static int ASN1CALL ASN1Dec_BitmapHeaderT81(ASN1decoding_t dec, BitmapHeaderT81 *val);
static int ASN1CALL ASN1Dec_BitmapHeaderT82(ASN1decoding_t dec, BitmapHeaderT82 *val);
static int ASN1CALL ASN1Dec_BitmapCreatePDU_bitmapFormatHeader(ASN1decoding_t dec, BitmapCreatePDU_bitmapFormatHeader *val);
static int ASN1CALL ASN1Dec_BitmapCreatePDU(ASN1decoding_t dec, BitmapCreatePDU *val);
static int ASN1CALL ASN1Dec_SIPDU(ASN1decoding_t dec, SIPDU *val);
static void ASN1CALL ASN1Free_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes(PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes *val);
static void ASN1CALL ASN1Free_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode(BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode *val);
static void ASN1CALL ASN1Free_WorkspaceCreatePDU_planeParameters_Seq(WorkspaceCreatePDU_planeParameters_Seq *val);
static void ASN1CALL ASN1Free_WorkspaceCreatePDU_viewParameters_Set(WorkspaceCreatePDU_viewParameters_Set *val);
static void ASN1CALL ASN1Free_WorkspaceEditPDU_planeEdits_Set(WorkspaceEditPDU_planeEdits_Set *val);
static void ASN1CALL ASN1Free_WorkspaceEditPDU_planeEdits(PWorkspaceEditPDU_planeEdits *val);
static void ASN1CALL ASN1Free_WorkspaceCreatePDU_viewParameters(PWorkspaceCreatePDU_viewParameters *val);
static void ASN1CALL ASN1Free_WorkspaceCreatePDU_planeParameters(PWorkspaceCreatePDU_planeParameters *val);
static void ASN1CALL ASN1Free_WorkspaceCreatePDU_protectedPlaneAccessList(PWorkspaceCreatePDU_protectedPlaneAccessList *val);
static void ASN1CALL ASN1Free_BitmapCreatePDU_checkpoints(PBitmapCreatePDU_checkpoints *val);
static void ASN1CALL ASN1Free_BitmapCheckpointPDU_passedCheckpoints(PBitmapCheckpointPDU_passedCheckpoints *val);
static void ASN1CALL ASN1Free_WorkspaceIdentifier_archiveWorkspace(WorkspaceIdentifier_archiveWorkspace *val);
static void ASN1CALL ASN1Free_EditablePlaneCopyDescriptor_objectList(PEditablePlaneCopyDescriptor_objectList *val);
static void ASN1CALL ASN1Free_BitmapData_dataCheckpoint(PBitmapData_dataCheckpoint *val);
#define ASN1Free_ArchiveHeader(x)
static void ASN1CALL ASN1Free_BitmapData(BitmapData *val);
static void ASN1CALL ASN1Free_ColorIndexTable(PColorIndexTable *val);
static void ASN1CALL ASN1Free_DSMCCTap(DSMCCTap *val);
static void ASN1CALL ASN1Free_NonStandardIdentifier(NonStandardIdentifier *val);
static void ASN1CALL ASN1Free_NonStandardParameter(NonStandardParameter *val);
static void ASN1CALL ASN1Free_PenNib(PenNib *val);
static void ASN1CALL ASN1Free_PixelAspectRatio(PixelAspectRatio *val);
static void ASN1CALL ASN1Free_PlaneUsage(PlaneUsage *val);
static void ASN1CALL ASN1Free_PointList(PointList *val);
static void ASN1CALL ASN1Free_RemoteEventDestinationAddress(RemoteEventDestinationAddress *val);
static void ASN1CALL ASN1Free_RemoteEventPermission(RemoteEventPermission *val);
#define ASN1Free_VideoWindowDestinationAddress(x)
#define ASN1Free_VideoSourceIdentifier(x)
#define ASN1Free_VideoWindowDeletePDU(x)
static void ASN1CALL ASN1Free_ViewState(ViewState *val);
static void ASN1CALL ASN1Free_WorkspaceDeleteReason(WorkspaceDeleteReason *val);
static void ASN1CALL ASN1Free_WorkspaceIdentifier(WorkspaceIdentifier *val);
static void ASN1CALL ASN1Free_WorkspaceViewState(WorkspaceViewState *val);
#define ASN1Free_ArchiveClosePDU(x)
#define ASN1Free_ArchiveOpenPDU(x)
static void ASN1CALL ASN1Free_BitmapCheckpointPDU(BitmapCheckpointPDU *val);
static void ASN1CALL ASN1Free_BitmapCreateContinuePDU(BitmapCreateContinuePDU *val);
static void ASN1CALL ASN1Free_BitmapDeletePDU(BitmapDeletePDU *val);
static void ASN1CALL ASN1Free_BitmapEditPDU(BitmapEditPDU *val);
static void ASN1CALL ASN1Free_ConductorPrivilegeGrantPDU(ConductorPrivilegeGrantPDU *val);
static void ASN1CALL ASN1Free_ConductorPrivilegeRequestPDU(ConductorPrivilegeRequestPDU *val);
static void ASN1CALL ASN1Free_DrawingDeletePDU(DrawingDeletePDU *val);
static void ASN1CALL ASN1Free_FontPDU(FontPDU *val);
static void ASN1CALL ASN1Free_RemoteEventPermissionGrantPDU(RemoteEventPermissionGrantPDU *val);
static void ASN1CALL ASN1Free_RemoteEventPermissionRequestPDU(RemoteEventPermissionRequestPDU *val);
static void ASN1CALL ASN1Free_RemotePrintPDU(RemotePrintPDU *val);
static void ASN1CALL ASN1Free_SINonStandardPDU(SINonStandardPDU *val);
#define ASN1Free_TextCreatePDU(x)
#define ASN1Free_TextDeletePDU(x)
#define ASN1Free_TextEditPDU(x)
static void ASN1CALL ASN1Free_WorkspaceCreatePDU(WorkspaceCreatePDU *val);
static void ASN1CALL ASN1Free_WorkspaceCreateAcknowledgePDU(WorkspaceCreateAcknowledgePDU *val);
static void ASN1CALL ASN1Free_WorkspaceDeletePDU(WorkspaceDeletePDU *val);
static void ASN1CALL ASN1Free_WorkspaceEditPDU(WorkspaceEditPDU *val);
static void ASN1CALL ASN1Free_WorkspaceReadyPDU(WorkspaceReadyPDU *val);
static void ASN1CALL ASN1Free_WorkspaceRefreshStatusPDU(WorkspaceRefreshStatusPDU *val);
static void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits_Set_action(WorkspaceEditPDU_viewEdits_Set_action *val);
static void ASN1CALL ASN1Free_WorkspaceCreatePDU_planeParameters_Seq_usage(PWorkspaceCreatePDU_planeParameters_Seq_usage *val);
static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteRGB_palette(PColorPalette_colorLookUpTable_paletteRGB_palette *val);
static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteCIELab_palette(PColorPalette_colorLookUpTable_paletteCIELab_palette *val);
static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteYCbCr_palette(PColorPalette_colorLookUpTable_paletteYCbCr_palette *val);
static void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits_Set(WorkspaceEditPDU_viewEdits_Set *val);
static void ASN1CALL ASN1Free_WorkspaceRefreshStatusPDU_nonStandardParameters(PWorkspaceRefreshStatusPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_WorkspaceReadyPDU_nonStandardParameters(PWorkspaceReadyPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_WorkspacePlaneCopyPDU_nonStandardParameters(PWorkspacePlaneCopyPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_WorkspaceEditPDU_nonStandardParameters(PWorkspaceEditPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits(PWorkspaceEditPDU_viewEdits *val);
static void ASN1CALL ASN1Free_WorkspaceDeletePDU_nonStandardParameters(PWorkspaceDeletePDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_WorkspaceCreateAcknowledgePDU_nonStandardParameters(PWorkspaceCreateAcknowledgePDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_WorkspaceCreatePDU_nonStandardParameters(PWorkspaceCreatePDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_TextEditPDU_nonStandardParameters(PTextEditPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_TextDeletePDU_nonStandardParameters(PTextDeletePDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_TextCreatePDU_nonStandardParameters(PTextCreatePDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_RemotePrintPDU_nonStandardParameters(PRemotePrintPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_RemotePointingDeviceEventPDU_nonStandardParameters(PRemotePointingDeviceEventPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_RemoteKeyboardEventPDU_nonStandardParameters(PRemoteKeyboardEventPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_RemoteEventPermissionRequestPDU_nonStandardParameters(PRemoteEventPermissionRequestPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_RemoteEventPermissionRequestPDU_remoteEventPermissionList(PRemoteEventPermissionRequestPDU_remoteEventPermissionList *val);
static void ASN1CALL ASN1Free_RemoteEventPermissionGrantPDU_nonStandardParameters(PRemoteEventPermissionGrantPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_RemoteEventPermissionGrantPDU_remoteEventPermissionList(PRemoteEventPermissionGrantPDU_remoteEventPermissionList *val);
static void ASN1CALL ASN1Free_FontPDU_nonStandardParameters(PFontPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_DrawingEditPDU_nonStandardParameters(PDrawingEditPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_DrawingDeletePDU_nonStandardParameters(PDrawingDeletePDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_DrawingCreatePDU_nonStandardParameters(PDrawingCreatePDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_ConductorPrivilegeRequestPDU_nonStandardParameters(PConductorPrivilegeRequestPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_ConductorPrivilegeGrantPDU_nonStandardParameters(PConductorPrivilegeGrantPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_BitmapEditPDU_nonStandardParameters(PBitmapEditPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_BitmapDeletePDU_nonStandardParameters(PBitmapDeletePDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_BitmapCreateContinuePDU_nonStandardParameters(PBitmapCreateContinuePDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_BitmapCreatePDU_nonStandardParameters(PBitmapCreatePDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_BitmapCheckpointPDU_nonStandardParameters(PBitmapCheckpointPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_BitmapAbortPDU_nonStandardParameters(PBitmapAbortPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_ArchiveOpenPDU_nonStandardParameters(PArchiveOpenPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_ArchiveErrorPDU_nonStandardParameters(PArchiveErrorPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_ArchiveClosePDU_nonStandardParameters(PArchiveClosePDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_ArchiveAcknowledgePDU_nonStandardParameters(PArchiveAcknowledgePDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_VideoWindowEditPDU_nonStandardParameters(PVideoWindowEditPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_VideoWindowDeletePDU_nonStandardParameters(PVideoWindowDeletePDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_VideoWindowCreatePDU_nonStandardParameters(PVideoWindowCreatePDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_VideoSourceIdentifier_dSMCCConnBinder(PVideoSourceIdentifier_dSMCCConnBinder *val);
static void ASN1CALL ASN1Free_TransparencyMask_nonStandardParameters(PTransparencyMask_nonStandardParameters *val);
static void ASN1CALL ASN1Free_TransparencyMask_bitMask(TransparencyMask_bitMask *val);
static void ASN1CALL ASN1Free_PointListEdits_Seq(PointListEdits_Seq *val);
static void ASN1CALL ASN1Free_PointList_pointsDiff16(PPointList_pointsDiff16 *val);
static void ASN1CALL ASN1Free_PointList_pointsDiff8(PPointList_pointsDiff8 *val);
static void ASN1CALL ASN1Free_PointList_pointsDiff4(PPointList_pointsDiff4 *val);
static void ASN1CALL ASN1Free_ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace(ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace *val);
static void ASN1CALL ASN1Free_ColorAccuracyEnhancementRGB_predefinedRGBSpace(ColorAccuracyEnhancementRGB_predefinedRGBSpace *val);
static void ASN1CALL ASN1Free_ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace(ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace *val);
static void ASN1CALL ASN1Free_ColorAccuracyEnhancementCIELab_predefinedCIELabSpace(ColorAccuracyEnhancementCIELab_predefinedCIELabSpace *val);
#define ASN1Free_ArchiveError(x)
#define ASN1Free_ArchiveOpenResult(x)
static void ASN1CALL ASN1Free_BitmapAbortReason(BitmapAbortReason *val);
static void ASN1CALL ASN1Free_BitmapDestinationAddress(BitmapDestinationAddress *val);
static void ASN1CALL ASN1Free_ButtonEvent(ButtonEvent *val);
static void ASN1CALL ASN1Free_ColorAccuracyEnhancementCIELab(ColorAccuracyEnhancementCIELab *val);
static void ASN1CALL ASN1Free_ColorAccuracyEnhancementGreyscale(ColorAccuracyEnhancementGreyscale *val);
static void ASN1CALL ASN1Free_ColorAccuracyEnhancementRGB(ColorAccuracyEnhancementRGB *val);
static void ASN1CALL ASN1Free_ColorAccuracyEnhancementYCbCr(ColorAccuracyEnhancementYCbCr *val);
static void ASN1CALL ASN1Free_ColorResolutionModeSpecifier(ColorResolutionModeSpecifier *val);
static void ASN1CALL ASN1Free_ConductorPrivilege(ConductorPrivilege *val);
static void ASN1CALL ASN1Free_DrawingDestinationAddress(DrawingDestinationAddress *val);
static void ASN1CALL ASN1Free_DrawingType(DrawingType *val);
static void ASN1CALL ASN1Free_EditablePlaneCopyDescriptor(EditablePlaneCopyDescriptor *val);
#define ASN1Free_KeyCode(x)
static void ASN1CALL ASN1Free_KeyModifier(KeyModifier *val);
#define ASN1Free_KeyPressState(x)
static void ASN1CALL ASN1Free_LineStyle(LineStyle *val);
static void ASN1CALL ASN1Free_PlaneAttribute(PlaneAttribute *val);
static void ASN1CALL ASN1Free_PointListEdits(PointListEdits *val);
static void ASN1CALL ASN1Free_TransparencyMask(TransparencyMask *val);
#define ASN1Free_VideoWindowAttribute(x)
#define ASN1Free_VideoWindowCreatePDU(x)
#define ASN1Free_VideoWindowEditPDU(x)
static void ASN1CALL ASN1Free_WorkspaceAttribute(WorkspaceAttribute *val);
static void ASN1CALL ASN1Free_WorkspaceViewAttribute(WorkspaceViewAttribute *val);
#define ASN1Free_ArchiveAcknowledgePDU(x)
#define ASN1Free_ArchiveErrorPDU(x)
static void ASN1CALL ASN1Free_BitmapAbortPDU(BitmapAbortPDU *val);
static void ASN1CALL ASN1Free_DrawingCreatePDU(DrawingCreatePDU *val);
static void ASN1CALL ASN1Free_DrawingEditPDU(DrawingEditPDU *val);
#define ASN1Free_RemoteKeyboardEventPDU(x)
static void ASN1CALL ASN1Free_RemotePointingDeviceEventPDU(RemotePointingDeviceEventPDU *val);
static void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits_Set_action_editView(PWorkspaceEditPDU_viewEdits_Set_action_editView *val);
static void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits_Set_action_createNewView(PWorkspaceEditPDU_viewEdits_Set_action_createNewView *val);
static void ASN1CALL ASN1Free_WorkspaceEditPDU_planeEdits_Set_planeAttributes(PWorkspaceEditPDU_planeEdits_Set_planeAttributes *val);
static void ASN1CALL ASN1Free_WorkspaceCreatePDU_viewParameters_Set_viewAttributes(PWorkspaceCreatePDU_viewParameters_Set_viewAttributes *val);
static void ASN1CALL ASN1Free_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes(PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes *val);
static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteYCbCr(ColorPalette_colorLookUpTable_paletteYCbCr *val);
static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteCIELab(ColorPalette_colorLookUpTable_paletteCIELab *val);
static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteRGB(ColorPalette_colorLookUpTable_paletteRGB *val);
static void ASN1CALL ASN1Free_WorkspacePlaneCopyPDU_copyDescriptor(WorkspacePlaneCopyPDU_copyDescriptor *val);
static void ASN1CALL ASN1Free_WorkspaceEditPDU_attributeEdits(PWorkspaceEditPDU_attributeEdits *val);
static void ASN1CALL ASN1Free_WorkspaceCreatePDU_workspaceAttributes(PWorkspaceCreatePDU_workspaceAttributes *val);
static void ASN1CALL ASN1Free_RemoteKeyboardEventPDU_keyModifierStates(PRemoteKeyboardEventPDU_keyModifierStates *val);
static void ASN1CALL ASN1Free_ConductorPrivilegeRequestPDU_privilegeList(PConductorPrivilegeRequestPDU_privilegeList *val);
static void ASN1CALL ASN1Free_ConductorPrivilegeGrantPDU_privilegeList(PConductorPrivilegeGrantPDU_privilegeList *val);
static void ASN1CALL ASN1Free_VideoWindowEditPDU_attributeEdits(PVideoWindowEditPDU_attributeEdits *val);
static void ASN1CALL ASN1Free_VideoWindowCreatePDU_attributes(PVideoWindowCreatePDU_attributes *val);
static void ASN1CALL ASN1Free_ColorSpaceSpecifier_cieLab(ColorSpaceSpecifier_cieLab *val);
static void ASN1CALL ASN1Free_ColorSpaceSpecifier_rgb(ColorSpaceSpecifier_rgb *val);
static void ASN1CALL ASN1Free_ColorSpaceSpecifier_yCbCr(ColorSpaceSpecifier_yCbCr *val);
static void ASN1CALL ASN1Free_ColorSpaceSpecifier_greyscale(ColorSpaceSpecifier_greyscale *val);
static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable(ColorPalette_colorLookUpTable *val);
static void ASN1CALL ASN1Free_BitmapAttribute(BitmapAttribute *val);
static void ASN1CALL ASN1Free_ColorPalette(ColorPalette *val);
static void ASN1CALL ASN1Free_ColorSpaceSpecifier(ColorSpaceSpecifier *val);
static void ASN1CALL ASN1Free_DrawingAttribute(DrawingAttribute *val);
static void ASN1CALL ASN1Free_WorkspacePlaneCopyPDU(WorkspacePlaneCopyPDU *val);
static void ASN1CALL ASN1Free_BitmapHeaderUncompressed_colorMappingMode_paletteMap(BitmapHeaderUncompressed_colorMappingMode_paletteMap *val);
static void ASN1CALL ASN1Free_BitmapHeaderUncompressed_colorMappingMode_directMap(BitmapHeaderUncompressed_colorMappingMode_directMap *val);
static void ASN1CALL ASN1Free_BitmapHeaderT82_colorMappingMode_paletteMap(BitmapHeaderT82_colorMappingMode_paletteMap *val);
static void ASN1CALL ASN1Free_DrawingEditPDU_attributeEdits(PDrawingEditPDU_attributeEdits *val);
static void ASN1CALL ASN1Free_DrawingCreatePDU_attributes(PDrawingCreatePDU_attributes *val);
static void ASN1CALL ASN1Free_BitmapEditPDU_attributeEdits(PBitmapEditPDU_attributeEdits *val);
static void ASN1CALL ASN1Free_BitmapCreatePDU_attributes(PBitmapCreatePDU_attributes *val);
static void ASN1CALL ASN1Free_BitmapHeaderT82_colorMappingMode(BitmapHeaderT82_colorMappingMode *val);
static void ASN1CALL ASN1Free_BitmapHeaderUncompressed_colorMappingMode(BitmapHeaderUncompressed_colorMappingMode *val);
static void ASN1CALL ASN1Free_BitmapHeaderUncompressed(BitmapHeaderUncompressed *val);
static void ASN1CALL ASN1Free_BitmapHeaderT81(BitmapHeaderT81 *val);
static void ASN1CALL ASN1Free_BitmapHeaderT82(BitmapHeaderT82 *val);
static void ASN1CALL ASN1Free_BitmapCreatePDU_bitmapFormatHeader(BitmapCreatePDU_bitmapFormatHeader *val);
static void ASN1CALL ASN1Free_BitmapCreatePDU(BitmapCreatePDU *val);
static void ASN1CALL ASN1Free_SIPDU(SIPDU *val);

typedef ASN1PerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[1] = {
    (ASN1EncFun_t) ASN1Enc_SIPDU,
};
typedef ASN1PerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[1] = {
    (ASN1DecFun_t) ASN1Dec_SIPDU,
};
static const ASN1FreeFun_t freefntab[1] = {
    (ASN1FreeFun_t) ASN1Free_SIPDU,
};
static const ULONG sizetab[1] = {
    SIZE_T126_Module_PDU_0,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */
double one = 1;

void ASN1CALL T126_Module_Startup(void)
{
    T126_Module = ASN1_CreateModule(0x10000, ASN1_PER_RULE_ALIGNED, ASN1FLAGS_NONE, 1, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x36323174);
}

void ASN1CALL T126_Module_Cleanup(void)
{
    ASN1_CloseModule(T126_Module);
    T126_Module = NULL;
}

static int ASN1CALL ASN1Enc_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes(ASN1encoding_t enc, PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes_ElmFn, 1, 8, 3);
}

static int ASN1CALL ASN1Enc_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes_ElmFn(ASN1encoding_t enc, PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes val)
{
    if (!ASN1Enc_ColorIndexTable(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes(ASN1decoding_t dec, PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes_ElmFn, sizeof(**val), 1, 8, 3);
}

static int ASN1CALL ASN1Dec_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes_ElmFn(ASN1decoding_t dec, PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes val)
{
    if (!ASN1Dec_ColorIndexTable(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes(PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes_ElmFn(PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes val)
{
    if (val) {
	ASN1Free_ColorIndexTable(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode(ASN1encoding_t enc, BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes(enc, &(val)->u.progressivePalettes))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode(ASN1decoding_t dec, BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes(dec, &(val)->u.progressivePalettes))
	    return 0;
	break;
    case 2:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode(BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes(&(val)->u.progressivePalettes);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementCIELab_generalCIELabParameters_gamut(ASN1encoding_t enc, ColorAccuracyEnhancementCIELab_generalCIELabParameters_gamut *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->lSpan + 32768))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->lOffset + 32768))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->aSpan + 32768))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->aOffset + 32768))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bSpan + 32768))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bOffset + 32768))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementCIELab_generalCIELabParameters_gamut(ASN1decoding_t dec, ColorAccuracyEnhancementCIELab_generalCIELabParameters_gamut *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->lSpan))
	return 0;
    (val)->lSpan += 0 - 32768;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->lOffset))
	return 0;
    (val)->lOffset += 0 - 32768;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->aSpan))
	return 0;
    (val)->aSpan += 0 - 32768;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->aOffset))
	return 0;
    (val)->aOffset += 0 - 32768;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bSpan))
	return 0;
    (val)->bSpan += 0 - 32768;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bOffset))
	return 0;
    (val)->bOffset += 0 - 32768;
    return 1;
}

static int ASN1CALL ASN1Enc_EditablePlaneCopyDescriptor_objectList_Seq(ASN1encoding_t enc, EditablePlaneCopyDescriptor_objectList_Seq *val)
{
    ASN1uint32_t l;
    l = ASN1uint32_uoctets((val)->sourceObjectHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->sourceObjectHandle))
	return 0;
    l = ASN1uint32_uoctets((val)->destinationObjectHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->destinationObjectHandle))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EditablePlaneCopyDescriptor_objectList_Seq(ASN1decoding_t dec, EditablePlaneCopyDescriptor_objectList_Seq *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->sourceObjectHandle))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->destinationObjectHandle))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq(ASN1encoding_t enc, WorkspaceCreatePDU_planeParameters_Seq *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->editable))
	return 0;
    if (!ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq_usage(enc, &(val)->usage))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes(enc, &(val)->planeAttributes))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq(ASN1decoding_t dec, WorkspaceCreatePDU_planeParameters_Seq *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->editable))
	return 0;
    if (!ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq_usage(dec, &(val)->usage))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes(dec, &(val)->planeAttributes))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_planeParameters_Seq(WorkspaceCreatePDU_planeParameters_Seq *val)
{
    if (val) {
	ASN1Free_WorkspaceCreatePDU_planeParameters_Seq_usage(&(val)->usage);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes(&(val)->planeAttributes);
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_viewParameters_Set(ASN1encoding_t enc, WorkspaceCreatePDU_viewParameters_Set *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    l = ASN1uint32_uoctets((val)->viewHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->viewHandle))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_WorkspaceCreatePDU_viewParameters_Set_viewAttributes(enc, &(val)->viewAttributes))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_viewParameters_Set(ASN1decoding_t dec, WorkspaceCreatePDU_viewParameters_Set *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->viewHandle))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_WorkspaceCreatePDU_viewParameters_Set_viewAttributes(dec, &(val)->viewAttributes))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_viewParameters_Set(WorkspaceCreatePDU_viewParameters_Set *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_WorkspaceCreatePDU_viewParameters_Set_viewAttributes(&(val)->viewAttributes);
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_planeEdits_Set(ASN1encoding_t enc, WorkspaceEditPDU_planeEdits_Set *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->plane))
	return 0;
    if (!ASN1Enc_WorkspaceEditPDU_planeEdits_Set_planeAttributes(enc, &(val)->planeAttributes))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_planeEdits_Set(ASN1decoding_t dec, WorkspaceEditPDU_planeEdits_Set *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->plane))
	return 0;
    if (!ASN1Dec_WorkspaceEditPDU_planeEdits_Set_planeAttributes(dec, &(val)->planeAttributes))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_planeEdits_Set(WorkspaceEditPDU_planeEdits_Set *val)
{
    if (val) {
	ASN1Free_WorkspaceEditPDU_planeEdits_Set_planeAttributes(&(val)->planeAttributes);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_planeEdits(ASN1encoding_t enc, PWorkspaceEditPDU_planeEdits *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceEditPDU_planeEdits_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_planeEdits_ElmFn(ASN1encoding_t enc, PWorkspaceEditPDU_planeEdits val)
{
    if (!ASN1Enc_WorkspaceEditPDU_planeEdits_Set(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_planeEdits(ASN1decoding_t dec, PWorkspaceEditPDU_planeEdits *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceEditPDU_planeEdits_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_planeEdits_ElmFn(ASN1decoding_t dec, PWorkspaceEditPDU_planeEdits val)
{
    if (!ASN1Dec_WorkspaceEditPDU_planeEdits_Set(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_planeEdits(PWorkspaceEditPDU_planeEdits *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceEditPDU_planeEdits_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_planeEdits_ElmFn(PWorkspaceEditPDU_planeEdits val)
{
    if (val) {
	ASN1Free_WorkspaceEditPDU_planeEdits_Set(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_viewParameters(ASN1encoding_t enc, PWorkspaceCreatePDU_viewParameters *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceCreatePDU_viewParameters_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_viewParameters_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_viewParameters val)
{
    if (!ASN1Enc_WorkspaceCreatePDU_viewParameters_Set(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_viewParameters(ASN1decoding_t dec, PWorkspaceCreatePDU_viewParameters *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceCreatePDU_viewParameters_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_viewParameters_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_viewParameters val)
{
    if (!ASN1Dec_WorkspaceCreatePDU_viewParameters_Set(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_viewParameters(PWorkspaceCreatePDU_viewParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceCreatePDU_viewParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_viewParameters_ElmFn(PWorkspaceCreatePDU_viewParameters val)
{
    if (val) {
	ASN1Free_WorkspaceCreatePDU_viewParameters_Set(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_planeParameters(ASN1encoding_t enc, PWorkspaceCreatePDU_planeParameters *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceCreatePDU_planeParameters_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_planeParameters_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_planeParameters val)
{
    if (!ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_planeParameters(ASN1decoding_t dec, PWorkspaceCreatePDU_planeParameters *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceCreatePDU_planeParameters_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_planeParameters_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_planeParameters val)
{
    if (!ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_planeParameters(PWorkspaceCreatePDU_planeParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceCreatePDU_planeParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_planeParameters_ElmFn(PWorkspaceCreatePDU_planeParameters val)
{
    if (val) {
	ASN1Free_WorkspaceCreatePDU_planeParameters_Seq(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_protectedPlaneAccessList(ASN1encoding_t enc, PWorkspaceCreatePDU_protectedPlaneAccessList *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceCreatePDU_protectedPlaneAccessList_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_protectedPlaneAccessList_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_protectedPlaneAccessList val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_protectedPlaneAccessList(ASN1decoding_t dec, PWorkspaceCreatePDU_protectedPlaneAccessList *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceCreatePDU_protectedPlaneAccessList_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_protectedPlaneAccessList_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_protectedPlaneAccessList val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1001;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_protectedPlaneAccessList(PWorkspaceCreatePDU_protectedPlaneAccessList *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceCreatePDU_protectedPlaneAccessList_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_protectedPlaneAccessList_ElmFn(PWorkspaceCreatePDU_protectedPlaneAccessList val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_BitmapCreatePDU_checkpoints(ASN1encoding_t enc, PBitmapCreatePDU_checkpoints *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BitmapCreatePDU_checkpoints_ElmFn, 1, 100, 7);
}

static int ASN1CALL ASN1Enc_BitmapCreatePDU_checkpoints_ElmFn(ASN1encoding_t enc, PBitmapCreatePDU_checkpoints val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapCreatePDU_checkpoints(ASN1decoding_t dec, PBitmapCreatePDU_checkpoints *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BitmapCreatePDU_checkpoints_ElmFn, sizeof(**val), 1, 100, 7);
}

static int ASN1CALL ASN1Dec_BitmapCreatePDU_checkpoints_ElmFn(ASN1decoding_t dec, PBitmapCreatePDU_checkpoints val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1;
    return 1;
}

static void ASN1CALL ASN1Free_BitmapCreatePDU_checkpoints(PBitmapCreatePDU_checkpoints *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BitmapCreatePDU_checkpoints_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BitmapCreatePDU_checkpoints_ElmFn(PBitmapCreatePDU_checkpoints val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_BitmapCheckpointPDU_passedCheckpoints(ASN1encoding_t enc, PBitmapCheckpointPDU_passedCheckpoints *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BitmapCheckpointPDU_passedCheckpoints_ElmFn, 1, 100, 7);
}

static int ASN1CALL ASN1Enc_BitmapCheckpointPDU_passedCheckpoints_ElmFn(ASN1encoding_t enc, PBitmapCheckpointPDU_passedCheckpoints val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapCheckpointPDU_passedCheckpoints(ASN1decoding_t dec, PBitmapCheckpointPDU_passedCheckpoints *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BitmapCheckpointPDU_passedCheckpoints_ElmFn, sizeof(**val), 1, 100, 7);
}

static int ASN1CALL ASN1Dec_BitmapCheckpointPDU_passedCheckpoints_ElmFn(ASN1decoding_t dec, PBitmapCheckpointPDU_passedCheckpoints val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1;
    return 1;
}

static void ASN1CALL ASN1Free_BitmapCheckpointPDU_passedCheckpoints(PBitmapCheckpointPDU_passedCheckpoints *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BitmapCheckpointPDU_passedCheckpoints_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BitmapCheckpointPDU_passedCheckpoints_ElmFn(PBitmapCheckpointPDU_passedCheckpoints val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_WorkspaceIdentifier_archiveWorkspace(ASN1encoding_t enc, WorkspaceIdentifier_archiveWorkspace *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    l = ASN1uint32_uoctets((val)->archiveHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->archiveHandle))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, ((val)->entryName).length - 1))
	return 0;
    if (!ASN1PEREncChar16String(enc, ((val)->entryName).length, ((val)->entryName).value, 16))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncGeneralizedTime(enc, &(val)->modificationTime, 8))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceIdentifier_archiveWorkspace(ASN1decoding_t dec, WorkspaceIdentifier_archiveWorkspace *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->archiveHandle))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &((val)->entryName).length))
	return 0;
    ((val)->entryName).length += 1;
    if (!ASN1PERDecChar16String(dec, ((val)->entryName).length, &((val)->entryName).value, 16))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecGeneralizedTime(dec, &(val)->modificationTime, 8))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceIdentifier_archiveWorkspace(WorkspaceIdentifier_archiveWorkspace *val)
{
    if (val) {
	ASN1char16string_free(&(val)->entryName);
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_PixelAspectRatio_general(ASN1encoding_t enc, PixelAspectRatio_general *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->numerator - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->denominator - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PixelAspectRatio_general(ASN1decoding_t dec, PixelAspectRatio_general *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->numerator))
	return 0;
    (val)->numerator += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->denominator))
	return 0;
    (val)->denominator += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_EditablePlaneCopyDescriptor_objectList(ASN1encoding_t enc, PEditablePlaneCopyDescriptor_objectList *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_EditablePlaneCopyDescriptor_objectList_ElmFn);
}

static int ASN1CALL ASN1Enc_EditablePlaneCopyDescriptor_objectList_ElmFn(ASN1encoding_t enc, PEditablePlaneCopyDescriptor_objectList val)
{
    if (!ASN1Enc_EditablePlaneCopyDescriptor_objectList_Seq(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EditablePlaneCopyDescriptor_objectList(ASN1decoding_t dec, PEditablePlaneCopyDescriptor_objectList *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_EditablePlaneCopyDescriptor_objectList_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_EditablePlaneCopyDescriptor_objectList_ElmFn(ASN1decoding_t dec, PEditablePlaneCopyDescriptor_objectList val)
{
    if (!ASN1Dec_EditablePlaneCopyDescriptor_objectList_Seq(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EditablePlaneCopyDescriptor_objectList(PEditablePlaneCopyDescriptor_objectList *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_EditablePlaneCopyDescriptor_objectList_ElmFn);
    }
}

static void ASN1CALL ASN1Free_EditablePlaneCopyDescriptor_objectList_ElmFn(PEditablePlaneCopyDescriptor_objectList val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementGreyscale_generalGreyscaleParameters(ASN1encoding_t enc, ColorAccuracyEnhancementGreyscale_generalGreyscaleParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncDouble(enc, (val)->gamma))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementGreyscale_generalGreyscaleParameters(ASN1decoding_t dec, ColorAccuracyEnhancementGreyscale_generalGreyscaleParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecDouble(dec, &(val)->gamma))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementCIELab_generalCIELabParameters(ASN1encoding_t enc, ColorAccuracyEnhancementCIELab_generalCIELabParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedInteger(enc, (val)->colorTemperature))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_ColorAccuracyEnhancementCIELab_generalCIELabParameters_gamut(enc, &(val)->gamut))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementCIELab_generalCIELabParameters(ASN1decoding_t dec, ColorAccuracyEnhancementCIELab_generalCIELabParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedInteger(dec, &(val)->colorTemperature))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_ColorAccuracyEnhancementCIELab_generalCIELabParameters_gamut(dec, &(val)->gamut))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_BitmapRegion_lowerRight(ASN1encoding_t enc, BitmapRegion_lowerRight *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->xCoordinate))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->yCoordinate))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapRegion_lowerRight(ASN1decoding_t dec, BitmapRegion_lowerRight *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->xCoordinate))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->yCoordinate))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_BitmapRegion_upperLeft(ASN1encoding_t enc, BitmapRegion_upperLeft *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->xCoordinate))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->yCoordinate))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapRegion_upperLeft(ASN1decoding_t dec, BitmapRegion_upperLeft *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->xCoordinate))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->yCoordinate))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_BitmapData_dataCheckpoint(ASN1encoding_t enc, PBitmapData_dataCheckpoint *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BitmapData_dataCheckpoint_ElmFn, 1, 100, 7);
}

static int ASN1CALL ASN1Enc_BitmapData_dataCheckpoint_ElmFn(ASN1encoding_t enc, PBitmapData_dataCheckpoint val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapData_dataCheckpoint(ASN1decoding_t dec, PBitmapData_dataCheckpoint *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BitmapData_dataCheckpoint_ElmFn, sizeof(**val), 1, 100, 7);
}

static int ASN1CALL ASN1Dec_BitmapData_dataCheckpoint_ElmFn(ASN1decoding_t dec, PBitmapData_dataCheckpoint val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1;
    return 1;
}

static void ASN1CALL ASN1Free_BitmapData_dataCheckpoint(PBitmapData_dataCheckpoint *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BitmapData_dataCheckpoint_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BitmapData_dataCheckpoint_ElmFn(PBitmapData_dataCheckpoint val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_BitmapData(ASN1encoding_t enc, BitmapData *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_BitmapData_dataCheckpoint(enc, &(val)->dataCheckpoint))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->padBits - 1))
	    return 0;
    }
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->data, 1, 8192, 16))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapData(ASN1decoding_t dec, BitmapData *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_BitmapData_dataCheckpoint(dec, &(val)->dataCheckpoint))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->padBits))
	    return 0;
	(val)->padBits += 1;
    }
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->data, 1, 8192, 16))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapData(BitmapData *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_BitmapData_dataCheckpoint(&(val)->dataCheckpoint);
	}
    }
}

static int ASN1CALL ASN1Enc_BitmapHeaderT4(ASN1encoding_t enc, BitmapHeaderT4 *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->twoDimensionalEncoding))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapHeaderT4(ASN1decoding_t dec, BitmapHeaderT4 *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->twoDimensionalEncoding))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_BitmapHeaderT6(ASN1encoding_t enc, BitmapHeaderT6 *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapHeaderT6(ASN1decoding_t dec, BitmapHeaderT6 *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_BitmapRegion(ASN1encoding_t enc, BitmapRegion *val)
{
    if (!ASN1Enc_BitmapRegion_upperLeft(enc, &(val)->upperLeft))
	return 0;
    if (!ASN1Enc_BitmapRegion_lowerRight(enc, &(val)->lowerRight))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapRegion(ASN1decoding_t dec, BitmapRegion *val)
{
    if (!ASN1Dec_BitmapRegion_upperLeft(dec, &(val)->upperLeft))
	return 0;
    if (!ASN1Dec_BitmapRegion_lowerRight(dec, &(val)->lowerRight))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_BitmapSize(ASN1encoding_t enc, BitmapSize *val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, (val)->width - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, (val)->height - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapSize(ASN1decoding_t dec, BitmapSize *val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &(val)->width))
	return 0;
    (val)->width += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &(val)->height))
	return 0;
    (val)->height += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_ColorCIELab(ASN1encoding_t enc, ColorCIELab *val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->l))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->a))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->b))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ColorCIELab(ASN1decoding_t dec, ColorCIELab *val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->l))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->a))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->b))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ColorCIExyChromaticity(ASN1encoding_t enc, ColorCIExyChromaticity *val)
{
    if (!ASN1PEREncDouble(enc, (val)->x))
	return 0;
    if (!ASN1PEREncDouble(enc, (val)->y))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ColorCIExyChromaticity(ASN1decoding_t dec, ColorCIExyChromaticity *val)
{
    if (!ASN1PERDecDouble(dec, &(val)->x))
	return 0;
    if (!ASN1PERDecDouble(dec, &(val)->y))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ColorIndexTable(ASN1encoding_t enc, PColorIndexTable *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ColorIndexTable_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_ColorIndexTable_ElmFn(ASN1encoding_t enc, PColorIndexTable val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ColorIndexTable(ASN1decoding_t dec, PColorIndexTable *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ColorIndexTable_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_ColorIndexTable_ElmFn(ASN1decoding_t dec, PColorIndexTable val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ColorIndexTable(PColorIndexTable *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ColorIndexTable_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ColorIndexTable_ElmFn(PColorIndexTable val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ColorRGB(ASN1encoding_t enc, ColorRGB *val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->r))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->g))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->b))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ColorRGB(ASN1decoding_t dec, ColorRGB *val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->r))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->g))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->b))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ColorYCbCr(ASN1encoding_t enc, ColorYCbCr *val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->y))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->cb))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->cr))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ColorYCbCr(ASN1decoding_t dec, ColorYCbCr *val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->cb))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->cr))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_DSMCCTap(ASN1encoding_t enc, DSMCCTap *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->use))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->id))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->associationTag))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->selector, 1, 256, 8))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DSMCCTap(ASN1decoding_t dec, DSMCCTap *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->use))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->id))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->associationTag))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->selector, 1, 256, 8))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DSMCCTap(DSMCCTap *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_NonStandardIdentifier(ASN1encoding_t enc, NonStandardIdentifier *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->u.h221nonStandard, 4, 255, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardIdentifier(ASN1decoding_t dec, NonStandardIdentifier *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->u.h221nonStandard, 4, 255, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardIdentifier(NonStandardIdentifier *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1objectidentifier_free(&(val)->u.object);
	    break;
	case 2:
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_NonStandardParameter(ASN1encoding_t enc, NonStandardParameter *val)
{
    if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->data))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardParameter(ASN1decoding_t dec, NonStandardParameter *val)
{
    if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->data))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardParameter(NonStandardParameter *val)
{
    if (val) {
	ASN1Free_NonStandardIdentifier(&(val)->nonStandardIdentifier);
	ASN1octetstring_free(&(val)->data);
    }
}

static int ASN1CALL ASN1Enc_PenNib(ASN1encoding_t enc, PenNib *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->u.nonStandardNib))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PenNib(ASN1decoding_t dec, PenNib *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->u.nonStandardNib))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PenNib(PenNib *val)
{
    if (val) {
	switch ((val)->choice) {
	case 3:
	    ASN1Free_NonStandardIdentifier(&(val)->u.nonStandardNib);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_PixelAspectRatio(ASN1encoding_t enc, PixelAspectRatio *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	if (!ASN1Enc_PixelAspectRatio_general(enc, &(val)->u.general))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->u.nonStandardAspectRatio))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PixelAspectRatio(ASN1decoding_t dec, PixelAspectRatio *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	if (!ASN1Dec_PixelAspectRatio_general(dec, &(val)->u.general))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->u.nonStandardAspectRatio))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PixelAspectRatio(PixelAspectRatio *val)
{
    if (val) {
	switch ((val)->choice) {
	case 6:
	    ASN1Free_NonStandardIdentifier(&(val)->u.nonStandardAspectRatio);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_PlaneProtection(ASN1encoding_t enc, PlaneProtection *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->protectedplane))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PlaneProtection(ASN1decoding_t dec, PlaneProtection *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->protectedplane))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_PlaneUsage(ASN1encoding_t enc, PlaneUsage *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->u.nonStandardPlaneUsage))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PlaneUsage(ASN1decoding_t dec, PlaneUsage *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->u.nonStandardPlaneUsage))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PlaneUsage(PlaneUsage *val)
{
    if (val) {
	switch ((val)->choice) {
	case 3:
	    ASN1Free_NonStandardIdentifier(&(val)->u.nonStandardPlaneUsage);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_PointList(ASN1encoding_t enc, PointList *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_PointList_pointsDiff4(enc, &(val)->u.pointsDiff4))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_PointList_pointsDiff8(enc, &(val)->u.pointsDiff8))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_PointList_pointsDiff16(enc, &(val)->u.pointsDiff16))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PointList(ASN1decoding_t dec, PointList *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_PointList_pointsDiff4(dec, &(val)->u.pointsDiff4))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_PointList_pointsDiff8(dec, &(val)->u.pointsDiff8))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_PointList_pointsDiff16(dec, &(val)->u.pointsDiff16))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PointList(PointList *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_PointList_pointsDiff4(&(val)->u.pointsDiff4);
	    break;
	case 2:
	    ASN1Free_PointList_pointsDiff8(&(val)->u.pointsDiff8);
	    break;
	case 3:
	    ASN1Free_PointList_pointsDiff16(&(val)->u.pointsDiff16);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_PointDiff4(ASN1encoding_t enc, PointDiff4 *val)
{
    if (!ASN1PEREncBitVal(enc, 4, (val)->xCoordinate + 8))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->yCoordinate + 8))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PointDiff4(ASN1decoding_t dec, PointDiff4 *val)
{
    if (!ASN1PERDecU8Val(dec, 4, &(val)->xCoordinate))
	return 0;
    (val)->xCoordinate += 0 - 8;
    if (!ASN1PERDecU8Val(dec, 4, &(val)->yCoordinate))
	return 0;
    (val)->yCoordinate += 0 - 8;
    return 1;
}

static int ASN1CALL ASN1Enc_PointDiff8(ASN1encoding_t enc, PointDiff8 *val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->xCoordinate + 128))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->yCoordinate + 128))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PointDiff8(ASN1decoding_t dec, PointDiff8 *val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU8Val(dec, 8, &(val)->xCoordinate))
	return 0;
    (val)->xCoordinate += 0 - 128;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU8Val(dec, 8, &(val)->yCoordinate))
	return 0;
    (val)->yCoordinate += 0 - 128;
    return 1;
}

static int ASN1CALL ASN1Enc_PointDiff16(ASN1encoding_t enc, PointDiff16 *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->xCoordinate + 32768))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->yCoordinate + 32768))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PointDiff16(ASN1decoding_t dec, PointDiff16 *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->xCoordinate))
	return 0;
    (val)->xCoordinate += 0 - 32768;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->yCoordinate))
	return 0;
    (val)->yCoordinate += 0 - 32768;
    return 1;
}

static int ASN1CALL ASN1Enc_RemoteEventDestinationAddress(ASN1encoding_t enc, RemoteEventDestinationAddress *val)
{
    ASN1uint32_t l;
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 0, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	l = ASN1uint32_uoctets((val)->u.softCopyWorkspace);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->u.softCopyWorkspace))
	    return 0;
	break;
    case 2:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_NonStandardParameter(ee, &(val)->u.nonStandardDestination))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteEventDestinationAddress(ASN1decoding_t dec, RemoteEventDestinationAddress *val)
{
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 0, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->u.softCopyWorkspace))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_NonStandardParameter(dd, &(val)->u.nonStandardDestination))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RemoteEventDestinationAddress(RemoteEventDestinationAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardDestination);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RemoteEventPermission(ASN1encoding_t enc, RemoteEventPermission *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->u.nonStandardEvent))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteEventPermission(ASN1decoding_t dec, RemoteEventPermission *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->u.nonStandardEvent))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RemoteEventPermission(RemoteEventPermission *val)
{
    if (val) {
	switch ((val)->choice) {
	case 3:
	    ASN1Free_NonStandardIdentifier(&(val)->u.nonStandardEvent);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RotationSpecifier(ASN1encoding_t enc, RotationSpecifier *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->rotationAngle))
	return 0;
    if (!ASN1Enc_PointDiff16(enc, &(val)->rotationAxis))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RotationSpecifier(ASN1decoding_t dec, RotationSpecifier *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->rotationAngle))
	return 0;
    if (!ASN1Dec_PointDiff16(dec, &(val)->rotationAxis))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_SoftCopyDataPlaneAddress(ASN1encoding_t enc, SoftCopyDataPlaneAddress *val)
{
    ASN1uint32_t l;
    l = ASN1uint32_uoctets((val)->workspaceHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->workspaceHandle))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->plane))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SoftCopyDataPlaneAddress(ASN1decoding_t dec, SoftCopyDataPlaneAddress *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->workspaceHandle))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->plane))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_SoftCopyPointerPlaneAddress(ASN1encoding_t enc, SoftCopyPointerPlaneAddress *val)
{
    ASN1uint32_t l;
    l = ASN1uint32_uoctets((val)->workspaceHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->workspaceHandle))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SoftCopyPointerPlaneAddress(ASN1decoding_t dec, SoftCopyPointerPlaneAddress *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->workspaceHandle))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_SourceDisplayIndicator(ASN1encoding_t enc, SourceDisplayIndicator *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncDouble(enc, (val)->displayAspectRatio))
	return 0;
    if (!ASN1PEREncDouble(enc, (val)->horizontalSizeRatio))
	return 0;
    if (!ASN1PEREncDouble(enc, (val)->horizontalPosition))
	return 0;
    if (!ASN1PEREncDouble(enc, (val)->verticalPosition))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SourceDisplayIndicator(ASN1decoding_t dec, SourceDisplayIndicator *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecDouble(dec, &(val)->displayAspectRatio))
	return 0;
    if (!ASN1PERDecDouble(dec, &(val)->horizontalSizeRatio))
	return 0;
    if (!ASN1PERDecDouble(dec, &(val)->horizontalPosition))
	return 0;
    if (!ASN1PERDecDouble(dec, &(val)->verticalPosition))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ViewState(ASN1encoding_t enc, ViewState *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->u.nonStandardViewState))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ViewState(ASN1decoding_t dec, ViewState *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->u.nonStandardViewState))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ViewState(ViewState *val)
{
    if (val) {
	switch ((val)->choice) {
	case 4:
	    ASN1Free_NonStandardIdentifier(&(val)->u.nonStandardViewState);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceColor(ASN1encoding_t enc, WorkspaceColor *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.workspacePaletteIndex))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ColorRGB(enc, &(val)->u.rgbTrueColor))
	    return 0;
	break;
    case 3:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceColor(ASN1decoding_t dec, WorkspaceColor *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.workspacePaletteIndex))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ColorRGB(dec, &(val)->u.rgbTrueColor))
	    return 0;
	break;
    case 3:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_WorkspaceDeleteReason(ASN1encoding_t enc, WorkspaceDeleteReason *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardReason))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceDeleteReason(ASN1decoding_t dec, WorkspaceDeleteReason *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardReason))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceDeleteReason(WorkspaceDeleteReason *val)
{
    if (val) {
	switch ((val)->choice) {
	case 3:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardReason);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceIdentifier(ASN1encoding_t enc, WorkspaceIdentifier *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	l = ASN1uint32_uoctets((val)->u.activeWorkspace);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->u.activeWorkspace))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_WorkspaceIdentifier_archiveWorkspace(enc, &(val)->u.archiveWorkspace))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceIdentifier(ASN1decoding_t dec, WorkspaceIdentifier *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->u.activeWorkspace))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_WorkspaceIdentifier_archiveWorkspace(dec, &(val)->u.archiveWorkspace))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceIdentifier(WorkspaceIdentifier *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_WorkspaceIdentifier_archiveWorkspace(&(val)->u.archiveWorkspace);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspacePoint(ASN1encoding_t enc, WorkspacePoint *val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, (val)->xCoordinate + 21845))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, (val)->yCoordinate + 21845))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspacePoint(ASN1decoding_t dec, WorkspacePoint *val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &(val)->xCoordinate))
	return 0;
    (val)->xCoordinate += 0 - 21845;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &(val)->yCoordinate))
	return 0;
    (val)->yCoordinate += 0 - 21845;
    return 1;
}

static int ASN1CALL ASN1Enc_WorkspaceRegion(ASN1encoding_t enc, WorkspaceRegion *val)
{
    if (!ASN1Enc_WorkspacePoint(enc, &(val)->upperLeft))
	return 0;
    if (!ASN1Enc_WorkspacePoint(enc, &(val)->lowerRight))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceRegion(ASN1decoding_t dec, WorkspaceRegion *val)
{
    if (!ASN1Dec_WorkspacePoint(dec, &(val)->upperLeft))
	return 0;
    if (!ASN1Dec_WorkspacePoint(dec, &(val)->lowerRight))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_WorkspaceSize(ASN1encoding_t enc, WorkspaceSize *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->width - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->height - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceSize(ASN1decoding_t dec, WorkspaceSize *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->width))
	return 0;
    (val)->width += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->height))
	return 0;
    (val)->height += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_WorkspaceViewState(ASN1encoding_t enc, WorkspaceViewState *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->u.nonStandardState))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceViewState(ASN1decoding_t dec, WorkspaceViewState *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->u.nonStandardState))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceViewState(WorkspaceViewState *val)
{
    if (val) {
	switch ((val)->choice) {
	case 5:
	    ASN1Free_NonStandardIdentifier(&(val)->u.nonStandardState);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_BitmapCheckpointPDU(ASN1encoding_t enc, BitmapCheckpointPDU *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    l = ASN1uint32_uoctets((val)->bitmapHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bitmapHandle))
	return 0;
    if (!ASN1Enc_BitmapCheckpointPDU_passedCheckpoints(enc, &(val)->passedCheckpoints))
	return 0;
    if (!ASN1PEREncBitVal(enc, 7, (val)->percentComplete - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_BitmapCheckpointPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapCheckpointPDU(ASN1decoding_t dec, BitmapCheckpointPDU *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bitmapHandle))
	return 0;
    if (!ASN1Dec_BitmapCheckpointPDU_passedCheckpoints(dec, &(val)->passedCheckpoints))
	return 0;
    if (!ASN1PERDecU16Val(dec, 7, &(val)->percentComplete))
	return 0;
    (val)->percentComplete += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_BitmapCheckpointPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapCheckpointPDU(BitmapCheckpointPDU *val)
{
    if (val) {
	ASN1Free_BitmapCheckpointPDU_passedCheckpoints(&(val)->passedCheckpoints);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_BitmapCheckpointPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_BitmapCreateContinuePDU(ASN1encoding_t enc, BitmapCreateContinuePDU *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    l = ASN1uint32_uoctets((val)->bitmapHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bitmapHandle))
	return 0;
    if (!ASN1Enc_BitmapData(enc, &(val)->bitmapData))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->moreToFollow))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_BitmapCreateContinuePDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapCreateContinuePDU(ASN1decoding_t dec, BitmapCreateContinuePDU *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bitmapHandle))
	return 0;
    if (!ASN1Dec_BitmapData(dec, &(val)->bitmapData))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->moreToFollow))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_BitmapCreateContinuePDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapCreateContinuePDU(BitmapCreateContinuePDU *val)
{
    if (val) {
	ASN1Free_BitmapData(&(val)->bitmapData);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_BitmapCreateContinuePDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_BitmapDeletePDU(ASN1encoding_t enc, BitmapDeletePDU *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    l = ASN1uint32_uoctets((val)->bitmapHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bitmapHandle))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_BitmapDeletePDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapDeletePDU(ASN1decoding_t dec, BitmapDeletePDU *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bitmapHandle))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_BitmapDeletePDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapDeletePDU(BitmapDeletePDU *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_BitmapDeletePDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_BitmapEditPDU(ASN1encoding_t enc, BitmapEditPDU *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 5, (val)->o))
	return 0;
    l = ASN1uint32_uoctets((val)->bitmapHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bitmapHandle))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_BitmapEditPDU_attributeEdits(enc, &(val)->attributeEdits))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_WorkspacePoint(enc, &(val)->anchorPointEdit))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_BitmapRegion(enc, &(val)->bitmapRegionOfInterestEdit))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_PointDiff16(enc, &(val)->scalingEdit))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_BitmapEditPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapEditPDU(ASN1decoding_t dec, BitmapEditPDU *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bitmapHandle))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_BitmapEditPDU_attributeEdits(dec, &(val)->attributeEdits))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_WorkspacePoint(dec, &(val)->anchorPointEdit))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_BitmapRegion(dec, &(val)->bitmapRegionOfInterestEdit))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_PointDiff16(dec, &(val)->scalingEdit))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_BitmapEditPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapEditPDU(BitmapEditPDU *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_BitmapEditPDU_attributeEdits(&(val)->attributeEdits);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_BitmapEditPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_ConductorPrivilegeGrantPDU(ASN1encoding_t enc, ConductorPrivilegeGrantPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->destinationUserID - 1001))
	return 0;
    if (!ASN1Enc_ConductorPrivilegeGrantPDU_privilegeList(enc, &(val)->privilegeList))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ConductorPrivilegeGrantPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConductorPrivilegeGrantPDU(ASN1decoding_t dec, ConductorPrivilegeGrantPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->destinationUserID))
	return 0;
    (val)->destinationUserID += 1001;
    if (!ASN1Dec_ConductorPrivilegeGrantPDU_privilegeList(dec, &(val)->privilegeList))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ConductorPrivilegeGrantPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConductorPrivilegeGrantPDU(ConductorPrivilegeGrantPDU *val)
{
    if (val) {
	ASN1Free_ConductorPrivilegeGrantPDU_privilegeList(&(val)->privilegeList);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ConductorPrivilegeGrantPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_ConductorPrivilegeRequestPDU(ASN1encoding_t enc, ConductorPrivilegeRequestPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_ConductorPrivilegeRequestPDU_privilegeList(enc, &(val)->privilegeList))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ConductorPrivilegeRequestPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConductorPrivilegeRequestPDU(ASN1decoding_t dec, ConductorPrivilegeRequestPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_ConductorPrivilegeRequestPDU_privilegeList(dec, &(val)->privilegeList))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ConductorPrivilegeRequestPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConductorPrivilegeRequestPDU(ConductorPrivilegeRequestPDU *val)
{
    if (val) {
	ASN1Free_ConductorPrivilegeRequestPDU_privilegeList(&(val)->privilegeList);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ConductorPrivilegeRequestPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_DrawingDeletePDU(ASN1encoding_t enc, DrawingDeletePDU *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    l = ASN1uint32_uoctets((val)->drawingHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->drawingHandle))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_DrawingDeletePDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DrawingDeletePDU(ASN1decoding_t dec, DrawingDeletePDU *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->drawingHandle))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_DrawingDeletePDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DrawingDeletePDU(DrawingDeletePDU *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_DrawingDeletePDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_FontPDU(ASN1encoding_t enc, FontPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_FontPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_FontPDU(ASN1decoding_t dec, FontPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_FontPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_FontPDU(FontPDU *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_FontPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_RemoteEventPermissionGrantPDU(ASN1encoding_t enc, RemoteEventPermissionGrantPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_RemoteEventDestinationAddress(enc, &(val)->destinationAddress))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->destinationUserID - 1001))
	return 0;
    if (!ASN1Enc_RemoteEventPermissionGrantPDU_remoteEventPermissionList(enc, &(val)->remoteEventPermissionList))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_RemoteEventPermissionGrantPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteEventPermissionGrantPDU(ASN1decoding_t dec, RemoteEventPermissionGrantPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_RemoteEventDestinationAddress(dec, &(val)->destinationAddress))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->destinationUserID))
	return 0;
    (val)->destinationUserID += 1001;
    if (!ASN1Dec_RemoteEventPermissionGrantPDU_remoteEventPermissionList(dec, &(val)->remoteEventPermissionList))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_RemoteEventPermissionGrantPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RemoteEventPermissionGrantPDU(RemoteEventPermissionGrantPDU *val)
{
    if (val) {
	ASN1Free_RemoteEventDestinationAddress(&(val)->destinationAddress);
	ASN1Free_RemoteEventPermissionGrantPDU_remoteEventPermissionList(&(val)->remoteEventPermissionList);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_RemoteEventPermissionGrantPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_RemoteEventPermissionRequestPDU(ASN1encoding_t enc, RemoteEventPermissionRequestPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_RemoteEventDestinationAddress(enc, &(val)->destinationAddress))
	return 0;
    if (!ASN1Enc_RemoteEventPermissionRequestPDU_remoteEventPermissionList(enc, &(val)->remoteEventPermissionList))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_RemoteEventPermissionRequestPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteEventPermissionRequestPDU(ASN1decoding_t dec, RemoteEventPermissionRequestPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_RemoteEventDestinationAddress(dec, &(val)->destinationAddress))
	return 0;
    if (!ASN1Dec_RemoteEventPermissionRequestPDU_remoteEventPermissionList(dec, &(val)->remoteEventPermissionList))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_RemoteEventPermissionRequestPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RemoteEventPermissionRequestPDU(RemoteEventPermissionRequestPDU *val)
{
    if (val) {
	ASN1Free_RemoteEventDestinationAddress(&(val)->destinationAddress);
	ASN1Free_RemoteEventPermissionRequestPDU_remoteEventPermissionList(&(val)->remoteEventPermissionList);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_RemoteEventPermissionRequestPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_RemotePrintPDU(ASN1encoding_t enc, RemotePrintPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
	return 0;
    if (!ASN1Enc_RemoteEventDestinationAddress(enc, &(val)->destinationAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 16, (val)->numberOfCopies - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBoolean(enc, (val)->portrait))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_WorkspaceRegion(enc, &(val)->regionOfInterest))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_RemotePrintPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RemotePrintPDU(ASN1decoding_t dec, RemotePrintPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1Dec_RemoteEventDestinationAddress(dec, &(val)->destinationAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 16, &(val)->numberOfCopies))
	    return 0;
	(val)->numberOfCopies += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecBoolean(dec, &(val)->portrait))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_WorkspaceRegion(dec, &(val)->regionOfInterest))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_RemotePrintPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RemotePrintPDU(RemotePrintPDU *val)
{
    if (val) {
	ASN1Free_RemoteEventDestinationAddress(&(val)->destinationAddress);
	if ((val)->o[0] & 0x10) {
	    ASN1Free_RemotePrintPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_SINonStandardPDU(ASN1encoding_t enc, SINonStandardPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandardTransaction))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SINonStandardPDU(ASN1decoding_t dec, SINonStandardPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandardTransaction))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SINonStandardPDU(SINonStandardPDU *val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&(val)->nonStandardTransaction);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU(ASN1encoding_t enc, WorkspaceCreatePDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
	return 0;
    if (!ASN1Enc_WorkspaceIdentifier(enc, &(val)->workspaceIdentifier))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->appRosterInstance))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->synchronized))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->acceptKeyboardEvents))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->acceptPointingDeviceEvents))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_WorkspaceCreatePDU_protectedPlaneAccessList(enc, &(val)->protectedPlaneAccessList))
	    return 0;
    }
    if (!ASN1Enc_WorkspaceSize(enc, &(val)->workspaceSize))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_WorkspaceCreatePDU_workspaceAttributes(enc, &(val)->workspaceAttributes))
	    return 0;
    }
    if (!ASN1Enc_WorkspaceCreatePDU_planeParameters(enc, &(val)->planeParameters))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_WorkspaceCreatePDU_viewParameters(enc, &(val)->viewParameters))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_WorkspaceCreatePDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU(ASN1decoding_t dec, WorkspaceCreatePDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1Dec_WorkspaceIdentifier(dec, &(val)->workspaceIdentifier))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->appRosterInstance))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->synchronized))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->acceptKeyboardEvents))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->acceptPointingDeviceEvents))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_WorkspaceCreatePDU_protectedPlaneAccessList(dec, &(val)->protectedPlaneAccessList))
	    return 0;
    }
    if (!ASN1Dec_WorkspaceSize(dec, &(val)->workspaceSize))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_WorkspaceCreatePDU_workspaceAttributes(dec, &(val)->workspaceAttributes))
	    return 0;
    }
    if (!ASN1Dec_WorkspaceCreatePDU_planeParameters(dec, &(val)->planeParameters))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_WorkspaceCreatePDU_viewParameters(dec, &(val)->viewParameters))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_WorkspaceCreatePDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU(WorkspaceCreatePDU *val)
{
    if (val) {
	ASN1Free_WorkspaceIdentifier(&(val)->workspaceIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_WorkspaceCreatePDU_protectedPlaneAccessList(&(val)->protectedPlaneAccessList);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_WorkspaceCreatePDU_workspaceAttributes(&(val)->workspaceAttributes);
	}
	ASN1Free_WorkspaceCreatePDU_planeParameters(&(val)->planeParameters);
	if ((val)->o[0] & 0x20) {
	    ASN1Free_WorkspaceCreatePDU_viewParameters(&(val)->viewParameters);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_WorkspaceCreatePDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceCreateAcknowledgePDU(ASN1encoding_t enc, WorkspaceCreateAcknowledgePDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_WorkspaceIdentifier(enc, &(val)->workspaceIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_WorkspaceCreateAcknowledgePDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceCreateAcknowledgePDU(ASN1decoding_t dec, WorkspaceCreateAcknowledgePDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_WorkspaceIdentifier(dec, &(val)->workspaceIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_WorkspaceCreateAcknowledgePDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceCreateAcknowledgePDU(WorkspaceCreateAcknowledgePDU *val)
{
    if (val) {
	ASN1Free_WorkspaceIdentifier(&(val)->workspaceIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_WorkspaceCreateAcknowledgePDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceDeletePDU(ASN1encoding_t enc, WorkspaceDeletePDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_WorkspaceIdentifier(enc, &(val)->workspaceIdentifier))
	return 0;
    if (!ASN1Enc_WorkspaceDeleteReason(enc, &(val)->reason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_WorkspaceDeletePDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceDeletePDU(ASN1decoding_t dec, WorkspaceDeletePDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_WorkspaceIdentifier(dec, &(val)->workspaceIdentifier))
	return 0;
    if (!ASN1Dec_WorkspaceDeleteReason(dec, &(val)->reason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_WorkspaceDeletePDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceDeletePDU(WorkspaceDeletePDU *val)
{
    if (val) {
	ASN1Free_WorkspaceIdentifier(&(val)->workspaceIdentifier);
	ASN1Free_WorkspaceDeleteReason(&(val)->reason);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_WorkspaceDeletePDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU(ASN1encoding_t enc, WorkspaceEditPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
	return 0;
    if (!ASN1Enc_WorkspaceIdentifier(enc, &(val)->workspaceIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_WorkspaceEditPDU_attributeEdits(enc, &(val)->attributeEdits))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_WorkspaceEditPDU_planeEdits(enc, &(val)->planeEdits))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_WorkspaceEditPDU_viewEdits(enc, &(val)->viewEdits))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_WorkspaceEditPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU(ASN1decoding_t dec, WorkspaceEditPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1Dec_WorkspaceIdentifier(dec, &(val)->workspaceIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_WorkspaceEditPDU_attributeEdits(dec, &(val)->attributeEdits))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_WorkspaceEditPDU_planeEdits(dec, &(val)->planeEdits))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_WorkspaceEditPDU_viewEdits(dec, &(val)->viewEdits))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_WorkspaceEditPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU(WorkspaceEditPDU *val)
{
    if (val) {
	ASN1Free_WorkspaceIdentifier(&(val)->workspaceIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_WorkspaceEditPDU_attributeEdits(&(val)->attributeEdits);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_WorkspaceEditPDU_planeEdits(&(val)->planeEdits);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_WorkspaceEditPDU_viewEdits(&(val)->viewEdits);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_WorkspaceEditPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceReadyPDU(ASN1encoding_t enc, WorkspaceReadyPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_WorkspaceIdentifier(enc, &(val)->workspaceIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_WorkspaceReadyPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceReadyPDU(ASN1decoding_t dec, WorkspaceReadyPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_WorkspaceIdentifier(dec, &(val)->workspaceIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_WorkspaceReadyPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceReadyPDU(WorkspaceReadyPDU *val)
{
    if (val) {
	ASN1Free_WorkspaceIdentifier(&(val)->workspaceIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_WorkspaceReadyPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceRefreshStatusPDU(ASN1encoding_t enc, WorkspaceRefreshStatusPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->refreshStatus))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_WorkspaceRefreshStatusPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceRefreshStatusPDU(ASN1decoding_t dec, WorkspaceRefreshStatusPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->refreshStatus))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_WorkspaceRefreshStatusPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceRefreshStatusPDU(WorkspaceRefreshStatusPDU *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_WorkspaceRefreshStatusPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action(ASN1encoding_t enc, WorkspaceEditPDU_viewEdits_Set_action *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action_createNewView(enc, &(val)->u.createNewView))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action_editView(enc, &(val)->u.editView))
	    return 0;
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardAction))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action(ASN1decoding_t dec, WorkspaceEditPDU_viewEdits_Set_action *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action_createNewView(dec, &(val)->u.createNewView))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action_editView(dec, &(val)->u.editView))
	    return 0;
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardAction))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits_Set_action(WorkspaceEditPDU_viewEdits_Set_action *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_WorkspaceEditPDU_viewEdits_Set_action_createNewView(&(val)->u.createNewView);
	    break;
	case 2:
	    ASN1Free_WorkspaceEditPDU_viewEdits_Set_action_editView(&(val)->u.editView);
	    break;
	case 4:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardAction);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq_usage(ASN1encoding_t enc, PWorkspaceCreatePDU_planeParameters_Seq_usage *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq_usage_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq_usage_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_planeParameters_Seq_usage val)
{
    if (!ASN1Enc_PlaneUsage(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq_usage(ASN1decoding_t dec, PWorkspaceCreatePDU_planeParameters_Seq_usage *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq_usage_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq_usage_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_planeParameters_Seq_usage val)
{
    if (!ASN1Dec_PlaneUsage(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_planeParameters_Seq_usage(PWorkspaceCreatePDU_planeParameters_Seq_usage *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceCreatePDU_planeParameters_Seq_usage_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_planeParameters_Seq_usage_ElmFn(PWorkspaceCreatePDU_planeParameters_Seq_usage val)
{
    if (val) {
	ASN1Free_PlaneUsage(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteRGB_palette(ASN1encoding_t enc, PColorPalette_colorLookUpTable_paletteRGB_palette *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ColorPalette_colorLookUpTable_paletteRGB_palette_ElmFn, 2, 256, 8);
}

static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteRGB_palette_ElmFn(ASN1encoding_t enc, PColorPalette_colorLookUpTable_paletteRGB_palette val)
{
    if (!ASN1Enc_ColorRGB(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteRGB_palette(ASN1decoding_t dec, PColorPalette_colorLookUpTable_paletteRGB_palette *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ColorPalette_colorLookUpTable_paletteRGB_palette_ElmFn, sizeof(**val), 2, 256, 8);
}

static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteRGB_palette_ElmFn(ASN1decoding_t dec, PColorPalette_colorLookUpTable_paletteRGB_palette val)
{
    if (!ASN1Dec_ColorRGB(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteRGB_palette(PColorPalette_colorLookUpTable_paletteRGB_palette *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ColorPalette_colorLookUpTable_paletteRGB_palette_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteRGB_palette_ElmFn(PColorPalette_colorLookUpTable_paletteRGB_palette val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteCIELab_palette(ASN1encoding_t enc, PColorPalette_colorLookUpTable_paletteCIELab_palette *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ColorPalette_colorLookUpTable_paletteCIELab_palette_ElmFn, 2, 256, 8);
}

static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteCIELab_palette_ElmFn(ASN1encoding_t enc, PColorPalette_colorLookUpTable_paletteCIELab_palette val)
{
    if (!ASN1Enc_ColorCIELab(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteCIELab_palette(ASN1decoding_t dec, PColorPalette_colorLookUpTable_paletteCIELab_palette *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ColorPalette_colorLookUpTable_paletteCIELab_palette_ElmFn, sizeof(**val), 2, 256, 8);
}

static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteCIELab_palette_ElmFn(ASN1decoding_t dec, PColorPalette_colorLookUpTable_paletteCIELab_palette val)
{
    if (!ASN1Dec_ColorCIELab(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteCIELab_palette(PColorPalette_colorLookUpTable_paletteCIELab_palette *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ColorPalette_colorLookUpTable_paletteCIELab_palette_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteCIELab_palette_ElmFn(PColorPalette_colorLookUpTable_paletteCIELab_palette val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteYCbCr_palette(ASN1encoding_t enc, PColorPalette_colorLookUpTable_paletteYCbCr_palette *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ColorPalette_colorLookUpTable_paletteYCbCr_palette_ElmFn, 2, 256, 8);
}

static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteYCbCr_palette_ElmFn(ASN1encoding_t enc, PColorPalette_colorLookUpTable_paletteYCbCr_palette val)
{
    if (!ASN1Enc_ColorYCbCr(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteYCbCr_palette(ASN1decoding_t dec, PColorPalette_colorLookUpTable_paletteYCbCr_palette *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ColorPalette_colorLookUpTable_paletteYCbCr_palette_ElmFn, sizeof(**val), 2, 256, 8);
}

static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteYCbCr_palette_ElmFn(ASN1decoding_t dec, PColorPalette_colorLookUpTable_paletteYCbCr_palette val)
{
    if (!ASN1Dec_ColorYCbCr(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteYCbCr_palette(PColorPalette_colorLookUpTable_paletteYCbCr_palette *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ColorPalette_colorLookUpTable_paletteYCbCr_palette_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteYCbCr_palette_ElmFn(PColorPalette_colorLookUpTable_paletteYCbCr_palette val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementRGB_generalRGBParameters_primaries(ASN1encoding_t enc, ColorAccuracyEnhancementRGB_generalRGBParameters_primaries *val)
{
    if (!ASN1Enc_ColorCIExyChromaticity(enc, &(val)->red))
	return 0;
    if (!ASN1Enc_ColorCIExyChromaticity(enc, &(val)->green))
	return 0;
    if (!ASN1Enc_ColorCIExyChromaticity(enc, &(val)->blue))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementRGB_generalRGBParameters_primaries(ASN1decoding_t dec, ColorAccuracyEnhancementRGB_generalRGBParameters_primaries *val)
{
    if (!ASN1Dec_ColorCIExyChromaticity(dec, &(val)->red))
	return 0;
    if (!ASN1Dec_ColorCIExyChromaticity(dec, &(val)->green))
	return 0;
    if (!ASN1Dec_ColorCIExyChromaticity(dec, &(val)->blue))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_primaries(ASN1encoding_t enc, ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_primaries *val)
{
    if (!ASN1Enc_ColorCIExyChromaticity(enc, &(val)->red))
	return 0;
    if (!ASN1Enc_ColorCIExyChromaticity(enc, &(val)->green))
	return 0;
    if (!ASN1Enc_ColorCIExyChromaticity(enc, &(val)->blue))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_primaries(ASN1decoding_t dec, ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_primaries *val)
{
    if (!ASN1Dec_ColorCIExyChromaticity(dec, &(val)->red))
	return 0;
    if (!ASN1Dec_ColorCIExyChromaticity(dec, &(val)->green))
	return 0;
    if (!ASN1Dec_ColorCIExyChromaticity(dec, &(val)->blue))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits_Set(ASN1encoding_t enc, WorkspaceEditPDU_viewEdits_Set *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    l = ASN1uint32_uoctets((val)->viewHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->viewHandle))
	return 0;
    if (!ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action(enc, &(val)->action))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits_Set(ASN1decoding_t dec, WorkspaceEditPDU_viewEdits_Set *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->viewHandle))
	return 0;
    if (!ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action(dec, &(val)->action))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits_Set(WorkspaceEditPDU_viewEdits_Set *val)
{
    if (val) {
	ASN1Free_WorkspaceEditPDU_viewEdits_Set_action(&(val)->action);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceRefreshStatusPDU_nonStandardParameters(ASN1encoding_t enc, PWorkspaceRefreshStatusPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceRefreshStatusPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceRefreshStatusPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PWorkspaceRefreshStatusPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceRefreshStatusPDU_nonStandardParameters(ASN1decoding_t dec, PWorkspaceRefreshStatusPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceRefreshStatusPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceRefreshStatusPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PWorkspaceRefreshStatusPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceRefreshStatusPDU_nonStandardParameters(PWorkspaceRefreshStatusPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceRefreshStatusPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceRefreshStatusPDU_nonStandardParameters_ElmFn(PWorkspaceRefreshStatusPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceReadyPDU_nonStandardParameters(ASN1encoding_t enc, PWorkspaceReadyPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceReadyPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceReadyPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PWorkspaceReadyPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceReadyPDU_nonStandardParameters(ASN1decoding_t dec, PWorkspaceReadyPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceReadyPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceReadyPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PWorkspaceReadyPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceReadyPDU_nonStandardParameters(PWorkspaceReadyPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceReadyPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceReadyPDU_nonStandardParameters_ElmFn(PWorkspaceReadyPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspacePlaneCopyPDU_nonStandardParameters(ASN1encoding_t enc, PWorkspacePlaneCopyPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspacePlaneCopyPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspacePlaneCopyPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PWorkspacePlaneCopyPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspacePlaneCopyPDU_nonStandardParameters(ASN1decoding_t dec, PWorkspacePlaneCopyPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspacePlaneCopyPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspacePlaneCopyPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PWorkspacePlaneCopyPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspacePlaneCopyPDU_nonStandardParameters(PWorkspacePlaneCopyPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspacePlaneCopyPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspacePlaneCopyPDU_nonStandardParameters_ElmFn(PWorkspacePlaneCopyPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_nonStandardParameters(ASN1encoding_t enc, PWorkspaceEditPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceEditPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PWorkspaceEditPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_nonStandardParameters(ASN1decoding_t dec, PWorkspaceEditPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceEditPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PWorkspaceEditPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_nonStandardParameters(PWorkspaceEditPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceEditPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_nonStandardParameters_ElmFn(PWorkspaceEditPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits(ASN1encoding_t enc, PWorkspaceEditPDU_viewEdits *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceEditPDU_viewEdits_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits_ElmFn(ASN1encoding_t enc, PWorkspaceEditPDU_viewEdits val)
{
    if (!ASN1Enc_WorkspaceEditPDU_viewEdits_Set(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits(ASN1decoding_t dec, PWorkspaceEditPDU_viewEdits *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceEditPDU_viewEdits_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits_ElmFn(ASN1decoding_t dec, PWorkspaceEditPDU_viewEdits val)
{
    if (!ASN1Dec_WorkspaceEditPDU_viewEdits_Set(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits(PWorkspaceEditPDU_viewEdits *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceEditPDU_viewEdits_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits_ElmFn(PWorkspaceEditPDU_viewEdits val)
{
    if (val) {
	ASN1Free_WorkspaceEditPDU_viewEdits_Set(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceDeletePDU_nonStandardParameters(ASN1encoding_t enc, PWorkspaceDeletePDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceDeletePDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceDeletePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PWorkspaceDeletePDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceDeletePDU_nonStandardParameters(ASN1decoding_t dec, PWorkspaceDeletePDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceDeletePDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceDeletePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PWorkspaceDeletePDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceDeletePDU_nonStandardParameters(PWorkspaceDeletePDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceDeletePDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceDeletePDU_nonStandardParameters_ElmFn(PWorkspaceDeletePDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceCreateAcknowledgePDU_nonStandardParameters(ASN1encoding_t enc, PWorkspaceCreateAcknowledgePDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceCreateAcknowledgePDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceCreateAcknowledgePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PWorkspaceCreateAcknowledgePDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceCreateAcknowledgePDU_nonStandardParameters(ASN1decoding_t dec, PWorkspaceCreateAcknowledgePDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceCreateAcknowledgePDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceCreateAcknowledgePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PWorkspaceCreateAcknowledgePDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceCreateAcknowledgePDU_nonStandardParameters(PWorkspaceCreateAcknowledgePDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceCreateAcknowledgePDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceCreateAcknowledgePDU_nonStandardParameters_ElmFn(PWorkspaceCreateAcknowledgePDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_nonStandardParameters(ASN1encoding_t enc, PWorkspaceCreatePDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceCreatePDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_nonStandardParameters(ASN1decoding_t dec, PWorkspaceCreatePDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceCreatePDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_nonStandardParameters(PWorkspaceCreatePDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceCreatePDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_nonStandardParameters_ElmFn(PWorkspaceCreatePDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TextEditPDU_nonStandardParameters(ASN1encoding_t enc, PTextEditPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_TextEditPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_TextEditPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PTextEditPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TextEditPDU_nonStandardParameters(ASN1decoding_t dec, PTextEditPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_TextEditPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_TextEditPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PTextEditPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TextEditPDU_nonStandardParameters(PTextEditPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_TextEditPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_TextEditPDU_nonStandardParameters_ElmFn(PTextEditPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TextDeletePDU_nonStandardParameters(ASN1encoding_t enc, PTextDeletePDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_TextDeletePDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_TextDeletePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PTextDeletePDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TextDeletePDU_nonStandardParameters(ASN1decoding_t dec, PTextDeletePDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_TextDeletePDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_TextDeletePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PTextDeletePDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TextDeletePDU_nonStandardParameters(PTextDeletePDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_TextDeletePDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_TextDeletePDU_nonStandardParameters_ElmFn(PTextDeletePDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TextCreatePDU_nonStandardParameters(ASN1encoding_t enc, PTextCreatePDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_TextCreatePDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_TextCreatePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PTextCreatePDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TextCreatePDU_nonStandardParameters(ASN1decoding_t dec, PTextCreatePDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_TextCreatePDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_TextCreatePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PTextCreatePDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TextCreatePDU_nonStandardParameters(PTextCreatePDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_TextCreatePDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_TextCreatePDU_nonStandardParameters_ElmFn(PTextCreatePDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RemotePrintPDU_nonStandardParameters(ASN1encoding_t enc, PRemotePrintPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RemotePrintPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_RemotePrintPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PRemotePrintPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RemotePrintPDU_nonStandardParameters(ASN1decoding_t dec, PRemotePrintPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RemotePrintPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RemotePrintPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PRemotePrintPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RemotePrintPDU_nonStandardParameters(PRemotePrintPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RemotePrintPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RemotePrintPDU_nonStandardParameters_ElmFn(PRemotePrintPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RemotePointingDeviceEventPDU_nonStandardParameters(ASN1encoding_t enc, PRemotePointingDeviceEventPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RemotePointingDeviceEventPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_RemotePointingDeviceEventPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PRemotePointingDeviceEventPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RemotePointingDeviceEventPDU_nonStandardParameters(ASN1decoding_t dec, PRemotePointingDeviceEventPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RemotePointingDeviceEventPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RemotePointingDeviceEventPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PRemotePointingDeviceEventPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RemotePointingDeviceEventPDU_nonStandardParameters(PRemotePointingDeviceEventPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RemotePointingDeviceEventPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RemotePointingDeviceEventPDU_nonStandardParameters_ElmFn(PRemotePointingDeviceEventPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RemoteKeyboardEventPDU_nonStandardParameters(ASN1encoding_t enc, PRemoteKeyboardEventPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RemoteKeyboardEventPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_RemoteKeyboardEventPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PRemoteKeyboardEventPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteKeyboardEventPDU_nonStandardParameters(ASN1decoding_t dec, PRemoteKeyboardEventPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RemoteKeyboardEventPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RemoteKeyboardEventPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PRemoteKeyboardEventPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RemoteKeyboardEventPDU_nonStandardParameters(PRemoteKeyboardEventPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RemoteKeyboardEventPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RemoteKeyboardEventPDU_nonStandardParameters_ElmFn(PRemoteKeyboardEventPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RemoteEventPermissionRequestPDU_nonStandardParameters(ASN1encoding_t enc, PRemoteEventPermissionRequestPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RemoteEventPermissionRequestPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_RemoteEventPermissionRequestPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PRemoteEventPermissionRequestPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteEventPermissionRequestPDU_nonStandardParameters(ASN1decoding_t dec, PRemoteEventPermissionRequestPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RemoteEventPermissionRequestPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RemoteEventPermissionRequestPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PRemoteEventPermissionRequestPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RemoteEventPermissionRequestPDU_nonStandardParameters(PRemoteEventPermissionRequestPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RemoteEventPermissionRequestPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RemoteEventPermissionRequestPDU_nonStandardParameters_ElmFn(PRemoteEventPermissionRequestPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RemoteEventPermissionRequestPDU_remoteEventPermissionList(ASN1encoding_t enc, PRemoteEventPermissionRequestPDU_remoteEventPermissionList *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RemoteEventPermissionRequestPDU_remoteEventPermissionList_ElmFn);
}

static int ASN1CALL ASN1Enc_RemoteEventPermissionRequestPDU_remoteEventPermissionList_ElmFn(ASN1encoding_t enc, PRemoteEventPermissionRequestPDU_remoteEventPermissionList val)
{
    if (!ASN1Enc_RemoteEventPermission(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteEventPermissionRequestPDU_remoteEventPermissionList(ASN1decoding_t dec, PRemoteEventPermissionRequestPDU_remoteEventPermissionList *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RemoteEventPermissionRequestPDU_remoteEventPermissionList_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RemoteEventPermissionRequestPDU_remoteEventPermissionList_ElmFn(ASN1decoding_t dec, PRemoteEventPermissionRequestPDU_remoteEventPermissionList val)
{
    if (!ASN1Dec_RemoteEventPermission(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RemoteEventPermissionRequestPDU_remoteEventPermissionList(PRemoteEventPermissionRequestPDU_remoteEventPermissionList *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RemoteEventPermissionRequestPDU_remoteEventPermissionList_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RemoteEventPermissionRequestPDU_remoteEventPermissionList_ElmFn(PRemoteEventPermissionRequestPDU_remoteEventPermissionList val)
{
    if (val) {
	ASN1Free_RemoteEventPermission(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RemoteEventPermissionGrantPDU_nonStandardParameters(ASN1encoding_t enc, PRemoteEventPermissionGrantPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RemoteEventPermissionGrantPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_RemoteEventPermissionGrantPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PRemoteEventPermissionGrantPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteEventPermissionGrantPDU_nonStandardParameters(ASN1decoding_t dec, PRemoteEventPermissionGrantPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RemoteEventPermissionGrantPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RemoteEventPermissionGrantPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PRemoteEventPermissionGrantPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RemoteEventPermissionGrantPDU_nonStandardParameters(PRemoteEventPermissionGrantPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RemoteEventPermissionGrantPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RemoteEventPermissionGrantPDU_nonStandardParameters_ElmFn(PRemoteEventPermissionGrantPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RemoteEventPermissionGrantPDU_remoteEventPermissionList(ASN1encoding_t enc, PRemoteEventPermissionGrantPDU_remoteEventPermissionList *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RemoteEventPermissionGrantPDU_remoteEventPermissionList_ElmFn);
}

static int ASN1CALL ASN1Enc_RemoteEventPermissionGrantPDU_remoteEventPermissionList_ElmFn(ASN1encoding_t enc, PRemoteEventPermissionGrantPDU_remoteEventPermissionList val)
{
    if (!ASN1Enc_RemoteEventPermission(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteEventPermissionGrantPDU_remoteEventPermissionList(ASN1decoding_t dec, PRemoteEventPermissionGrantPDU_remoteEventPermissionList *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RemoteEventPermissionGrantPDU_remoteEventPermissionList_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RemoteEventPermissionGrantPDU_remoteEventPermissionList_ElmFn(ASN1decoding_t dec, PRemoteEventPermissionGrantPDU_remoteEventPermissionList val)
{
    if (!ASN1Dec_RemoteEventPermission(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RemoteEventPermissionGrantPDU_remoteEventPermissionList(PRemoteEventPermissionGrantPDU_remoteEventPermissionList *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RemoteEventPermissionGrantPDU_remoteEventPermissionList_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RemoteEventPermissionGrantPDU_remoteEventPermissionList_ElmFn(PRemoteEventPermissionGrantPDU_remoteEventPermissionList val)
{
    if (val) {
	ASN1Free_RemoteEventPermission(&val->value);
    }
}

static int ASN1CALL ASN1Enc_FontPDU_nonStandardParameters(ASN1encoding_t enc, PFontPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_FontPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_FontPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PFontPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_FontPDU_nonStandardParameters(ASN1decoding_t dec, PFontPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_FontPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_FontPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PFontPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_FontPDU_nonStandardParameters(PFontPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_FontPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_FontPDU_nonStandardParameters_ElmFn(PFontPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DrawingEditPDU_nonStandardParameters(ASN1encoding_t enc, PDrawingEditPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DrawingEditPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_DrawingEditPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PDrawingEditPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DrawingEditPDU_nonStandardParameters(ASN1decoding_t dec, PDrawingEditPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DrawingEditPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DrawingEditPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PDrawingEditPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DrawingEditPDU_nonStandardParameters(PDrawingEditPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DrawingEditPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DrawingEditPDU_nonStandardParameters_ElmFn(PDrawingEditPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DrawingDeletePDU_nonStandardParameters(ASN1encoding_t enc, PDrawingDeletePDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DrawingDeletePDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_DrawingDeletePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PDrawingDeletePDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DrawingDeletePDU_nonStandardParameters(ASN1decoding_t dec, PDrawingDeletePDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DrawingDeletePDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DrawingDeletePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PDrawingDeletePDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DrawingDeletePDU_nonStandardParameters(PDrawingDeletePDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DrawingDeletePDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DrawingDeletePDU_nonStandardParameters_ElmFn(PDrawingDeletePDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DrawingCreatePDU_nonStandardParameters(ASN1encoding_t enc, PDrawingCreatePDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DrawingCreatePDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_DrawingCreatePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PDrawingCreatePDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DrawingCreatePDU_nonStandardParameters(ASN1decoding_t dec, PDrawingCreatePDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DrawingCreatePDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DrawingCreatePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PDrawingCreatePDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DrawingCreatePDU_nonStandardParameters(PDrawingCreatePDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DrawingCreatePDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DrawingCreatePDU_nonStandardParameters_ElmFn(PDrawingCreatePDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConductorPrivilegeRequestPDU_nonStandardParameters(ASN1encoding_t enc, PConductorPrivilegeRequestPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ConductorPrivilegeRequestPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_ConductorPrivilegeRequestPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PConductorPrivilegeRequestPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConductorPrivilegeRequestPDU_nonStandardParameters(ASN1decoding_t dec, PConductorPrivilegeRequestPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ConductorPrivilegeRequestPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ConductorPrivilegeRequestPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PConductorPrivilegeRequestPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConductorPrivilegeRequestPDU_nonStandardParameters(PConductorPrivilegeRequestPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ConductorPrivilegeRequestPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ConductorPrivilegeRequestPDU_nonStandardParameters_ElmFn(PConductorPrivilegeRequestPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConductorPrivilegeGrantPDU_nonStandardParameters(ASN1encoding_t enc, PConductorPrivilegeGrantPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ConductorPrivilegeGrantPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_ConductorPrivilegeGrantPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PConductorPrivilegeGrantPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConductorPrivilegeGrantPDU_nonStandardParameters(ASN1decoding_t dec, PConductorPrivilegeGrantPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ConductorPrivilegeGrantPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ConductorPrivilegeGrantPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PConductorPrivilegeGrantPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConductorPrivilegeGrantPDU_nonStandardParameters(PConductorPrivilegeGrantPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ConductorPrivilegeGrantPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ConductorPrivilegeGrantPDU_nonStandardParameters_ElmFn(PConductorPrivilegeGrantPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BitmapEditPDU_nonStandardParameters(ASN1encoding_t enc, PBitmapEditPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BitmapEditPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_BitmapEditPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PBitmapEditPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapEditPDU_nonStandardParameters(ASN1decoding_t dec, PBitmapEditPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BitmapEditPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BitmapEditPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PBitmapEditPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BitmapEditPDU_nonStandardParameters(PBitmapEditPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BitmapEditPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BitmapEditPDU_nonStandardParameters_ElmFn(PBitmapEditPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BitmapDeletePDU_nonStandardParameters(ASN1encoding_t enc, PBitmapDeletePDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BitmapDeletePDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_BitmapDeletePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PBitmapDeletePDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapDeletePDU_nonStandardParameters(ASN1decoding_t dec, PBitmapDeletePDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BitmapDeletePDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BitmapDeletePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PBitmapDeletePDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BitmapDeletePDU_nonStandardParameters(PBitmapDeletePDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BitmapDeletePDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BitmapDeletePDU_nonStandardParameters_ElmFn(PBitmapDeletePDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BitmapCreateContinuePDU_nonStandardParameters(ASN1encoding_t enc, PBitmapCreateContinuePDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BitmapCreateContinuePDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_BitmapCreateContinuePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PBitmapCreateContinuePDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapCreateContinuePDU_nonStandardParameters(ASN1decoding_t dec, PBitmapCreateContinuePDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BitmapCreateContinuePDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BitmapCreateContinuePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PBitmapCreateContinuePDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BitmapCreateContinuePDU_nonStandardParameters(PBitmapCreateContinuePDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BitmapCreateContinuePDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BitmapCreateContinuePDU_nonStandardParameters_ElmFn(PBitmapCreateContinuePDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BitmapCreatePDU_nonStandardParameters(ASN1encoding_t enc, PBitmapCreatePDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BitmapCreatePDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_BitmapCreatePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PBitmapCreatePDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapCreatePDU_nonStandardParameters(ASN1decoding_t dec, PBitmapCreatePDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BitmapCreatePDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BitmapCreatePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PBitmapCreatePDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BitmapCreatePDU_nonStandardParameters(PBitmapCreatePDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BitmapCreatePDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BitmapCreatePDU_nonStandardParameters_ElmFn(PBitmapCreatePDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BitmapCheckpointPDU_nonStandardParameters(ASN1encoding_t enc, PBitmapCheckpointPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BitmapCheckpointPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_BitmapCheckpointPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PBitmapCheckpointPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapCheckpointPDU_nonStandardParameters(ASN1decoding_t dec, PBitmapCheckpointPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BitmapCheckpointPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BitmapCheckpointPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PBitmapCheckpointPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BitmapCheckpointPDU_nonStandardParameters(PBitmapCheckpointPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BitmapCheckpointPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BitmapCheckpointPDU_nonStandardParameters_ElmFn(PBitmapCheckpointPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BitmapAbortPDU_nonStandardParameters(ASN1encoding_t enc, PBitmapAbortPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BitmapAbortPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_BitmapAbortPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PBitmapAbortPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapAbortPDU_nonStandardParameters(ASN1decoding_t dec, PBitmapAbortPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BitmapAbortPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BitmapAbortPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PBitmapAbortPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BitmapAbortPDU_nonStandardParameters(PBitmapAbortPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BitmapAbortPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BitmapAbortPDU_nonStandardParameters_ElmFn(PBitmapAbortPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ArchiveOpenPDU_nonStandardParameters(ASN1encoding_t enc, PArchiveOpenPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ArchiveOpenPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_ArchiveOpenPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PArchiveOpenPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ArchiveOpenPDU_nonStandardParameters(ASN1decoding_t dec, PArchiveOpenPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ArchiveOpenPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ArchiveOpenPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PArchiveOpenPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ArchiveOpenPDU_nonStandardParameters(PArchiveOpenPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ArchiveOpenPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ArchiveOpenPDU_nonStandardParameters_ElmFn(PArchiveOpenPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ArchiveErrorPDU_nonStandardParameters(ASN1encoding_t enc, PArchiveErrorPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ArchiveErrorPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_ArchiveErrorPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PArchiveErrorPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ArchiveErrorPDU_nonStandardParameters(ASN1decoding_t dec, PArchiveErrorPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ArchiveErrorPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ArchiveErrorPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PArchiveErrorPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ArchiveErrorPDU_nonStandardParameters(PArchiveErrorPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ArchiveErrorPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ArchiveErrorPDU_nonStandardParameters_ElmFn(PArchiveErrorPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ArchiveClosePDU_nonStandardParameters(ASN1encoding_t enc, PArchiveClosePDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ArchiveClosePDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_ArchiveClosePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PArchiveClosePDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ArchiveClosePDU_nonStandardParameters(ASN1decoding_t dec, PArchiveClosePDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ArchiveClosePDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ArchiveClosePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PArchiveClosePDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ArchiveClosePDU_nonStandardParameters(PArchiveClosePDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ArchiveClosePDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ArchiveClosePDU_nonStandardParameters_ElmFn(PArchiveClosePDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ArchiveAcknowledgePDU_nonStandardParameters(ASN1encoding_t enc, PArchiveAcknowledgePDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ArchiveAcknowledgePDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_ArchiveAcknowledgePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PArchiveAcknowledgePDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ArchiveAcknowledgePDU_nonStandardParameters(ASN1decoding_t dec, PArchiveAcknowledgePDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ArchiveAcknowledgePDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ArchiveAcknowledgePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PArchiveAcknowledgePDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ArchiveAcknowledgePDU_nonStandardParameters(PArchiveAcknowledgePDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ArchiveAcknowledgePDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ArchiveAcknowledgePDU_nonStandardParameters_ElmFn(PArchiveAcknowledgePDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceViewAttribute_viewRegion(ASN1encoding_t enc, WorkspaceViewAttribute_viewRegion *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_WorkspaceRegion(enc, &(val)->u.partialWorkspace))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceViewAttribute_viewRegion(ASN1decoding_t dec, WorkspaceViewAttribute_viewRegion *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_WorkspaceRegion(dec, &(val)->u.partialWorkspace))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VideoWindowEditPDU_nonStandardParameters(ASN1encoding_t enc, PVideoWindowEditPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_VideoWindowEditPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_VideoWindowEditPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PVideoWindowEditPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VideoWindowEditPDU_nonStandardParameters(ASN1decoding_t dec, PVideoWindowEditPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_VideoWindowEditPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_VideoWindowEditPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PVideoWindowEditPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_VideoWindowEditPDU_nonStandardParameters(PVideoWindowEditPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_VideoWindowEditPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_VideoWindowEditPDU_nonStandardParameters_ElmFn(PVideoWindowEditPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_VideoWindowDeletePDU_nonStandardParameters(ASN1encoding_t enc, PVideoWindowDeletePDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_VideoWindowDeletePDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_VideoWindowDeletePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PVideoWindowDeletePDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VideoWindowDeletePDU_nonStandardParameters(ASN1decoding_t dec, PVideoWindowDeletePDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_VideoWindowDeletePDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_VideoWindowDeletePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PVideoWindowDeletePDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_VideoWindowDeletePDU_nonStandardParameters(PVideoWindowDeletePDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_VideoWindowDeletePDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_VideoWindowDeletePDU_nonStandardParameters_ElmFn(PVideoWindowDeletePDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_VideoWindowCreatePDU_nonStandardParameters(ASN1encoding_t enc, PVideoWindowCreatePDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_VideoWindowCreatePDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_VideoWindowCreatePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PVideoWindowCreatePDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VideoWindowCreatePDU_nonStandardParameters(ASN1decoding_t dec, PVideoWindowCreatePDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_VideoWindowCreatePDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_VideoWindowCreatePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PVideoWindowCreatePDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_VideoWindowCreatePDU_nonStandardParameters(PVideoWindowCreatePDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_VideoWindowCreatePDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_VideoWindowCreatePDU_nonStandardParameters_ElmFn(PVideoWindowCreatePDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_VideoSourceIdentifier_dSMCCConnBinder(ASN1encoding_t enc, PVideoSourceIdentifier_dSMCCConnBinder *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_VideoSourceIdentifier_dSMCCConnBinder_ElmFn);
}

static int ASN1CALL ASN1Enc_VideoSourceIdentifier_dSMCCConnBinder_ElmFn(ASN1encoding_t enc, PVideoSourceIdentifier_dSMCCConnBinder val)
{
    if (!ASN1Enc_DSMCCTap(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VideoSourceIdentifier_dSMCCConnBinder(ASN1decoding_t dec, PVideoSourceIdentifier_dSMCCConnBinder *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_VideoSourceIdentifier_dSMCCConnBinder_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_VideoSourceIdentifier_dSMCCConnBinder_ElmFn(ASN1decoding_t dec, PVideoSourceIdentifier_dSMCCConnBinder val)
{
    if (!ASN1Dec_DSMCCTap(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_VideoSourceIdentifier_dSMCCConnBinder(PVideoSourceIdentifier_dSMCCConnBinder *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_VideoSourceIdentifier_dSMCCConnBinder_ElmFn);
    }
}

static void ASN1CALL ASN1Free_VideoSourceIdentifier_dSMCCConnBinder_ElmFn(PVideoSourceIdentifier_dSMCCConnBinder val)
{
    if (val) {
	ASN1Free_DSMCCTap(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TransparencyMask_nonStandardParameters(ASN1encoding_t enc, PTransparencyMask_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_TransparencyMask_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_TransparencyMask_nonStandardParameters_ElmFn(ASN1encoding_t enc, PTransparencyMask_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransparencyMask_nonStandardParameters(ASN1decoding_t dec, PTransparencyMask_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_TransparencyMask_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_TransparencyMask_nonStandardParameters_ElmFn(ASN1decoding_t dec, PTransparencyMask_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TransparencyMask_nonStandardParameters(PTransparencyMask_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_TransparencyMask_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_TransparencyMask_nonStandardParameters_ElmFn(PTransparencyMask_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TransparencyMask_bitMask(ASN1encoding_t enc, TransparencyMask_bitMask *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->u.uncompressed))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->u.jbigCompressed))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardFormat))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TransparencyMask_bitMask(ASN1decoding_t dec, TransparencyMask_bitMask *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->u.uncompressed))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->u.jbigCompressed))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardFormat))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransparencyMask_bitMask(TransparencyMask_bitMask *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1octetstring_free(&(val)->u.uncompressed);
	    break;
	case 2:
	    ASN1octetstring_free(&(val)->u.jbigCompressed);
	    break;
	case 3:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardFormat);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_PointListEdits_Seq(ASN1encoding_t enc, PointListEdits_Seq *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->initialIndex))
	return 0;
    if (!ASN1Enc_PointDiff16(enc, &(val)->initialPointEdit))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_PointList(enc, &(val)->subsequentPointEdits))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PointListEdits_Seq(ASN1decoding_t dec, PointListEdits_Seq *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initialIndex))
	return 0;
    if (!ASN1Dec_PointDiff16(dec, &(val)->initialPointEdit))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_PointList(dec, &(val)->subsequentPointEdits))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PointListEdits_Seq(PointListEdits_Seq *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_PointList(&(val)->subsequentPointEdits);
	}
    }
}

static int ASN1CALL ASN1Enc_PointList_pointsDiff16(ASN1encoding_t enc, PPointList_pointsDiff16 *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_PointList_pointsDiff16_ElmFn, 0, 255, 8);
}

static int ASN1CALL ASN1Enc_PointList_pointsDiff16_ElmFn(ASN1encoding_t enc, PPointList_pointsDiff16 val)
{
    if (!ASN1Enc_PointDiff16(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PointList_pointsDiff16(ASN1decoding_t dec, PPointList_pointsDiff16 *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_PointList_pointsDiff16_ElmFn, sizeof(**val), 0, 255, 8);
}

static int ASN1CALL ASN1Dec_PointList_pointsDiff16_ElmFn(ASN1decoding_t dec, PPointList_pointsDiff16 val)
{
    if (!ASN1Dec_PointDiff16(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PointList_pointsDiff16(PPointList_pointsDiff16 *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_PointList_pointsDiff16_ElmFn);
    }
}

static void ASN1CALL ASN1Free_PointList_pointsDiff16_ElmFn(PPointList_pointsDiff16 val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_PointList_pointsDiff8(ASN1encoding_t enc, PPointList_pointsDiff8 *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_PointList_pointsDiff8_ElmFn, 0, 255, 8);
}

static int ASN1CALL ASN1Enc_PointList_pointsDiff8_ElmFn(ASN1encoding_t enc, PPointList_pointsDiff8 val)
{
    if (!ASN1Enc_PointDiff8(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PointList_pointsDiff8(ASN1decoding_t dec, PPointList_pointsDiff8 *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_PointList_pointsDiff8_ElmFn, sizeof(**val), 0, 255, 8);
}

static int ASN1CALL ASN1Dec_PointList_pointsDiff8_ElmFn(ASN1decoding_t dec, PPointList_pointsDiff8 val)
{
    if (!ASN1Dec_PointDiff8(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PointList_pointsDiff8(PPointList_pointsDiff8 *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_PointList_pointsDiff8_ElmFn);
    }
}

static void ASN1CALL ASN1Free_PointList_pointsDiff8_ElmFn(PPointList_pointsDiff8 val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_PointList_pointsDiff4(ASN1encoding_t enc, PPointList_pointsDiff4 *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_PointList_pointsDiff4_ElmFn, 0, 255, 8);
}

static int ASN1CALL ASN1Enc_PointList_pointsDiff4_ElmFn(ASN1encoding_t enc, PPointList_pointsDiff4 val)
{
    if (!ASN1Enc_PointDiff4(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PointList_pointsDiff4(ASN1decoding_t dec, PPointList_pointsDiff4 *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_PointList_pointsDiff4_ElmFn, sizeof(**val), 0, 255, 8);
}

static int ASN1CALL ASN1Dec_PointList_pointsDiff4_ElmFn(ASN1decoding_t dec, PPointList_pointsDiff4 val)
{
    if (!ASN1Dec_PointDiff4(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PointList_pointsDiff4(PPointList_pointsDiff4 *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_PointList_pointsDiff4_ElmFn);
    }
}

static void ASN1CALL ASN1Free_PointList_pointsDiff4_ElmFn(PPointList_pointsDiff4 val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementYCbCr_generalYCbCrParameters(ASN1encoding_t enc, ColorAccuracyEnhancementYCbCr_generalYCbCrParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncDouble(enc, (val)->gamma))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncUnsignedInteger(enc, (val)->colorTemperature))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_primaries(enc, &(val)->primaries))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementYCbCr_generalYCbCrParameters(ASN1decoding_t dec, ColorAccuracyEnhancementYCbCr_generalYCbCrParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecDouble(dec, &(val)->gamma))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecUnsignedInteger(dec, &(val)->colorTemperature))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_primaries(dec, &(val)->primaries))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace(ASN1encoding_t enc, ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardRGBSpace))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace(ASN1decoding_t dec, ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardRGBSpace))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace(ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardRGBSpace);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementRGB_generalRGBParameters(ASN1encoding_t enc, ColorAccuracyEnhancementRGB_generalRGBParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncDouble(enc, (val)->gamma))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncUnsignedInteger(enc, (val)->colorTemperature))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_ColorAccuracyEnhancementRGB_generalRGBParameters_primaries(enc, &(val)->primaries))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementRGB_generalRGBParameters(ASN1decoding_t dec, ColorAccuracyEnhancementRGB_generalRGBParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecDouble(dec, &(val)->gamma))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecUnsignedInteger(dec, &(val)->colorTemperature))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_ColorAccuracyEnhancementRGB_generalRGBParameters_primaries(dec, &(val)->primaries))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementRGB_predefinedRGBSpace(ASN1encoding_t enc, ColorAccuracyEnhancementRGB_predefinedRGBSpace *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardRGBSpace))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementRGB_predefinedRGBSpace(ASN1decoding_t dec, ColorAccuracyEnhancementRGB_predefinedRGBSpace *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardRGBSpace))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorAccuracyEnhancementRGB_predefinedRGBSpace(ColorAccuracyEnhancementRGB_predefinedRGBSpace *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardRGBSpace);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace(ASN1encoding_t enc, ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardGreyscaleSpace))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace(ASN1decoding_t dec, ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardGreyscaleSpace))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace(ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardGreyscaleSpace);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementCIELab_predefinedCIELabSpace(ASN1encoding_t enc, ColorAccuracyEnhancementCIELab_predefinedCIELabSpace *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardCIELabSpace))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementCIELab_predefinedCIELabSpace(ASN1decoding_t dec, ColorAccuracyEnhancementCIELab_predefinedCIELabSpace *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardCIELabSpace))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorAccuracyEnhancementCIELab_predefinedCIELabSpace(ColorAccuracyEnhancementCIELab_predefinedCIELabSpace *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardCIELabSpace);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_BitmapAbortReason(ASN1encoding_t enc, BitmapAbortReason *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardReason))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapAbortReason(ASN1decoding_t dec, BitmapAbortReason *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardReason))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapAbortReason(BitmapAbortReason *val)
{
    if (val) {
	switch ((val)->choice) {
	case 4:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardReason);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_BitmapDestinationAddress(ASN1encoding_t enc, BitmapDestinationAddress *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_SoftCopyDataPlaneAddress(enc, &(val)->u.softCopyImagePlane))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_SoftCopyDataPlaneAddress(enc, &(val)->u.softCopyAnnotationPlane))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_SoftCopyPointerPlaneAddress(enc, &(val)->u.softCopyPointerPlane))
	    return 0;
	break;
    case 5:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_NonStandardParameter(ee, &(val)->u.nonStandardDestination))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapDestinationAddress(ASN1decoding_t dec, BitmapDestinationAddress *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 2, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_SoftCopyDataPlaneAddress(dec, &(val)->u.softCopyImagePlane))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_SoftCopyDataPlaneAddress(dec, &(val)->u.softCopyAnnotationPlane))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_SoftCopyPointerPlaneAddress(dec, &(val)->u.softCopyPointerPlane))
	    return 0;
	break;
    case 5:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_NonStandardParameter(dd, &(val)->u.nonStandardDestination))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapDestinationAddress(BitmapDestinationAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 5:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardDestination);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ButtonEvent(ASN1encoding_t enc, ButtonEvent *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->u.nonStandardButtonEvent))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ButtonEvent(ASN1decoding_t dec, ButtonEvent *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->u.nonStandardButtonEvent))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ButtonEvent(ButtonEvent *val)
{
    if (val) {
	switch ((val)->choice) {
	case 6:
	    ASN1Free_NonStandardIdentifier(&(val)->u.nonStandardButtonEvent);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementCIELab(ASN1encoding_t enc, ColorAccuracyEnhancementCIELab *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ColorAccuracyEnhancementCIELab_predefinedCIELabSpace(enc, &(val)->u.predefinedCIELabSpace))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ColorAccuracyEnhancementCIELab_generalCIELabParameters(enc, &(val)->u.generalCIELabParameters))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementCIELab(ASN1decoding_t dec, ColorAccuracyEnhancementCIELab *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ColorAccuracyEnhancementCIELab_predefinedCIELabSpace(dec, &(val)->u.predefinedCIELabSpace))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ColorAccuracyEnhancementCIELab_generalCIELabParameters(dec, &(val)->u.generalCIELabParameters))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorAccuracyEnhancementCIELab(ColorAccuracyEnhancementCIELab *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ColorAccuracyEnhancementCIELab_predefinedCIELabSpace(&(val)->u.predefinedCIELabSpace);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementGreyscale(ASN1encoding_t enc, ColorAccuracyEnhancementGreyscale *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace(enc, &(val)->u.predefinedGreyscaleSpace))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ColorAccuracyEnhancementGreyscale_generalGreyscaleParameters(enc, &(val)->u.generalGreyscaleParameters))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementGreyscale(ASN1decoding_t dec, ColorAccuracyEnhancementGreyscale *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace(dec, &(val)->u.predefinedGreyscaleSpace))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ColorAccuracyEnhancementGreyscale_generalGreyscaleParameters(dec, &(val)->u.generalGreyscaleParameters))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorAccuracyEnhancementGreyscale(ColorAccuracyEnhancementGreyscale *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace(&(val)->u.predefinedGreyscaleSpace);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementRGB(ASN1encoding_t enc, ColorAccuracyEnhancementRGB *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ColorAccuracyEnhancementRGB_predefinedRGBSpace(enc, &(val)->u.predefinedRGBSpace))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ColorAccuracyEnhancementRGB_generalRGBParameters(enc, &(val)->u.generalRGBParameters))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementRGB(ASN1decoding_t dec, ColorAccuracyEnhancementRGB *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ColorAccuracyEnhancementRGB_predefinedRGBSpace(dec, &(val)->u.predefinedRGBSpace))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ColorAccuracyEnhancementRGB_generalRGBParameters(dec, &(val)->u.generalRGBParameters))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorAccuracyEnhancementRGB(ColorAccuracyEnhancementRGB *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ColorAccuracyEnhancementRGB_predefinedRGBSpace(&(val)->u.predefinedRGBSpace);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementYCbCr(ASN1encoding_t enc, ColorAccuracyEnhancementYCbCr *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace(enc, &(val)->u.predefinedYCbCrSpace))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ColorAccuracyEnhancementYCbCr_generalYCbCrParameters(enc, &(val)->u.generalYCbCrParameters))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementYCbCr(ASN1decoding_t dec, ColorAccuracyEnhancementYCbCr *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace(dec, &(val)->u.predefinedYCbCrSpace))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ColorAccuracyEnhancementYCbCr_generalYCbCrParameters(dec, &(val)->u.generalYCbCrParameters))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorAccuracyEnhancementYCbCr(ColorAccuracyEnhancementYCbCr *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace(&(val)->u.predefinedYCbCrSpace);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ColorResolutionModeSpecifier(ASN1encoding_t enc, ColorResolutionModeSpecifier *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->u.nonStandardResolutionMode))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorResolutionModeSpecifier(ASN1decoding_t dec, ColorResolutionModeSpecifier *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->u.nonStandardResolutionMode))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorResolutionModeSpecifier(ColorResolutionModeSpecifier *val)
{
    if (val) {
	switch ((val)->choice) {
	case 4:
	    ASN1Free_NonStandardIdentifier(&(val)->u.nonStandardResolutionMode);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ConductorPrivilege(ASN1encoding_t enc, ConductorPrivilege *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->u.nonStandardPrivilege))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConductorPrivilege(ASN1decoding_t dec, ConductorPrivilege *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->u.nonStandardPrivilege))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConductorPrivilege(ConductorPrivilege *val)
{
    if (val) {
	switch ((val)->choice) {
	case 9:
	    ASN1Free_NonStandardIdentifier(&(val)->u.nonStandardPrivilege);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_DrawingDestinationAddress(ASN1encoding_t enc, DrawingDestinationAddress *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 0, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_SoftCopyDataPlaneAddress(enc, &(val)->u.softCopyAnnotationPlane))
	    return 0;
	break;
    case 2:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_NonStandardParameter(ee, &(val)->u.nonStandardDestination))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DrawingDestinationAddress(ASN1decoding_t dec, DrawingDestinationAddress *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 0, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_SoftCopyDataPlaneAddress(dec, &(val)->u.softCopyAnnotationPlane))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_NonStandardParameter(dd, &(val)->u.nonStandardDestination))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DrawingDestinationAddress(DrawingDestinationAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardDestination);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_DrawingType(ASN1encoding_t enc, DrawingType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->u.nonStandardDrawingType))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DrawingType(ASN1decoding_t dec, DrawingType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->u.nonStandardDrawingType))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DrawingType(DrawingType *val)
{
    if (val) {
	switch ((val)->choice) {
	case 6:
	    ASN1Free_NonStandardIdentifier(&(val)->u.nonStandardDrawingType);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EditablePlaneCopyDescriptor(ASN1encoding_t enc, EditablePlaneCopyDescriptor *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_EditablePlaneCopyDescriptor_objectList(enc, &(val)->objectList))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_PointDiff16(enc, &(val)->destinationOffset))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->planeClearFlag))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EditablePlaneCopyDescriptor(ASN1decoding_t dec, EditablePlaneCopyDescriptor *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_EditablePlaneCopyDescriptor_objectList(dec, &(val)->objectList))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_PointDiff16(dec, &(val)->destinationOffset))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->planeClearFlag))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EditablePlaneCopyDescriptor(EditablePlaneCopyDescriptor *val)
{
    if (val) {
	ASN1Free_EditablePlaneCopyDescriptor_objectList(&(val)->objectList);
    }
}

static int ASN1CALL ASN1Enc_KeyModifier(ASN1encoding_t enc, KeyModifier *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	break;
    case 10:
	break;
    case 11:
	if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->u.nonStandardModifier))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_KeyModifier(ASN1decoding_t dec, KeyModifier *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	break;
    case 10:
	break;
    case 11:
	if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->u.nonStandardModifier))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_KeyModifier(KeyModifier *val)
{
    if (val) {
	switch ((val)->choice) {
	case 11:
	    ASN1Free_NonStandardIdentifier(&(val)->u.nonStandardModifier);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_LineStyle(ASN1encoding_t enc, LineStyle *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->u.nonStandardStyle))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_LineStyle(ASN1decoding_t dec, LineStyle *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->u.nonStandardStyle))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_LineStyle(LineStyle *val)
{
    if (val) {
	switch ((val)->choice) {
	case 7:
	    ASN1Free_NonStandardIdentifier(&(val)->u.nonStandardStyle);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_PermanentPlaneCopyDescriptor(ASN1encoding_t enc, PermanentPlaneCopyDescriptor *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_WorkspaceRegion(enc, &(val)->sourceRegion))
	return 0;
    if (!ASN1Enc_WorkspaceRegion(enc, &(val)->destinationRegion))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PermanentPlaneCopyDescriptor(ASN1decoding_t dec, PermanentPlaneCopyDescriptor *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_WorkspaceRegion(dec, &(val)->sourceRegion))
	return 0;
    if (!ASN1Dec_WorkspaceRegion(dec, &(val)->destinationRegion))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_PlaneAttribute(ASN1encoding_t enc, PlaneAttribute *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_PlaneProtection(enc, &(val)->u.protection))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardAttribute))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PlaneAttribute(ASN1decoding_t dec, PlaneAttribute *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_PlaneProtection(dec, &(val)->u.protection))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardAttribute))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PlaneAttribute(PlaneAttribute *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardAttribute);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_PointListEdits(ASN1encoding_t enc, PointListEdits *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_PointListEdits_Seq(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PointListEdits(ASN1decoding_t dec, PointListEdits *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_PointListEdits_Seq(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PointListEdits(PointListEdits *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 0; i < (val)->count; i++) {
	    ASN1Free_PointListEdits_Seq(&(val)->value[i]);
	}
    }
}

static int ASN1CALL ASN1Enc_TransparencyMask(ASN1encoding_t enc, TransparencyMask *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_TransparencyMask_bitMask(enc, &(val)->bitMask))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_TransparencyMask_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TransparencyMask(ASN1decoding_t dec, TransparencyMask *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_TransparencyMask_bitMask(dec, &(val)->bitMask))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransparencyMask_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransparencyMask(TransparencyMask *val)
{
    if (val) {
	ASN1Free_TransparencyMask_bitMask(&(val)->bitMask);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransparencyMask_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceAttribute(ASN1encoding_t enc, WorkspaceAttribute *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_WorkspaceColor(enc, &(val)->u.backgroundColor))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncBoolean(enc, (val)->u.preserve))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardAttribute))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceAttribute(ASN1decoding_t dec, WorkspaceAttribute *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_WorkspaceColor(dec, &(val)->u.backgroundColor))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecBoolean(dec, &(val)->u.preserve))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardAttribute))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceAttribute(WorkspaceAttribute *val)
{
    if (val) {
	switch ((val)->choice) {
	case 3:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardAttribute);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceViewAttribute(ASN1encoding_t enc, WorkspaceViewAttribute *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_WorkspaceViewAttribute_viewRegion(enc, &(val)->u.viewRegion))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_WorkspaceViewState(enc, &(val)->u.viewState))
	    return 0;
	break;
    case 3:
	if (!ASN1PEREncBoolean(enc, (val)->u.updatesEnabled))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_SourceDisplayIndicator(enc, &(val)->u.sourceDisplayIndicator))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardAttribute))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceViewAttribute(ASN1decoding_t dec, WorkspaceViewAttribute *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_WorkspaceViewAttribute_viewRegion(dec, &(val)->u.viewRegion))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_WorkspaceViewState(dec, &(val)->u.viewState))
	    return 0;
	break;
    case 3:
	if (!ASN1PERDecBoolean(dec, &(val)->u.updatesEnabled))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_SourceDisplayIndicator(dec, &(val)->u.sourceDisplayIndicator))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardAttribute))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceViewAttribute(WorkspaceViewAttribute *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_WorkspaceViewState(&(val)->u.viewState);
	    break;
	case 5:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardAttribute);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_BitmapAbortPDU(ASN1encoding_t enc, BitmapAbortPDU *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
	return 0;
    l = ASN1uint32_uoctets((val)->bitmapHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bitmapHandle))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->userID - 1001))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_BitmapAbortReason(enc, &(val)->reason))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->message).length - 1))
	    return 0;
	if (!ASN1PEREncChar16String(enc, ((val)->message).length, ((val)->message).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_BitmapAbortPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapAbortPDU(ASN1decoding_t dec, BitmapAbortPDU *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bitmapHandle))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->userID))
	    return 0;
	(val)->userID += 1001;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_BitmapAbortReason(dec, &(val)->reason))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->message).length))
	    return 0;
	((val)->message).length += 1;
	if (!ASN1PERDecChar16String(dec, ((val)->message).length, &((val)->message).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_BitmapAbortPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapAbortPDU(BitmapAbortPDU *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1Free_BitmapAbortReason(&(val)->reason);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1char16string_free(&(val)->message);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_BitmapAbortPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_DrawingCreatePDU(ASN1encoding_t enc, DrawingCreatePDU *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 5, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	l = ASN1uint32_uoctets((val)->drawingHandle);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->drawingHandle))
	    return 0;
    }
    if (!ASN1Enc_DrawingDestinationAddress(enc, &(val)->destinationAddress))
	return 0;
    if (!ASN1Enc_DrawingType(enc, &(val)->drawingType))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_DrawingCreatePDU_attributes(enc, &(val)->attributes))
	    return 0;
    }
    if (!ASN1Enc_WorkspacePoint(enc, &(val)->anchorPoint))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_RotationSpecifier(enc, &(val)->rotation))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncBitVal(enc, 8, (val)->sampleRate - 1))
	    return 0;
    }
    if (!ASN1Enc_PointList(enc, &(val)->pointList))
	return 0;
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_DrawingCreatePDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DrawingCreatePDU(ASN1decoding_t dec, DrawingCreatePDU *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->drawingHandle))
	    return 0;
    }
    if (!ASN1Dec_DrawingDestinationAddress(dec, &(val)->destinationAddress))
	return 0;
    if (!ASN1Dec_DrawingType(dec, &(val)->drawingType))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_DrawingCreatePDU_attributes(dec, &(val)->attributes))
	    return 0;
    }
    if (!ASN1Dec_WorkspacePoint(dec, &(val)->anchorPoint))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_RotationSpecifier(dec, &(val)->rotation))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecU16Val(dec, 8, &(val)->sampleRate))
	    return 0;
	(val)->sampleRate += 1;
    }
    if (!ASN1Dec_PointList(dec, &(val)->pointList))
	return 0;
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_DrawingCreatePDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DrawingCreatePDU(DrawingCreatePDU *val)
{
    if (val) {
	ASN1Free_DrawingDestinationAddress(&(val)->destinationAddress);
	ASN1Free_DrawingType(&(val)->drawingType);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_DrawingCreatePDU_attributes(&(val)->attributes);
	}
	ASN1Free_PointList(&(val)->pointList);
	if ((val)->o[0] & 0x8) {
	    ASN1Free_DrawingCreatePDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_DrawingEditPDU(ASN1encoding_t enc, DrawingEditPDU *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 5, (val)->o))
	return 0;
    l = ASN1uint32_uoctets((val)->drawingHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->drawingHandle))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_DrawingEditPDU_attributeEdits(enc, &(val)->attributeEdits))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_WorkspacePoint(enc, &(val)->anchorPointEdit))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_RotationSpecifier(enc, &(val)->rotationEdit))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_PointListEdits(enc, &(val)->pointListEdits))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_DrawingEditPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DrawingEditPDU(ASN1decoding_t dec, DrawingEditPDU *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->drawingHandle))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_DrawingEditPDU_attributeEdits(dec, &(val)->attributeEdits))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_WorkspacePoint(dec, &(val)->anchorPointEdit))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_RotationSpecifier(dec, &(val)->rotationEdit))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_PointListEdits(dec, &(val)->pointListEdits))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_DrawingEditPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DrawingEditPDU(DrawingEditPDU *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_DrawingEditPDU_attributeEdits(&(val)->attributeEdits);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_PointListEdits(&(val)->pointListEdits);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_DrawingEditPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_RemotePointingDeviceEventPDU(ASN1encoding_t enc, RemotePointingDeviceEventPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if (!ASN1Enc_RemoteEventDestinationAddress(enc, &(val)->destinationAddress))
	return 0;
    if (!ASN1Enc_ButtonEvent(enc, &(val)->leftButtonState))
	return 0;
    if (!ASN1Enc_ButtonEvent(enc, &(val)->middleButtonState))
	return 0;
    if (!ASN1Enc_ButtonEvent(enc, &(val)->rightButtonState))
	return 0;
    if (!ASN1Enc_WorkspacePoint(enc, &(val)->initialPoint))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 8, (val)->sampleRate - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_PointList(enc, &(val)->pointList))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_RemotePointingDeviceEventPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RemotePointingDeviceEventPDU(ASN1decoding_t dec, RemotePointingDeviceEventPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1Dec_RemoteEventDestinationAddress(dec, &(val)->destinationAddress))
	return 0;
    if (!ASN1Dec_ButtonEvent(dec, &(val)->leftButtonState))
	return 0;
    if (!ASN1Dec_ButtonEvent(dec, &(val)->middleButtonState))
	return 0;
    if (!ASN1Dec_ButtonEvent(dec, &(val)->rightButtonState))
	return 0;
    if (!ASN1Dec_WorkspacePoint(dec, &(val)->initialPoint))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU16Val(dec, 8, &(val)->sampleRate))
	    return 0;
	(val)->sampleRate += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_PointList(dec, &(val)->pointList))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_RemotePointingDeviceEventPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RemotePointingDeviceEventPDU(RemotePointingDeviceEventPDU *val)
{
    if (val) {
	ASN1Free_RemoteEventDestinationAddress(&(val)->destinationAddress);
	ASN1Free_ButtonEvent(&(val)->leftButtonState);
	ASN1Free_ButtonEvent(&(val)->middleButtonState);
	ASN1Free_ButtonEvent(&(val)->rightButtonState);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_PointList(&(val)->pointList);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_RemotePointingDeviceEventPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action_editView(ASN1encoding_t enc, PWorkspaceEditPDU_viewEdits_Set_action_editView *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action_editView_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action_editView_ElmFn(ASN1encoding_t enc, PWorkspaceEditPDU_viewEdits_Set_action_editView val)
{
    if (!ASN1Enc_WorkspaceViewAttribute(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action_editView(ASN1decoding_t dec, PWorkspaceEditPDU_viewEdits_Set_action_editView *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action_editView_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action_editView_ElmFn(ASN1decoding_t dec, PWorkspaceEditPDU_viewEdits_Set_action_editView val)
{
    if (!ASN1Dec_WorkspaceViewAttribute(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits_Set_action_editView(PWorkspaceEditPDU_viewEdits_Set_action_editView *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceEditPDU_viewEdits_Set_action_editView_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits_Set_action_editView_ElmFn(PWorkspaceEditPDU_viewEdits_Set_action_editView val)
{
    if (val) {
	ASN1Free_WorkspaceViewAttribute(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action_createNewView(ASN1encoding_t enc, PWorkspaceEditPDU_viewEdits_Set_action_createNewView *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action_createNewView_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action_createNewView_ElmFn(ASN1encoding_t enc, PWorkspaceEditPDU_viewEdits_Set_action_createNewView val)
{
    if (!ASN1Enc_WorkspaceViewAttribute(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action_createNewView(ASN1decoding_t dec, PWorkspaceEditPDU_viewEdits_Set_action_createNewView *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action_createNewView_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action_createNewView_ElmFn(ASN1decoding_t dec, PWorkspaceEditPDU_viewEdits_Set_action_createNewView val)
{
    if (!ASN1Dec_WorkspaceViewAttribute(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits_Set_action_createNewView(PWorkspaceEditPDU_viewEdits_Set_action_createNewView *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceEditPDU_viewEdits_Set_action_createNewView_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits_Set_action_createNewView_ElmFn(PWorkspaceEditPDU_viewEdits_Set_action_createNewView val)
{
    if (val) {
	ASN1Free_WorkspaceViewAttribute(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_planeEdits_Set_planeAttributes(ASN1encoding_t enc, PWorkspaceEditPDU_planeEdits_Set_planeAttributes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceEditPDU_planeEdits_Set_planeAttributes_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_planeEdits_Set_planeAttributes_ElmFn(ASN1encoding_t enc, PWorkspaceEditPDU_planeEdits_Set_planeAttributes val)
{
    if (!ASN1Enc_PlaneAttribute(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_planeEdits_Set_planeAttributes(ASN1decoding_t dec, PWorkspaceEditPDU_planeEdits_Set_planeAttributes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceEditPDU_planeEdits_Set_planeAttributes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_planeEdits_Set_planeAttributes_ElmFn(ASN1decoding_t dec, PWorkspaceEditPDU_planeEdits_Set_planeAttributes val)
{
    if (!ASN1Dec_PlaneAttribute(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_planeEdits_Set_planeAttributes(PWorkspaceEditPDU_planeEdits_Set_planeAttributes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceEditPDU_planeEdits_Set_planeAttributes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_planeEdits_Set_planeAttributes_ElmFn(PWorkspaceEditPDU_planeEdits_Set_planeAttributes val)
{
    if (val) {
	ASN1Free_PlaneAttribute(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_viewParameters_Set_viewAttributes(ASN1encoding_t enc, PWorkspaceCreatePDU_viewParameters_Set_viewAttributes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceCreatePDU_viewParameters_Set_viewAttributes_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_viewParameters_Set_viewAttributes_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_viewParameters_Set_viewAttributes val)
{
    if (!ASN1Enc_WorkspaceViewAttribute(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_viewParameters_Set_viewAttributes(ASN1decoding_t dec, PWorkspaceCreatePDU_viewParameters_Set_viewAttributes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceCreatePDU_viewParameters_Set_viewAttributes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_viewParameters_Set_viewAttributes_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_viewParameters_Set_viewAttributes val)
{
    if (!ASN1Dec_WorkspaceViewAttribute(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_viewParameters_Set_viewAttributes(PWorkspaceCreatePDU_viewParameters_Set_viewAttributes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceCreatePDU_viewParameters_Set_viewAttributes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_viewParameters_Set_viewAttributes_ElmFn(PWorkspaceCreatePDU_viewParameters_Set_viewAttributes val)
{
    if (val) {
	ASN1Free_WorkspaceViewAttribute(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes(ASN1encoding_t enc, PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes val)
{
    if (!ASN1Enc_PlaneAttribute(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes(ASN1decoding_t dec, PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes val)
{
    if (!ASN1Dec_PlaneAttribute(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes(PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes_ElmFn(PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes val)
{
    if (val) {
	ASN1Free_PlaneAttribute(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteYCbCr(ASN1encoding_t enc, ColorPalette_colorLookUpTable_paletteYCbCr *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_ColorPalette_colorLookUpTable_paletteYCbCr_palette(enc, &(val)->palette))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ColorAccuracyEnhancementYCbCr(enc, &(val)->enhancement))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteYCbCr(ASN1decoding_t dec, ColorPalette_colorLookUpTable_paletteYCbCr *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_ColorPalette_colorLookUpTable_paletteYCbCr_palette(dec, &(val)->palette))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ColorAccuracyEnhancementYCbCr(dec, &(val)->enhancement))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteYCbCr(ColorPalette_colorLookUpTable_paletteYCbCr *val)
{
    if (val) {
	ASN1Free_ColorPalette_colorLookUpTable_paletteYCbCr_palette(&(val)->palette);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ColorAccuracyEnhancementYCbCr(&(val)->enhancement);
	}
    }
}

static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteCIELab(ASN1encoding_t enc, ColorPalette_colorLookUpTable_paletteCIELab *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_ColorPalette_colorLookUpTable_paletteCIELab_palette(enc, &(val)->palette))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ColorAccuracyEnhancementCIELab(enc, &(val)->enhancement))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteCIELab(ASN1decoding_t dec, ColorPalette_colorLookUpTable_paletteCIELab *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_ColorPalette_colorLookUpTable_paletteCIELab_palette(dec, &(val)->palette))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ColorAccuracyEnhancementCIELab(dec, &(val)->enhancement))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteCIELab(ColorPalette_colorLookUpTable_paletteCIELab *val)
{
    if (val) {
	ASN1Free_ColorPalette_colorLookUpTable_paletteCIELab_palette(&(val)->palette);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ColorAccuracyEnhancementCIELab(&(val)->enhancement);
	}
    }
}

static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteRGB(ASN1encoding_t enc, ColorPalette_colorLookUpTable_paletteRGB *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_ColorPalette_colorLookUpTable_paletteRGB_palette(enc, &(val)->palette))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ColorAccuracyEnhancementRGB(enc, &(val)->enhancement))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteRGB(ASN1decoding_t dec, ColorPalette_colorLookUpTable_paletteRGB *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_ColorPalette_colorLookUpTable_paletteRGB_palette(dec, &(val)->palette))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ColorAccuracyEnhancementRGB(dec, &(val)->enhancement))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteRGB(ColorPalette_colorLookUpTable_paletteRGB *val)
{
    if (val) {
	ASN1Free_ColorPalette_colorLookUpTable_paletteRGB_palette(&(val)->palette);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ColorAccuracyEnhancementRGB(&(val)->enhancement);
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspacePlaneCopyPDU_copyDescriptor(ASN1encoding_t enc, WorkspacePlaneCopyPDU_copyDescriptor *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_PermanentPlaneCopyDescriptor(enc, &(val)->u.permanentPlaneCopyDescriptor))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_EditablePlaneCopyDescriptor(enc, &(val)->u.editablePlaneCopyDescriptor))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspacePlaneCopyPDU_copyDescriptor(ASN1decoding_t dec, WorkspacePlaneCopyPDU_copyDescriptor *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_PermanentPlaneCopyDescriptor(dec, &(val)->u.permanentPlaneCopyDescriptor))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_EditablePlaneCopyDescriptor(dec, &(val)->u.editablePlaneCopyDescriptor))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspacePlaneCopyPDU_copyDescriptor(WorkspacePlaneCopyPDU_copyDescriptor *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_EditablePlaneCopyDescriptor(&(val)->u.editablePlaneCopyDescriptor);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_attributeEdits(ASN1encoding_t enc, PWorkspaceEditPDU_attributeEdits *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceEditPDU_attributeEdits_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_attributeEdits_ElmFn(ASN1encoding_t enc, PWorkspaceEditPDU_attributeEdits val)
{
    if (!ASN1Enc_WorkspaceAttribute(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_attributeEdits(ASN1decoding_t dec, PWorkspaceEditPDU_attributeEdits *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceEditPDU_attributeEdits_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_attributeEdits_ElmFn(ASN1decoding_t dec, PWorkspaceEditPDU_attributeEdits val)
{
    if (!ASN1Dec_WorkspaceAttribute(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_attributeEdits(PWorkspaceEditPDU_attributeEdits *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceEditPDU_attributeEdits_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_attributeEdits_ElmFn(PWorkspaceEditPDU_attributeEdits val)
{
    if (val) {
	ASN1Free_WorkspaceAttribute(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_workspaceAttributes(ASN1encoding_t enc, PWorkspaceCreatePDU_workspaceAttributes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceCreatePDU_workspaceAttributes_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_workspaceAttributes_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_workspaceAttributes val)
{
    if (!ASN1Enc_WorkspaceAttribute(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_workspaceAttributes(ASN1decoding_t dec, PWorkspaceCreatePDU_workspaceAttributes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceCreatePDU_workspaceAttributes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_workspaceAttributes_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_workspaceAttributes val)
{
    if (!ASN1Dec_WorkspaceAttribute(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_workspaceAttributes(PWorkspaceCreatePDU_workspaceAttributes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceCreatePDU_workspaceAttributes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_workspaceAttributes_ElmFn(PWorkspaceCreatePDU_workspaceAttributes val)
{
    if (val) {
	ASN1Free_WorkspaceAttribute(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RemoteKeyboardEventPDU_keyModifierStates(ASN1encoding_t enc, PRemoteKeyboardEventPDU_keyModifierStates *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RemoteKeyboardEventPDU_keyModifierStates_ElmFn);
}

static int ASN1CALL ASN1Enc_RemoteKeyboardEventPDU_keyModifierStates_ElmFn(ASN1encoding_t enc, PRemoteKeyboardEventPDU_keyModifierStates val)
{
    if (!ASN1Enc_KeyModifier(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteKeyboardEventPDU_keyModifierStates(ASN1decoding_t dec, PRemoteKeyboardEventPDU_keyModifierStates *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RemoteKeyboardEventPDU_keyModifierStates_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RemoteKeyboardEventPDU_keyModifierStates_ElmFn(ASN1decoding_t dec, PRemoteKeyboardEventPDU_keyModifierStates val)
{
    if (!ASN1Dec_KeyModifier(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RemoteKeyboardEventPDU_keyModifierStates(PRemoteKeyboardEventPDU_keyModifierStates *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RemoteKeyboardEventPDU_keyModifierStates_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RemoteKeyboardEventPDU_keyModifierStates_ElmFn(PRemoteKeyboardEventPDU_keyModifierStates val)
{
    if (val) {
	ASN1Free_KeyModifier(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConductorPrivilegeRequestPDU_privilegeList(ASN1encoding_t enc, PConductorPrivilegeRequestPDU_privilegeList *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ConductorPrivilegeRequestPDU_privilegeList_ElmFn);
}

static int ASN1CALL ASN1Enc_ConductorPrivilegeRequestPDU_privilegeList_ElmFn(ASN1encoding_t enc, PConductorPrivilegeRequestPDU_privilegeList val)
{
    if (!ASN1Enc_ConductorPrivilege(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConductorPrivilegeRequestPDU_privilegeList(ASN1decoding_t dec, PConductorPrivilegeRequestPDU_privilegeList *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ConductorPrivilegeRequestPDU_privilegeList_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ConductorPrivilegeRequestPDU_privilegeList_ElmFn(ASN1decoding_t dec, PConductorPrivilegeRequestPDU_privilegeList val)
{
    if (!ASN1Dec_ConductorPrivilege(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConductorPrivilegeRequestPDU_privilegeList(PConductorPrivilegeRequestPDU_privilegeList *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ConductorPrivilegeRequestPDU_privilegeList_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ConductorPrivilegeRequestPDU_privilegeList_ElmFn(PConductorPrivilegeRequestPDU_privilegeList val)
{
    if (val) {
	ASN1Free_ConductorPrivilege(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConductorPrivilegeGrantPDU_privilegeList(ASN1encoding_t enc, PConductorPrivilegeGrantPDU_privilegeList *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ConductorPrivilegeGrantPDU_privilegeList_ElmFn);
}

static int ASN1CALL ASN1Enc_ConductorPrivilegeGrantPDU_privilegeList_ElmFn(ASN1encoding_t enc, PConductorPrivilegeGrantPDU_privilegeList val)
{
    if (!ASN1Enc_ConductorPrivilege(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConductorPrivilegeGrantPDU_privilegeList(ASN1decoding_t dec, PConductorPrivilegeGrantPDU_privilegeList *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ConductorPrivilegeGrantPDU_privilegeList_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ConductorPrivilegeGrantPDU_privilegeList_ElmFn(ASN1decoding_t dec, PConductorPrivilegeGrantPDU_privilegeList val)
{
    if (!ASN1Dec_ConductorPrivilege(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConductorPrivilegeGrantPDU_privilegeList(PConductorPrivilegeGrantPDU_privilegeList *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ConductorPrivilegeGrantPDU_privilegeList_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ConductorPrivilegeGrantPDU_privilegeList_ElmFn(PConductorPrivilegeGrantPDU_privilegeList val)
{
    if (val) {
	ASN1Free_ConductorPrivilege(&val->value);
    }
}

static int ASN1CALL ASN1Enc_VideoWindowEditPDU_attributeEdits(ASN1encoding_t enc, PVideoWindowEditPDU_attributeEdits *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_VideoWindowEditPDU_attributeEdits_ElmFn);
}

static int ASN1CALL ASN1Enc_VideoWindowEditPDU_attributeEdits_ElmFn(ASN1encoding_t enc, PVideoWindowEditPDU_attributeEdits val)
{
    if (!ASN1Enc_VideoWindowAttribute(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VideoWindowEditPDU_attributeEdits(ASN1decoding_t dec, PVideoWindowEditPDU_attributeEdits *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_VideoWindowEditPDU_attributeEdits_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_VideoWindowEditPDU_attributeEdits_ElmFn(ASN1decoding_t dec, PVideoWindowEditPDU_attributeEdits val)
{
    if (!ASN1Dec_VideoWindowAttribute(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_VideoWindowEditPDU_attributeEdits(PVideoWindowEditPDU_attributeEdits *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_VideoWindowEditPDU_attributeEdits_ElmFn);
    }
}

static void ASN1CALL ASN1Free_VideoWindowEditPDU_attributeEdits_ElmFn(PVideoWindowEditPDU_attributeEdits val)
{
    if (val) {
	ASN1Free_VideoWindowAttribute(&val->value);
    }
}

static int ASN1CALL ASN1Enc_VideoWindowCreatePDU_attributes(ASN1encoding_t enc, PVideoWindowCreatePDU_attributes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_VideoWindowCreatePDU_attributes_ElmFn);
}

static int ASN1CALL ASN1Enc_VideoWindowCreatePDU_attributes_ElmFn(ASN1encoding_t enc, PVideoWindowCreatePDU_attributes val)
{
    if (!ASN1Enc_VideoWindowAttribute(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VideoWindowCreatePDU_attributes(ASN1decoding_t dec, PVideoWindowCreatePDU_attributes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_VideoWindowCreatePDU_attributes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_VideoWindowCreatePDU_attributes_ElmFn(ASN1decoding_t dec, PVideoWindowCreatePDU_attributes val)
{
    if (!ASN1Dec_VideoWindowAttribute(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_VideoWindowCreatePDU_attributes(PVideoWindowCreatePDU_attributes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_VideoWindowCreatePDU_attributes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_VideoWindowCreatePDU_attributes_ElmFn(PVideoWindowCreatePDU_attributes val)
{
    if (val) {
	ASN1Free_VideoWindowAttribute(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ColorSpaceSpecifier_cieLab(ASN1encoding_t enc, ColorSpaceSpecifier_cieLab *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ColorAccuracyEnhancementCIELab(enc, &(val)->accuracyEnhancement))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorSpaceSpecifier_cieLab(ASN1decoding_t dec, ColorSpaceSpecifier_cieLab *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ColorAccuracyEnhancementCIELab(dec, &(val)->accuracyEnhancement))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorSpaceSpecifier_cieLab(ColorSpaceSpecifier_cieLab *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ColorAccuracyEnhancementCIELab(&(val)->accuracyEnhancement);
	}
    }
}

static int ASN1CALL ASN1Enc_ColorSpaceSpecifier_rgb(ASN1encoding_t enc, ColorSpaceSpecifier_rgb *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ColorAccuracyEnhancementRGB(enc, &(val)->accuracyEnhancement))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorSpaceSpecifier_rgb(ASN1decoding_t dec, ColorSpaceSpecifier_rgb *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ColorAccuracyEnhancementRGB(dec, &(val)->accuracyEnhancement))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorSpaceSpecifier_rgb(ColorSpaceSpecifier_rgb *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ColorAccuracyEnhancementRGB(&(val)->accuracyEnhancement);
	}
    }
}

static int ASN1CALL ASN1Enc_ColorSpaceSpecifier_yCbCr(ASN1encoding_t enc, ColorSpaceSpecifier_yCbCr *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ColorAccuracyEnhancementYCbCr(enc, &(val)->accuracyEnhancement))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorSpaceSpecifier_yCbCr(ASN1decoding_t dec, ColorSpaceSpecifier_yCbCr *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ColorAccuracyEnhancementYCbCr(dec, &(val)->accuracyEnhancement))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorSpaceSpecifier_yCbCr(ColorSpaceSpecifier_yCbCr *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ColorAccuracyEnhancementYCbCr(&(val)->accuracyEnhancement);
	}
    }
}

static int ASN1CALL ASN1Enc_ColorSpaceSpecifier_greyscale(ASN1encoding_t enc, ColorSpaceSpecifier_greyscale *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ColorAccuracyEnhancementGreyscale(enc, &(val)->accuracyEnhancement))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorSpaceSpecifier_greyscale(ASN1decoding_t dec, ColorSpaceSpecifier_greyscale *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ColorAccuracyEnhancementGreyscale(dec, &(val)->accuracyEnhancement))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorSpaceSpecifier_greyscale(ColorSpaceSpecifier_greyscale *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ColorAccuracyEnhancementGreyscale(&(val)->accuracyEnhancement);
	}
    }
}

static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable(ASN1encoding_t enc, ColorPalette_colorLookUpTable *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ColorPalette_colorLookUpTable_paletteRGB(enc, &(val)->u.paletteRGB))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ColorPalette_colorLookUpTable_paletteCIELab(enc, &(val)->u.paletteCIELab))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_ColorPalette_colorLookUpTable_paletteYCbCr(enc, &(val)->u.paletteYCbCr))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardPalette))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable(ASN1decoding_t dec, ColorPalette_colorLookUpTable *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ColorPalette_colorLookUpTable_paletteRGB(dec, &(val)->u.paletteRGB))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ColorPalette_colorLookUpTable_paletteCIELab(dec, &(val)->u.paletteCIELab))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_ColorPalette_colorLookUpTable_paletteYCbCr(dec, &(val)->u.paletteYCbCr))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardPalette))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable(ColorPalette_colorLookUpTable *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ColorPalette_colorLookUpTable_paletteRGB(&(val)->u.paletteRGB);
	    break;
	case 2:
	    ASN1Free_ColorPalette_colorLookUpTable_paletteCIELab(&(val)->u.paletteCIELab);
	    break;
	case 3:
	    ASN1Free_ColorPalette_colorLookUpTable_paletteYCbCr(&(val)->u.paletteYCbCr);
	    break;
	case 4:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardPalette);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_BitmapAttribute(ASN1encoding_t enc, BitmapAttribute *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ViewState(enc, &(val)->u.viewState))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncExtensionBitClear(enc))
	    return 0;
	if (!ASN1PEREncBitVal(enc, 1, (val)->u.zOrder))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardAttribute))
	    return 0;
	break;
    case 4:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_TransparencyMask(ee, &(val)->u.transparencyMask))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapAttribute(ASN1decoding_t dec, BitmapAttribute *val)
{
    ASN1uint32_t x;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 2, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ViewState(dec, &(val)->u.viewState))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecExtensionBit(dec, &x))
	    return 0;
	if (!x) {
	    if (!ASN1PERDecU32Val(dec, 1, (ASN1uint32_t *)&(val)->u.zOrder))
		return 0;
	} else {
	    if (!ASN1PERDecSkipNormallySmall(dec))
		return 0;
	}
	break;
    case 3:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardAttribute))
	    return 0;
	break;
    case 4:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_TransparencyMask(dd, &(val)->u.transparencyMask))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapAttribute(BitmapAttribute *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ViewState(&(val)->u.viewState);
	    break;
	case 3:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardAttribute);
	    break;
	case 4:
	    ASN1Free_TransparencyMask(&(val)->u.transparencyMask);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ColorPalette(ASN1encoding_t enc, ColorPalette *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_ColorPalette_colorLookUpTable(enc, &(val)->colorLookUpTable))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->transparentEntry))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorPalette(ASN1decoding_t dec, ColorPalette *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_ColorPalette_colorLookUpTable(dec, &(val)->colorLookUpTable))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->transparentEntry))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorPalette(ColorPalette *val)
{
    if (val) {
	ASN1Free_ColorPalette_colorLookUpTable(&(val)->colorLookUpTable);
    }
}

static int ASN1CALL ASN1Enc_ColorSpaceSpecifier(ASN1encoding_t enc, ColorSpaceSpecifier *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ColorSpaceSpecifier_greyscale(enc, &(val)->u.greyscale))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ColorSpaceSpecifier_yCbCr(enc, &(val)->u.yCbCr))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_ColorSpaceSpecifier_rgb(enc, &(val)->u.rgb))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_ColorSpaceSpecifier_cieLab(enc, &(val)->u.cieLab))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->u.nonStandardColorSpace))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorSpaceSpecifier(ASN1decoding_t dec, ColorSpaceSpecifier *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ColorSpaceSpecifier_greyscale(dec, &(val)->u.greyscale))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ColorSpaceSpecifier_yCbCr(dec, &(val)->u.yCbCr))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_ColorSpaceSpecifier_rgb(dec, &(val)->u.rgb))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_ColorSpaceSpecifier_cieLab(dec, &(val)->u.cieLab))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->u.nonStandardColorSpace))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorSpaceSpecifier(ColorSpaceSpecifier *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ColorSpaceSpecifier_greyscale(&(val)->u.greyscale);
	    break;
	case 2:
	    ASN1Free_ColorSpaceSpecifier_yCbCr(&(val)->u.yCbCr);
	    break;
	case 3:
	    ASN1Free_ColorSpaceSpecifier_rgb(&(val)->u.rgb);
	    break;
	case 4:
	    ASN1Free_ColorSpaceSpecifier_cieLab(&(val)->u.cieLab);
	    break;
	case 5:
	    ASN1Free_NonStandardIdentifier(&(val)->u.nonStandardColorSpace);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_DrawingAttribute(ASN1encoding_t enc, DrawingAttribute *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_WorkspaceColor(enc, &(val)->u.penColor))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_WorkspaceColor(enc, &(val)->u.fillColor))
	    return 0;
	break;
    case 3:
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.penThickness - 1))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_PenNib(enc, &(val)->u.penNib))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_LineStyle(enc, &(val)->u.lineStyle))
	    return 0;
	break;
    case 6:
	if (!ASN1PEREncBoolean(enc, (val)->u.highlight))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_ViewState(enc, &(val)->u.viewState))
	    return 0;
	break;
    case 8:
	if (!ASN1PEREncExtensionBitClear(enc))
	    return 0;
	if (!ASN1PEREncBitVal(enc, 1, (val)->u.zOrder))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardAttribute))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DrawingAttribute(ASN1decoding_t dec, DrawingAttribute *val)
{
    ASN1uint32_t x;
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_WorkspaceColor(dec, &(val)->u.penColor))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_WorkspaceColor(dec, &(val)->u.fillColor))
	    return 0;
	break;
    case 3:
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.penThickness))
	    return 0;
	(val)->u.penThickness += 1;
	break;
    case 4:
	if (!ASN1Dec_PenNib(dec, &(val)->u.penNib))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_LineStyle(dec, &(val)->u.lineStyle))
	    return 0;
	break;
    case 6:
	if (!ASN1PERDecBoolean(dec, &(val)->u.highlight))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_ViewState(dec, &(val)->u.viewState))
	    return 0;
	break;
    case 8:
	if (!ASN1PERDecExtensionBit(dec, &x))
	    return 0;
	if (!x) {
	    if (!ASN1PERDecU32Val(dec, 1, (ASN1uint32_t *) &(val)->u.zOrder))
		return 0;
	} else {
	    if (!ASN1PERDecSkipNormallySmall(dec))
		return 0;
	}
	break;
    case 9:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardAttribute))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DrawingAttribute(DrawingAttribute *val)
{
    if (val) {
	switch ((val)->choice) {
	case 4:
	    ASN1Free_PenNib(&(val)->u.penNib);
	    break;
	case 5:
	    ASN1Free_LineStyle(&(val)->u.lineStyle);
	    break;
	case 7:
	    ASN1Free_ViewState(&(val)->u.viewState);
	    break;
	case 9:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardAttribute);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspacePlaneCopyPDU(ASN1encoding_t enc, WorkspacePlaneCopyPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_WorkspaceIdentifier(enc, &(val)->sourceWorkspaceIdentifier))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sourcePlane))
	return 0;
    if (!ASN1Enc_WorkspaceIdentifier(enc, &(val)->destinationWorkspaceIdentifier))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->destinationPlane))
	return 0;
    if (!ASN1Enc_WorkspacePlaneCopyPDU_copyDescriptor(enc, &(val)->copyDescriptor))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_WorkspacePlaneCopyPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspacePlaneCopyPDU(ASN1decoding_t dec, WorkspacePlaneCopyPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_WorkspaceIdentifier(dec, &(val)->sourceWorkspaceIdentifier))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sourcePlane))
	return 0;
    if (!ASN1Dec_WorkspaceIdentifier(dec, &(val)->destinationWorkspaceIdentifier))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->destinationPlane))
	return 0;
    if (!ASN1Dec_WorkspacePlaneCopyPDU_copyDescriptor(dec, &(val)->copyDescriptor))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_WorkspacePlaneCopyPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspacePlaneCopyPDU(WorkspacePlaneCopyPDU *val)
{
    if (val) {
	ASN1Free_WorkspaceIdentifier(&(val)->sourceWorkspaceIdentifier);
	ASN1Free_WorkspaceIdentifier(&(val)->destinationWorkspaceIdentifier);
	ASN1Free_WorkspacePlaneCopyPDU_copyDescriptor(&(val)->copyDescriptor);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_WorkspacePlaneCopyPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_BitmapHeaderUncompressed_colorMappingMode_paletteMap(ASN1encoding_t enc, BitmapHeaderUncompressed_colorMappingMode_paletteMap *val)
{
    if (!ASN1Enc_ColorPalette(enc, &(val)->colorPalette))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->bitsPerPixel - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapHeaderUncompressed_colorMappingMode_paletteMap(ASN1decoding_t dec, BitmapHeaderUncompressed_colorMappingMode_paletteMap *val)
{
    if (!ASN1Dec_ColorPalette(dec, &(val)->colorPalette))
	return 0;
    if (!ASN1PERDecU16Val(dec, 3, &(val)->bitsPerPixel))
	return 0;
    (val)->bitsPerPixel += 1;
    return 1;
}

static void ASN1CALL ASN1Free_BitmapHeaderUncompressed_colorMappingMode_paletteMap(BitmapHeaderUncompressed_colorMappingMode_paletteMap *val)
{
    if (val) {
	ASN1Free_ColorPalette(&(val)->colorPalette);
    }
}

static int ASN1CALL ASN1Enc_BitmapHeaderUncompressed_colorMappingMode_directMap(ASN1encoding_t enc, BitmapHeaderUncompressed_colorMappingMode_directMap *val)
{
    if (!ASN1Enc_ColorSpaceSpecifier(enc, &(val)->colorSpace))
	return 0;
    if (!ASN1Enc_ColorResolutionModeSpecifier(enc, &(val)->resolutionMode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapHeaderUncompressed_colorMappingMode_directMap(ASN1decoding_t dec, BitmapHeaderUncompressed_colorMappingMode_directMap *val)
{
    if (!ASN1Dec_ColorSpaceSpecifier(dec, &(val)->colorSpace))
	return 0;
    if (!ASN1Dec_ColorResolutionModeSpecifier(dec, &(val)->resolutionMode))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BitmapHeaderUncompressed_colorMappingMode_directMap(BitmapHeaderUncompressed_colorMappingMode_directMap *val)
{
    if (val) {
	ASN1Free_ColorSpaceSpecifier(&(val)->colorSpace);
	ASN1Free_ColorResolutionModeSpecifier(&(val)->resolutionMode);
    }
}

static int ASN1CALL ASN1Enc_BitmapHeaderT82_colorMappingMode_paletteMap(ASN1encoding_t enc, BitmapHeaderT82_colorMappingMode_paletteMap *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_ColorPalette(enc, &(val)->bitmapPalette))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode(enc, &(val)->progressiveMode))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapHeaderT82_colorMappingMode_paletteMap(ASN1decoding_t dec, BitmapHeaderT82_colorMappingMode_paletteMap *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_ColorPalette(dec, &(val)->bitmapPalette))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode(dec, &(val)->progressiveMode))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapHeaderT82_colorMappingMode_paletteMap(BitmapHeaderT82_colorMappingMode_paletteMap *val)
{
    if (val) {
	ASN1Free_ColorPalette(&(val)->bitmapPalette);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode(&(val)->progressiveMode);
	}
    }
}

static int ASN1CALL ASN1Enc_DrawingEditPDU_attributeEdits(ASN1encoding_t enc, PDrawingEditPDU_attributeEdits *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DrawingEditPDU_attributeEdits_ElmFn);
}

static int ASN1CALL ASN1Enc_DrawingEditPDU_attributeEdits_ElmFn(ASN1encoding_t enc, PDrawingEditPDU_attributeEdits val)
{
    if (!ASN1Enc_DrawingAttribute(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DrawingEditPDU_attributeEdits(ASN1decoding_t dec, PDrawingEditPDU_attributeEdits *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DrawingEditPDU_attributeEdits_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DrawingEditPDU_attributeEdits_ElmFn(ASN1decoding_t dec, PDrawingEditPDU_attributeEdits val)
{
    if (!ASN1Dec_DrawingAttribute(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DrawingEditPDU_attributeEdits(PDrawingEditPDU_attributeEdits *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DrawingEditPDU_attributeEdits_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DrawingEditPDU_attributeEdits_ElmFn(PDrawingEditPDU_attributeEdits val)
{
    if (val) {
	ASN1Free_DrawingAttribute(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DrawingCreatePDU_attributes(ASN1encoding_t enc, PDrawingCreatePDU_attributes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DrawingCreatePDU_attributes_ElmFn);
}

static int ASN1CALL ASN1Enc_DrawingCreatePDU_attributes_ElmFn(ASN1encoding_t enc, PDrawingCreatePDU_attributes val)
{
    if (!ASN1Enc_DrawingAttribute(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DrawingCreatePDU_attributes(ASN1decoding_t dec, PDrawingCreatePDU_attributes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DrawingCreatePDU_attributes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DrawingCreatePDU_attributes_ElmFn(ASN1decoding_t dec, PDrawingCreatePDU_attributes val)
{
    if (!ASN1Dec_DrawingAttribute(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DrawingCreatePDU_attributes(PDrawingCreatePDU_attributes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DrawingCreatePDU_attributes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DrawingCreatePDU_attributes_ElmFn(PDrawingCreatePDU_attributes val)
{
    if (val) {
	ASN1Free_DrawingAttribute(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BitmapEditPDU_attributeEdits(ASN1encoding_t enc, PBitmapEditPDU_attributeEdits *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BitmapEditPDU_attributeEdits_ElmFn);
}

static int ASN1CALL ASN1Enc_BitmapEditPDU_attributeEdits_ElmFn(ASN1encoding_t enc, PBitmapEditPDU_attributeEdits val)
{
    if (!ASN1Enc_BitmapAttribute(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapEditPDU_attributeEdits(ASN1decoding_t dec, PBitmapEditPDU_attributeEdits *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BitmapEditPDU_attributeEdits_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BitmapEditPDU_attributeEdits_ElmFn(ASN1decoding_t dec, PBitmapEditPDU_attributeEdits val)
{
    if (!ASN1Dec_BitmapAttribute(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BitmapEditPDU_attributeEdits(PBitmapEditPDU_attributeEdits *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BitmapEditPDU_attributeEdits_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BitmapEditPDU_attributeEdits_ElmFn(PBitmapEditPDU_attributeEdits val)
{
    if (val) {
	ASN1Free_BitmapAttribute(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BitmapCreatePDU_attributes(ASN1encoding_t enc, PBitmapCreatePDU_attributes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BitmapCreatePDU_attributes_ElmFn);
}

static int ASN1CALL ASN1Enc_BitmapCreatePDU_attributes_ElmFn(ASN1encoding_t enc, PBitmapCreatePDU_attributes val)
{
    if (!ASN1Enc_BitmapAttribute(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapCreatePDU_attributes(ASN1decoding_t dec, PBitmapCreatePDU_attributes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BitmapCreatePDU_attributes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BitmapCreatePDU_attributes_ElmFn(ASN1decoding_t dec, PBitmapCreatePDU_attributes val)
{
    if (!ASN1Dec_BitmapAttribute(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BitmapCreatePDU_attributes(PBitmapCreatePDU_attributes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BitmapCreatePDU_attributes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BitmapCreatePDU_attributes_ElmFn(PBitmapCreatePDU_attributes val)
{
    if (val) {
	ASN1Free_BitmapAttribute(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BitmapHeaderT82_colorMappingMode(ASN1encoding_t enc, BitmapHeaderT82_colorMappingMode *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ColorSpaceSpecifier(enc, &(val)->u.directMap))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_BitmapHeaderT82_colorMappingMode_paletteMap(enc, &(val)->u.paletteMap))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapHeaderT82_colorMappingMode(ASN1decoding_t dec, BitmapHeaderT82_colorMappingMode *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ColorSpaceSpecifier(dec, &(val)->u.directMap))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_BitmapHeaderT82_colorMappingMode_paletteMap(dec, &(val)->u.paletteMap))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapHeaderT82_colorMappingMode(BitmapHeaderT82_colorMappingMode *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ColorSpaceSpecifier(&(val)->u.directMap);
	    break;
	case 2:
	    ASN1Free_BitmapHeaderT82_colorMappingMode_paletteMap(&(val)->u.paletteMap);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_BitmapHeaderUncompressed_colorMappingMode(ASN1encoding_t enc, BitmapHeaderUncompressed_colorMappingMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_BitmapHeaderUncompressed_colorMappingMode_directMap(enc, &(val)->u.directMap))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_BitmapHeaderUncompressed_colorMappingMode_paletteMap(enc, &(val)->u.paletteMap))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapHeaderUncompressed_colorMappingMode(ASN1decoding_t dec, BitmapHeaderUncompressed_colorMappingMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_BitmapHeaderUncompressed_colorMappingMode_directMap(dec, &(val)->u.directMap))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_BitmapHeaderUncompressed_colorMappingMode_paletteMap(dec, &(val)->u.paletteMap))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapHeaderUncompressed_colorMappingMode(BitmapHeaderUncompressed_colorMappingMode *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_BitmapHeaderUncompressed_colorMappingMode_directMap(&(val)->u.directMap);
	    break;
	case 2:
	    ASN1Free_BitmapHeaderUncompressed_colorMappingMode_paletteMap(&(val)->u.paletteMap);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_BitmapHeaderUncompressed(ASN1encoding_t enc, BitmapHeaderUncompressed *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_BitmapHeaderUncompressed_colorMappingMode(enc, &(val)->colorMappingMode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapHeaderUncompressed(ASN1decoding_t dec, BitmapHeaderUncompressed *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_BitmapHeaderUncompressed_colorMappingMode(dec, &(val)->colorMappingMode))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapHeaderUncompressed(BitmapHeaderUncompressed *val)
{
    if (val) {
	ASN1Free_BitmapHeaderUncompressed_colorMappingMode(&(val)->colorMappingMode);
    }
}

static int ASN1CALL ASN1Enc_BitmapHeaderT81(ASN1encoding_t enc, BitmapHeaderT81 *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1Enc_ColorSpaceSpecifier(enc, &(val)->colorSpace))
	return 0;
    if (!ASN1Enc_ColorResolutionModeSpecifier(enc, &(val)->resolutionMode))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 1, (val)->o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1Enc_ColorPalette(ee, &(val)->colorPalette))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapHeaderT81(ASN1decoding_t dec, BitmapHeaderT81 *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_ColorSpaceSpecifier(dec, &(val)->colorSpace))
	return 0;
    if (!ASN1Dec_ColorResolutionModeSpecifier(dec, &(val)->resolutionMode))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ColorPalette(dd, &(val)->colorPalette))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapHeaderT81(BitmapHeaderT81 *val)
{
    if (val) {
	ASN1Free_ColorSpaceSpecifier(&(val)->colorSpace);
	ASN1Free_ColorResolutionModeSpecifier(&(val)->resolutionMode);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ColorPalette(&(val)->colorPalette);
	}
    }
}

static int ASN1CALL ASN1Enc_BitmapHeaderT82(ASN1encoding_t enc, BitmapHeaderT82 *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_BitmapHeaderT82_colorMappingMode(enc, &(val)->colorMappingMode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapHeaderT82(ASN1decoding_t dec, BitmapHeaderT82 *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_BitmapHeaderT82_colorMappingMode(dec, &(val)->colorMappingMode))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapHeaderT82(BitmapHeaderT82 *val)
{
    if (val) {
	ASN1Free_BitmapHeaderT82_colorMappingMode(&(val)->colorMappingMode);
    }
}

static int ASN1CALL ASN1Enc_BitmapCreatePDU_bitmapFormatHeader(ASN1encoding_t enc, BitmapCreatePDU_bitmapFormatHeader *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_BitmapHeaderUncompressed(enc, &(val)->u.bitmapHeaderUncompressed))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_BitmapHeaderT4(enc, &(val)->u.bitmapHeaderT4))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_BitmapHeaderT6(enc, &(val)->u.bitmapHeaderT6))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_BitmapHeaderT81(enc, &(val)->u.bitmapHeaderT81))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_BitmapHeaderT82(enc, &(val)->u.bitmapHeaderT82))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.bitmapHeaderNonStandard))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapCreatePDU_bitmapFormatHeader(ASN1decoding_t dec, BitmapCreatePDU_bitmapFormatHeader *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_BitmapHeaderUncompressed(dec, &(val)->u.bitmapHeaderUncompressed))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_BitmapHeaderT4(dec, &(val)->u.bitmapHeaderT4))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_BitmapHeaderT6(dec, &(val)->u.bitmapHeaderT6))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_BitmapHeaderT81(dec, &(val)->u.bitmapHeaderT81))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_BitmapHeaderT82(dec, &(val)->u.bitmapHeaderT82))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.bitmapHeaderNonStandard))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapCreatePDU_bitmapFormatHeader(BitmapCreatePDU_bitmapFormatHeader *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_BitmapHeaderUncompressed(&(val)->u.bitmapHeaderUncompressed);
	    break;
	case 4:
	    ASN1Free_BitmapHeaderT81(&(val)->u.bitmapHeaderT81);
	    break;
	case 5:
	    ASN1Free_BitmapHeaderT82(&(val)->u.bitmapHeaderT82);
	    break;
	case 6:
	    ASN1Free_NonStandardParameter(&(val)->u.bitmapHeaderNonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_BitmapCreatePDU(ASN1encoding_t enc, BitmapCreatePDU *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 7, (val)->o))
	return 0;
    l = ASN1uint32_uoctets((val)->bitmapHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bitmapHandle))
	return 0;
    if (!ASN1Enc_BitmapDestinationAddress(enc, &(val)->destinationAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_BitmapCreatePDU_attributes(enc, &(val)->attributes))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_WorkspacePoint(enc, &(val)->anchorPoint))
	    return 0;
    }
    if (!ASN1Enc_BitmapSize(enc, &(val)->bitmapSize))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_BitmapRegion(enc, &(val)->bitmapRegionOfInterest))
	    return 0;
    }
    if (!ASN1Enc_PixelAspectRatio(enc, &(val)->pixelAspectRatio))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_PointDiff16(enc, &(val)->scaling))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_BitmapCreatePDU_checkpoints(enc, &(val)->checkpoints))
	    return 0;
    }
    if (!ASN1Enc_BitmapCreatePDU_bitmapFormatHeader(enc, &(val)->bitmapFormatHeader))
	return 0;
    if ((val)->o[0] & 0x4) {
	if (!ASN1Enc_BitmapData(enc, &(val)->bitmapData))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->moreToFollow))
	return 0;
    if ((val)->o[0] & 0x2) {
	if (!ASN1Enc_BitmapCreatePDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapCreatePDU(ASN1decoding_t dec, BitmapCreatePDU *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 7, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bitmapHandle))
	return 0;
    if (!ASN1Dec_BitmapDestinationAddress(dec, &(val)->destinationAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_BitmapCreatePDU_attributes(dec, &(val)->attributes))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_WorkspacePoint(dec, &(val)->anchorPoint))
	    return 0;
    }
    if (!ASN1Dec_BitmapSize(dec, &(val)->bitmapSize))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_BitmapRegion(dec, &(val)->bitmapRegionOfInterest))
	    return 0;
    }
    if (!ASN1Dec_PixelAspectRatio(dec, &(val)->pixelAspectRatio))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_PointDiff16(dec, &(val)->scaling))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_BitmapCreatePDU_checkpoints(dec, &(val)->checkpoints))
	    return 0;
    }
    if (!ASN1Dec_BitmapCreatePDU_bitmapFormatHeader(dec, &(val)->bitmapFormatHeader))
	return 0;
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_BitmapData(dec, &(val)->bitmapData))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->moreToFollow))
	return 0;
    if ((val)->o[0] & 0x2) {
	if (!ASN1Dec_BitmapCreatePDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapCreatePDU(BitmapCreatePDU *val)
{
    if (val) {
	ASN1Free_BitmapDestinationAddress(&(val)->destinationAddress);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_BitmapCreatePDU_attributes(&(val)->attributes);
	}
	ASN1Free_PixelAspectRatio(&(val)->pixelAspectRatio);
	if ((val)->o[0] & 0x8) {
	    ASN1Free_BitmapCreatePDU_checkpoints(&(val)->checkpoints);
	}
	ASN1Free_BitmapCreatePDU_bitmapFormatHeader(&(val)->bitmapFormatHeader);
	if ((val)->o[0] & 0x4) {
	    ASN1Free_BitmapData(&(val)->bitmapData);
	}
	if ((val)->o[0] & 0x2) {
	    ASN1Free_BitmapCreatePDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_SIPDU(ASN1encoding_t enc, SIPDU *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 5, 28))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ArchiveAcknowledgePDU(enc, &(val)->u.archiveAcknowledgePDU))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ArchiveClosePDU(enc, &(val)->u.archiveClosePDU))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_ArchiveErrorPDU(enc, &(val)->u.archiveErrorPDU))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_ArchiveOpenPDU(enc, &(val)->u.archiveOpenPDU))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_BitmapAbortPDU(enc, &(val)->u.bitmapAbortPDU))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_BitmapCheckpointPDU(enc, &(val)->u.bitmapCheckpointPDU))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_BitmapCreatePDU(enc, &(val)->u.bitmapCreatePDU))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_BitmapCreateContinuePDU(enc, &(val)->u.bitmapCreateContinuePDU))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_BitmapDeletePDU(enc, &(val)->u.bitmapDeletePDU))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_BitmapEditPDU(enc, &(val)->u.bitmapEditPDU))
	    return 0;
	break;
    case 11:
	if (!ASN1Enc_ConductorPrivilegeGrantPDU(enc, &(val)->u.conductorPrivilegeGrantPDU))
	    return 0;
	break;
    case 12:
	if (!ASN1Enc_ConductorPrivilegeRequestPDU(enc, &(val)->u.conductorPrivilegeRequestPDU))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_DrawingCreatePDU(enc, &(val)->u.drawingCreatePDU))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_DrawingDeletePDU(enc, &(val)->u.drawingDeletePDU))
	    return 0;
	break;
    case 15:
	if (!ASN1Enc_DrawingEditPDU(enc, &(val)->u.drawingEditPDU))
	    return 0;
	break;
    case 16:
	if (!ASN1Enc_RemoteEventPermissionGrantPDU(enc, &(val)->u.remoteEventPermissionGrantPDU))
	    return 0;
	break;
    case 17:
	if (!ASN1Enc_RemoteEventPermissionRequestPDU(enc, &(val)->u.remoteEventPermissionRequestPDU))
	    return 0;
	break;
    case 18:
	if (!ASN1Enc_RemoteKeyboardEventPDU(enc, &(val)->u.remoteKeyboardEventPDU))
	    return 0;
	break;
    case 19:
	if (!ASN1Enc_RemotePointingDeviceEventPDU(enc, &(val)->u.remotePointingDeviceEventPDU))
	    return 0;
	break;
    case 20:
	if (!ASN1Enc_RemotePrintPDU(enc, &(val)->u.remotePrintPDU))
	    return 0;
	break;
    case 21:
	if (!ASN1Enc_SINonStandardPDU(enc, &(val)->u.siNonStandardPDU))
	    return 0;
	break;
    case 22:
	if (!ASN1Enc_WorkspaceCreatePDU(enc, &(val)->u.workspaceCreatePDU))
	    return 0;
	break;
    case 23:
	if (!ASN1Enc_WorkspaceCreateAcknowledgePDU(enc, &(val)->u.workspaceCreateAcknowledgePDU))
	    return 0;
	break;
    case 24:
	if (!ASN1Enc_WorkspaceDeletePDU(enc, &(val)->u.workspaceDeletePDU))
	    return 0;
	break;
    case 25:
	if (!ASN1Enc_WorkspaceEditPDU(enc, &(val)->u.workspaceEditPDU))
	    return 0;
	break;
    case 26:
	if (!ASN1Enc_WorkspacePlaneCopyPDU(enc, &(val)->u.workspacePlaneCopyPDU))
	    return 0;
	break;
    case 27:
	if (!ASN1Enc_WorkspaceReadyPDU(enc, &(val)->u.workspaceReadyPDU))
	    return 0;
	break;
    case 28:
	if (!ASN1Enc_WorkspaceRefreshStatusPDU(enc, &(val)->u.workspaceRefreshStatusPDU))
	    return 0;
	break;
    case 29:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_FontPDU(ee, &(val)->u.fontPDU))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 30:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_TextCreatePDU(ee, &(val)->u.textCreatePDU))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 31:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_TextDeletePDU(ee, &(val)->u.textDeletePDU))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 32:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_TextEditPDU(ee, &(val)->u.textEditPDU))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 33:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_VideoWindowCreatePDU(ee, &(val)->u.videoWindowCreatePDU))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 34:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_VideoWindowDeletePDU(ee, &(val)->u.videoWindowDeleatePDU))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 35:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_VideoWindowEditPDU(ee, &(val)->u.videoWindowEditPDU))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SIPDU(ASN1decoding_t dec, SIPDU *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 5, 28))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ArchiveAcknowledgePDU(dec, &(val)->u.archiveAcknowledgePDU))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ArchiveClosePDU(dec, &(val)->u.archiveClosePDU))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_ArchiveErrorPDU(dec, &(val)->u.archiveErrorPDU))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_ArchiveOpenPDU(dec, &(val)->u.archiveOpenPDU))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_BitmapAbortPDU(dec, &(val)->u.bitmapAbortPDU))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_BitmapCheckpointPDU(dec, &(val)->u.bitmapCheckpointPDU))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_BitmapCreatePDU(dec, &(val)->u.bitmapCreatePDU))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_BitmapCreateContinuePDU(dec, &(val)->u.bitmapCreateContinuePDU))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_BitmapDeletePDU(dec, &(val)->u.bitmapDeletePDU))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_BitmapEditPDU(dec, &(val)->u.bitmapEditPDU))
	    return 0;
	break;
    case 11:
	if (!ASN1Dec_ConductorPrivilegeGrantPDU(dec, &(val)->u.conductorPrivilegeGrantPDU))
	    return 0;
	break;
    case 12:
	if (!ASN1Dec_ConductorPrivilegeRequestPDU(dec, &(val)->u.conductorPrivilegeRequestPDU))
	    return 0;
	break;
    case 13:
	if (!ASN1Dec_DrawingCreatePDU(dec, &(val)->u.drawingCreatePDU))
	    return 0;
	break;
    case 14:
	if (!ASN1Dec_DrawingDeletePDU(dec, &(val)->u.drawingDeletePDU))
	    return 0;
	break;
    case 15:
	if (!ASN1Dec_DrawingEditPDU(dec, &(val)->u.drawingEditPDU))
	    return 0;
	break;
    case 16:
	if (!ASN1Dec_RemoteEventPermissionGrantPDU(dec, &(val)->u.remoteEventPermissionGrantPDU))
	    return 0;
	break;
    case 17:
	if (!ASN1Dec_RemoteEventPermissionRequestPDU(dec, &(val)->u.remoteEventPermissionRequestPDU))
	    return 0;
	break;
    case 18:
	if (!ASN1Dec_RemoteKeyboardEventPDU(dec, &(val)->u.remoteKeyboardEventPDU))
	    return 0;
	break;
    case 19:
	if (!ASN1Dec_RemotePointingDeviceEventPDU(dec, &(val)->u.remotePointingDeviceEventPDU))
	    return 0;
	break;
    case 20:
	if (!ASN1Dec_RemotePrintPDU(dec, &(val)->u.remotePrintPDU))
	    return 0;
	break;
    case 21:
	if (!ASN1Dec_SINonStandardPDU(dec, &(val)->u.siNonStandardPDU))
	    return 0;
	break;
    case 22:
	if (!ASN1Dec_WorkspaceCreatePDU(dec, &(val)->u.workspaceCreatePDU))
	    return 0;
	break;
    case 23:
	if (!ASN1Dec_WorkspaceCreateAcknowledgePDU(dec, &(val)->u.workspaceCreateAcknowledgePDU))
	    return 0;
	break;
    case 24:
	if (!ASN1Dec_WorkspaceDeletePDU(dec, &(val)->u.workspaceDeletePDU))
	    return 0;
	break;
    case 25:
	if (!ASN1Dec_WorkspaceEditPDU(dec, &(val)->u.workspaceEditPDU))
	    return 0;
	break;
    case 26:
	if (!ASN1Dec_WorkspacePlaneCopyPDU(dec, &(val)->u.workspacePlaneCopyPDU))
	    return 0;
	break;
    case 27:
	if (!ASN1Dec_WorkspaceReadyPDU(dec, &(val)->u.workspaceReadyPDU))
	    return 0;
	break;
    case 28:
	if (!ASN1Dec_WorkspaceRefreshStatusPDU(dec, &(val)->u.workspaceRefreshStatusPDU))
	    return 0;
	break;
    case 29:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_FontPDU(dd, &(val)->u.fontPDU))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 30:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_TextCreatePDU(dd, &(val)->u.textCreatePDU))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 31:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_TextDeletePDU(dd, &(val)->u.textDeletePDU))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 32:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_TextEditPDU(dd, &(val)->u.textEditPDU))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 33:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_VideoWindowCreatePDU(dd, &(val)->u.videoWindowCreatePDU))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 34:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_VideoWindowDeletePDU(dd, &(val)->u.videoWindowDeleatePDU))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 35:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_VideoWindowEditPDU(dd, &(val)->u.videoWindowEditPDU))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SIPDU(SIPDU *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ArchiveAcknowledgePDU(&(val)->u.archiveAcknowledgePDU);
	    break;
	case 2:
	    ASN1Free_ArchiveClosePDU(&(val)->u.archiveClosePDU);
	    break;
	case 3:
	    ASN1Free_ArchiveErrorPDU(&(val)->u.archiveErrorPDU);
	    break;
	case 4:
	    ASN1Free_ArchiveOpenPDU(&(val)->u.archiveOpenPDU);
	    break;
	case 5:
	    ASN1Free_BitmapAbortPDU(&(val)->u.bitmapAbortPDU);
	    break;
	case 6:
	    ASN1Free_BitmapCheckpointPDU(&(val)->u.bitmapCheckpointPDU);
	    break;
	case 7:
	    ASN1Free_BitmapCreatePDU(&(val)->u.bitmapCreatePDU);
	    break;
	case 8:
	    ASN1Free_BitmapCreateContinuePDU(&(val)->u.bitmapCreateContinuePDU);
	    break;
	case 9:
	    ASN1Free_BitmapDeletePDU(&(val)->u.bitmapDeletePDU);
	    break;
	case 10:
	    ASN1Free_BitmapEditPDU(&(val)->u.bitmapEditPDU);
	    break;
	case 11:
	    ASN1Free_ConductorPrivilegeGrantPDU(&(val)->u.conductorPrivilegeGrantPDU);
	    break;
	case 12:
	    ASN1Free_ConductorPrivilegeRequestPDU(&(val)->u.conductorPrivilegeRequestPDU);
	    break;
	case 13:
	    ASN1Free_DrawingCreatePDU(&(val)->u.drawingCreatePDU);
	    break;
	case 14:
	    ASN1Free_DrawingDeletePDU(&(val)->u.drawingDeletePDU);
	    break;
	case 15:
	    ASN1Free_DrawingEditPDU(&(val)->u.drawingEditPDU);
	    break;
	case 16:
	    ASN1Free_RemoteEventPermissionGrantPDU(&(val)->u.remoteEventPermissionGrantPDU);
	    break;
	case 17:
	    ASN1Free_RemoteEventPermissionRequestPDU(&(val)->u.remoteEventPermissionRequestPDU);
	    break;
	case 18:
	    ASN1Free_RemoteKeyboardEventPDU(&(val)->u.remoteKeyboardEventPDU);
	    break;
	case 19:
	    ASN1Free_RemotePointingDeviceEventPDU(&(val)->u.remotePointingDeviceEventPDU);
	    break;
	case 20:
	    ASN1Free_RemotePrintPDU(&(val)->u.remotePrintPDU);
	    break;
	case 21:
	    ASN1Free_SINonStandardPDU(&(val)->u.siNonStandardPDU);
	    break;
	case 22:
	    ASN1Free_WorkspaceCreatePDU(&(val)->u.workspaceCreatePDU);
	    break;
	case 23:
	    ASN1Free_WorkspaceCreateAcknowledgePDU(&(val)->u.workspaceCreateAcknowledgePDU);
	    break;
	case 24:
	    ASN1Free_WorkspaceDeletePDU(&(val)->u.workspaceDeletePDU);
	    break;
	case 25:
	    ASN1Free_WorkspaceEditPDU(&(val)->u.workspaceEditPDU);
	    break;
	case 26:
	    ASN1Free_WorkspacePlaneCopyPDU(&(val)->u.workspacePlaneCopyPDU);
	    break;
	case 27:
	    ASN1Free_WorkspaceReadyPDU(&(val)->u.workspaceReadyPDU);
	    break;
	case 28:
	    ASN1Free_WorkspaceRefreshStatusPDU(&(val)->u.workspaceRefreshStatusPDU);
	    break;
	case 29:
	    ASN1Free_FontPDU(&(val)->u.fontPDU);
	    break;
	case 30:
	    ASN1Free_TextCreatePDU(&(val)->u.textCreatePDU);
	    break;
	case 31:
	    ASN1Free_TextDeletePDU(&(val)->u.textDeletePDU);
	    break;
	case 32:
	    ASN1Free_TextEditPDU(&(val)->u.textEditPDU);
	    break;
	case 33:
	    ASN1Free_VideoWindowCreatePDU(&(val)->u.videoWindowCreatePDU);
	    break;
	case 34:
	    ASN1Free_VideoWindowDeletePDU(&(val)->u.videoWindowDeleatePDU);
	    break;
	case 35:
	    ASN1Free_VideoWindowEditPDU(&(val)->u.videoWindowEditPDU);
	    break;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\textobj.cpp ===
//
// TEXTOBJ.CPP
// Drawing objects: point, openpolyline, closepolyline, ellipse
//
// Copyright Microsoft 1998-
//
#include "precomp.h"
#include "nmwbobj.h"


TextObj::TextObj(void)
{
#ifdef _DEBUG
    FillMemory(&m_textMetrics, sizeof(m_textMetrics), DBG_UNINIT);
#endif // _DEBUG

    //
    // ALWAYS ZERO OUT m_textMetrics.  Calculations depend on the height
    // and width of chars being zero before the font is set.
    //
    ZeroMemory(&m_textMetrics, sizeof(m_textMetrics));

	SetMyWorkspace(NULL);
	SetOwnerID(g_MyMemberID);

	m_ToolType = TOOLTYPE_TEXT;

	//
	// Created locally, not selected, not editing or deleting.
	//
	CreatedLocally();
	ClearSelectionFlags();
	ClearEditionFlags();
	ClearDeletionFlags();
	SetType(siNonStandardPDU_chosen);

	SetFillColor(RGB(-1,-1,-1),TRUE);
	SetZOrder(front);

	//
	// No attributes changed, they will be set as we change them
	//
	SetWorkspaceHandle(g_pCurrentWorkspace == NULL ? 0 : g_pCurrentWorkspace->GetWorkspaceHandle()); 
	SetType(drawingCreatePDU_chosen);
	SetROP(R2_NOTXORPEN);
	SetPlaneID(1);
	SetMyPosition(NULL);
	SetMyWorkspace(NULL);
	// 1 Pixels for pen thickness
	SetPenThickness(2);
	SetAnchorPoint(0,0);
	
	RECT rect;
    ::SetRectEmpty(&rect);
	SetRect(&rect);
	SetBoundsRect(&rect);

    m_hFontThumb = ::CreateFont(0,0,0,0,FW_NORMAL,0,0,0,0,OUT_TT_PRECIS,
        CLIP_DFA_OVERRIDE, DRAFT_QUALITY,FF_SWISS,NULL);

	m_hFont = ::CreateFont(0,0,0,0,FW_NORMAL,0,0,0,0,OUT_TT_PRECIS,
				    CLIP_DFA_OVERRIDE, 
				    DRAFT_QUALITY,
				    FF_SWISS,NULL);

	m_nKerningOffset = 0;
	ResetAttrib();

}

TextObj::~TextObj( void )
{
	RemoveObjectFromResendList(this);
	RemoveObjectFromRequestHandleList(this);

	TRACE_DEBUG(("drawingHandle = %d", GetThisObjectHandle() ));

	//
	// Tell other nodes that we are gone
	//
	if(GetMyWorkspace() != NULL && WasDeletedLocally())
	{
		OnObjectDelete();
	}

	if(m_hFont)
	{
		::DeleteFont(m_hFont);
        m_hFont = NULL;
	}


	if (m_hFontThumb)
    {
        ::DeleteFont(m_hFontThumb);
        m_hFontThumb = NULL;
    }


	strTextArray.ClearOut();
    strTextArray.RemoveAll();

}

void TextObj::TextEditObj (TEXTPDU_ATTRIB* pEditAttrib )
{

	RECT		rect;
	POSITION	pos;
	POINT		anchorPoint;
	LONG 		deltaX = 0;
	LONG		deltaY = 0;

	TRACE_DEBUG(("TextEditObj drawingHandle = %d", GetThisObjectHandle() ));

	//
	// Was edited remotely
	//
	ClearEditionFlags();

	//
	// Get the previous anchor point
	//
	GetAnchorPoint(&anchorPoint);

	//
	// Read attributes
	//
	m_dwChangedAttrib = pEditAttrib->attributesFlag;
	GetTextAttrib(pEditAttrib);

	//
	// Change the anchor point
	//
	if(HasAnchorPointChanged())
	{
		{
			//
			// Get the delta from previous anchor point
			//
			deltaX -= anchorPoint.x; 
			deltaY -= anchorPoint.y;

			//
			// Get the new anchor point
			//
			GetAnchorPoint(&anchorPoint);
			deltaX += anchorPoint.x; 
			deltaY += anchorPoint.y;
			TRACE_DEBUG(("Delta (%d,%d)", deltaX , deltaY));

			//
			// Was edited remotely
			//
			ClearEditionFlags();
		}
		
		UnDraw();

		GetRect(&rect);
		::OffsetRect(&rect,  deltaX, deltaY);
		SetRect(&rect);
		SetBoundsRect(&rect);

	}
	

	if(HasAnchorPointChanged() ||
		HasFillColorChanged() ||
		HasPenColorChanged() ||
		HasFontChanged() ||
		HasTextChanged())
	{
		Draw(NULL);
	}
	else if(HasZOrderChanged())
	{
		if(GetZOrder() == front)
		{
			g_pDraw->BringToTopSelection(FALSE, this);
		}
		else
		{
			g_pDraw->SendToBackSelection(FALSE, this);
		}
	}
	//
	// If it just select/unselected it
	//
	else if(HasViewStateChanged())
	{
		; // do nothing
	}
	//
	// If we have a valid font. 
	//
	else if(GetFont())
	{
		Draw();
	}

	//
	// Reset all the attributes
	//
	ResetAttrib();
}


void    TextObj::GetTextAttrib(TEXTPDU_ATTRIB * pattributes)
{
	if(HasPenColorChanged())
	{
		SetPenColor(pattributes->textPenColor, TRUE);
	}
	
	if(HasFillColorChanged())
	{
		SetFillColor(pattributes->textFillColor, TRUE);
	}
	
	if(HasViewStateChanged())
	{

		//
		// If the other node is selecting the drawing or unselecting
		//
		if(pattributes->textViewState == selected_chosen)
		{
			SelectedRemotely();
		}
		else if(pattributes->textViewState == unselected_chosen)
		{
			ClearSelectionFlags();
		}

		SetViewState(pattributes->textViewState);
	}
	
	if(HasZOrderChanged())
	{
		SetZOrder((ZOrder)pattributes->textZOrder);
	}
	
	if(HasAnchorPointChanged())
	{
		SetAnchorPoint(pattributes->textAnchorPoint.x, pattributes->textAnchorPoint.y );
	}
	
	if(HasFontChanged())
	{
		UnDraw();

		if(m_hFont)
		{
			::DeleteFont(m_hFont);
			m_hFont = NULL;
		}
	    m_hFont = ::CreateFontIndirect(&pattributes->textFont);
	    if (!m_hFont)
	    {
	        // Could not create the font
	        ERROR_OUT(("Failed to create font"));
	    }

        if (m_hFontThumb)
        {
            ::DeleteFont(m_hFontThumb);
            m_hFontThumb = NULL;
        }
        m_hFontThumb = ::CreateFontIndirect(&pattributes->textFont);
        if (!m_hFontThumb)
        {
            // Could not create the font
            ERROR_OUT(("Failed to create thumbnail font"));
        }
	}
	
	int lines = 0;
	UINT maxString = 0;
	
	if(HasTextChanged())
	{

		BYTE * pBuff = (BYTE *)&pattributes->textString;
		VARIABLE_STRING * pVarString = NULL;

		lines = pattributes->numberOfLines;
		int i;
		CHAR * cBuff = NULL;
		LPWSTR   lpWideCharStr;

		for (i = 0; i < lines ; i++)
		{
			pVarString  = (VARIABLE_STRING *) pBuff;

			lpWideCharStr = (LPWSTR)&pVarString->string;
			UINT strSize = 0;
			strSize= WideCharToMultiByte(CP_ACP, 0, lpWideCharStr, -1, NULL, 0, NULL, NULL ); 

			//
			// Get the longest string
			//
			if(strSize > maxString)
			{
				maxString = strSize;
			}
			
			DBG_SAVE_FILE_LINE
			cBuff = new TCHAR[strSize];
			WideCharToMultiByte(CP_ACP, 0, lpWideCharStr, -1, cBuff, strSize, NULL, NULL );
			strTextArray.SetSize(i);
			strTextArray.SetAtGrow(i, cBuff );
			delete [] cBuff;

 			ASSERT(pVarString->header.start.y == i);
			pBuff += pVarString->header.len;

		}

		//
		// Calculate the rect
		//
		if(m_hFont)
		{

			//
			// Remove the old text before we paly with the text size
			//
			UnDraw();

			g_pDraw->PrimeFont(g_pDraw->m_hDCCached, m_hFont, &m_textMetrics);
			g_pDraw->UnPrimeFont(g_pDraw->m_hDCCached);
		}	
	}

}

void    TextObj::SetTextAttrib(TEXTPDU_ATTRIB * pattributes)
{

	if(HasPenColorChanged())
	{
		GetPenColor(&pattributes->textPenColor);
	}
	
	if(HasFillColorChanged())
	{
		GetFillColor(&pattributes->textFillColor);
	}
	
	if(HasViewStateChanged())
	{
		pattributes->textViewState = GetViewState();
	}
	
	if(HasZOrderChanged())
	{
		pattributes->textZOrder = GetZOrder();
	}
	
	if(HasAnchorPointChanged())
	{
		GetAnchorPoint(&pattributes->textAnchorPoint);
	}
	
	if(HasFontChanged())
	{
	    ::GetObject(m_hFont, sizeof(LOGFONT), &pattributes->textFont);
	}
	

	if(HasTextChanged())
	{
		BYTE * pBuff = (BYTE *)&pattributes->textString;
		VARIABLE_STRING * pVarString= NULL;
		LPWSTR   lpWideCharStr;

		int size = strTextArray.GetSize();
		int i;

		for (i = 0; i < size ; i++)
		{
			pVarString = (VARIABLE_STRING *)pBuff;
			lpWideCharStr = (LPWSTR)&pVarString->string;
			int strSize = 0;
			strSize= MultiByteToWideChar(CP_ACP, 0, strTextArray[i], -1, lpWideCharStr, 0)*sizeof(WCHAR); 
			MultiByteToWideChar(CP_ACP, 0, strTextArray[i], -1, lpWideCharStr, strSize);
			pVarString->header.len = strSize + sizeof(VARIABLE_STRING_HEADER);
			pVarString->header.start.x = 0; // JOSEF change that
			pVarString->header.start.y = i;
			pBuff += pVarString->header.len;
		}

		pattributes->numberOfLines = size;

		//
		// Since we are sending text, need to send some font
		//
		::GetObject(m_hFont, sizeof(LOGFONT), &pattributes->textFont);
	}


	
}


void TextObj::CreateTextPDU(ASN1octetstring_t *pData, UINT choice)
{

	MSTextPDU * pTextPDU = NULL;
	UINT stringSize = 0;	// Size of all the strings UNICODE
	int lines = 0;			// Number of text lines

	//
	// Calculate the size of the whole pdu
	//
	ULONG length = 0;
	if(choice == textDeletePDU_chosen)
	{
		length = sizeof(MSTextDeletePDU);
	}
	else
	{

		//
		// Calculate the size of the text
		//
		if(HasTextChanged())
		{
			int i;
			lines = strTextArray.GetSize();

			for (i = 0; i < lines ; i++)
			{
				stringSize += MultiByteToWideChar(CP_ACP, 0, strTextArray[i], -1, NULL, 0) * sizeof(WCHAR); 
			}
		}

		length = sizeof(MSTextPDU) + sizeof(VARIABLE_STRING_HEADER)* lines + stringSize;
	}

	DBG_SAVE_FILE_LINE
	pTextPDU = (MSTextPDU *) new BYTE[length];

	//
	// PDU choice: create, edit delete
	//
	pTextPDU->header.nonStandardPDU = choice;

	//
	// This objects handle
	//
	pTextPDU->header.textHandle = GetThisObjectHandle();
	TRACE_DEBUG(("Text >> Text handle  = %d",pTextPDU->header.textHandle ));

	//
	// This objects workspacehandle
	//
	WorkspaceObj * pWorkspace = GetMyWorkspace();
	ASSERT(pWorkspace);
    if(pWorkspace == NULL)
    {
        delete [] pTextPDU;
        pData->value = NULL;
        pData->length = 0;
        return;
    }
	pTextPDU->header.workspaceHandle = pWorkspace->GetThisObjectHandle();
	TRACE_DEBUG(("Text >> Workspace handle  = %d",pTextPDU->header.workspaceHandle ));

	if(choice != textDeletePDU_chosen)
	{
		//
		// Get all the attributes that changed
		//
		pTextPDU->attrib.attributesFlag = GetPresentAttribs();
		SetTextAttrib(&pTextPDU->attrib);
	}

	//
	// Set the pointer for the data that is going to be encoded
	//
	pData->value = (ASN1octet_t *)pTextPDU;
	pData->length = length;
}




void TextObj::UnDraw(void)
{
	RECT rect;
	GetBoundsRect(&rect);
	g_pDraw->InvalidateSurfaceRect(&rect,TRUE);
}


void TextObj::Draw(HDC hDC, BOOL thumbNail, BOOL bPrinting)
{

	if(!bPrinting)
	{

		//
		// Don't draw anything if we don't belong in this workspace
		//
		if(GetWorkspaceHandle() != g_pCurrentWorkspace->GetThisObjectHandle())
		{
			return;
		}
	}

    RECT        clipBox;
    BOOL        dbcsEnabled = GetSystemMetrics(SM_DBCSENABLED);
    INT		    *tabArray; 
    UINT        ch;
    int         i,j;
    BOOL        zoomed    = g_pDraw->Zoomed();
    int		    oldBkMode = 0;
    int         iIndex    = 0;
    POINT       pointPos;
	int		    nLastTab;
	ABC		    abc;
    int		    iLength;
    TCHAR *     strLine;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicText::Draw");

	if(hDC == NULL)
	{
		hDC = g_pDraw->m_hDCCached;
	}

    //
    // Only draw anything if the bounding rectangle intersects the current
    // clip box.
    //
    if (::GetClipBox(hDC, &clipBox) == ERROR)
	{
        WARNING_OUT(("Failed to get clip box"));
	}

    //
    // Select the font.
    //
    if (thumbNail)
	{
        TRACE_MSG(("Using thumbnail font"));
        g_pDraw->PrimeFont(hDC, m_hFontThumb, &m_textMetrics);
	}
    else
	{
        TRACE_MSG(("Using standard font"));
        g_pDraw->PrimeFont(hDC, m_hFont, &m_textMetrics);
	}

    //
    // Set the color and mode for drawing.
    //
    COLORREF rgb;
    GetPenColor(&rgb);
    
    ::SetTextColor(hDC, SET_PALETTERGB(rgb));

    //
    // Set the background to be transparent
    //
    oldBkMode = ::SetBkMode(hDC, TRANSPARENT);

    //
    // Calculate the bounding rectangle, accounting for the new font.
    //
    CalculateBoundsRect();

    if (!::IntersectRect(&clipBox, &clipBox, &m_rect))
    {
        TRACE_MSG(("No clip/bounds intersection"));
        return;
    }



    //
    // Get the start point for the text.
    //
    pointPos.x = m_rect.left + m_nKerningOffset;
    pointPos.y = m_rect.top;

    //
    // Loop through the text strings drawing each as we go.
    //
    for (iIndex = 0; iIndex < strTextArray.GetSize(); iIndex++)
	{
        //
        // Get a reference to the line to be printed for convenience.
        //
        strLine  = (LPTSTR)strTextArray[iIndex];
        iLength  = lstrlen(strLine);

        //
        // Only draw the line if there are any characters in it.
        //
        if (iLength > 0)
	  	{
            if (zoomed)
	  		{
				// if new fails just skip it
				DBG_SAVE_FILE_LINE
				tabArray = new INT[iLength+1];
				if( tabArray == NULL )
                {
                    ERROR_OUT(("Failed to allocate tabArray"));
					continue;
                }

				// We are zoomed. Must calculate char spacings
				// ourselfs so that they end up proportionally
				// in the right places. TabbedTextOut will not
				// do this right so we have to use ExtTextOut with
				// a tab array.

				// figure out tab array
                j = 0;
				nLastTab = 0;
                for (i=0; i < iLength; i++)
	  			{
                    ch = strLine[(int)i]; //Don't worry about DBCS here...
					abc = GetTextABC(strLine, 0, i);

					if( j > 0 )
						tabArray[j-1] = abc.abcB - nLastTab;

					nLastTab = abc.abcB;
					j++;
	  			}

				// Now, strip out any tab chars so they don't interact
				// in an obnoxious manner with the tab array we just
				// made and so they don't make ugly little 
				// blocks when they are drawn.
                for (i=0; i < iLength; i++)
	  			{
                    ch = strLine[(int)i];
                    if ((dbcsEnabled) && (IsDBCSLeadByte((BYTE)ch)))
						i++;
					else
                    if(strLine[(int)i] == '\t')
                        strLine[i] = ' '; // blow off tab, tab array 
											   // will compensate for this
	  			}

				// do it
                ::ExtTextOut(hDC, pointPos.x,
                                pointPos.y,
                                0,
                                NULL,
                                strLine,
                                iLength,
                                tabArray);

				delete [] tabArray; 
			}
            else
			{
                POINT   ptPos;

                GetAnchorPoint(&ptPos);

				// Not zoomed, just do it
				::TabbedTextOut(hDC, pointPos.x,
								 pointPos.y,
								 strLine,
								 iLength,
								 0,
								 NULL,
                                 ptPos.x);
			}
		}

        //
        // Move to the next line.
        //
        ASSERT(m_textMetrics.tmHeight != DBG_UNINIT);
        pointPos.y += (m_textMetrics.tmHeight);
	}

    //
    // Do NOT draw focus if clipboard or printing
    //
	if (WasSelectedLocally() && (hDC == g_pDraw->m_hDCCached))
	{
		DrawRect();
	}


    //
    // Restore the old background mode.
    //
    ::SetBkMode(hDC, oldBkMode);
    g_pDraw->UnPrimeFont(hDC);


	//
	// If we are drawing on top of a remote pointer, draw it.
	//
	BitmapObj* remotePointer = NULL;
	WBPOSITION pos = NULL;
	remotePointer = g_pCurrentWorkspace->RectHitRemotePointer(&m_rect, GetPenThickness()/2, NULL);
	while(remotePointer)
	{
		remotePointer->Draw();
		remotePointer = g_pCurrentWorkspace->RectHitRemotePointer(&m_rect, GetPenThickness()/2, remotePointer->GetMyPosition());
	}

    
}

void TextObj::SetPenColor(COLORREF rgb, BOOL isPresent)
{
	ChangedPenColor();
	m_bIsPenColorPresent = isPresent;
	if(!isPresent)
	{
		return;
	}
	
	m_penColor.rgbtRed = GetRValue(rgb);
	m_penColor.rgbtGreen = GetGValue(rgb);
	m_penColor.rgbtBlue = GetBValue(rgb);

}

BOOL TextObj::GetPenColor(COLORREF * rgb)
{
	if(m_bIsPenColorPresent)
	{
		*rgb = RGB(m_penColor.rgbtRed, m_penColor.rgbtGreen, m_penColor.rgbtBlue);
	}
	return m_bIsPenColorPresent;
}

BOOL TextObj::GetPenColor(RGBTRIPLE* rgb)
{
	if(m_bIsPenColorPresent)
	{
		*rgb = m_penColor;
	}
	return m_bIsPenColorPresent;
}


void TextObj::SetFillColor(COLORREF rgb, BOOL isPresent)
{
	ChangedFillColor();
	m_bIsFillColorPresent = isPresent;
	if(!isPresent)
	{
		return;
	}
	
	m_fillColor.rgbtRed = GetRValue(rgb);
	m_fillColor.rgbtGreen = GetGValue(rgb);
	m_fillColor.rgbtBlue = GetBValue(rgb);

}

BOOL TextObj::GetFillColor(COLORREF* rgb)
{
	if(m_bIsFillColorPresent && rgb !=NULL)
	{
		*rgb = RGB(m_fillColor.rgbtRed, m_fillColor.rgbtGreen, m_fillColor.rgbtBlue);
	}
	return m_bIsFillColorPresent;
}

BOOL TextObj::GetFillColor(RGBTRIPLE* rgb)
{
	if(m_bIsFillColorPresent && rgb!= NULL)
	{
		*rgb = m_fillColor;
	}
	return m_bIsFillColorPresent;
}

//
// Get the encoded buffer for Drawing Create PDU
//
void	TextObj::GetEncodedCreatePDU(ASN1_BUF *pBuf)
{
	SIPDU *sipdu = NULL;
	DBG_SAVE_FILE_LINE
	sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
	if(sipdu)
	{
		sipdu->choice = siNonStandardPDU_chosen;
		CreateNonStandardPDU(&sipdu->u.siNonStandardPDU.nonStandardTransaction, NonStandardTextID);
		CreateTextPDU(&sipdu->u.siNonStandardPDU.nonStandardTransaction.data, textCreatePDU_chosen);
		((MSTextPDU *)sipdu->u.siNonStandardPDU.nonStandardTransaction.data.value)->header.nonStandardPDU = textCreatePDU_chosen;
		ASN1_BUF encodedPDU;
		g_pCoder->Encode(sipdu, pBuf);
		if(sipdu->u.siNonStandardPDU.nonStandardTransaction.data.value)
		{
			delete sipdu->u.siNonStandardPDU.nonStandardTransaction.data.value;
		}
		delete [] sipdu;
	}
	else
	{
		TRACE_MSG(("Failed to create penMenu"));
        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);

	}
}

void TextObj::SendTextPDU(UINT choice)
{

	if(!g_pNMWBOBJ->CanDoText())
	{
		return;
	}

	SIPDU *sipdu = NULL;
	DBG_SAVE_FILE_LINE
	sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
	if(sipdu)
	{
		sipdu->choice = siNonStandardPDU_chosen;
		CreateNonStandardPDU(&sipdu->u.siNonStandardPDU.nonStandardTransaction, NonStandardTextID);
		CreateTextPDU(&sipdu->u.siNonStandardPDU.nonStandardTransaction.data, choice);
        if(sipdu->u.siNonStandardPDU.nonStandardTransaction.data.value == NULL)
        {
            return;
        }

		T120Error rc = SendT126PDU(sipdu);
		if(rc == T120_NO_ERROR)
		{
			ResetAttrib();
			SIPDUCleanUp(sipdu);
		}
	}
	else
	{
		TRACE_MSG(("Failed to create sipdu"));
        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
	}

}

//
// UI Created a new Drawing Object
//
void TextObj::SendNewObjectToT126Apps(void)
{
	SendTextPDU(textCreatePDU_chosen);
}

//
// UI Edited the Drawing Object
//
void	TextObj::OnObjectEdit(void)
{
	g_bContentsChanged = TRUE;
	SendTextPDU(textEditPDU_chosen);
}

//
// UI Deleted the Drawing Object
//
void	TextObj::OnObjectDelete(void)
{
	g_bContentsChanged = TRUE;
	SendTextPDU(textDeletePDU_chosen);
}

//
//
// Function:    TextObj::SetFont
//
// Purpose:     Set the font to be used for drawing
//
//
void TextObj::SetFont(HFONT hFont)
{
    MLZ_EntryOut(ZONE_FUNCTION, "TextObj::SetFont");

    // Get the font details
    LOGFONT lfont;
    ::GetObject(hFont, sizeof(LOGFONT), &lfont);

    //
    // Pass the logical font into the SetFont() function
    //
	SetFont(&lfont);
}




//
//
// Function:    TextObj::SetText
//
// Purpose:     Set the text of the object
//
//
void TextObj::SetText(TCHAR * strText)
{
    // Remove all the current stored text
	strTextArray.SetSize(0);

    // Scan the text for carriage return and new-line characters
    int iNext = 0;
    int iLast = 0;
    int textSize = lstrlen(strText);
    TCHAR savedChar[1];

    //
    // In this case, we don't know how many lines there will be.  So we
    // use Add() from the StrArray class.
    //
    while (iNext < textSize)
    {
        // Find the next carriage return or line feed
        iNext += StrCspn(strText + iNext, "\r\n");

        // Extract the text before the terminator
        // and add it to the current list of text lines.

        savedChar[0] = strText[iNext];
        strText[iNext] = 0;
        strTextArray.Add((strText+iLast));
        strText[iNext] = savedChar[0];
    

        if (iNext < textSize)
        {
            // Skip the carriage return
            if (strText[iNext] == '\r')
                iNext++;

            // Skip a following new line (if there is one)
            if (strText[iNext] == '\n')
                iNext++;

            // Update the index of the start of the next line
            iLast = iNext;
        }
    }

	if(textSize)
	{
    
		// Calculate the bounding rectangle for the new text
		CalculateBoundsRect();
		ChangedText();
	}
}



//
//
// Function:    TextObj::SetText
//
// Purpose:     Set the text of the object
//
//
void TextObj::SetText(const StrArray& _strTextArray)
{
    // Scan the text for carriage return and new-line characters
    int iSize = _strTextArray.GetSize();

    //
    // In this case we know how many lines, so set that # then use SetAt()
    // to stick text there.
    //
    strTextArray.RemoveAll();
    strTextArray.SetSize(iSize);

    int iNext = 0;
    for ( ; iNext < iSize; iNext++)
    {
        strTextArray.SetAt(iNext, _strTextArray[iNext]);
    }

    // Calculate the new bounding rectangle
    CalculateBoundsRect();

}



//
//
// Function:    TextObj::SetFont(metrics)
//
// Purpose:     Set the font to be used for drawing
//
//
void TextObj::SetFont(LOGFONT *pLogFont, BOOL bReCalc )
{
    HFONT hNewFont;

    MLZ_EntryOut(ZONE_FUNCTION, "TextObj::SetFont");

    // Ensure that the font can be resized by the zoom function
    // (proof quality prevents font scaling).
    pLogFont->lfQuality = DRAFT_QUALITY;

    //zap FontAssociation mode (bug 3258)
    pLogFont->lfClipPrecision |= CLIP_DFA_OVERRIDE;

    // Always work in cell coordinates to get scaling right
    TRACE_MSG(("Setting font height %d, width %d, face %s, family %d, precis %d",
        pLogFont->lfHeight,pLogFont->lfWidth,pLogFont->lfFaceName,
        pLogFont->lfPitchAndFamily, pLogFont->lfOutPrecision));

    hNewFont = ::CreateFontIndirect(pLogFont);
    if (!hNewFont)
    {
        // Could not create the font
        ERROR_OUT(("Failed to create font"));
        DefaultExceptionHandler(WBFE_RC_WINDOWS, 0);
	    return;
    }

    // We are now guaranteed to be able to delete the old font
    if (m_hFont != NULL)
    {
        DeleteFont(m_hFont);
    }
    m_hFont = hNewFont;


    // Calculate the line height for this font
    ASSERT(g_pDraw);
	g_pDraw->PrimeFont(g_pDraw->GetCachedDC(), m_hFont, &m_textMetrics);

    // Set up the thumbnail font, forcing truetype if not currently TT
    if (!(m_textMetrics.tmPitchAndFamily & TMPF_TRUETYPE))
    {
        pLogFont->lfFaceName[0]    = 0;
        pLogFont->lfOutPrecision   = OUT_TT_PRECIS;
        TRACE_MSG(("Non-True type font"));
    }

    if (m_hFontThumb != NULL)
    {
        ::DeleteFont(m_hFontThumb);
        m_hFontThumb = NULL;
    }
    m_hFontThumb = ::CreateFontIndirect(pLogFont);
    if (!m_hFontThumb)
    {
        // Could not create the font
        ERROR_OUT(("Failed to create thumbnail font"));
    }

    // Calculate the bounding rectangle, accounting for the new font
    if( bReCalc )
	    CalculateBoundsRect();

	ChangedFont();

	g_pDraw->UnPrimeFont(g_pDraw->m_hDCCached);
}


//
//
// Function:    TextObj::CalculateRect
//
// Purpose:     Calculate the bounding rectangle of a portion of the object
//
//
void TextObj::CalculateRect(int iStartX,
                                     int iStartY,
                                     int iStopX,
                                     int iStopY,
                                    LPRECT lprcResult)
{
    RECT    rcResult;
    RECT    rcT;
    int     iIndex;

    MLZ_EntryOut(ZONE_FUNCTION, "TextObj::CalculateRect");

    //
    // NOTE:
    // We must use an intermediate rectangle, so as not to disturb the
    // contents of the passed-in one until done.  lprcResult may be pointing
    // to the current bounds rect, and we call functions from here that
    // may need its current value.
    //

    // Initialize the result rectangle
    ::SetRectEmpty(&rcResult);

    if (!strTextArray.GetSize())
    {
        // Text is empty
        goto DoneCalc;
    }

    // Allow for special limit values and ensure that the start and stop
    // character positions are in range.
    if (iStopY == LAST_LINE)
    {
        iStopY = strTextArray.GetSize() - 1;
    }
    iStopY = min(iStopY, strTextArray.GetSize() - 1);
    iStopY = max(iStopY, 0);

    if (iStopX == LAST_CHAR)
    {
        iStopX = lstrlen(strTextArray[iStopY]);
    }
    iStopX = min(iStopX, lstrlen(strTextArray[iStopY]));
    iStopX = max(iStopX, 0);

    // Loop through the text strings, adding each to the rectangle
    for (iIndex = iStartY; iIndex <= iStopY; iIndex++)
    {
        int iLeftX = ((iIndex == iStartY) ? iStartX : 0);
        int iRightX = ((iIndex == iStopY)
                        ? iStopX : lstrlen(strTextArray[iIndex]));

        GetTextRectangle(iIndex, iLeftX, iRightX, &rcT);
        ::UnionRect(&rcResult, &rcResult, &rcT);
    }

DoneCalc:
    *lprcResult = rcResult;
}

//
//
// Function:    TextObj::CalculateBoundsRect
//
// Purpose:     Calculate the bounding rectangle of the object
//
//
void TextObj::CalculateBoundsRect(void)
{
    // Set the new bounding rectangle
    CalculateRect(0, 0, LAST_CHAR, LAST_LINE, &m_rect);
}


//
//
// Function:    TextObj::GetTextABC
//
// Purpose:     Calculate the ABC numbers for a string of text
//																			
// COMMENT BY RAND: The abc returned is for the whole string, not just one
//					char. I.e, ABC.abcA is the offset to the first glyph in
//					the string, ABC.abcB is the sum of all of the glyphs and
//					ABC.abcC is the trailing space after the last glyph. 	
//					ABC.abcA + ABC.abcB + ABC.abcC is the total rendered 	
//					length including overhangs.								
//
// Note - we never use the A spacing so it is always 0
//
ABC TextObj::GetTextABC( LPCTSTR pText,
                                int iStartX,
                                int iStopX)
{
	MLZ_EntryOut(ZONE_FUNCTION, "TextObj::GetTextABC");
	ABC  abcResult;
    HDC  hDC;
	BOOL rc = FALSE;
	ABC  abcFirst;
	ABC  abcLast;
	BOOL zoomed = g_pDraw->Zoomed();
	int  nCharLast;
	int  i;
	LPCTSTR pScanStr;
	
	ZeroMemory( (PVOID)&abcResult, sizeof abcResult );
	ZeroMemory( (PVOID)&abcFirst, sizeof abcFirst );
	ZeroMemory( (PVOID)&abcLast, sizeof abcLast );

	// Get the standard size measure of the text
	LPCTSTR pABC = (pText + iStartX);
	int pABCLength = iStopX - iStartX;
	hDC = g_pDraw->GetCachedDC();
	g_pDraw->PrimeFont(hDC, m_hFont, &m_textMetrics);

	//
	// We must temporarily unzoom if we are currently zoomed since the
	// weird Windows font handling will not give us the same answer for
	// the text extent in zoomed mode for some TrueType fonts
	//
	if (zoomed)
    {
		::ScaleViewportExtEx(hDC, 1, g_pDraw->ZoomFactor(), 1, g_pDraw->ZoomFactor(), NULL);
    }

    DWORD size = ::GetTabbedTextExtent(hDC, pABC, pABCLength, 0, NULL);

	// We now have the advance width of the text
	abcResult.abcB = LOWORD(size);
	TRACE_MSG(("Basic text width is %d",abcResult.abcB));

	// Allow for C space (or overhang)
	if (iStopX > iStartX)
		{
		if (m_textMetrics.tmPitchAndFamily & TMPF_TRUETYPE)
			{
			if(GetSystemMetrics( SM_DBCSENABLED ))
				{
				// have to handle DBCS on both ends
				if( IsDBCSLeadByte( (BYTE)pABC[0] ) )
					{
					// pack multi byte char into a WORD for GetCharABCWidths
					WORD wMultiChar = MAKEWORD( pABC[1], pABC[0] );
					rc = ::GetCharABCWidths(hDC, wMultiChar, wMultiChar, &abcFirst);
					}
				else
					{
					// first char is SBCS
					rc = ::GetCharABCWidths(hDC, pABC[0], pABC[0], &abcFirst );
					}

				// Check for DBCS as last char. Have to scan whole string to be sure
				pScanStr = pABC;
				nCharLast = 0;
				for( i=0; i<pABCLength; i++, pScanStr++ )
					{
					nCharLast = i;
					if( IsDBCSLeadByte( (BYTE)*pScanStr ) )
						{
						i++;
						pScanStr++;
						}
					}

				if( IsDBCSLeadByte( (BYTE)pABC[nCharLast] ) )
					{
					// pack multi byte char into a WORD for GetCharABCWidths
					ASSERT( (nCharLast+1) < pABCLength );
					WORD wMultiChar = MAKEWORD( pABC[nCharLast+1], pABC[nCharLast] );
					rc = ::GetCharABCWidths(hDC, wMultiChar, wMultiChar, &abcLast);
					}
				else
					{
					// last char is SBCS
					rc = ::GetCharABCWidths(hDC, pABC[nCharLast], pABC[nCharLast], &abcLast );
					}
				}
			else
				{
				// SBCS, no special fiddling, just call GetCharABCWidths()
				rc = ::GetCharABCWidths(hDC, pABC[0], pABC[0], &abcFirst );

				nCharLast = pABCLength-1;
				rc = rc && ::GetCharABCWidths(hDC, pABC[nCharLast], pABC[nCharLast], &abcLast );
				}

			TRACE_MSG(("abcFirst: rc=%d, a=%d, b=%d, c=%d", 
						rc, abcFirst.abcA, abcFirst.abcB, abcFirst.abcC) );
			TRACE_MSG(("abcLast: rc=%d, a=%d, b=%d, c=%d", 
						rc, abcLast.abcA, abcLast.abcB, abcLast.abcC) );
			}


		if( rc )
			{
			// The text was trutype and we got good abcwidths
			// Give the C space of the last characters from
			// the string as the C space of the text.
			abcResult.abcA = abcFirst.abcA;
			abcResult.abcC = abcLast.abcC;
			}
		else
			{
			//
			// Mock up C value for a non TT font by taking some of overhang as
			// the negative C value.
			//
			//TRACE_MSG(("Using overhang -%d as C space",m_textMetrics.tmOverhang/2));
			
			// Adjust B by -overhang to make update rect schoot
			// far enough to the left so that the toes of italic cap A's
			// don't get clipped. Ignore comment above.
			abcResult.abcB -= m_textMetrics.tmOverhang;
			}
		}

	//
	// If we temporarily unzoomed then restore it now
	//
	if (zoomed)
    {
		::ScaleViewportExtEx(hDC, g_pDraw->ZoomFactor(), 1, g_pDraw->ZoomFactor(), 1, NULL);
	}

	TRACE_MSG(("Final text width is %d, C space %d",abcResult.abcB,abcResult.abcC));

	return abcResult;
}





//
//
// Function:    TextObj::GetTextRectangle
//
// Purpose:     Calculate the bounding rectangle of a portion of the object
//
//
void TextObj::GetTextRectangle(int iStartY,
                                        int iStartX,
                                        int iStopX,
                                        LPRECT lprc)
{
	// ABC structures for text sizing
	ABC abcText1;
	ABC abcText2;
	int iLeftOffset = 0;
	MLZ_EntryOut(ZONE_FUNCTION, "TextObj::GetTextRectangle");

    ASSERT(iStartY < strTextArray.GetSize());

	// Here we calculate the width of the text glyphs in which we
	// are interested. In case there are tabs involved we must start
	// with position 0 and get two lengths then subtract them

	abcText1 = GetTextABC(strTextArray[iStartY], 0, iStopX);

	if (iStartX > 0)
	{
		
		// The third param used to be iStartX-1 which is WRONG. It
		// has to point to the first char pos past the string
		// we are using.
		abcText2 = GetTextABC(strTextArray[iStartY], 0, iStartX);

		
		// Just use B part for offset. Adding A snd/or C to it moves the update
		// rectangle too far to the right and clips the char
		iLeftOffset = abcText2.abcB;
		}
	else
		{
		
		ZeroMemory( &abcText2, sizeof abcText2 );
		}

	//
	// We need to allow for A and C space in the bounding rectangle.  Use
	// ABS function just to make sure we get a large enough rectangle.
	//
	
	// Move A and C from original offset calc to here for width of update 
	// rectangle. Add in tmOverhang (non zero for non-tt fonts) to compensate
	// for the kludge in GetTextABC()....THIS EDITBOX CODE HAS GOT TO GO...
	abcText1.abcB = abcText1.abcB - iLeftOffset +	
					  abs(abcText2.abcA) + abs(abcText2.abcC) +
					  abs(abcText1.abcA) + abs(abcText1.abcC) +
					  m_textMetrics.tmOverhang;

	TRACE_DEBUG(("Left offset %d",iLeftOffset));
	TRACE_DEBUG(("B width now %d",abcText1.abcB));

	// Build the result rectangle.
	// Note that we never return an empty rectangle. This allows for the
	// fact that the Windows rectangle functions will ignore empty
	// rectangles completely. This would cause the bounding rectangle
	// calculation (for instance) to go wrong if the top or bottom lines
	// in a text object were empty.
    ASSERT(m_textMetrics.tmHeight != DBG_UNINIT);
	int iLineHeight = m_textMetrics.tmHeight + m_textMetrics.tmExternalLeading;

    lprc->left = 0;
    lprc->top = 0;
    lprc->right = max(1, abcText1.abcB);
    lprc->bottom = iLineHeight;
    ::OffsetRect(lprc, iLeftOffset, iLineHeight * iStartY);

	// rect is the correct width at this point but it might need to be schooted to 
	// the left a bit to allow for kerning of 1st letter (bug 469)
	if( abcText1.abcA < 0 )
	{
        ::OffsetRect(lprc, abcText1.abcA, 0);
		m_nKerningOffset = -abcText1.abcA;
	}
	else
		m_nKerningOffset = 0;

    POINT   pt;
    GetAnchorPoint(&pt);
    ::OffsetRect(lprc, pt.x, pt.y);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\tool.hpp ===
//
// TOOL.HPP
// Tool Classes
//
// Copyright Microsoft 1998-
//
#ifndef __TOOL_HPP_
#define __TOOL_HPP_


class DCWbGraphic;


//
// Tool types
//
#define TOOLTYPE_FIRST  0
enum
{
    TOOLTYPE_SELECT = TOOLTYPE_FIRST,
    TOOLTYPE_ERASER,
    TOOLTYPE_TEXT,
    TOOLTYPE_HIGHLIGHT,
    TOOLTYPE_PEN,
    TOOLTYPE_LINE,
    TOOLTYPE_BOX,
    TOOLTYPE_FILLEDBOX,
    TOOLTYPE_ELLIPSE,
    TOOLTYPE_FILLEDELLIPSE,
    TOOLTYPE_REMOTEPOINTER,

    // This must come last
    TOOLTYPE_MAX
}; 


#define TOOL_INDEX(cmd)     ((cmd) - IDM_TOOLS_START)


#define DEF_PENCOLOR        RGB(0, 0, 0)
#define DEF_HIGHLIGHTCOLOR  RGB(255, 255, 0)

#define NUM_OF_WIDTHS       4



//
//
// Class:   WbTool
//
// Purpose: Base Tool class
//
//
class WbTool
{
public:
    //
    // Constructors
    //
    WbTool(int toolType);
    ~WbTool();

    //
    // Return the type of the tool
    //
    int ToolType(void) { return m_toolType; }

    //
    // Return whether the tool supports various attributes
    //
    BOOL HasColor(void);        // Tool supports colors
    BOOL HasWidth(void);        // Tool supports widths
    BOOL HasFont(void);         // Tool supports font

    //
    // Return the handle of the cursor for the tool
    //
    HCURSOR GetCursorForTool(void);

    //
    // Get/set the tool attributes
    //
    UINT GetWidthAtIndex(UINT uiIndex){ return m_uiWidths[uiIndex]; }
    VOID SetWidthAtIndex(UINT uiIndex, UINT uiWidth)
                               { m_uiWidths[uiIndex] = uiWidth; }

    void SetFont(HFONT hFont);
    void DeselectGraphic(void) { m_selectedTool = TOOLTYPE_MAX; }
    void SelectGraphic(T126Obj* pGraphic);

    //
    // Return the pen attributes
    //
    COLORREF GetColor(void)  { return m_clrCur; }
    void     SetColor(COLORREF clr) { m_clrCur = clr; }
    UINT     GetWidth(void)  { return m_uiWidths[m_uiWidthIndexCur]; }
    void     SetWidthIndex(UINT uiWidthIndex){ m_uiWidthIndexCur = uiWidthIndex; }
    UINT     GetWidthIndex(void)  { return m_uiWidthIndexCur; }
    int      GetROP(void);
    HFONT    GetFont(void) { return(m_hFont); }


protected:
    //
    // Tool type
    //
    int         m_toolType;
    int         m_selectedTool;

    //
    // Tool attributes
    //
    COLORREF    m_clrCur;
    UINT        m_uiWidths[NUM_OF_WIDTHS];
    UINT        m_uiWidthIndexCur;
    HFONT       m_hFont;
};


#endif // __TOOL_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\tool.cpp ===
//
// TOOL.CPP
// Drawing Tools
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"
#include "draw.hpp"



//
//
// Function:    WbTool
//
// Purpose:     Constructors for tools
//
//
WbTool::WbTool(int toolType)
{
    COLORREF    defColor;
    UINT        defWidth;
    int         iIndex;

    MLZ_EntryOut(ZONE_FUNCTION, "WbTool::WbTool");


    // Save the tool type
    m_toolType = toolType;
    m_selectedTool = TOOLTYPE_MAX;

    m_uiWidthIndexCur = 0;

    // Read the colors of the pen
    if (toolType == TOOLTYPE_HIGHLIGHT)
        defColor = DEF_HIGHLIGHTCOLOR;
    else
        defColor = DEF_PENCOLOR;
    m_clrCur = defColor;

    for (iIndex = 0; iIndex < NUM_OF_WIDTHS; iIndex++)
    {
        defWidth = 	(toolType == TOOLTYPE_HIGHLIGHT) ?
            g_HighlightWidths[iIndex] :
            g_PenWidths[iIndex];

        m_uiWidths[iIndex] = defWidth;
    }

    // Read the font details
    LOGFONT lfont;

    ::GetObject(::GetStockObject(DEFAULT_GUI_FONT), sizeof(LOGFONT), &lfont);
    lfont.lfClipPrecision |= CLIP_DFA_OVERRIDE;
    lfont.lfCharSet = DEFAULT_CHARSET;
    m_hFont = ::CreateFontIndirect(&lfont);
}


//
// WbTool::~WbTool
// Destructor
//
WbTool::~WbTool()
{
    if (m_hFont != NULL)
    {
        ::DeleteFont(m_hFont);
        m_hFont = NULL;
    }
}



//
//
// Function:    HasColor
//
// Purpose:     Return TRUE if the tool supports colors
//
//
BOOL WbTool::HasColor(void) 
{
    BOOL bResult = TRUE;

    switch (m_toolType)
    {
        case TOOLTYPE_ERASER:
            bResult = FALSE;
            break;

    }

    return bResult;
}


//
//
// Function:    HasWidth
//
// Purpose:     Return TRUE if the tool supports widths
//
//
BOOL WbTool::HasWidth(void) 
{
    BOOL bResult = FALSE;

    switch (m_toolType)
    {
        case TOOLTYPE_PEN:
        case TOOLTYPE_HIGHLIGHT:
        case TOOLTYPE_LINE:
        case TOOLTYPE_BOX:
        case TOOLTYPE_ELLIPSE:
            bResult = TRUE;
            break;

        // For the selector tool, it depends on the selected object type
        case TOOLTYPE_SELECT:
            switch (m_selectedTool)
            {
		        case TOOLTYPE_LINE:
        		case TOOLTYPE_BOX:
			    case TOOLTYPE_ELLIPSE:
                case TOOLTYPE_PEN:
                case TOOLTYPE_HIGHLIGHT:
                {
                    bResult = TRUE;
                    break;
                }
            }
            break;

        default:
            // The rest don't support widths, including filled tools
            break;
    }

    return bResult;
}




//
//
// Function:	HasFont
//
// Purpose:	 Return TRUE if the tool supports fonts
//
//
BOOL WbTool::HasFont(void)
{
	BOOL bResult = FALSE;

	switch (m_toolType)
	{
		case TOOLTYPE_TEXT:
			bResult = TRUE;
			break;

		// For the selector tool, it depends on the selected object type
		case TOOLTYPE_SELECT:
            switch (m_selectedTool)
            {
                case TOOLTYPE_TEXT:
                    bResult = TRUE;
                    break;

                default:
                    break;
            }
            break;

        default:
            break;
	}

    return bResult;
}

//
//
// Function:    GetROP
//
// Purpose:     Return the ROP for this tool
//
//
int WbTool::GetROP(void) 
{
    // If this is a highlight tool we use MASKPEN, else we use the standard
    if (m_toolType == TOOLTYPE_HIGHLIGHT)
        return(R2_MASKPEN);
    else
        return(R2_COPYPEN);
}


//
//
// Function:    GetCursorForTool
//
// Purpose:     Return the handle to the cursor for the tool
//
//
HCURSOR WbTool::GetCursorForTool(void) 
{
    int   nName = -1;

    switch(m_toolType)
    {
        case TOOLTYPE_SELECT:
            break; // use default arrow for select cursor (bug 439)

        case TOOLTYPE_PEN:
            nName = PENFREEHANDCURSOR;
            break;

        case TOOLTYPE_LINE:
        case TOOLTYPE_BOX:
        case TOOLTYPE_FILLEDBOX:
        case TOOLTYPE_ELLIPSE:
        case TOOLTYPE_FILLEDELLIPSE:
            nName = PENCURSOR;
            break;

        case TOOLTYPE_HIGHLIGHT:
            nName = HIGHLIGHTFREEHANDCURSOR;
            break;

        case TOOLTYPE_TEXT:
            nName = TEXTCURSOR;
            break;
    
        case TOOLTYPE_ERASER:
            nName = DELETECURSOR;
            break;

        default:
            // Do nothing - the name pointer is NULL
            break;
    }

    HCURSOR hcursorResult = NULL;

    if (nName == -1)
    {
        // Return the standard arrow cursor as a default
        hcursorResult = ::LoadCursor(NULL, IDC_ARROW);
    }
    else
    {
        // Return the cursor for the tool
        hcursorResult = ::LoadCursor(g_hInstance, MAKEINTRESOURCE( nName ) );
    }

    return hcursorResult;
}

//
//
// Function:    SetFont
//
// Purpoxse:     Set the current font of the tool
//
//
void WbTool::SetFont(HFONT hFont)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbTool::SetFont");

    // Get the font details
    LOGFONT lfont;

    ::GetObject(hFont, sizeof(LOGFONT), &lfont);
    //zap FontAssociation mode (bug 3258)
    lfont.lfClipPrecision |= CLIP_DFA_OVERRIDE;

    // Set the local font
    if (m_hFont != NULL)
    {
        ::DeleteFont(m_hFont);
        m_hFont = NULL;
    }
    m_hFont = ::CreateFontIndirect(&lfont);
}


//
//
// Function:    SelectGraphic
//
// Purpose:     Set the current selected graphic type, and copy the colors,
//              widths and font into this tool's attributes.
//
//
void WbTool::SelectGraphic(T126Obj* pGraphic)
{
    UINT uiIndex;

    // Save the selected tool type
    m_selectedTool = pGraphic->GraphicTool();

    // Get the tool object for the selected tool type
    WbTool* pTool = g_pMain->m_ToolArray[m_selectedTool];

    if (HasColor())
    {
        pGraphic->GetPenColor(&m_clrCur);
    }

    if (HasWidth())
    {
        for (uiIndex = 0; uiIndex < NUM_OF_WIDTHS; uiIndex++)
        {
            SetWidthAtIndex(uiIndex, pTool->GetWidthAtIndex(uiIndex));
        }

        // See if the object's width matches any of the available colors
        // for this tool type
        for (uiIndex = 0; uiIndex < NUM_OF_WIDTHS; uiIndex++)
        {
            if (pGraphic->GetPenThickness() == m_uiWidths[uiIndex])
            {
                break;
            }
        }

        SetWidthIndex(uiIndex);
    }

    if (HasFont())
    {
        if (pGraphic->GraphicTool() == TOOLTYPE_TEXT)
        {
            SetFont(((TextObj *)pGraphic)->GetFont());
        }
    }
}



//
// WbMainWindow::InitToolArray
// Create the array of WB tools
//
//
BOOL WbMainWindow::InitToolArray(void)
{
    int tool;
    WbTool * pTool;

    for (tool = TOOLTYPE_FIRST; tool < TOOLTYPE_MAX; tool++)
    {
        // Add the new tool to the array
		DBG_SAVE_FILE_LINE
        pTool = new WbTool(tool);
        if (!pTool)
        {
            ERROR_OUT(("Can't create tool %d", tool));
            return(FALSE);
        }

        m_ToolArray[tool] = pTool;
    }

    return(TRUE);
}


//
// WbMainWindow::DestroyToolAray()
//
// Free the array of WB tools
//
void WbMainWindow::DestroyToolArray(void)
{
    int         tool;
    WbTool *    pTool;

    for (tool = TOOLTYPE_FIRST; tool < TOOLTYPE_MAX; tool++)
    {
        pTool = m_ToolArray[tool];
        if (pTool != NULL)
        {
            m_ToolArray[tool] = NULL;
            delete pTool;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\twnd.cpp ===
//
// TWND.CPP
// ToolBar handler
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"


//
// This is the button layout for the toolbar
//
static UINT g_uToolBar[TOOLBAR_MAXBUTTON] =
{
    IDM_SELECT,
    IDM_ERASER,
    IDM_TEXT,
    IDM_HIGHLIGHT,
    IDM_PEN,
    IDM_LINE,
    IDM_BOX,
    IDM_FILLED_BOX,
    IDM_ELLIPSE,
    IDM_FILLED_ELLIPSE,
    0,
    IDM_ZOOM,
    IDM_REMOTE,
    IDM_LOCK,
    IDM_SYNC,
    0,
    IDM_GRAB_AREA,
    IDM_GRAB_WINDOW
};



//
//
// Function:    WbToolBar constructor
//
// Purpose:     Create the tool window
//
//
WbToolBar::WbToolBar()
{
    m_hwnd = NULL;
    m_hbmImages = NULL;
}


WbToolBar::~WbToolBar()
{
    if (m_hbmImages != NULL)
    {
        ::DeleteBitmap(m_hbmImages);
        m_hbmImages = NULL;
    }
}



//
//
// Function:    Create
//
// Purpose:     Create the tool window
//
//
BOOL WbToolBar::Create(HWND hwndParent)
{
    TBBUTTON    tb;
    int         iImage, i;

    //
    // Create the tool window
    //
    m_hwnd = ::CreateWindowEx(0, TOOLBARCLASSNAME, NULL,
        WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | TBSTYLE_WRAPABLE | WS_TABSTOP |
        CCS_NODIVIDER | CCS_NOPARENTALIGN | CCS_NOMOVEY | CCS_NORESIZE,
        0, 0, 0, 0,
        hwndParent, (HMENU)IDC_TOOLBAR, g_hInstance, NULL);

    if (!m_hwnd)
    {
        ERROR_OUT(("WbToolBar::Create create of window failed"));
        return(FALSE);
    }

    //
    // Tell COMCTL32 the structure size for the buttons
    //
    ::SendMessage(m_hwnd, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);

    //
    // And the margin for the buttons
    //
    ::SendMessage(m_hwnd, TB_SETINDENT, TOOLBAR_MARGINX, 0);


    //
    // Add the buttons into the toolbar
    //

    ZeroMemory(&tb, sizeof(tb));
    iImage = 0;

    for (i = 0; i < TOOLBAR_MAXBUTTON; i++)
    {
        tb.fsState = TBSTATE_ENABLED;
        tb.idCommand = g_uToolBar[i];

        if (!tb.idCommand)
        {
            tb.fsStyle = TBSTYLE_SEP;
            tb.iBitmap = TOOLBAR_SEPARATORY;
        }
        else
        {
            tb.fsStyle = TBSTYLE_BUTTON;
            tb.iBitmap = iImage++;
        }

        if (!::SendMessage(m_hwnd, TB_ADDBUTTONS, 1, (LPARAM)&tb))
        {
            ERROR_OUT(("Failed to add button %d to toolbar", i));
            return(FALSE);
        }
    }

    //
    // Tell the toolbar the image and button sizes
    //
    ::SendMessage(m_hwnd, TB_SETBITMAPSIZE, 0,
        MAKELONG(TOOLBAR_IMAGEWIDTH, TOOLBAR_IMAGEHEIGHT));
    ::SendMessage(m_hwnd, TB_SETBUTTONSIZE, 0,
        MAKELONG(TOOLBAR_BTNWIDTH, TOOLBAR_BTNHEIGHT));

    //
    // Load the bitmap resource -- use sys color change handler
    //
    RecolorButtonImages();

    // set up rows
    ::SendMessage(m_hwnd, TB_SETROWS, MAKELPARAM(TOOLBAR_NUMROWS +
        TOOLBAR_NUMSEPARATORS, TRUE), 0);

    ::InvalidateRect(m_hwnd, NULL, TRUE);

    return(TRUE);
}



//
//
// Function:    GetNaturalSize
//
// Purpose:     Return the natural size of the tool client area
//
//
void WbToolBar::GetNaturalSize(LPSIZE lpsize)
{
    RECT rectButton;
    RECT rectButton2;

    if (!::SendMessage(m_hwnd, TB_GETITEMRECT, TOOLBAR_FIRSTBUTTON,
        (LPARAM)&rectButton))
    {
        ::SetRectEmpty(&rectButton);
    }

    if (!::SendMessage(m_hwnd, TB_GETITEMRECT, TOOLBAR_LASTBUTTON,
        (LPARAM)&rectButton2))
    {
        ::SetRectEmpty(&rectButton2);
    }

    lpsize->cx = TOOLBAR_WIDTH;
    lpsize->cy = rectButton2.bottom - rectButton.top +
        // Vertical margin
        (rectButton2.bottom - rectButton2.top);
}


//
//
// Function:    WidthFromHeight
//
// Purpose:     Calculate the width of the toolbar, given the height for
//              the fixed mode.
//
//
UINT WbToolBar::WidthFromHeight(UINT uiHeight)
{
    SIZE    size;

    GetNaturalSize(&size);
    return(size.cx);
}


//
//
// Function:    PushDown
//
// Purpose:     Push down a button in the tool window
//
//
BOOL WbToolBar::PushDown(UINT uiId)
{
    UINT butId;
    BOOL bDown;

    // If this isn't an exclusive checkable group, it's easy.
    if ((uiId < IDM_TOOLS_START) || (uiId >= IDM_TOOLS_MAX))
    {
        return (BOOL)(::SendMessage(m_hwnd, TB_CHECKBUTTON, uiId, MAKELPARAM(TRUE, 0)));
    }

    // Push this one down and pop up all the others
    for (butId = IDM_TOOLS_START; butId < IDM_TOOLS_MAX; butId++)
    {
        bDown = (butId == uiId);
        ::SendMessage(m_hwnd, TB_CHECKBUTTON, butId, MAKELPARAM(bDown, 0));
    }

    return( TRUE );
}


//
//
// Function:    PopUp
//
// Purpose:     Pop up a button in the tool window
//
//
BOOL WbToolBar::PopUp(UINT uiId)
{
    return (BOOL)(::SendMessage(m_hwnd, TB_CHECKBUTTON, uiId, MAKELPARAM(FALSE, 0)));
}

//
//
// Function:    Enable
//
// Purpose:     Enable a button in the tool window
//
//
BOOL WbToolBar::Enable(UINT uiId)
{
    return (BOOL)(::SendMessage(m_hwnd, TB_ENABLEBUTTON, uiId, MAKELPARAM(TRUE, 0)));
}

//
//
// Function:    Disable
//
// Purpose:     Disable a button in the tool window
//
//
BOOL WbToolBar::Disable(UINT uiId)
{
    return (BOOL)(::SendMessage(m_hwnd, TB_ENABLEBUTTON, uiId, MAKELPARAM(FALSE, 0)));
}




void WbToolBar::RecolorButtonImages(void)
{
    // re-color bitmap for toolbar
    HBITMAP hbmNew;

    hbmNew = (HBITMAP)::LoadImage(g_hInstance, MAKEINTRESOURCE(IDR_TOOLS),
        IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS | LR_DEFAULTCOLOR | LR_DEFAULTSIZE);

    if (hbmNew == NULL)
    {
        ERROR_OUT(("OnSysColorChange:  failed to load toolbar bitmap"));
    }
    else
    {
        BITMAP  bmp;

        ::GetObject(hbmNew, sizeof(bmp), &bmp);

        if (m_hbmImages == NULL)
        {
            TBADDBITMAP addBitmap;

            // First time
            addBitmap.hInst = NULL;
            addBitmap.nID   = (UINT_PTR)hbmNew;

            ::SendMessage(m_hwnd, TB_ADDBITMAP,
                (bmp.bmWidth / TOOLBAR_IMAGEWIDTH), (LPARAM)&addBitmap);
        }
        else
        {
            TBREPLACEBITMAP replaceBitmap;

            replaceBitmap.hInstOld = NULL;
            replaceBitmap.nIDOld = (UINT_PTR)m_hbmImages;
            replaceBitmap.hInstNew = NULL;
            replaceBitmap.nIDNew = (UINT_PTR)hbmNew;

            ::SendMessage(m_hwnd, TB_REPLACEBITMAP, 0, (LPARAM)&replaceBitmap);
        }

        if (m_hbmImages)
        {
            ::DeleteBitmap(m_hbmImages);
        }

        m_hbmImages = hbmNew;
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\txted.cpp ===
//
// TXTED.CPP
// Editor for Text Objects
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"




/////////////////////////////////////////////////////////////////////////////
// WbTextBox


//
// This is a subclassed edit field
//

WbTextBox::WbTextBox(WbTextEditor * pEditor)
{
    OSVERSIONINFO OsData;

    m_hwnd = NULL;
    m_pfnEditPrev = NULL;

    m_MaxRect.left = 0;
    m_MaxRect.top = 0;
    m_MaxRect.right = INT_MAX;
    m_MaxRect.bottom = INT_MAX;

    ::SetRectEmpty(&m_rectErase);

    m_bInIME = FALSE;
    m_bDontEscapeThisTime = FALSE;

    // see if we need to make adjustments for NT.
    m_ptNTBooger.x = 0;
    m_ptNTBooger.y = 0;
    OsData.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if( GetVersionEx( &OsData ) )
    {
        if( OsData.dwPlatformId == VER_PLATFORM_WIN32_NT )
        {
            // NT editboxes are offset from Win95 editboxes. We
            // have to de-booger them
            m_ptNTBooger.x = 3;
        }
    }

    m_pEditor = pEditor;
}


//
// ~WbTextBox()
//
WbTextBox::~WbTextBox()
{
    if (m_hwnd != NULL)
    {
        ::DestroyWindow(m_hwnd);
        m_hwnd = NULL;
    }
}



//
// Create()
// Creates an edit field then subclasses it with our window procedure
//
BOOL WbTextBox::Create(HWND hwndParent)
{
    ASSERT(!m_hwnd);

    m_hwnd = ::CreateWindowEx(0, _T("EDIT"), NULL,
        WS_CHILD | WS_BORDER | ES_MULTILINE | ES_WANTRETURN |
        ES_AUTOHSCROLL | ES_AUTOVSCROLL,
        CW_USEDEFAULT, 0, CW_USEDEFAULT, 0,
        hwndParent, NULL, g_hInstance, NULL);

    if (!m_hwnd)
    {
        ERROR_OUT(("WbTextBox::Create failed to create edit window"));
        return(FALSE);
    }

    // Init the data
    ::SetWindowLongPtr(m_hwnd, GWLP_USERDATA, (LONG_PTR)this);

    // Subclass the window
    m_pfnEditPrev = (WNDPROC)::SetWindowLongPtr(m_hwnd, GWLP_WNDPROC,
        (LONG_PTR)TextWndProc);

    return(TRUE);

}



//
// TextWndProc()
// Message subclass handler for edit field
//
LRESULT CALLBACK TextWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult;
    WbTextBox * ptb;

    ptb = (WbTextBox *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);
    ASSERT(ptb != NULL);
    ASSERT(ptb->m_pfnEditPrev != NULL);

    lResult = 0;

    switch( message )
    {
        case WM_CLEAR:
        case WM_CUT:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            ptb->OnClearCut();
            break;

        case WM_UNDO:
        case WM_PASTE:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            ptb->OnUndoPaste();
            break;

        case WM_IME_STARTCOMPOSITION:
        {
            ptb->m_bInIME = TRUE;
            ptb->m_bDontEscapeThisTime = TRUE;

            // let editbox take it from here
            goto DefEditProc;
            break;
        }


        case WM_IME_CHAR:
        {
            ptb->m_bDontEscapeThisTime = FALSE;
            goto DefEditProc;
            break;
        }


        case WM_IME_ENDCOMPOSITION:
        {
            ptb->m_bInIME = FALSE;
            goto DefEditProc;
            break;
        }

        case WM_KILLFOCUS:
        {
            if (ptb->m_bInIME && g_fnImmGetContext)
            {
                HIMC hImc = g_fnImmGetContext(hwnd);
                if ((hImc != NULL) && g_fnImmNotifyIME)
                {
                    // we're loosing control, tell IME to wrap it up (bug 130)
                    g_fnImmNotifyIME( hImc, NI_COMPOSITIONSTR, CPS_COMPLETE, 0 );
                }
            }
            // goto DefEditProc;
            break;
        }

        case WM_CHAR:
            ptb->OnChar((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_KEYUP:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            ptb->OnKeyUp((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_SYSKEYDOWN:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            ptb->OnSysKeyDown((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_TIMER:
            ptb->OnTimer((UINT)wParam);
            break;

        case WM_MOUSEMOVE:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            ptb->OnMouseMove((UINT)wParam, (short)LOWORD(lParam), (short)HIWORD(lParam));
            break;

        case WM_LBUTTONUP:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            ptb->OnLButtonUp((UINT)wParam, (short)LOWORD(lParam), (short)HIWORD(lParam));
            break;

        case WM_MOVE:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            ptb->OnMove((short)LOWORD(lParam), (short)HIWORD(lParam));
            break;

        default:
DefEditProc:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            break;
    }

    return(lResult);
}


//
// OnClearCut()
//
void WbTextBox::OnClearCut()
{
    POINT   ptCaret;
    POINT   ptPos;

    ::GetCaretPos(&ptCaret);
    m_pEditor->GetAnchorPoint(&ptPos);

    m_pEditor->m_cursorXYPos.x = ptCaret.x + ptPos.x;
    m_pEditor->m_cursorXYPos.y = ptCaret.y + ptPos.y;
	OnUndoPaste();
}


//
// OnUndoPaste()
//
void WbTextBox::OnUndoPaste(void)
{
    FitBox();
    AutoCaretScroll();
	OnTimer(0);

}


//
// OnChar()
//
void  WbTextBox::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    int    nFirst;
    int    nLast;
    int    nPrevNumLines;
    int    nPrevNumChars;
    LRESULT dwPosChar;
    POINT  ptTop;

    // clear ignore next escape (NM4db:456)
    m_bDontEscapeThisTime = FALSE;

    ::SendMessage(m_hwnd, EM_GETSEL, (WPARAM)&nFirst, (LPARAM)&nLast);
    dwPosChar = ::SendMessage(m_hwnd, EM_POSFROMCHAR, nFirst, 0);
    ptTop.x = (short)LOWORD(dwPosChar);
    ptTop.y = (short)HIWORD(dwPosChar);

    nPrevNumLines = (int)::SendMessage(m_hwnd, EM_GETLINECOUNT, 0, 0);
    nPrevNumChars = (int)::SendMessage(m_hwnd, EM_LINELENGTH, (WPARAM)-1, 0);

    ::CallWindowProc(m_pfnEditPrev, m_hwnd, WM_CHAR, nChar, MAKELONG(nRepCnt, nFlags));

    SetupBackgroundRepaint( ptTop,
         (nPrevNumLines != ::SendMessage(m_hwnd, EM_GETLINECOUNT, 0, 0))||
         (nPrevNumChars > ::SendMessage(m_hwnd, EM_LINELENGTH, (WPARAM)-1, 0)));

    FitBox();
	m_pEditor->ChangedText();

}




void WbTextBox::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    POINT   ptCaret;
    POINT   ptPos;

    AutoCaretScroll();

    switch( nChar )
    {
        case VK_MENU:
        case VK_SHIFT:
        case VK_CONTROL:
            break;


        case VK_DELETE:
            SelectAtLeastOne();
            ::SendMessage(m_hwnd, WM_CLEAR, 0, 0);
            break;


        case VK_ESCAPE:
            if( !m_bInIME )
            {
                if( m_bDontEscapeThisTime )
                    m_bDontEscapeThisTime = FALSE;
                else
                {
                    // End the text entry abandoning the changes
                    g_pDraw->EndTextEntry(FALSE);
                    return; // we don't exist anymore, bail out
                }
            }
            break;


        default:
            break;
    }

    ::GetCaretPos(&ptCaret);
    m_pEditor->GetAnchorPoint(&ptPos);

    m_pEditor->m_cursorXYPos.x = ptCaret.x + ptPos.x;
    m_pEditor->m_cursorXYPos.y = ptCaret.y + ptPos.y;
}





void WbTextBox::OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    switch( nChar )
    {
        case VK_MENU:
            // ignore next escape (NM4db:456)
            m_bDontEscapeThisTime = TRUE;
            break;

        default:
            break;
    }
}




BOOL WbTextBox::FitBox( void )
{
    RECT rectErase;
    RECT crEditRect;
    RECT crEditBox;
    RECT crEditWnd;
    RECT crDrawWnd;
    int   nDeltaWidth, nDeltaHeight;
    HDC     hDC = NULL;
    HDC     hDrawDC = NULL;
    TCHAR *szBoxText = NULL;
    BOOL bNoChanges;
    POINT   ptDrawLoc;
    HFONT   hSaveFont = NULL;
    POINT  ptBitmapTopLeft;
    LPTSTR pszText;
    int    nTextLen;
    int textSize;

    bNoChanges = TRUE;

    hDC = ::GetDC(m_hwnd);
    if (hDC == NULL)
    {
        bNoChanges = TRUE;
        goto bail_out;
    }

    hDrawDC = g_pDraw->GetCachedDC();
    if (hDrawDC == NULL)
    {
        bNoChanges = TRUE;
        goto bail_out;
    }

    hSaveFont = SelectFont(hDC, m_pEditor->GetFont());

    textSize = ::GetWindowTextLength(m_hwnd);
    if (!textSize)
    {
        // Use a " " for a string, which is two characters.
		DBG_SAVE_FILE_LINE
        szBoxText = new TCHAR[2];
        if (!szBoxText)
        {
            ERROR_OUT(("Failed to allocate TCHAR array for empty text"));
            goto bail_out;
        }
        else
        {
            szBoxText[0] = 0;
        }
    }
    else
    {
		DBG_SAVE_FILE_LINE
        szBoxText = new TCHAR[textSize+1];
        if (!szBoxText)
        {
            ERROR_OUT(("Failed to allocate TCHAR array for object text"));
            goto bail_out;
        }
        else
        {
            ::GetWindowText(m_hwnd, (LPTSTR)szBoxText, textSize+1);
        }
    }

    // Have to check string length for NT. crEditRect comes back from
    // DrawText    giant-positive (i.e., still equal to m_MaxRect) if szBoxText
    // is empty. This causes crEditRect to overflow to giant negative later
    // resulting in very bizare painting problems. Win95 doesn't care because
    // it returns 16bit results that look like -1 instead of giant positive.

    ::GetClientRect(g_pDraw->m_hwnd, &crDrawWnd );

    // BUG 464 -DrawText doesn't calc widths involving tabs the same way a
    //            standard edit control does so replace it with DrawTextEx
    //            using the DT_EDITCONTROL format
    crEditRect = m_MaxRect;
    pszText = szBoxText;
    nTextLen = lstrlen(szBoxText);

	::DrawTextEx( hDC,
		  ((nTextLen == 0) ? " " : pszText),
		  ((nTextLen == 0) ? 1 : nTextLen),
		  &crEditRect,
		  DT_CALCRECT | DT_EXPANDTABS | DT_NOPREFIX | DT_EDITCONTROL,
		  NULL );



	m_pEditor->SetText(szBoxText);

    // BUG 464 (continued) -DrawTextEx doesn't include blank-last-lines in its height
    //                        calc like DrawText does so have to add an extra line
    //                        height for blank lines to have same behavior as DrawText
    ASSERT(m_pEditor->m_textMetrics.tmHeight != DBG_UNINIT);
    if ((nTextLen >= 2) && !IsDBCSLeadByte(pszText[nTextLen-2]) && (pszText[nTextLen-1] == _T('\n')) )
        crEditRect.bottom += m_pEditor->m_textMetrics.tmHeight;

    // NT sanity check if this still fails
    if ( ((crEditRect.right - crEditRect.left) == (m_MaxRect.right - m_MaxRect.left)) ||
         ((crEditRect.right - crEditRect.left) <= 0) )
    {
        crEditRect.right = crEditRect.left + crDrawWnd.right - crDrawWnd.left;
    }

    if ( ((crEditRect.bottom - crEditRect.top) == (m_MaxRect.bottom - m_MaxRect.top)) ||
         ((crEditRect.bottom - crEditRect.top) <= 0) )
    {
        crEditRect.bottom = crEditRect.top + crDrawWnd.bottom - crDrawWnd.top;
    }

    ::GetClientRect(m_hwnd, &crEditBox);
    ::GetWindowRect(m_hwnd, &crEditWnd);
    ::MapWindowPoints(NULL, g_pDraw->m_hwnd, (LPPOINT)&crEditWnd, 2);

    // do min size check for IME's.
    int nMinWidth;
    ASSERT(m_pEditor->m_textMetrics.tmMaxCharWidth != DBG_UNINIT);
    nMinWidth = MIN_FITBOX_CHARS*m_pEditor->m_textMetrics.tmMaxCharWidth;
    if ((crEditRect.right - crEditRect.left) < nMinWidth )
        crEditRect.right = crEditRect.left + nMinWidth;

    // must add some slop to prevent autoscroll from kicking in
    crEditRect.right += 2*m_pEditor->m_textMetrics.tmMaxCharWidth;

    ASSERT(m_pEditor->m_textMetrics.tmHeight != DBG_UNINIT);
    crEditRect.bottom += m_pEditor->m_textMetrics.tmHeight;

    //pretend we had a right or bottom scroll
    ::OffsetRect(&crEditRect, -1, -1);

    nDeltaWidth = (crEditRect.right - crEditRect.left) - (crEditBox.right - crEditBox.left);
    if (nDeltaWidth > 0)
    {
        bNoChanges = FALSE;
        if ( crEditRect.left < 0 )
        {
            // right scroll, adjust right edge
            crEditWnd.right += nDeltaWidth;
        }
        else
        {
            // left scroll, adjust left edge
            crEditWnd.left -= nDeltaWidth;
        }
    }

    nDeltaHeight = (crEditRect.bottom - crEditRect.top) - (crEditBox.bottom - crEditBox.top);
    if (nDeltaHeight > 0)
    {
        bNoChanges = FALSE;
        if( crEditRect.left < 0 )
        {
            // bottom scroll, adjust bottom edge
            crEditWnd.bottom += nDeltaHeight;
        }
        else
        {
            // top scroll, adjust top edge
            crEditWnd.top -= nDeltaHeight;
        }
    }

    if( bNoChanges )
        goto bail_out;

    // resize
    ::MoveWindow(m_hwnd, crEditWnd.left, crEditWnd.top,
        crEditWnd.right - crEditWnd.left, crEditWnd.bottom - crEditWnd.top, TRUE );

    // update bounding box
    ::GetClientRect(m_hwnd, &crEditBox);
    ::MapWindowPoints(m_hwnd, g_pDraw->m_hwnd, (LPPOINT)&crEditBox, 2);

    ::OffsetRect(&crEditBox, g_pDraw->m_originOffset.cx+1 + m_ptNTBooger.x,
        g_pDraw->m_originOffset.cy + m_ptNTBooger.y );//+1 );
    m_pEditor->m_rect = crEditBox;
    m_pEditor->SetBoundsRect(&crEditBox);

bail_out:

    if (hDC != NULL )
    {
    	if(hSaveFont)
       {
             SelectFont(hDC, hSaveFont);
	}
        ::ReleaseDC(m_hwnd, hDC );
    }

    if(szBoxText)
    {
    	delete [] szBoxText;
    }
    
    return( !bNoChanges );
}




void WbTextBox::OnTimer(UINT nIDEvent)
{
    TRACE_TIMER(("WbTextBox::OnTimer"));

	//
	// If something changed: Text,Font, anchor point etc...
	//
	if(m_pEditor->HasTextChanged())
	{
		//
		// If we are not added to the workspace
		//
		if(!m_pEditor->GetMyWorkspace())
		{
			m_pEditor->SetAllAttribs();
			m_pEditor->AddToWorkspace();
		}
		else
		{
			m_pEditor->OnObjectEdit();
		}
	}
}



//
// WbTextBox::OnLButtonUp()
//
void  WbTextBox::OnLButtonUp(UINT nFlags, int x, int y)
{
    POINT   ptCaret;
    POINT   ptPos;

    ::GetCaretPos(&ptCaret);
    m_pEditor->GetAnchorPoint(&ptPos);

    m_pEditor->m_cursorXYPos.x = ptCaret.x + ptPos.x;
    m_pEditor->m_cursorXYPos.y = ptCaret.y + ptPos.y;
}




//
// WbTextBox::OnMouseMove()
//
void  WbTextBox::OnMouseMove(UINT nFlags, int x, int y)
{
    if (nFlags & MK_LBUTTON )
    {
        // we're dragging
        ::HideCaret(m_hwnd);
        AutoCaretScroll();
        ::ShowCaret(m_hwnd);
    }
}



void  WbTextBox::AutoCaretScroll( void )
{
    POINT   ptCaret;
    POINT   ptPos;

    ::GetCaretPos(&ptCaret);
    m_pEditor->GetAnchorPoint(&ptPos);

    ptCaret.x += ptPos.x;
    ptCaret.y += ptPos.y;

    g_pDraw->AutoScroll(ptCaret.x, ptCaret.y, FALSE, m_pEditor->m_cursorXYPos.x,
        m_pEditor->m_cursorXYPos.y);
    m_pEditor->m_cursorXYPos = ptCaret;
}



void WbTextBox::SetupBackgroundRepaint
(
    POINT   ptTopPaint,
    BOOL    bNumLinesChanged
)
{
    RECT    rectBox;

    ::GetClientRect(m_hwnd, &rectBox);

    if (ptTopPaint.y == -1)
    {
        ::GetCaretPos(&ptTopPaint);
    }

    ASSERT(m_pEditor->m_textMetrics.tmHeight != DBG_UNINIT);
    rectBox.top = ptTopPaint.y;
    if( !bNumLinesChanged )
        rectBox.bottom = rectBox.top + m_pEditor->m_textMetrics.tmHeight;

    ::InvalidateRect(m_hwnd, &rectBox, TRUE );
}



//
// Selects at least one (DBCS) char if there is not a selection already.
//
void WbTextBox::SelectAtLeastOne( void )
{
    int nFirst, nLast;
    TCHAR * szBoxText;

    ::SendMessage(m_hwnd, EM_GETSEL, (WPARAM)&nFirst, (LPARAM)&nLast);
    if( nFirst == nLast )
    {
        int textSize = ::GetWindowTextLength(m_hwnd);
		DBG_SAVE_FILE_LINE
        szBoxText = new TCHAR[textSize + 1];
        if (!szBoxText)
        {
            ERROR_OUT(("Failed to allocate TCHAR array for object text"));
        }
        else
        {
            ::GetWindowText( m_hwnd, szBoxText, textSize+1);

            if (nFirst < textSize)
            {
                nLast++;

                if( IsDBCSLeadByte( (BYTE) szBoxText[ nFirst ] )||
                    (szBoxText[ nFirst ] == _T('\r'))
                    )
                    nLast++;

                ::SendMessage(m_hwnd, EM_SETSEL, nFirst, nLast);
            }

            delete [] szBoxText;
        }
    }
}



void WbTextBox::OnMove(int x, int y)
{
    if (m_pEditor->m_nLastShow == SW_SHOW)
    {
        FitBox();
        ::ShowCaret(m_hwnd);
    }
}


int WbTextBox::GetMaxCharHeight( void )
{
    ASSERT(m_pEditor->m_textMetrics.tmHeight != DBG_UNINIT);
    return( m_pEditor->m_textMetrics.tmHeight );
}




int WbTextBox::GetMaxCharWidth( void )
{
    ASSERT(m_pEditor->m_textMetrics.tmMaxCharWidth != DBG_UNINIT);
    return( m_pEditor->m_textMetrics.tmMaxCharWidth );
}




//
// Aborts and shuts down text editor without hitting the cores.  Call this
// to shutdown editing during a lock condition (that we don't own)
//
void WbTextBox::AbortEditGently( void )
{
    RECT           boundsRect;

    // shut down rejecting all edits
    g_pDraw->EndTextEntry(FALSE);

    // Delete the text object
    if (g_pDraw->m_pTextEditor != NULL)
    {
	    m_pEditor->GetBoundsRect(&boundsRect);

		delete g_pDraw->m_pTextEditor;		// zap in memory original
        g_pDraw->m_pTextEditor = NULL;		//  text object, loose any current edits
		m_pEditor = NULL;
    }
    else
    {
        SetRectEmpty(&boundsRect);
    }

	// Redraw any altered parts of the screen
    g_pDraw->InvalidateSurfaceRect(&boundsRect, TRUE);

}



//
//
// Function:    WbTextEditor
//
// Purpose:     Constructor
//
//
WbTextEditor::WbTextEditor(void)
{
    // Initialize the cursor position
    m_cursorCharPos.x = 0;
    m_cursorCharPos.y = 0;

    // set parent for editbox
    m_pEditBox = NULL;

    m_cursorXYPos.x = 0;
    m_cursorXYPos.y = 0;

    m_bFirstSetFontCall = TRUE;
    m_nLastShow = -1;
}


WbTextEditor::~WbTextEditor(void)
{
    if (m_pEditBox != NULL)
    {
        delete m_pEditBox;
        m_pEditBox = NULL;
    }
}


//
//
// Function:    SetCursorPosFromPoint
//
// Purpose:     Return the character position most closely matching a
//              given co-ordinate position in the text object.
//
//
void WbTextEditor::SetCursorPosFromPoint(POINT pointXY)
{
    int    nCharPos;

    if (::PtInRect(&m_rect, pointXY))
    {
        // make point relative to editbox
        pointXY.x -= g_pDraw->m_originOffset.cx;
        pointXY.y -= g_pDraw->m_originOffset.cy;

        ::MapWindowPoints(g_pDraw->m_hwnd, m_pEditBox->m_hwnd,
            &pointXY, 1);

        ::SendMessage(m_pEditBox->m_hwnd, WM_LBUTTONDOWN, 0,
                               MAKELONG( pointXY.x, pointXY.y ) );
        ::SendMessage(m_pEditBox->m_hwnd, WM_LBUTTONUP, 0,
                               MAKELONG( pointXY.x, pointXY.y ) );


        // get char index in editbox
        nCharPos = (int)::SendMessage(m_pEditBox->m_hwnd, EM_CHARFROMPOS, 0,
            MAKELPARAM(pointXY.x, pointXY.y));
        if( nCharPos < 0 )
            return;

        // Set the new cursor char co-ordinates
        m_cursorCharPos.x = (short)LOWORD(nCharPos);
        m_cursorCharPos.y = (short)HIWORD(nCharPos);

        // Move the cursor to the new position
        GetXYPosition(m_cursorCharPos, &m_cursorXYPos);
    }
}

//
//
// Function:    GetCursorSize
//
// Purpose:     Return the cursor size for the current font
//
//
void WbTextEditor::GetCursorSize(LPSIZE lpsize)
{
    ASSERT(m_textMetrics.tmHeight != DBG_UNINIT);
    lpsize->cx = ::GetSystemMetrics(SM_CXBORDER);
    lpsize->cy = m_textMetrics.tmHeight;
}

//
//
// Function:    XYPosition
//
// Purpose:     Calculate the X,Y co-ordinates of a character position
//
//
void WbTextEditor::GetXYPosition(POINT pointChar, LPPOINT lpptXY)
{
    int     nCharIndex;
    LRESULT dwCharPos;

    nCharIndex = (int)::SendMessage(m_pEditBox->m_hwnd, EM_LINEINDEX, pointChar.y, 0)
        + pointChar.x;

    GetAnchorPoint(lpptXY);

    dwCharPos = ::SendMessage(m_pEditBox->m_hwnd, EM_POSFROMCHAR, nCharIndex, 0);

    lpptXY->x += (short)LOWORD(dwCharPos);
    lpptXY->y += (short)HIWORD(dwCharPos);
}



//
//
// Function:    Clear
//
// Purpose:     Clear the text editor
//
//
void WbTextEditor::Clear(void)
{
    RECT cEWndRect;

    // Remove all the current stored text
    strTextArray.RemoveAll();

    // Reset the cursor position
    m_cursorCharPos.x = 0;
    m_cursorCharPos.y = 0;

    // clear editbox
    ::SetWindowText(m_pEditBox->m_hwnd, _TEXT(""));

    // init editbox size
    m_rect.right = m_rect.left + 2*m_pEditBox->GetMaxCharWidth();
    m_rect.bottom = m_rect.top + 2*m_pEditBox->GetMaxCharHeight();
	SetBoundsRect(&m_rect);

    cEWndRect = m_rect;
    ::OffsetRect(&cEWndRect, -(g_pDraw->m_originOffset.cx+1 + m_pEditBox->m_ptNTBooger.x),
                          -(g_pDraw->m_originOffset.cy + m_pEditBox->m_ptNTBooger.y) );

    ::BringWindowToTop(m_pEditBox->m_hwnd);
    ::MoveWindow(m_pEditBox->m_hwnd, cEWndRect.left, cEWndRect.top,
        cEWndRect.right - cEWndRect.left, cEWndRect.bottom - cEWndRect.top,
        TRUE);
}

//
//
// Function:    New
//
// Purpose:     Clear the text editor and reset the graphic handle
//
//
BOOL WbTextEditor::New(void)
{
    // create editbox
    if (!Create())
    {
        ERROR_OUT(("Error creating drawing area window"));
        return(FALSE);
    }

    // Clear the object
    Clear();

    return(TRUE);
}


//
//
// Function:    SetTextObject
//
// Purpose:     Attach a text object to the editor
//
//
BOOL WbTextEditor::SetTextObject(TextObj* ptext)
{
    // create editbox
    if (!Create())
    {
        ERROR_OUT(("Error creating drawing area window"));
        return(FALSE);
    }

    // setup font
    SetFont( ptext->m_hFont );

	POINT	pPoint;
    ptext->GetAnchorPoint(&pPoint);

    MoveTo(pPoint.x, pPoint.y);

    // copy the text to the editbox
    GetText();

    return(TRUE);
}


//
//
// Function:    IsEmpty
//
// Purpose:     Return TRUE if there is no text in the object
//
//
BOOL WbTextEditor::IsEmpty(void)
{
    return(::GetWindowTextLength(m_pEditBox->m_hwnd) <= 0 );
}



void WbTextEditor::PutText(void)
{
    int nNumLines;
    int i;
    int nMaxLineLen, nLineLen;
    int nLine;
    TCHAR *cbuf;
    WbTextEditor *pThis;

    pThis = (WbTextEditor *)this; // overide const declaration

    nNumLines = (int)::SendMessage(m_pEditBox->m_hwnd, EM_GETLINECOUNT, 0, 0);

    // figure out buf size
    nMaxLineLen = 0;
    for (i = 0; i < nNumLines; i++)
    {
        nLine = (int)::SendMessage(m_pEditBox->m_hwnd, EM_LINEINDEX, i, 0);
        nLineLen = (int)::SendMessage(m_pEditBox->m_hwnd, EM_LINELENGTH, nLine, 0);

        if (nMaxLineLen < nLineLen)
            nMaxLineLen = nLineLen;
    }

    // make buf
    nMaxLineLen += sizeof(WORD);
	DBG_SAVE_FILE_LINE
    cbuf = new TCHAR[nMaxLineLen];
    if( cbuf == NULL )
    {
        ERROR_OUT(("PutText failing; couldn't allocate TCHAR array"));
        return;
    }

    //
    // copy editbox innards to textbox string
    // Again, we know in advance how many lines; use SetSize/SetAt()
    //
    strTextArray.RemoveAll();
    strTextArray.SetSize(nNumLines);

    for(i = 0; i < nNumLines; i++)
    {
        *(LPWORD)cbuf = (WORD)nMaxLineLen;
        nLineLen = (int)::SendMessage(m_pEditBox->m_hwnd, EM_GETLINE, i, (LPARAM)cbuf);
        cbuf[nLineLen] = _T('\0');
        strTextArray.SetAt(i, cbuf );
    }

    // clean up
    delete [] cbuf;
}




void WbTextEditor::GetText(void)
{
    int nNumLines;
    int textSize = 0;
    int i;
    TCHAR * pText = NULL;
    TCHAR * pStartText;

    nNumLines = strTextArray.GetSize();

    //
    // Calculate the buffer size we need
    //
    for (i = 0; i < nNumLines; i++ )
    {
        textSize += lstrlen(strTextArray[i]);

        if ((i + 1) < nNumLines)
            textSize += lstrlen(_T("\r\n"));
    }

    //
    // Get the lines, with \r\n separating them
    //
	DBG_SAVE_FILE_LINE
    pText = new TCHAR[textSize + 1];
    if (!pText)
    {
        ERROR_OUT(("GetText failing; couldn't allocate TCHAR array"));
    }
    else
    {
        // Null this out in casae textSize is 0.
        pStartText = pText;
        pStartText[0] = 0;

        for (i = 0; i < nNumLines; i++)
        {
            lstrcpy(pStartText, strTextArray[i]);
            pStartText += lstrlen(strTextArray[i]);

            if ((i + 1) < nNumLines)
            {
                lstrcpy(pStartText, _T("\r\n"));
                pStartText += lstrlen(_T("\r\n"));
            }
        }

        ::SetWindowText(m_pEditBox->m_hwnd, pText);
        delete [] pText;
    }
}




void WbTextEditor::CalculateBoundsRect( void )
{
    RECT    cEWndRect;

    ASSERT(m_pEditBox);

    ::GetClientRect(m_pEditBox->m_hwnd, &cEWndRect);
    ::MapWindowPoints(m_pEditBox->m_hwnd, g_pDraw->m_hwnd,
        (LPPOINT)&cEWndRect, 2);

    m_rect = cEWndRect;
    ::OffsetRect(&m_rect, g_pDraw->m_originOffset.cx+1 + m_pEditBox->m_ptNTBooger.x,
                           g_pDraw->m_originOffset.cy + m_pEditBox->m_ptNTBooger.y);//+1 );

	SetBoundsRect(&m_rect);

    ::BringWindowToTop(m_pEditBox->m_hwnd);
}




// set editbox visibility
void WbTextEditor::ShowBox( int nShow )
{
    if (m_nLastShow == nShow)
    {
        if( nShow == SW_SHOW)
            ::SetFocus(m_pEditBox->m_hwnd);

        return;
    }

    m_nLastShow = nShow;

    if (nShow == SW_SHOW)
    {
        // show it
        if (m_pEditBox != NULL)
        {
            ::ShowWindow(m_pEditBox->m_hwnd, SW_SHOW);
            ::BringWindowToTop(m_pEditBox->m_hwnd);
            ::SetFocus(m_pEditBox->m_hwnd);

            ::HideCaret(m_pEditBox->m_hwnd);
            m_pEditBox->FitBox();
            ::ShowCaret(m_pEditBox->m_hwnd);
        }
    }
    else
    {
        if (m_pEditBox != NULL)
        {
            ::ShowWindow(m_pEditBox->m_hwnd, SW_HIDE);
            m_bFirstSetFontCall = TRUE;
		
			KillTimer();

            delete m_pEditBox;
            m_pEditBox = NULL;
        }
    }
}



//
// Create()
//
// Creates the edit box window
//
BOOL WbTextEditor::Create( void )
{
    if (m_pEditBox == NULL)
    {
		DBG_SAVE_FILE_LINE
        m_pEditBox = new WbTextBox(this);
        if (m_pEditBox == NULL)
        {
            ERROR_OUT(("Couldn't create edit text box"));
            return(FALSE);
        }

        if (!m_pEditBox->Create(g_pDraw->m_hwnd))
        {
            ERROR_OUT(("WbTextEditor::Create failed; can't create edit field"));
            return(FALSE);
        }
    }

    return(TRUE);
}




void WbTextEditor::MoveBy(int cx, int cy)
{
    RECT cEWndRect;

    ::GetClientRect(m_pEditBox->m_hwnd, &cEWndRect);

    if ((m_rect.right - m_rect.left) < (cEWndRect.right - cEWndRect.left))
        m_rect.right = m_rect.left + (cEWndRect.right - cEWndRect.left);

    if ((m_rect.bottom - m_rect.top) < (cEWndRect.bottom - cEWndRect.top))
        m_rect.bottom = m_rect.top + (cEWndRect.bottom - cEWndRect.top);

    cEWndRect = m_rect;
    ::OffsetRect(&cEWndRect, -(g_pDraw->m_originOffset.cx+1 + m_pEditBox->m_ptNTBooger.x),
                          -(g_pDraw->m_originOffset.cy + m_pEditBox->m_ptNTBooger.y) );//+1) );

    ::BringWindowToTop(m_pEditBox->m_hwnd);
    ::MoveWindow(m_pEditBox->m_hwnd, cEWndRect.left, cEWndRect.top,
        cEWndRect.right - cEWndRect.left, cEWndRect.bottom - cEWndRect.top,
        TRUE);
}




void WbTextEditor::SetFont( LOGFONT *pLogFont, BOOL bDummy )
{
    // Ignore bDummy. Had to add that so polymorph will work correctly
    // for DCWbGraphicText::SetFont()

    // Have to delay recalc of bounding rect because editbox will have a
    // bogus (bad) font until SetFont is called. Can't call SetFont
    // before this because new font hasn't been made yet.

	TextObj::SetFont( pLogFont, FALSE );

	if(m_pEditBox)
	{
		::SendMessage(m_pEditBox->m_hwnd, WM_SETFONT, (WPARAM)m_hFont, TRUE);

		// now do bounding rect
		CalculateBoundsRect();

		if( m_bFirstSetFontCall )
	        m_bFirstSetFontCall = FALSE;
	    else
	    {
			::HideCaret(m_pEditBox->m_hwnd);

	        m_pEditBox->FitBox();
			m_pEditBox->AutoCaretScroll();

	        ::ShowCaret(m_pEditBox->m_hwnd);
		}
	}
}




void WbTextEditor::SetTimer( UINT nElapse )
{
    ::SetTimer(m_pEditBox->m_hwnd, TIMER_GRAPHIC_UPDATE, nElapse, NULL);
}



void WbTextEditor::KillTimer( void )
{
	if(m_pEditBox)
	{
		::KillTimer(m_pEditBox->m_hwnd, TIMER_GRAPHIC_UPDATE);
	}
}




// Resets editbox painting for a resized drawing window
void WbTextEditor::ParentResize( void )
{
    ::HideCaret(m_pEditBox->m_hwnd);
    m_pEditBox->FitBox();
    ::ShowCaret(m_pEditBox->m_hwnd);
}




void WbTextEditor::RedrawEditbox(void)
{
    ::InvalidateRect(m_pEditBox->m_hwnd, NULL, TRUE);
    m_pEditBox->FitBox();
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\wbcaps.h ===
// From T120 recomendation
#include <gcc.h>
#define _SI_CHANNEL_0                    8
#define _SI_BITMAP_CREATE_TOKEN         8
#define  _SI_WORKSPACE_REFRESH_TOKEN       9

enum T126Caps
{
Cap_None = 0,
Hard_Copy_Image,
Hard_Copy_Image_Bitmap_Max_Width,
Hard_Copy_Image_Bitmap_Max_Height,
Hard_Copy_Image_Bitmap_Any_Aspect_Ratio,
Hard_Copy_Image_Bitmap_Format_T_6,
Hard_Copy_Image_Bitmap_Format_T_82,
Soft_Copy_Workspace,
Soft_Copy_Workspace_Max_Width,
Soft_Copy_Workspace_Max_Height,
Soft_Copy_Workspace_Max_Planes = 10,
Soft_Copy_Color_16,
Soft_Copy_Color_202,
Soft_Copy_Color_True,
Soft_Copy_Plane_Editing,
Soft_Copy_Scaling,
Soft_Copy_Bitmap_No_Token_Protection,
Soft_Copy_Pointing,
Soft_Copy_Pointing_Bitmap_Max_Width,
Soft_Copy_Pointing_Bitmap_Max_Height,
Soft_Copy_Pointing_Bitmap_Format_T_82 = 20,
Soft_Copy_Annotation,
Soft_Copy_Annotation_Bitmap_Max_Width,
Soft_Copy_Annotation_Bitmap_Max_Height,
Soft_Copy_Annotation_Drawing_Pen_Min_Thickness,
Soft_Copy_Annotation_Drawing_Pen_Max_Thickness,
Soft_Copy_Annotation_Drawing_Ellipse,
Soft_Copy_Annotation_Drawing_Pen_Square_Nib,
Soft_Copy_Annotation_Drawing_Highlight,
Soft_Copy_Annotation_Bitmap_Format_T_82,
Soft_Copy_Image = 30,
Soft_Copy_Image_Bitmap_Max_Width,
Soft_Copy_Image_Bitmap_Max_Height,
Soft_Copy_Image_Bitmap_Any_Aspect_Ratio,
Soft_Copy_Image_Bitmap_Format_T_82_Differential,
Soft_Copy_Image_Bitmap_Format_T_82_Differential_Deterministic_Prediction,
Soft_Copy_Image_Bitmap_Format_T_82_12_Bit_Grey_Scale,
Soft_Copy_Image_Bitmap_Format_T_81_Extended_Sequential_DCT,
Soft_Copy_Image_Bitmap_Format_T_81_Progressive_DCT,
Soft_Copy_Image_Bitmap_Format_T_81_Spatial_DPCM,
Soft_Copy_Image_Bitmap_Format_T_81_Differential_Sequential_DCT = 40,
Soft_Copy_Image_Bitmap_Format_T_81_Differential_Progressive_DCT,
Soft_Copy_Image_Bitmap_Format_T_81_Differential_Spatial_DPCM,
Soft_Copy_Image_Bitmap_Format_T_81_Extended_Sequential_DCT_Arithmetic,
Soft_Copy_Image_Bitmap_Format_T_81_Progressive_DCT_Arithmetic,
Soft_Copy_Image_Bitmap_Format_T_81_Spatial_DPCM_Arithmetic,
Soft_Copy_Image_Bitmap_Format_T_81_Differential_Sequential_DCT_Arithmetic,
Soft_Copy_Image_Bitmap_Format_T_81_Differential_Progressive_DCT_Arithmetic,
Soft_Copy_Image_Bitmap_Format_T_81_Differential_Spatial_DPCM_Arithmetic,
Soft_Copy_Image_Bitmap_Format_T_81_YCbCr_420,
Soft_Copy_Image_Bitmap_Format_T_81_YCbCr_444 = 50,
Soft_Copy_Image_Bitmap_Format_T_81_RGB_444,
Soft_Copy_Image_Bitmap_Format_T_81__CIELab_420,
Soft_Copy_Image_Bitmap_Format_T_81_CIELab_422,
Soft_Copy_Image_Bitmap_Format_T_81_CIELab_444,
Soft_Copy_Image_Bitmap_Format_T_81_Non_Interleaved,
Soft_Copy_Image_Bitmap_Format_Uncompressed_YCbCr_420,
Soft_Copy_Image_Bitmap_Format_Uncompressed_YCbCr_444,
Soft_Copy_Image_Bitmap_Format_Uncompressed__CIELab_420,
Soft_Copy_Image_Bitmap_Format_Uncompressed_CIELab_422,
Soft_Copy_Image_Bitmap_Format_Uncompressed_CIELab_444 = 60,
Archive_Support,
Soft_Copy_Annotation_Drawing_Rotation,
Soft_Copy_Transparency_Mask,
Soft_Copy_Video_Window,
};

typedef struct tagCAPS
{
	T126Caps	CapValue;
	GCCCapType  Type;
	UINT		SICE_Count_Rule;
	UINT		MinValue;
	UINT		MaxValue;
	T126Caps	Dependency;
}GCCCAPABILITY;




GCCCAPABILITY GCCCaps[] = 
{
///*01*/Hard_Copy_Image,GCC_LOGICAL_CAPABILITY,2,0,0,Cap_None,
		//Negotiate the use of hard-copy image exchanges
		//This capability implies a maximum image size of 1728 horizontal by 2300 vertical
		//It also implies the ability to support unscaled image bitmap creation using either
		//Uncompressed or T_4 (G3) formats with a single bitplane and either fax1 or fax2 pixel aspect ratios.
///*02*/Hard_Copy_Image_Bitmap_Max_Width,GCC_UNSIGNED_MINIMUM_CAPABILITY,1,1729,21845,Hard_Copy_Image,
		//Negotiate the maximum width of an image bitmap for hard-copy image exchanges
		//This dimension is relative to the pixel aspect ratio of the image.
///*03*/Hard_Copy_Image_Bitmap_Max_Height,GCC_UNSIGNED_MINIMUM_CAPABILITY,1,2301,21845,Hard_Copy_Image,
		//Negotiate the maximum height of an image bitmap for hard-copy image exchanges
		//This dimension is relative to the pixel aspect ratio of the image.
///*04*/Hard_Copy_Image_Bitmap_Any_Aspect_Ratio,GCC_LOGICAL_CAPABILITY,1,0,0,Hard_Copy_Image,
		//Negotiate the ability to transmit image bitmaps to a hard-copy workspace with an arbitrary aspect ratio.
///*05*/Hard_Copy_Image_Bitmap_Format_T_6,GCC_LOGICAL_CAPABILITY,1,0,0,Hard_Copy_Image,
		//Negotiate the ability to support bitmap creation using T_6 (G4) image compression format
		//with a single bitplane and either fax1 or fax2 pixel aspect ratios.
///*06*/Hard_Copy_Image_Bitmap_Format_T_82,GCC_LOGICAL_CAPABILITY,1,0,0,Hard_Copy_Image,
		//Negotiate the ability to support bitmap creation using T_82 (JBIG) image compression format
		//This capability implies the ability to handle 1 bit plane with 1:1 pixel aspect ratio and the
		//ability to only handle bitmaps encoded without the use of JBIG resolution reduction.
  /*07*/Soft_Copy_Workspace,GCC_LOGICAL_CAPABILITY,2,0,0,Cap_None,
		//Negotiate the ability to support at least one workspace for soft-copy information
		//This capability implies a maximum workspace size of 384 horizontal by 288 vertical
		//with workspace background colors Black and White.
		//Presence of this capability also implies that one of the capabilities Soft-Copy-Annotation
		//or Soft-Copy-Image shall also be included in the Application Capabilities List.
  /*08*/Soft_Copy_Workspace_Max_Width,GCC_UNSIGNED_MINIMUM_CAPABILITY,1,385,21845,Soft_Copy_Workspace,
		//Negotiate the maximum workspace width.  This dimension is relative to a 1:1 pixel aspect ratio (square pixels).
  /*09*/Soft_Copy_Workspace_Max_Height,GCC_UNSIGNED_MINIMUM_CAPABILITY,1,289,21845,Soft_Copy_Workspace,
		//Negotiate the maximum workspace height.  This dimension is relative to a 1:1 pixel aspect ratio (square pixels).
  /*10*/Soft_Copy_Workspace_Max_Planes,GCC_UNSIGNED_MINIMUM_CAPABILITY,1,2,256,Soft_Copy_Workspace,
		//Negotiate the maximum number of planes allowed in any workspace.
  /*11*/Soft_Copy_Color_16,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Workspace,
		//Negotiate the use of the 16-color palette for use in workspace backgrounds or,
		//if the Soft-Copy-Annotation capability is negotiated, in drawing elements.
  /*12*/Soft_Copy_Color_202,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Workspace,
		//Negotiate the use of the 202 color palette for use in workspace backgrounds or,
		//if the Soft-Copy-Annotation capability is negotiated, in drawing elements.
  /*13*/Soft_Copy_Color_True,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Workspace,
		//Negotiate the use of the true color (24-bit RGB) as well as the use of the 202 color palette
		//for use in workspace backgrounds or, if the Soft-Copy-Annotation capability is negotiated, in drawing elements.
  /*14*/Soft_Copy_Plane_Editing,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Workspace,
		//Negotiate the ability to declare any workspace plane to be editable.
  /*15*/Soft_Copy_Scaling,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Workspace,
		//Negotiate the ability to declare a scaling rectangle during creation of soft-copy bitmaps
		//Without this capability, bitmaps are applied to the destination workspace without scaling
		//(other than that required for non 1:1 pixel aspect ratios).
///*16*/Soft_Copy_Bitmap_No_Token_Protection,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Workspace,
		//Negotiate the ability to transmit soft-copy bitmaps of any variety without the need to hold the SI-BITMAP-CREATE-TOKEN.
///*17*/Soft_Copy_Pointing,GCC_LOGICAL_CAPABILITY,2,0,0,Soft_Copy_Workspace,
		//Negotiate the use of pointer bitmaps on soft-copy workspaces
		//Successful negotiation of this capability  allows the following coding formats  and associated
		//parameter constraints for pointer bitmaps:1. Uncompressed format of either 8-bit greyscale,
		//RGB 4:4:4 or 1, 4, or 8 bit palettized with a 1:1 pixel aspect ratio
		//This capability implies the ability to handle pointer bitmaps up to a maximum size of 32 by 32 pixels.
///*18*/Soft_Copy_Pointing_Bitmap_Max_Width,GCC_UNSIGNED_MINIMUM_CAPABILITY,1,33,21845,Soft_Copy_Pointing,
		//Negotiate the maximum width of a pointer bitmap
		//This dimension is relative to a 1:1 pixel aspect ratio (square pixels).
///*19*/Soft_Copy_Pointing_Bitmap_Max_Height,GCC_UNSIGNED_MINIMUM_CAPABILITY,1,33,21845,Soft_Copy_Pointing,
		//Negotiate the maximum height of a pointer bitmap
		//This dimension is relative to a 1:1 pixel aspect ratio (square pixels).
///*20*/Soft_Copy_Pointing_Bitmap_Format_T_82,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Pointing,
		//Negotiate the ability to use T_82 (JBIG) compression format for encoding pointer bitmaps
		//This capability implies the ability to handle either 8-bit greyscale, or up to
		//8 palettized bitplanes with a 1:1 pixel aspect ratio and the ability to only handle bitmaps
		//encoded without the use of JBIG resolution reduction.
  /*21*/Soft_Copy_Annotation,GCC_LOGICAL_CAPABILITY,2,0,0,Soft_Copy_Workspace,
		//Negotiate the use of annotation on soft-copy workspaces
		//The presence of this capability in the negotiated capability set implies the ability to create
		//workspaces with annotation specified as the usage-designator of workspace planes
		//Successful negotiation of this capability also allows the following coding formats
		//and associated parameter constraints for annotation bitmaps:
		//1. Uncompressed bitmap format of either 8-bit greyscale, RGB 4:4:4 or 1, 4,
		//or 8 bit palettized raster and color formats with a 1:1 pixel aspect ratio
		//This capability also implies the ability to support the creation of drawings using
		//the DrawingCreatePDU with a pen thickness of 3 to 16 pixels, and a round pen nib. 
///*22*/Soft_Copy_Annotation_Bitmap_Max_Width,GCC_UNSIGNED_MINIMUM_CAPABILITY,1,385,65536,Soft_Copy_Annotation,
		//Negotiate the maximum width of an annotation bitmap
		//This dimension is relative to a 1:1 pixel aspect ratio (square pixels).
///*23*/Soft_Copy_Annotation_Bitmap_Max_Height,GCC_UNSIGNED_MINIMUM_CAPABILITY,1,289,65536,Soft_Copy_Annotation,
		//Negotiate the maximum height of an annotation bitmap
		//This dimension is relative to a 1:1 pixel aspect ratio (square pixels).
  /*24*/Soft_Copy_Annotation_Drawing_Pen_Min_Thickness,GCC_UNSIGNED_MAXIMUM_CAPABILITY,1,1,2,Soft_Copy_Annotation,
		//Negotiate the Minimum thickness in pixels of lines drawn using the DrawingCreatePDU.
  /*25*/Soft_Copy_Annotation_Drawing_Pen_Max_Thickness,GCC_UNSIGNED_MINIMUM_CAPABILITY,1,17,255,Soft_Copy_Annotation,
		//The capability is used to negotiate the maximum thickness in pixels of lines drawn using the DrawingCreatePDU.
  /*26*/Soft_Copy_Annotation_Drawing_Ellipse,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Annotation,
		//Negotiate the ability to use the ellipse drawing type when using the DrawingCreatePDU.
///*27*/Soft_Copy_Annotation_Drawing_Pen_Square_Nib,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Annotation,
		//Negotiate the ability to use a square nib shape in creation of lines drawn using the DrawingCreatePDU.
  /*28*/Soft_Copy_Annotation_Drawing_Highlight,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Annotation,
		//Negotiate the ability to make use of the Highlight line style for drawing.
///*29*/Soft_Copy_Annotation_Bitmap_Format_T_82,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Annotation,
		//Negotiate the ability to use T_82 (JBIG) compression format for encoding annotation bitmaps
		//This capability implies the ability to handle either 8-bit greyscale, or up to 8 palettized bitplanes
		//with a 1:1 pixel aspect ratio and  the ability to only handle bitmaps encoded without the use of JBIG
		//resolution reduction.
  /*30*/Soft_Copy_Image,GCC_LOGICAL_CAPABILITY,2,0,0,Soft_Copy_Workspace,
		//Negotiate the use of image bitmaps on soft-copy workspaces
		//The presence of this capability in the negotiated capability set implies the ability to create workspaces
		//with image specified as the usage-designator of workspace planes
		//Successful negotiation of this capability  allows the following coding formats  and associated parameter
		//constraints for image bitmaps:
		//1. JBIG: this capability implies the ability to handle either 8-bit greyscale, RGB 4:4:4,
		//or  up to 8 palettized bitplanes and  the ability to only handle bitmaps encoded without the use of JBIG
		//resolution reduction.  Both 1:1 and CIF pixel aspect ratios shall be supported
		//2. JPEG: this capability implies the ability to handle the Baseline DCT encoding mode, with baseline 
		//sequential transmission and 8 bit/sample data precision in component interleaved format only, using 
		//a color space and color resolution mode of YCbCr 4:2:2, or greyscale
		//Both 1:1 and CIF pixel aspect ratios shall be supported.
		//3. Uncompressed: this capability implies the ability to handle 8-bit greyscale, RGB 4:4:4, 
		//YCbCr 4:2:2, or palettized 1, 4, or 8 bits per pixel.  Both 1:1 and CIF pixel aspect ratios shall be supported.
///*31*/Soft_Copy_Image_Bitmap_Max_Width,GCC_UNSIGNED_MINIMUM_CAPABILITY,1,385,65536,Soft_Copy_Image,
		//Negotiate the Maximum workspace width for soft-copy image bitmap exchanges
		//This dimension is relative to the pixel aspect ratio of the image bitmap.
///*32*/Soft_Copy_Image_Bitmap_Max_Height,GCC_UNSIGNED_MINIMUM_CAPABILITY,1,289,65536,Soft_Copy_Image,
		//Negotiate the Maximum workspace height for soft-copy image bitmap exchanges
		//This dimension is relative to the pixel aspect ratio of the image bitmap.
///*33*/Soft_Copy_Image_Bitmap_Any_Aspect_Ratio,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to transmit image bitmaps to a soft-copy workspace with an arbitrary aspect ratio.
///*34*/Soft_Copy_Image_Bitmap_Format_T_82_Differential,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use resolution reduction (differential layers) when encoding a JBIG format image bitmap
///*35*/Soft_Copy_Image_Bitmap_Format_T_82_Differential_Deterministic_Prediction,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image_Bitmap_Format_T_82_Differential,
		//Negotiate the ability to use deterministic prediction when encoding a JBIG 
		//format image bitmap using resolution reduction (differential layers).
///*36*/Soft_Copy_Image_Bitmap_Format_T_82_12_Bit_Grey_Scale,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use 12 bit planes when encoding a JBIG format image bitmap.
///*37*/Soft_Copy_Image_Bitmap_Format_T_81_Extended_Sequential_DCT,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use Extended Sequential DCT mode when encoding a JPEG format image bitmap.
///*38*/Soft_Copy_Image_Bitmap_Format_T_81_Progressive_DCT,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use Progressive DCT mode when encoding a JPEG format image bitmap.
///*39*/Soft_Copy_Image_Bitmap_Format_T_81_Spatial_DPCM,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use Spatial DPCM mode when encoding a JPEG format image bitmap.
///*40*/Soft_Copy_Image_Bitmap_Format_T_81_Differential_Sequential_DCT,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use Differential Sequential DCT mode when encoding a JPEG format image bitmap.
///*41*/Soft_Copy_Image_Bitmap_Format_T_81_Differential_Progressive_DCT,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use Differential Progressive DCT mode when encoding a JPEG format image bitmap.
///*42*/Soft_Copy_Image_Bitmap_Format_T_81_Differential_Spatial_DPCM,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use Differential Spatial DPCM mode when encoding a JPEG format image bitmap.
///*43*/Soft_Copy_Image_Bitmap_Format_T_81_Extended_Sequential_DCT_Arithmetic,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use Extended Sequential DCT mode using Arithmetic encoding when encoding a JPEG 
		//format image bitmap.
///*44*/Soft_Copy_Image_Bitmap_Format_T_81_Progressive_DCT_Arithmetic,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use Progressive DCT mode using Arithmetic encoding when encoding a JPEG format image bitmap.
///*45*/Soft_Copy_Image_Bitmap_Format_T_81_Spatial_DPCM_Arithmetic,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use Spatial DPCM mode using Arithmetic encoding when encoding a JPEG format image bitmap.
///*46*/Soft_Copy_Image_Bitmap_Format_T_81_Differential_Sequential_DCT_Arithmetic,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use Differential Sequential DCT mode using Arithmetic encoding when encoding a JPEG 
		//format image bitmap.
///*47*/Soft_Copy_Image_Bitmap_Format_T_81_Differential_Progressive_DCT_Arithmetic,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use Differential Progressive DCT mode using Arithmetic encoding when encoding a JPEG 
		//format image bitmap.
///*48*/Soft_Copy_Image_Bitmap_Format_T_81_Differential_Spatial_DPCM_Arithmetic,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use Differential Spatial DPCM mode using Arithmetic encoding when encoding a JPEG 
		//format image bitmap.
///*49*/Soft_Copy_Image_Bitmap_Format_T_81_YCbCr_420,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use a chroma format of YCbCr 4:2:0 when encoding a JPEG format image bitmap.
///*50*/Soft_Copy_Image_Bitmap_Format_T_81_YCbCr_444,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use a chroma format of YCbCr 4:4:4 when encoding a JPEG format image bitmap.
///*51*/Soft_Copy_Image_Bitmap_Format_T_81_RGB_444,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use a chroma format of RGB 4:4:4 when encoding a JPEG format image bitmap.
///*52*/Soft_Copy_Image_Bitmap_Format_T_81__CIELab_420,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use a chroma format of CIELab 4:2:0 when encoding a JPEG format image bitmap.
///*53*/Soft_Copy_Image_Bitmap_Format_T_81_CIELab_422,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use a chroma format of CIELab 4:2:2 when encoding a JPEG format image bitmap.
///*54*/Soft_Copy_Image_Bitmap_Format_T_81_CIELab_444,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use a chroma format of CIELab 4:4:4 when encoding a JPEG format image bitmap.
///*55*/Soft_Copy_Image_Bitmap_Format_T_81_Non_Interleaved,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use non-interleaved ordering of color components.
///*56*/Soft_Copy_Image_Bitmap_Format_Uncompressed_YCbCr_420,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use a chroma format of YCbCr 4:2:0 when encoding an Uncompressed format image bitmap.
///*57*/Soft_Copy_Image_Bitmap_Format_Uncompressed_YCbCr_444,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use a chroma format of YCbCr 4:4:4 when encoding an Uncompressed format image bitmap.
///*58*/Soft_Copy_Image_Bitmap_Format_Uncompressed__CIELab_420,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use a chroma format of CIELab 4:2:0 when encoding an Uncompressed format image bitmap.
///*59*/Soft_Copy_Image_Bitmap_Format_Uncompressed_CIELab_422,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use a chroma format of CIELab 4:2:2 when encoding an Uncompressed format image bitmap.
///*60*/Soft_Copy_Image_Bitmap_Format_Uncompressed_CIELab_444,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use a chroma format of CIELab 4:4:4 when encoding an Uncompressed format image bitmap.
///*61*/Archive_Support,GCC_LOGICAL_CAPABILITY,0,0,0,Cap_None,
		//Negotiate the support of archives.
///*62*/Soft_Copy_Annotation_Drawing_Rotation,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Annotation,
		//This capability is used to negotiate the ability to specify the optional 
		//rotation parameter that defines a rotation to be applied to annotation 
		//drawing elements.
///*63*/Soft_Copy_Transparency_Mask,GCC_LOGICAL_CAPABILITY,2,0,0,Soft_Copy_Image,
		//This capability is used to negotiate the ability to use arbitrary 
		//transparency masks for applicable graphical elements allowing arbitrary 
		//pixels within these objects to be interpreted as transparent. This capability 
		//also implies the support of JBIG compression given that a transparency mask 
		//can be optionally encoded in this manner.
///*64*/Soft_Copy_Video_Window,GCC_LOGICAL_CAPABILITY,2,0,0,Soft_Copy_Image
		//This capability is used to negotiate the ability to define video windows that 
		//can encapsulate out of band video streams in a workspace. Successful 
		//negotiation of this capability between two or more session participants 
		//enables the use of the VideoWindowCreatePDU, VideoWindowDeletePDU and 
		//VideoWindowEditPDU.
};


const USHORT _iT126_MAX_COLLAPSING_CAPABILITIES   = sizeof(GCCCaps)/sizeof(GCCCAPABILITY);

static ULONG T126KeyNodes[] = {0,0,20,126,0,1};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\txted.hpp ===
//
// TXTED.HPP
// Text Object Editor
//
// Copyright Microsoft 1998-
//
#ifndef __TXTED_HPP_
#define __TXTED_HPP_



#define MIN_IME_WINDOW    30 

#define MIN_FITBOX_CHARS 6

class WbTextEditor;

/////////////////////////////////////////////////////////////////////////////
// WbTextBox window

class WbTextBox
{
public:
	WbTextBox(WbTextEditor * pEditor);
    ~WbTextBox();

    BOOL Create(HWND hwndParent);

	BOOL FitBox( void );

	void AutoCaretScroll( void );

	int	GetMaxCharHeight( void );

	int	GetMaxCharWidth( void );

	void AbortEditGently( void );

    HWND    m_hwnd;
	POINT   m_ptNTBooger;

    friend LRESULT CALLBACK TextWndProc(HWND, UINT, WPARAM, LPARAM);

    WNDPROC m_pfnEditPrev;

protected:
    RECT    m_MaxRect;
	WbTextEditor *m_pEditor;
	RECT     m_rectErase;
	BOOL	 m_bInIME;
	BOOL	 m_bDontEscapeThisTime;

	void SetupBackgroundRepaint( POINT ptTopPaint, BOOL bNumLinesChanged=TRUE );
	void SelectAtLeastOne( void );

    void    OnClearCut(void);
    void    OnUndoPaste(void);
	void    OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	void    OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	void    OnTimer(UINT nIDEvent);
	void    OnLButtonUp(UINT nFlags, int x, int y);
	void    OnMouseMove(UINT nFlags, int x, int y);
    void    OnMove(int x, int y);
	void    OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
};

/////////////////////////////////////////////////////////////////////////////


//
//
// Class:   WbTextEditor
//
// Purpose: Allow editing of the text in a DCWbGraphicText object
//
//
class WbTextEditor : public TextObj
{
	friend class WbTextBox;
    friend class WbDrawingArea;
	
	public:
    //
    // Constructor
    //
    WbTextEditor(void);
   ~WbTextEditor(void);

    // writes text to underlying text object before relaying to text object
    DWORD CalculateExternalLength(void);

	// calcs bounds rect and sets editbox to new size
    void CalculateBoundsRect(void);

	void SetTimer( UINT nElapse );
	void KillTimer( void );
  
	// set editbox visibility
	void ShowBox( int nShow );

	BOOL Create( void );

	// Moves underlying text object and then moves editbox rect
    void MoveBy(int cx, int cy);

	void RedrawEditbox(void);

	// resets editbox for parent resizing
	void ParentResize( void );

	// clipboard
	void Copy( void ) 
		{ ::SendMessage(m_pEditBox->m_hwnd, WM_COPY, 0, 0); }

	void Cut( void ) 
        { ::SendMessage(m_pEditBox->m_hwnd, WM_CUT, 0, 0); }

	void Paste( void ) 
        { ::SendMessage(m_pEditBox->m_hwnd, WM_PASTE, 0, 0); }

    virtual void SetFont( LOGFONT *pLogFont, BOOL bDummy=TRUE );
    virtual void SetFont(HFONT hFont) { TextObj::SetFont(hFont); }

    //
    // Attach a text object to the editor.  This function copies the
    // contents of the specified text object into the text editor.  The
    // editor will not alter the contents of the object passed and does not
    // keep a copy of the pointer parameter.
    //
    BOOL SetTextObject(TextObj * ptext);

    //
    // Return the width and height for the cursor in pixels as a size
    //
    void GetCursorSize(LPSIZE lpsize);

    //
    // Set the current edit cursor position from a point specified in
    // logical co-ordinates.  This function does nothing if the point
    // specified is outside the bounding rectangle of the object being
    // edited.  If the point specified is within the bounding rectangle the
    // current edit cursor position is updated to a point as close as
    // possible to that passed as parameter.
    //
    void SetCursorPosFromPoint(POINT pointXY);

    void Clear(void);                // Delete all text
    BOOL New(void);                  // Delete text and reset handles

    //
    // Return TRUE if there is not text in the object
    //
    BOOL IsEmpty(void);

	void AbortEditGently( void )
		{m_pEditBox->AbortEditGently();}

	WbTextBox *m_pEditBox;

protected:
    //
    // Pixel position from a character position
    //
    void GetXYPosition(POINT pointChar, LPPOINT lpptGet);

    //
    // Current cursor position.  Note that cursorCharPos.x gives the BYTE
    // position of the cursor rather than the character position.  On SBCS
    // systems the character and byte positions will always be the same,
    // but on DBCS systems the number of bytes in a string can be greater
    // than the number of characters.
    //
    // cursorCharPos.x should NEVER be set to a byte count which is in the
    // middle of a double byte character.
    //
    POINT   m_cursorCharPos;
    POINT   m_cursorXYPos;

	int	 m_nLastShow;
	void PutText(void);
	void GetText(void);
};


#endif // __TXTED_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\wgrp.hpp ===
//
// WGRP.HPP
// Widths Group
//
// Copyright Microsoft 1998-
//

#ifndef __WGRP_HPP
#define __WGRP_HPP


#define WIDTHBAR_WIDTH	TOOLBAR_WIDTH
#define WIDTHBAR_HEIGHT	50




class WbWidthsGroup
{
public:
	WbWidthsGroup();
    ~WbWidthsGroup();

	BOOL    Create(HWND hwndParent, LPCRECT lprect);
    void    GetNaturalSize(LPSIZE lpsize);

    void    PushDown(UINT uiIndex);
    int     ItemFromPoint(int x, int y) const;
    void    GetItemRect(int iItem, LPRECT lprc) const;

    HWND    m_hwnd;

    friend LRESULT CALLBACK  WGWndProc(HWND, UINT, WPARAM, LPARAM);

protected:
    void    OnPaint(void);
    void    OnLButtonDown(int x, int y);

	UINT    m_uLast;
    UINT    m_cyItem;
};

#endif // __WGRP_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\user.hpp ===
//
// USER.HPP
// User Class
//
// Copyright Microsoft 1998-
//
#ifndef __USER_HPP_
#define __USER_HPP_


//
//
// Class:   WbUser
//
// Purpose: User object recorder
//
//
class DCWbGraphicPointer;

class WbUser
{
public:
    //
    // Constructor
    //
    WbUser(POM_OBJECT hUser = NULL);

    //
    // Destructor
    //
    ~WbUser(void);

    //
    // Return the user handle
    //
    POM_OBJECT Handle(void) const { return(m_hUser);}

    //
    // Refresh the user details
    //
    void Refresh(void);

    //
    // Update the external copy of the user information
    //
    void Update(void);

    //
    // Return the user name
    //
    LPCSTR Name(void) const { return(m_strName); }

    //
    // Synchronize the users page with other synced users
    //
    void Sync(void);
    void Unsync(void);

    //
    // Update the user's position from the sync position. This does not
    // change the sync position.
    //
    void GetSyncPosition(void);

    //
    // Update the sync position from the user's current position
    //
    void PutSyncPosition(void);

    //
    // Return a remote pointer object for this user
    //
    DCWbGraphicPointer* GetPointer(void) { return(m_pRemotePointer); }

    //
    // Put the user's remote pointer at the position specified
    //
    void PutPointer(WB_PAGE_HANDLE hPage, POINT point);

    //
    // Remove the user's remote pointer
    //
    void RemovePointer(void);

    //
    // Return TRUE if the user is synced
    //
    BOOL IsSynced(void) const { return m_bSynced; }

    //
    // Return TRUE if the user has the contents lock
    //
    BOOL HasContentsLock(void) const;

    //
    // Return TRUE if the user has their remote pointer active
    //
    BOOL IsUsingPointer(void) const;

    //
    // Return the current page of the user
    //
    WB_PAGE_HANDLE Page(void) const {return m_hPageCurrent; }
    void SetPage(WB_PAGE_HANDLE hPage);

    //
    // Return the current position within the page of the user
    //
    void  GetVisibleRect(LPRECT lprc) { *lprc = m_rectVisible; }
    void  SetVisibleRect(LPCRECT lprc);

    //
    // Return the page of the user's pointer
    //
    WB_PAGE_HANDLE PointerPage(void) const;

    //
    // Return the position of the user's pointer
    //
    void GetPointerPosition(LPPOINT lpptPos);

    //
    // Return the user's color
    //
    COLORREF Color(void) const { return(m_color); }

    //
    // Return TRUE if this is the local user
    //
    BOOL IsLocalUser(void) const { return(m_bLocalUser); }

    //
    // Operators
    //
    virtual WbUser& operator=(const WbUser& user);
    virtual BOOL operator!=(const WbUser& user) const;
    virtual BOOL operator==(const WbUser& user) const;

    //
    // Set zoom/unzoom state
    //
    void Zoom(void) { m_zoomed = TRUE; }
    void Unzoom(void) { m_zoomed = FALSE; }
    BOOL GetZoom(void) const { return(m_zoomed); }

protected:
    //
    // Core access handle
    //
    POM_OBJECT  m_hUser;

    //
    // Flag indicating Whether this is the local user
    //
    BOOL        m_bLocalUser;

    BOOL        m_zoomed;

    //
    // Local copies of the user information
    //
    char        m_strName[TSHR_MAX_PERSON_NAME_LEN];
    BOOL        m_bSynced;
    WB_PAGE_HANDLE  m_hPageCurrent;
    RECT        m_rectVisible;
    COLORREF    m_color;

    //
    // Graphic pointer associated with this user
    //
    DCWbGraphicPointer* m_pRemotePointer;
};


//
//
// Class:   WbUserList
//
// Purpose: Map from user handles to user object pointers
//
//
class WbUserList : public COBLIST
{
public:

    //
    // Destructor
    //
    ~WbUserList(void);

    //
    // Clear all entries from the map, deleting the associated object
    //
    void Clear(void);
};



//
// Return lock status
//
BOOL WB_Locked(void);
BOOL WB_ContentsLocked(void);
BOOL WB_GotLock(void);
BOOL WB_GotContentsLock(void);
BOOL WB_PresentationMode(void);



//
// Return an object representing the local user
//
WbUser* WB_LocalUser(void);

//
// Retrieving users
//
WbUser* WB_GetUser(POM_OBJECT hUser);
WbUser* WB_GetFirstUser(void);
WbUser* WB_GetNextUser(const WbUser* pUser);

//
// Return an object representing the user who has the lock
//
WbUser* WB_LockUser(void);




#endif // __USER_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\wboblist.cpp ===
// PRECOMP
#include "precomp.h"
   
VOID* CWBOBLIST::GetTail()
{
	if(m_pTail)
	{
		return m_pTail->pItem;
	}
	else
	{
		return NULL;
	}
}

VOID* CWBOBLIST::GetNext(WBPOSITION& rPos)
{
	ASSERT(rPos);
	
	VOID* pReturn = rPos->pItem;
	rPos = rPos->pNext;

	return pReturn;
}

VOID* CWBOBLIST::GetPrevious(WBPOSITION& rPos)
{
	ASSERT(rPos);
	
	VOID* pReturn = rPos->pItem;
	rPos = rPos->pPrev;

	return pReturn;
}

WBPOSITION CWBOBLIST::AddAt(VOID* pItem, WBPOSITION Pos)
{
	ASSERT(Pos);

	WBPOSITION posRet = NULL;

	DBG_SAVE_FILE_LINE
	if (posRet = new COBNODED)
	{
		posRet->pItem = pItem;
		posRet->pNext = Pos->pNext;
		posRet->pPrev = Pos;
		Pos->pNext = posRet;
		if(posRet->pNext)
		{
			posRet->pNext->pPrev = posRet;
		}
		else
		{
			m_pTail = posRet;
		}

	}
	
	return posRet;
}

VOID* CWBOBLIST::RemoveAt(WBPOSITION Pos)
{
	VOID* pReturn = NULL;

	if (m_pHead)
	{
		if (m_pHead == Pos)
		{
			// Removing the first element in the list
			
			m_pHead = Pos->pNext;
			pReturn = Pos->pItem;
			delete Pos;

			if(m_pHead != NULL)
			{
				m_pHead->pPrev = NULL;
			}
			else
			{
				// Removing the only element!
				m_pTail = NULL;
			}


		}
		else
		{
			WBPOSITION pCur = m_pHead;

			while (pCur && pCur->pNext)
			{
				if (pCur->pNext == Pos)
				{
					// Removing 
					
					pCur->pNext = Pos->pNext;
					
					if(pCur->pNext)
					{
						pCur->pNext->pPrev = pCur;
					}

					if (m_pTail == Pos)
					{
						m_pTail = pCur;
					}
					pReturn = Pos->pItem;
					delete Pos;
				}

				pCur = pCur->pNext;
			}
		}
	}

	return pReturn;
}

WBPOSITION CWBOBLIST::AddTail(VOID* pItem)
{
	WBPOSITION posRet = NULL;

	if (m_pTail)
	{
		DBG_SAVE_FILE_LINE
		if (m_pTail->pNext = new COBNODED)
		{
			m_pTail->pNext->pPrev = m_pTail;
			m_pTail = m_pTail->pNext;
			m_pTail->pItem = pItem;
			m_pTail->pNext = NULL;
		}
	}
	else
	{
		ASSERT(!m_pHead);
		DBG_SAVE_FILE_LINE
		if (m_pHead = new COBNODED)
		{
			m_pTail = m_pHead;
			m_pTail->pItem = pItem;
			m_pTail->pNext = NULL;
			m_pTail->pPrev = NULL;
		}
	}

	return m_pTail;
}

void CWBOBLIST::EmptyList()
{
    while (!IsEmpty()) {
        RemoveAt(GetHeadPosition());
    }
}

CWBOBLIST::~CWBOBLIST()
{
    ASSERT(IsEmpty());
}

WBPOSITION CWBOBLIST::GetPosition(void* _pItem)
{
    // For potential efficiency of lookup (if we switched to 
    // a doubly linked list), users should really store the WBPOSITION
    // of an item. For those that don't, this method is provided.

    WBPOSITION    pos = m_pHead;

    while (pos) {
        if (pos->pItem == _pItem) {
            break;
        }
		GetNext(pos);
    }
    return pos;
}

WBPOSITION CWBOBLIST::Lookup(void* pComparator)
{
    WBPOSITION    pos = m_pHead;

    while (pos) {
        if (Compare(pos->pItem, pComparator)) {
            break;
        }
		GetNext(pos);
    }
    return pos;
}


WBPOSITION CWBOBLIST::AddHead(VOID* pItem)
{
	WBPOSITION posRet = NULL;

	if (m_pHead)
	{
		DBG_SAVE_FILE_LINE
		if (posRet = new COBNODED)
		{
			posRet->pNext = m_pHead;
			m_pHead->pPrev = posRet;
			posRet->pItem = pItem;
			m_pHead = posRet;
			m_pHead->pPrev = NULL;
		}
	}
	else
	{
		ASSERT(!m_pTail);
		DBG_SAVE_FILE_LINE
		if (m_pHead = new COBNODED)
		{
			m_pTail = m_pHead;
			m_pHead->pItem = pItem;
			m_pHead->pNext = NULL;
			m_pHead->pPrev = NULL;
		}
	}

	return m_pHead;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\wboblist.hpp ===
//
// CWBOBLIST.HPP
// User Class
//
// Copyright Microsoft 1998-
//
#ifndef __CWBOBLIST_HPP_
#define __CWBOBLIST_HPP_

// class COBNODED;
#define WBPOSITION COBNODED*

struct COBNODED
{
	WBPOSITION	pNext;
	WBPOSITION	pPrev;
	void*		pItem;
};

class CWBOBLIST
{
protected:
	WBPOSITION m_pHead;
	WBPOSITION m_pTail;
    virtual BOOL Compare(void* pItemToCompare, void* pComparator) 
        {return(pItemToCompare == pComparator);};
public:
	CWBOBLIST() : m_pHead(NULL), m_pTail(NULL) { };
	
	WBPOSITION	    GetHeadPosition() { return(m_pHead); };
	WBPOSITION	    GetTailPosition() { return(m_pTail); };
	virtual void *  RemoveAt(WBPOSITION rPos);
	WBPOSITION		AddAt(VOID* pItem, WBPOSITION Pos);
	virtual void *	ReplaceAt(WBPOSITION rPos, void* pNewItem)
	{
		void *pvoid = rPos->pItem;
		rPos->pItem = pNewItem;
		return(pvoid);
	}

	WBPOSITION		AddHead(void* pItem);
	WBPOSITION	    AddTail(void* pItem);
	BOOL		    IsEmpty() { return(!m_pHead); };
	void *		    GetHead(){return GetFromPosition(GetHeadPosition());};
	void *		    GetTail();
	void *		    GetNext(WBPOSITION& rPos);
	void*			GetPrevious(WBPOSITION& rPos);
    WBPOSITION      GetPosition(void* pItem);
    WBPOSITION      Lookup(void* pComparator);
    void            EmptyList();
    virtual         ~CWBOBLIST();
	void *			RemoveHead() { return RemoveAt(m_pHead); };
	void *			RemoveTail() { return RemoveAt(m_pTail); };
	void *		    GetFromPosition(WBPOSITION rPos){return (rPos == NULL ? NULL : rPos->pItem);};
};




#endif  __CWBOBLIST_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\wbloader.h ===
#ifndef _WhiteBoard_AppletLoader_H_
#define _WhiteBoard_AppletLoader_H_

#include <iappldr.h>


class WBLoader : public CRefCount, public IAppletLoader
{
public:

    WBLoader(void);
    ~WBLoader(void);

    // IAppletLoader methods
    STDMETHOD_(void,           ReleaseInterface)(void);
	STDMETHOD_(APPLDR_RESULT,  AppletStartup)(BOOL fNoUI);
	STDMETHOD_(APPLDR_RESULT,  AppletCleanup)(DWORD dwTimeout);
	STDMETHOD_(APPLDR_RESULT,  AppletInvoke)(BOOL fRemote, T120ConfID nConfID, LPSTR pszCmdLine);
    STDMETHOD_(APPLDR_RESULT,  AppletQuery)(APPLET_QUERY_ID eQueryId);
    STDMETHOD_(APPLDR_RESULT,  OnNM2xNodeJoin)(void);
};


#endif // _WhiteBoard_AppletLoader_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\wgrp.cpp ===
//
// WGRP.CPP
// Widths Group
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"


static const TCHAR szWGClassName[] = "T126WB_WGRP";


WbWidthsGroup::WbWidthsGroup()
{
    int     i;

    m_hwnd  = NULL;
    m_uLast = 0;

    //
    // Calculate the height of each item in the list--it's the max of the
    // pen widths + slop space
    //
    m_cyItem = 0;
    for (i = 0; i < NUM_OF_WIDTHS; i++)
    {
        m_cyItem = max(m_cyItem, g_PenWidths[i]);
    }
    m_cyItem += 2 * ::GetSystemMetrics(SM_CYEDGE);
}


WbWidthsGroup::~WbWidthsGroup()
{
    if (m_hwnd != NULL)
    {
        ::DestroyWindow(m_hwnd);
        ASSERT(m_hwnd == NULL);
    }

    ::UnregisterClass(szWGClassName, g_hInstance);
}



BOOL WbWidthsGroup::Create(HWND hwndParent, LPCRECT lprect)
{
    WNDCLASSEX      wc;

    // Register our class
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize           = sizeof(wc);
    wc.style            = 0;
    wc.lpfnWndProc      = WGWndProc;
    wc.hInstance        = g_hInstance;
    wc.hCursor          = ::LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_BTNFACE + 1);
    wc.lpszClassName    = szWGClassName;

    if (!::RegisterClassEx(&wc))
    {
        ERROR_OUT(("WbWidthsGroup::Create register class failed"));
        return(FALSE);
    }

    ASSERT(!m_hwnd);

    if (!::CreateWindowEx(WS_EX_STATICEDGE, szWGClassName, NULL,
        WS_CHILD | WS_CLIPSIBLINGS | WS_TABSTOP, lprect->left, lprect->top,
        lprect->right - lprect->left, lprect->bottom - lprect->top,
        hwndParent, (HMENU)IDM_WIDTH, g_hInstance, this))
    {
        ERROR_OUT(("Can't create WbWidthsGroup"));
        return(FALSE);
    }

    return(TRUE);
}



//
// WGWndProc()
// Message handler for width window
//
LRESULT CALLBACK WGWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    WbWidthsGroup * pwg = (WbWidthsGroup *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (message)
    {
        case WM_NCCREATE:
            pwg = (WbWidthsGroup *)(((LPCREATESTRUCT)lParam)->lpCreateParams);
            ASSERT(pwg);

            pwg->m_hwnd = hwnd;
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pwg);
            goto DefWndProc;
            break;

        case WM_NCDESTROY:
            ASSERT(pwg);
            pwg->m_hwnd = NULL;
            break;

        case WM_PAINT:
            ASSERT(pwg);
            pwg->OnPaint();
            break;

        case WM_LBUTTONDOWN:
            ASSERT(pwg);
            pwg->OnLButtonDown((short)LOWORD(lParam), (short)HIWORD(lParam));
            break;

        case WM_NOTIFY:
            // Pass up to main window
            lResult = ::SendMessage(g_pMain->m_hwnd, message, wParam, lParam);
            break;

        default:
DefWndProc:
            lResult = DefWindowProc(hwnd, message, wParam, lParam);
            break;
    }

    return(lResult);
}



void WbWidthsGroup::GetNaturalSize(LPSIZE lpsize)
{
    lpsize->cy = ::GetSystemMetrics(SM_CYEDGE) +
        (NUM_OF_WIDTHS * m_cyItem);

    if (m_hwnd != NULL)
    {
        RECT    rect;

        ::GetWindowRect(m_hwnd, &rect);
        rect.right -= rect.left;
        lpsize->cx = max(WIDTHBAR_WIDTH, rect.right);
    }
    else
    {
        lpsize->cx = WIDTHBAR_WIDTH;
    }
}



void WbWidthsGroup::PushDown(UINT uiIndex)
{
    if( (uiIndex < NUM_OF_WIDTHS))
    {
        //
        // We really should just invalidate the last selected item, if one,
        // and the new selected item, if one.  But heck, there are only 4
        // items, no big deal to paint.
        //
        m_uLast = uiIndex;
        ::InvalidateRect(m_hwnd, NULL, TRUE);
    }
}




void WbWidthsGroup::OnPaint(void)
{
    PAINTSTRUCT ps;
    int         i;
    RECT        rect;
    int         cx, cy;
    int         nPenWidth;
    HBRUSH      hOldBrush;

    ::BeginPaint(m_hwnd, &ps);

    ::GetClientRect(m_hwnd, &rect);
    cx = ::GetSystemMetrics(SM_CXEDGE);
    cy = m_cyItem / 2;

    // First, fill the background of the selected item
    hOldBrush = SelectBrush(ps.hdc, ::GetSysColorBrush(COLOR_3DHILIGHT));

    ::PatBlt(ps.hdc, rect.left, m_uLast * m_cyItem,
        rect.right - rect.left, m_cyItem, PATCOPY);

    rect.right -= rect.left + 2*cx;

    // Now, use the black brush
    SelectBrush(ps.hdc, ::GetStockObject(BLACK_BRUSH));

    for (i = 0; i < NUM_OF_WIDTHS; i++)
    {
        nPenWidth = g_PenWidths[i];

        ::PatBlt(ps.hdc, cx, rect.top + (m_cyItem - nPenWidth) / 2,
            rect.right, nPenWidth, PATCOPY);

        rect.top += m_cyItem;
    }

    SelectBrush(ps.hdc, hOldBrush);

    // Finish painting
    ::EndPaint(m_hwnd, &ps);
}



//
// ItemFromPoint()
// Returns which item, in the client, is under the point.
//
int WbWidthsGroup::ItemFromPoint(int x, int y) const
{
    int iItem;

    iItem = y / m_cyItem;

    // If it's in the border above the first item, pin it.
    if (iItem < 0)
        iItem = 0;

    // If it's in the border below the last item, pin it.
    if (iItem >= (IDM_WIDTHS_END - IDM_WIDTHS_START))
        iItem = (IDM_WIDTHS_END - IDM_WIDTHS_START - 1);

    return(iItem + IDM_WIDTHS_START);
}


//
// GetItemRect()
// Gets the client-relative rectangle of an item
//
void WbWidthsGroup::GetItemRect(int iItem, LPRECT lprc) const
{
    ::GetClientRect(m_hwnd, lprc);

    lprc->top = (iItem - IDM_WIDTHS_START) * m_cyItem;
    lprc->bottom = lprc->top + m_cyItem;
}


//
// OnLButtonDown()
//
void WbWidthsGroup::OnLButtonDown(int x, int y)
{
    int iItem;

    iItem = ItemFromPoint(x, y);
    ::PostMessage(g_pMain->m_hwnd, WM_COMMAND,
                    (WPARAM)MAKELONG(iItem, BN_CLICKED),
                    (LPARAM)m_hwnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\wbloader.cpp ===
#include "precomp.h"
#include "wbloader.h"
#include "nmwbobj.h"

WBLoader   *g_pWBLoader = NULL;
HANDLE      g_hWorkThread = NULL;
BOOL        g_fShutdownByT120 = FALSE;

DWORD __stdcall WBWorkThreadProc(LPVOID lpv);

TCHAR g_PassedFileName [MAX_PATH * 2];

T120Error CALLBACK CreateAppletLoaderInterface
(
    IAppletLoader     **ppOutIntf
)
{
    if (NULL != ppOutIntf)
    {
        if (NULL == g_pWBLoader)
        {
            DBG_SAVE_FILE_LINE
            *ppOutIntf = (IAppletLoader *) new WBLoader();
            return ((NULL != *ppOutIntf) ? T120_NO_ERROR : T120_ALLOCATION_FAILURE);
        }
        return T120_ALREADY_INITIALIZED;
    }
    return T120_INVALID_PARAMETER;
}



//
// FT Applet Loader
//

WBLoader::WBLoader(void)
:
    CRefCount(MAKE_STAMP_ID('W','B','L','D'))
{

	ASSERT(NULL == g_pWBLoader);

    g_pWBLoader = this;
}


WBLoader::~WBLoader(void)
{
    ASSERT(this == g_pWBLoader);

    g_pWBLoader = NULL;
}


//
// Create the work thread and wait for its being started.
//
APPLDR_RESULT WBLoader::AppletStartup
(
    BOOL            fNoUI
)
{
    APPLDR_RESULT eRet = APPLDR_FAIL;
    if (0 == g_dwWorkThreadID)
    {
        HANDLE hSync = ::CreateEvent(NULL, FALSE, FALSE, NULL);
        if (NULL != hSync)
        {
            g_hWorkThread = ::CreateThread(NULL, 0, WBWorkThreadProc, hSync, 0, &g_dwWorkThreadID);
            if (NULL != g_hWorkThread)
            {
                ::WaitForSingleObject(hSync, 5000); // 5 seconds
                // ASSERT(g_pNMWBOBJ);
                eRet = APPLDR_NO_ERROR;
            }
            ::CloseHandle(hSync);
        }
    }
    return eRet;
}

//
APPLDR_RESULT WBLoader::AppletCleanup
(
    DWORD           dwTimeout
)
{
	if (g_pMain)
	{
		//
		// Last change to save
		//
		int rc = g_pMain->QuerySaveRequired(TRUE);
        if (rc == IDYES)
        {
            rc = (int)g_pMain->OnSave(FALSE);
        }

		if (rc == IDCANCEL)
		{
			return APPLDR_CANCEL_EXIT;
		}
	}

    g_fShutdownByT120 = TRUE;

    ::T120_AppletStatus(APPLET_ID_WB, APPLET_CLOSING);

    // notify the work thread to exit
    ::PostThreadMessage(g_dwWorkThreadID, WM_QUIT, 0, 0);

    // wait for the worker thread's going down
    ::WaitForSingleObject(g_hWorkThread, dwTimeout);

    return APPLDR_NO_ERROR;
}


APPLDR_RESULT WBLoader::AppletQuery(APPLET_QUERY_ID eQueryId)
{
    // Do nothing now
    return APPLDR_NO_ERROR;
}

APPLDR_RESULT WBLoader::OnNM2xNodeJoin(void)
{
    // Do nothing now
    return APPLDR_NO_ERROR;
}

APPLDR_RESULT WBLoader::AppletInvoke
(
    BOOL            fRemote,
    T120ConfID      nConfID,
    LPSTR           pszCmdLine
)
{
	::ZeroMemory(&g_PassedFileName, sizeof(g_PassedFileName));
	if(pszCmdLine)
	{
		lstrcpy(g_PassedFileName, pszCmdLine);
		if(g_pMain)
		{
			PostMessage(g_pMain->m_hwnd, WM_USER_LOAD_FILE, 0, 0);
		}
    }

	TRACE_MSG((">>>>AppletInvoke g_pMain = %x",g_pMain));

	if(g_pMain)
	{
		PostMessage(g_pMain->m_hwnd, WM_USER_BRING_TO_FRONT_WINDOW, 0, 0);
	}

    return APPLDR_NO_ERROR;
}


void WBLoader::ReleaseInterface(void)
{
    Release();
}


DWORD __stdcall WBWorkThreadProc(LPVOID lpv)
{

    HRESULT hr = S_OK;

    ::SetEvent((HANDLE) lpv);

	DBG_SAVE_FILE_LINE
	g_pNMWBOBJ  = new CNMWbObj();
	if (NULL == g_pNMWBOBJ || NULL == g_pMain)
	{
		ERROR_OUT(("WB_Startup: cannot create CNMWbObj"));
        hr = E_OUTOFMEMORY;
	}

	if(*g_PassedFileName)
	{
		PostMessage(g_pMain->m_hwnd, WM_USER_LOAD_FILE, 0, 0);
	}

    ::T120_AppletStatus(APPLET_ID_WB, APPLET_WORK_THREAD_STARTED);
	TRACE_MSG((">>>>WBWorkThreadProc APPLET_WORK_THREAD_STARTED"));

	if(g_pMain)
	{
		PostMessage(g_pMain->m_hwnd, WM_USER_BRING_TO_FRONT_WINDOW, 0, 0);
	}

    //
    // MESSAGE LOOP
    //
    if (S_OK == hr)
    {
	    MSG     msg;
	
    	while (::GetMessage(&msg, NULL, NULL, NULL))
	    {
	        if (!g_pMain->FilterMessage(&msg))
	        {
	
				::TranslateMessage(&msg);
    	    	::DispatchMessage(&msg);
    	    }
	    }
	}

	if(g_pNMWBOBJ)
	{
		delete  g_pNMWBOBJ;
		g_pNMWBOBJ = NULL;
	}

    ::T120_AppletStatus(APPLET_ID_WB, APPLET_WORK_THREAD_EXITED);

    g_dwWorkThreadID = 0;

	TRACE_MSG((">>>>WBWorkThreadProc APPLET_WORK_THREAD_EXITED"));

    if (! g_fShutdownByT120)
    {
        FreeLibraryAndExitThread(g_hInstance, 0);
    }

	return 0;
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\wrkspobj.cpp ===
//
// DRAWOBJ.CPP
// Drawing objects: point, openpolyline, closepolyline, ellipse
//
// Copyright Microsoft 1998-
//
#include "precomp.h"
#include "NMWbObj.h"

WorkspaceObj* g_pCurrentWorkspace;
WorkspaceObj* g_pConferenceWorkspace;

//
// Created from UI
//
WorkspaceObj::WorkspaceObj ( void )
{

	ResetAttrib();

	SetOwnerID(g_MyMemberID);

	SetType(workspaceCreatePDU_chosen);

	//
	// Workspace Identifier
	//
	SetWorkspaceHandle(0);

	//
	// Application Roster Instance
	//
    m_appRosterInstance = g_pNMWBOBJ->m_instanceNumber;

	//
	// Is Wokspace synchronized
	//
    m_bsynchronized = TRUE;

	//
	// Does workspace accept keyboard events
	//
    m_acceptKeyboardEvents = FALSE;

	//
	// Does workspace accept mouse events
	//
    m_acceptPointingDeviceEvents = FALSE;

	SetViewState(focus_chosen);

	SetUpdatesEnabled(!g_pDraw->IsLocked());

	//
	// Workspace max width and height
	//
    m_workspaceSize.x = DRAW_WIDTH;		// Max width
    m_workspaceSize.y = DRAW_HEIGHT;	// Max height in Draw.hpp

	RECT rect;
	rect.top = 0;
	rect.left = 0;
	rect.right = m_workspaceSize.x;
	rect.bottom = m_workspaceSize.y;
	SetRect(&rect);
}


//
// Created from Remote
//
WorkspaceObj::WorkspaceObj (WorkspaceCreatePDU * pWorkspaceCreatePDU, BOOL bForcedResend)
{

	ResetAttrib();
	SetType(workspaceCreatePDU_chosen);

	SetUpdatesEnabled(TRUE);

	//
	// Workspace Identifier
	//
	SetWorkspaceHandle(GetWorkspaceIdentifier(&pWorkspaceCreatePDU->workspaceIdentifier));
	SetThisObjectHandle(GetWorkspaceHandle());

#ifdef _DEBUG

	//
	// Application Roster Instance
	//
    m_appRosterInstance = pWorkspaceCreatePDU->appRosterInstance;
	TRACE_DEBUG(("m_appRosterInstance = %d", m_appRosterInstance));

	//
	// Is Wokspace synchronized
	//
    m_bsynchronized = pWorkspaceCreatePDU->synchronized;
	TRACE_DEBUG(("m_bsynchronized = %d", m_bsynchronized));

	//
	// Does workspace accept keyboard events
	//
    m_acceptKeyboardEvents = pWorkspaceCreatePDU->acceptKeyboardEvents;
	TRACE_DEBUG(("m_acceptKeyboardEvents = %d", m_acceptKeyboardEvents));

	//
	// Does workspace accept mouse events
	//
     m_acceptPointingDeviceEvents = pWorkspaceCreatePDU->acceptPointingDeviceEvents;
	TRACE_DEBUG(("m_acceptPointingDeviceEvents = %d", m_acceptPointingDeviceEvents));

	//
	// List of nodes that can access workspace
	//
	if(pWorkspaceCreatePDU->bit_mask & protectedPlaneAccessList_present)
	{
		WorkspaceCreatePDU_protectedPlaneAccessList_Element *pNode;
		pNode = pWorkspaceCreatePDU->protectedPlaneAccessList;
		do
		{
			BYTE * pByte;
			DBG_SAVE_FILE_LINE
			pByte = new BYTE[1];
			*pByte = (UCHAR)pNode->value;
			m_protectedPlaneAccessList.AddTail(pByte);
			pNode = pNode->next;		
		}while (pNode);

	}

	//
	// Workspace max width and height
	//
    m_workspaceSize.x = pWorkspaceCreatePDU->workspaceSize.width;
    m_workspaceSize.y = pWorkspaceCreatePDU->workspaceSize.height;
	TRACE_DEBUG(("m_workspaceSize(x,y) = (%d, %d)", m_workspaceSize.x, m_workspaceSize.y));

	RECT rect;
	rect.top = 0;
	rect.left = 0;
	rect.right = m_workspaceSize.x;
	rect.bottom = m_workspaceSize.y;
	SetRect(&rect);

	//
	// Workspace attributes
	//
	if(pWorkspaceCreatePDU->bit_mask & workspaceAttributes_present)
	{
		GetWorkSpaceAttrib(pWorkspaceCreatePDU->workspaceAttributes);
	}

	//
	// Workspace plane parameters
	//
	GetWorkSpacePlaneParam(pWorkspaceCreatePDU->planeParameters);


	//
	// Workspace view parameters
	//
	if(pWorkspaceCreatePDU->bit_mask & viewParameters_present)
	{
		m_viewHandle = pWorkspaceCreatePDU->viewParameters->value.viewHandle;
		TRACE_DEBUG(("View Handle = %d", m_viewHandle));
		
		if(pWorkspaceCreatePDU->viewParameters->value.bit_mask & viewAttributes_present)
		{
			GetWorkSpaceViewParam(pWorkspaceCreatePDU->viewParameters->value.viewAttributes);
		}
	}

#endif // 0

	//
	// Add it to the list of workspaces
	//
	AddNewWorkspace(this, bForcedResend);

}



WorkspaceObj::~WorkspaceObj( void )
{
	RemoveObjectFromResendList(this);
	RemoveObjectFromRequestHandleList(this);

	//
	// Tell other nodes that we are gone
	//
	if(WasDeletedLocally())
	{
		OnObjectDelete();
	}

	//
	// Delete all the objects in this workspace
	//
	T126Obj * pObj;
    while ((pObj = (T126Obj *)m_T126ObjectsInWorkspace.RemoveTail()) != NULL)
    {
    	pObj->SetMyWorkspace(NULL);
		delete pObj;
		g_numberOfObjects--;
	}
	
	g_numberOfWorkspaces--;
}


void WorkspaceObj::WorkspaceEditObj ( WorkspaceEditPDU * pWorkspaceEditPDU )
{

	//
	// Workspace view parameters
	//
	if(pWorkspaceEditPDU->bit_mask & viewEdits_present)
	{
		GetWorkSpaceViewEditParam(pWorkspaceEditPDU->viewEdits);
	}

	if(HasUpatesEnabledStateChanged())
	{
		if(GetUpdatesEnabled())
		{
			g_pMain->UnlockDrawingArea();
		}
		else
		{
			g_pMain->LockDrawingArea();
		}

		g_pMain->UpdatePageButtons();
	}

	if(HasViewStateChanged() &&
		pWorkspaceEditPDU->viewEdits &&
		pWorkspaceEditPDU->viewEdits->value.action.choice == editView_chosen)
	{
		if(g_pDraw->IsSynced())
		{
			g_pMain->GotoPage(this, FALSE);
		}

		g_pConferenceWorkspace = this;
	}
	
	ResetAttrib();
	
#ifdef _DEBUG
	//
	// Workspace attributes
	//
	if(pWorkspaceEditPDU->bit_mask & WorkspaceEditPDU_attributeEdits_present)
	{
		GetWorkSpaceAttrib((WorkspaceCreatePDU_workspaceAttributes *)pWorkspaceEditPDU->attributeEdits);
	}

	//
	// Workspace plane parameters
	//
	if(pWorkspaceEditPDU->bit_mask & planeEdits_present)
	{
		GetWorkSpacePlaneParam((WorkspaceCreatePDU_planeParameters *)pWorkspaceEditPDU->planeEdits);
	}

#endif // 0
}

UINT WorkspaceObj::GetWorkspaceIdentifier(WorkspaceIdentifier *workspaceIdentifier)
{

	TRACE_DEBUG(("GetWorkspaceIdentifier choice = %d", workspaceIdentifier->choice));
	switch(workspaceIdentifier->choice)
	{
		case(activeWorkspace_chosen):
		{
			TRACE_MSG(("activeWorkspace = %d", workspaceIdentifier->u.activeWorkspace));
			return(workspaceIdentifier->u.activeWorkspace);
			break;
		}
//		case(archiveWorkspace_chosen):
//		{
//			break;
//		}
		default:
		{
		    ERROR_OUT(("Invalid workspaceIdentifier choice"));
			break;
		}
	}
	return -1;
}

void WorkspaceObj::CreateWorkspaceCreatePDU(WorkspaceCreatePDU * pWorkspaceCreatePDU)
{

	pWorkspaceCreatePDU->bit_mask = 0;
	//
	// Workspace Identifier, we have to ask GCC for an active unique workspace handle
	//
	pWorkspaceCreatePDU->workspaceIdentifier.choice = activeWorkspace_chosen;
	pWorkspaceCreatePDU->workspaceIdentifier.u.activeWorkspace = GetWorkspaceHandle();

	//
	// Application Roster Instance
	//
    pWorkspaceCreatePDU->appRosterInstance = (ASN1uint16_t)g_pNMWBOBJ->m_instanceNumber;

	//
	// Is Wokspace synchronized
	//
	pWorkspaceCreatePDU->synchronized = (ASN1bool_t)m_bsynchronized;

	//
	// Does workspace accept keyboard events
	//
	pWorkspaceCreatePDU->acceptKeyboardEvents = (ASN1bool_t)m_acceptKeyboardEvents;

	//
	// Does workspace accept mouse events
	//
	pWorkspaceCreatePDU->acceptPointingDeviceEvents = (ASN1bool_t)m_acceptPointingDeviceEvents;

	//
	// Workspace max width and height
	//
    pWorkspaceCreatePDU->workspaceSize.width = (USHORT)m_workspaceSize.x;
    pWorkspaceCreatePDU->workspaceSize.height = (USHORT)m_workspaceSize.y;


	//
	// Workspace plane parameters
	//
	PWorkspaceCreatePDU_planeParameters planeParameters;
	PWorkspaceCreatePDU_planeParameters_Seq_usage usage;
	PWorkspaceCreatePDU_planeParameters_Seq_usage pFirstUsage;

	//
	// Do the plane parameters
	//
	DBG_SAVE_FILE_LINE
	planeParameters = (PWorkspaceCreatePDU_planeParameters)new BYTE[sizeof(WorkspaceCreatePDU_planeParameters)];	
	pWorkspaceCreatePDU->planeParameters = planeParameters;
	planeParameters->value.bit_mask = planeAttributes_present;
	planeParameters->value.editable = TRUE;
	planeParameters->next = NULL;

	DBG_SAVE_FILE_LINE
	PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes pPlaneAttrib;
	pPlaneAttrib = (PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes) new BYTE[sizeof(WorkspaceCreatePDU_planeParameters_Seq_planeAttributes)];
	pPlaneAttrib->value.choice = protection_chosen;
	pPlaneAttrib->value.u.protection.protectedplane = FALSE;
	pPlaneAttrib->next = NULL;
	
	planeParameters->value.planeAttributes = pPlaneAttrib;

	DBG_SAVE_FILE_LINE
	usage = (PWorkspaceCreatePDU_planeParameters_Seq_usage) new BYTE[sizeof(WorkspaceCreatePDU_planeParameters_Seq_usage)];
	pFirstUsage = usage;
	planeParameters->value.usage = usage;
	usage->value.choice = image_chosen;
	
	DBG_SAVE_FILE_LINE
	usage = (PWorkspaceCreatePDU_planeParameters_Seq_usage) new BYTE[sizeof(WorkspaceCreatePDU_planeParameters_Seq_usage)];
	planeParameters->value.usage->next = usage;
	usage->value.choice = annotation_chosen;
	usage->next = NULL;

	//
	// Do the plane parameters 2nd time
	//
	DBG_SAVE_FILE_LINE
	planeParameters->next = (PWorkspaceCreatePDU_planeParameters)new BYTE[sizeof(WorkspaceCreatePDU_planeParameters)];	
	planeParameters = planeParameters->next;
	planeParameters->value.bit_mask = planeAttributes_present;
	planeParameters->value.editable = TRUE;
	planeParameters->value.usage = pFirstUsage;
	planeParameters->next = NULL;
	planeParameters->value.planeAttributes = pPlaneAttrib;

	//
	// Do it hte 3rd time
	//
	planeParameters->next = (PWorkspaceCreatePDU_planeParameters)new BYTE[sizeof(WorkspaceCreatePDU_planeParameters)];	
	planeParameters = planeParameters->next;
	planeParameters->value.bit_mask = planeAttributes_present;
	planeParameters->value.editable = TRUE;
	planeParameters->value.usage = pFirstUsage;
	planeParameters->next = NULL;
	planeParameters->value.planeAttributes = pPlaneAttrib;


	pWorkspaceCreatePDU->viewParameters = NULL;
}

void WorkspaceObj::CreateWorkspaceDeletePDU(WorkspaceDeletePDU *pWorkspaceDeletePDU)
{
	pWorkspaceDeletePDU->bit_mask = 0;
	pWorkspaceDeletePDU->workspaceIdentifier.choice = activeWorkspace_chosen;
	pWorkspaceDeletePDU->workspaceIdentifier.u.activeWorkspace = GetWorkspaceHandle();
	pWorkspaceDeletePDU->reason.choice = userInitiated_chosen;
}

void WorkspaceObj::CreateWorkspaceEditPDU(WorkspaceEditPDU *pWorkspaceEditPDU)
{
	pWorkspaceEditPDU->bit_mask = 0;
	pWorkspaceEditPDU->workspaceIdentifier.choice = activeWorkspace_chosen;
	pWorkspaceEditPDU->workspaceIdentifier.u.activeWorkspace = GetWorkspaceHandle();

	PWorkspaceEditPDU_viewEdits_Set_action_editView pEditView = NULL;
	pWorkspaceEditPDU->viewEdits = NULL;
	
	if(HasUpatesEnabledStateChanged() || HasViewStateChanged())
	{
		pWorkspaceEditPDU->bit_mask |= viewEdits_present;
		DBG_SAVE_FILE_LINE
		pWorkspaceEditPDU->viewEdits = (PWorkspaceEditPDU_viewEdits)new BYTE[sizeof(WorkspaceEditPDU_viewEdits)];
		pWorkspaceEditPDU->viewEdits->next = NULL;
		pWorkspaceEditPDU->viewEdits->value.viewHandle = m_viewHandle;
		pWorkspaceEditPDU->viewEdits->value.action.choice = (ASN1choice_t)m_viewActionChoice;
		pWorkspaceEditPDU->viewEdits->value.action.u.editView = NULL;
	}
	
	if(HasUpatesEnabledStateChanged())
	{
		DBG_SAVE_FILE_LINE
		pEditView = (PWorkspaceEditPDU_viewEdits_Set_action_editView) new BYTE[sizeof (WorkspaceEditPDU_viewEdits_Set_action_editView)];
		pEditView->next = NULL;
		pEditView->value.choice = updatesEnabled_chosen;
		pEditView->value.u.updatesEnabled = (ASN1bool_t)GetUpdatesEnabled();
		pWorkspaceEditPDU->viewEdits->value.action.u.editView = pEditView;
	}


	if(HasViewStateChanged())
	{
		DBG_SAVE_FILE_LINE
		pEditView = (PWorkspaceEditPDU_viewEdits_Set_action_editView) new BYTE[sizeof (WorkspaceEditPDU_viewEdits_Set_action_editView)];
		pEditView->next = pWorkspaceEditPDU->viewEdits->value.action.u.editView;
		pEditView->value.choice = WorkspaceViewAttribute_viewState_chosen;
		pEditView->value.u.viewState.choice = (ASN1choice_t)GetViewState();
		pWorkspaceEditPDU->viewEdits->value.action.u.editView = pEditView;
	}
}


void WorkspaceObj::RemoveT126Object(T126Obj *pObj)
{

	//
	// The contents of the wb just changed
	//
	g_bContentsChanged = TRUE;

	//
	// Remove it from the List Of objcets in the workspace
	//
	WBPOSITION pos = m_T126ObjectsInWorkspace.GetPosition(pObj);

	m_T126ObjectsInWorkspace.RemoveAt(pos);

	//
	// Erase the drawing
	//
	pObj->DrawRect();
	pObj->UnselectDrawingObject();

	pObj->UnDraw();

	//
	// Put the object in the trash, don't delete it locally
	// but tell the other nodes to delete it
	//
	g_numberOfObjects--;

	g_pDraw->DeleteSelection();

	if(pObj != g_pMain->m_pLocalRemotePointer && pObj->WasDeletedLocally())
	{
		pObj->SetMyPosition(NULL);
		g_pTrash->AddTail( pObj );
		pObj->OnObjectDelete();
	}
	else
	{
		delete pObj;
	}
}


T126Obj* WorkspaceObj::FindObjectInWorkspace(UINT objectHandle)
{
	T126Obj* pObj;

	WBPOSITION pos;
	pos = m_T126ObjectsInWorkspace.GetTailPosition();
    while (pos != NULL)
    {
		pObj = (T126Obj*)m_T126ObjectsInWorkspace.GetPrevious(pos);

		if(pObj && pObj->GetThisObjectHandle() == objectHandle)
		{
			return pObj;
		}
	}

	return NULL;
}


BOOL WorkspaceObj::IsObjectInWorkspace(T126Obj* pObjToFind)
{
	T126Obj* pObj;

	WBPOSITION pos;
	pos = m_T126ObjectsInWorkspace.GetHeadPosition();
	while (pos != NULL)
	{
		pObj = (T126Obj*)m_T126ObjectsInWorkspace.GetNext(pos);
		if(pObj == pObjToFind)
		{
			return TRUE;
		}
	}
	return FALSE;
}


BOOL IsWorkspaceListed(T126Obj * pWorkspaceObj)
{
	T126Obj * pObj;

	WBPOSITION pos;
	pos = g_pListOfWorkspaces->GetHeadPosition();
	while (pos != NULL)
	{
		pObj =(T126Obj *) g_pListOfWorkspaces->GetNext(pos);

		if(pObj == pWorkspaceObj)
		{
			return TRUE;
		}
	}

	return FALSE;
}

//
// Add new workspace
//
void AddNewWorkspace(WorkspaceObj * pWorkspaceObj, BOOL bForcedResend)
{
	g_bContentsChanged = TRUE;

	//
	// Add it to the list of workspace objects
	//
	if(g_pConferenceWorkspace)
	{
		WBPOSITION pos = g_pConferenceWorkspace->GetMyPosition();
		pWorkspaceObj->SetMyPosition(g_pListOfWorkspaces->AddAt(pWorkspaceObj, pos));
	}
	else
	{
		pWorkspaceObj->SetMyPosition(g_pListOfWorkspaces->AddTail(pWorkspaceObj));

		g_pConferenceWorkspace = pWorkspaceObj;
		g_pCurrentWorkspace = pWorkspaceObj;	
		if(!g_pDraw->IsSynced())
		{
			g_pMain->OnSync();
		}
	}

	g_numberOfWorkspaces++;
	
	if(g_pDraw->IsSynced())
	{
		g_pMain->GotoPage(pWorkspaceObj, bForcedResend);
	}
	//
	// We are not synced but update the page butons anyway
	//
	else
	{
		g_pConferenceWorkspace = pWorkspaceObj;
		g_pMain->UpdatePageButtons();
	}
}

BitmapObj * WorkspaceObj::RectHitRemotePointer(LPRECT hitRect, int penThickness , WBPOSITION pos)
{
	if(pos == NULL)
	{
		pos = m_T126ObjectsInWorkspace.GetTailPosition();
	}
	else
	{
		m_T126ObjectsInWorkspace.GetPrevious(pos);
	}
	
	T126Obj* pPointer = (T126Obj*)m_T126ObjectsInWorkspace.GetFromPosition(pos);
	
	RECT pointerRect;
	RECT intersectRect;

	while(pos && pPointer && pPointer->GraphicTool() == TOOLTYPE_REMOTEPOINTER)
	{
		pPointer->GetRect(&pointerRect);
		::InflateRect(&pointerRect, penThickness , penThickness);
		NormalizeRect(&pointerRect);
		NormalizeRect(hitRect);
		if(IntersectRect(&intersectRect, &pointerRect, hitRect))
		{
			return (BitmapObj *)pPointer;
		}
		pPointer = (T126Obj*) m_T126ObjectsInWorkspace.GetPrevious(pos);	
	}
	return NULL;
}


void WorkspaceObj::AddTail(T126Obj * pObj)
{
	//
	// The contents of the wb just changed
	//
	g_bContentsChanged = TRUE;
	
	pObj->SetMyWorkspace(this);
	T126Obj* pPointer = (T126Obj*)m_T126ObjectsInWorkspace.GetTail();

	//
	// Add the local remote pointer in the tail position
	// and other type of objects before all the remote pointers
	//
	if(!(pObj->GraphicTool() == TOOLTYPE_REMOTEPOINTER && pObj->IAmTheOwner()) &&
		pPointer && pPointer->GraphicTool() == TOOLTYPE_REMOTEPOINTER)
	{
		WBPOSITION pos = m_T126ObjectsInWorkspace.GetTailPosition();
		WBPOSITION insertPos = NULL;
		
		//
		// Find the first object that is not a remote pointer
		//
		while(pPointer->GraphicTool() == TOOLTYPE_REMOTEPOINTER)
		{
			insertPos = pos;
			if(pos == NULL)
			{
				break;
			}
			pPointer = (T126Obj*) m_T126ObjectsInWorkspace.GetPrevious(pos);	
		}
		
		if(insertPos)
		{
			pObj->SetMyPosition(m_T126ObjectsInWorkspace.AddAt(pObj, insertPos));
		}
		else
		{
			pObj->SetMyPosition(m_T126ObjectsInWorkspace.AddHead(pObj));
		}

		//
		// Make sure we repaint the area, if there was a handle it could be under it
		//
		if(pObj->GraphicTool() == TOOLTYPE_REMOTEPOINTER)
		{
			((BitmapObj*)pObj)->CreateSaveBitmap();
		}

		RECT rect;
		pObj->GetBoundsRect(&rect);
		g_pDraw->InvalidateSurfaceRect(&rect,TRUE);
		
	}
	else	
	{
		pObj->SetMyPosition(m_T126ObjectsInWorkspace.AddTail(pObj));
	}
}


WorkspaceObj* RemoveWorkspace(WorkspaceObj * pWorkspaceObj)
{
	WorkspaceObj * pWrkspc;

	g_bContentsChanged = TRUE;
	
	WBPOSITION pos = pWorkspaceObj->GetMyPosition();
	WBPOSITION prevPos = pos;

	g_pListOfWorkspaces->GetPrevious(prevPos);

	g_pListOfWorkspaces->RemoveAt(pos);

	//
	// We just removed the first page
	//
	if(prevPos == NULL)
	{
		pWrkspc = (WorkspaceObj *)g_pListOfWorkspaces->GetHead();
	}
	else
	{
		pWrkspc = (WorkspaceObj *)g_pListOfWorkspaces->GetPrevious(prevPos);
	}

	//
	// The current workspace is pointing to the deleted object
	//
	if(g_pCurrentWorkspace == pWorkspaceObj)
	{
		::InvalidateRect(g_pDraw->m_hwnd, NULL, TRUE);


		//
		// If we were drawing/selecting or dragging something, finish now
		//
		g_pDraw->OnLButtonUp(0,0,0);

		//
		// If we are deleting the current workspace and we have the text editor active
		//
		if (g_pDraw->TextEditActive())
		{
			//
			// Finish the text
			//
   			g_pDraw->EndTextEntry(FALSE);
		}

		g_pCurrentWorkspace = NULL;
	}

	if(g_pConferenceWorkspace == pWorkspaceObj)
	{
		g_pConferenceWorkspace = NULL;

	}

	delete pWorkspaceObj;

	return pWrkspc;
}

UINT WorkspaceObj::EnumerateObjectsInWorkspace(void)
{
	UINT objects = 0;
	WBPOSITION pos;
	T126Obj* pObj;
	
	pos = GetHeadPosition();
	while(pos)
	{
		pObj = GetNextObject(pos);
		if(pObj && pObj->GraphicTool() != TOOLTYPE_REMOTEPOINTER)
		{
			objects++;
		}
	}
	return objects;
}


void ResendAllObjects(void)
{
 	//
	// Resend all objects
  	//
	WBPOSITION pos;
	WBPOSITION posObj;
	WorkspaceObj* pWorkspace;
	WorkspaceObj* pCurrentWorkspace;

	pCurrentWorkspace  = g_pCurrentWorkspace;

	T126Obj* pObj;
	pos = g_pListOfWorkspaces->GetHeadPosition();
	while(pos)
	{
		pWorkspace = (WorkspaceObj*)g_pListOfWorkspaces->GetNext(pos);
		if(pWorkspace)
		{
			pWorkspace->SetAllAttribs();
			pWorkspace->SendNewObjectToT126Apps();
			posObj = pWorkspace->GetHeadPosition();
			while(posObj)
			{
				pObj = pWorkspace->GetNextObject(posObj);
				if(pObj)
				{
					pObj->ClearSelectionFlags();
					pObj->SetAllAttribs();
					pObj->SendNewObjectToT126Apps();

					//
					// Lines need to be saved in various pdus with 256 points in each pdu
					//
					if(pObj->GraphicTool() == TOOLTYPE_PEN || pObj->GraphicTool() == TOOLTYPE_HIGHLIGHT)
					{
						int nPoints = ((DrawObj*)pObj)->m_points->GetSize();
						int size = MAX_POINT_LIST_VALUES + 1;
						if(nPoints > (MAX_POINT_LIST_VALUES + 1))
						{
							while(size != nPoints)
							{
								if(nPoints > (size + MAX_POINT_LIST_VALUES + 1))
								{
									size += MAX_POINT_LIST_VALUES + 1;
								}
								else
								{
									size = nPoints;
								}

								//
								// Move to the next 256 points
								//

								((DrawObj*)pObj)->m_points->SetSize(size - 1);

								//
								// Send the next 256 points
								//
								pObj->ResetAttrib();
								((DrawObj*)pObj)->ChangedPointList();
								pObj->OnObjectEdit();
							}
							((DrawObj*)pObj)->m_points->SetSize(size);
						}
					}
				}
			}
		}
	}

	//
	// Syncronize page
	//
	if(g_pCurrentWorkspace)
	{
		g_pMain->GotoPage(g_pCurrentWorkspace);
		g_pCurrentWorkspace->SetViewState(focus_chosen);
		g_pCurrentWorkspace->SetViewActionChoice(editView_chosen);
		g_pCurrentWorkspace->OnObjectEdit();
	}
}

void RemoveObjectFromRequestHandleList(T126Obj * pObjRequest)
{
	T126Obj* pObj;
	WBPOSITION pos;
	WBPOSITION prevPos;
	pos = g_pListOfObjectsThatRequestedHandles->GetHeadPosition();
	while (pos != NULL)
	{
		prevPos = pos;
		pObj = (T126Obj*)g_pListOfObjectsThatRequestedHandles->GetNext(pos);
		if(pObj == pObjRequest)
		{
			g_pListOfObjectsThatRequestedHandles->RemoveAt(prevPos);
			break;
		}
	}
}


UINT GetSIPDUObjectHandle(SIPDU * sipdu)
{
	UINT ObjectHandle = 0;

	switch(sipdu->choice)
	{
		case bitmapAbortPDU_chosen:
			ObjectHandle = sipdu->u.bitmapAbortPDU.bitmapHandle;
		break;
		
		case bitmapCheckpointPDU_chosen:
			ObjectHandle = sipdu->u.bitmapCheckpointPDU.bitmapHandle;
		break;
		
		case bitmapCreatePDU_chosen:
			ObjectHandle = sipdu->u.bitmapCreatePDU.bitmapHandle;
		break;
		
		case bitmapCreateContinuePDU_chosen:
			ObjectHandle = sipdu->u.bitmapCreateContinuePDU.bitmapHandle;
		break;
		
		case bitmapDeletePDU_chosen:
			ObjectHandle = sipdu->u.bitmapDeletePDU.bitmapHandle;
		break;
		
		case bitmapEditPDU_chosen:
			ObjectHandle = sipdu->u.bitmapEditPDU.bitmapHandle;
		break;
		
		case drawingCreatePDU_chosen:
			ObjectHandle = sipdu->u.drawingCreatePDU.drawingHandle;
		break;
		
		case drawingDeletePDU_chosen:
			ObjectHandle = sipdu->u.drawingDeletePDU.drawingHandle;
		break;
		
		case drawingEditPDU_chosen:
			ObjectHandle = sipdu->u.drawingEditPDU.drawingHandle;
		break;
		
		case siNonStandardPDU_chosen:
		ObjectHandle = ((TEXTPDU_HEADER*) sipdu->u.siNonStandardPDU.nonStandardTransaction.data.value)->textHandle;
		break;
		
		case workspaceCreatePDU_chosen:
			ObjectHandle = WorkspaceObj::GetWorkspaceIdentifier(&sipdu->u.workspaceCreatePDU.workspaceIdentifier);
		break;
		
		case workspaceCreateAcknowledgePDU_chosen:
			ObjectHandle = WorkspaceObj::GetWorkspaceIdentifier(&sipdu->u.workspaceCreateAcknowledgePDU.workspaceIdentifier);
		break;
		
		case workspaceDeletePDU_chosen:
			ObjectHandle = WorkspaceObj::GetWorkspaceIdentifier(&sipdu->u.workspaceDeletePDU.workspaceIdentifier);
		break;
		
		case workspaceEditPDU_chosen:
			ObjectHandle = WorkspaceObj::GetWorkspaceIdentifier(&sipdu->u.workspaceEditPDU.workspaceIdentifier);
		break;
		
		case workspacePlaneCopyPDU_chosen:
			ObjectHandle = WorkspaceObj::GetWorkspaceIdentifier(&sipdu->u.workspacePlaneCopyPDU.sourceWorkspaceIdentifier);
		break;
		
		case workspaceReadyPDU_chosen:
			ObjectHandle = WorkspaceObj::GetWorkspaceIdentifier(&sipdu->u.workspaceReadyPDU.workspaceIdentifier);
		break;
		
	}

	return ObjectHandle;


}


BOOL RemoveObjectFromResendList(T126Obj * pObjRequest)
{
	BOOL bRemoved = FALSE;
	SIPDU* pPDU;
	WBPOSITION pos;
	WBPOSITION prevPos;

	UINT objectHandle = pObjRequest->GetThisObjectHandle();
	pos = g_pRetrySendList->GetHeadPosition();
	while (pos != NULL)
	{
		prevPos = pos;
		pPDU = (SIPDU*)g_pRetrySendList->GetNext(pos);
		if(GetSIPDUObjectHandle(pPDU) == objectHandle)
		{
			g_pRetrySendList->RemoveAt(prevPos);
			SIPDUCleanUp(pPDU);
			bRemoved = TRUE;
		}
	}

	return bRemoved;
}




void RemoveRemotePointer(MEMBER_ID nMemberID)
{
 	//
	// Resend all objects
  	//
	WBPOSITION pos;
	WBPOSITION posObj;
	WorkspaceObj* pWorkspace;
	ULONG ownerID;
	T126Obj* pObj;
	pos = g_pListOfWorkspaces->GetHeadPosition();
	while(pos)
	{
		pWorkspace = (WorkspaceObj*)g_pListOfWorkspaces->GetNext(pos);
		if(pWorkspace)
		{
			posObj = pWorkspace->GetHeadPosition();
			while(posObj)
			{
				pObj = pWorkspace->GetNextObject(posObj);
				if(pObj && pObj->GraphicTool() == TOOLTYPE_REMOTEPOINTER)
				{
					ownerID = GET_NODE_ID_FROM_MEMBER_ID(pObj->GetOwnerID());

					TRACE_DEBUG(("RemoveRemotePointer ownerID=%x member that left =%x " , ownerID, nMemberID));

					
					if(ownerID != g_MyMemberID)
					{
						if(nMemberID)
						{
							if(nMemberID == ownerID)					
							{
								pWorkspace->RemoveT126Object(pObj);
							}
						}
						else
						{
							pWorkspace->RemoveT126Object(pObj);
						}
					}
				}
			}
		}
	}

	//
	// Syncronize page
	//
	if(g_pCurrentWorkspace)
	{
		g_pCurrentWorkspace->SetViewActionChoice(editView_chosen);
		g_pCurrentWorkspace->OnObjectEdit();
	}
}


BOOL IsThereAnythingInAnyWorkspace(void)
{
	WBPOSITION pos;
	WBPOSITION posObj;
	WorkspaceObj* pWorkspace;
	T126Obj* pObj;
	pos = g_pListOfWorkspaces->GetHeadPosition();
	while(pos)
	{
		pWorkspace = (WorkspaceObj*)g_pListOfWorkspaces->GetNext(pos);
		if(pWorkspace)
		{
			posObj = pWorkspace->GetHeadPosition();
			while(posObj)
			{
				pObj = pWorkspace->GetNextObject(posObj);
				if(pObj)
				{
					if(pObj->GraphicTool() != TOOLTYPE_REMOTEPOINTER)
					{
						return TRUE;
					}
				}
			}
		}
	}
	return FALSE;
}



//
// UI Edited the Workspace Object
//
void WorkspaceObj::OnObjectEdit(void)
{

	g_bContentsChanged = TRUE;

	//
	// If we are not synced don't bug the other nodes
	//
	if(!g_pDraw->IsSynced())
	{
		return;
	}

	SIPDU *sipdu = NULL;
	DBG_SAVE_FILE_LINE
	sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
	if(!sipdu)
	{
		TRACE_MSG(("Failed to create sipdu"));
        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
        return;
	}

	sipdu->choice = workspaceEditPDU_chosen;
	CreateWorkspaceEditPDU(&sipdu->u.workspaceEditPDU);
	T120Error rc = SendT126PDU(sipdu);
	if(rc == T120_NO_ERROR)
	{
		SIPDUCleanUp(sipdu);
		ResetAttrib();
	}
}

//
// UI Deleted the Workspace Object
//
void WorkspaceObj::OnObjectDelete(void)
{
	SIPDU *sipdu = NULL;
	DBG_SAVE_FILE_LINE
	sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
	if(sipdu)
	{
		sipdu->choice = workspaceDeletePDU_chosen;
		CreateWorkspaceDeletePDU(&sipdu->u.workspaceDeletePDU);
		T120Error rc = SendT126PDU(sipdu);
		if(rc == T120_NO_ERROR)
		{
			SIPDUCleanUp(sipdu);
		}
	}
	else
	{
		TRACE_MSG(("Failed to create sipdu"));
        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
	}
}

void WorkspaceObj::GetEncodedCreatePDU(ASN1_BUF *pBuf)
{
	SIPDU *sipdu = NULL;
	sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
	if(sipdu)
	{
		sipdu->choice = workspaceCreatePDU_chosen;
		CreateWorkspaceCreatePDU(&sipdu->u.workspaceCreatePDU);
		ASN1_BUF encodedPDU;
		g_pCoder->Encode(sipdu, pBuf);
		delete sipdu->u.workspaceCreatePDU.planeParameters->value.usage;
		delete sipdu->u.workspaceCreatePDU.planeParameters;
		delete [] sipdu;
	}
	else
	{
		TRACE_MSG(("Failed to create sipdu"));
        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
	}
	
}


void SendWorkspaceRefreshPDU(BOOL bImtheRefresher)
{
	SIPDU *sipdu = NULL;
	DBG_SAVE_FILE_LINE
	sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
	if(sipdu)
	{
		sipdu->choice = workspaceRefreshStatusPDU_chosen;
		sipdu->u.workspaceRefreshStatusPDU.bit_mask = 0;
		sipdu->u.workspaceRefreshStatusPDU.refreshStatus = (ASN1bool_t)bImtheRefresher;
		T120Error rc = SendT126PDU(sipdu);
		if(rc == T120_NO_ERROR)
		{
			SIPDUCleanUp(sipdu);
		}
	}
	else
	{
		TRACE_MSG(("Failed to create sipdu"));
        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
	}

}

//
// UI Created a new Workspace Object
//
void WorkspaceObj::SendNewObjectToT126Apps(void)
{
	SIPDU *sipdu = NULL;
	DBG_SAVE_FILE_LINE
	sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
	if(sipdu)
	{
		sipdu->choice = workspaceCreatePDU_chosen;
		CreateWorkspaceCreatePDU(&sipdu->u.workspaceCreatePDU);
		TRACE_DEBUG(("Sending Workspace >> Workspace handle  = %d", sipdu->u.workspaceCreatePDU.workspaceIdentifier.u.activeWorkspace ));
		T120Error rc = SendT126PDU(sipdu);
		if(rc == T120_NO_ERROR)
		{
			SIPDUCleanUp(sipdu);
		}

		SetAllAttribs();
		SetViewActionChoice(createNewView_chosen);
		SetViewState(focus_chosen);
		OnObjectEdit();
	}
	else
	{
		TRACE_MSG(("Failed to create sipdu"));
        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
	}
	
}


void WorkspaceObj::GetWorkSpaceViewEditParam(PWorkspaceEditPDU_viewEdits pViewEdits)
{
	m_viewHandle = pViewEdits->value.viewHandle;
	TRACE_DEBUG(("GetWorkSpaceViewEditParam View Handle = %d", m_viewHandle));
	TRACE_DEBUG(("GetWorkSpaceViewEditParam View Choice = %d", pViewEdits->value.action.choice));

	switch(pViewEdits->value.action.choice)
	{
		case(createNewView_chosen):
		{
			GetWorkSpaceViewParam((PWorkspaceCreatePDU_viewParameters_Set_viewAttributes)pViewEdits->value.action.u.createNewView);
		}
		break;

		case(editView_chosen):
		{
			GetWorkSpaceViewParam((PWorkspaceCreatePDU_viewParameters_Set_viewAttributes)pViewEdits->value.action.u.editView);
		}
		break;

		case(deleteView_chosen):
		{
			;
		}
		break;

//		case(nonStandardAction_chosen):
//		{
//		}
//		break;

		default:
		WARNING_OUT(("Invalid workspace view attribute"));
		break;
	}
}


void WorkspaceObj::GetWorkSpaceViewParam(PWorkspaceCreatePDU_viewParameters_Set_viewAttributes pViewAttributes)
{

	PWorkspaceCreatePDU_viewParameters_Set_viewAttributes attributes;
	attributes = pViewAttributes;
	while(attributes)
	{
		switch(attributes->value.choice)
		{
			case (viewRegion_chosen):
			{

				switch(attributes->value.u.viewRegion.choice)
				{
					case(fullWorkspace_chosen):
					{
						m_viewRegion.top = 0;
						m_viewRegion.left = 0;
						m_viewRegion.bottom = m_workspaceSize.x;
						m_viewRegion.right = m_workspaceSize.y;
						TRACE_DEBUG(("fullWorkspace_chosen View Region = (%d, %d)(%d, %d)",
									m_viewRegion.top,
									m_viewRegion.left,
									m_viewRegion.bottom,
									m_viewRegion.right));
						
					}
						case(partialWorkspace_chosen):
					{
						m_viewRegion.top = attributes->value.u.viewRegion.u.partialWorkspace.upperLeft.yCoordinate;
						m_viewRegion.left = attributes->value.u.viewRegion.u.partialWorkspace.upperLeft.xCoordinate;
						m_viewRegion.bottom = attributes->value.u.viewRegion.u.partialWorkspace.upperLeft.yCoordinate;
						m_viewRegion.right = attributes->value.u.viewRegion.u.partialWorkspace.upperLeft.xCoordinate;
						TRACE_DEBUG(("partialWorkspace_chosen View Region = (%d, %d)(%d, %d)",
									m_viewRegion.top,
									m_viewRegion.left,
									m_viewRegion.bottom,
									m_viewRegion.right));
					}
					break;
						default:
				    ERROR_OUT(("Invalid view region choice"));
					break;
					}
			}
			break;

			case (WorkspaceViewAttribute_viewState_chosen):
			{
				SetViewState(attributes->value.u.viewState.choice);
				TRACE_DEBUG(("View state = %d", attributes->value.u.viewState.choice));
			}
			break;

			case (updatesEnabled_chosen):
			{
 				SetUpdatesEnabled(attributes->value.u.updatesEnabled);
				if(!m_bUpdatesEnabled)
				{
					g_pNMWBOBJ->m_LockerID = GetOwnerID();
				}

				TRACE_DEBUG(("Updates enabled = %d", m_bUpdatesEnabled));
			}
			break;

//			case (sourceDisplayIndicator_chosen):
//			{
//				JOSEF what we do with these??????
//						attributes->value.u.sourceDisplayIndicator.displayAspectRatio;
//					    attributes->value.u.sourceDisplayIndicator.horizontalSizeRatio;
//					    attributes->value.u.sourceDisplayIndicator.horizontalPosition;
//					    attributes->value.u.sourceDisplayIndicator.verticalPosition;
//
//			}
//			break;

			default:
		    WARNING_OUT(("Invalid workspace view attribute"));
			break;
		}
	attributes = attributes->next;
	}
}


//
// JOSEF The following is not used but is part of the standard
// It is removed because we don't need it now
// We may need to add it for interop in the future
//
#ifdef _DEBUG

void WorkspaceObj::SetBackGroundColor(COLORREF rgb)
{
	m_backgroundColor.rgbtRed = GetRValue(rgb);
	m_backgroundColor.rgbtGreen = GetGValue(rgb);
	m_backgroundColor.rgbtBlue = GetBValue(rgb);
}




void WorkspaceObj::GetWorkSpaceAttrib(PWorkspaceCreatePDU_workspaceAttributes pWorkspaceAttributes)
{

	PWorkspaceCreatePDU_workspaceAttributes attributes;
	attributes = pWorkspaceAttributes;
	COLORREF rgb;
	while(attributes)
	{
		switch(attributes->value.choice)
		{
			case(backgroundColor_chosen):
			{
				switch(attributes->value.u.backgroundColor.choice)
				{
//					case(workspacePaletteIndex_chosen):
//					{
//						ASN1uint16_t workspacePaletteIndex = ((attributes->value.u.backgroundColor).u).workspacePaletteIndex;
//						break;
//					}
					case(rgbTrueColor_chosen):
					{
						rgb = RGB(attributes->value.u.backgroundColor.u.rgbTrueColor.r,
										attributes->value.u.backgroundColor.u.rgbTrueColor.g,
										attributes->value.u.backgroundColor.u.rgbTrueColor.b);
						SetBackGroundColor(rgb);
						TRACE_DEBUG(("Attribute penColor (r,g,b)=(%d, %d,%d)",
								attributes->value.u.backgroundColor.u.rgbTrueColor.r,
								attributes->value.u.backgroundColor.u.rgbTrueColor.g,
								attributes->value.u.backgroundColor.u.rgbTrueColor.b));
						break;
					}
					case(transparent_chosen):
					{
						SetBackGroundColor(0);
						TRACE_DEBUG(("Backgroundcolor transparent"));
						break;
					}
					default:
				    ERROR_OUT(("Invalid backgroundColor choice"));
					break;
				}
				break;
  			}

			case(preserve_chosen):
			{
				m_bPreserve = attributes->value.u.preserve;
				TRACE_DEBUG(("m_bPreserve %d", m_bPreserve));
			}	
			break;
		}
	
		attributes = attributes->next;
	}

}

void WorkspaceObj::GetWorkSpacePlaneParam(PWorkspaceCreatePDU_planeParameters pPlaneParameters)
{

		TRACE_DEBUG(("GetWorkSpacePlaneParam NYI"));

	;
}
#endif // 0



void TogleLockInAllWorkspaces(BOOL bLock, BOOL bResend)
{
	WorkspaceObj * pWorkspace;
	WBPOSITION pos = g_pListOfWorkspaces->GetHeadPosition();
    while (pos)
    {
		pWorkspace = (WorkspaceObj *) g_pListOfWorkspaces->GetNext(pos);

		pWorkspace->SetUpdatesEnabled(!bLock);
		if(bResend)
		{
			pWorkspace->SetViewActionChoice(editView_chosen);
			pWorkspace->OnObjectEdit();
		}
	}
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb32stub\wb32stub.cpp ===
// File: wb32stub.cpp

#include <windows.h>
#include <tchar.h>
#include "SDKInternal.h"

#ifdef _DEBUG
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hInstPrev, LPTSTR lpCmdLine, int nCmdShow)
{
	lpCmdLine = GetCommandLine();
#else  // _DEBUG
int __cdecl main()
{
	LPTSTR lpCmdLine = GetCommandLine();
#endif // _DEBUG

	// All I have to do is find two quotes
	int nQuotes = 0;
	while((nQuotes != 2) && (*lpCmdLine))
	{	
		if(*lpCmdLine == '"')
		{
			++nQuotes;
		}

		lpCmdLine = CharNext(lpCmdLine);
	}

		// Skip the whitespace
	lpCmdLine = CharNext(lpCmdLine);

	CoInitialize(NULL);

	IInternalConfExe* pConf = NULL;

	if(SUCCEEDED(CoCreateInstance(CLSID_NmManager, NULL, CLSCTX_LOCAL_SERVER, IID_IInternalConfExe, reinterpret_cast<void**>(&pConf))))
	{	
		BSTR strCmdLine = NULL;
		bool bOldWB = true;
		if(*lpCmdLine)
		{
			if(('-' == lpCmdLine[0]) && (' ' == lpCmdLine[1]))
			{
				bOldWB = false;
				lpCmdLine = CharNext(lpCmdLine);
				lpCmdLine = CharNext(lpCmdLine);
			}

			int nConvertedLen = MultiByteToWideChar(CP_ACP, 0, lpCmdLine, -1, NULL, NULL) - 1;
			strCmdLine = ::SysAllocStringLen(NULL, nConvertedLen);
			if(strCmdLine != NULL)
			{
				MultiByteToWideChar(CP_ACP, 0, lpCmdLine, -1, strCmdLine, nConvertedLen);
			}
		}

		pConf->LaunchApplet(bOldWB ? NM_APPID_WHITEBOARD : NM_APPID_T126_WHITEBOARD, strCmdLine);
		pConf->Release();

		if(strCmdLine)
		{
			SysFreeString(strCmdLine);
		}
	}
	
	CoUninitialize();

#ifndef _DEBUG
	ExitProcess(0);
#endif

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\wrkspobj.hpp ===
//
// WRKSPOBJ.HPP
// Drawing objects: point, openpolyline, closepolyline, ellipse
//
// Copyright Microsoft 1998-
//
#ifndef __WRKSPOBJ_HPP_
#define __WRKSPOBJ_HPP_

#include "mcshelp.h"

void AddNewWorkspace(WorkspaceObj * pWorkspaceObj, BOOL bForcedResend = FALSE);
WorkspaceObj* RemoveWorkspace(WorkspaceObj * pWorkspaceObj);
void RemoveObjectFromRequestHandleList(T126Obj * pObjRequest);
BOOL RemoveObjectFromResendList(T126Obj * pObjRequest);
void RemoveRemotePointer(MEMBER_ID nMemberID);
void ResendAllObjects(void);
BOOL IsThereAnythingInAnyWorkspace(void);
BOOL IsWorkspaceListed(T126Obj * pWorkspaceObj);
void SendWorkspaceRefreshPDU(BOOL bImtheRefresher);
void TogleLockInAllWorkspaces(BOOL bLock, BOOL bResend = FALSE);

class BitmapObj;

class WorkspaceObj : public T126Obj
{

public:
	
	WorkspaceObj ( void );
	WorkspaceObj (WorkspaceCreatePDU * pworkspaceCreatePDU, BOOL bForcedResend);
	~WorkspaceObj( void );
	void WorkspaceEditObj ( WorkspaceEditPDU * pworkspaceEditPDU );

	BOOL m_bWorkspaceReady;

	void CreateWorkspaceCreatePDU(WorkspaceCreatePDU *);
	void CreateWorkspaceDeletePDU(WorkspaceDeletePDU *);
	void CreateWorkspaceEditPDU(WorkspaceEditPDU *);
	static UINT GetWorkspaceIdentifier(WorkspaceIdentifier *workspaceIdentifier);
	void GetWorkSpaceViewEditParam(PWorkspaceEditPDU_viewEdits pViewEdits);
	void GetWorkSpaceViewParam(PWorkspaceCreatePDU_viewParameters_Set_viewAttributes pViewAttributes);

	//
	// Workspace object list management
	//
	void AddTail(T126Obj * pObj);
	void AddHead(T126Obj * pObj){pObj->SetMyWorkspace(this); pObj->SetMyPosition(m_T126ObjectsInWorkspace.AddHead(pObj));}
	WBPOSITION GetTailPosition(void){return m_T126ObjectsInWorkspace.GetTailPosition();}
	WBPOSITION GetHeadPosition(void){return m_T126ObjectsInWorkspace.GetHeadPosition();}
	T126Obj*  GetHead(void){return (T126Obj*)m_T126ObjectsInWorkspace.GetHead();}
	T126Obj*  GetTail(void){return (T126Obj*)m_T126ObjectsInWorkspace.GetTail();}
	T126Obj*  GetNextObject(WBPOSITION& pos){return (T126Obj*)m_T126ObjectsInWorkspace.GetNext(pos);}
	T126Obj*  GetPreviousObject(WBPOSITION& pos){return (T126Obj*)m_T126ObjectsInWorkspace.GetPrevious(pos);}
	T126Obj*  RemoveAt(WBPOSITION& pos){return (T126Obj*)m_T126ObjectsInWorkspace.RemoveAt(pos);}
	void RemoveT126Object(T126Obj *pObj);
	T126Obj* FindObjectInWorkspace(UINT objectHandle);
	BOOL IsObjectInWorkspace(T126Obj* pObjToFind);
	UINT EnumerateObjectsInWorkspace(void);
	BitmapObj * RectHitRemotePointer(LPRECT rect, int, WBPOSITION pos);


	void SetBackGroundColor(COLORREF rgb);

	//
	// Base class overwrite
	//
	void Draw(HDC hDC = NULL, BOOL bForcedDraw = FALSE, BOOL bPrinting = FALSE){};
	void UnDraw(){};
	BOOL CheckReallyHit(LPCRECT pRectHit){return TRUE;};

	BOOL HasFillColor(void){return FALSE;}
	void SetFillColor(COLORREF cr, BOOL isPresent){}
    BOOL GetFillColor(COLORREF * pcr) {return FALSE;}
    BOOL GetFillColor(RGBTRIPLE* prgb) {return FALSE;}

	void SetPenColor(COLORREF cr, BOOL isPresent){}
    BOOL GetPenColor(COLORREF * pcr) {return FALSE;}
    BOOL GetPenColor(RGBTRIPLE * prgb) {return FALSE;}

	void ChangedAnchorPoint(void){};
	BOOL HasAnchorPointChanged(void){return FALSE;}
	void ChangedZOrder(void){};
	BOOL HasZOrderChanged(void){return FALSE;}
	void ChangedViewState(void){m_dwChangedAttrib |= 0x00000001;}
	void ChangedUpatesEnabledState(void){m_dwChangedAttrib |= 0x00000002;}
	BOOL HasViewStateChanged(void){return (m_dwChangedAttrib & 0x00000001);}
	BOOL HasUpatesEnabledStateChanged(void){return (m_dwChangedAttrib & 0x00000002);}
	void ResetAttrib(void){m_dwChangedAttrib = 0;}
	void SetAllAttribs(void){m_dwChangedAttrib = 0x00000003;};
	void ChangedPenThickness(void){};
	BOOL GetUpdatesEnabled(void){return m_bUpdatesEnabled;}
	void SetUpdatesEnabled(BOOL bUpdatesEnabled){m_bUpdatesEnabled = bUpdatesEnabled; ChangedUpatesEnabledState();}
	void SetViewActionChoice(UINT action){m_viewActionChoice = action;}
	void SetViewHandle(UINT viewHandle){m_viewHandle = viewHandle;}
	
	void OnObjectEdit(void);
	void OnObjectDelete(void);
	void SendNewObjectToT126Apps(void);
	void GetEncodedCreatePDU(ASN1_BUF *pBuf);

protected:
	DWORD			m_dwChangedAttrib;
	CWBOBLIST m_T126ObjectsInWorkspace;
	UINT m_appRosterInstance;
	BOOL m_bsynchronized;
	POINT m_workspaceSize;
	BOOL m_acceptKeyboardEvents;
	BOOL m_acceptPointingDeviceEvents;
	BOOL m_bUpdatesEnabled;
	ULONG m_viewHandle;
	RECT m_viewRegion;
	UINT m_viewActionChoice;
	COBLIST m_protectedPlaneAccessList;

#ifdef _DEBUG
	RGBTRIPLE	m_backgroundColor;
	BOOL m_bPreserve;

	void GetWorkSpaceAttrib(PWorkspaceCreatePDU_workspaceAttributes pWorkspaceAttributes);
	void GetWorkSpacePlaneParam(PWorkspaceCreatePDU_planeParameters pPlaneParameters);
#endif // 0
};

#endif // __WRKSPOBJ_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\attribs.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       attribs.h
//  Content:    This file contains the attributes object definition.
//  History:
//      Wed 17-Apr-1996 11:18:47  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1995-1996
//
//****************************************************************************

#ifndef _ATTRIBS_H_
#define _ATTRIBS_H_

//****************************************************************************
// CAttributes definition
//****************************************************************************
//
class CAttributes : public IIlsAttributes
{
	friend class CIlsMain;
	friend class CIlsUser;
	friend class CIlsMeetingPlace;

private:
	LONG			m_cRef;
	ILS_ATTR_TYPE	m_AccessType;
	ULONG			m_cAttrs;
	ULONG			m_cchNames;
	ULONG			m_cchValues;
	CList			m_AttrList;

	// Private methods
	//
	HRESULT InternalSetAttribute ( TCHAR *pszName, TCHAR *pszValue );
	HRESULT InternalCheckAttribute ( TCHAR *pszName, BOOL fRemove );
	HRESULT InternalSetAttributeName ( TCHAR *pszName );

protected:

	VOID SetAccessType ( ILS_ATTR_TYPE AttrType ) { m_AccessType = AttrType; }

public:
	// Constructor and destructor
	//
	CAttributes ( VOID );
	~CAttributes ( VOID );

	// For internal use
	//
	ULONG GetCount ( VOID ) { return m_cAttrs; }

	ILS_ATTR_TYPE GetAccessType( void) { return m_AccessType; }
 
	HRESULT GetAttributeList ( TCHAR **ppszList, ULONG *pcList, ULONG *pcb );
	HRESULT GetAttributePairs ( TCHAR **ppszPairs, ULONG *pcList, ULONG *pcb );
	HRESULT SetAttributePairs( TCHAR *pszPairs, ULONG cPair );
	HRESULT SetAttributes ( CAttributes *pAttributes );
	HRESULT RemoveAttributes ( CAttributes *pAttributes);
    HRESULT CloneNameValueAttrib(CAttributes **ppClone);
	// IUnknown
	//
	STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
	STDMETHODIMP_(ULONG)    AddRef (void);
	STDMETHODIMP_(ULONG)    Release (void);

	// IIlsAttributes
	//

	// For ILS_ATTRTYPE_NAME_VALUE
	//
	STDMETHODIMP            SetAttribute (BSTR bstrName, BSTR bstrValue);
	STDMETHODIMP            GetAttribute (BSTR bstrName, BSTR *pbstrValue);
	STDMETHODIMP            EnumAttributes (IEnumIlsNames **ppEnumAttribute);

	// For ILS_ATTRTYPE_NAME_ONLY
	//
	STDMETHODIMP			SetAttributeName ( BSTR bstrName );

#ifdef DEBUG
	// For debugging
	//
	void                    DebugOut (void);
#endif // DEBUG
};

#endif //_ATTRIBS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\attribs.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       attribs.cpp
//  Content:    This file contains the attributes object.
//  History:
//      Wed 17-Apr-1996 11:13:54  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1995-1996
//
//****************************************************************************

#include "ulsp.h"
#include "attribs.h"

//****************************************************************************
// CAttributes::CAttributes (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//  12/05/96 -by- Chu, Lon-Chan [lonchanc]
// Added access type.
//****************************************************************************

CAttributes::
CAttributes ( VOID )
:m_cRef (0),
 m_cAttrs (0),
 m_cchNames (0),
 m_cchValues (0),
 m_AccessType (ILS_ATTRTYPE_NAME_VALUE)
{
}

//****************************************************************************
// CAttributes::~CAttributes (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CAttributes::~CAttributes (void)
{
	ASSERT (m_cRef == 0);

    LPTSTR pszAttr;
    HANDLE hEnum;

    // Free all the attributes
    //
    m_AttrList.Enumerate(&hEnum);
    while (m_AttrList.Next(&hEnum, (LPVOID *)&pszAttr) == NOERROR)
    {
        ::MemFree (pszAttr);
    }
    m_AttrList.Flush();
    return;
}

//****************************************************************************
// STDMETHODIMP
// CAttributes::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CAttributes::QueryInterface (REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (riid == IID_IIlsAttributes || riid == IID_IUnknown)
    {
        *ppv = (IIlsAttributes *) this;
    };

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        return ILS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CAttributes::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:14:17  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CAttributes::AddRef (void)
{
	DllLock ();

	MyDebugMsg ((DM_REFCOUNT, "CAttribute::AddRef: ref=%ld\r\n", m_cRef));
    ::InterlockedIncrement (&m_cRef);
    return (ULONG) m_cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CAttributes::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:14:26  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CAttributes::Release (void)
{
	DllRelease ();

	ASSERT (m_cRef > 0);

	MyDebugMsg ((DM_REFCOUNT, "CAttribute::Release: ref=%ld\r\n", m_cRef));
    if (::InterlockedDecrement (&m_cRef) == 0)
    {
        delete this;
        return 0;
    }

    return (ULONG) m_cRef;
}

//****************************************************************************
// STDMETHODIMP
// CAttributes::InternalSetAttribute (LPTSTR szName, LPTSTR szValue)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CAttributes::
InternalSetAttribute ( TCHAR *pszName, TCHAR *pszValue )
{
    ULONG cName, cValue;
    LPTSTR  *ppszAttr;
    LPTSTR pszNewAttr;
    HANDLE hEnum;
    HRESULT hr;

    // Allocate the new attribute pair
    //
    cName = lstrlen(pszName);
	cValue = (pszValue != NULL) ? lstrlen (pszValue) : 0;
    pszNewAttr = (TCHAR *) ::MemAlloc (((cName+1) + (cValue+1)) * sizeof (TCHAR));
    if (pszNewAttr == NULL)
    {
        return ILS_E_MEMORY;
    };

    // Make the new attribute pair
    //
    lstrcpy(pszNewAttr, pszName);
    lstrcpy(pszNewAttr + cName + 1, (pszValue != NULL) ? pszValue : TEXT (""));

    // Look for the attribute in the list
    //
    hr = NOERROR;
    m_AttrList.Enumerate(&hEnum);
    while(m_AttrList.NextStorage(&hEnum, (PVOID *)&ppszAttr) == NOERROR)
    {
        // Match the attribute's name
        //
        if (!lstrcmpi(*ppszAttr, pszName))
        {
            // Found the specified attribute
            //
            break;
        };
    };

    if (ppszAttr != NULL)
    {
        // Replace the old pair
        //
        m_cchValues += (cValue + 1) -
                    (lstrlen(((LPTSTR)*ppszAttr)+cName+1)+1);
        ::MemFree (*ppszAttr);
        *ppszAttr = pszNewAttr;
    }
    else
    {
        // Insert the new attribute pair
        //
        hr = m_AttrList.Insert(pszNewAttr);

        if (SUCCEEDED(hr))
        {
            // Update the name buffer count
            //
            m_cchNames += cName+1;
            m_cchValues += cValue+1;
            m_cAttrs++;
        }
        else
        {
            ::MemFree (pszNewAttr);      
        };
    };

    return hr;
}

//****************************************************************************
// HRESULT
// CAttributes::InternalSetAttributeName ( TCHAR *pszName )
//
// History:
//  12/06/96 -by- Chu, Lon-Chan [lonchanc]
// Created.
//****************************************************************************

HRESULT CAttributes::
InternalSetAttributeName ( TCHAR *pszName )
{
	// We do not check for duplicate
	//
	HRESULT hr = m_AttrList.Insert (pszName);
	if (hr == S_OK)
	{
		// Update the name buffer count
		//
		m_cchNames += lstrlen (pszName) + 1;
		m_cAttrs++;
	}

	return hr;
}

//****************************************************************************
// STDMETHODIMP
// CAttributes::InternalRemoveAttribute (LPTSTR szName)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CAttributes::
InternalCheckAttribute ( TCHAR *pszName, BOOL fRemove )
{
    LPTSTR  pszAttr;
    HANDLE  hEnum;
    HRESULT hr;

    // Look for the attribute in the list
    //
    m_AttrList.Enumerate(&hEnum);
    while(m_AttrList.Next(&hEnum, (PVOID *)&pszAttr) == NOERROR)
    {
        // Match the attribute's name
        //
        if (! lstrcmpi(pszAttr, pszName))
        {
            // Found the specified attribute
            //
            break;
        };
    };

    // If found, we are asked to remove it, do so
    //
    if (pszAttr != NULL)
    {
        if (fRemove) {
            hr = m_AttrList.Remove(pszAttr);

            if (SUCCEEDED(hr))
            {
                ULONG   cName;

                // Update the name buffer count
                //
                cName = lstrlen(pszName);
                m_cchNames -= cName+1;
                m_cchValues -= lstrlen(pszAttr+cName+1)+1;
                m_cAttrs--;

                ::MemFree (pszAttr);
           };
        }
        else {
            hr = S_OK;
        }
    }
    else
    {
        hr = S_FALSE;
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CAttributes::SetAttribute (BSTR bstrName, BSTR bstrValue)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//  12/06/96 -by- Chu, Lon-Chan [lonchanc]
// Added access type.
//****************************************************************************

STDMETHODIMP CAttributes::
SetAttribute ( BSTR bstrName, BSTR bstrValue )
{
    LPTSTR  szName;
    HRESULT hr;

	// Validate access type
	//
	if (m_AccessType != ILS_ATTRTYPE_NAME_VALUE)
		return ILS_E_ACCESS_CONTROL;

    // Validate parameters
    //
    if (bstrName == NULL)
        return ILS_E_POINTER;

    if (*bstrName == '\0')
        return ILS_E_PARAMETER;

    // Convert the name format
    //
    hr = BSTR_to_LPTSTR(&szName, bstrName);

    if (SUCCEEDED(hr))
    {
        // If bstrValue is NULL, remove the attribute
        //
        if (bstrValue == NULL)
        {
            hr = InternalCheckAttribute(szName, TRUE);
        }
        else
        {
            LPTSTR  szValue = NULL;

			if (bstrValue != NULL && *bstrValue != L'\0')
				hr = BSTR_to_LPTSTR(&szValue, bstrValue);

            if (SUCCEEDED(hr))
            {
                hr = InternalSetAttribute(szName, szValue);
                ::MemFree (szValue);
            };
        };

        // Free resources
        //
        ::MemFree (szName);
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CAttributes::GetAttribute (BSTR bstrName, BSTR *pbstrValue)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//  12/06/96 -by- Chu, Lon-Chan [lonchanc]
// Added access type.
//****************************************************************************

STDMETHODIMP CAttributes::
GetAttribute ( BSTR bstrName, BSTR *pbstrValue )
{
    LPTSTR szName;
    HRESULT hr;

	// Validate access type
	//
	if (m_AccessType != ILS_ATTRTYPE_NAME_VALUE)
		return ILS_E_ACCESS_CONTROL;

    // Validate parameters
    //
    if (pbstrValue == NULL)
        return ILS_E_POINTER;

    // Assume failure
    //
    *pbstrValue = NULL;

    // Validate more parameters
    //
    if (bstrName == NULL)
        return ILS_E_POINTER;

    if (*bstrName == '\0')
        return ILS_E_PARAMETER;

    // Convert the name format
    //
    hr = BSTR_to_LPTSTR(&szName, bstrName);

    if (SUCCEEDED(hr))
    {
        HANDLE hEnum;
        LPTSTR pszAttr;

        // Look for the attribute in the list
        //
        m_AttrList.Enumerate(&hEnum);
        while(m_AttrList.Next(&hEnum, (PVOID *)&pszAttr) == NOERROR)
        {
            // Match the attribute's name
            //
            if (!lstrcmpi(pszAttr, szName))
            {
                // Found the specified attribute
                //
                break;
            };
        };

        // If found, return the value
        //
        if (pszAttr != NULL)
        {
            hr = LPTSTR_to_BSTR(pbstrValue, pszAttr+lstrlen(pszAttr)+1);
        }
        else
        {
            hr = ILS_E_FAIL;
        };
    };

    // Free resources
    //
    ::MemFree (szName);
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CAttributes::EnumAttributes (IEnumIlsNames *pEnumAttribute)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//  12/06/96 -by- Chu, Lon-Chan [lonchanc]
// Added access type.
//****************************************************************************

STDMETHODIMP CAttributes::
EnumAttributes ( IEnumIlsNames **ppEnumAttribute )
{
    CEnumNames *pea;
    ULONG  cAttrs, cbAttrs;
    LPTSTR pszAttrs;
    HRESULT hr;

	// Validate access type
	//
	if (m_AccessType != ILS_ATTRTYPE_NAME_VALUE)
		return ILS_E_ACCESS_CONTROL;

    // Validate parameters
    //
    if (ppEnumAttribute == NULL)
        return ILS_E_POINTER;

    // Assume failure
    //
    *ppEnumAttribute = NULL;

    hr = GetAttributeList(&pszAttrs, &cAttrs, &cbAttrs);

    if (FAILED(hr))
    {
        return hr;
    };

    // Create a peer enumerator
    //
    pea = new CEnumNames;

    if (pea != NULL)
    {
        hr = pea->Init(pszAttrs, cAttrs);

        if (SUCCEEDED(hr))
        {
            // Get the enumerator interface
            //
            pea->AddRef();
            *ppEnumAttribute = pea;
        }
        else
        {
            delete pea;
        };
    }
    else
    {
        hr = ILS_E_MEMORY;
    };

    if (pszAttrs != NULL)
    {
        ::MemFree (pszAttrs);
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CAttributes::SetAttributeName (BSTR bstrName)
//
// History:
//  12/05/96 -by- Chu, Lon-Chan [lonchanc]
// Created.
//****************************************************************************

STDMETHODIMP CAttributes::
SetAttributeName ( BSTR bstrName )
{
	TCHAR *pszName;
	HRESULT hr;

	// Validate access type
	//
	if (m_AccessType != ILS_ATTRTYPE_NAME_ONLY)
		return ILS_E_ACCESS_CONTROL;

	// Validate parameters
	//
	if (bstrName == NULL)
		return ILS_E_POINTER;

	if (*bstrName == '\0')
		return ILS_E_PARAMETER;

	// Convert the name format
	//
	if (BSTR_to_LPTSTR (&pszName, bstrName) != S_OK)
		return ILS_E_MEMORY;

	// Set the attribute name
	//
	return InternalSetAttributeName (pszName);
}

//****************************************************************************
// STDMETHODIMP
// CAttributes::GetAttributeList (LPTSTR *ppszList, ULONG *pcList, ULONG *pcb)
// 	Get attribute names only.
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CAttributes::
GetAttributeList ( TCHAR **ppszList, ULONG *pcList, ULONG *pcb )
{
    LPTSTR szAttrs, pszNext, pszAttr;
    HANDLE hEnum;
#ifdef DEBUG
    ULONG cAttrsDbg = 0;
#endif // DEBUG

    // Assume no list or failure
    //
    *ppszList = NULL;
    *pcList = 0;
    *pcb = 0;

    // If no list, return nothing
    //
    if (m_cAttrs == 0)
    {
        return NOERROR;
    };

    // Allocate the buffer for the attribute list
    //
    szAttrs = (TCHAR *) ::MemAlloc ((m_cchNames+1) * sizeof (TCHAR));
    if (szAttrs == NULL)
    {
        return ILS_E_MEMORY;
    };

    // Enumerate the list
    //
    pszNext = szAttrs;
    m_AttrList.Enumerate(&hEnum);
    while(m_AttrList.Next(&hEnum, (PVOID *)&pszAttr) == NOERROR)
    {
        // Attribute name
        //
        lstrcpy(pszNext, pszAttr);
        pszNext += lstrlen(pszNext)+1;
#ifdef DEBUG
        cAttrsDbg++;
#endif // DEBUG
    };
    *pszNext = '\0';
    ASSERT(cAttrsDbg == m_cAttrs);
    
    // return the attribute list
    //
    *pcList = m_cAttrs;
    *ppszList = szAttrs;
    *pcb = (m_cchNames+1)*sizeof(TCHAR);
    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CAttributes::GetAttributePairs (LPTSTR *ppszList, ULONG *pcList, ULONG *pcb)
//	Get pairs of attribute names and values.
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CAttributes::
GetAttributePairs ( TCHAR **ppszPairs, ULONG *pcList, ULONG *pcb )
{
    LPTSTR szAttrs, pszNext, pszAttr;
    ULONG cLen;
    HANDLE hEnum;
#ifdef DEBUG
    ULONG cAttrsDbg = 0;
#endif // DEBUG

	// Validate access type
	//
	if (m_AccessType != ILS_ATTRTYPE_NAME_VALUE)
		return ILS_E_ACCESS_CONTROL;

    // Assume no list or failure
    //
    *ppszPairs = NULL;
    *pcList = 0;
    *pcb = 0;

    // If no list, return nothing
    //
    if (m_cAttrs == 0)
    {
        return NOERROR;
    };

    // Allocate the buffer for the attribute list
    //
    szAttrs = (TCHAR *) ::MemAlloc ((m_cchNames+m_cchValues+1) * sizeof (TCHAR));
    if (szAttrs == NULL)
    {
        return ILS_E_MEMORY;
    };

    // Enumerate the list
    //
    pszNext = szAttrs;
    m_AttrList.Enumerate(&hEnum);
    while(m_AttrList.Next(&hEnum, (PVOID *)&pszAttr) == NOERROR)
    {
        // Attribute name
        //
        lstrcpy(pszNext, pszAttr);
        cLen = lstrlen(pszNext)+1;
        pszNext += cLen;

        // Attribute value
        //
        lstrcpy(pszNext, pszAttr+cLen);
        pszNext += lstrlen(pszNext)+1;

#ifdef DEBUG
        cAttrsDbg++;
#endif // DEBUG
    };
    *pszNext = '\0';
    ASSERT(cAttrsDbg == m_cAttrs);
    
    // return the attribute list
    //
    *pcList = m_cAttrs;
    *ppszPairs = szAttrs;
    *pcb = (m_cchNames+m_cchValues+1)*sizeof(TCHAR);
    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CAttributes::SetAttributePairs (LPTSTR pszList, ULONG cPair)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CAttributes::
SetAttributePairs ( TCHAR *pszList, ULONG cPair )
{
    LPTSTR pszName, pszValue;
    ULONG cLen, i;
    HRESULT hr;

	// Validate access type
	//
	if (m_AccessType != ILS_ATTRTYPE_NAME_VALUE)
		return ILS_E_ACCESS_CONTROL;

    // Do nothing if nothing to set
    //
    if ((cPair == 0) ||
        (pszList == NULL))
    {
        return NOERROR;
    };

    pszName = pszList;
    for (i = 0; i < cPair; i++)
    {
        pszValue = pszName + lstrlen(pszName) + 1;
        InternalSetAttribute(pszName, pszValue);
        pszName = pszValue + lstrlen(pszValue) + 1;
    };
    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CAttributes::SetAttributes (CAttributes *pAttributes)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CAttributes::
SetAttributes ( CAttributes *pAttrsEx )
{
    LPTSTR pszNextAttr;
    HANDLE hEnum;
    HRESULT hr;

	// Validate access type
	//
	if (m_AccessType != ILS_ATTRTYPE_NAME_VALUE)
		return ILS_E_ACCESS_CONTROL;

    // Enumerate the external attribute list
    //
    pAttrsEx->m_AttrList.Enumerate(&hEnum);
    while(pAttrsEx->m_AttrList.Next(&hEnum, (PVOID *)&pszNextAttr) == NOERROR)
    {
        hr = InternalSetAttribute(pszNextAttr,
                                  pszNextAttr+lstrlen(pszNextAttr)+1);
        ASSERT(SUCCEEDED(hr));
    };
    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CAttributes::RemoveAttributes (CAttributes *pAttributes)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CAttributes::
RemoveAttributes ( CAttributes *pAttrsEx )
{
    LPTSTR pszNextAttr;
    HANDLE hEnum;

    // Enumerate the external attribute list
    //
    pAttrsEx->m_AttrList.Enumerate(&hEnum);
    while(pAttrsEx->m_AttrList.Next(&hEnum, (PVOID *)&pszNextAttr) == NOERROR)
    {
        InternalCheckAttribute(pszNextAttr, TRUE);
    };
    return NOERROR;
}

#ifdef MAYBE
HRESULT CAttributes::
SetOpsAttributes ( CAttributes *pAttrsEx, CAttributes **ppOverlap, CAttributes **ppIntersect )
{
    LPTSTR pszNextAttr;
    HANDLE hEnum;
    BOOL fFullOverlap=FALSE, fNoOverlap = TRUE;

    // Enumerate the external attribute list
    //
    pAttrsEx->m_AttrList.Enumerate(&hEnum);
    while(pAttrsEx->m_AttrList.Next(&hEnum, (PVOID *)&pszNextAttr) == NOERROR)
    {
        if (InternalCheckAttribute(pszNextAttr, FALSE)!=S_OK) {
            // didn't find this attribute
            if (ppOverlap) {
                if (!*ppOverlap) {

                    *ppOverlap = new CAttributes;
                    if (!*ppOverlap) {

                        goto bailout;

                    }

                    (*ppOverlap)->SetAccessType (ILS_ATTRTYPE_NAME_VALUE);

                }
                
            }

        }
        else {

        }
    };

bailout:

    return NOERROR;
}
#endif //MAYBE



#ifdef DEBUG
//****************************************************************************
// void
// CAttributes::DebugOut (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void
CAttributes::DebugOut (void)
{
    LPTSTR pszNextAttr;
    HANDLE hEnum;

    // The attribute pair count
    //
    DPRINTF1(TEXT("Number of attributes: %d\r\n"), m_cAttrs);

    // Each attribute pair
    //
    m_AttrList.Enumerate(&hEnum);
    while(m_AttrList.Next(&hEnum, (PVOID *)&pszNextAttr) == NOERROR)
    {
        DPRINTF2(TEXT("\t<%s> = <%s>"), pszNextAttr,
                 pszNextAttr+lstrlen(pszNextAttr)+1);
    };
    return;
}
#endif // DEBUG


//****************************************************************************
// STDMETHODIMP
// CAttributes::Clone(IIlsAttibutes **ppAttributes)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 1/22/1997  Shishir Pardikar [shishirp] Created.
//
// Notes:   this clones only attrib list which has both name and value
//
//****************************************************************************
HRESULT
CAttributes::CloneNameValueAttrib(CAttributes **ppAttributes)
{
    CAttributes *pAttributes = NULL;
    HRESULT hr;

    if (ppAttributes == NULL) {

        return (ILS_E_PARAMETER);

    }

    *ppAttributes = NULL;



    pAttributes = new CAttributes;

    if (!pAttributes) {

        return (ILS_E_MEMORY);

    }

	pAttributes->SetAccessType (m_AccessType);
    hr = pAttributes->SetAttributes(this);

    if (!SUCCEEDED(hr)) {

        delete pAttributes;
        return hr;            

    }

    *ppAttributes = pAttributes;


    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\cserver.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\callback.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       callback.cpp
//  Content:    This file contains the ULS callback routine.
//  History:
//      Wed 17-Apr-1996 11:13:54  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1995-1996
//
//****************************************************************************

#include "ulsp.h"
#include "callback.h"
#include "culs.h"
#include "localusr.h"
#include "attribs.h"
#include "localprt.h"
#include "ulsmeet.h"

//****************************************************************************
// void OnRegisterResult(UINT uMsg, ULONG uMsgID, HRESULT hResult)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void OnRegisterResult(UINT uMsg, ULONG uMsgID, HRESULT hResult)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->RequestDone(&ri)))
    {
        ASSERT(uMsg == ri.uReqType);
		CIlsUser *pUser = ReqInfo_GetUser (&ri);

        switch(uMsg)
        {
            case WM_ILS_REGISTER_CLIENT:              // lParam = hResult
                //
                // Call the appropriate object's member
                //
                ASSERT (pUser != NULL);
                if (pUser != NULL)
                	pUser->InternalRegisterNext(hResult);
                break;

            case WM_ILS_UNREGISTER_CLIENT:            // lParam = hResult
                //
                // Call the appropriate object's member
                //
                ASSERT (pUser != NULL);
                if (pUser != NULL)
                	pUser->InternalUnregisterNext(hResult);
                break;

            default:
                ASSERT(0);
                break;
        };

        // Release the objects
        //
        if (pUser != NULL)
        	pUser->Release ();
    }
    else
    {
        DPRINTF1(TEXT("OnRegisterResult: No pending request for %x"),
                 uMsgID);
        // ASSERT (0);
    };
    return;
}

//****************************************************************************
// void OnLocalRegisterResult(UINT uMsg, ULONG uReqID, HRESULT hResult)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void OnLocalRegisterResult(UINT uMsg, ULONG uReqID, HRESULT hResult)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = uReqID;
    ri.uMsgID = 0;

    if (SUCCEEDED(g_pReqMgr->RequestDone(&ri)))
    {
        ASSERT(uMsg == ri.uReqType);
		CIlsUser *pUser = ReqInfo_GetUser (&ri);

        // Call the appropriate object's member
        //
        switch(uMsg)
        {
            case WM_ILS_LOCAL_REGISTER:
            	ASSERT (pUser != NULL);
            	if (pUser != NULL)
            		pUser->RegisterResult(uReqID, hResult);
                break;

            case WM_ILS_LOCAL_UNREGISTER:
            	ASSERT (pUser != NULL);
            	if (pUser != NULL)
            		pUser->UnregisterResult(uReqID, hResult);
                break;

            default:
                ASSERT(0);
                break;
        };

        // Release the objects
        //
        if (pUser != NULL)
        	pUser->Release ();
    }
    else
    {
        DPRINTF1(TEXT("OnLocalRegisterResult: No pending request for %x"),
                 uReqID);
        // ASSERT (0);
    };
    return;
}

//****************************************************************************
// void OnSetUserInfo(UINT uMsg, ULONG uID, HRESULT hResult)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void OnSetUserInfo(UINT uMsg, ULONG uID, HRESULT hResult)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    switch (uMsg)
    {
        case WM_ILS_SET_CLIENT_INFO:
            //
            // Look for the matching Ldap Message ID
            //
            ri.uReqID = 0;       // Mark that we are looking for the message ID
            ri.uMsgID = uID;     // Not the request ID
            break;

        default:
            ASSERT(0);
            break;
    };

    if (SUCCEEDED(g_pReqMgr->RequestDone(&ri)))
    {
        ASSERT(uMsg == ri.uReqType);
		CIlsUser *pUser = ReqInfo_GetUser (&ri);

		ASSERT (pUser != NULL);
		if (pUser != NULL)
		{
	        // Call the appropriate object's member
	        //
	        pUser->UpdateResult(ri.uReqID, hResult);

	        // Release the objects
	        //
	        pUser->Release();
       	}
    }
    else
    {
        DPRINTF1(TEXT("OnSetUserInfo: No pending request for %x"),
                 uID);
        // ASSERT (0);
    };
    return;
}

//****************************************************************************
// void OnSetProtocol(UINT uMsg, ULONG uID, HRESULT hResult)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void OnSetProtocol(UINT uMsg, ULONG uID, HRESULT hResult)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    APP_CHANGE_PROT uCmd;

    switch (uMsg)
    {
        case WM_ILS_REGISTER_PROTOCOL:

            // Look for the matching request information
            //
            ri.uReqID = 0;      // Mark that we are looking for the message ID
            ri.uMsgID = uID;    // Not the request ID
            uCmd = ILS_APP_ADD_PROT;
            break;

        case WM_ILS_LOCAL_REGISTER_PROTOCOL:

            // Look for the matching request information
            //
            ri.uReqID = uID;    // Mark that we are looking for the request ID
            ri.uMsgID = 0;      // Not the message ID
            uCmd = ILS_APP_ADD_PROT;
            break;

        case WM_ILS_UNREGISTER_PROTOCOL:

            // Look for the matching request information
            //
            ri.uReqID = 0;      // Mark that we are looking for the message ID
            ri.uMsgID = uID;    // Not the request ID
            uCmd = ILS_APP_REMOVE_PROT;
            break;

        case WM_ILS_LOCAL_UNREGISTER_PROTOCOL:

            // Look for the matching request information
            //
            ri.uReqID = uID;    // Mark that we are looking for the request ID
            ri.uMsgID = 0;      // Not the message ID
            uCmd = ILS_APP_REMOVE_PROT;
            break;

        default:
            ASSERT(0);
            break;
    };

    if (SUCCEEDED(g_pReqMgr->RequestDone(&ri)))
    {
        ASSERT(uMsg == ri.uReqType);
		CIlsUser *pUser = ReqInfo_GetUser (&ri);
		CLocalProt *pProtocol = ReqInfo_GetProtocol (&ri);

        // Check the request parameter
        //
        if (pProtocol == NULL)
        {
            switch(uMsg)
            {
                case WM_ILS_REGISTER_PROTOCOL:

                    // Call the appropriate object's member
                    //
                    ASSERT (pUser != NULL);
                    if (pUser != NULL)
                    	pUser->InternalRegisterNext(hResult);
                    break;

                case WM_ILS_UNREGISTER_PROTOCOL:

                    // Call the appropriate object's member
                    //
                    ASSERT (pUser != NULL);
                    if (pUser != NULL)
                    	pUser->InternalUnregisterNext(hResult);
                    break;

                default:
                    // Must be a response from server
                    //
                    ASSERT(0);
                    break;
            };

            // Release the objects
            //
            if (pUser != NULL)
            	pUser->Release();
        }
        else
        {
        	ASSERT (pUser != NULL && pProtocol != NULL);
            if (pUser != NULL && pProtocol != NULL)
            {
	            // Call the appropriate object's member
	            //
            	pUser->ProtocolChangeResult(pProtocol,
                                            ri.uReqID, hResult,
                                            uCmd);
	            // Release the objects
	            //
	            pUser->Release();
	            pProtocol->Release();
            }
        };
    }
    else
    {
        DPRINTF1(TEXT("OnSetProtocol: No pending request for %x"),
                 uID);
        // ASSERT (0);
    };
    return;
}

//****************************************************************************
// void OnEnumUserNamesResult(ULONG uMsgID, PLDAP_ENUM ple)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void OnEnumUserNamesResult(ULONG uMsgID, PLDAP_ENUM ple)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->GetRequestInfo(&ri)))
    {
        ASSERT(WM_ILS_ENUM_CLIENTS == ri.uReqType);
		CIlsMain *pMain = ReqInfo_GetMain (&ri);

        // Call the appropriate object's member
        //
        ASSERT (pMain != NULL);
        if (pMain != NULL)
        {
        	pMain->EnumUserNamesResult(ri.uReqID, ple);
        }

        // If the enumeration was terminated, remove the pending request
        //
        if ((ple == NULL) ||
            (ple->hResult != NOERROR))
        {
            ri.uReqID = 0;
            ri.uMsgID = uMsgID;
            g_pReqMgr->RequestDone(&ri);

            // Release the objects
            //
    	    if (pMain != NULL)
    	    	pMain->Release();
        };
    }
    else
    {
        DPRINTF1(TEXT("OnEnumUserNamesResult: No pending request for %x"),
                 uMsgID);
        // ASSERT (0);
    };

    // Free the information buffer
    //
    if (ple != NULL)
    {
        ::MemFree (ple);
    };
    return;
}

//****************************************************************************
// void OnEnumMeetingNamesResult(ULONG uMsgID, PLDAP_ENUM ple)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
void OnEnumMeetingNamesResult(ULONG uMsgID, PLDAP_ENUM ple)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->GetRequestInfo(&ri)))
    {
        ASSERT(WM_ILS_ENUM_MEETINGS == ri.uReqType);
		CIlsMain *pMain = ReqInfo_GetMain (&ri);
		ASSERT (pMain != NULL);
		if (pMain != NULL)
		{
	        // Call the appropriate object's member
	        //
			pMain->EnumMeetingPlaceNamesResult(ri.uReqID, ple);
		}

        // If the enumeration was terminated, remove the pending request
        //
        if ((ple == NULL) ||
            (ple->hResult != NOERROR))
        {
            ri.uReqID = 0;
            ri.uMsgID = uMsgID;
            g_pReqMgr->RequestDone(&ri);

            // Release the objects
            //
			if (pMain != NULL)
            	pMain->Release();
        };
    }
    else
    {
        DPRINTF1(TEXT("OnEnumMeetingNamesResult: No pending request for %x"),
                 uMsgID);
        // ASSERT (0);
    };

    // Free the information buffer
    //
    if (ple != NULL)
    {
        ::MemFree (ple);
    };
    return;
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// void OnResolveUserResult(ULONG uMsgID, PLDAP_CLIENTINFO_RES puir)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void OnResolveUserResult(ULONG uMsgID, PLDAP_CLIENTINFO_RES puir)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->RequestDone(&ri)))
    {
        ASSERT(WM_ILS_RESOLVE_CLIENT == ri.uReqType);
		CIlsServer *pServer = ReqInfo_GetServer (&ri);
		CIlsMain *pMain = ReqInfo_GetMain (&ri);

        ASSERT (pMain != NULL && pServer != NULL);
        if (pMain != NULL && pServer != NULL)
        {
	        // Call the appropriate object's member
    	    //
        	pMain->GetUserResult(ri.uReqID, puir, pServer);

	        // Release the objects
	        //
	        pMain->Release();
			pServer->Release ();
		}
    }
    else
    {
        DPRINTF1(TEXT("OnResolveUserResult: No pending request for %x"),
                 uMsgID);
        // ASSERT (0);
    };

    // Free the information buffer
    //
    ::MemFree (puir);
    return;
}

//****************************************************************************
// void OnEnumUsersResult(ULONG uMsgID, PLDAP_ENUM ple)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void OnEnumUsersResult(ULONG uMsgID, PLDAP_ENUM ple)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->GetRequestInfo(&ri)))
    {
        ASSERT(WM_ILS_ENUM_CLIENTINFOS == ri.uReqType);

        // Call the appropriate object's member
        //
        CIlsServer *pServer = ReqInfo_GetServer (&ri);
		CIlsMain *pMain = ReqInfo_GetMain (&ri);

		ASSERT (pServer != NULL && pMain != NULL);
		if (pServer != NULL && pMain != NULL)
			pMain->EnumUsersResult(ri.uReqID, ple, pServer);

        // If the enumeration was terminated, remove the pending request
        //
        if ((ple == NULL) ||
            (ple->hResult != NOERROR))
        {
            ri.uReqID = 0;
            ri.uMsgID = uMsgID;
            g_pReqMgr->RequestDone(&ri);

            // Release the objects
            //
            if (pMain != NULL)
            	pMain->Release();

            if (pServer != NULL)
            	pServer->Release ();
        };
    }
    else
    {
        DPRINTF1(TEXT("EnumUsersResult: No pending request for %x"),
                 uMsgID);
        // ASSERT (0);
    };

    // Free the information buffer
    //
    if (ple != NULL)
    {
        ::MemFree (ple);
    };
    return;
}

//****************************************************************************
// void OnEnumMeetingsResult(ULONG uMsgID, PLDAP_ENUM ple)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
void OnEnumMeetingsResult(ULONG uMsgID, PLDAP_ENUM ple)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->GetRequestInfo(&ri)))
    {
        ASSERT(WM_ILS_ENUM_MEETINGINFOS == ri.uReqType);

        // Call the appropriate object's member
        //
        CIlsServer *pServer = ReqInfo_GetServer (&ri);
        CIlsMain *pMain = ReqInfo_GetMain (&ri);
        ASSERT (pServer != NULL && pMain != NULL);
        if (pServer != NULL && pMain != NULL)
        {
        	pMain->EnumMeetingPlacesResult(ri.uReqID, ple, pServer);
        }

        // If the enumeration was terminated, remove the pending request
        //
        if ((ple == NULL) ||
            (ple->hResult != NOERROR))
        {
            ri.uReqID = 0;
            ri.uMsgID = uMsgID;
            g_pReqMgr->RequestDone(&ri);

            // Release the objects
            //
            if (pMain != NULL)
            	pMain->Release ();

            if (pServer != NULL)
            	pServer->Release ();
        };
    }
    else
    {
        DPRINTF1(TEXT("EnumMeetingsResult: No pending request for %x"),
                 uMsgID);
        // ASSERT (0);
    };

    // Free the information buffer
    //
    if (ple != NULL)
    {
        ::MemFree (ple);
    };
    return;
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// void OnEnumProtocolsResult(ULONG uMsgID, PLDAP_ENUM ple)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void OnEnumProtocolsResult(ULONG uMsgID, PLDAP_ENUM ple)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->RequestDone(&ri)))
    {
        ASSERT(WM_ILS_ENUM_PROTOCOLS == ri.uReqType);
		CIlsUser *pUser = ReqInfo_GetUser (&ri);
		ASSERT (pUser != NULL);
		if (pUser != NULL)
		{
	        // Call the appropriate object's member
    	    //
        	pUser->EnumProtocolsResult(ri.uReqID, ple);

	        // Release the objects
        	//
    	    pUser->Release();
    	}
    }
    else
    {
        DPRINTF1(TEXT("EnumProtocolsResult: No pending request for %x"),
                 uMsgID);
        // ASSERT (0);
    };

    // Free the information buffer
    //
    ::MemFree (ple);
    return;
}

//****************************************************************************
// void OnResolveProtocolResult(ULONG uMsgID, PLDAP_PROTINFO_RES ppir)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void OnResolveProtocolResult(ULONG uMsgID, PLDAP_PROTINFO_RES ppir)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->RequestDone(&ri)))
    {
        ASSERT(WM_ILS_RESOLVE_PROTOCOL == ri.uReqType);
		CIlsUser *pUser = ReqInfo_GetUser (&ri);
		ASSERT (pUser != NULL);
		if (pUser != NULL)
		{
        	// Call the appropriate object's member
        	//
        	pUser->GetProtocolResult(ri.uReqID, ppir);

	        // Release the objects
	        //
			pUser->Release();
		}
    }
    else
    {
        DPRINTF1(TEXT("OnResolveProtocolResult: No pending request for %x"),
                 uMsgID);
        // ASSERT (0);
    };

    // Free the information buffer
    //
    ::MemFree (ppir);
    return;
}

//****************************************************************************
// VOID OnClientNeedRelogon ( BOOL fPrimary, VOID *pUnk)
//
// History:
//  Thur 07-Nov-1996 12:50:00  -by-  Chu, Lon-Chan [lonchanc]
// Created.
//****************************************************************************

VOID OnClientNeedRelogon ( BOOL fPrimary, VOID *pUnk)
{
	ASSERT (pUnk != NULL);

    ((CIlsUser *)pUnk)->StateChanged (WM_ILS_CLIENT_NEED_RELOGON, fPrimary);
}

//****************************************************************************
// VOID OnClientNetworkDown ( BOOL fPrimary, VOID *pUnk)
//
// History:
//  Thur 07-Nov-1996 12:50:00  -by-  Chu, Lon-Chan [lonchanc]
// Created.
//****************************************************************************

VOID OnClientNetworkDown ( BOOL fPrimary, VOID *pUnk)
{
	ASSERT (pUnk != NULL);

    ((CIlsUser *)pUnk)->StateChanged (WM_ILS_CLIENT_NETWORK_DOWN, fPrimary);
}


//****************************************************************************
// void OnResolveUserResult(ULONG uMsgID, PLDAP_CLIENTINFO_RES puir)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
void OnResolveMeetingPlaceResult (ULONG uMsgID, PLDAP_MEETINFO_RES pmir)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->RequestDone(&ri)))
    {
        ASSERT(WM_ILS_RESOLVE_MEETING == ri.uReqType);

        CIlsServer *pServer = ReqInfo_GetServer (&ri);
        CIlsMain *pMain = ReqInfo_GetMain (&ri);
        ASSERT (pMain != NULL && pServer != NULL);
        if (pMain != NULL && pServer != NULL)
        {
	        // Call the appropriate object's member
    	    //
        	pMain->GetMeetingPlaceResult(ri.uReqID, pmir, pIlsServer);

        	// Release the objects
        	//
			pServer->Release ();
	        pMain->Release();
		}
    }
    else
    {
        DPRINTF1(TEXT("OnResolveMeetingPlaceResult: No pending request for %x"),
                 uMsgID);
        // ASSERT (0);
    };

    // Free the information buffer
    //
    ::MemFree (pmir);
    return;
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// Routine:  OnEnumMeetingPlacesResult(ULONG uMsgID, PLDAP_ENUM ple)
//
// Synopsis:
//
// Arguments:
//
// Returns: void
//
// History: 11/27/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
void OnEnumMeetingPlacesResult(ULONG uMsgID, PLDAP_ENUM ple)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->GetRequestInfo(&ri)))
    {
        ASSERT(WM_ILS_ENUM_MEETINGINFOS == ri.uReqType);
		CIlsServer *pServer = ReqInfo_GetServer (&ri);
		CIlsMain *pMain = ReqInfo_GetMain (&ri);

		ASSERT (pServer != NULL && pMain != NULL);
		if (pServer != NULL && pMain != NULL)
		{
	        // Call the appropriate object's member
	        //
	        pMain->EnumMeetingPlacesResult(ri.uReqID, ple, pServer);
		}

        // If the enumeration was terminated, remove the pending request
        //
        if ((ple == NULL) ||
            (ple->hResult != NOERROR))
        {
            ri.uReqID = 0;
            ri.uMsgID = uMsgID;
            g_pReqMgr->RequestDone(&ri);

            // Release the objects
            //
            if (pMain != NULL)
            	pMain->Release();

            if (pServer != NULL)
            	pServer->Release ();
        };
    }
    else
    {
        DPRINTF1(TEXT("EnumMeetingsResult: No pending request for %x"),
                 uMsgID);
        // ASSERT (0);
    };

    // Free the information buffer
    //
    if (ple != NULL)
    {
        ::MemFree (ple);
    };
    return;
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// Routine:  OnEnumMeetingPlaceNamesResult(ULONG uMsgID, PLDAP_ENUM ple)
//
// Synopsis:
//
// Arguments:
//
// Returns: void
//
// History: 11/27/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
void OnEnumMeetingPlaceNamesResult(ULONG uMsgID, PLDAP_ENUM ple)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->GetRequestInfo(&ri)))
    {
        ASSERT(WM_ILS_ENUM_MEETINGS == ri.uReqType);

        // Call the appropriate object's member
        //
		CIlsMain *pMain = ReqInfo_GetMain (&ri);
		ASSERT (pMain != NULL);
		if (pMain != NULL)
		{
			pMain->EnumMeetingPlaceNamesResult(ri.uReqID, ple);
		}

        // If the enumeration was terminated, remove the pending request
        //
        if ((ple == NULL) ||
            (ple->hResult != NOERROR))
        {
            ri.uReqID = 0;
            ri.uMsgID = uMsgID;
            g_pReqMgr->RequestDone(&ri);

            // Release the objects
            //
            if (pMain != NULL)
            	pMain->Release();
        };
    }
    else
    {
        DPRINTF1(TEXT("OnEnumMeetingPlaceNamesResult: No pending request for %x"),
                 uMsgID);
        // ASSERT (0);
    };

    // Free the information buffer
    //
    if (ple != NULL)
    {
        ::MemFree (ple);
    };
    return;
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// Routine:  OnRegisterMeetingPlaceResult(ULONG uMsgID, HRESULT hr)
//
// Synopsis:
//
// Arguments:
//
// Returns: void
//
// History: 11/27/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
VOID OnRegisterMeetingPlaceResult(ULONG uMsgID, HRESULT hr)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->GetRequestInfo(&ri)))
    {
        ASSERT(WM_ILS_REGISTER_MEETING == ri.uReqType);
        CIlsMeetingPlace *pMeeting = ReqInfo_GetMeeting (&ri);
        ASSERT (pMeeting != NULL);
        if (pMeeting != NULL)
        	pMeeting->RegisterResult(ri.uReqID, hr);

        ri.uReqID = 0;
        ri.uMsgID = uMsgID;
        g_pReqMgr->RequestDone(&ri);

        // Release the objects
        //
        if (pMeeting != NULL)
        	pMeeting->Release();
    }
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// Routine:  OnUnregisterMeetingPlaceResult(ULONG uMsgID, HRESULT hr)
//
// Synopsis:
//
// Arguments:
//
// Returns: void
//
// History: 11/27/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
VOID OnUnregisterMeetingPlaceResult(ULONG uMsgID, HRESULT hr)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->GetRequestInfo(&ri)))
    {
        ASSERT(WM_ILS_UNREGISTER_MEETING == ri.uReqType);
        CIlsMeetingPlace *pMeeting = ReqInfo_GetMeeting (&ri);
        ASSERT (pMeeting != NULL);
        if (pMeeting != NULL)
        	pMeeting->UnregisterResult(ri.uReqID, hr);

        ri.uReqID = 0;
        ri.uMsgID = uMsgID;
        g_pReqMgr->RequestDone(&ri);

        // Release the objects
        //
        if (pMeeting != NULL)
        	pMeeting->Release();
    }
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// Routine:  OnUpdateMeetingResult(ULONG uMsgID, HRESULT hr)
//
// Synopsis:
//
// Arguments:
//
// Returns: void
//
// History: 11/27/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
VOID OnUpdateMeetingResult(ULONG uMsgID, HRESULT hr)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->GetRequestInfo(&ri)))
    {
        ASSERT(WM_ILS_SET_MEETING_INFO == ri.uReqType);
        CIlsMeetingPlace *pMeeting = ReqInfo_GetMeeting (&ri);
        ASSERT (pMeeting != NULL);
        if (pMeeting != NULL)
        	pMeeting->UpdateResult(ri.uReqID, hr);

        ri.uReqID = 0;
        ri.uMsgID = uMsgID;
        g_pReqMgr->RequestDone(&ri);

        // Release the objects
        //
        if (pMeeting != NULL)
        	pMeeting->Release();
    }
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// Routine:  OnAddAttendeeResult(ULONG uMsgID, HRESULT hr)
//
// Synopsis:
//
// Arguments:
//
// Returns: void
//
// History: 11/27/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
VOID OnAddAttendeeResult(ULONG uMsgID, HRESULT hr)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->GetRequestInfo(&ri)))
    {
        ASSERT(WM_ILS_ADD_ATTENDEE == ri.uReqType);
        CIlsMeetingPlace *pMeeting = ReqInfo_GetMeeting (&ri);
        ASSERT (pMeeting != NULL);
        if (pMeeting != NULL)
			pMeeting->AddAttendeeResult(ri.uReqID, hr);

        ri.uReqID = 0;
        ri.uMsgID = uMsgID;
        g_pReqMgr->RequestDone(&ri);

        // Release the objects
        //
        if (pMeeting != NULL)
        	pMeeting->Release();
    }
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// Routine:  OnRemoveAttendeeResult(ULONG uMsgID, HRESULT hr)
//
// Synopsis:
//
// Arguments:
//
// Returns: void
//
// History: 11/27/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
VOID OnRemoveAttendeeResult(ULONG uMsgID, HRESULT hr)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->GetRequestInfo(&ri)))
    {
        ASSERT(WM_ILS_REMOVE_ATTENDEE == ri.uReqType);
        CIlsMeetingPlace *pMeeting = ReqInfo_GetMeeting (&ri);
        ASSERT (pMeeting != NULL);
        if (pMeeting != NULL)
			pMeeting->RemoveAttendeeResult(ri.uReqID, hr);

        ri.uReqID = 0;
        ri.uMsgID = uMsgID;
        g_pReqMgr->RequestDone(&ri);

        // Release the objects
        //
        if (pMeeting != NULL)
        	pMeeting->Release();
    }
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// Routine:  OnEnumAttendeesResult(ULONG uMsgID, PLDAP_ENUM ple)
//
// Synopsis:
//
// Arguments:
//
// Returns: void
//
// History: 11/27/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
VOID OnEnumAttendeesResult(ULONG uMsgID, PLDAP_ENUM ple)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->GetRequestInfo(&ri)))
    {
        ASSERT(WM_ILS_ENUM_ATTENDEES == ri.uReqType);

        // Call the appropriate object's member
        //
        CIlsMeetingPlace *pMeeting = ReqInfo_GetMeeting (&ri);
        ASSERT (pMeeting != NULL);
        if (pMeeting != NULL)
			pMeeting->EnumAttendeeNamesResult(ri.uReqID, ple);

        // If the enumeration was terminated, remove the pending request
        //
        if ((ple == NULL) ||
            (ple->hResult != NOERROR))
        {
            ri.uReqID = 0;
            ri.uMsgID = uMsgID;
            g_pReqMgr->RequestDone(&ri);

            // Release the objects
            //
	        if (pMeeting != NULL)
    	    	pMeeting->Release();
        };
    }
    else
    {
        DPRINTF1(TEXT("OnEnumUserNamesResult: No pending request for %x"),
                 uMsgID);
        // ASSERT (0);
    };

    // Free the information buffer
    //
    if (ple != NULL)
    {
        ::MemFree (ple);
    };
}
#endif // ENABLE_MEETING_PLACE


//****************************************************************************
// long CALLBACK ULSNotifyProc(HWND hwnd, UINT message, WPARAM wParam,
//                             LPARAM lParam)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

LRESULT CALLBACK ULSNotifyProc(HWND hwnd, UINT message, WPARAM wParam,
                            LPARAM lParam)
{
    switch (message)
    {
#ifdef ENABLE_MEETING_PLACE
        case WM_ILS_REGISTER_MEETING:
            ::OnRegisterMeetingPlaceResult(wParam, lParam);
            break;

        case WM_ILS_UNREGISTER_MEETING:
            ::OnUnregisterMeetingPlaceResult(wParam, lParam);
            break;

        case WM_ILS_SET_MEETING_INFO:
            ::OnUpdateMeetingResult(wParam, lParam);
            break;

        case WM_ILS_ADD_ATTENDEE:
            ::OnAddAttendeeResult(wParam, lParam);
            break;

        case WM_ILS_REMOVE_ATTENDEE:
            ::OnRemoveAttendeeResult(wParam, lParam);
            break;

        case WM_ILS_RESOLVE_MEETING:
			::OnResolveMeetingPlaceResult (wParam, (PLDAP_MEETINFO_RES) lParam);

        case WM_ILS_ENUM_MEETINGINFOS:
            ::OnEnumMeetingPlacesResult(wParam, (PLDAP_ENUM)lParam);
            break;

        case WM_ILS_ENUM_MEETINGS:
            ::OnEnumMeetingPlaceNamesResult(wParam, (PLDAP_ENUM)lParam);
            break;

        case WM_ILS_ENUM_ATTENDEES:
            ::OnEnumAttendeesResult(wParam, (PLDAP_ENUM)lParam);
            break;
#endif // ENABLE_MEETING_PLACE

        case WM_ILS_REGISTER_CLIENT:              // lParam = hResult
        case WM_ILS_UNREGISTER_CLIENT:            // lParam = hResult
            ::OnRegisterResult(message, (ULONG)wParam, (HRESULT)lParam);
            break;

        case WM_ILS_SET_CLIENT_INFO:              // lParam = hResult
            ::OnSetUserInfo (message, (ULONG)wParam, (HRESULT)lParam);
            break;


        case WM_ILS_REGISTER_PROTOCOL:          // lParam = hResult
        case WM_ILS_UNREGISTER_PROTOCOL:  // lParam = hResult
            ::OnSetProtocol (message, (ULONG)wParam, (HRESULT)lParam);
            break;

        case WM_ILS_LOCAL_REGISTER:             // lParam = hResult
        case WM_ILS_LOCAL_UNREGISTER:           // lParam = hResult
            ::OnLocalRegisterResult(message, (ULONG)wParam, (HRESULT)lParam);
            break;

        case WM_ILS_ENUM_CLIENTS:                 // lParam = PLDAP_ENUM
            ::OnEnumUserNamesResult((ULONG)wParam, (PLDAP_ENUM)lParam);
            break;

        case WM_ILS_RESOLVE_CLIENT:               // lParam = PLDAP_CLIENTINFO_RES
            ::OnResolveUserResult((ULONG)wParam, (PLDAP_CLIENTINFO_RES)lParam);
            break;

        case WM_ILS_ENUM_CLIENTINFOS:             // lParam = PLDAP_ENUM
            ::OnEnumUsersResult((ULONG)wParam, (PLDAP_ENUM)lParam);
            break;

        case WM_ILS_ENUM_PROTOCOLS:             // lParam = PLDAP_ENUM
            ::OnEnumProtocolsResult((ULONG)wParam, (PLDAP_ENUM)lParam);
            break;

        case WM_ILS_RESOLVE_PROTOCOL:           // lParam = PLDAP_PROTINFO_RES
            ::OnResolveProtocolResult((ULONG)wParam, (PLDAP_PROTINFO_RES)lParam);
            break;

		case WM_ILS_CLIENT_NEED_RELOGON:				// wParam=fPrimary, lParam=Object Pointer
			::OnClientNeedRelogon ((BOOL) wParam, (VOID *) lParam);
			break;

		case WM_ILS_CLIENT_NETWORK_DOWN:				// wParam=fPrimary, lParam=Object
			::OnClientNetworkDown ((BOOL) wParam, (VOID *) lParam);
			break;

       default:
            return DefWindowProc(hwnd, message, wParam, lParam);
    }

    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\classfac.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       classfac.cpp
//  Content:    This file contains the class factory object.
//  History:
//      Tue 08-Oct-1996 08:56:46  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#include "ulsp.h"
#include "culs.h"

//****************************************************************************
// Initialize GUIDs (should be done only and at-least once per DLL/EXE)
//****************************************************************************

#define INITGUID
#include <initguid.h>
#include <ilsguid.h>
#include "classfac.h"

//****************************************************************************
// Global Parameters
//****************************************************************************
//
CClassFactory*  g_pClassFactory = NULL;

//****************************************************************************
// CClassFactory::CClassFactory (void)
//
// History:
//  Tue 08-Oct-1996 09:00:10  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CClassFactory::
CClassFactory (void)
{
    cRef = 0;
    return;
}

//****************************************************************************
// STDMETHODIMP
// CClassFactory::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Tue 08-Oct-1996 09:00:18  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CClassFactory::QueryInterface (REFIID riid, void **ppv)
{
    if (riid == IID_IClassFactory || riid == IID_IUnknown)
    {
        *ppv = (IClassFactory *) this;
        AddRef();
        return S_OK;
    }

    *ppv = NULL;
    return ILS_E_NO_INTERFACE;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CClassFactory::AddRef (void)
//
// History:
//  Tue 08-Oct-1996 09:00:26  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CClassFactory::AddRef (void)
{
    DllLock();

	ASSERT (this == g_pClassFactory);

	MyDebugMsg ((DM_REFCOUNT, "CClassFactory::AddRef: ref=%ld\r\n", cRef));
    ::InterlockedIncrement ((LONG *) &cRef);
    return cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CClassFactory::Release (void)
//
// History:
//  Tue 08-Oct-1996 09:00:33  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CClassFactory::Release (void)
{
    DllRelease();

	ASSERT (this == g_pClassFactory);
	ASSERT (cRef > 0);

	MyDebugMsg ((DM_REFCOUNT, "CClassFactory::Release: ref=%ld\r\n", cRef));
    if (::InterlockedDecrement ((LONG *) &cRef) == 0)
    {
        delete this;
	    g_pClassFactory = NULL;
    };

    return cRef;
}

//****************************************************************************
// STDMETHODIMP
// CClassFactory::CreateInstance (LPUNKNOWN punkOuter, REFIID riid, void **ppv)
//
// History:
//  Tue 08-Oct-1996 09:00:40  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CClassFactory::CreateInstance (LPUNKNOWN punkOuter, REFIID riid, void **ppv)
{
    CIlsMain *pcu;
    HRESULT     hr;

    if (ppv == NULL)
    {
        return ILS_E_POINTER;
    };

    *ppv = NULL;

    if (punkOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION;
    };

    // Allow only on instance of the ULS object
    //
    if (g_pCIls != NULL)
    {
        return ILS_E_FAIL;
    };

    pcu = new CIlsMain;

    if (pcu != NULL)
    {
        hr = pcu->Init();

        if (SUCCEEDED(hr))
        {
            *ppv = (IIlsMain *)pcu;
            pcu->AddRef();
        }
        else
        {
            delete pcu;
        };
    }
    else
    {
        hr = ILS_E_MEMORY;
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CClassFactory::LockServer (BOOL fLock)
//
// History:
//  Tue 08-Oct-1996 09:00:48  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CClassFactory::LockServer (BOOL fLock)
{
    if (fLock)
    {
        DllLock();
		MyDebugMsg ((DM_REFCOUNT, "CClassFactory::LockServer\r\n"));
    }
    else
    {
        DllRelease();
		MyDebugMsg ((DM_REFCOUNT, "CClassFactory::UNLockServer\r\n"));
    };
    return S_OK;
}

//****************************************************************************
// STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
//
// History:
//  Tue 08-Oct-1996 09:00:55  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    if (riid == IID_IClassFactory || riid == IID_IUnknown)
    {
        // Check the requested class
        //
        if (rclsid == CLSID_InternetLocationServices)
        {
        	if (g_pClassFactory == NULL)
        	{
			    g_pClassFactory = new CClassFactory;
			}
			ASSERT (g_pClassFactory != NULL);

            if ((*ppv = (void *) g_pClassFactory) != NULL)
            {
				g_pClassFactory->AddRef ();
                return NOERROR;
            }
            else
            {
                return E_OUTOFMEMORY;
            }
        };
    }

    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\callback.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       callback.h
//  Content:    This file contains the local asynchronous response
//              definition.
//  History:
//      Wed 17-Apr-1996 11:18:47  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#ifndef _CALLBACK_H_
#define _CALLBACK_H_

#define WM_ILS_LOCAL_ASYNC_RES              (WM_ILS_ASYNC_RES+0x1000)
#define WM_ILS_LOCAL_USER_INFO_CHANGED      (WM_ILS_LOCAL_ASYNC_RES+0) // 0       0
#define WM_ILS_LOCAL_SET_USER_INFO          (WM_ILS_LOCAL_ASYNC_RES+1) // uReqID  hResult
#define WM_ILS_LOCAL_REGISTER_PROTOCOL      (WM_ILS_LOCAL_ASYNC_RES+6) // uMsgID  hResult
#define WM_ILS_LOCAL_UNREGISTER_PROTOCOL    (WM_ILS_LOCAL_ASYNC_RES+7) // uMsgID  hResult
#define WM_ILS_LOCAL_REGISTER               (WM_ILS_LOCAL_ASYNC_RES+8) // uMsgID  hResult
#define WM_ILS_LOCAL_UNREGISTER             (WM_ILS_LOCAL_ASYNC_RES+9) // uMsgID  hResult

//****************************************************************************
// Private type definition
//****************************************************************************
//
typedef struct tagSimpleResultInfo {
    ULONG   uReqID;
    HRESULT hResult;
}   SRINFO, *PSRINFO;

typedef struct tagObjectResultInfo {
    ULONG   uReqID;
    HRESULT hResult;
    PVOID   pv;
}   OBJRINFO, *POBJRINFO;

typedef struct tagEnumResultInfo {
    ULONG   uReqID;
    HRESULT hResult;
    ULONG   cItems;
    PVOID   pv;
}   ENUMRINFO, *PENUMRINFO;

#endif //_CALLBACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\classfac.h ===
#ifndef _CLASSFAC_H_
#define _CLASSFAC_H_

//****************************************************************************
// CClassFactory definition
//****************************************************************************
//
class CClassFactory : public IClassFactory
{
private:
    ULONG cRef;

public:
    // Constructor
    CClassFactory(void);

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IClassFactory
    STDMETHODIMP            CreateInstance (LPUNKNOWN punkOuter, REFIID iid, void **ppv);
    STDMETHODIMP            LockServer (BOOL fLock);
};

extern CClassFactory*  g_pClassFactory;

#endif // ! _CLASSFAC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\connpt.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       connpt.cpp
//  Content:    This file contains the conection point object.
//  History:
//      Wed 17-Apr-1996 11:13:54  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1995-1996
//
//****************************************************************************

#include "ulsp.h"
#include "connpt.h"

//****************************************************************************
// CEnumConnectionPoints::CEnumConnectionPoints (void)
//
// History:
//  Wed 17-Apr-1996 11:15:18  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CEnumConnectionPoints::CEnumConnectionPoints (void)
{
    cRef = 0;
    iIndex = 0;
    pcnp = NULL;
    return;
}

//****************************************************************************
// CEnumConnectionPoints::~CEnumConnectionPoints (void)
//
// History:
//  Wed 17-Apr-1996 11:15:18  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CEnumConnectionPoints::~CEnumConnectionPoints (void)
{
    if (pcnp != NULL)
    {
        pcnp->Release();
    };
    return;
}

//****************************************************************************
// STDMETHODIMP
// CEnumConnectionPoints::Init (IConnectionPoint *pcnpInit)
//
// History:
//  Wed 17-Apr-1996 11:15:25  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumConnectionPoints::Init (IConnectionPoint *pcnpInit)
{
    iIndex = 0;
    pcnp = pcnpInit;

    if (pcnp != NULL)
    {
        pcnp->AddRef();
    };
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CEnumConnectionPoints::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:15:31  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumConnectionPoints::QueryInterface (REFIID riid, void **ppv)
{
    if (riid == IID_IEnumConnectionPoints || riid == IID_IUnknown)
    {
        *ppv = (IEnumConnectionPoints *) this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return ILS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumConnectionPoints::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:15:37  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumConnectionPoints::AddRef (void)
{
    DllLock();

	MyDebugMsg ((DM_REFCOUNT, "CEnumConnectionPoints::AddRef: ref=%ld\r\n", cRef));
    ::InterlockedIncrement ((LONG *) &cRef);
    return cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumConnectionPoints::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:15:43  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumConnectionPoints::Release (void)
{
    DllRelease();

	ASSERT (cRef > 0);

	MyDebugMsg ((DM_REFCOUNT, "CEnumConnectionPoints::Release: ref=%ld\r\n", cRef));
	if (::InterlockedDecrement ((LONG *) &cRef) == 0)
    {
        delete this;
        return 0;
    }
    return cRef;
}

//****************************************************************************
// STDMETHODIMP 
// CEnumConnectionPoints::Next (ULONG cConnections,
//                              IConnectionPoint **rgpcn,
//                              ULONG *pcFetched)
//
// History:
//  Wed 17-Apr-1996 11:15:49  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP 
CEnumConnectionPoints::Next (ULONG cConnections,
                             IConnectionPoint **rgpcn,
                             ULONG *pcFetched)
{
    ULONG   cCopied;

    // Validate the pointer
    //
    if (rgpcn == NULL)
        return ILS_E_POINTER;

    // Validate the parameters
    //
    if ((cConnections == 0) ||
        ((cConnections > 1) && (pcFetched == NULL)))
        return ILS_E_PARAMETER;

    // Check the enumeration index
    //
    cCopied = 0;
    if ((pcnp != NULL) && (iIndex == 0))
    {
        // Return the only connection point
        //
        *rgpcn = pcnp;
        (*rgpcn)->AddRef();
        iIndex++;
        cCopied++;    
    };

    // Determine the returned information based on other parameters
    //
    if (pcFetched != NULL)
    {
        *pcFetched = cCopied;
    };
    return (cConnections == cCopied ? S_OK : S_FALSE);
}

//****************************************************************************
// STDMETHODIMP
// CEnumConnectionPoints::Skip (ULONG cConnections)
//
// History:
//  Wed 17-Apr-1996 11:15:56  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumConnectionPoints::Skip (ULONG cConnections)
{
    // Validate the parameters
    //
    if (cConnections == 0) 
        return ILS_E_PARAMETER;

    // Check the enumeration index limit
    //
    if ((pcnp == NULL) || (iIndex > 0))
    {
        return S_FALSE;
    }
    else
    {
        // Skip the only elelment
        //
        iIndex++;
        return (cConnections == 1 ? S_OK : S_FALSE);
    };
}

//****************************************************************************
// STDMETHODIMP
// CEnumConnectionPoints::Reset (void)
//
// History:
//  Wed 17-Apr-1996 11:16:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumConnectionPoints::Reset (void)
{
    iIndex = 0;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CEnumConnectionPoints::Clone(IEnumConnectionPoints **ppEnum)
//
// History:
//  Wed 17-Apr-1996 11:16:11  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumConnectionPoints::Clone(IEnumConnectionPoints **ppEnum)
{
    CEnumConnectionPoints *pecp;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return ILS_E_POINTER;
    };

    *ppEnum = NULL;

    // Create an enumerator
    //
    pecp = new CEnumConnectionPoints;
    if (pecp == NULL)
        return ILS_E_MEMORY;

    // Clone the information
    //
    pecp->iIndex = iIndex;
    pecp->pcnp = pcnp;

    if (pcnp != NULL)
    {
        pcnp->AddRef();
    };

    // Return the cloned enumerator
    //
    pecp->AddRef();
    *ppEnum = pecp;
    return S_OK;
}

//****************************************************************************
// CConnectionPoint::CConnectionPoint (const IID *pIID,
//                                     IConnectionPointContainer *pCPCInit)
//
// History:
//  Wed 17-Apr-1996 11:16:17  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CConnectionPoint::CConnectionPoint (const IID *pIID,
                                    IConnectionPointContainer *pCPCInit)
{
    cRef = 0;
    riid = *pIID;
    pCPC = pCPCInit;
    dwNextCookie = COOKIE_INIT_VALUE;
    cSinkNodes = 0;
    pSinkList = NULL;
    return;
}

//****************************************************************************
// CConnectionPoint::~CConnectionPoint (void)
//
// History:
//  Wed 17-Apr-1996 11:16:17  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CConnectionPoint::~CConnectionPoint (void)
{
    PSINKNODE pSinkNode;

    // Traverse the sink list and free each one of them
    //
    while (pSinkList != NULL)
    {
        pSinkNode = pSinkList;
        pSinkList = pSinkNode->pNext;

        pSinkNode->pUnk->Release();
        delete pSinkNode;
    };
    return;
}

//****************************************************************************
// STDMETHODIMP
// CConnectionPoint::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:16:23  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CConnectionPoint::QueryInterface (REFIID riid, void **ppv)
{
    if (riid == IID_IConnectionPoint || riid == IID_IUnknown)
    {
        *ppv = (IConnectionPoint *) this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return ILS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CConnectionPoint::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:16:30  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CConnectionPoint::AddRef (void)
{
    DllLock();

	MyDebugMsg ((DM_REFCOUNT, "CConnectionPoint::AddRef: ref=%ld\r\n", cRef));
    ::InterlockedIncrement ((LONG *) &cRef);
    return cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CConnectionPoint::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:16:36  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CConnectionPoint::Release (void)
{
    DllRelease();

	ASSERT (cRef > 0);

	MyDebugMsg ((DM_REFCOUNT, "CConnectionPoint::Release: ref=%ld\r\n", cRef));
	if (::InterlockedDecrement ((LONG *) &cRef) == 0)
    {
        delete this;
        return 0;
    }
    return cRef;
}

//****************************************************************************
// STDMETHODIMP
// CConnectionPoint::Notify(void *pv, CONN_NOTIFYPROC pfn)
//
// History:
//  Wed 17-Apr-1996 11:16:43  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CConnectionPoint::Notify(void *pv, CONN_NOTIFYPROC pfn)
{
    PSINKNODE  pSinkNode, pPrev;
    IUnknown   *pUnk;
    BOOL       fNeedClear;
    HRESULT    hr;

    // Enumerate each connection
    //
    pSinkNode = pSinkList;
    hr = S_OK;
    fNeedClear = FALSE;
    while((pSinkNode != NULL) && (SUCCEEDED(hr)))
    {
        // Important!! Important!!
        // Lock the sink object here. Need to do this in case that the sink
        // object calls back to Unadvise and we remove this sink node during
        // callback.
        //
        pSinkNode->uFlags |= SN_LOCKED;
        pUnk = pSinkNode->pUnk;

        // Calls the sink object
        // Note: Do not need to reference the sink object again.
        //       We already did when Advise was called.
        //
        hr = (*pfn)(pUnk, pv);

        pSinkNode->uFlags &= ~SN_LOCKED;
        if (pSinkNode->uFlags & SN_REMOVED)
        {
            fNeedClear = TRUE;
        };

        pSinkNode = pSinkNode->pNext;
    };

    // If there is at least one node to free
    //
    if (fNeedClear)
    {
        // Traverse the list for nodes to remove
        //
        pSinkNode = pSinkList;
        pPrev = NULL;

        while (pSinkNode != NULL)
        {
            // Release the sink object, if unadvise
            //
            if (pSinkNode->uFlags & SN_REMOVED)
            {
                PSINKNODE pNext;

                pNext = pSinkNode->pNext;
                if (pPrev == NULL)
                {
                    // This is the head of the list
                    //
                    pSinkList = pNext;
                }
                else
                {
                    pPrev->pNext = pNext;
                };

                pSinkNode->pUnk->Release();
                cSinkNodes--;
                delete pSinkNode;
                pSinkNode = pNext;
            }
            else
            {
                pPrev = pSinkNode;
                pSinkNode = pSinkNode->pNext;
            };
        };
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CConnectionPoint::GetConnectionInterface(IID *pIID)
//
// History:
//  Wed 17-Apr-1996 11:16:43  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CConnectionPoint::GetConnectionInterface(IID *pIID)
{
    // Validate the parameter
    //
    if (pIID == NULL)
        return ILS_E_POINTER;

    // Support only one connection interface
    //
    *pIID = riid;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CConnectionPoint::GetConnectionPointContainer(IConnectionPointContainer **ppCPC)
//
// History:
//  Wed 17-Apr-1996 11:16:49  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CConnectionPoint::GetConnectionPointContainer(IConnectionPointContainer **ppCPC)
{
    // Validate the parameter
    //
    if (ppCPC == NULL)
        return ILS_E_POINTER;

    // Return the container and add its reference count
    //
    *ppCPC = pCPC;

    if (pCPC != NULL)
    {
        // The container is still alive
        //
        pCPC->AddRef();
        return S_OK;
    }
    else
    {
        // The container no longer exists
        //
        return ILS_E_FAIL;
    };
}

//****************************************************************************
// STDMETHODIMP
// CConnectionPoint::Advise(IUnknown *pUnk, DWORD *pdwCookie)
//
// History:
//  Wed 17-Apr-1996 11:17:01  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CConnectionPoint::Advise(IUnknown *pUnk, DWORD *pdwCookie)
{
    PSINKNODE pSinkNode;
    IUnknown *pSinkInterface;

    // Validate the parameter
    //
    if ((pUnk == NULL) ||
        (pdwCookie == NULL))
        return ILS_E_PARAMETER;

    // Get the sink interface
    //
    if (FAILED(pUnk->QueryInterface(riid, (void **)&pSinkInterface)))
        return CONNECT_E_CANNOTCONNECT;

    // Create the sink node
    //
    pSinkNode = new SINKNODE;
    pSinkNode->pNext = pSinkList;
    pSinkNode->pUnk = pSinkInterface;
    pSinkNode->dwCookie = dwNextCookie;
    pSinkNode->uFlags = 0;
    *pdwCookie = dwNextCookie;

    // Put it in the sink list
    //
    pSinkList = pSinkNode;
    dwNextCookie++;
    cSinkNodes++;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CConnectionPoint::Unadvise(DWORD dwCookie)
//
// History:
//  Wed 17-Apr-1996 11:17:09  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CConnectionPoint::Unadvise(DWORD dwCookie)
{
    PSINKNODE pSinkNode, pPrev;

    // Search for the matching sink object
    //
    pPrev = NULL;
    pSinkNode = pSinkList;

    // Traverse the sink list to find the specified sink object
    //
    while (pSinkNode != NULL)
    {
        if (pSinkNode->dwCookie == dwCookie)
        {
            // Flag to remove
            //
            pSinkNode->uFlags |= SN_REMOVED;
            break;
        };

        pPrev = pSinkNode;
        pSinkNode = pSinkNode->pNext;
    };

    // Have we found the specified sink object?
    //
    if (pSinkNode == NULL)
    {
        // No, return failure
        //
        return CONNECT_E_NOCONNECTION;
    };

    // Release the sink object, if not locked
    //
    if ((pSinkNode->uFlags & SN_REMOVED) &&
        !(pSinkNode->uFlags & SN_LOCKED))
    {
        // Is there a previous node?
        //
        if (pPrev == NULL)
        {
            // This is the head of the list
            //
            pSinkList = pSinkNode->pNext;
        }
        else
        {
            pPrev->pNext = pSinkNode->pNext;
        };

        pSinkNode->pUnk->Release();
        cSinkNodes--;
        delete pSinkNode;
    };

    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CConnectionPoint::EnumConnections(IEnumConnections **ppEnum)
//
// History:
//  Wed 17-Apr-1996 11:17:18  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CConnectionPoint::EnumConnections(IEnumConnections **ppEnum)
{
    CEnumConnections *pecn;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return ILS_E_POINTER;
    };

    // Assume failure
    //
    *ppEnum = NULL;

    // Create an enumerator
    //
    pecn = new CEnumConnections;
    if (pecn == NULL)
        return ILS_E_MEMORY;

    // Initialize the enumerator
    //
    hr = pecn->Init(pSinkList, cSinkNodes);

    if (FAILED(hr))
    {
        delete pecn;
        return hr;
    };

    pecn->AddRef();
    *ppEnum = pecn;
    return S_OK;
}

//****************************************************************************
// CEnumConnections::CEnumConnections(void)
//
// History:
//  Wed 17-Apr-1996 11:17:25  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CEnumConnections::CEnumConnections(void)
{
    cRef = 0;
    iIndex = 0;
    cConnections = 0;
    pConnectData = NULL;
    return;
}

//****************************************************************************
// CEnumConnections::~CEnumConnections(void)
//
// History:
//  Wed 17-Apr-1996 11:17:25  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CEnumConnections::~CEnumConnections(void)
{
    if (pConnectData != NULL)
    {
        UINT i;

        for (i = 0; i < cConnections; i++)
        {
            pConnectData[i].pUnk->Release();
        };
        delete [] pConnectData;
    };
    return;
}

//****************************************************************************
// STDMETHODIMP
// CEnumConnections::Init(PSINKNODE pSinkList, ULONG cSinkNodes)
//
// History:
//  Wed 17-Apr-1996 11:17:34  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumConnections::Init(PSINKNODE pSinkList, ULONG cSinkNodes)
{
    HRESULT hr = S_OK;

    iIndex = 0;
    cConnections = 0;
    pConnectData = NULL;

    // Snapshot the connection list
    //
    if (cSinkNodes > 0)
    {
        UINT i;

        pConnectData = new CONNECTDATA[cSinkNodes];
        
        if (pConnectData != NULL)
        {
            for (i = 0; i < cSinkNodes && pSinkList != NULL; i++)
            {
                if (!(pSinkList->uFlags & SN_REMOVED))
                {
                    pConnectData[cConnections].pUnk = pSinkList->pUnk;
                    pConnectData[cConnections].pUnk->AddRef();
                    pConnectData[cConnections].dwCookie = pSinkList->dwCookie;
                    cConnections++;
                };
                pSinkList = pSinkList->pNext;
            };
        }
        else
        {
            hr = ILS_E_MEMORY;
        };
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CEnumConnections::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:17:40  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumConnections::QueryInterface (REFIID riid, void **ppv)
{
    if (riid == IID_IEnumConnections || riid == IID_IUnknown)
    {
        *ppv = (IEnumConnections *) this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return ILS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumConnections::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:17:49  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumConnections::AddRef (void)
{
    DllLock();

	MyDebugMsg ((DM_REFCOUNT, "CEnumConnections::AddRef: ref=%ld\r\n", cRef));
    ::InterlockedIncrement ((LONG *) &cRef);
    return cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumConnections::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:17:59  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumConnections::Release (void)
{
    DllRelease();

	ASSERT (cRef > 0);

	MyDebugMsg ((DM_REFCOUNT, "CEnumConnections::Release: ref=%ld\r\n", cRef));
    if (::InterlockedDecrement ((LONG *) &cRef) == 0)
    {
        delete this;
        return 0;
    }
    return cRef;
}

//****************************************************************************
// STDMETHODIMP 
// CEnumConnections::Next (ULONG cConnectionDatas, CONNECTDATA *rgpcd,
//                         ULONG *pcFetched)
//
// History:
//  Wed 17-Apr-1996 11:18:07  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP 
CEnumConnections::Next (ULONG cConnectDatas, CONNECTDATA *rgpcd,
                        ULONG *pcFetched)
{
    CONNECTDATA  *pConnect;
    ULONG        cCopied;

    // Validate the pointer
    //
    if (rgpcd == NULL)
        return ILS_E_POINTER;

    // Validate the parameters
    //
    if ((cConnectDatas == 0) ||
        ((cConnectDatas > 1) && (pcFetched == NULL)))
        return ILS_E_PARAMETER;

    // Check the enumeration index
    //
    pConnect = &pConnectData[iIndex];
    for (cCopied = 0; iIndex < cConnections && cCopied < cConnectDatas; cCopied++)
    {
        rgpcd[cCopied] = *pConnect;
        rgpcd[cCopied].pUnk->AddRef();
        iIndex++;
        pConnect++;
    };        

    // Determine the returned information based on other parameters
    //
    if (pcFetched != NULL)
    {
        *pcFetched = cCopied;
    };
    return (cConnectDatas == cCopied ? S_OK : S_FALSE);
}

//****************************************************************************
// STDMETHODIMP
// CEnumConnections::Skip (ULONG cConnectDatas)
//
// History:
//  Wed 17-Apr-1996 11:18:15  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumConnections::Skip (ULONG cConnectDatas)
{
    // Validate the parameters
    //
    if (cConnectDatas == 0) 
        return ILS_E_PARAMETER;

    // Check the enumeration index limit
    //
    if ((iIndex+cConnectDatas) >= cConnections)
    {
        iIndex = cConnections;
        return S_FALSE;
    }
    else
    {
        // Skip as requested
        //
        iIndex += cConnectDatas;
        return S_OK;
    };
}

//****************************************************************************
// STDMETHODIMP
// CEnumConnections::Reset (void)
//
// History:
//  Wed 17-Apr-1996 11:18:22  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumConnections::Reset (void)
{
    iIndex = 0;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CEnumConnections::Clone(IEnumConnections **ppEnum)
//
// History:
//  Wed 17-Apr-1996 11:18:29  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumConnections::Clone(IEnumConnections **ppEnum)
{
    CEnumConnections *pecn;
    CONNECTDATA *pConnectDataClone;
    UINT i;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return ILS_E_POINTER;
    };

    *ppEnum = NULL;

    // Create an enumerator
    //
    pecn = new CEnumConnections;
    if (pecn == NULL)
        return ILS_E_MEMORY;

    // Clone the information
    //
    pConnectDataClone = new CONNECTDATA[cConnections];
    if (pConnectDataClone == NULL)
    {
        delete pecn;
        return ILS_E_MEMORY;
    };

    // Clone the connect data list
    //
    for (i = 0; i < cConnections; i++)
    {
        pConnectDataClone[i] = pConnectData[i];
        pConnectDataClone[i].pUnk->AddRef();
    };
    pecn->iIndex = iIndex;
    pecn->cConnections = cConnections;

    // Return the cloned enumerator
    //
    pecn->AddRef();
    *ppEnum = pecn;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\cserver.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       cserver.cpp
//  Content:    This file contains the ULS server object.
//  History:
//      Wed 17-Apr-1996 11:13:54  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#include "ulsp.h"
#include "culs.h"
#include "localusr.h"
#include "attribs.h"
#include "localprt.h"
#include "callback.h"



//****************************************************************************
// ILS_STATE
// CIlsUser::GetULSState(VOID)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

ILS_STATE CIlsUser::
GetULSState ( VOID )
{
    ILS_STATE uULSState;

    switch(m_uState)
    {
        case ULSSVR_INVALID:
        case ULSSVR_INIT:
            uULSState = ILS_UNREGISTERED;
            break;

        case ULSSVR_REG_USER:
        case ULSSVR_REG_PROT:
            uULSState = ILS_REGISTERING;
            break;

        case ULSSVR_CONNECT:
            uULSState = ILS_REGISTERED;
            break;

        case ULSSVR_UNREG_PROT:
        case ULSSVR_UNREG_USER:
            uULSState = ILS_UNREGISTERING;
            break;

        case ULSSVR_RELOGON:
            uULSState = ILS_REGISTERED_BUT_INVALID;
            break;

        case ULSSVR_NETWORK_DOWN:
            uULSState = ILS_NETWORK_DOWN;
            break;

        default:
            ASSERT(0);
            uULSState = ILS_UNREGISTERED;
            break;
    };

    return uULSState;
}

//****************************************************************************
// void
// CIlsUser::NotifyULSRegister(HRESULT hr)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void
CIlsUser::NotifyULSRegister(HRESULT hr)
{
    g_pCIls->LocalAsyncRespond(WM_ILS_LOCAL_REGISTER, m_uReqID, hr);
    m_uReqID = 0;
    return;
}

//****************************************************************************
// void
// CIlsUser::NotifyULSUnregister(HRESULT hr)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void
CIlsUser::NotifyULSUnregister(HRESULT hr)
{
    g_pCIls->LocalAsyncRespond(WM_ILS_LOCAL_UNREGISTER, m_uReqID, hr);
    m_uReqID = 0;
    return;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::AddPendingRequest(ULONG uReqType, ULONG uMsgID)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CIlsUser::
AddPendingRequest(ULONG uReqType, ULONG uMsgID)
{
    // Add the request to the queue
    //
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    ri.uReqType = uReqType;
    ri.uMsgID = uMsgID;

    ReqInfo_SetUser (&ri, this);

    HRESULT hr = g_pReqMgr->NewRequest(&ri);
    if (SUCCEEDED(hr))
    {
        // Make sure the objects do not disappear before we get the response
        //
        this->AddRef();

        // Remember the last request
        //
        m_uLastMsgID = uMsgID;
    }

    return hr;
}


//****************************************************************************
// STDMETHODIMP
// CIlsUser::Register (CIlsUser *pUser, CLocalApp  *pApp, ULONG uReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CIlsUser::
InternalRegister ( ULONG uReqID )
{
    LDAP_ASYNCINFO lai;
    PLDAP_CLIENTINFO pui;
    HANDLE hUser;
    HRESULT hr;

    ASSERT(uReqID != 0);

    // Validate the proper state
    //
    if (m_uState != ULSSVR_INIT)
        return ILS_E_FAIL;

    // Get the protocol enumerator
    //
    hr = EnumLocalProtocols(&m_pep);
    if (SUCCEEDED(hr))
    {
        // Remember the request ID
        //
        m_uReqID = uReqID;

        // Start the registration state machine
        //
        hr = InternalRegisterNext (NOERROR);
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::InternalRegisterNext (HRESULT hr)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CIlsUser::
InternalRegisterNext (HRESULT hr)
{
// lonchanc:
// I need to change Viroon's logic here.
// We should simply send out a bunch of requests and
// wait for all of them to come back, rather than
// doing a state machine stuff!!!
    LDAP_ASYNCINFO lai;
    ULONG uReqType;

    // Clean up last request
    //
    m_uLastMsgID = 0;

    if (SUCCEEDED(hr))
    {
        switch (m_uState)
        {
            case ULSSVR_INIT:
            {
                PLDAP_CLIENTINFO pui;
                HANDLE hUser;

                // Snap-shot the user information now
                //
                hr = InternalGetUserInfo (TRUE, &pui, LU_MOD_ALL);

                if (SUCCEEDED(hr))
                {
                    // Register the user with the server
                    //
                    hr = ::UlsLdap_RegisterClient ( (DWORD_PTR) this,
								                    m_pIlsServer->GetServerInfo (),
								                    pui,
								                    &hUser,
								                    &lai);
                    if (SUCCEEDED(hr))
                    {
                        // We are registering the user
                        //
                        m_hLdapUser = hUser;
                        m_uState = ULSSVR_REG_USER;
                        uReqType = WM_ILS_REGISTER_CLIENT;
                    };
                    ::MemFree (pui);
                };
                break;
            }

            case ULSSVR_REG_USER:

                m_uState = ULSSVR_REG_PROT;
                //
                // Fall through to start registering the protocol
                //
            case ULSSVR_REG_PROT:
            {
                IIlsProtocol *plp;

                // Get the next protocol from the application
                //
                ASSERT (m_pep != NULL);
                hr = m_pep->Next(1, &plp, NULL);

                switch (hr)
                {
                    case NOERROR:
                    {
                    	ASSERT (plp != NULL);
                        hr = RegisterLocalProtocol(FALSE, (CLocalProt *)plp, &lai);
                    	plp->Release (); // AddRef by m_pep->Next()
                        uReqType = WM_ILS_REGISTER_PROTOCOL;
                        break;
                    }
                    case S_FALSE:
                    {
                        // The last protocol is done. Cleanup enumerator
                        //
                        m_pep->Release();
                        m_pep = NULL;

                        // Change to connect state and notify the ULS object
                        // We are done. Get out of here.
                        //
                        hr = NOERROR;
                        m_uState = ULSSVR_CONNECT;
                        NotifyULSRegister(NOERROR);
                        return NOERROR;
                    }
                    default:
                    {
                        // Fail the enumeration, bail out
                        //
                        break;
                    }
                };
                break;
            }
            default:
                ASSERT(0);
                break;
        };
    };

    if (SUCCEEDED(hr))
    {
        // Add a pending request to handle the response
        //
        hr = AddPendingRequest(uReqType, lai.uMsgID);
    };

    if (FAILED(hr))
    {
        // Oops ! the server failed us. Clean up the registration
        //
        InternalCleanupRegistration (TRUE);

        // Notify the ULS object for the failure
        //
        NotifyULSRegister(hr);
    };
    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::CleanupRegistration (void)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
CIlsUser::InternalCleanupRegistration ( BOOL fKeepProtList )
{
    LDAP_ASYNCINFO lai;

    // Note: This is a fast cleanup. The idea is to unregister everything being
    // registered so far without waiting for the unregister result.
    //

    // Unregister each registered protocol
    //
    CLocalProt *plp = NULL;
    HANDLE hEnum = NULL;
    m_ProtList.Enumerate(&hEnum);
    if (fKeepProtList)
    {
	    while (m_ProtList.Next (&hEnum, (VOID **) &plp) == NOERROR)
	    {
	    	ASSERT (plp != NULL);
	        ::UlsLdap_VirtualUnRegisterProtocol(plp->GetProviderHandle());
	    	plp->SetProviderHandle (NULL);
	    }
    }
    else
    {
	    while(m_ProtList.Next (&hEnum, (VOID **) &plp) == NOERROR)
	    {
	    	ASSERT (plp != NULL);
	        ::UlsLdap_UnRegisterProtocol (plp->GetProviderHandle (), &lai);
	        plp->Release();
	    }
	    m_ProtList.Flush ();
	}

    //
    // Unregister user
    //
    if (m_hLdapUser != NULL)
    {
        ::UlsLdap_UnRegisterClient (m_hLdapUser, &lai);
        m_hLdapUser = NULL;
    };

    // Release all the resource
    //
    if (m_pep != NULL)
    {
        m_pep->Release();
        m_pep = NULL;
    };

    // Unwind the object to the initialize state
    //
    m_uState = ULSSVR_INIT;
    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::Unregister (ULONG uReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
CIlsUser::InternalUnregister (ULONG uReqID)
{
    HRESULT hr;

    ASSERT(uReqID != 0);

    // Remove the last request, if any
    //
    if (m_uLastMsgID != 0)
    {
	    COM_REQ_INFO ri;
	    ReqInfo_Init (&ri);

        // Look for the matching request information
        //
        ri.uReqID = 0;
        ri.uMsgID = m_uLastMsgID;

        g_pReqMgr->RequestDone(&ri);
    };

    // If this is to cancel the current registration, we need to cancel the
    // registration then start unregistration.
    //
    if (m_uReqID != 0)
    {
        NotifyULSRegister(ILS_E_ABORT);
    };

    // Determine the starting state
    //
    hr = NOERROR;
    switch (m_uState)
    {
    	case ULSSVR_RELOGON:
    	case ULSSVR_NETWORK_DOWN:

        case ULSSVR_CONNECT:
        case ULSSVR_REG_PROT:
            //
            // In the middle of registering a protocol or an app
            // Unregistering the protocol then the app
            //
            m_uState = ULSSVR_UNREG_PROT;
            break;

        case ULSSVR_REG_USER:
            //
            // In the middle of registering the user
            // Unregistering the user
            //
            m_uState = ULSSVR_UNREG_USER;
            break;

        default:
            hr = ILS_E_FAIL;
            break;
    }

    // The initial request succeeds, remember the request ID
    //
    if (SUCCEEDED(hr))
    {
        // lonchanc: [11/15/96]
        // To fix the "OnLocalRegisterResult: No pending request for 0" problem,
        // we have to put uReqID because UnregisterNext() will use uReqID when
        // it fails to unregister app/user.
        //
        m_uReqID = uReqID;
        hr = InternalUnregisterNext(hr);

#if 0	// lonchanc: [11/15/96]
		// See the comment above.
        if (SUCCEEDED(hr))
        {
            m_uReqID = uReqID;
        };
#endif
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::InternalUnregisterNext (HRESULT hr)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
CIlsUser::InternalUnregisterNext (HRESULT hr)
{
    LDAP_ASYNCINFO lai;
    ULONG uReqType;

    // Clean up last request
    //
    m_uLastMsgID = 0;

    do
    {
        switch (m_uState)
        {
            case ULSSVR_UNREG_PROT:
            {
                // Is there another protocol?
                //
                CLocalProt *plp = NULL;
                HANDLE hEnum = NULL;
                m_ProtList.Enumerate(&hEnum);
                while (m_ProtList.Next(&hEnum, (VOID **)&plp) == S_OK)
                {
                	// Do not need to unregister protocols because
                	// UnregisterUser will delete the entire entry.
                	//
        	        ::UlsLdap_VirtualUnRegisterProtocol (plp->GetProviderHandle());

                    // Another protocol to clean up
                    //
                    plp->SetProviderHandle (NULL);

                    // Do not need to plp->Release() (cf. AddRef by RegisterLocalProtocol)
                    // because the user object still contain all the protocol objects
                    //
                }

                // Unregister the user
                //
                m_uState = ULSSVR_UNREG_USER;
                hr = ::UlsLdap_UnRegisterClient (m_hLdapUser, &lai);
                uReqType = WM_ILS_UNREGISTER_CLIENT;
                m_hLdapUser = NULL;
                break;
            }

            case ULSSVR_UNREG_USER:
                //
                // Put the object back into the init state
                //
                InternalCleanupRegistration(TRUE);
                NotifyULSUnregister(NOERROR);
                return NOERROR;

            default:
                ASSERT(0);
                return NOERROR;
        };
    }
    while (FAILED(hr));    // Unregistration failed, nohing to wait for

    if (SUCCEEDED(hr))
    {
        AddPendingRequest(uReqType, lai.uMsgID);
    };
    return hr;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\connpt.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       connpt.h
//  Content:    This file contains the connection container object definition.
//  History:
//      Wed 17-Apr-1996 11:18:47  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#ifndef _CONNPT_H_
#define _CONNPT_H_

//****************************************************************************
// CEnumConnectionPoints definition
//****************************************************************************
//
class CEnumConnectionPoints : public IEnumConnectionPoints
{
private:
    ULONG                   cRef;
    ULONG                   iIndex;
    IConnectionPoint        *pcnp;

public:
    // Constructor and Initialization
    CEnumConnectionPoints (void);
    ~CEnumConnectionPoints (void);
    STDMETHODIMP            Init (IConnectionPoint *pcnpInit);

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IEnumConnectionPoints
    STDMETHODIMP            Next(ULONG cConnections, IConnectionPoint **rgpcn,
                                 ULONG *pcFetched);
    STDMETHODIMP            Skip(ULONG cConnections);
    STDMETHODIMP            Reset();
    STDMETHODIMP            Clone(IEnumConnectionPoints **ppEnum);
};

//****************************************************************************
// CConnectionPoint definition
//****************************************************************************
//
typedef struct tagSinkNode
{
    struct tagSinkNode      *pNext;
    IUnknown                *pUnk;
    ULONG                   uFlags;
    DWORD                   dwCookie;
}   SINKNODE, *PSINKNODE;

typedef HRESULT (*CONN_NOTIFYPROC)(IUnknown *pUnk, void *);

#define COOKIE_INIT_VALUE   1
#define SN_LOCKED           0x00000001
#define SN_REMOVED          0x00000002

class CConnectionPoint : public IConnectionPoint
{
private:
    ULONG                   cRef;
    IID                     riid;
    IConnectionPointContainer *pCPC;
    DWORD                   dwNextCookie;
    ULONG                   cSinkNodes;
    PSINKNODE               pSinkList;

public:
    // Constructor and destructor
    CConnectionPoint (const IID *pIID, IConnectionPointContainer *pCPCInit);
    ~CConnectionPoint (void);

    // Class public functions
    void                    ContainerReleased() {pCPC = NULL; return;}
    STDMETHODIMP            Notify (void *pv, CONN_NOTIFYPROC pfn);

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IConnectionPoint
    STDMETHODIMP            GetConnectionInterface(IID *pIID);
    STDMETHODIMP            GetConnectionPointContainer(IConnectionPointContainer **ppCPC);
    STDMETHODIMP            Advise(IUnknown *pUnk, DWORD *pdwCookie);
    STDMETHODIMP            Unadvise(DWORD dwCookie);
    STDMETHODIMP            EnumConnections(IEnumConnections **ppEnum);
};

//****************************************************************************
// CEnumConnections definition
//****************************************************************************
//
class CEnumConnections : public IEnumConnections
{
private:
    ULONG                   cRef;
    ULONG                   iIndex;
    ULONG                   cConnections;
    CONNECTDATA             *pConnectData;

public:
    // Constructor and Initialization
    CEnumConnections (void);
    ~CEnumConnections (void);
    STDMETHODIMP            Init(PSINKNODE pSinkList, ULONG cSinkNodes);

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IEnumConnections
    STDMETHODIMP            Next(ULONG cConnections, CONNECTDATA *rgpcn,
                                 ULONG *pcFetched);
    STDMETHODIMP            Skip(ULONG cConnections);
    STDMETHODIMP            Reset();
    STDMETHODIMP            Clone(IEnumConnections **ppEnum);
};

#endif //_CONNPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\debug.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       debug.cpp
//  Content:    This file contains miscellaneous debug routines.
//  History:
//      Thu 08-Apr-1993 09:43:46  -by-  Viroon  Touranachun [viroont]
//
//****************************************************************************

#include "ulsp.h"
#include "debug.h"

#ifdef  DEBUG

UINT DbgUlsTrace(LPCTSTR pszFormat, ...)
{
	if (F_ZONE_ENABLED(ghZoneUls, DM_TRACE))
	{
		va_list v1;
		va_start(v1, pszFormat);

		DbgPrintf(TEXT("ULS:Trace"), (PSTR) pszFormat, v1);

		va_end(v1);
	}
	return 0;
}


VOID DbgMsgUls(ULONG iZone, CHAR *pszFormat, ...)
{
	if (F_ZONE_ENABLED(ghZoneUls, iZone))
	{
		PCSTR pszPrefix;
		switch (iZone)
			{
		case DM_ERROR:    pszPrefix = "ILS:Error";    break;
		case DM_WARNING:  pszPrefix = "ILS:Warning";  break;
		case DM_TRACE:    pszPrefix = "ILS:Trace";    break;
		case DM_REFCOUNT: pszPrefix = "ILS:RefCount"; break;
		case ZONE_KA:     pszPrefix = "ILS:KA";       break;
		case ZONE_FILTER: pszPrefix = "ILS:Filter";   break;
		case ZONE_REQ:    pszPrefix = "ILS:Request";  break;
		case ZONE_RESP:   pszPrefix = "ILS:Response"; break;
		case ZONE_CONN:   pszPrefix = "ILS:Connection"; break;
		default:          pszPrefix = "ILS:???";      break;
			}
		
		va_list args;
		va_start(args, pszFormat);
		DbgPrintf(pszPrefix, pszFormat, args);
		va_end(args);
	}
}

#endif  // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\culs.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       culs.h
//  Content:    This file contains the ULS object definition.
//  History:
//      Wed 17-Apr-1996 11:18:47  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#ifndef _CILS_H_
#define _CILS_H_

#include "connpt.h"
#include "spserver.h"

class CIlsServer;

//****************************************************************************
// CIls definition
//****************************************************************************
//

class CIlsMain : public IIlsMain,
             public IConnectionPointContainer 
{
private:

    LONG                    m_cRef;
    BOOL                    fInit;
    HWND                    hwndCallback;
    CConnectionPoint        *pConnPt;

    BOOL                    IsInitialized (void) {return fInit;}
    STDMETHODIMP            NotifySink (void *pv, CONN_NOTIFYPROC pfn);
	HRESULT					StringToFilter (TCHAR *pszFilter ,CFilter **ppFilter);

    HRESULT	EnumUsersEx (
			BOOL					fNameOnly,
			CIlsServer				*pServer,
			IIlsFilter				*pFilter,
			CAttributes				*pAttrib,
			ULONG					*puReqID );

	HRESULT EnumMeetingPlacesEx (
			BOOL					fNameOnly,
			CIlsServer				*pServer,
			IIlsFilter				*pFilter,
			CAttributes				*pAttrib,
			ULONG					*puReqID);

public:
    // Constructor and destructor
    CIlsMain (void);
    ~CIlsMain (void);
    STDMETHODIMP    Init (void);

    // Internal methods
    HWND            GetNotifyWindow(void) {return hwndCallback;}
    void            LocalAsyncRespond (ULONG msg, ULONG uReqID, LPARAM lParam)
                    {PostMessage(hwndCallback, msg, uReqID, lParam); return;}


    // Asynchronous response handler
    //
    STDMETHODIMP    GetUserResult (ULONG uReqID, PLDAP_CLIENTINFO_RES puir, CIlsServer *pIlsServer);
    STDMETHODIMP    EnumUserNamesResult (ULONG uReqID, PLDAP_ENUM ple);
    STDMETHODIMP    EnumUsersResult (ULONG uReqID, PLDAP_ENUM ple, CIlsServer *pIlsServer);
#ifdef ENABLE_MEETING_PLACE
    HRESULT    GetMeetingPlaceResult (ULONG uReqID, PLDAP_MEETINFO_RES pmir, CIlsServer *pIlsServer);
    HRESULT    EnumMeetingPlacesResult(ULONG ulReqID, PLDAP_ENUM  ple, CIlsServer *pIlsServer);
    HRESULT    EnumMeetingPlaceNamesResult( ULONG ulReqID, PLDAP_ENUM  ple);
#endif // ENABLE_MEETING_PLACE

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IIls
    STDMETHODIMP    Initialize (VOID);

    STDMETHODIMP    CreateServer ( BSTR bstrServerName, IIlsServer **ppServer );

    STDMETHODIMP    CreateUser( BSTR bstrUserID, BSTR bstrAppName, IIlsUser **ppUser);

    STDMETHODIMP    CreateAttributes ( ILS_ATTR_TYPE AttrType, IIlsAttributes **ppAttributes );

    STDMETHODIMP    EnumUserNames ( IIlsServer *pServer,
                                    IIlsFilter *pFilter,
                                    IEnumIlsNames   **ppEnumUserNames,
                                    ULONG *puReqID);

    STDMETHODIMP    GetUser (   IIlsServer *pServer,
                                BSTR bstrUserName,
                                BSTR bstrAppName,
                                BSTR bstrProtName,
                                IIlsAttributes *pAttrib,
                                IIlsUser **ppUser,
                                ULONG *puReqID);

    STDMETHODIMP    EnumUsers ( IIlsServer *pServer,
                                IIlsFilter *pFilter,
                                IIlsAttributes *pAttrib,
                                IEnumIlsUsers **ppEnumUser,
                                ULONG *puReqID);

#ifdef ENABLE_MEETING_PLACE
    STDMETHODIMP    CreateMeetingPlace( 
                                        BSTR   bstrMeetingPlaceID,
                                        LONG   lMeetingPlaceType,    // set to default
                                        LONG   lAttendeeType,    // set to default
                                        IIlsMeetingPlace **ppMeetingPlace
                                    );

    // Lightweight enumerator of MeetingPlaces for a given server
    // This returns only the names. If a caller wants more info than
    // the names he can get the name from here, and call the 
    // heavyweight enumerator (see below) with the filter specifying
    // the name.    

    STDMETHODIMP    EnumMeetingPlaceNames(
                                        IIlsServer *pServer,
                                        IIlsFilter *pFilter,
                                        IEnumIlsNames **ppEnumMeetingPlaceNames,
                                        ULONG   *pulID
                                        );

    // Slightly heavier enumerator. Returns the MeetingPlaces and
    // associated default attributes

    STDMETHODIMP    EnumMeetingPlaces(
                                        IIlsServer *pServer,
                                        IIlsFilter *pFilter,
                                        IIlsAttributes *pAttributes,
                                        IEnumIlsMeetingPlaces **ppEnumMeetingPlace,
                                        ULONG   *pulID
                                        );

    STDMETHODIMP    GetMeetingPlace( IIlsServer *pServer,
                                BSTR bstrMeetingPlaceID,
								IIlsAttributes	*pAttrib,
								IIlsMeetingPlace	**ppMtg,
                                ULONG *pulID);   
#endif // ENABLE_MEETING_PLACE

    STDMETHODIMP    Abort (ULONG uReqID);
    STDMETHODIMP    Uninitialize (void);

    // Filter methods
    STDMETHODIMP    CreateFilter ( ILS_FILTER_TYPE FilterType,
    								ILS_FILTER_OP FilterOp,
                                    IIlsFilter **ppFilter );
    STDMETHODIMP    StringToFilter (BSTR bstrFilterString, IIlsFilter **ppFilter);

    // IConnectionPointContainer
    STDMETHODIMP    EnumConnectionPoints(IEnumConnectionPoints **ppEnum);
    STDMETHODIMP    FindConnectionPoint(REFIID riid,
                                        IConnectionPoint **ppcp);
};


class CIlsServer : public IIlsServer
{
private:

	LONG			m_cRefs;
	LONG			m_dwSignature;

	SERVER_INFO		m_ServerInfo;

public:

	CIlsServer ( VOID );
	~CIlsServer ( VOID );

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

	// IIlsServer
	STDMETHODIMP	SetAuthenticationMethod ( ILS_ENUM_AUTH_METHOD enumAuthMethod );
	STDMETHODIMP	SetLogonName ( BSTR bstrLogonName );
	STDMETHODIMP	SetLogonPassword ( BSTR bstrLogonPassword );
	STDMETHODIMP	SetDomain ( BSTR bstrDomain );
	STDMETHODIMP	SetCredential ( BSTR bstrCredential );
    STDMETHODIMP    SetTimeout ( ULONG uTimeoutInSecond );
	STDMETHODIMP	SetBaseDN ( BSTR bstrBaseDN );

	CIlsServer *Clone ( VOID );

	HRESULT SetServerName ( TCHAR *pszServerName );
	HRESULT SetServerName ( BSTR bstrServerName );
	TCHAR *DuplicateServerName ( VOID );
	BSTR DuplicateServerNameBSTR ( VOID );

	SERVER_INFO *GetServerInfo ( VOID ) { return &m_ServerInfo; }
	TCHAR *GetServerName ( VOID ) { return m_ServerInfo.pszServerName; }

	BOOL IsGoodServerName ( VOID ) { return ::MyIsGoodString (m_ServerInfo.pszServerName); }
	BOOL IsBadServerName ( VOID ) { return ::MyIsBadString (m_ServerInfo.pszServerName); }

	enum { ILS_SERVER_SIGNATURE = 0x12abcdef };
	BOOL IsGoodIlsServer ( VOID ) { return (m_dwSignature == ILS_SERVER_SIGNATURE); }
	BOOL IsBadIlsServer ( VOID ) { return (m_dwSignature != ILS_SERVER_SIGNATURE); }
};


inline BOOL MyIsBadServer ( CIlsServer *p )
{
	return (p == NULL || p->IsBadIlsServer () || p->IsBadServerName ());
}

inline BOOL MyIsBadServer ( IIlsServer *p )
{
	return MyIsBadServer ((CIlsServer *) p);
}

//****************************************************************************
// Global Parameters
//****************************************************************************
//
LRESULT CALLBACK ULSNotifyProc(HWND hwnd, UINT message, WPARAM wParam,
                            LPARAM lParam);

#endif //_CONFMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\debug.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       debug.h
//  Content:    This file contains the debug-related declaration
//  History:
//      Tue 23-Feb-1993 14:08:25  -by-  Viroon  Touranachun [viroont]
//
//****************************************************************************

#ifndef _ULSDBG_H_
#define _ULSDBG_H_

#include <confdbg.h>

//****************************************************************************
// Macros
//****************************************************************************

#ifdef DEBUG

#define DM_ERROR    0x0000      // Error                       /* ;Internal */
#define DM_WARNING  0x0001      // Warning                     /* ;Internal */
#define DM_TRACE    0x0002      // Trace messages
#define DM_REFCOUNT 0x0003      // 

#define ZONE_KA     0x0004
#define ZONE_FILTER 0x0005
#define ZONE_REQ    0x0006
#define ZONE_RESP   0x0007
#define ZONE_CONN   0x0008

extern HDBGZONE ghZoneUls;
UINT DbgUlsTrace(LPCTSTR, ...);
VOID DbgMsgUls(ULONG uZone, CHAR *pszFormat, ...);

#define DPRINTF(sz)            DbgUlsTrace(sz)
#define DPRINTF1(sz,x)         DbgUlsTrace(sz, x)
#define DPRINTF2(sz,x,y)       DbgUlsTrace(sz, x, y)

#define DBG_REF               (!F_ZONE_ENABLED(ghZoneUls, DM_REFCOUNT)) ? 0 : DbgUlsTrace

#define MyAssert(expr)			ASSERT(expr)
#define MyDebugMsg(s)			DbgMsgUls s

#else // DEBUG

#define DPRINTF(sz)    
#define DPRINTF1(sz,x)
#define DPRINTF2(sz,x,y)

inline void WINAPI DbgUlsTrace(LPCTSTR, ...) { }
#define DBG_REF     1 ? (void)0 : ::DbgUlsTrace

#define MyAssert(expr)			
#define MyDebugMsg(s)			
#endif // DEBUG

#endif  //_ULSDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\filter.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       filter.cpp
//  Content:    This file contains the filter object.
//  History:
//      Tue 12-Nov-1996 15:50:00  -by-  Chu, Lon-Chan [lonchanc]
//
//  Copyright (c) Microsoft Corporation 1995-1996
//
//****************************************************************************

#include "ulsp.h"
#include "filter.h"
#include "sputils.h"


/* ----------------------------------------------------------------------
	CFilter::CFilter

	History:
	11/12/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

CFilter::CFilter ( ILS_FILTER_TYPE Type )
:
 m_nSignature (ILS_FILTER_SIGNATURE),
 m_cRefs (0),
 m_Op (ILS_FILTEROP_NONE),
 m_cSubFilters (0),
 m_pszValue (NULL),
 m_NameType (ILS_ATTRNAME_UNKNOWN),
 m_Type (Type)
{
	// Initialize individual members based on filter type
	//
	ZeroMemory (&m_Name, sizeof (m_Name));
}


/* ----------------------------------------------------------------------
	CFilter::~CFilter

	History:
	11/12/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

CFilter::~CFilter ( VOID )
{
	ASSERT (m_Type == ILS_FILTERTYPE_COMPOSITE || m_Type == ILS_FILTERTYPE_SIMPLE);

	// Common members
	//
	m_nSignature = -1;

	// Clean up individual members based on filter type
	//
	if (m_Type == ILS_FILTERTYPE_COMPOSITE)
	{
	    m_SubFilters.Flush();
	}
	else
	{
		FreeName ();
		FreeValue ();
	}	
}


/* ----------------------------------------------------------------------
	CFilter::QueryInterface

	History:
	11/12/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

STDMETHODIMP CFilter::
QueryInterface ( REFIID riid, VOID **ppv )
{
	HRESULT hr = S_OK;
    *ppv = NULL;

    if (riid == IID_IIlsFilter || riid == IID_IUnknown)
    {
        *ppv = (IIlsFilter *) this;
    }

    if (*ppv != NULL)
        ((IUnknown *) *ppv)->AddRef();
    else
        hr = ILS_E_NO_INTERFACE;

    return hr;
}


/* ----------------------------------------------------------------------
	CFilter::AddRef

	History:
	11/12/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

STDMETHODIMP_(ULONG) CFilter::
AddRef ( VOID )
{
    DllLock();

	MyDebugMsg ((DM_REFCOUNT, "CFilter::AddRef: ref=%ld\r\n", m_cRefs));
	::InterlockedIncrement (&m_cRefs);
    return m_cRefs;
}


/* ----------------------------------------------------------------------
	CFilter::Release

	History:
	11/12/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

STDMETHODIMP_(ULONG) CFilter::
Release ( VOID )
{
	ASSERT (m_cRefs > 0);

	DllRelease();

	MyDebugMsg ((DM_REFCOUNT, "CFilter::Release: ref=%ld\r\n", m_cRefs));
    if (::InterlockedDecrement (&m_cRefs) == 0)
    {
		if (m_Type == ILS_FILTERTYPE_COMPOSITE)
		{
	    	HANDLE hEnum;
	    	CFilter *pFilter;

		    // Free all the attributes
		    //
		    m_SubFilters.Enumerate (&hEnum);
		    while (m_SubFilters.Next (&hEnum, (VOID **) &pFilter) == NOERROR)
		    {
		    	if (pFilter != NULL)
		    	{
		    		pFilter->Release ();
		    	}
		    	else
		    	{
		    		ASSERT (FALSE);
		    	}
		    }
	    }
	    
        delete this;
        return 0;
	}

    return m_cRefs;
}


/* ----------------------------------------------------------------------
	CFilter::AddSubFilter

	Input:
		pFilter: A pointer to a filter object.

	History:
	11/12/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

STDMETHODIMP CFilter::
AddSubFilter ( IIlsFilter *pFilter )
{
	// Make sure we have correct filter type
	//
	if (m_Type != ILS_FILTERTYPE_COMPOSITE)
		return ILS_E_FILTER_TYPE;

	// Make sure we have a valid sub-filter
	//
	if (pFilter == NULL || ((CFilter *) pFilter)->IsBadFilter ())
		return ILS_E_POINTER;

	HRESULT hr = m_SubFilters.Insert ((VOID *) pFilter);
	if (hr == S_OK)
		m_cSubFilters++;

	return hr;
}


/* ----------------------------------------------------------------------
	CFilter::RemoveSubFilter

	Input:
		pFilter: A placeholder to a pointer to a filter object.
				 If it is NULL, remove the first item.

	History:
	11/12/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

STDMETHODIMP CFilter::
RemoveSubFilter ( IIlsFilter *pFilter )
{
	// Make sure we have correct filter type
	//
	if (m_Type != ILS_FILTERTYPE_COMPOSITE)
		return ILS_E_FILTER_TYPE;

	// Make sure we have a valid filter
	//
	if (pFilter == NULL || ((CFilter *) pFilter)->IsBadFilter ())
		return ILS_E_POINTER;

	HRESULT hr = m_SubFilters.Remove ((VOID *) pFilter);
	if (hr == S_OK)
	{
		ASSERT (m_cSubFilters > 0);
		m_cSubFilters--;
	}

	return hr;
}


HRESULT CFilter::
RemoveAnySubFilter ( CFilter **ppFilter )
{
	// Make sure we have correct filter type
	//
	if (m_Type != ILS_FILTERTYPE_COMPOSITE)
	{
		ASSERT (FALSE);
		return ILS_E_FILTER_TYPE;
	}

	// Make sure we have a valid filter
	//
	if (ppFilter == NULL)
	{
		ASSERT (FALSE);
		return ILS_E_POINTER;
	}

	HRESULT hr = S_OK;

	if (*ppFilter == NULL)
	{
		HANDLE hEnum;
		
		m_SubFilters.Enumerate (&hEnum);
		m_SubFilters.Next (&hEnum, (VOID **) ppFilter);
	}

	hr = m_SubFilters.Remove ((VOID *) *ppFilter);
	if (hr == S_OK)
	{
		ASSERT (m_cSubFilters > 0);
		m_cSubFilters--;
	}

	return hr;
}


/* ----------------------------------------------------------------------
	CFilter::GetCount

	Output:
		pcElements: A pointer to the count of filter elements.

	History:
	12/03/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

STDMETHODIMP CFilter::
GetCount ( ULONG *pcElements )
{
	// Make sure we have correct filter type
	//
	if (m_Type != ILS_FILTERTYPE_COMPOSITE)
		return ILS_E_FILTER_TYPE;

	HRESULT hr = S_OK;
	if (pcElements != NULL)
	{
		*pcElements = m_cSubFilters;
	}
	else
	{
		hr = ILS_E_POINTER;
	}

	return hr;
}


/* ----------------------------------------------------------------------
	CFilter::CalcFilterSize

	Input/Output:
		pcbStringSize: A pointer to the cumulative string size.

	History:
	12/03/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

HRESULT CFilter::
CalcFilterSize ( ULONG *pcbStringSize )
{
	ASSERT (pcbStringSize != NULL);

	HRESULT hr = S_OK;
	ULONG cbSize;
	TCHAR *psz;

	switch (m_Type)
	{
	case ILS_FILTERTYPE_COMPOSITE:
		{
			// First, count for "()"
			//
			cbSize = 4 * sizeof (TCHAR); // "(&)"

			// Second, enumerat every child
			//
			HANDLE hEnum;
			CFilter *pFilter = NULL;
		    m_SubFilters.Enumerate (&hEnum);
		    while (m_SubFilters.Next (&hEnum, (VOID **) &pFilter) == NOERROR)
		    {
		    	if (pFilter != NULL)
		    	{
		    		hr = pFilter->CalcFilterSize (pcbStringSize);
		    	}
		    	else
		    	{
		    		ASSERT (FALSE);
		    		hr = ILS_E_POINTER;
		    	}

				// Report error if needed
				//
		    	if (hr != S_OK)
		    		goto MyExit;
		    } // while
		} // case
		break;

	case ILS_FILTERTYPE_SIMPLE:
		{
			// First, count for "()"
			//
			cbSize = 3 * sizeof (TCHAR); // "()"

			// Second, count for attribute name
			//
			ASSERT (m_NameType == ILS_ATTRNAME_STANDARD || m_NameType == ILS_ATTRNAME_ARBITRARY);
			psz = (m_NameType == ILS_ATTRNAME_STANDARD) ?
					(TCHAR *) UlsLdap_GetStdAttrNameString (m_Name.std) :
					m_Name.psz;
			if (psz == NULL)
			{
				hr = ILS_E_POINTER;
				goto MyExit;
			}

			// Add up the string length
			//
			cbSize += lstrlen (psz) * sizeof (TCHAR);

			// Third, add up the equal sign, eg. "~="
			//
			cbSize += sizeof (TCHAR) * 2;

			// Fourth, count for attribute value
			//
			psz = m_pszValue;
			if (psz != NULL)
			{
				cbSize += lstrlen (psz) * sizeof (TCHAR);
			}
		}
		break;

	default:
		ASSERT (FALSE);
		hr = ILS_E_FILTER_TYPE;
		break;
	}

MyExit:

	// Clean up the size if failed
	//
	if (hr != S_OK)
		cbSize = 0;

	// Output the string size
	//
	*pcbStringSize += cbSize;

	return hr;
}


/* ----------------------------------------------------------------------
	CFilter::BuildLdapString

	Input/Output:
		ppszBuf: a pointer to where the next char of the rendering buffer is.

	History:
	12/03/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

HRESULT CFilter::
BuildLdapString ( TCHAR **ppszBuf )
{
	ASSERT (ppszBuf != NULL);

	// A running pointer
	//
	TCHAR *pszCurr = *ppszBuf;
	HRESULT hr = S_OK;

	// First, output "("
	//
	*pszCurr++ = TEXT ('(');

	// Second, output the operator if composite;
	// output the attribute name if simple
	//
	switch (m_Type)
	{
	case ILS_FILTERTYPE_COMPOSITE:
		{
			// Second, Output the operator
			//
			switch (GetOp ())
			{
			case ILS_FILTEROP_AND:
				*pszCurr++ = TEXT ('&');
				break;
			case ILS_FILTEROP_OR:
				*pszCurr++ = TEXT ('|');
				break;
			case ILS_FILTEROP_NOT:
				*pszCurr++ = TEXT ('!');
				break;
			default:
				hr = ILS_E_PARAMETER;
				goto MyExit;
			}

			// Third, enumerate every child
			//
			HANDLE hEnum;
			CFilter *pFilter;
		    m_SubFilters.Enumerate (&hEnum);
		    while (m_SubFilters.Next (&hEnum, (VOID **) &pFilter) == NOERROR)
		    {
		    	if (pFilter != NULL)
		    	{
	    			hr = pFilter->BuildLdapString (&pszCurr);
		    	}
		    	else
		    	{
		    		ASSERT (FALSE);
		    		hr = ILS_E_POINTER;
		    	}

				// Report error if needed
				//
				if (hr != S_OK)
					goto MyExit;
		    } // while
		} // case
		break;

	case ILS_FILTERTYPE_SIMPLE:
		{
			// Second, output attribute name
			//
			ASSERT (m_NameType == ILS_ATTRNAME_STANDARD || m_NameType == ILS_ATTRNAME_ARBITRARY);
			TCHAR *psz = (m_NameType == ILS_ATTRNAME_STANDARD) ?
							(TCHAR *) UlsLdap_GetStdAttrNameString (m_Name.std) :
							m_Name.psz;

			// Copy the attribute name
			//
			lstrcpy (pszCurr, psz);
			pszCurr += lstrlen (pszCurr);

			// Third, copy the comparison sign
			//
			switch (GetOp ())
			{
			case ILS_FILTEROP_EQUAL:
				*pszCurr++ = TEXT ('=');
				break;
			case ILS_FILTEROP_EXIST:
				*pszCurr++ = TEXT ('=');
				*pszCurr++ = TEXT ('*');
				break;
			case ILS_FILTEROP_APPROX:
				*pszCurr++ = TEXT ('~');
				*pszCurr++ = TEXT ('=');
				break;
			case ILS_FILTEROP_LESS_THAN:
				*pszCurr++ = TEXT ('<');
				*pszCurr++ = TEXT ('=');
				break;
			case ILS_FILTEROP_GREATER_THAN:
				*pszCurr++ = TEXT ('>');
				*pszCurr++ = TEXT ('=');
				break;
			default:
				ASSERT (FALSE);
				hr = ILS_E_PARAMETER;
				goto MyExit;
			}

			// Fourth, count for attribute value
			//
			psz = m_pszValue;
			if (psz != NULL)
			{
				lstrcpy (pszCurr, psz);
				pszCurr += lstrlen (pszCurr);
			}
		} // case
		break;

	default:
		ASSERT (FALSE);
		hr = ILS_E_FILTER_TYPE;
		goto MyExit;
	}

	// Finally, output ")"
	//
	*pszCurr++ = TEXT (')');

MyExit:

	// Output where the next char should go
	//
	*pszCurr = TEXT ('\0');
	*ppszBuf = pszCurr;

	return hr;
}


/* ----------------------------------------------------------------------
	CFilter::SetStandardAttributeName

	Input:
		AttrName: An index to identify a standard attribute name.

	History:
	11/12/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

STDMETHODIMP CFilter::
SetStandardAttributeName ( ILS_STD_ATTR_NAME AttrName )
{
	// Make sure we have correct filter type
	//
	if (m_Type != ILS_FILTERTYPE_SIMPLE)
		return ILS_E_FILTER_TYPE;

	// Check standard attributes
	//
	if (((LONG) AttrName <= (LONG) ILS_STDATTR_NULL) ||
		((LONG) AttrName >= (LONG) ILS_NUM_OF_STDATTRS))
		return ILS_E_PARAMETER;

	// Free up the old string if needed
	//
	FreeName ();

	// Set the new standard attribute name
	//
	m_NameType = ILS_ATTRNAME_STANDARD;
	m_Name.std = AttrName;

	return S_OK;
}


/* ----------------------------------------------------------------------
	CFilter::SetExtendedAttributeName

	Input:
		pszAnyAttrName: A pointer to the name of an arbitrary attribute.

	History:
	11/12/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

STDMETHODIMP CFilter::
SetExtendedAttributeName ( BSTR bstrAnyAttrName )
{
	// Make sure we have correct filter type
	//
	if (m_Type != ILS_FILTERTYPE_SIMPLE)
		return ILS_E_FILTER_TYPE;

	// Make sure the string is valid
	//
	if (bstrAnyAttrName == NULL)
		return ILS_E_POINTER;

	HRESULT hr = S_OK;

#ifdef _UNICODE
	hr = SetExtendedAttributeName ((WCHAR *) bstrAnyAttrName);
#else
	TCHAR *pszAnyAttrName = NULL;
	hr = BSTR_to_LPTSTR (&pszAnyAttrName, bstrAnyAttrName);
	if (hr == S_OK)
	{
		ASSERT (pszAnyAttrName != NULL);
		hr = SetExtendedAttributeName (pszAnyAttrName);
		::MemFree(pszAnyAttrName);
	}
#endif

	return hr;
}


HRESULT CFilter::
SetExtendedAttributeName ( TCHAR *pszAnyAttrName )
{
	ASSERT (pszAnyAttrName != NULL);

	// Set the new standard attribute name
	//
	HRESULT hr = S_OK;
	const TCHAR *pszPrefix = UlsLdap_GetExtAttrNamePrefix ();
	ULONG cchPrefix = (pszPrefix != NULL) ? lstrlen (pszPrefix) : 0; // don't put +1 here!!!
	TCHAR *psz = (TCHAR *) MemAlloc ((lstrlen (pszAnyAttrName) + 1 + cchPrefix) * sizeof (TCHAR));
	if (psz != NULL)
	{
		FreeName ();
		m_NameType = ILS_ATTRNAME_ARBITRARY;
		m_Name.psz = psz;
		if (pszPrefix != NULL)
		{
			lstrcpy (psz, pszPrefix);
			psz += cchPrefix;
		}
		lstrcpy (psz, pszAnyAttrName);
	}
	else
	{
		hr = ILS_E_MEMORY;
	}

	return hr;
}


/* ----------------------------------------------------------------------
	CFilter::SetAttributeValue

	Input:
		pszAttrValue: A pointer to the string value of an attribute.

	History:
	11/12/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

STDMETHODIMP CFilter::
SetAttributeValue ( BSTR bstrAttrValue )
{
	// Make sure we have correct filter type
	//
	if (m_Type != ILS_FILTERTYPE_SIMPLE)
		return ILS_E_FILTER_TYPE;

	// Make sure we have valid string
	//
	if (bstrAttrValue == NULL)
		return ILS_E_POINTER;

	HRESULT hr = S_OK;

#ifdef _UNICODE
	hr = SetAttributeValue ((WCHAR *) bstrAttrValue);
#else
	TCHAR *pszAttrValue = NULL;
	hr = BSTR_to_LPTSTR (&pszAttrValue, bstrAttrValue);
	if (hr == S_OK)
	{
		ASSERT (pszAttrValue != NULL);
		hr = SetAttributeValue (pszAttrValue);
		::MemFree(pszAttrValue);
	}
#endif

	return hr;
}


HRESULT CFilter::
SetAttributeValue ( TCHAR *pszAttrValue )
{
	ASSERT (pszAttrValue != NULL);

	// Make a duplicate of the attribute value
	//
	HRESULT hr = S_OK;
	ULONG cch = My_lstrlen (pszAttrValue);
	if (cch < FILTER_INTERNAL_SMALL_BUFFER_SIZE)
	{
		FreeValue ();
		m_pszValue = &m_szInternalValueBuffer[0];
		My_lstrcpy (m_pszValue, pszAttrValue);
	}
	else
	{
		TCHAR *psz = My_strdup (pszAttrValue);
		if (psz != NULL)
		{
			FreeValue ();
			m_pszValue = psz;
		}
		else
		{
			hr = ILS_E_MEMORY;
		}
	}

	return S_OK;
}


/* ----------------------------------------------------------------------
	CFilter::FreeName

	History:
	11/12/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

VOID CFilter::
FreeName ( VOID )
{
	ASSERT (m_Type == ILS_FILTERTYPE_SIMPLE);

	// Free the value field
	//
	if (m_NameType == ILS_ATTRNAME_ARBITRARY)
	{
		MemFree (m_Name.psz);
	}

	// Reset it to zero
	//
	ZeroMemory (&m_Name, sizeof (m_Name));

	// Reset name type
	//
	m_NameType = ILS_ATTRNAME_UNKNOWN;
}


/* ----------------------------------------------------------------------
	CFilter::FreeValue

	History:
	11/12/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

VOID CFilter::
FreeValue ( VOID )
{
	ASSERT (m_Type == ILS_FILTERTYPE_SIMPLE);

	// Free the value field
	//
	if (m_pszValue != &m_szInternalValueBuffer[0])
	{
		MemFree (m_pszValue);
	}

	m_pszValue = NULL;
}




CFilterParser::CFilterParser ( VOID )
:
 m_pszFilter (NULL),
 m_pszCurr (NULL),
 m_TokenType (ILS_TOKEN_NULL),
 m_pszTokenValue (NULL),
 m_nTokenValue (0)
{
}


CFilterParser::~CFilterParser ( VOID )
{
    ::MemFree(m_pszFilter);
}


HRESULT CFilterParser::
Expr ( CFilter **ppOutFilter, TCHAR *pszFilter )
{
	// Make sure we have a valid string
	//
	if (ppOutFilter == NULL || pszFilter == NULL)
		return ILS_E_POINTER;

	// Free old string if any
	//
	MemFree (m_pszFilter); // checking null inside

	// Find out how big the filter string
	//
	ULONG cch = lstrlen (pszFilter) + 1;
	if (cch < 32)
		cch = 32; // make sure we have some decent size of buffer

	// Allocate buffer to keep the filter string
	//
	m_pszFilter = (TCHAR *) MemAlloc (cch * sizeof (TCHAR) * 2);
	if (m_pszFilter == NULL)
		return ILS_E_MEMORY;

	// Copy filter string
	//
	lstrcpy (m_pszFilter, pszFilter);
	m_pszCurr = m_pszFilter;

	// Keep the rest for token value
	//
	m_pszTokenValue = m_pszFilter + cch;
	m_nTokenValue = 0;

	// Call the parser engine
	//
	return Expr (ppOutFilter);
}


HRESULT CFilterParser::
Expr ( CFilter **ppOutFilter )
{
	/* LR(1) Parsing Grammar
		<Expr> 		:=	'(' <Expr> ')' <TailExpr> |
						'!' '(' Expr ')' |
						AttrName EqualOp AttrValue <TailExpr> |
						NULL
		<TailExpr>	:=	RelOp Expr | NULL
		EqualOp		:=	'!=' | '='
		RelOp		:=	'&' | '|' | '!'
		AttrName	:=	'$' Integer | Alphanum
		AttrValue	:=	Alphanum
	 */

	// Clean up first
	//
	ASSERT (ppOutFilter != NULL);
	*ppOutFilter = NULL;
	HRESULT hr = S_OK;
	CFilter *pElement = NULL;

	// Look ahead by 1
	//
	GetToken ();
	switch (m_TokenType)
	{
	case ILS_TOKEN_NOT:
		// Make sure left parenthesis
		//
		GetToken ();
		if (m_TokenType != ILS_TOKEN_LP)
		{
			hr = ILS_E_FILTER_STRING;
			goto MyExit;
		}

		// Fall through
		//

	case ILS_TOKEN_LP:
		// Parse the expression inside parentheses
		//
		hr = Expr (ppOutFilter);
		if (hr != S_OK)
			goto MyExit;

		// See if it is incomplete expr
		//
		if (*ppOutFilter == NULL)
		{
			hr = ILS_E_FILTER_STRING;
			goto MyExit;
		}

		// Make sure right parenthesis ended
		// ILS_TOKEN_RP was taken in TrailExpr()
		//
		if (m_TokenType != ILS_TOKEN_RP)
		{
			hr = ILS_E_FILTER_STRING;
			goto MyExit;
		}

		// Handle TailExpr
		//
		hr = TailExpr (ppOutFilter, *ppOutFilter);
		break;

	case ILS_TOKEN_STDATTR:
	case ILS_TOKEN_LITERAL:
		// Create a simple filter
		//
		pElement = new CFilter (ILS_FILTERTYPE_SIMPLE);
		if (pElement == NULL)
		{
			hr = ILS_E_MEMORY;
			goto MyExit;
		}
		pElement->AddRef ();

		// Set arbitrary attribute name
		//
		hr = (m_TokenType == ILS_TOKEN_STDATTR) ?
				pElement->SetStandardAttributeName ((ILS_STD_ATTR_NAME) m_nTokenValue) :
				pElement->SetExtendedAttributeName (m_pszTokenValue);
		if (hr != S_OK)
		{
			goto MyExit;
		}

		// Must be eq or neq
		//
		GetToken ();
		switch (m_TokenType)
		{
		case ILS_TOKEN_EQ:
		case ILS_TOKEN_NEQ:
			pElement->SetOp ((ILS_FILTER_OP) m_nTokenValue);
			break;
		default:
			hr = ILS_E_FILTER_STRING;
			goto MyExit;
		}

		// Must be literal attribute value
		//
		GetToken ();
		if (m_TokenType != ILS_TOKEN_LITERAL)
		{
			hr = ILS_E_FILTER_STRING;
			goto MyExit;
		}
		hr = pElement->SetAttributeValue (m_pszTokenValue);

		// Handle TailExpr
		//
		hr = TailExpr (ppOutFilter, pElement);
		break;

	case ILS_TOKEN_NULL:
		break;

	default:
		hr = ILS_E_FILTER_STRING;
		break;
	}

MyExit:

	if (hr != S_OK)
	{
		if (pElement != NULL)
			pElement->Release ();

		if (*ppOutFilter != NULL)
			(*ppOutFilter)->Release ();
	}

	return hr;
}


HRESULT CFilterParser::
TailExpr ( CFilter **ppOutFilter, CFilter *pInFilter )
{
	// Clean up first
	//
	ASSERT (ppOutFilter != NULL);
	ASSERT (pInFilter != NULL);
	*ppOutFilter = NULL;
	HRESULT hr = S_OK;

	// Look ahead
	//
	ILS_FILTER_OP FilterOp = ILS_FILTEROP_OR;
	GetToken ();
	switch (m_TokenType)
	{
	case ILS_TOKEN_AND:
		// Change filter op to AND
		//
		FilterOp = ILS_FILTEROP_AND;

		// Fall through
		//

	case ILS_TOKEN_OR:
		// Assume FilterOp is set properly
		//
		ASSERT (FilterOp == ILS_FILTEROP_OR ||
				FilterOp == ILS_FILTEROP_AND);

		// Parse the expr
		//
		hr = Expr (ppOutFilter);
		if (hr != S_OK)
			goto MyExit;

		// See if it is incomplete expr
		//
		if (*ppOutFilter == NULL)
		{
			hr = ILS_E_FILTER_STRING;
			goto MyExit;
		}

		// If the out filter is a composite and has same op,
		//		then re-use the composite
		//		else create a new composite
		//
		if ((*ppOutFilter)->GetType () == ILS_FILTERTYPE_COMPOSITE &&
			(*ppOutFilter)->GetOp ()   == FilterOp)
		{
			// Re-use the composite
			//
			hr = ((CFilter *) (*ppOutFilter))->AddSubFilter (pInFilter);
			if (hr != S_OK)
			{
				goto MyExit;
			}
		}
		else
		{
			// Create a container for in filter and new filter from Expr
			//
			CFilter *pFilter = new CFilter (ILS_FILTERTYPE_COMPOSITE);
			if (pFilter == NULL)
			{
				hr = ILS_E_MEMORY;
				goto MyExit;
			}
			pFilter->AddRef ();

			// Set op
			//
			pFilter->SetOp (FilterOp);

			// Set up membership
			//
			hr = pFilter->AddSubFilter (*ppOutFilter);
			if (hr != S_OK)
			{
				pFilter->Release ();
				goto MyExit;
			}
			hr = pFilter->AddSubFilter (pInFilter);
			if (hr != S_OK)
			{
				pFilter->Release (); // recursively
				*ppOutFilter = NULL;
				goto MyExit;
			}

			// Output this new composite filter
			//
			*ppOutFilter = pFilter;
		}
		break;
		
	case ILS_TOKEN_NOT:
		// Should not have in filter at all
		//
		if (pInFilter != NULL)
		{
			hr = ILS_E_FILTER_STRING;
			goto MyExit;
		}

		// Parse the expr
		//
		hr = Expr (ppOutFilter);
		if (hr != S_OK)
			goto MyExit;

		// If it is incomplete expr
		//
		if (*ppOutFilter == NULL)
		{
			hr = ILS_E_FILTER_STRING;
			goto MyExit;
		}

		// If the out filter is a composite and has same op,
		//		then re-use the composite
		//		else create a new composite
		//
		if ((*ppOutFilter)->GetType () == ILS_FILTERTYPE_COMPOSITE &&
			(*ppOutFilter)->GetOp ()   == ILS_FILTEROP_NOT)
		{
			// Remove the composite due to NOT NOT cancellation
			//
			CFilter *pFilter = NULL;
			hr = (*ppOutFilter)->RemoveAnySubFilter (&pFilter);
			if (hr != S_OK)
			{
				goto MyExit;
			}

			// Make sure we have a valid pFilter
			//
			if (pFilter == NULL)
			{
				hr = ILS_E_FILTER_STRING;
				goto MyExit;
			}

			// Free the old out filter
			//
			(*ppOutFilter)->Release ();

			// Output this filter
			//
			*ppOutFilter = pFilter;
		}
		else
		{
			// Create a container for in filter and new filter from Expr
			//
			CFilter *pFilter = new CFilter (ILS_FILTERTYPE_COMPOSITE);
			if (pFilter == NULL)
			{
				hr = ILS_E_MEMORY;
				goto MyExit;
			}
			pFilter->AddRef ();

			// Set op
			//
			pFilter->SetOp (ILS_FILTEROP_NOT);

			// Set up membership
			//
			hr = pFilter->AddSubFilter (*ppOutFilter);
			if (hr != S_OK)
			{
				pFilter->Release ();
				goto MyExit;
			}

			// Output this new composite filter
			//
			*ppOutFilter = pFilter;
		}
		break;

	case ILS_TOKEN_NULL:
	case ILS_TOKEN_RP:
		// No more expression, in filter is the out filter
		//
		*ppOutFilter = pInFilter;
		break;

	default:
		hr = ILS_E_PARAMETER;
		break;
	}

MyExit:

	if (hr != S_OK)
	{
		if (*ppOutFilter != NULL)
			(*ppOutFilter)->Release ();
	}

	return hr;
}


HRESULT CFilterParser::
GetToken ( VOID )
{
	// Set m_TokenType, m_pszTokenValue, m_nTokenValue
	TCHAR *psz;

	// Clean token
	//
	ASSERT (m_pszTokenValue != NULL);
	m_TokenType = ILS_TOKEN_NULL;
	*m_pszTokenValue = TEXT ('\0');
	m_nTokenValue = 0;

	// Have we finished?
	//
	if (m_pszCurr == NULL)
		return S_OK;

	// Skip any while spaces
	//
	while (::My_isspace (*m_pszCurr))
		m_pszCurr++;

	// Have we finished?
	//
	if (*m_pszCurr == TEXT ('\0'))
		return S_OK;

	// Look at the first character
	//
	HRESULT hr = S_OK;
	switch ((ILS_TOKEN_TYPE) *m_pszCurr)
	{
	case ILS_TOKEN_STDATTR:
		// Set token type
		//
		m_TokenType = ILS_TOKEN_STDATTR;

		// Set token string
		//
		psz = m_pszTokenValue;
		*psz++ = *m_pszCurr++;
		while (*m_pszCurr != TEXT ('\0'))
		{
			if (TEXT ('0') <= *m_pszCurr && *m_pszCurr <= TEXT ('9'))
				*psz++ = *m_pszCurr++;
			else		
				break;
		}
		*psz = TEXT ('\0');

		// Set token value
		//
		m_nTokenValue = ::GetStringLong (m_pszTokenValue + 1);
		break;

	case ILS_TOKEN_LP:
	case ILS_TOKEN_RP:
		// Set token type
		//
		m_TokenType = (ILS_TOKEN_TYPE) *m_pszCurr++;
		break;

	case ILS_TOKEN_EQ:
		// Set token value to be filter op
		//
		m_nTokenValue = (LONG) ILS_FILTEROP_EQUAL;

		// Set token type
		//
		m_TokenType = (ILS_TOKEN_TYPE) *m_pszCurr++;
		break;

	case ILS_TOKEN_APPROX:
		if (m_pszCurr[1] == TEXT ('='))
		{
			// Set token value to be filter op
			//
			m_nTokenValue = (LONG) ILS_FILTEROP_APPROX;

			// Set token type
			//
			m_TokenType = (ILS_TOKEN_TYPE) *m_pszCurr;
			m_pszCurr += 2;
		}
		else
		{
			hr = ILS_E_FILTER_STRING; 
		}
		break;

	case ILS_TOKEN_GE:
		if (m_pszCurr[1] == TEXT ('='))
		{
			// Set token value to be filter op
			//
			m_nTokenValue = (LONG) ILS_FILTEROP_GREATER_THAN;

			// Set token type
			//
			m_TokenType = (ILS_TOKEN_TYPE) *m_pszCurr;
			m_pszCurr += 2;
		}
		else
		{
			hr = ILS_E_FILTER_STRING; 
		}
		break;

	case ILS_TOKEN_LE:
		if (m_pszCurr[1] == TEXT ('='))
		{
			// Set token value to be filter op
			//
			m_nTokenValue = (LONG) ILS_FILTEROP_LESS_THAN;

			// Set token type
			//
			m_TokenType = (ILS_TOKEN_TYPE) *m_pszCurr;
			m_pszCurr += 2;
		}
		else
		{
			hr = ILS_E_FILTER_STRING; 
		}
		break;

	case ILS_TOKEN_AND:
		// Set token value to be filter op
		//
		m_nTokenValue = (LONG) ILS_FILTEROP_AND;

		// Set token type
		//
		m_TokenType = (ILS_TOKEN_TYPE) *m_pszCurr++;
		break;

	case ILS_TOKEN_OR:
		// Set token value to be filter op
		//
		m_nTokenValue = (LONG) ILS_FILTEROP_OR;

		// Set token type
		//
		m_TokenType = (ILS_TOKEN_TYPE) *m_pszCurr++;
		break;

	case ILS_TOKEN_NOT:
		// Look ahead for !=
		//
		if ((ILS_TOKEN_TYPE) *(m_pszCurr+1) == TEXT ('='))
		{
			// Set token type
			//
			m_TokenType = ILS_TOKEN_NEQ;
			m_pszCurr += 2;
		}
		else
		{
			// Set token value to be filter op
			//
			m_nTokenValue = (LONG) ILS_FILTEROP_NOT;

			// Set token type
			//
			m_TokenType = (ILS_TOKEN_TYPE) *m_pszCurr++;
		}
		break;		

	default: // Handle alpha numeric
		{
			// Set token string
			//
			BOOL fStayInLoop = (*m_pszCurr != TEXT ('\0'));
			psz = m_pszTokenValue;
			while (fStayInLoop)
			{
				// Stop only when encountering delimiters such as
				//
				switch (*m_pszCurr)
				{
				case ILS_TOKEN_STDATTR:
				case ILS_TOKEN_LP:
				case ILS_TOKEN_RP:
				case ILS_TOKEN_EQ:
				// case ILS_TOKEN_NEQ: // - is a valid char such as in ms-netmeeting
				case ILS_TOKEN_APPROX:
				case ILS_TOKEN_GE:
				case ILS_TOKEN_LE:
				case ILS_TOKEN_AND:
				case ILS_TOKEN_OR:
				case ILS_TOKEN_NOT:
					fStayInLoop = FALSE;
					break;
				default:
					*psz++ = *m_pszCurr++;
					fStayInLoop = (*m_pszCurr != TEXT ('\0'));
					break;
				}
			}
			*psz = TEXT ('\0');

			// Remove trailing spaces
			//
			psz--;
			while (psz >= m_pszCurr && ::My_isspace (*psz))
				*psz-- = TEXT ('\0');

			// Set token type
			//
			m_TokenType = (*m_pszTokenValue == TEXT ('\0')) ?
								ILS_TOKEN_NULL :
								ILS_TOKEN_LITERAL;
		}
		break;
	}

	return hr;
}



HRESULT FilterToLdapString ( CFilter *pFilter, TCHAR **ppszFilter )
{
	HRESULT hr;

	// Make sure we have valid pointers
	//
	if (pFilter == NULL || ppszFilter == NULL)
		return ILS_E_POINTER;

	// Clean up output
	//
	TCHAR *pszFilter = NULL;

	// Calculate the string size
	//
	ULONG cbSize = 0;
	hr = pFilter->CalcFilterSize (&cbSize);
	if (hr != S_OK)
		goto MyExit;

	// Allocate string buffer
	//
	pszFilter = (TCHAR *) MemAlloc (cbSize);
	if (pszFilter == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Make a copy of pszFilter because
	// FilterToLdapString() will change the value
	//
	TCHAR *pszFilterAux;
	pszFilterAux = pszFilter;

	// Render the filter string
	//
	hr = pFilter->BuildLdapString (&pszFilterAux);

MyExit:

	if (hr != S_OK)
	{
		MemFree (pszFilter);
		pszFilter = NULL;
	}

	*ppszFilter = pszFilter;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\culs.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       culs.cpp
//  Content:    This file contains the ULS object.
//  History:
//      Wed 17-Apr-1996 11:13:54  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#include "ulsp.h"
#include "culs.h"
#include "localusr.h"
#include "attribs.h"
#include "localprt.h"
#include "callback.h"
#include "filter.h"
#include "sputils.h"
#include "ulsmeet.h"

//****************************************************************************
// Constant and static text definition
//****************************************************************************
//
#define ILS_WND_CLASS       TEXT("UserLocationServicesClass")
#define ILS_WND_NAME        TEXT("ULSWnd")
#define ILS_DATABASE_MUTEX  TEXT("User Location Service Database")

//****************************************************************************
// Global Parameters
//****************************************************************************
//
CIlsMain  *g_pCIls   = NULL;
CReqMgr   *g_pReqMgr = NULL;
HWND      g_hwndCulsWindow = NULL;

//****************************************************************************
// Event Notifiers
//****************************************************************************
//
//****************************************************************************
// HRESULT
// OnNotifyEnumUserNamesResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
OnNotifyEnumUserNamesResult (IUnknown *pUnk, void *pv)
{
    CEnumNames  *penum   = NULL;
    PENUMRINFO  peri    = (PENUMRINFO)pv;
    HRESULT     hr      = peri->hResult;

    // Create the enumerator only when there is anything to be enumerated
    //
    if (hr == NOERROR)
    {
        ASSERT (peri->pv != NULL);

        // Create a UserName enumerator
        //
        penum = new CEnumNames;

        if (penum != NULL)
        {
            hr = penum->Init((LPTSTR)peri->pv, peri->cItems);

            if (SUCCEEDED(hr))
            {
                penum->AddRef();
            }
            else
            {
                delete penum;
                penum = NULL;
            };
        }
        else
        {
            hr = ILS_E_MEMORY;
        };
    };

    // Notify the sink object
    //
    ((IIlsNotify*)pUnk)->EnumUserNamesResult(peri->uReqID,
                                             penum != NULL ? 
                                             (IEnumIlsNames *)penum :
                                             NULL,
                                             hr);

    if (penum != NULL)
    {
        penum->Release();
    };
    return hr;
}

//****************************************************************************
// HRESULT
// OnNotifyGetUserResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
OnNotifyGetUserResult (IUnknown *pUnk, void *pv)
{
    POBJRINFO pobjri = (POBJRINFO)pv;

    ((IIlsNotify*)pUnk)->GetUserResult(pobjri->uReqID,
                                       (IIlsUser *)pobjri->pv,
                                       pobjri->hResult);
    return S_OK;
}

//****************************************************************************
// HRESULT
// OnNotifyGetUserResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
HRESULT
OnNotifyGetMeetingPlaceResult (IUnknown *pUnk, void *pv)
{
    POBJRINFO pobjri = (POBJRINFO)pv;

    ((IIlsNotify*)pUnk)->GetMeetingPlaceResult(pobjri->uReqID,
                                       (IIlsMeetingPlace *)pobjri->pv,
                                       pobjri->hResult);
    return S_OK;
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// HRESULT
// OnNotifyEnumUsersResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
OnNotifyEnumUsersResult (IUnknown *pUnk, void *pv)
{
    CEnumUsers *penum   = NULL;
    PENUMRINFO peri     = (PENUMRINFO)pv;
    HRESULT    hr       = peri->hResult;

    if (hr == NOERROR)
    {
        ASSERT (peri->pv != NULL);

        // Create a UserName enumerator
        //
        penum = new CEnumUsers;

        if (penum != NULL)
        {
            hr = penum->Init((CIlsUser **)peri->pv, peri->cItems);

            if (SUCCEEDED(hr))
            {
                penum->AddRef();
            }
            else
            {
                delete penum;
                penum = NULL;
            };
        }
        else
        {
            hr = ILS_E_MEMORY;
        };
    };

    // Notify the sink object
    //
    ((IIlsNotify*)pUnk)->EnumUsersResult(peri->uReqID,
                                         penum != NULL ? 
                                         (IEnumIlsUsers *)penum :
                                         NULL,
                                         hr);

    if (penum != NULL)
    {
        penum->Release();
    };
    return hr;
}

//****************************************************************************
// HRESULT
// OnNotifyEnumMeetingPlacesResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
HRESULT
OnNotifyEnumMeetingPlacesResult (IUnknown *pUnk, void *pv)
{
    CEnumMeetingPlaces *penum   = NULL;
    PENUMRINFO peri     = (PENUMRINFO)pv;
    HRESULT    hr       = peri->hResult;

    if (hr == NOERROR)
    {
        ASSERT (peri->pv != NULL);

        // Create a MeetingPlace enumerator
        //
        penum = new CEnumMeetingPlaces;

        if (penum != NULL)
        {
            // jam it with the data that we got
            hr = penum->Init((CIlsMeetingPlace **)peri->pv, peri->cItems);

            if (SUCCEEDED(hr))
            {
                penum->AddRef();
            }
            else
            {
                delete penum;
                penum = NULL;
            };
        }
        else
        {
            hr = ILS_E_MEMORY;
        };
    };

    // Notify the sink object
    //
    ((IIlsNotify*)pUnk)->EnumMeetingPlacesResult(peri->uReqID,
                                         penum != NULL ? 
                                         (IEnumIlsMeetingPlaces *)penum :
                                         NULL,
                                         hr);

    if (penum != NULL)
    {
        penum->Release();
    };
    return hr;
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// HRESULT
// OnNotifyEnumMeetingPlaceNamesResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
HRESULT
OnNotifyEnumMeetingPlaceNamesResult (IUnknown *pUnk, void *pv)
{
    CEnumNames  *penum   = NULL;
    PENUMRINFO  peri    = (PENUMRINFO)pv;
    HRESULT     hr      = peri->hResult;

    // Create the enumerator only when there is anything to be enumerated
    //
    if (hr == NOERROR)
    {
        ASSERT (peri->pv != NULL);

        // Create a MeetingPlaceName enumerator
        //
        penum = new CEnumNames;

        if (penum != NULL)
        {
            hr = penum->Init((LPTSTR)peri->pv, peri->cItems);

            if (SUCCEEDED(hr))
            {
                penum->AddRef();
            }
            else
            {
                delete penum;
                penum = NULL;
            };
        }
        else
        {
            hr = ILS_E_MEMORY;
        };
    };

    // Notify the sink object
    //
    ((IIlsNotify*)pUnk)->EnumMeetingPlaceNamesResult(peri->uReqID,
                                             penum != NULL ? 
                                             (IEnumIlsNames *)penum :
                                             NULL,
                                             hr);

    if (penum != NULL)
    {
        penum->Release();
    };
    return hr;
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// Class Implementation
//****************************************************************************
//
//****************************************************************************
// CIlsMain::CIls (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CIlsMain::
CIlsMain ( VOID )
:m_cRef (0),
 fInit (FALSE),
 hwndCallback (NULL),
 pConnPt (NULL)
{
    ::EnterCriticalSection (&g_ULSSem);
    g_pCIls = this;
    ::LeaveCriticalSection (&g_ULSSem);
}

//****************************************************************************
// CIlsMain::~CIls (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CIlsMain::
~CIlsMain ( VOID )
{
	ASSERT (m_cRef == 0);

    // Free up resources
    //
    Uninitialize();

    // Release the connection point
    //
    if (pConnPt != NULL)
    {
        pConnPt->ContainerReleased();
        ((IConnectionPoint*)pConnPt)->Release();
    };

    // We are gone now
    //
    ::EnterCriticalSection (&g_ULSSem);
    g_pCIls = NULL;
    ::LeaveCriticalSection (&g_ULSSem);

    return;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMain::Init (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsMain::Init (void)
{
    HRESULT hr;

    // Make the connection point
    //
    pConnPt = new CConnectionPoint (&IID_IIlsNotify,
                                    (IConnectionPointContainer *)this);
    if (pConnPt != NULL)
    {
        ((IConnectionPoint*)pConnPt)->AddRef();
        hr = S_OK;
    }
    else
    {
        hr = ILS_E_MEMORY;
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMain::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsMain::QueryInterface (REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (riid == IID_IIlsMain || riid == IID_IUnknown)
    {
        *ppv = (IIlsMain *) this;
    }
    else
    {
        if (riid == IID_IConnectionPointContainer)
        {
            *ppv = (IConnectionPointContainer *) this;
        };
    };

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        return ILS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CIlsMain::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:14:17  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CIlsMain::AddRef (void)
{
    DllLock();

	MyDebugMsg ((DM_REFCOUNT, "CIlsMain::AddRef: ref=%ld\r\n", m_cRef));
    ::InterlockedIncrement (&m_cRef);
    return (ULONG) m_cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CIlsMain::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:14:26  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CIlsMain::Release (void)
{
    DllRelease();

	ASSERT (m_cRef > 0);

	MyDebugMsg ((DM_REFCOUNT, "CIlsMain::Release: ref=%ld\r\n", m_cRef));
	if (::InterlockedDecrement (&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return (ULONG) m_cRef;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMain::Initialize (BSTR bstrAppName, REFGUID rguid, BSTR bstrMimeType)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsMain::Initialize ()
{
    WNDCLASS wc;
    HRESULT hr;

    if (IsInitialized())
    {
        return ILS_E_FAIL;
    };

    // Activate the services
    //
    hr = ILS_E_FAIL;
    fInit = TRUE;


    // Fill in window class structure with parameters that describe the
    // working window.
    //
    wc.style            = CS_NOCLOSE;
    wc.lpfnWndProc      = ULSNotifyProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = g_hInstance;
    wc.hIcon            = ::LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = ::LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)COLOR_WINDOW;
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = ILS_WND_CLASS;

    if (::RegisterClass(&wc) != 0)
    {
        hwndCallback = ::CreateWindowEx(0L, ILS_WND_CLASS,
                                        ILS_WND_NAME,
                                        WS_OVERLAPPED, 
                                        0, 0, 100, 50,
                                        NULL, NULL, g_hInstance, NULL);
        if (hwndCallback != NULL)
        {
            // Initialize the request manager
            //
            g_pReqMgr = new CReqMgr;

            if (g_pReqMgr != NULL)
            {
                // Initialize the LDAP layer
                //
                hr = ::UlsLdap_Initialize(hwndCallback);

            }
            else
            {
                hr = ILS_E_MEMORY;
            };
        };
    };

    if (FAILED(hr))
    {
        Uninitialize();
    }
    else {

        g_hwndCulsWindow = hwndCallback;

    }

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMain::CreateUser
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP CIlsMain::
CreateUser (
    BSTR    	bstrUserID,
    BSTR    	bstrAppName,
    IIlsUser 	**ppUser)
{
    CIlsUser *plu;
    HRESULT     hr;

	// Make sure ils main is initialized
	//
	if (! IsInitialized ())
	{
		return ILS_E_NOT_INITIALIZED;
	}

    // Validate parameter
    //
    if (ppUser == NULL)
    {
        return ILS_E_POINTER;
    };

    // Assume failure
    //
    *ppUser = NULL;

    //
    // Allocate a new user object
    //
    plu = new CIlsUser;

    if (plu != NULL)
    {
        // Initialize the object
        //
        hr = plu->Init(bstrUserID, bstrAppName);

        if (SUCCEEDED(hr))
        {
            *ppUser = (IIlsUser *)plu;
            (*ppUser)->AddRef();
        }
        else
        {
            delete plu;
        };
    }
    else
    {
        hr = ILS_E_MEMORY;
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMain::Uninitialize (void)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsMain::Uninitialize (void)
{
	// Make sure ils main is initialized
	//
	if (! IsInitialized ())
	{
		return ILS_E_NOT_INITIALIZED;
	}

    // Uninitialize the LDAP layer
    //
    ::UlsLdap_Deinitialize();

    // Remove the request manager
    //
    if (g_pReqMgr != NULL)
    {
        delete g_pReqMgr;
        g_pReqMgr = NULL;
    };

    // Clear the callback window
    //
    if (hwndCallback != NULL)
    {
        ::DestroyWindow(hwndCallback);
        hwndCallback = NULL;
    };
    ::UnregisterClass(ILS_WND_CLASS, g_hInstance);

    // Flag that is is uninitialized
    //
    fInit = FALSE;

    return S_OK;
};

//****************************************************************************
// STDMETHODIMP
// CIlsMain::NotifySink (void *pv, CONN_NOTIFYPROC pfn)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsMain::NotifySink (void *pv, CONN_NOTIFYPROC pfn)
{
    HRESULT hr = S_OK;

    if (pConnPt != NULL)
    {
        hr = pConnPt->Notify(pv, pfn);
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMain::CreateAttributes (ILS_ACCESS_CONTROL AccessControl, IIlsAttributes **ppAttributes)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//  12/05/96 -by- Chu, Lon-Chan [lonchanc]
// Added access control.
//****************************************************************************

STDMETHODIMP CIlsMain::
CreateAttributes ( ILS_ATTR_TYPE AttrType, IIlsAttributes **ppAttributes )
{
	// Make sure ils main is initialized
	//
	if (! IsInitialized ())
	{
		return ILS_E_NOT_INITIALIZED;
	}

    CAttributes *pa;
    HRESULT hr;

    // Validate parameter
    //
    if (ppAttributes == NULL)
    {
        return ILS_E_POINTER;
    };

	// Validate access control
	//
	if (AttrType != ILS_ATTRTYPE_NAME_ONLY &&
		AttrType != ILS_ATTRTYPE_NAME_VALUE)
		return ILS_E_PARAMETER;

    // Assume failure
    //
    *ppAttributes = NULL;

    // Allocate an attributes object
    //
    pa = new CAttributes;
    if (pa != NULL)
    {
    	pa->SetAccessType (AttrType);
        pa->AddRef();
        *ppAttributes = pa;
        hr = NOERROR;
    }
    else
    {
        hr = ILS_E_MEMORY;
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMain::GetUser (BSTR bstrServerName, BSTR bstrUserID,
//                ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP CIlsMain::
GetUser (
	IIlsServer		*pIlsServer,
	BSTR			bstrUserID,
	BSTR			bstrAppID,
	BSTR			bstrProtID,
	IIlsAttributes	*pAttrib,
	IIlsUser		**ppUser,
	ULONG			*puReqID )
{
	// Make sure ils main is initialized
	//
	if (! IsInitialized ())
	{
		return ILS_E_NOT_INITIALIZED;
	}

    LDAP_ASYNCINFO ldai; 
    HRESULT hr;

	// We do not implement synchronous operation
	//
	if (ppUser != NULL)
		return ILS_E_NOT_IMPL;

    // Validate parameters
    //
	if (::MyIsBadServer (pIlsServer) || bstrUserID == NULL || puReqID == NULL)
        return ILS_E_POINTER;

	// Clone the server object
	//
	pIlsServer = ((CIlsServer *) pIlsServer)->Clone ();
	if (pIlsServer == NULL)
		return ILS_E_MEMORY;

	// Get a list of extended attribute names
	//
    TCHAR *pszList = NULL;
    ULONG cList =0, cbList = 0;
    if (pAttrib != NULL)
    {
        hr = ((CAttributes *) pAttrib)->GetAttributeList (&pszList, &cList, &cbList);
        if (FAILED (hr))
        {
        	pIlsServer->Release ();
        	return hr;
        }
    }

	// Initialize locals
	//
    TCHAR *pszUserID = NULL, *pszAppID = NULL, *pszProtID = NULL;

    // Get from the specified server
    //
    hr = BSTR_to_LPTSTR(&pszUserID, bstrUserID);
    if (FAILED (hr))
		goto MyExit;

	// Get the app id if given
	//
	if (bstrAppID != NULL)
	{
        hr = BSTR_to_LPTSTR (&pszAppID, bstrAppID);
        if (FAILED (hr))
			goto MyExit;
	}

	// Get the protocol id if given
	//
	if (bstrProtID != NULL)
	{
        hr = BSTR_to_LPTSTR (&pszProtID, bstrProtID);
        if (FAILED (hr))
			goto MyExit;
	}

    hr = ::UlsLdap_ResolveClient (((CIlsServer *) pIlsServer)->GetServerInfo (),
            						pszUserID,
            						pszAppID,
            						pszProtID,
            						pszList,
            						cList,
            						&ldai);

    if (SUCCEEDED(hr))
    {
	    COM_REQ_INFO ri;
	    ReqInfo_Init (&ri);

        // If updating server was successfully requested, wait for the response
        //
        ri.uReqType = WM_ILS_RESOLVE_CLIENT;
        ri.uMsgID = ldai.uMsgID;

        ReqInfo_SetMain (&ri, this);

		ReqInfo_SetServer (&ri, pIlsServer);
		pIlsServer->AddRef ();

        hr = g_pReqMgr->NewRequest(&ri);
        if (SUCCEEDED(hr))
        {
            // Make sure the objects do not disappear before we get the response
            //
            this->AddRef();

            // Return the request ID
            //
            *puReqID = ri.uReqID;
        }
    };

MyExit:

	// Release the server object
	//
   	pIlsServer->Release ();

	// Free the list of extended attribute names
	//
	::MemFree (pszList);

	// Free the names
	::MemFree (pszUserID);
	::MemFree (pszAppID);
	::MemFree (pszProtID);

	return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMain::GetUserResult (ULONG uReqID, PLDAP_CLIENTINFO_RES puir,
//                      LPTSTR szServer)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsMain::GetUserResult (ULONG uReqID, PLDAP_CLIENTINFO_RES puir,
                     CIlsServer *pIlsServer)
{
    CIlsUser *pu;
    OBJRINFO objri;

    // Default to the server's result
    //
    objri.hResult = (puir != NULL) ? puir->hResult : ILS_E_MEMORY;

    if (SUCCEEDED(objri.hResult))
    {
    	ASSERT (! MyIsBadServer (pIlsServer));

        // The server returns CLIENTINFO, create a User object
        //
        pu = new CIlsUser;

        if (pu != NULL)
        {
            objri.hResult = pu->Init(pIlsServer, &puir->lci);
            if (SUCCEEDED(objri.hResult))
            {
                pu->AddRef();
            }
            else
            {
                delete pu;
                pu = NULL;
            };
        }
        else
        {
            objri.hResult = ILS_E_MEMORY;
        };
    }
    else
    {
        pu = NULL;
    };
    // Package the notification info
    //
    objri.uReqID = uReqID;
    objri.pv = (void *)(pu == NULL ? NULL : (IIlsUser *)pu);
    NotifySink((void *)&objri, OnNotifyGetUserResult);

    if (pu != NULL)
    {
        pu->Release();
    };
    return NOERROR;
}


//****************************************************************************
// STDMETHODIMP
// CIlsMain::EnumUserNames (BSTR bstrServerName, IIlsFilter *pFilter,
//                      ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CIlsMain::
EnumUsersEx (
	BOOL		    fNameOnly,
	CIlsServer		*pIlsServer,
	IIlsFilter	    *pFilter,
    CAttributes		*pAttrib,
	ULONG		    *puReqID )
{
    LDAP_ASYNCINFO ldai; 
    HRESULT hr;

    // Validate parameter
    //
    if (::MyIsBadServer (pIlsServer) || puReqID == NULL)
        return ILS_E_POINTER;

	// Clone the server object
	//
	pIlsServer = ((CIlsServer *) pIlsServer)->Clone ();
	if (pIlsServer == NULL)
		return ILS_E_MEMORY;

	// Get a list of extended attribute names
	//
    TCHAR *pszList = NULL;
    ULONG cList =0, cbList = 0;
    if (pAttrib != NULL)
    {
        ASSERT (!fNameOnly);

        hr = pAttrib->GetAttributeList(&pszList, &cList, &cbList);
        if (FAILED(hr))
        {
        	pIlsServer->Release ();
        	return hr;
        }
    }

	// Construct default filter if needed
	//
	TCHAR *pszFilter = NULL;
	BOOL fDefaultRenderer = FALSE;
    if (pFilter == NULL)
    {
    	// Build default filter string
    	//
		TCHAR szLocalFilter[32];
    	wsprintf (&szLocalFilter[0], TEXT ("($%u=*)"), (UINT) ILS_STDATTR_USER_ID);

		// Render this filter
		//
		hr = StringToFilter (&szLocalFilter[0], (CFilter **) &pFilter);
		if (! SUCCEEDED (hr))
			goto MyExit;

		// Indicate we have default filter string
		//
		fDefaultRenderer = TRUE;
	}

	// Create a ldap-like filter
	//
	hr = ::FilterToLdapString ((CFilter *) pFilter, &pszFilter);
	if (hr != S_OK)
		goto MyExit;

	// Enumerate users
	//
    hr = fNameOnly ?	::UlsLdap_EnumClients (pIlsServer->GetServerInfo (),
    											pszFilter,
    											&ldai) :
						::UlsLdap_EnumClientInfos (pIlsServer->GetServerInfo (),
													pszList,
													cList,
													pszFilter,
													&ldai);
	if (hr != S_OK)
		goto MyExit;

	// If updating server was successfully requested, wait for the response
	//
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

	ri.uReqType = fNameOnly ? WM_ILS_ENUM_CLIENTS : WM_ILS_ENUM_CLIENTINFOS;
	ri.uMsgID   = ldai.uMsgID;

	ReqInfo_SetMain (&ri, this);

    if (! fNameOnly)
    {
    	ReqInfo_SetServer (&ri, pIlsServer);
		pIlsServer->AddRef ();
	}

	// Remember this request
	//
	hr = g_pReqMgr->NewRequest (&ri);

	if (hr == S_OK)
	{
	    // Make sure the objects do not disappear before we get the response
	    //
		this->AddRef ();

	    // Return the request ID
	    //
	    *puReqID = ri.uReqID;
	}

MyExit:

	// Release server object
	//
	pIlsServer->Release ();

	// Free the filter string
	//
	::MemFree (pszFilter);

	// Release default filter if needed
	//
    if (fDefaultRenderer && pFilter != NULL)
    	pFilter->Release ();

	// Free the list of extended attribute names
	//
    ::MemFree (pszList);

    return hr;
}


STDMETHODIMP
CIlsMain::EnumUserNames (
	IIlsServer		*pIlsServer,
	IIlsFilter		*pFilter,
    IEnumIlsNames   **ppEnumUserNames,
	ULONG			*puReqID )
{
	// Make sure ils main is initialized
	//
	if (! IsInitialized ())
	{
		return ILS_E_NOT_INITIALIZED;
	}

	// We do not implement synchronous operation
	//
	if (ppEnumUserNames != NULL)
		return ILS_E_NOT_IMPL;

	return EnumUsersEx (TRUE,
						(CIlsServer *) pIlsServer,
						pFilter,
						NULL,
						puReqID);
}


//****************************************************************************
// STDMETHODIMP
// CIlsMain::EnumUserNamesResult (ULONG uReqID, PLDAP_ENUM ple)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsMain::EnumUserNamesResult (ULONG uReqID, PLDAP_ENUM ple)
{
    ENUMRINFO eri;

    // Package the notification info
    //
    eri.uReqID  = uReqID;

    // PLDAP_ENUM is NULL when the enumeration is terminated successfully
    //
    if (ple != NULL)
    {
        eri.hResult = ple->hResult;
        eri.cItems  = ple->cItems;
        eri.pv      = (void *)(((PBYTE)ple)+ple->uOffsetItems);
    }
    else
    {
        eri.hResult = S_FALSE;
        eri.cItems  = 0;
        eri.pv      = NULL;
    };
    NotifySink((void *)&eri, OnNotifyEnumUserNamesResult);
    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMain::EnumUsers (BSTR bstrServerName, IIlsFilter *pFilter,
//                  ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP CIlsMain::
EnumUsers (
	IIlsServer		*pIlsServer,
	IIlsFilter		*pFilter,
	IIlsAttributes	*pAttrib,
	IEnumIlsUsers	**ppEnumUsers,
	ULONG			*puReqID)
{
	// Make sure ils main is initialized
	//
	if (! IsInitialized ())
	{
		return ILS_E_NOT_INITIALIZED;
	}

	// We do not implement synchronous operation
	//
	if (ppEnumUsers != NULL)
		return ILS_E_NOT_IMPL;

	return EnumUsersEx (FALSE,
						(CIlsServer *) pIlsServer,
						pFilter,
						(CAttributes *) pAttrib,
						puReqID);
}

//****************************************************************************
// STDMETHODIMP
// CIlsMain::EnumUsersResult (ULONG uReqID, PLDAP_ENUM ple, LPTSTR szServer)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsMain::EnumUsersResult (ULONG uReqID, PLDAP_ENUM ple, CIlsServer *pIlsServer)
{
    CIlsUser **ppu;
    ULONG   cUsers;
    ENUMRINFO eri;
    HRESULT hr;

    if (ple != NULL)
    {
        eri.hResult = ple->hResult;
        cUsers = ple->cItems;
    }
    else
    {
        eri.hResult = S_FALSE;
        cUsers = 0;
    };
    eri.uReqID = uReqID;
    eri.cItems = 0;

    if ((eri.hResult == NOERROR) && (cUsers != 0))
    {
    	ASSERT (! MyIsBadServer (pIlsServer));

        // Build an array of User objects here
        //
        ppu = (CIlsUser **) ::MemAlloc (cUsers*sizeof(CIlsUser *));

        if (ppu != NULL)
        {
            CIlsUser       *pu;
            PLDAP_CLIENTINFO pui;
            ULONG          i;

            // Build one User object at a time
            //
            pui = (PLDAP_CLIENTINFO)(((PBYTE)ple)+ple->uOffsetItems);

            for (i = 0; i < cUsers; i++)
            {
                pu = new CIlsUser;

                if (pu != NULL)
                {
                    if (SUCCEEDED(pu->Init(pIlsServer, pui)))
                    {
                        pu->AddRef();
                        ppu[eri.cItems++] = pu;
                    }
                    else
                    {
                        delete pu;
                    };
                };
                pui++;
            };
        }
        else
        {
            eri.hResult = ILS_E_MEMORY;
        };
    }
    else
    {
        ppu = NULL;
    };

    // Package the notification info
    //
    eri.pv = (void *)ppu;
    NotifySink((void *)&eri, OnNotifyEnumUsersResult);

    // Free the resources
    //
    if (ppu != NULL)
    {
        for (; eri.cItems; eri.cItems--)
        {
            ppu[eri.cItems-1]->Release();
        };
        ::MemFree (ppu);
    };
    return NOERROR;
}


//****************************************************************************
// STDMETHODIMP
// CIlsMain::CreateMeetingPlace (BSTR bstrMeetingPlaceID, LONG lConfType, LONG lMemberType,
//                              IIlsMeetingPlace  **ppMeetingPlace);    
//
//
// History:
//  
// Created.
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
STDMETHODIMP
CIlsMain::CreateMeetingPlace (
    BSTR bstrMeetingPlaceID,
    LONG lConfType,
    LONG lMemberType,
    IIlsMeetingPlace  **ppMeetingPlace)
{
	// Make sure ils main is initialized
	//
	if (! IsInitialized ())
	{
		return ILS_E_NOT_INITIALIZED;
	}

    CIlsMeetingPlace *pCcr = NULL;
    HRESULT hr;

    // we are just createing a place holder object which when registered
    // will be visible by other users

	if (ppMeetingPlace == NULL || bstrMeetingPlaceID == NULL)
	{
		return ILS_E_POINTER;
	}

    *ppMeetingPlace = NULL;
    pCcr = new CIlsMeetingPlace;

    if (pCcr != NULL )
    {
        // succeeded in createing the object
        hr = pCcr->Init(bstrMeetingPlaceID, lConfType, lConfType);
        if (SUCCEEDED(hr))
        {
            *ppMeetingPlace = (IIlsMeetingPlace *) pCcr;
            (*ppMeetingPlace)->AddRef ();
        }
        else
        {
            delete pCcr;
        }
    }
    else
    {
        hr = ILS_E_MEMORY;
    }
    
    return (hr);
}
#endif // ENABLE_MEETING_PLACE


//****************************************************************************
// STDMETHODIMP
// CIlsMain::GetMeetingPlace (BSTR bstrServerName, BSTR bstrMeetingPlaceID, ULONG *puReqID)
//
// History:
// Created.
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
STDMETHODIMP CIlsMain::
GetMeetingPlace (
	IIlsServer			*pIlsServer,
	BSTR				bstrMeetingPlaceID,
	IIlsAttributes		*pAttrib,
	IIlsMeetingPlace	**ppMeetingPlace,
	ULONG				*puReqID)
{
	// Make sure ils main is initialized
	//
	if (! IsInitialized ())
	{
		return ILS_E_NOT_INITIALIZED;
	}

    LDAP_ASYNCINFO ldai; 
    LPTSTR pszMtgID = NULL;
    HRESULT hr;

	// We do not implement synchronous operation
	//
	if (ppMeetingPlace != NULL)
		return ILS_E_NOT_IMPL;

    // Validate parameters
    //
	if (::MyIsBadServer (pIlsServer) || bstrMeetingPlaceID == NULL || puReqID == NULL)
        return ILS_E_POINTER;

	// Clone the server object
	//
	pIlsServer = ((CIlsServer *) pIlsServer)->Clone ();
	if (pIlsServer == NULL)
		return ILS_E_MEMORY;

	// Get a list of extended attribute names
	//
    TCHAR *pszList = NULL;
    ULONG cList =0, cbList = 0;
    if (pAttrib != NULL)
    {
        hr = ((CAttributes *) pAttrib)->GetAttributeList (&pszList, &cList, &cbList);
        if (FAILED (hr))
        {
        	pIlsServer->Release ();
        	return hr;
        }
    }

    // Get from the specified server
    //
    hr = BSTR_to_LPTSTR(&pszMtgID, bstrMeetingPlaceID);
    if (SUCCEEDED(hr))
    {
        // BUGBUG AppID not given
        hr = ::UlsLdap_ResolveMeeting (((CIlsServer *) pIlsServer)->GetServerInfo (),
        								pszMtgID,
        								pszList,
        								cList,
        								&ldai);

        if (SUCCEEDED(hr))
        {
		    COM_REQ_INFO ri;
		    ReqInfo_Init (&ri);

            // If updating server was successfully requested, wait for the response
            //
            ri.uReqType = WM_ILS_RESOLVE_MEETING;
            ri.uMsgID = ldai.uMsgID;

            ReqInfo_SetMain (&ri, this);

            ReqInfo_SetServer (&ri, pIlsServer);
            pIlsServer->AddRef ();

            hr = g_pReqMgr->NewRequest(&ri);
            if (SUCCEEDED(hr))
            {
                // Make sure the objects do not disappear before we get the response
                //
                this->AddRef();

                // Return the request ID
                //
                *puReqID = ri.uReqID;
            }
        };
        ::MemFree (pszMtgID);
    };

	// Release the server object
	//
	pIlsServer->Release ();

	// Free the list of extended attribute names
	//
	::MemFree (pszList);

    return hr;
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// HRESULT
// CIlsMain::GetMeetingPlaceResult (ULONG uReqID, LDAP_MEETINFO_RES pmir,
//                      LPTSTR szServer)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
HRESULT CIlsMain::
GetMeetingPlaceResult (ULONG uReqID, PLDAP_MEETINFO_RES pmir, CIlsServer *pIlsServer)
{
    CIlsMeetingPlace *pm;
    OBJRINFO objri;

    // Default to the server's result
    //
    objri.hResult = (pmir != NULL) ? pmir->hResult : ILS_E_MEMORY;
    if (SUCCEEDED (objri.hResult))
    {
    	ASSERT (! MyIsBadServer (pIlsServer));

        // The server returns CLIENTINFO, create a User object
        //
        pm = new CIlsMeetingPlace;
        if (pm != NULL)
        {
            objri.hResult = pm->Init (pIlsServer, &(pmir->lmi));
            if (SUCCEEDED (objri.hResult))
            {
                pm->AddRef();
            }
            else
            {
                delete pm;
                pm = NULL;
            };
        }
        else
        {
            objri.hResult = ILS_E_MEMORY;
        };
    }
    else
    {
        pm = NULL;
    };

    // Package the notification info
    //
    objri.uReqID = uReqID;
    objri.pv = (void *) (pm == NULL ? NULL : (IIlsMeetingPlace *) pm);
    NotifySink ((void *) &objri, OnNotifyGetMeetingPlaceResult);

    if (pm != NULL)
        pm->Release();

    return NOERROR;
}
#endif // ENABLE_MEETING_PLACE


//****************************************************************************
// STDMETHODIMP
// CIlsMain::EnumMeetingPlaces (BSTR bstrServerName, IIlsFilter *pFilter,
//                   IIlsAttributes *pAttributes, ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
HRESULT CIlsMain::
EnumMeetingPlacesEx (
	BOOL					fNameOnly,
	CIlsServer				*pIlsServer,
	IIlsFilter				*pFilter,
	CAttributes				*pAttrib,
	ULONG					*puReqID)
{
    LDAP_ASYNCINFO ldai; 
    HRESULT hr;

    // Validate parameter
    //
    if (::MyIsBadServer (pIlsServer) || puReqID == NULL)
        return ILS_E_POINTER;

    if (pFilter != NULL)
        return ILS_E_PARAMETER;

	// Clone the server object
	//
	pIlsServer = ((CIlsServer *) pIlsServer)->Clone ();
	if (pIlsServer == NULL)
		return ILS_E_MEMORY;

	// Get a list of extended attribute names
	//
    TCHAR *pszList = NULL;
    ULONG cList =0, cbList = 0;
    if (pAttrib != NULL)
    {
        hr = ((CAttributes *) pAttrib)->GetAttributeList (&pszList, &cList, &cbList);
        if (FAILED (hr))
        {
        	pIlsServer->Release ();
        	return hr;
        }
    }

	// Construct default filter if needed
	//
	TCHAR *pszFilter = NULL;
	BOOL fDefaultRenderer = FALSE;
    if (pFilter == NULL)
    {
    	// Build default filter string
    	//
		TCHAR szLocalFilter[256];
    	wsprintf (&szLocalFilter[0], TEXT ("($%u=*)"), (INT) ILS_STDATTR_MEETING_ID );

		// Render this filter
		//
		hr = StringToFilter (&szLocalFilter[0], (CFilter **) &pFilter);
		if (! SUCCEEDED (hr))
			goto MyExit;

		// Indicate we have default filter string
		//
		fDefaultRenderer = TRUE;
	}

	// Create a ldap-like filter
	//
	hr = ::FilterToLdapString ((CFilter *) pFilter, &pszFilter);
	if (hr != S_OK)
		goto MyExit;

	// Enum meeting places
	//
    hr = fNameOnly ?	::UlsLdap_EnumMeetings (pIlsServer->GetServerInfo (),
    											pszFilter,
    											&ldai) :
						::UlsLdap_EnumMeetingInfos (pIlsServer->GetServerInfo (),
    												pszList,
    												cList,
			    									pszFilter,
			    									&ldai);
    if (SUCCEEDED(hr))
    {
	    COM_REQ_INFO ri;
	    ReqInfo_Init (&ri);

        // If updating server was successfully requested, wait for the response
        //
        ri.uReqType = fNameOnly ? WM_ILS_ENUM_MEETINGS : WM_ILS_ENUM_MEETINGINFOS;
        ri.uMsgID = ldai.uMsgID;

		ReqInfo_SetMain (&ri, this);

        if (! fNameOnly)
        {
        	ReqInfo_SetServer (&ri, pIlsServer);
			pIlsServer->AddRef ();
		}

        hr = g_pReqMgr->NewRequest(&ri);
        if (SUCCEEDED(hr))
        {
            // Make sure the objects do not disappear before we get the response
            //
            this->AddRef();

            // Return the request ID
            //
            *puReqID = ri.uReqID;
        };
    };

MyExit:

	// Free the server object
	//
	pIlsServer->Release ();

	// Free the list of extended attribute names
	//
	::MemFree (pszList);

	// Free the filter string
	//
	::MemFree (pszFilter);

	// Release default filter if needed
	//
    if (fDefaultRenderer && pFilter != NULL)
    	pFilter->Release ();

    return hr;
}
#endif // ENABLE_MEETING_PLACE


#ifdef ENABLE_MEETING_PLACE
STDMETHODIMP CIlsMain::
EnumMeetingPlaces (
	IIlsServer				*pServer,
	IIlsFilter				*pFilter,
	IIlsAttributes			*pAttributes,
	IEnumIlsMeetingPlaces	**ppEnum,
	ULONG					*puReqID)
{
	// Make sure ils main is initialized
	//
	if (! IsInitialized ())
	{
		return ILS_E_NOT_INITIALIZED;
	}

	// We do not implement synchronous operation
	//
	if (ppEnum != NULL)
		return ILS_E_NOT_IMPL;

 	return EnumMeetingPlacesEx (FALSE,
 								(CIlsServer *) pServer,
								pFilter,
								(CAttributes *) pAttributes,
								puReqID);
}
#endif // ENABLE_MEETING_PLACE


//****************************************************************************
// HRESULT
// CIlsMain::EnumMeetingPlacesResult (ULONG uReqID, PLDAP_ENUM ple, LPTSTR szServer)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
HRESULT
CIlsMain::EnumMeetingPlacesResult (ULONG uReqID, PLDAP_ENUM ple, CIlsServer *pIlsServer)
{
    CIlsMeetingPlace **ppm;
    ULONG   cMeetingPlaces;
    ENUMRINFO eri;
    HRESULT hr;

    if (ple != NULL)
    {
        eri.hResult = ple->hResult;
        cMeetingPlaces = ple->cItems;
    }
    else
    {
        eri.hResult = S_FALSE;
        cMeetingPlaces = 0;
    };
    eri.uReqID = uReqID;
    eri.cItems = 0;

    if ((eri.hResult == NOERROR) && (cMeetingPlaces != 0))
    {
		ASSERT (! MyIsBadServer (pIlsServer));

        // Build an array of MeetingPlace objects here
        //
        ppm = (CIlsMeetingPlace **) ::MemAlloc (cMeetingPlaces*sizeof(CIlsMeetingPlace *));

        if (ppm != NULL)
        {
            CIlsMeetingPlace       *pm;
            PLDAP_MEETINFO pmi;
            ULONG          i;

            
            // Build one MeetingPlace object at a time
            //
            pmi = (PLDAP_MEETINFO)(((PBYTE)ple)+ple->uOffsetItems);

            for (i = 0; i < cMeetingPlaces; i++)
            {
                pm = new CIlsMeetingPlace;

                if (pm != NULL)
                {
                    if (SUCCEEDED(pm->Init(pIlsServer, pmi)))
                    {
                        pm->AddRef();
                        ppm[eri.cItems++] = pm;
                    }
                    else
                    {
                        delete pm;
                    };
                };
                pmi++;
            };
        }
        else
        {
            eri.hResult = ILS_E_MEMORY;
        };
    }
    else
    {
        ppm = NULL;
    };

    // Package the notification info
    //
    eri.pv = (void *)ppm;
    NotifySink((void *)&eri, OnNotifyEnumMeetingPlacesResult);

    // Free the resources
    //
    if (ppm != NULL)
    {
        for (; eri.cItems; eri.cItems--)
        {
            ppm[eri.cItems-1]->Release();
        };
        ::MemFree (ppm);
    };
    return NOERROR;
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// STDMETHODIMP
// CIlsMain::EnumMeetingPlaceNames (BSTR bstrServerName, IIlsFilter *pFilter,
//                      ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
STDMETHODIMP CIlsMain::
EnumMeetingPlaceNames (
	IIlsServer		*pServer,
	IIlsFilter		*pFilter,
	IEnumIlsNames	**ppEnum,
	ULONG			*puReqID)
{
	// Make sure ils main is initialized
	//
	if (! IsInitialized ())
	{
		return ILS_E_NOT_INITIALIZED;
	}

	// We do not implement synchronous operation
	//
	if (ppEnum != NULL)
		return ILS_E_NOT_IMPL;

 	return EnumMeetingPlacesEx (TRUE,
 								(CIlsServer *) pServer,
								pFilter,
								NULL,
								puReqID);
}
#endif // ENABLE_MEETING_PLACE


//****************************************************************************
// HRESULT
// CIlsMain::EnumMeetingPlaceNamesResult (ULONG uReqID, PLDAP_ENUM ple)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
HRESULT
CIlsMain::EnumMeetingPlaceNamesResult (ULONG uReqID, PLDAP_ENUM ple)
{
    ENUMRINFO eri;

    // Package the notification info
    //
    eri.uReqID  = uReqID;

    // PLDAP_ENUM is NULL when the enumeration is terminated successfully
    //
    if (ple != NULL)
    {
        eri.hResult = ple->hResult;
        eri.cItems  = ple->cItems;
        eri.pv      = (void *)(((PBYTE)ple)+ple->uOffsetItems);
    }
    else
    {
        eri.hResult = S_FALSE;
        eri.cItems  = 0;
        eri.pv      = NULL;
    };
    NotifySink((void *)&eri, OnNotifyEnumMeetingPlaceNamesResult);
    return NOERROR;
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// STDMETHODIMP
// CIlsMain::Abort (ULONG uReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsMain::Abort (ULONG uReqID)
{
	// Make sure ils main is initialized
	//
	if (! IsInitialized ())
	{
		return ILS_E_NOT_INITIALIZED;
	}

    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    BOOL    fServerReq;
    HRESULT hr;

    // Look for the matching request information
    //
    ri.uReqID = uReqID;
    ri.uMsgID = 0; 
    hr = g_pReqMgr->GetRequestInfo(&ri);

    if (FAILED(hr))
    {
        return ILS_E_PARAMETER;
    };

    // Determine the request type
    //
    hr = NOERROR;
    switch(ri.uReqType)
    {
        //*************************************************************************
        // Fail if it is register request.
        // Cancelling register request must be done through unregister
        //*************************************************************************
        //
        case WM_ILS_LOCAL_REGISTER:
        case WM_ILS_LOCAL_UNREGISTER:
            return ILS_E_FAIL;

        //*************************************************************************
        // These requests are parts of register, they should not be exposed to
        // the caller.
        //*************************************************************************
        //
        case WM_ILS_REGISTER_CLIENT:
        case WM_ILS_UNREGISTER_CLIENT:
            ASSERT(0);
            break;

        //*************************************************************************
        // Release the objects and resources refernced or allocated for the request
        // See callback.cpp for the handler in the successful response case
        //*************************************************************************
        //
        case WM_ILS_REGISTER_PROTOCOL:
        case WM_ILS_UNREGISTER_PROTOCOL:
        case WM_ILS_LOCAL_REGISTER_PROTOCOL:
        case WM_ILS_LOCAL_UNREGISTER_PROTOCOL:
			{
				CIlsUser *pUser = ReqInfo_GetUser (&ri);
				if (pUser != NULL)
					pUser->Release ();

				CLocalProt *pProtocol = ReqInfo_GetProtocol (&ri);
				if (pProtocol != NULL)
					pProtocol->Release ();
            }
            break;

        case WM_ILS_SET_CLIENT_INFO:
        case WM_ILS_ENUM_PROTOCOLS:
        case WM_ILS_RESOLVE_PROTOCOL:
			{
				CIlsUser *pUser = ReqInfo_GetUser (&ri);
				if (pUser != NULL)
					pUser->Release ();
			}
            break;

        case WM_ILS_ENUM_CLIENTS:
			{
				CIlsMain *pMain = ReqInfo_GetMain (&ri);
				if (pMain != NULL)
					pMain->Release ();
			}
            break;

        case WM_ILS_RESOLVE_CLIENT:
        case WM_ILS_ENUM_CLIENTINFOS:
			{
				CIlsMain *pMain = ReqInfo_GetMain (&ri);
				if (pMain != NULL)
					pMain->Release ();

				CIlsServer *pServer = ReqInfo_GetServer (&ri);
				if (pServer != NULL)
					pServer->Release ();
			}
            break;


        //*************************************************************************
        // Fail if it is register request.
        // Cancelling register request must be done through unregister
        //*************************************************************************
        //
#ifdef ENABLE_MEETING_PLACE
		case WM_ILS_REGISTER_MEETING:
		case WM_ILS_UNREGISTER_MEETING:
            return ILS_E_FAIL;

		case WM_ILS_SET_MEETING_INFO:
		case WM_ILS_ADD_ATTENDEE:
		case WM_ILS_REMOVE_ATTENDEE:
		case WM_ILS_ENUM_ATTENDEES:
			{
				CIlsMeetingPlace *pMeeting = ReqInfo_GetMeeting (&ri);
				if (pMeeting != NULL)
					pMeeting->Release ();
			}
            break;

		case WM_ILS_RESOLVE_MEETING:
		case WM_ILS_ENUM_MEETINGINFOS:
			{
				CIlsMain *pMain = ReqInfo_GetMain (&ri);
				if (pMain != NULL)
					pMain->Release ();

				CIlsServer *pServer = ReqInfo_GetServer (&ri);
				if (pServer != NULL)
					pServer->Release ();
			}
			break;

		case WM_ILS_ENUM_MEETINGS:
			{
				CIlsMain *pMain = ReqInfo_GetMain (&ri);
				if (pMain != NULL)
					pMain->Release ();
			}
			break;
#endif // ENABLE_MEETING_PLACE

        default:
            // Unknown request
            //
            ASSERT(0);
            break;
    };

    // If it is a server request, cancel the request
    //
    if (ri.uMsgID != 0)
    {
        hr = UlsLdap_Cancel(ri.uMsgID);
    };

    if (SUCCEEDED(hr))
    {
        // Remove the request from the queue
        //
        hr = g_pReqMgr->RequestDone(&ri);
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMain::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
//
// History:
//  Wed 17-Apr-1996 11:15:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsMain::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
{
    CEnumConnectionPoints *pecp;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return ILS_E_POINTER;
    };
    
    // Assume failure
    //
    *ppEnum = NULL;

    // Create an enumerator
    //
    pecp = new CEnumConnectionPoints;
    if (pecp == NULL)
        return ILS_E_MEMORY;

    // Initialize the enumerator
    //
    hr = pecp->Init((IConnectionPoint *)pConnPt);
    if (FAILED(hr))
    {
        delete pecp;
        return hr;
    };

    // Give it back to the caller
    //
    pecp->AddRef();
    *ppEnum = pecp;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMain::FindConnectionPoint(REFIID riid, IConnectionPoint **ppcp)
//
// History:
//  Wed 17-Apr-1996 11:15:09  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsMain::FindConnectionPoint(REFIID riid, IConnectionPoint **ppcp)
{
    IID siid;
    HRESULT hr;

    // Validate parameters
    //
    if (ppcp == NULL)
    {
        return ILS_E_POINTER;
    };
    
    // Assume failure
    //
    *ppcp = NULL;

    if (pConnPt != NULL)
    {
        hr = pConnPt->GetConnectionInterface(&siid);

        if (SUCCEEDED(hr))
        {
            if (riid == siid)
            {
                *ppcp = (IConnectionPoint *)pConnPt;
                (*ppcp)->AddRef();
                hr = S_OK;
            }
            else
            {
                hr = ILS_E_NO_INTERFACE;
            };
        };
    }
    else
    {
        hr = ILS_E_NO_INTERFACE;
    };

    return hr;
}

/* ----------------------------------------------------------------------
	CIlsMain::CreateFilter

	Output:
		ppFilter: a placeholder for the new filter object

	Input:
		FilterOp: a filter operation

	History:
	11/12/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

STDMETHODIMP CIlsMain::
CreateFilter (
	ILS_FILTER_TYPE	FilterType,
	ILS_FILTER_OP	FilterOp,
	IIlsFilter		**ppFilter )
{
	// Make sure ils main is initialized
	//
	if (! IsInitialized ())
	{
		return ILS_E_NOT_INITIALIZED;
	}

	// Make sure we have valid return pointer
	//
	if (ppFilter == NULL)
		return ILS_E_POINTER;

	// Make sure type/op are compatible
	//
	HRESULT hr = S_OK;
	switch (FilterType)
	{
	case ILS_FILTERTYPE_COMPOSITE:
		// Make sure type/op are compatible
		//
		switch (FilterOp)
		{
		case ILS_FILTEROP_AND:
			// Supported
			//
			break;
		case ILS_FILTEROP_OR:
		case ILS_FILTEROP_NOT:
			// Not supported
			//
			// lonchanc: let it fail at the server side
			hr = ILS_S_SERVER_MAY_NOT_SUPPORT;
			break;
		default:
			// Invalid
			//
			hr = ILS_E_PARAMETER;
			break;
		}
		break;

	case ILS_FILTERTYPE_SIMPLE:
		// Make sure type/op are compatible
		//
		switch (FilterOp)
		{
		case ILS_FILTEROP_EQUAL:
		case ILS_FILTEROP_EXIST:
		case ILS_FILTEROP_LESS_THAN:
		case ILS_FILTEROP_GREATER_THAN:
			// Supported
			//
			break;
		case ILS_FILTEROP_APPROX:
			// Not supported
			//
			hr = ILS_S_SERVER_MAY_NOT_SUPPORT;
			break;
		default:
			// Invalid
			//
			hr = ILS_E_PARAMETER;
			break;
		}
		break;

	default:
		hr = ILS_E_FILTER_TYPE;
		break;
	}

	// Create filter only if type/op are compatible
	//
	if (SUCCEEDED (hr))
	{
		CFilter *pFilter = new CFilter (FilterType);
		*ppFilter = pFilter;
		if (pFilter != NULL)
		{
			hr = S_OK;
			pFilter->AddRef ();
			pFilter->SetOp (FilterOp);
		}
		else
			hr = ILS_E_MEMORY;
	}

	return hr;
}


/* ----------------------------------------------------------------------
	CIlsMain::StringToFilter
	Output:
		ppFilter: a placeholder for the new filter object

	Input:
		bstrFilterString: an LDAP-like filter string

	History:
	11/12/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

STDMETHODIMP CIlsMain::
StringToFilter ( BSTR bstrFilterString, IIlsFilter **ppFilter )
{
	// Make sure ils main is initialized
	//
	if (! IsInitialized ())
	{
		return ILS_E_NOT_INITIALIZED;
	}

	// Make sure the filter string is valid
	//
	if (bstrFilterString == NULL)
		return ILS_E_POINTER;

	// Convert a bstr to an ansi string
	//
	TCHAR *pszFilter = NULL;
    HRESULT hr = ::BSTR_to_LPTSTR (&pszFilter, bstrFilterString);
    if (hr == S_OK)
    {
		ASSERT (pszFilter != NULL);

		// Render this filter
		//
		hr = StringToFilter (pszFilter, (CFilter **) ppFilter);

		// Free the temporary ansi string
		//
		::MemFree(pszFilter);
	}

	return hr;
}


HRESULT CIlsMain::
StringToFilter ( TCHAR *pszFilter, CFilter **ppFilter )
{
	// Construct a composite filter
	//
	CFilterParser FilterParser;
	return FilterParser.Expr (ppFilter, pszFilter);
}


STDMETHODIMP CIlsMain::
CreateServer ( BSTR bstrServerName, IIlsServer **ppServer )
{
	// Make sure ils main is initialized
	//
	if (! IsInitialized ())
	{
		return ILS_E_NOT_INITIALIZED;
	}

	if (bstrServerName == NULL || ppServer == NULL)
		return ILS_E_POINTER;

	HRESULT hr;
	CIlsServer *pIlsServer = new CIlsServer;
	if (pIlsServer != NULL)
	{
		hr = pIlsServer->SetServerName (bstrServerName);
		if (hr == S_OK)
		{
			pIlsServer->AddRef ();
		}
		else
		{
			delete pIlsServer;
			pIlsServer = NULL;
		}
	}
	else
	{
		hr = ILS_E_MEMORY;
	}

	*ppServer = (IIlsServer *) pIlsServer;
	return hr;
}



/* ---------- server authentication object ------------ */


CIlsServer::
CIlsServer ( VOID )
:m_cRefs (0),
 m_dwSignature (ILS_SERVER_SIGNATURE)
{
	::ZeroMemory (&m_ServerInfo, sizeof (m_ServerInfo));
	m_ServerInfo.AuthMethod = ILS_AUTH_ANONYMOUS;
}


CIlsServer::
~CIlsServer ( VOID )
{
	m_dwSignature = 0;
	::IlsFreeServerInfo (&m_ServerInfo);
}


STDMETHODIMP_(ULONG) CIlsServer::
AddRef ( VOID )
{
	DllLock();

	MyDebugMsg ((DM_REFCOUNT, "CIlsServer::AddRef: ref=%ld\r\n", m_cRefs));
	::InterlockedIncrement (&m_cRefs);
	return m_cRefs;
}


STDMETHODIMP_(ULONG) CIlsServer::
Release ( VOID )
{
	DllRelease();

	ASSERT (m_cRefs > 0);

	MyDebugMsg ((DM_REFCOUNT, "CIlsServer::Release: ref=%ld\r\n", m_cRefs));
	if (::InterlockedDecrement (&m_cRefs) == 0)
	{
		delete this;
		return 0;
	}
	return m_cRefs;
}


STDMETHODIMP CIlsServer::
QueryInterface ( REFIID riid, VOID **ppv )
{
    *ppv = NULL;

    if (riid == IID_IIlsServer || riid == IID_IUnknown)
    {
        *ppv = (IIlsServer *) this;
    }

    if (*ppv != NULL)
    {
        ((LPUNKNOWN) *ppv)->AddRef();
        return S_OK;
    }

    return ILS_E_NO_INTERFACE;
}


STDMETHODIMP CIlsServer::
SetAuthenticationMethod ( ILS_ENUM_AUTH_METHOD enumAuthMethod )
{
	HRESULT hr;

	if (ILS_AUTH_ANONYMOUS <= enumAuthMethod &&
		enumAuthMethod < ILS_NUM_OF_AUTH_METHODS)
	{
		m_ServerInfo.AuthMethod = enumAuthMethod;
		hr = S_OK;
	}
	else
	{
		hr = ILS_E_PARAMETER;
	}

	return hr;
}


STDMETHODIMP CIlsServer::
SetLogonName ( BSTR bstrLogonName )
{
	// Make sure the filter string is valid
	//
	if (bstrLogonName == NULL)
		return ILS_E_POINTER;

	// Convert a bstr to an ansi string
	//
	TCHAR *psz = NULL;
    HRESULT hr = ::BSTR_to_LPTSTR (&psz, bstrLogonName);
    if (hr == S_OK)
    {
    	// Free the old string
    	//
	    ::MemFree (m_ServerInfo.pszLogonName);

		// Keep the new string
		//
    	m_ServerInfo.pszLogonName = psz;
	}

    return hr;
}


STDMETHODIMP CIlsServer::
SetLogonPassword ( BSTR bstrLogonPassword )
{
	// Make sure the filter string is valid
	//
	if (bstrLogonPassword == NULL)
		return ILS_E_POINTER;

	// Convert a bstr to an ansi string
	//
	TCHAR *psz = NULL;
    HRESULT hr = ::BSTR_to_LPTSTR (&psz, bstrLogonPassword);
    if (hr == S_OK)
    {
    	// Free the old string
    	//
	    ::MemFree (m_ServerInfo.pszLogonPassword);

		// Keep the new string
		//
    	m_ServerInfo.pszLogonPassword = psz;
	}

    return hr;
}


STDMETHODIMP CIlsServer::
SetDomain ( BSTR bstrDomain )
{
	// Make sure the filter string is valid
	//
	if (bstrDomain == NULL)
		return ILS_E_POINTER;

	// Convert a bstr to an ansi string
	//
	TCHAR *psz = NULL;
    HRESULT hr = ::BSTR_to_LPTSTR (&psz, bstrDomain);
    if (hr == S_OK)
    {
    	// Free the old string
    	//
	    ::MemFree (m_ServerInfo.pszDomain);

		// Keep the new string
		//
    	m_ServerInfo.pszDomain = psz;
	}

    return hr;
}


STDMETHODIMP CIlsServer::
SetCredential ( BSTR bstrCredential )
{
	// Make sure the filter string is valid
	//
	if (bstrCredential == NULL)
		return ILS_E_POINTER;

	// Convert a bstr to an ansi string
	//
	TCHAR *psz = NULL;
    HRESULT hr = ::BSTR_to_LPTSTR (&psz, bstrCredential);
    if (hr == S_OK)
    {
    	// Free the old string
    	//
	    ::MemFree (m_ServerInfo.pszCredential);

		// Keep the new string
		//
    	m_ServerInfo.pszCredential = psz;
	}

    return hr;
}


STDMETHODIMP CIlsServer::
SetTimeout ( ULONG uTimeoutInSecond )
{
    m_ServerInfo.uTimeoutInSecond = uTimeoutInSecond;
    return S_OK;
}


STDMETHODIMP CIlsServer::
SetBaseDN ( BSTR bstrBaseDN )
{
	// Make sure the filter string is valid
	//
	if (bstrBaseDN == NULL)
		return ILS_E_POINTER;

	// Convert a bstr to an ansi string
	//
	TCHAR *psz = NULL;
    HRESULT hr = ::BSTR_to_LPTSTR (&psz, bstrBaseDN);
    if (hr == S_OK)
    {
    	// Free the old string
    	//
	    ::MemFree (m_ServerInfo.pszBaseDN);

		// Keep the new string
		//
    	m_ServerInfo.pszBaseDN = psz;
	}

    return hr;
}


HRESULT CIlsServer::
SetServerName ( TCHAR *pszServerName )
{
	// Make sure the filter string is valid
	//
	if (pszServerName == NULL)
		return ILS_E_POINTER;

	// duplicate the server name
	//
	HRESULT hr;
	TCHAR *psz = ::My_strdup (pszServerName);
	if (psz != NULL)
	{
	    if (MyIsGoodString (psz))
	    {
	    	// Free the old string
	    	//
		    ::MemFree (m_ServerInfo.pszServerName);

			// Keep the new string
			//
	    	m_ServerInfo.pszServerName = psz;

	    	hr = S_OK;
		}
		else
		{
			::MemFree (psz);
			psz = NULL;
			hr = ILS_E_PARAMETER;
		}
	}
	else
	{
		hr = ILS_E_MEMORY;
	}

    return hr;
}



HRESULT CIlsServer::
SetServerName ( BSTR bstrServerName )
{
	// Make sure the filter string is valid
	//
	if (bstrServerName == NULL)
		return ILS_E_POINTER;

	// Convert a bstr to an ansi string
	//
	TCHAR *psz = NULL;
    HRESULT hr = ::BSTR_to_LPTSTR (&psz, bstrServerName);
    if (hr == S_OK)
    {
	    if (MyIsGoodString (psz))
	    {
	    	// Free the old string
	    	//
		    ::MemFree (m_ServerInfo.pszServerName);

			// Keep the new string
			//
	    	m_ServerInfo.pszServerName = psz;
	    }
	    else
	    {
	    	::MemFree (psz);
	    	psz = NULL;
	    	hr = ILS_E_PARAMETER;
	    }
	}

    return ((psz != NULL) ? S_OK : ILS_E_MEMORY);
}


TCHAR *CIlsServer::
DuplicateServerName ( VOID )
{
	return My_strdup (m_ServerInfo.pszServerName);
}


BSTR CIlsServer::
DuplicateServerNameBSTR ( VOID )
{
	BSTR bstr = NULL;
	TCHAR *psz = DuplicateServerName ();
	if (psz != NULL)
	{
		LPTSTR_to_BSTR (&bstr, psz);
	}

	return bstr;
}


CIlsServer *CIlsServer::
Clone ( VOID )
{
	CIlsServer *p = new CIlsServer;

	if (p != NULL)
	{
		if (::IlsCopyServerInfo (p->GetServerInfo (), GetServerInfo ()) == S_OK)
		{
			p->AddRef ();
		}
		else
		{
			::IlsFreeServerInfo (p->GetServerInfo ());
			::MemFree (p);
			p = NULL;
		}
	}

	return p;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\filter.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       filter.h
//  Content:    This file contains the filter object.
//  History:
//      Tue 12-Nov-1996 15:50:00  -by-  Chu, Lon-Chan [lonchanc]
//
//  Copyright (c) Microsoft Corporation 1995-1996
//
//****************************************************************************

#ifndef _FILTER_H_
#define _FILTER_H_


typedef enum 
{
	ILS_ATTRNAME_UNKNOWN,
	ILS_ATTRNAME_STANDARD,
	ILS_ATTRNAME_ARBITRARY,
}
	ILS_ATTR_NAME_TYPE;


//****************************************************************************
// CFilter definition
//****************************************************************************
//

class CFilter : public IIlsFilter
{
	friend class CFilterParser;

public:
	// Constructor and destructor
	//
	CFilter ( ILS_FILTER_TYPE Type );
	~CFilter ( VOID );

	// IUnknown
	//
	STDMETHODIMP            QueryInterface ( REFIID iid, VOID **ppv );
	STDMETHODIMP_(ULONG)    AddRef ( VOID );
	STDMETHODIMP_(ULONG)    Release ( VOID );

	// Composite filter operations
	//
	STDMETHODIMP	AddSubFilter ( IIlsFilter *pFilter );
	STDMETHODIMP	RemoveSubFilter ( IIlsFilter *pFilter );
	STDMETHODIMP	GetCount ( ULONG *pcElements );

	// Simple filter operations
	//
	STDMETHODIMP	SetStandardAttributeName ( ILS_STD_ATTR_NAME AttrName );
	STDMETHODIMP	SetExtendedAttributeName ( BSTR bstrAnyAttrName );
	STDMETHODIMP	SetAttributeValue ( BSTR bstrAttrValue );

	// Common operations
	//
	ILS_FILTER_TYPE GetType ( VOID ) { return m_Type; }
	ILS_FILTER_OP GetOp ( VOID ) { return m_Op; }
	VOID SetOp ( ILS_FILTER_OP Op ) { m_Op = Op; }

	enum { ILS_FILTER_SIGNATURE = 0x20698052 };
	BOOL IsValidFilter ( VOID ) { return (m_nSignature == ILS_FILTER_SIGNATURE); }
	BOOL IsBadFilter ( VOID ) { return (m_nSignature != ILS_FILTER_SIGNATURE); }

	HRESULT CalcFilterSize ( ULONG *pcbStringSize );
	HRESULT BuildLdapString ( TCHAR **ppszBuf );

protected:

	HRESULT RemoveAnySubFilter ( CFilter **ppFilter );

	HRESULT	SetExtendedAttributeName ( TCHAR *pszAnyAttrName );
	HRESULT SetAttributeValue ( TCHAR *pszAttrValue );

private:

	// Simple filter helpers
	//
	VOID FreeName ( VOID );
	VOID FreeValue ( VOID );

	// Common members
	//
	LONG				m_nSignature;
	LONG				m_cRefs;
	ILS_FILTER_TYPE		m_Type;	// filter type
	ILS_FILTER_OP		m_Op;	// filter op

	// Composite filter members
	//
	CList	m_SubFilters;
	ULONG	m_cSubFilters;

	// Simple filter members
	//
	ILS_ATTR_NAME_TYPE	m_NameType;
	union
	{
		ILS_STD_ATTR_NAME	std;
		TCHAR				*psz;
	}
		m_Name; 	// Attribute name
	TCHAR				*m_pszValue;

	#define FILTER_INTERNAL_SMALL_BUFFER_SIZE		16
	TCHAR				m_szInternalValueBuffer[FILTER_INTERNAL_SMALL_BUFFER_SIZE];
};



typedef enum
{
	ILS_TOKEN_NULL		= 0,
	ILS_TOKEN_LITERAL	= 1,
	ILS_TOKEN_STDATTR	= TEXT ('$'),	// $
	ILS_TOKEN_LP		= TEXT ('('),	// (
	ILS_TOKEN_RP		= TEXT (')'),	// )
	ILS_TOKEN_EQ		= TEXT ('='),	// =
	ILS_TOKEN_NEQ		= TEXT ('-'),	// !=
	ILS_TOKEN_APPROX	= TEXT ('~'),	// ~=
	ILS_TOKEN_GE		= TEXT ('>'),	// >=
	ILS_TOKEN_LE		= TEXT ('<'),	// <=
	ILS_TOKEN_AND		= TEXT ('&'),	// &
	ILS_TOKEN_OR		= TEXT ('|'),	// |
	ILS_TOKEN_NOT		= TEXT ('!'),	// !
}
	ILS_TOKEN_TYPE;


class CFilterParser
{
public:
	// Constructor and destructor
	//
	CFilterParser ( VOID );
	~CFilterParser ( VOID );

	HRESULT Expr ( CFilter **ppOutFilter, TCHAR *pszFilter );

protected:

private:

	HRESULT Expr ( CFilter **ppOutFilter );
	HRESULT TailExpr ( CFilter **ppOutFilter, CFilter *pInFilter );
	HRESULT GetToken ( VOID );

	// Cache of the filter string
	//
	TCHAR		*m_pszFilter;

	// Running pointer to parse the filter string
	//
	TCHAR		*m_pszCurr;

	// look ahead token for LL(1)
	//
	ILS_TOKEN_TYPE	m_TokenType;
	TCHAR			*m_pszTokenValue;
	LONG			m_nTokenValue;
};


HRESULT FilterToLdapString ( CFilter *pFilter, TCHAR **ppszFilter );


#endif // _FILTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\localapp.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       localapp.cpp
//  Content:    This file contains the LocalApplication object.
//  History:
//      Wed 17-Apr-1996 11:13:54  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#include "ulsp.h"
#include "localapp.h"
#include "localprt.h"
#include "attribs.h"
#include "callback.h"
#include "culs.h"

//****************************************************************************
// Event Notifiers
//****************************************************************************
//
//****************************************************************************
// HRESULT
// OnNotifyLocalAppAttributesChangeResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
OnNotifyLocalAppAttributesChangeResult (IUnknown *pUnk, void *pv)
{
    PSRINFO psri = (PSRINFO)pv;

    ((IULSLocalAppNotify*)pUnk)->AttributesChangeResult(psri->uReqID,
                                                        psri->hResult);
    return S_OK;
}

//****************************************************************************
// HRESULT
// OnNotifyLocalAppProtocolChangeResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
OnNotifyLocalAppProtocolChangeResult (IUnknown *pUnk, void *pv)
{
    PSRINFO psri = (PSRINFO)pv;

    ((IULSLocalAppNotify*)pUnk)->ProtocolChangeResult(psri->uReqID,
                                                      psri->hResult);
    return S_OK;
}

//****************************************************************************
// Class Implementation
//****************************************************************************
//
//****************************************************************************
// CLocalApp::CLocalApp (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CLocalApp::CLocalApp (void)
{
    cRef = 0;
    szName = NULL;
    guid = GUID_NULL;
    szMimeType = NULL;
    pAttrs = NULL;
    pConnPt = NULL;
    return;
}

//****************************************************************************
// CLocalApp::~CLocalApp (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CLocalApp::~CLocalApp (void)
{
    CLocalProt *plp;
    HANDLE hEnum;

    // Release the connection point
    //
    if (pConnPt != NULL)
    {
        pConnPt->ContainerReleased();
        ((IConnectionPoint*)pConnPt)->Release();
    };

    // Release the protocol objects
    //
    ProtList.Enumerate(&hEnum);
    while(ProtList.Next(&hEnum, (PVOID *)&plp) == NOERROR)
    {
        plp->Release();
    };
    ProtList.Flush();

    // Release the attributes object
    //
    if (pAttrs != NULL)
    {
        pAttrs->Release();
    };

    // Release the buffer resources
    //
    if (szName != NULL)
    {
        FreeLPTSTR(szName);
    };

    if (szMimeType != NULL)
    {
        FreeLPTSTR(szMimeType);
    };

    return;
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::Init (BSTR bstrName, REFGUID rguid, BSTR bstrMimeType)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::Init (BSTR bstrName, REFGUID rguid, BSTR bstrMimeType)
{
    HRESULT hr;

    // Cache the application information
    //
    guid = rguid;

    hr = BSTR_to_LPTSTR(&szName, bstrName);
    if (SUCCEEDED(hr))
    {
        hr = BSTR_to_LPTSTR(&szMimeType, bstrMimeType);
        if (SUCCEEDED(hr))
        {
            // Initialize the attributes list
            //
            pAttrs = new CAttributes (ULS_ATTRACCESS_NAME_VALUE);

            if (pAttrs != NULL)
            {
                // Make the connection point
                //
                pConnPt = new CConnectionPoint (&IID_IULSLocalAppNotify,
                                                (IConnectionPointContainer *)this);
                if (pConnPt != NULL)
                {
                    ((IConnectionPoint*)pConnPt)->AddRef();
                    hr = NOERROR;
                }
                else
                {
                    hr = ULS_E_MEMORY;
                };
            }
            else
            {
                hr = ULS_E_MEMORY;
            };
        };
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::QueryInterface (REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (riid == IID_IULSLocalApplication || riid == IID_IUnknown)
    {
        *ppv = (IULS *) this;
    }
    else
    {
        if (riid == IID_IConnectionPointContainer)
        {
            *ppv = (IConnectionPointContainer *) this;
        };
    };

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        return ULS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CLocalApp::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:14:17  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CLocalApp::AddRef (void)
{
    cRef++;
    return cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CLocalApp::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:14:26  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CLocalApp::Release (void)
{
    cRef--;

    if (cRef == 0)
    {
        delete this;
        return 0;
    }
    else
    {
        return cRef;
    };
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::NotifySink (void *pv, CONN_NOTIFYPROC pfn)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::NotifySink (void *pv, CONN_NOTIFYPROC pfn)
{
    HRESULT hr = S_OK;

    if (pConnPt != NULL)
    {
        hr = pConnPt->Notify(pv, pfn);
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::AttributesChangeResult (CAttributes *pAttributes,
//                                    ULONG uReqID, HRESULT hResult,
//                                    APP_CHANGE_ATTRS uCmd)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::AttributesChangeResult (CAttributes *pAttributes,
                                   ULONG uReqID, HRESULT hResult,
                                   APP_CHANGE_ATTRS uCmd)
{
    SRINFO sri;

    // If the server accepts the changes, modify the local information
    //
    if (SUCCEEDED(hResult))
    {
        // Update based on the command.
        //
        switch(uCmd)
        {
            case ULS_APP_SET_ATTRIBUTES:
                hResult = pAttrs->SetAttributes(pAttributes);
                break;

            case ULS_APP_REMOVE_ATTRIBUTES:
                hResult = pAttrs->RemoveAttributes(pAttributes);
                break;

            default:
                ASSERT(0);
                break;
        };
    };

    // Notify the sink object
    //
    sri.uReqID = uReqID;
    sri.hResult = hResult;
    hResult = NotifySink((void *)&sri, OnNotifyLocalAppAttributesChangeResult);

#ifdef DEBUG
    DPRINTF (TEXT("CLocalApp--current attributes********************\r\n"));
    pAttrs->DebugOut();
    DPRINTF (TEXT("\r\n*************************************************"));
#endif // DEBUG;

    return hResult;
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::ProtocolChangeResult (CLocalProt *pProtocol,
//                                  ULONG uReqID, HRESULT hResult,
//                                  APP_CHANGE_PROT uCmd)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::ProtocolChangeResult (CLocalProt *pProtocol,
                                 ULONG uReqID, HRESULT hResult,
                                 APP_CHANGE_PROT uCmd)
{
    SRINFO sri;

    // If the server accepts the changes, modify the local information
    //
    if (SUCCEEDED(hResult))
    {
        // Update based on the command.
        //
        switch(uCmd)
        {
            case ULS_APP_ADD_PROT:
                hResult = ProtList.Insert((PVOID)pProtocol);
                if (SUCCEEDED(hResult))
                {
                    pProtocol->AddRef();
                };
                break;

            case ULS_APP_REMOVE_PROT:
                hResult = ProtList.Remove((PVOID)pProtocol);
                if (SUCCEEDED(hResult))
                {
                    pProtocol->Release();
                };
                break;

            default:
                ASSERT(0);
                break;
        };
    };

    // Notify the sink object
    //
    sri.uReqID = uReqID;
    sri.hResult = hResult;
    hResult = NotifySink((void *)&sri, OnNotifyLocalAppProtocolChangeResult);

#ifdef DEBUG
    DPRINTF (TEXT("CLocalApp--current Protocols********************\r\n"));
    DebugProtocolDump();
    DPRINTF (TEXT("\r\n*************************************************"));
#endif // DEBUG;

    return hResult;
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::CreateProtocol (BSTR bstrProtocolID, ULONG uPortNumber,
//                            BSTR bstrMimeType,
//                            IULSLocalAppProtocol **ppProtocol)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::CreateProtocol (BSTR bstrProtocolID, ULONG uPortNumber,
                           BSTR bstrMimeType,
                           IULSLocalAppProtocol **ppProtocol)
{
    CLocalProt *plp;
    HRESULT hr;

    // Validate parameter
    //
    if (ppProtocol == NULL)
    {
        return ULS_E_POINTER;
    };

    // Assume failure
    //
    *ppProtocol = NULL;

    // Create a new object
    //
    plp = new CLocalProt;

    if (plp != NULL)
    {
        hr = plp->Init(bstrProtocolID, uPortNumber, bstrMimeType);

        if (SUCCEEDED(hr))
        {
            plp->AddRef();
            *ppProtocol = plp;
        };
    }
    else
    {
        hr = ULS_E_MEMORY;
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::ChangeProtocol (IULSLocalAppProtocol *pProtocol,
//                            ULONG *puReqID, APP_CHANGE_PROT uCmd)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::ChangeProtocol (IULSLocalAppProtocol *pProtocol,
                           ULONG *puReqID, APP_CHANGE_PROT uCmd)
{
    CLocalProt *plp;
    PVOID   pv;
    HRESULT hr;
    HANDLE  hLdapApp;
    LDAP_ASYNCINFO ldai; 
    HANDLE hEnum;

    // Validate parameters
    //
    if ((pProtocol == NULL) ||
        (puReqID == NULL))
    {
        return ULS_E_POINTER;
    };

    hr = pProtocol->QueryInterface(IID_IULSLocalAppProtocol, &pv);

    if (FAILED(hr))
    {
        return ULS_E_PARAMETER;
    };
    pProtocol->Release();

    // Check whether the protocol exists
    //
    ProtList.Enumerate(&hEnum);
    while(ProtList.Next(&hEnum, (PVOID *)&plp) == NOERROR)
    {
        if (plp->IsSameAs((CLocalProt *)pProtocol) == NOERROR)
        {
            break;
        };
    };

    if (plp != NULL)
    {
        // The protocol exists, fail if this add request
        //
        if (uCmd == ULS_APP_ADD_PROT)
        {
            return ULS_E_PARAMETER;
        };
    }
    else
    {
        // The protocol does not exist, fail if this remove request
        //
        if (uCmd == ULS_APP_REMOVE_PROT)
        {
            return ULS_E_PARAMETER;
        };
    };

    // Update the server information first
    //
    switch (uCmd)
    {
        case ULS_APP_ADD_PROT:
            hr = g_pCUls->RegisterLocalProtocol((CLocalProt*)pProtocol, &ldai);
            break;

        case ULS_APP_REMOVE_PROT:
            hr = g_pCUls->UnregisterLocalProtocol((CLocalProt*)pProtocol, &ldai);
            break;

        default:
            ASSERT(0);
            break;
    };
    
    switch (hr)
    {
        case NOERROR:
            //
            // Server starts updating the protocol successfullly
            // We will wait for the server response.
            //
            break;

        case S_FALSE:
            //
            // We have not registered, will do local response
            //
            hr = NOERROR;
            ldai.uMsgID = 0;    
            break;

        default:
            // ULS is locked. Return failure.
            //
            hr = ULS_E_ABORT;
            break; 
    }

    if (SUCCEEDED(hr))
    {
        REQUESTINFO ri;
        ULONG   uMsg;

        switch(uCmd)
        {
            case ULS_APP_ADD_PROT:
                uMsg = (ldai.uMsgID == 0 ? WM_ULS_LOCAL_REGISTER_PROTOCOL:
                                           WM_ULS_REGISTER_PROTOCOL);
                break;

            case ULS_APP_REMOVE_PROT:
                uMsg = (ldai.uMsgID == 0 ? WM_ULS_LOCAL_UNREGISTER_PROTOCOL :
                                           WM_ULS_UNREGISTER_PROTOCOL);
                break;

            default:
                ASSERT(0);
                break;
        };
 
        // If updating server was successfully requested, wait for the response
        //
        ri.uReqType = uMsg;
        ri.uMsgID = ldai.uMsgID;
        ri.pv     = (PVOID)this;
        ri.lParam = (LPARAM)((CLocalProt*)pProtocol);

        hr = g_pReqMgr->NewRequest(&ri);

        if (SUCCEEDED(hr))
        {
            // Make sure the objects do not disappear before we get the response
            //
            this->AddRef();
            pProtocol->AddRef();

            // Return the request ID
            //
            *puReqID = ri.uReqID;

            // If not registered with server, start async response ourselves
            //
            if (ldai.uMsgID == 0)
            {
                g_pCUls->LocalAsyncRespond(uMsg, ri.uReqID, NOERROR);
            };
        };
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::AddProtocol (IULSLocalAppProtocol *pProtocol,
//                         ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::AddProtocol (IULSLocalAppProtocol *pProtocol,
                        ULONG *puReqID)
{
    return ChangeProtocol(pProtocol, puReqID, ULS_APP_ADD_PROT);
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::RemoveProtocol (IULSLocalAppProtocol *pProtocol,
//                            ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::RemoveProtocol (IULSLocalAppProtocol *pProtocol,
                           ULONG *puReqID)
{
    return ChangeProtocol(pProtocol, puReqID, ULS_APP_REMOVE_PROT);
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::EnumProtocols (IEnumULSLocalAppProtocols **ppEnumProtocol)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::EnumProtocols (IEnumULSLocalAppProtocols **ppEnumProtocol)
{
    CEnumLocalAppProtocols *pep;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnumProtocol == NULL)
    {
        return ULS_E_POINTER;
    };

    // Assume failure
    //
    *ppEnumProtocol = NULL;

    // Create a peer enumerator
    //
    pep = new CEnumLocalAppProtocols;

    if (pep != NULL)
    {
        hr = pep->Init(&ProtList);

        if (SUCCEEDED(hr))
        {
            // Get the enumerator interface
            //
            pep->AddRef();
            *ppEnumProtocol = pep;
        }
        else
        {
            delete pep;
        };
    }
    else
    {
        hr = ULS_E_MEMORY;
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::ChangeAttributes (IULSAttributes *pAttributes, ULONG *puReqID,
//                              APP_CHANGE_ATTRS uCmd)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::ChangeAttributes (IULSAttributes *pAttributes, ULONG *puReqID,
                             APP_CHANGE_ATTRS uCmd)
{
    PVOID   pv;
    HRESULT hr;
    HANDLE  hLdapApp;
    LDAP_ASYNCINFO ldai; 

    // Validate parameters
    //
    if ((pAttributes == NULL) ||
        (puReqID == NULL))
    {
        return ULS_E_POINTER;
    };

    hr = pAttributes->QueryInterface(IID_IULSAttributes, &pv);

    if (FAILED(hr))
    {
        return ULS_E_PARAMETER;
    };

    // If no attributes, fails the call
    //
    if (((CAttributes*)pAttributes)->GetCount() == 0)
    {
        return ULS_E_PARAMETER;
    };

    // Check if already registered
    //
    hr = g_pCUls->GetAppHandle(&hLdapApp);

    switch (hr)
    {
        case NOERROR:
        {
            LPTSTR pAttrList;
            ULONG  cAttrs, cb;

            // Yes, get the attributes list
            //
            switch (uCmd)
            {
                case ULS_APP_SET_ATTRIBUTES:
                    hr = ((CAttributes*)pAttributes)->GetAttributePairs(&pAttrList,
                                                                        &cAttrs,
                                                                        &cb);
                    if (SUCCEEDED(hr))
                    {
                        hr = ::UlsLdap_SetAppAttrs(hLdapApp, cAttrs, pAttrList,
                                                   &ldai);
                        FreeLPTSTR(pAttrList);
                    };
                    break;

                case ULS_APP_REMOVE_ATTRIBUTES:
                    hr = ((CAttributes*)pAttributes)->GetAttributeList(&pAttrList,
                                                                        &cAttrs,
                                                                        &cb);

                    if (SUCCEEDED(hr))
                    {
                        hr = ::UlsLdap_RemoveAppAttrs(hLdapApp, cAttrs, pAttrList,
                                                      &ldai);
                        FreeLPTSTR(pAttrList);
                    };
                    break;

                default:
                    ASSERT(0);
                    break;
            };
            break;
        }
    
        case S_FALSE:
            //
            // Not registered, will do local response
            //
            hr = NOERROR;
            ldai.uMsgID = 0;
            break;

        default:
            // ULS is locked. Return failure.
            //
            hr = ULS_E_ABORT;
            break; 
    };

    if (SUCCEEDED(hr))
    {
        REQUESTINFO ri;
        ULONG   uMsg;

        switch(uCmd)
        {
            case ULS_APP_SET_ATTRIBUTES:
                uMsg = (ldai.uMsgID == 0 ? WM_ULS_LOCAL_SET_APP_ATTRS :
                                           WM_ULS_SET_APP_ATTRS);
                break;

            case ULS_APP_REMOVE_ATTRIBUTES:
                uMsg = (ldai.uMsgID == 0 ? WM_ULS_LOCAL_REMOVE_APP_ATTRS :
                                           WM_ULS_REMOVE_APP_ATTRS);
                break;

            default:
                ASSERT(0);
                break;
        };

        // If updating server was successfully requested, wait for the response
        //
        ri.uReqType = uMsg;
        ri.uMsgID = ldai.uMsgID;
        ri.pv     = (PVOID)this;
        ri.lParam = (LPARAM)((CAttributes *)pAttributes);

        hr = g_pReqMgr->NewRequest(&ri);

        if (SUCCEEDED(hr))
        {
            // Make sure the objects do not disappear before we get the response
            //
            this->AddRef();
            pAttributes->AddRef();

            // Return the request ID
            //
            *puReqID = ri.uReqID;

            // If not registered with server, start async response ourselves
            //
            if (ldai.uMsgID == 0)
            {
                g_pCUls->LocalAsyncRespond(uMsg, ri.uReqID, NOERROR);
            };
        };
    };

    // Matching the QueryInterface
    //
    pAttributes->Release();
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::SetAttributes (IULSAttributes *pAttributes, ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::SetAttributes (IULSAttributes *pAttributes, ULONG *puReqID)
{
    return ChangeAttributes(pAttributes, puReqID, ULS_APP_SET_ATTRIBUTES);
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::RemoveAttributes (IULSAttributes *pAttributes, ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::RemoveAttributes (IULSAttributes *pAttributes, ULONG *puReqID)
{
    return ChangeAttributes(pAttributes, puReqID, ULS_APP_REMOVE_ATTRIBUTES);
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::GetAppInfo (PLDAP_APPINFO *ppAppInfo)
//
// History:
//  Wed 17-Apr-1996 11:15:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::GetAppInfo (PLDAP_APPINFO *ppAppInfo)
{
    PLDAP_APPINFO pai;
    ULONG cName, cMime;
    LPTSTR szAttrs;
    ULONG cAttrs, cbAttrs;
    HRESULT hr;

    // Assume failure
    //
    *ppAppInfo = NULL;

    // Calculate the buffer size
    //
    cName = lstrlen(szName)+1;
    cMime = lstrlen(szMimeType)+1;

    // Get the attribute pairs
    //
    hr = pAttrs->GetAttributePairs(&szAttrs, &cAttrs, &cbAttrs);
    if (FAILED(hr))
    {
        return hr;
    };

    // Allocate the buffer
    //
    pai = (PLDAP_APPINFO)LocalAlloc(LPTR, sizeof(LDAP_APPINFO) +
                                                ((cName + cMime)* sizeof(TCHAR)) +
                                                cbAttrs);
    if (pai == NULL)
    {
        hr = ULS_E_MEMORY;
    }
    else
    {
        // Fill the structure content
        //
        pai->uSize              = sizeof(*pai);
        pai->guid               = guid;
        pai->uOffsetName        = sizeof(*pai);
        pai->uOffsetMimeType    = pai->uOffsetName + (cName*sizeof(TCHAR));
        pai->cAttributes        = cAttrs;
        pai->uOffsetAttributes  = (cAttrs != 0 ?
                                   pai->uOffsetMimeType  + (cMime*sizeof(TCHAR)) :
                                   0);

        // Copy the user information
        //
        lstrcpy((LPTSTR)(((PBYTE)pai)+pai->uOffsetName), szName);
        lstrcpy((LPTSTR)(((PBYTE)pai)+pai->uOffsetMimeType), szMimeType);
        if (cAttrs)
        {
            CopyMemory(((PBYTE)pai)+pai->uOffsetAttributes, szAttrs, cbAttrs);
        };

        // Return the structure
        //
        *ppAppInfo = pai;
    };

    if (szAttrs != NULL)
    {
        FreeLPTSTR(szAttrs);
    };
    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
//
// History:
//  Wed 17-Apr-1996 11:15:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
{
    CEnumConnectionPoints *pecp;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return ULS_E_POINTER;
    };
    
    // Assume failure
    //
    *ppEnum = NULL;

    // Create an enumerator
    //
    pecp = new CEnumConnectionPoints;
    if (pecp == NULL)
        return ULS_E_MEMORY;

    // Initialize the enumerator
    //
    hr = pecp->Init((IConnectionPoint *)pConnPt);
    if (FAILED(hr))
    {
        delete pecp;
        return hr;
    };

    // Give it back to the caller
    //
    pecp->AddRef();
    *ppEnum = pecp;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::FindConnectionPoint(REFIID riid, IConnectionPoint **ppcp)
//
// History:
//  Wed 17-Apr-1996 11:15:09  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::FindConnectionPoint(REFIID riid, IConnectionPoint **ppcp)
{
    IID siid;
    HRESULT hr;

    // Validate parameters
    //
    if (ppcp == NULL)
    {
        return ULS_E_POINTER;
    };
    
    // Assume failure
    //
    *ppcp = NULL;

    if (pConnPt != NULL)
    {
        hr = pConnPt->GetConnectionInterface(&siid);

        if (SUCCEEDED(hr))
        {
            if (riid == siid)
            {
                *ppcp = (IConnectionPoint *)pConnPt;
                (*ppcp)->AddRef();
                hr = S_OK;
            }
            else
            {
                hr = ULS_E_NO_INTERFACE;
            };
        };
    }
    else
    {
        hr = ULS_E_NO_INTERFACE;
    };

    return hr;
}

#ifdef DEBUG
//****************************************************************************
// void
// CLocalApp::DebugProtocolDump (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void
CLocalApp::DebugProtocolDump (void)
{
    CLocalProt *plp;
    BSTR bstrID;
    LPTSTR pszID;
    ULONG  cCount;
    HANDLE hEnum;

    // Each protocol
    //
    cCount = 1;
    ProtList.Enumerate(&hEnum);
    while(ProtList.Next(&hEnum, (PVOID *)&plp) == NOERROR)
    {
        if (SUCCEEDED(plp->GetID (&bstrID)))
        {
            BSTR_to_LPTSTR(&pszID, bstrID);
            DPRINTF2(TEXT("%d> %s"), cCount++, pszID);
            FreeLPTSTR(pszID);
            SysFreeString(bstrID);
        };
    };
    return;
}
#endif // DEBUG

//****************************************************************************
// CEnumLocalAppProtocols::CEnumLocalAppProtocols (void)
//
// History:
//  Wed 17-Apr-1996 11:15:18  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CEnumLocalAppProtocols::CEnumLocalAppProtocols (void)
{
    cRef = 0;
    hEnum = NULL;
    return;
}

//****************************************************************************
// CEnumLocalAppProtocols::~CEnumLocalAppProtocols (void)
//
// History:
//  Wed 17-Apr-1996 11:15:18  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CEnumLocalAppProtocols::~CEnumLocalAppProtocols (void)
{
    CLocalProt *plp;

    ProtList.Enumerate(&hEnum);
    while(ProtList.Next(&hEnum, (PVOID *)&plp) == NOERROR)
    {
        plp->Release();
    };
    ProtList.Flush();
    return;
}

//****************************************************************************
// STDMETHODIMP
// CEnumLocalAppProtocols::Init (CList *pProtList)
//
// History:
//  Wed 17-Apr-1996 11:15:25  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumLocalAppProtocols::Init (CList *pProtList)
{
    CLocalProt *plp;
    HRESULT hr;

    // Duplicate the protocol list
    //
    hr = ProtList.Clone (pProtList, NULL);

    if (SUCCEEDED(hr))
    {
        // Add reference to each protocol object
        //
        ProtList.Enumerate(&hEnum);
        while(ProtList.Next(&hEnum, (PVOID *)&plp) == NOERROR)
        {
            plp->AddRef();
        };

        // Reset the enumerator
        //
        ProtList.Enumerate(&hEnum);
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CEnumLocalAppProtocols::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:15:31  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumLocalAppProtocols::QueryInterface (REFIID riid, void **ppv)
{
    if (riid == IID_IEnumULSLocalAppProtocols || riid == IID_IUnknown)
    {
        *ppv = (IEnumULSLocalAppProtocols *) this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return ULS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumLocalAppProtocols::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:15:37  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumLocalAppProtocols::AddRef (void)
{
    cRef++;
    return cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumLocalAppProtocols::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:15:43  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumLocalAppProtocols::Release (void)
{
    cRef--;

    if (cRef == 0)
    {
        delete this;
        return 0;
    }
    else
    {
        return cRef;
    };
}

//****************************************************************************
// STDMETHODIMP 
// CEnumLocalAppProtocols::Next (ULONG cProtocols,
//                               IULSLocalAppProtocol **rgpProt,
//                               ULONG *pcFetched)
//
// History:
//  Wed 17-Apr-1996 11:15:49  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP 
CEnumLocalAppProtocols::Next (ULONG cProtocols, IULSLocalAppProtocol **rgpProt,
                              ULONG *pcFetched)
{
    CLocalProt *plp;
    ULONG   cCopied;
    HRESULT hr;

    // Validate the pointer
    //
    if (rgpProt == NULL)
        return ULS_E_POINTER;

    // Validate the parameters
    //
    if ((cProtocols == 0) ||
        ((cProtocols > 1) && (pcFetched == NULL)))
        return ULS_E_PARAMETER;

    // Check the enumeration index
    //
    cCopied = 0;

    // Can copy if we still have more protocols
    //
    while ((cCopied < cProtocols) &&
           (ProtList.Next(&hEnum, (PVOID *)&plp) == NOERROR))
    {
        rgpProt[cCopied] = plp;
        plp->AddRef();
        cCopied++;
    };

    // Determine the returned information based on other parameters
    //
    if (pcFetched != NULL)
    {
        *pcFetched = cCopied;
    };
    return (cProtocols == cCopied ? S_OK : S_FALSE);
}

//****************************************************************************
// STDMETHODIMP
// CEnumLocalAppProtocols::Skip (ULONG cProtocols)
//
// History:
//  Wed 17-Apr-1996 11:15:56  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumLocalAppProtocols::Skip (ULONG cProtocols)
{
    CLocalProt *plp;
    ULONG cSkipped;

    // Validate the parameters
    //
    if (cProtocols == 0) 
        return ULS_E_PARAMETER;

    // Check the enumeration index limit
    //
    cSkipped = 0;

    // Can skip only if we still have more attributes
    //
    while ((cSkipped < cProtocols) &&
           (ProtList.Next(&hEnum, (PVOID *)&plp) == NOERROR))
    {
        cSkipped++;
    };

    return (cProtocols == cSkipped ? S_OK : S_FALSE);
}

//****************************************************************************
// STDMETHODIMP
// CEnumLocalAppProtocols::Reset (void)
//
// History:
//  Wed 17-Apr-1996 11:16:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumLocalAppProtocols::Reset (void)
{
    ProtList.Enumerate(&hEnum);
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CEnumLocalAppProtocols::Clone(IEnumULSLocalAppProtocols **ppEnum)
//
// History:
//  Wed 17-Apr-1996 11:16:11  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumLocalAppProtocols::Clone(IEnumULSLocalAppProtocols **ppEnum)
{
    CEnumLocalAppProtocols *pep;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return ULS_E_POINTER;
    };

    *ppEnum = NULL;

    // Create an enumerator
    //
    pep = new CEnumLocalAppProtocols;
    if (pep == NULL)
        return ULS_E_MEMORY;

    // Clone the information
    //
    pep->hEnum = hEnum;
    hr = pep->ProtList.Clone (&ProtList, &(pep->hEnum));

    if (SUCCEEDED(hr))
    {
        CLocalProt *plp;
        HANDLE hEnumTemp;

        // Add reference to each protocol object
        //
        pep->ProtList.Enumerate(&hEnumTemp);
        while(pep->ProtList.Next(&hEnumTemp, (PVOID *)&plp) == NOERROR)
        {
            plp->AddRef();
        };

        // Return the cloned enumerator
        //
        pep->AddRef();
        *ppEnum = pep;
    }
    else
    {
        delete pep;
    };
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\ldapsp.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		ldapsp.cpp
	Content:	This file contains the ldap service provider interface.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"

// Window handle of this layer's hidden window
//
HWND g_hWndHidden = NULL;

// Window handle of the COM layer's hidden window
//
HWND g_hWndNotify = NULL;

// Internal request thread
//
HANDLE g_hReqThread = NULL;
DWORD g_dwReqThreadID = 0;

// Hidden window class
//
extern TCHAR c_szWindowClassName[];

// Global generator for response ID
//
ULONG g_uRespID = 1;

// Global
//
DWORD g_dwClientSig = 0;

// Global counter for the times of initializations
//
LONG g_cInitialized = 0;


// Internal functions prototypes
//
VOID BuildStdAttrNameArray ( VOID );
TCHAR *AddBaseToFilter ( TCHAR *, const TCHAR * );
HRESULT _EnumClientsEx ( ULONG, TCHAR *, TCHAR *, ULONG, TCHAR *, LDAP_ASYNCINFO * );



/* ----------------------------------------------------------------------
	UlsLdap_Initialize

	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.
	10/30/96	Chu, Lon-Chan [lonchanc]
				Tested on ILS (7438)
   ---------------------------------------------------------------------- */

HRESULT UlsLdap_Initialize ( HWND hWndCallback )
{
	HRESULT hr;

	// Make sure this service provider is not initialized twice
	//
	if (g_cInitialized++ != 0)
		return S_OK;

	#ifdef DEBUG
	// Validate handler table
	//
	extern VOID DbgValidateHandlerTable ( VOID );
	DbgValidateHandlerTable ();
	#endif

	// Validate standard attribute name table
	//
	#ifdef DEBUG
	extern VOID DbgValidateStdAttrNameArray ( VOID );
	DbgValidateStdAttrNameArray ();
	#endif

	// Clean up the events for safe rollback
	//
	ZeroMemory (&g_ahThreadWaitFor[0], NUM_THREAD_WAIT_FOR * sizeof (HANDLE));

	// Initialize global settings via registry
	//
	if (! GetRegistrySettings ())
	{
		MyAssert (FALSE);
	}

	// Make sure the uls window handle is valid
	//
	if (! MyIsWindow (hWndCallback))
	{
		MyAssert (FALSE);
		g_cInitialized--;
		MyAssert (g_cInitialized == 0);
		return ILS_E_HANDLE;
	}

	// Cache the uls window handle
	//
	g_hWndNotify = hWndCallback;

	// Initialize ILS specifics
	//
	hr = IlsInitialize ();
	if (hr != S_OK)
		return hr;

	// Create events for inter-thread synchronization
	//
	g_fExitNow = FALSE;
	for (INT i = 0; i < NUM_THREAD_WAIT_FOR; i++)
	{	
		g_ahThreadWaitFor[i] = CreateEvent (NULL,	// no security
											FALSE,	// auto reset
											FALSE,	// not signaled initially
											NULL);	// no event name
		if (g_ahThreadWaitFor[i] == NULL)
		{
			hr = ILS_E_FAIL;
			goto MyExit;
		}
	}

	// Create an internal session container
	//
	g_pSessionContainer = new SP_CSessionContainer;
	if (g_pSessionContainer == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Initialize the internal session container
	//
	hr = g_pSessionContainer->Initialize (8, NULL);
	if (hr != S_OK)
		goto MyExit;

	// Create an internal pending request queue
	//
	g_pReqQueue = new SP_CRequestQueue;
	if (g_pReqQueue == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Create an internal pending response queue
	//
	g_pRespQueue = new SP_CResponseQueue;
	if (g_pRespQueue == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Create an internal refresh scheduler
	//
	g_pRefreshScheduler = new SP_CRefreshScheduler;
	if (g_pRefreshScheduler == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Create the hidden window
	//
	if (! MyCreateWindow ())
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Start WSA for subsequent host query in this service provider
	//
	WSADATA WSAData;
	if (WSAStartup (MAKEWORD (1, 1), &WSAData))
	{
		hr = ILS_E_WINSOCK;
		goto MyExit;
	}

	// Create an internal hidden request thread that
	// sends request and keep alive messages
	//
	g_hReqThread = CreateThread (NULL, 0,
								ReqThread,
								NULL, 0,
								&g_dwReqThreadID);
	if (g_hReqThread == NULL)
	{
		hr = ILS_E_THREAD;
		goto MyExit;
	}

	// Everything seems successful
	//
	hr = S_OK;

MyExit:

	if (hr != S_OK)
	{
		// Something wrong, roll back
		//
		g_cInitialized--;

		for (i = 0; i < NUM_THREAD_WAIT_FOR; i++)
		{
			if (g_ahThreadWaitFor[i] != NULL)
			{
				CloseHandle (g_ahThreadWaitFor[i]);
				g_ahThreadWaitFor[i] = NULL;
			}
		}

		IlsCleanup ();

		if (g_pSessionContainer != NULL)
		{
			delete g_pSessionContainer;
			g_pSessionContainer = NULL;
		}

		if (g_pReqQueue != NULL)
		{
			delete g_pReqQueue;
			g_pReqQueue = NULL;
		}

		if (g_pRespQueue != NULL)
		{
			delete g_pRespQueue;
			g_pRespQueue = NULL;
		}

		if (g_pRefreshScheduler != NULL)
		{
			delete g_pRefreshScheduler;
			g_pRefreshScheduler = NULL;
		}

		// Unconditional call to WSACleanup() will not cause any problem
		// because it simply returns WSAEUNINITIALIZED.
		//
		WSACleanup ();

		MyAssert (g_hReqThread == NULL);
		MyAssert (g_cInitialized == 0);
	}

	return hr;
}

/* ----------------------------------------------------------------------
	UlsLdap_Deinitialize

	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.
	10/30/96	Chu, Lon-Chan [lonchanc]
				Tested on ILS (7438)
   ---------------------------------------------------------------------- */

HRESULT UlsLdap_Deinitialize ( VOID )
{
	HRESULT hr = S_OK;

	// Make sure this service provider is initialized
	//
	if (--g_cInitialized != 0)
	{
		if (g_cInitialized < 0)
		{
			MyAssert (FALSE);
			g_cInitialized = 0;
			return ILS_E_NOT_INITIALIZED;
		}
		return S_OK;
	}

	// Make sure we have a valid internal hidden window handle
	//
	if (MyIsWindow (g_hWndHidden))
	{
		// Kill poll timer
		//
		KillTimer (g_hWndHidden, ID_TIMER_POLL_RESULT);

		// Destroy the hidden window
		//
		DestroyWindow (g_hWndHidden);

		// Unregister the window class
		//
		UnregisterClass (c_szWindowClassName, g_hInstance);
	}
	else
	{
		MyAssert (FALSE);
	}

	// Is the request thread alive?
	//
	if (g_hReqThread != NULL)
	{
		// Signal the request thread to exit
		//
		SetEvent (g_hevExitReqThread);
		g_fExitNow = TRUE;

		// Wait for the request thread to respond
		//
		DWORD dwResult;
		#define REQ_THREAD_EXIT_TIMEOUT		10000	// 10 seconds timeout
		ULONG tcTimeout = REQ_THREAD_EXIT_TIMEOUT;
		ULONG tcTarget = GetTickCount () + tcTimeout;
		do
		{
			dwResult = (g_hReqThread != NULL) ?
						MsgWaitForMultipleObjects (
								1,
								&g_hReqThread,
								FALSE,
								tcTimeout,
								QS_ALLINPUT) :
						WAIT_OBJECT_0;

			if (dwResult == (WAIT_OBJECT_0 + 1))
			{
				// Insure that this thread continues to respond
				//
				if (! KeepUiResponsive ())
				{
					dwResult = WAIT_TIMEOUT;
					break;
				}
			}

			// Make sure we only wait for 90 seconds totally
			//
			tcTimeout = tcTarget - GetTickCount ();
		}
		// If the thread does not exit, let's continue to wait.
		//
		while (	dwResult == (WAIT_OBJECT_0 + 1) &&
				tcTimeout <= REQ_THREAD_EXIT_TIMEOUT);

		// Make sure we propagate back the error that
		// the internal request thread is not responding
		//
		if (dwResult == WAIT_TIMEOUT)
		{
		#ifdef _DEBUG
		    DBG_REF("ULS Terminating internal thread");
		#endif
			hr = ILS_E_THREAD;
			TerminateThread (g_hReqThread, (DWORD) -1);
		}

		// Clean up the internal hidden thread descriptor
		//
		CloseHandle (g_hReqThread);
		g_hReqThread = NULL;
		g_dwReqThreadID = 0;
	} // if (g_hReqThread != NULL)

	// Clean up inter-thread synchronization
	//
	for (INT i = 0; i < NUM_THREAD_WAIT_FOR; i++)
	{
		if (g_ahThreadWaitFor[i] != NULL)
		{
			CloseHandle (g_ahThreadWaitFor[i]);
			g_ahThreadWaitFor[i] = NULL;
		}
	}

    IlsCleanup();

	// Free the internal session container
	//
	if (g_pSessionContainer != NULL)
	{
		delete g_pSessionContainer;
		g_pSessionContainer = NULL;
	}

	// Free the internal pending request queue
	//
	if (g_pReqQueue != NULL)
	{
		delete g_pReqQueue;
		g_pReqQueue = NULL;
	}

	// Free the internal pending response queue
	//
	if (g_pRespQueue != NULL)
	{
		delete g_pRespQueue;
		g_pRespQueue = NULL;
	}

	// Free the refresh scheduler object
	//
	if (g_pRefreshScheduler != NULL)
	{
		delete g_pRefreshScheduler;
		g_pRefreshScheduler = NULL;
	}

	// Unconditional call to WSACleanup() will not cause any problem
	// because it simply returns WSAEUNINITIALIZED.
	//
	WSACleanup ();

	return hr;
}


/* ----------------------------------------------------------------------
	UlsLdap_Cancel

	History:
	10/30/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

HRESULT UlsLdap_Cancel ( ULONG uMsgID )
{
	HRESULT hr = ILS_E_FAIL;

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	if (g_pRespQueue == NULL || g_pReqQueue == NULL)
	{
		MyAssert (FALSE);
		return ILS_E_FAIL;
	}

	// The locking order is
	// Lock(PendingOpQueue), Lock(RequestQueue), Lock (CurrOp)
	//
	g_pRespQueue->WriteLock ();
	g_pReqQueue->WriteLock ();
	g_pReqQueue->LockCurrOp ();

	// Redirect the call to the pending op queue object
	//
	hr = g_pRespQueue->Cancel (uMsgID);
	if (hr != S_OK)
	{
		// Redirect the call to the request queue object
		//
		hr = g_pReqQueue->Cancel (uMsgID);
	}

	// Unlock is always in the reverse order of lock
	//
	g_pReqQueue->UnlockCurrOp ();
	g_pReqQueue->WriteUnlock ();
	g_pRespQueue->WriteUnlock ();

	return S_OK;
}


LPARAM
AsynReq_Cancel ( MARSHAL_REQ *pReq )
{
	HRESULT hr = S_OK;

	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_CANCEL);

	// Delinearize parameters
	//
	ULONG uRespID = (ULONG) MarshalReq_GetParam (pReq, 0);

	// Cancelling in request queue is easy and done in UlsLdap_Cancel()
	// because the request is not sent to the server yet.
	// Cancelling in CurrOp is also easy because the request thread will
	// find out that the current request is cancelled and then can call
	// g_pRespQueue->Cancel() in the request thread (not UI thread).
	// Cancelling in pending op queue is tricky. I have to marshal it to
	// the request thread to do it. This is why AsynReq_Cancel is called!!!

	// Redirect the call to the pending op queue object
	//
	if (g_pRespQueue != NULL)
	{
		hr = g_pRespQueue->Cancel (uRespID);
	}
	else
	{
		MyAssert (FALSE);
	}

	return (LPARAM) hr;
}

/* ----------------------------------------------------------------------
	UlsLdap_RegisterClient

	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.
	10/30/96	Chu, Lon-Chan [lonchanc]
				Tested on ILS (7438)
	1/14/97		Chu, Lon-Chan [lonchanc]
				Collapsed user/app objects.
   ---------------------------------------------------------------------- */

HRESULT
UlsLdap_RegisterClient (
	DWORD_PTR		dwContext,
    SERVER_INFO     *pServer,
	LDAP_CLIENTINFO	*pInfo,
	HANDLE			*phClient,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Maks sure the server name is valid
	//
	if (MyIsBadServerInfo (pServer))
		return ILS_E_POINTER;

	// Make sure the returned handle
	//
	if (phClient == NULL)
		return ILS_E_POINTER;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Make sure the client info structure is valid
	//
	#ifdef STRICT_CHECK
	if (MyIsBadWritePtr (pInfo, sizeof (*pInfo)))
		return ILS_E_POINTER;
	#endif

	// Make sure the unique id is valid
	//
	TCHAR *pszCN = (TCHAR *) ((BYTE *) pInfo + pInfo->uOffsetCN);
	if (pInfo->uOffsetCN == INVALID_OFFSET || *pszCN == TEXT ('\0'))
		return ILS_E_PARAMETER;

	// Make sure no modify/remove extended attributes
	// Registration only allows ToAdd
	//
	if (pInfo->cAttrsToModify != 0 || pInfo->cAttrsToRemove != 0)
		return ILS_E_PARAMETER;

	// Compute the total size of the data
	//
	ULONG cbServer = IlsGetLinearServerInfoSize (pServer);
	ULONG cParams = 3;
	ULONG cbSize = cbServer + pInfo->uSize;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_REGISTER_CLIENT, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Create a local client object
	//
	HRESULT hr;
	SP_CClient *pClient = new SP_CClient (dwContext);
	if (pClient == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Make sure this client object will not go away unexpectedly
	//
	pClient->AddRef ();

	// Linearize parameters
	//
	MarshalReq_SetParamServer (pReq, 0, pServer, cbServer);
	MarshalReq_SetParam (pReq, 1, (DWORD_PTR) pInfo, pInfo->uSize);
	MarshalReq_SetParam (pReq, 2, (DWORD_PTR) pClient, 0);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

MyExit:

	if (hr == S_OK)
	{
		*phClient = (HANDLE) pClient;
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_RegisterClient ( MARSHAL_REQ *pReq )
{
	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_REGISTER_CLIENT);

	// Delinearize parameters
	//
	SERVER_INFO *pServer = (SERVER_INFO *) MarshalReq_GetParam (pReq, 0);
	LDAP_CLIENTINFO	*pInfo = (LDAP_CLIENTINFO *) MarshalReq_GetParam (pReq, 1);
	SP_CClient *pClient = (SP_CClient *) MarshalReq_GetParam (pReq, 2);

	// Register the client object on the server
	//
	HRESULT hr = pClient->Register (pReq->uRespID, pServer, pInfo);
	if (hr != S_OK)
	{
		// Release this newly allocated local user object
		//
		pClient->Release ();
	}

	return (LPARAM) hr;
}


/* ----------------------------------------------------------------------
	UlsLdap_RegisterProtocol

	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.
	10/30/96	Chu, Lon-Chan [lonchanc]
				Blocked by ILS (7438, 7442)
   ---------------------------------------------------------------------- */

HRESULT
UlsLdap_RegisterProtocol (
	HANDLE			hClient,
	LDAP_PROTINFO	*pInfo,
	HANDLE			*phProt,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Convert handle to pointer
	//
	SP_CClient *pClient = (SP_CClient *) hClient;

	// Make sure the parent local app object is valid
	//
	if (MyIsBadWritePtr (pClient, sizeof (*pClient)) ||
		! pClient->IsValidObject () ||
		! pClient->IsRegistered ())
		return ILS_E_HANDLE;

	// Make sure the returned handle
	//
	if (phProt == NULL)
		return ILS_E_POINTER;

	// Make sure the prot info structure is valid
	//
	#ifdef STRICT_CHECK
	if (MyIsBadWritePtr (pInfo, sizeof (*pInfo)))
		return ILS_E_POINTER;
	#endif

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Make sure the protocol name is valid
	//
	TCHAR *pszProtName = (TCHAR *) ((BYTE *) pInfo + pInfo->uOffsetName);
	if (pInfo->uOffsetName == INVALID_OFFSET || *pszProtName == TEXT ('\0'))
		return ILS_E_PARAMETER;

	// Compute the total size of the data
	//
	ULONG cParams = 3;
	ULONG cbSize = pInfo->uSize;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_REGISTER_PROTOCOL, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Create a local prot object
	//
	SP_CProtocol *pProt = new SP_CProtocol (pClient);
	if (pProt == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Make sure the local prot object will not be deleted randomly
	//
	pProt->AddRef ();

	// Linearize parameters
	//
	MarshalReq_SetParam (pReq, 0, (DWORD_PTR) pClient, 0);
	MarshalReq_SetParam (pReq, 1, (DWORD_PTR) pInfo, pInfo->uSize);
	MarshalReq_SetParam (pReq, 2, (DWORD_PTR) pProt, 0);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

MyExit:

	if (hr == S_OK)
	{
		*phProt = (HANDLE) pProt;
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_RegisterProtocol ( MARSHAL_REQ *pReq )
{
	HRESULT hr;

	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_REGISTER_PROTOCOL);

	// Delinearize parameters
	//
	SP_CClient *pClient = (SP_CClient *) MarshalReq_GetParam (pReq, 0);
	LDAP_PROTINFO *pInfo = (LDAP_PROTINFO *) MarshalReq_GetParam (pReq, 1);
	SP_CProtocol *pProt = (SP_CProtocol *) MarshalReq_GetParam (pReq, 2);

	// Make sure the parent local app object is valid
	//
	if (MyIsBadWritePtr (pClient, sizeof (*pClient)) ||
		! pClient->IsValidObject () ||
		! pClient->IsRegistered ())
	{
		hr = ILS_E_HANDLE;
	}
	else
	{
		// Make the local prot object do prot registration
		//
		hr = pProt->Register (pReq->uRespID, pInfo);
		if (hr != S_OK)
		{
			// Release the newly allocated local prot object
			//
			pProt->Release ();
		}
	}

	return (LPARAM) hr;
}


/* ----------------------------------------------------------------------
	UlsLdap_RegisterMeeting

	Input:
		pszServer: A pointer to the server name.
		pMeetInfo: A pointer to meeting info structure.
		phMtg: A return meeting object handle.
		pAsyncInfo: A pointer to async info structure.

	History:
	12/02/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

#ifdef ENABLE_MEETING_PLACE
HRESULT
UlsLdap_RegisterMeeting (
	DWORD			dwContext,
	SERVER_INFO		*pServer,
	LDAP_MEETINFO	*pInfo,
	HANDLE			*phMtg,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Maks sure the server name is valid
	//
	if (MyIsBadServerInfo (pServer))
		return ILS_E_POINTER;

	// Make sure the returned handle
	//
	if (phMtg == NULL)
		return ILS_E_POINTER;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Make sure the user info structure is valid
	//
	#ifdef STRICT_CHECK
	if (MyIsBadWritePtr (pInfo, sizeof (*pInfo)))
		return ILS_E_POINTER;
	#endif

	// Make sure the unique id is valid
	//
	TCHAR *pszName = (TCHAR *) ((BYTE *) pInfo + pInfo->uOffsetMeetingPlaceID);
	if (pInfo->uOffsetMeetingPlaceID == INVALID_OFFSET || *pszName == TEXT ('\0'))
		return ILS_E_PARAMETER;

	// Make sure no modify/remove extended attributes
	// Registration only allows ToAdd
	//
	if (pInfo->cAttrsToModify != 0 || pInfo->cAttrsToRemove != 0)
		return ILS_E_PARAMETER;

	// Compute the total size of the data
	//
	ULONG cbServer = IlsGetLinearServerInfoSize (pServer);
	ULONG cParams = 3;
	ULONG cbSize = cbServer + pInfo->uSize;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_REGISTER_MEETING, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Create a local user object
	//
	SP_CMeeting *pMtg = new SP_CMeeting (dwContext);
	if (pMtg == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Make sure this local user object will not go away randomly
	//
	pMtg->AddRef ();

	// Linearize parameters
	//
	MarshalReq_SetParamServer (pReq, 0, pServer, cbServer);
	MarshalReq_SetParam (pReq, 1, (DWORD) pInfo, pInfo->uSize);
	MarshalReq_SetParam (pReq, 2, (DWORD) pMtg, 0);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

MyExit:

	if (hr == S_OK)
	{
		*phMtg = (HANDLE) pMtg;
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_RegisterMeeting ( MARSHAL_REQ *pReq )
{
	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_REGISTER_MEETING);

	// Delinearize parameters
	//
	SERVER_INFO *pServer = (SERVER_INFO *) MarshalReq_GetParam (pReq, 0);
	LDAP_MEETINFO *pInfo = (LDAP_MEETINFO *) MarshalReq_GetParam (pReq, 1);
	SP_CMeeting *pMtg = (SP_CMeeting *) MarshalReq_GetParam (pReq, 2);

	// Make the local meeting object do meeting registration
	//
	HRESULT hr = pMtg->Register (pReq->uRespID, pServer, pInfo);
	if (hr != S_OK)
	{
		// Release this newly allocated local user object
		//
		pMtg->Release ();
	}

	return (LPARAM) hr;
}
#endif // ENABLE_MEETING_PLACE


/* ----------------------------------------------------------------------
	UlsLdap_UnRegisterClient

	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.
	10/30/96	Chu, Lon-Chan [lonchanc]
				Tested on ILS (7438)
	1/14/97		Chu, Lon-Chan [lonchanc]
				Collapsed user/app objects.
   ---------------------------------------------------------------------- */

HRESULT
UlsLdap_UnRegisterClient (
	HANDLE			hClient,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Convert handle to pointer
	//
	SP_CClient *pClient = (SP_CClient *) hClient;

	// Make sure the local client object is valid
	//
	if (MyIsBadWritePtr (pClient, sizeof (*pClient)) ||
		! pClient->IsValidObject () ||
		! pClient->IsRegistered ())
		return ILS_E_HANDLE;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Compute the total size of the data
	//
	ULONG cParams = 1;
	ULONG cbSize = 0;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_UNREGISTER_CLIENT, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Linearize parameters
	//
	MarshalReq_SetParam (pReq, 0, (DWORD_PTR) pClient, 0);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

	if (hr == S_OK)
	{
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_UnRegisterClient ( MARSHAL_REQ *pReq )
{
	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_UNREGISTER_CLIENT);

	// Delinearize parameters
	//
	SP_CClient *pClient = (SP_CClient *) MarshalReq_GetParam (pReq, 0);

	// Make sure the local client object is valid
	//
	HRESULT hr;
	if (MyIsBadWritePtr (pClient, sizeof (*pClient)) ||
		! pClient->IsValidObject () ||
		! pClient->IsRegistered ())
	{
		// When submitting this request, the client object is fine
		// but now it is not, so it must have been unregistered and released.
		//
		MyAssert (FALSE); // to see if any one tries to break it this way!!!
		hr = S_OK;
	}
	else
	{
		// Make the client object do user unregistration
		//
		hr = pClient->UnRegister (pReq->uRespID);

		// Free this client object
		//
		pClient->Release ();
	}

	return (LPARAM) hr;
}

/* ----------------------------------------------------------------------
	UlsLdap_UnRegisterProtocol

	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.
	10/30/96	Chu, Lon-Chan [lonchanc]
				Tested on ILS (7438)
   ---------------------------------------------------------------------- */

HRESULT UlsLdap_VirtualUnRegisterProtocol ( HANDLE hProt )
{
	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Convert handle to pointer
	//
	SP_CProtocol *pProt = (SP_CProtocol *) hProt;

	// Make sure the local prot object is valid
	//
	if (MyIsBadWritePtr (pProt, sizeof (*pProt)))
		return ILS_E_HANDLE;

	// Free this local prot object
	//
	pProt->Release ();

    return S_OK;
}

HRESULT UlsLdap_UnRegisterProtocol (
	HANDLE			hProt,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Convert handle to pointer
	//
	SP_CProtocol *pProt = (SP_CProtocol *) hProt;

	// Make sure the local prot object is valid
	//
	if (MyIsBadWritePtr (pProt, sizeof (*pProt)) ||
		! pProt->IsValidObject () ||
		! pProt->IsRegistered ())
		return ILS_E_HANDLE;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Compute the total size of the data
	//
	ULONG cParams = 1;
	ULONG cbSize = 0;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_UNREGISTER_PROTOCOL, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Linearize parameters
	//
	MarshalReq_SetParam (pReq, 0, (DWORD_PTR) pProt, 0);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

	if (hr == S_OK)
	{
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_UnRegisterProt ( MARSHAL_REQ *pReq )
{
	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_UNREGISTER_PROTOCOL);

	// Delinearize parameters
	//
	SP_CProtocol *pProt = (SP_CProtocol *) MarshalReq_GetParam (pReq, 0);

	// Make sure the local prot object is valid
	//
	HRESULT hr;
	if (MyIsBadWritePtr (pProt, sizeof (*pProt)) ||
		! pProt->IsValidObject () ||
		! pProt->IsRegistered ())
	{
		// When submitting this request, the client object is fine
		// but now it is not, so it must have been unregistered and released.
		//
		MyAssert (FALSE); // to see if any one tries to break it this way!!!
		hr = S_OK;
	}
	else
	{
		// Make the local prot object do prot unregistration
		//
		hr = pProt->UnRegister (pReq->uRespID);

		// Free this local prot object
		//
		pProt->Release ();
	}

	return (LPARAM) hr;
}


/* ----------------------------------------------------------------------
	UlsLdap_UnRegisterMeeting

	Input:
		pszServer: server name.
		hMeeting: a handle to the meeting object.
		pAsyncInfo: a pointer to async info structure.

	History:
	12/02/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

#ifdef ENABLE_MEETING_PLACE
HRESULT UlsLdap_UnRegisterMeeting (
	HANDLE			hMtg,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Convert handle to pointer
	//
	SP_CMeeting *pMtg = (SP_CMeeting *) hMtg;

	// Make sure the local user object is valid
	//
	if (MyIsBadWritePtr (pMtg, sizeof (*pMtg)) ||
		! pMtg->IsValidObject () ||
		! pMtg->IsRegistered ())
		return ILS_E_HANDLE;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Compute the total size of the data
	//
	ULONG cParams = 1;
	ULONG cbSize = 0;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_UNREGISTER_MEETING, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Linearize parameters
	//
	MarshalReq_SetParam (pReq, 0, (DWORD) pMtg, 0);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

	if (hr == S_OK)
	{
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_UnRegisterMeeting ( MARSHAL_REQ *pReq )
{
	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_UNREGISTER_MEETING);

	// Delinearize parameters
	//
	SP_CMeeting *pMtg = (SP_CMeeting *) MarshalReq_GetParam (pReq, 0);

	// Make sure the local user object is valid
	//
	HRESULT hr;
	if (MyIsBadWritePtr (pMtg, sizeof (*pMtg)) ||
		! pMtg->IsValidObject () ||
		! pMtg->IsRegistered ())
	{
		// When submitting this request, the client object is fine
		// but now it is not, so it must have been unregistered and released.
		//
		MyAssert (FALSE); // to see if any one tries to break it this way!!!
		hr = S_OK;
	}
	else
	{
		// Make the local user object do user unregistration
		//
		hr = pMtg->UnRegister (pReq->uRespID);

		// Free this local user object
		//
		pMtg->Release ();
	}

	return (LPARAM) hr;
}
#endif // ENABLE_MEETING_PLACE


/* ----------------------------------------------------------------------
	UlsLdap_SetClientInfo

	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.
	10/30/96	Chu, Lon-Chan [lonchanc]
				Tested on ILS (7438)
	1/14/97		Chu, Lon-Chan [lonchanc]
				Collapsed user/app objects.
   ---------------------------------------------------------------------- */

HRESULT
UlsLdap_SetClientInfo (
	HANDLE			hClient,
	LDAP_CLIENTINFO	*pInfo,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Convert handle to pointer
	//
	SP_CClient *pClient = (SP_CClient *) hClient;

	// Make sure the client object is valid
	//
	if (MyIsBadWritePtr (pClient, sizeof (*pClient)) ||
		! pClient->IsValidObject () ||
		! pClient->IsRegistered ())
		return ILS_E_HANDLE;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Make sure the user info structure is valid
	//
	#ifdef STRICT_CHECK
	if (MyIsBadWritePtr (pInfo, sizeof (*pInfo)))
		return ILS_E_POINTER;
	#endif

	// We should not change the app name here
	//
	if (pInfo->uOffsetAppName != INVALID_OFFSET || pInfo->uOffsetCN != INVALID_OFFSET)
		return ILS_E_PARAMETER; // ILS_E_READ_ONLY;

	// lonchanc: BUGS
	// ISBU requires us to block any change of components of dn
	//
	pInfo->uOffsetCountryName = 0;

	// Compute the total size of the data
	//
	ULONG cParams = 2;
	ULONG cbSize = pInfo->uSize;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_SET_CLIENT_INFO, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Linearize parameters
	//
	MarshalReq_SetParam (pReq, 0, (DWORD_PTR) pClient, 0);
	MarshalReq_SetParam (pReq, 1, (DWORD_PTR) pInfo, pInfo->uSize);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

	if (hr == S_OK)
	{
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_SetClientInfo ( MARSHAL_REQ *pReq )
{
	HRESULT hr = S_OK;

	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_SET_CLIENT_INFO);

	// Delinearize parameters
	//
	SP_CClient *pClient = (SP_CClient *) MarshalReq_GetParam (pReq, 0);
	LDAP_CLIENTINFO *pInfo = (LDAP_CLIENTINFO *) MarshalReq_GetParam (pReq, 1);

	// Make sure the local client object is valid
	//
	if (MyIsBadWritePtr (pClient, sizeof (*pClient)) ||
		! pClient->IsValidObject () ||
		! pClient->IsRegistered ())
	{
		// When submitting this request, the client object is fine
		// but now it is not, so it must have been unregistered and released.
		//
		MyAssert (FALSE); // to see if any one tries to break it this way!!!
		hr = ILS_E_HANDLE;
	}
	else
	{
		// Set standard attributes
		//
		hr = pClient->SetAttributes (pReq->uRespID, pInfo);
	}

	return (LPARAM) hr;
}


/* ----------------------------------------------------------------------
	UlsLdap_SetProtocolInfo

	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.
	10/30/96	Chu, Lon-Chan [lonchanc]
				Blocked by ILS (7438, 7442)
   ---------------------------------------------------------------------- */

HRESULT UlsLdap_SetProtocolInfo (
	HANDLE			hProt,
	LDAP_PROTINFO	*pInfo,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Convert handle to pointer
	//
	SP_CProtocol *pProt = (SP_CProtocol *) hProt;

	// Make sure the local prot object is valid
	//
	if (MyIsBadWritePtr (pProt, sizeof (*pProt)) ||
		! pProt->IsValidObject () ||
		! pProt->IsRegistered ())
		return ILS_E_HANDLE;

	// Make sure the prot info structure is valid
	//
	#ifdef STRICT_CHECK
	if (MyIsBadWritePtr (pInfo, sizeof (*pInfo)))
		return ILS_E_POINTER;
	#endif

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Compute the total size of the data
	//
	ULONG cParams = 2;
	ULONG cbSize = pInfo->uSize;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_SET_PROTOCOL_INFO, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Linearize parameters
	//
	MarshalReq_SetParam (pReq, 0, (DWORD_PTR) pProt, 0);
	MarshalReq_SetParam (pReq, 1, (DWORD_PTR) pInfo, pInfo->uSize);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

	if (hr == S_OK)
	{
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_SetProtocolInfo ( MARSHAL_REQ *pReq )
{
	HRESULT hr = S_OK;

	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_SET_PROTOCOL_INFO);

	// Delinearize parameters
	//
	SP_CProtocol *pProt = (SP_CProtocol *) MarshalReq_GetParam (pReq, 0);
	LDAP_PROTINFO *pInfo = (LDAP_PROTINFO *) MarshalReq_GetParam (pReq, 1);

	// Make sure the local client object is valid
	//
	if (MyIsBadWritePtr (pProt, sizeof (*pProt)) ||
		! pProt->IsValidObject () ||
		! pProt->IsRegistered ())
	{
		// When submitting this request, the client object is fine
		// but now it is not, so it must have been unregistered and released.
		//
		MyAssert (FALSE); // to see if any one tries to break it this way!!!
		hr = ILS_E_HANDLE;
	}
	else
	{
		// Set standard attributes
		//
		hr = pProt->SetAttributes (pReq->uRespID, pInfo);
	}

	return (LPARAM) hr;
}


/* ----------------------------------------------------------------------
	UlsLdap_SetMeetingInfo

	Input:
		pszServer: A server name.
		pszMtgName: A meeting id string.
		pMeetInfo: A pointer to meeting info structure.
		pAsyncInfo: A pointer to async info structure.

	History:
	12/02/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

#ifdef ENABLE_MEETING_PLACE
HRESULT UlsLdap_SetMeetingInfo (
	SERVER_INFO		*pServer,
	TCHAR			*pszMtgName,
	LDAP_MEETINFO	*pInfo,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Make sure we have valid pointers
	//
	if (MyIsBadServerInfo (pServer) || MyIsBadString (pszMtgName))
		return ILS_E_POINTER;

	// Make sure the app info structure is valid
	//
	#ifdef STRICT_CHECK
	if (MyIsBadWritePtr (pInfo, sizeof (*pInfo)))
		return ILS_E_POINTER;
	#endif

	// Make sure we do not change meeting name
	//
	if (pInfo->uOffsetMeetingPlaceID != 0)
		return ILS_E_PARAMETER;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Compute the total size of the data
	//
	ULONG cbServer = IlsGetLinearServerInfoSize (pServer);
	ULONG cbSizeMtgName = (lstrlen (pszMtgName) + 1) * sizeof (TCHAR);
	ULONG cParams = 3;
	ULONG cbSize = cbServer + cbSizeMtgName + pInfo->uSize;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_SET_MEETING_INFO, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Linearize parameters
	//
	MarshalReq_SetParamServer (pReq, 0, pServer, cbServer);
	MarshalReq_SetParam (pReq, 1, (DWORD) pszMtgName, cbSizeMtgName);
	MarshalReq_SetParam (pReq, 2, (DWORD) pInfo, pInfo->uSize);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

	if (hr == S_OK)
	{
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_SetMeetingInfo ( MARSHAL_REQ *pReq )
{
	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_SET_MEETING_INFO);

	// Delinearize parameters
	//
	SERVER_INFO *pServer = (SERVER_INFO *) MarshalReq_GetParam (pReq, 0);
	TCHAR *pszMtgName = (TCHAR *) MarshalReq_GetParam (pReq, 1);
	LDAP_MEETINFO *pInfo = (LDAP_MEETINFO *) MarshalReq_GetParam (pReq, 2);

	MyAssert (! MyIsBadServerInfo (pServer));
	MyAssert (MyIsGoodString (pszMtgName));
	MyAssert (! MyIsBadWritePtr (pInfo, pInfo->uSize));

	// Set standard/arbitrary attributes
	//
	return (LPARAM) MtgSetAttrs (pServer, pszMtgName, pInfo, pReq->uRespID);
}
#endif // ENABLE_MEETING_PLACE


/* ----------------------------------------------------------------------
	My_EnumClientsEx

	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.
	10/30/96	Chu, Lon-Chan [lonchanc]
				Tested on ILS (7438)
	1/14/97		Chu, Lon-Chan [lonchanc]
				Collapsed user/app objects.
   ---------------------------------------------------------------------- */

HRESULT
My_EnumClientsEx (
	ULONG			uNotifyMsg,
	SERVER_INFO		*pServer,
	TCHAR			*pszAnyAttrNameList,
	ULONG			cAnyAttrNames,
	TCHAR			*pszFilter,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure we only deal with the following messages
	//
	MyAssert (	uNotifyMsg == WM_ILS_ENUM_CLIENTINFOS ||
				uNotifyMsg == WM_ILS_ENUM_CLIENTS);

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Maks sure the server name is valid
	//
	if (MyIsBadServerInfo (pServer))
		return ILS_E_POINTER;

	// Compute the total size of the data
	//
	ULONG cbServer = IlsGetLinearServerInfoSize (pServer);
	ULONG cbSizeAnyAttrNames = 0;
	TCHAR *psz = pszAnyAttrNameList;
	ULONG cch;
	for (ULONG i = 0; i < cAnyAttrNames; i++)
	{
		cch = lstrlen (psz) + 1;
		cbSizeAnyAttrNames += cch * sizeof (TCHAR);
		psz += cch;
	}
	ULONG cbSizeFilter = (pszFilter != NULL) ? (lstrlen (pszFilter) + 1) * sizeof (TCHAR) : 0;
	ULONG cParams = 4;
	ULONG cbSize = cbServer + cbSizeAnyAttrNames + cbSizeFilter;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (uNotifyMsg, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Linearize parameters
	//
	MarshalReq_SetParamServer (pReq, 0, pServer, cbServer);
	MarshalReq_SetParam (pReq, 1, (DWORD_PTR) pszAnyAttrNameList, cbSizeAnyAttrNames);
	MarshalReq_SetParam (pReq, 2, (DWORD) cAnyAttrNames, 0);
	MarshalReq_SetParam (pReq, 3, (DWORD_PTR) pszFilter, cbSizeFilter);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

	if (hr == S_OK)
	{
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_EnumClientsEx ( MARSHAL_REQ *pReq )
{
	HRESULT hr = S_OK;

	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	ULONG uNotifyMsg = pReq->uNotifyMsg;

	// Delinearize parameters
	//
	SERVER_INFO *pServer = (SERVER_INFO *) MarshalReq_GetParam (pReq, 0);
	TCHAR *pszAnyAttrNameList = (TCHAR *) MarshalReq_GetParam (pReq, 1);
	ULONG cAnyAttrNames = (ULONG) MarshalReq_GetParam (pReq, 2);
	TCHAR *pszFilter = (TCHAR *) MarshalReq_GetParam (pReq, 3);

	// Clean locals
	//
	SP_CSession *pSession = NULL;
	LDAP *ld;
	ULONG uMsgID = (ULONG) -1;

	// Create an array of names of attributes to return
	//
	TCHAR *apszAttrNames[COUNT_ENUM_DIR_CLIENT_INFO+1];
	TCHAR **ppszNameList = &apszAttrNames[0];
	ULONG cTotalNames;

	// See the input filter string
	//
	if (pszFilter != NULL)
	{
		MyDebugMsg ((ZONE_FILTER, "EC: in-filter=[%s]\r\n", pszFilter));
	}

	// Create a enum client filter
	//
	pszFilter = AddBaseToFilter (pszFilter, STR_DEF_CLIENT_BASE_DN);
	if (pszFilter == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// See the enhanced filter string
	//
	if (pszFilter != NULL)
	{
		MyDebugMsg ((ZONE_FILTER, "EC: out-filter=[%s]\r\n", pszFilter));
	}

	// Ask directory standard attributes only if enum client info
	//
	if (uNotifyMsg == WM_ILS_ENUM_CLIENTINFOS)
	{
		// Default total number of attributes
		//
		cTotalNames = COUNT_ENUM_DIR_CLIENT_INFO;

		// Do we want any extended attribute to be returned?
		//
		if (pszAnyAttrNameList != NULL && cAnyAttrNames != 0)
		{
			// Prefix arbitrary attribute names
			//
			pszAnyAttrNameList = IlsPrefixNameValueArray (FALSE, cAnyAttrNames,
										(const TCHAR *) pszAnyAttrNameList);
			if (pszAnyAttrNameList == NULL)
			{
				MemFree (pszFilter);
				hr = ILS_E_MEMORY;
				goto MyExit;
			}

			// Allocate memory for returned attributes' names
			//
			cTotalNames += cAnyAttrNames;
			ppszNameList = (TCHAR **) MemAlloc (sizeof (TCHAR *) * (cTotalNames + 1));
			if (ppszNameList == NULL)
			{
				MemFree (pszFilter);
				MemFree (pszAnyAttrNameList);
				hr = ILS_E_MEMORY;
				goto MyExit;
			}
		}
	}
	else
	{
		cTotalNames = 1;
	}

	// Ask to return cn only if enum names only
	//
	ppszNameList[0] = STR_CLIENT_CN;

	// Add names of standard/extended attributes to return
	//
	if (uNotifyMsg == WM_ILS_ENUM_CLIENTINFOS)
	{
		// Set up standard attribtues now
		//
		for (ULONG i = 1; i < COUNT_ENUM_DIR_CLIENT_INFO; i++)
		{
			ppszNameList[i] = (TCHAR *) c_apszClientStdAttrNames[i];
		}

		// Set arbitrary attribute names if needed
		//
		TCHAR *psz = pszAnyAttrNameList;
		for (i = COUNT_ENUM_DIR_CLIENT_INFO; i < cTotalNames; i++)
		{
			ppszNameList[i] = psz;
			psz += lstrlen (psz) + 1;
		}
	}

	// Terminate the list
	//
	ppszNameList[cTotalNames] = NULL;

	// Get a session object
	//
	hr = g_pSessionContainer->GetSession (&pSession, pServer);
	if (hr == S_OK)
	{
		// Get an ldap session
		//
		MyAssert (pSession != NULL);
		ld = pSession->GetLd ();
		MyAssert (ld != NULL);

		// Update options in ld
		//
		ld->ld_sizelimit = 0;	// no limit in the num of entries to return
		ld->ld_timelimit = 0;	// no limit on the time to spend on the search
		ld->ld_deref = LDAP_DEREF_ALWAYS;

		// Send search query
		//
		uMsgID = ldap_search (	ld,
								STR_DEF_CLIENT_BASE_DN, // base DN
								LDAP_SCOPE_BASE, // scope
								pszFilter, // filter
								ppszNameList, // attrs[]
								0);	// both type and value
		if (uMsgID == -1)
		{
			// This ldap_search failed.
			// Convert ldap error code to hr
			//
			hr = ::LdapError2Hresult (ld->ld_errno);

			// Free the session object
			//
			pSession->Disconnect ();
		}
	}

	// Free the filter string
	//
	MemFree (pszFilter);

	// Free the buffer holding all returned attribute names if needed
	//
	if (ppszNameList != &apszAttrNames[0])
		MemFree (ppszNameList);

	// Report failure if so
	//
	if (hr != S_OK)
	{
		// Free extended attribute name list
		//
		if (pszAnyAttrNameList != NULL && cAnyAttrNames != 0)
			MemFree (pszAnyAttrNameList);

		// Report failure
		//
		goto MyExit;
	}

	// Construct a pending info structure
	//
	RESP_INFO ri;
	FillDefRespInfo (&ri, pReq->uRespID, ld, uMsgID, INVALID_MSG_ID);
	ri.uNotifyMsg = uNotifyMsg;
	ri.cAnyAttrs = cAnyAttrNames;
	ri.pszAnyAttrNameList = pszAnyAttrNameList;

	// Queue this pending response
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		// Abort the ldap_search
		//
		ldap_abandon (ld, uMsgID);

		// Free the session object
		//
		pSession->Disconnect ();
		MyAssert (FALSE);
	}

MyExit:

	LDAP_ENUM *pEnum = NULL;
	if (hr != S_OK)
	{
		pEnum = (LDAP_ENUM *) MemAlloc (sizeof (LDAP_ENUM));
		if (pEnum != NULL)
		{
			pEnum->uSize = sizeof (*pEnum);
			pEnum->hResult = hr;
		}
	}

	return (LPARAM) pEnum;
}


/* ----------------------------------------------------------------------
	UlsLdap_EnumClients

	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.
	10/30/96	Chu, Lon-Chan [lonchanc]
				Tested on ILS (7438)
	1/14/97		Chu, Lon-Chan [lonchanc]
				Collapsed user/app objects.
   ---------------------------------------------------------------------- */

HRESULT
UlsLdap_EnumClients (
	SERVER_INFO		*pServer,
	TCHAR			*pszFilter,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	// Dispatch the call to a common subroutine
	//
	return My_EnumClientsEx (WM_ILS_ENUM_CLIENTS,
							pServer,
							NULL,
							0,
							pszFilter,
							pAsyncInfo);
}


/* ----------------------------------------------------------------------
	UlsLdap_EnumClientInfos

	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.
	10/30/96	Chu, Lon-Chan [lonchanc]
				Tested on ILS (7438)
	1/14/97		Chu, Lon-Chan [lonchanc]
				Collapsed user/app objects.
   ---------------------------------------------------------------------- */

HRESULT
UlsLdap_EnumClientInfos (
	SERVER_INFO		*pServer,
	TCHAR			*pszAnyAttrNameList,
	ULONG			cAnyAttrNames,
	TCHAR			*pszFilter,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	// Dispatch the call to a common subroutine
	//
	return My_EnumClientsEx (WM_ILS_ENUM_CLIENTINFOS,
							pServer,
							pszAnyAttrNameList,
							cAnyAttrNames,
							pszFilter,
							pAsyncInfo);
}


/* ----------------------------------------------------------------------
	UlsLdap_EnumProtocols

	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.
	10/30/96	Chu, Lon-Chan [lonchanc]
				Blocked by ILS (7438, 7442)
   ---------------------------------------------------------------------- */

HRESULT
UlsLdap_EnumProtocols (
	SERVER_INFO		*pServer,
	TCHAR			*pszUserName,
	TCHAR			*pszAppName,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	if (MyIsBadServerInfo (pServer) || MyIsBadString (pszUserName) ||
		MyIsBadString (pszAppName))
		return ILS_E_POINTER;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Compute the total size of the data
	//
	ULONG cbServer = IlsGetLinearServerInfoSize (pServer);
	ULONG cbSizeUserName = (lstrlen (pszUserName) + 1) * sizeof (TCHAR);
	ULONG cbSizeAppName = (lstrlen (pszAppName) + 1) * sizeof (TCHAR);
	ULONG cParams = 3;
	ULONG cbSize = cbServer + cbSizeUserName + cbSizeAppName;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_ENUM_PROTOCOLS, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Linearize parameters
	//
	MarshalReq_SetParamServer (pReq, 0, pServer, cbServer);
	MarshalReq_SetParam (pReq, 1, (DWORD_PTR) pszUserName, cbSizeUserName);
	MarshalReq_SetParam (pReq, 2, (DWORD_PTR) pszAppName, cbSizeAppName);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

	if (hr == S_OK)
	{
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_EnumProtocols ( MARSHAL_REQ *pReq )
{
	HRESULT hr = S_OK;
	SP_CSession *pSession = NULL;
	LDAP *ld;
	ULONG uMsgID = (ULONG) -1;

	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_ENUM_PROTOCOLS);

	// Delinearize parameters
	//
	SERVER_INFO *pServer = (SERVER_INFO *) MarshalReq_GetParam (pReq, 0);
	TCHAR *pszUserName = (TCHAR *) MarshalReq_GetParam (pReq, 1);
	TCHAR *pszAppName = (TCHAR *) MarshalReq_GetParam (pReq, 2);

	// Create enum protocols filter
	//
	TCHAR *pszFilter = ProtCreateEnumFilter (pszUserName, pszAppName);
	if (pszFilter == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Get the session object
	//
	hr = g_pSessionContainer->GetSession (&pSession, pServer);
	if (hr != S_OK)
	{
		MemFree (pszFilter);
		goto MyExit;
	}
	MyAssert (pSession != NULL);

	// Get an ldap session
	//
	ld = pSession->GetLd ();
	MyAssert (ld != NULL);

	// Create an array of names of attributes to return
	//
	TCHAR *apszAttrNames[2];
	apszAttrNames[0] = (TCHAR *) c_apszProtStdAttrNames[ENUM_PROTATTR_NAME];
	apszAttrNames[1] = NULL;

	// Update options in ld
	//
	ld->ld_sizelimit = 0;	// no limit in the num of entries to return
	ld->ld_timelimit = 0;	// no limit on the time to spend on the search
	ld->ld_deref = LDAP_DEREF_ALWAYS;

	// Send the search query
	//
	uMsgID = ldap_search (ld, (TCHAR *) &c_szDefClientBaseDN[0],	// base DN
									LDAP_SCOPE_BASE,	// scope
									pszFilter,
									&apszAttrNames[0],	// attrs[]
									0);	// both type and value
	// Free the search filter
	//
	MemFree (pszFilter);

	// Check the return of ldap_search
	//
	if (uMsgID == -1)
	{
		// This ldap_search failed.
		// Convert ldap error code to hr
		//
		hr = ::LdapError2Hresult (ld->ld_errno);

		// Free the session object
		//
		pSession->Disconnect ();
		goto MyExit;
	}

	// Construct a pending info structure
	//
	RESP_INFO ri;
	FillDefRespInfo (&ri, pReq->uRespID, ld, uMsgID, INVALID_MSG_ID);
	ri.uNotifyMsg = WM_ILS_ENUM_PROTOCOLS;

	// Queue this pending response
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		// Abort the ldap_search
		//
		ldap_abandon (ld, uMsgID);

		// Free the session object
		//
		pSession->Disconnect ();
		MyAssert (FALSE);
	}

MyExit:

	LDAP_ENUM *pEnum = NULL;
	if (hr != S_OK)
	{
		pEnum = (LDAP_ENUM *) MemAlloc (sizeof (LDAP_ENUM));
		if (pEnum != NULL)
		{
			pEnum->uSize = sizeof (*pEnum);
			pEnum->hResult = hr;
		}
	}

	return (LPARAM) pEnum;
}


/* ----------------------------------------------------------------------
	My_EnumMtgsEx

	Input:
		uNotifyMsg: A notification message.
		pszServer: A pointer to the server name.
		pszFilter: A pointer to a filter string.
		pAsyncInfo: A pointer to async info structure.

	History:
	12/02/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

#ifdef ENABLE_MEETING_PLACE
HRESULT
My_EnumMtgsEx (
	ULONG			uNotifyMsg,
	SERVER_INFO		*pServer,
	TCHAR			*pszAnyAttrNameList,
	ULONG			cAnyAttrNames,
	TCHAR			*pszFilter,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure we only deal with the following messages
	//
	MyAssert (	uNotifyMsg == WM_ILS_ENUM_MEETINGINFOS ||
				uNotifyMsg == WM_ILS_ENUM_MEETINGS);

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Maks sure the server name is valid
	//
	if (MyIsBadServerInfo (pServer))
		return ILS_E_POINTER;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Compute the total size of the data
	//
	ULONG cbServer = IlsGetLinearServerInfoSize (pServer);
	ULONG cbSizeAnyAttrNames = 0;
	TCHAR *psz = pszAnyAttrNameList;
	ULONG cch;
	for (ULONG i = 0; i < cAnyAttrNames; i++)
	{
		cch = lstrlen (psz) + 1;
		cbSizeAnyAttrNames += cch * sizeof (TCHAR);
		psz += cch;
	}
	ULONG cbSizeFilter = (pszFilter != NULL) ? (lstrlen (pszFilter) + 1) * sizeof (TCHAR) : 0;
	ULONG cParams = 4;
	ULONG cbSize = cbServer + cbSizeAnyAttrNames + cbSizeFilter;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (uNotifyMsg, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Linearize parameters
	//
	MarshalReq_SetParamServer (pReq, 0, pServer, cbServer);
	MarshalReq_SetParam (pReq, 1, (DWORD) pszAnyAttrNameList, cbSizeAnyAttrNames);
	MarshalReq_SetParam (pReq, 2, (DWORD) cAnyAttrNames, 0);
	MarshalReq_SetParam (pReq, 3, (DWORD) pszFilter, cbSizeFilter);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

	if (hr == S_OK)
	{
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_EnumMtgsEx ( MARSHAL_REQ *pReq )
{
	HRESULT hr = S_OK;

	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	ULONG uNotifyMsg = pReq->uNotifyMsg;

	// Delinearize parameters
	//
	SERVER_INFO *pServer = (SERVER_INFO *) MarshalReq_GetParam (pReq, 0);
	TCHAR *pszAnyAttrNameList = (TCHAR *) MarshalReq_GetParam (pReq, 1);
	ULONG cAnyAttrNames = (ULONG) MarshalReq_GetParam (pReq, 2);
	TCHAR *pszFilter = (TCHAR *) MarshalReq_GetParam (pReq, 3);

	// Clean locals
	//
	SP_CSession *pSession = NULL;
	LDAP *ld;
	ULONG uMsgID = (ULONG) -1;

	// Create an array of names of attributes to return
	//
	TCHAR *apszAttrNames[COUNT_ENUM_DIRMTGINFO+1];
	TCHAR **ppszNameList = &apszAttrNames[0];
	ULONG cTotalNames;

	// See the input filter string
	//
	if (pszFilter != NULL)
	{
		MyDebugMsg ((ZONE_FILTER, "EU: in-filter=[%s]\r\n", pszFilter));
	}

	// Create a enum user filter
	//
	pszFilter = AddBaseToFilter (pszFilter, &c_szDefMtgBaseDN[0]);
	if (pszFilter == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// See the enhanced filter string
	//
	if (pszFilter != NULL)
	{
		MyDebugMsg ((ZONE_FILTER, "EU: out-filter=[%s]\r\n", pszFilter));
	}

	// Ask directory standard attributes only if enum dir user info
	//
	if (uNotifyMsg == WM_ILS_ENUM_MEETINGINFOS)
	{
		// Default total number of attributes
		//
		cTotalNames = COUNT_ENUM_DIRMTGINFO;

		// Do we want any extended attribute to be returned?
		//
		if (pszAnyAttrNameList != NULL && cAnyAttrNames != 0)
		{
			// Prefix arbitrary attribute names
			//
			pszAnyAttrNameList = IlsPrefixNameValueArray (FALSE, cAnyAttrNames,
													(const TCHAR *) pszAnyAttrNameList);
			if (pszAnyAttrNameList == NULL)
			{
				MemFree (pszFilter);
				hr = ILS_E_MEMORY;
				goto MyExit;
			}

			// Allocate memory for returned attributes' names
			//
			cTotalNames += cAnyAttrNames;
			ppszNameList = (TCHAR **) MemAlloc (sizeof (TCHAR *) * (cTotalNames + 1));
			if (ppszNameList == NULL)
			{
				MemFree (pszFilter);
				MemFree (pszAnyAttrNameList);
				hr = ILS_E_MEMORY;
				goto MyExit;
			}
		}
	}
	else
	{
		cTotalNames = 1;
	}

	// Ask to return cn only if enum names only
	//
	ppszNameList[0] = STR_MTG_NAME;

	// Add names of standard/extended attributes to return
	//
	if (uNotifyMsg == WM_ILS_ENUM_MEETINGINFOS)
	{
		// Set up standard attribtues now
		//
		for (ULONG i = 1; i < COUNT_ENUM_DIRMTGINFO; i++)
		{
			ppszNameList[i] = (TCHAR *) c_apszMtgStdAttrNames[i];
		}

		// Set arbitrary attribute names if needed
		//
		TCHAR *psz = pszAnyAttrNameList;
		for (i = COUNT_ENUM_DIRMTGINFO; i < cTotalNames; i++)
		{
			ppszNameList[i] = psz;
			psz += lstrlen (psz) + 1;
		}
	}

	// Terminate the list
	//
	ppszNameList[cTotalNames] = NULL;

	// Get a session object
	//
	hr = g_pSessionContainer->GetSession (&pSession, pServer);
	if (hr == S_OK)
	{
		// Get an ldap session
		//
		MyAssert (pSession != NULL);
		ld = pSession->GetLd ();
		MyAssert (ld != NULL);

		// Update options in ld
		//
		ld->ld_sizelimit = 0;	// no limit in the num of entries to return
		ld->ld_timelimit = 0;	// no limit on the time to spend on the search
		ld->ld_deref = LDAP_DEREF_ALWAYS;

		// Send search query
		//
		uMsgID = ldap_search (ld, (TCHAR *) &c_szDefMtgBaseDN[0],	// base DN
									LDAP_SCOPE_BASE,	// scope
									pszFilter,	// filter
									ppszNameList,	// attrs[]
									0);	// both type and value
		if (uMsgID == -1)
		{
			// This ldap_search failed.
			// Convert ldap error code to hr
			//
			hr = ::LdapError2Hresult (ld->ld_errno);

			// Free the session object
			//
			pSession->Disconnect ();
		}
	}

	// Free the filter string
	//
	MemFree (pszFilter);

	// Free the buffer holding all returned attribute names if needed
	//
	if (ppszNameList != &apszAttrNames[0])
		MemFree (ppszNameList);

	// Report failure if so
	//
	if (hr != S_OK)
	{
		// Free extended attribute name list
		//
		if (pszAnyAttrNameList != NULL && cAnyAttrNames != 0)
			MemFree (pszAnyAttrNameList);

		// Report failure
		//
		goto MyExit;
	}

	// Construct a pending info structure
	//
	RESP_INFO ri;
	FillDefRespInfo (&ri, pReq->uRespID, ld, uMsgID, INVALID_MSG_ID);
	ri.uNotifyMsg = uNotifyMsg;
	ri.cAnyAttrs = cAnyAttrNames;

	// Queue this pending response
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		// Abort the ldap_search
		//
		ldap_abandon (ld, uMsgID);

		// Free the session object
		//
		pSession->Disconnect ();
		MyAssert (FALSE);
	}

MyExit:

	LDAP_ENUM *pEnum = NULL;
	if (hr != S_OK)
	{
		pEnum = (LDAP_ENUM *) MemAlloc (sizeof (LDAP_ENUM));
		if (pEnum != NULL)
		{
			pEnum->uSize = sizeof (*pEnum);
			pEnum->hResult = hr;
		}
	}

	return (LPARAM) pEnum;
}
#endif // ENABLE_MEETING_PLACE


/* ----------------------------------------------------------------------
	UlsLdap_EnumMeetingInfos

	Input:
		pszServer: server name.
		pszFilter: a filter string.
		pAsyncInfo: a pointer to async info structure.

	History:
	12/02/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

#ifdef ENABLE_MEETING_PLACE
HRESULT
UlsLdap_EnumMeetingInfos (
	SERVER_INFO		*pServer,
	TCHAR			*pszAnyAttrNameList,
	ULONG			cAnyAttrNames,
	TCHAR			*pszFilter,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	// Dispatch the call to a common subroutine
	//
	return My_EnumMtgsEx (WM_ILS_ENUM_MEETINGINFOS,
						pServer,
						pszAnyAttrNameList,
						cAnyAttrNames,
						pszFilter,
						pAsyncInfo);
}
#endif // ENABLE_MEETING_PLACE


/* ----------------------------------------------------------------------
	UlsLdap_EnumMeetings

	Input:
		pszServer: server name.
		pszFilter: a filter string.
		pAsyncInfo: a pointer to async info structure.

	History:
	12/02/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

#ifdef ENABLE_MEETING_PLACE
HRESULT
UlsLdap_EnumMeetings (
	SERVER_INFO		*pServer,
	TCHAR			*pszFilter,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Dispatch the call to a common subroutine
	//
	return My_EnumMtgsEx (WM_ILS_ENUM_MEETINGS,
						pServer,
						NULL,
						0,
						pszFilter,
						pAsyncInfo);
}
#endif // ENABLE_MEETING_PLACE


/* ----------------------------------------------------------------------
	UlsLdap_EnumAttendee

	Input:
		pszServer: server name.
		pszMeetingID: a meeting id string.
		pszFilter: a filter string.
		pAsyncInfo: a pointer to async info structure.

	History:
	12/02/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

#ifdef ENABLE_MEETING_PLACE
HRESULT
UlsLdap_EnumAttendees(
	SERVER_INFO		*pServer,
	TCHAR			*pszMtgName,
	TCHAR			*pszFilter,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	if (MyIsBadServerInfo (pServer) || MyIsBadString (pszMtgName))
		return ILS_E_POINTER;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Compute the total size of the data
	//
	ULONG cbServer = IlsGetLinearServerInfoSize (pServer);
	ULONG cbSizeMtgName = (lstrlen (pszMtgName) + 1) * sizeof (TCHAR);
	ULONG cbSizeFilter = (pszFilter != NULL) ? (lstrlen (pszFilter) + 1) * sizeof (TCHAR) : 0;
	ULONG cParams = 3;
	ULONG cbSize = cbServer + cbSizeMtgName + cbSizeFilter;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_ENUM_ATTENDEES, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Linearize parameters
	//
	MarshalReq_SetParamServer (pReq, 0, pServer, cbServer);
	MarshalReq_SetParam (pReq, 1, (DWORD) pszMtgName, cbSizeMtgName);
	MarshalReq_SetParam (pReq, 2, (DWORD) pszFilter, cbSizeFilter);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

	if (hr == S_OK)
	{
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_EnumAttendees ( MARSHAL_REQ *pReq )
{
	HRESULT hr = S_OK;

	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_ENUM_ATTENDEES);

	// Delinearize parameters
	//
	SERVER_INFO *pServer = (SERVER_INFO *) MarshalReq_GetParam (pReq, 0);
	TCHAR *pszMtgName = (TCHAR *) MarshalReq_GetParam (pReq, 1);
	TCHAR *pszFilter = (TCHAR *) MarshalReq_GetParam (pReq, 2);

	// Clean up locals
	//
	SP_CSession *pSession = NULL;
	LDAP *ld;
	ULONG uMsgID = (ULONG) -1;

	// BUGS: ignore the input filter
	//
	pszFilter = MtgCreateEnumMembersFilter (pszMtgName);
	if (pszFilter == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Create an array of names of attributes to return
	//
	TCHAR *apszAttrNames[3];
	apszAttrNames[0] = STR_MTG_NAME;
	apszAttrNames[1] = (TCHAR *) c_apszMtgStdAttrNames[ENUM_MTGATTR_MEMBERS];
	apszAttrNames[2] = NULL;

	// Get the session object
	//
	hr = g_pSessionContainer->GetSession (&pSession, pServer);
	if (hr != S_OK)
	{
		MemFree (pszFilter);
		goto MyExit;
	}
	MyAssert (pSession != NULL);

	// Get an ldap session
	//
	ld = pSession->GetLd ();
	MyAssert (ld != NULL);

	// Update options in ld
	//
	ld->ld_sizelimit = 0;	// no limit in the num of entries to return
	ld->ld_timelimit = 0;	// no limit on the time to spend on the search
	ld->ld_deref = LDAP_DEREF_ALWAYS;

	// Send the search query
	//
	uMsgID = ldap_search (ld, (TCHAR *) &c_szDefMtgBaseDN[0],	// base DN
						LDAP_SCOPE_BASE,	// scope
						pszFilter,
						&apszAttrNames[0],	// attrs[]
						0);	// both type and value

	// Free the search filter
	//
	MemFree (pszFilter);

	// Check the return of ldap_search
	//
	if (uMsgID == -1)
	{
		// This ldap_search failed.
		// Convert ldap error code to hr
		//
		hr = ::LdapError2Hresult (ld->ld_errno);

		// Free the session object
		//
		pSession->Disconnect ();
		goto MyExit;
	}

	// Construct a pending info structure
	//
	RESP_INFO ri;
	FillDefRespInfo (&ri, pReq->uRespID, ld, uMsgID, INVALID_MSG_ID);
	ri.uNotifyMsg = WM_ILS_ENUM_ATTENDEES;

	// Queue this pending response
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		// Abort the ldap_search
		//
		ldap_abandon (ld, uMsgID);

		// Free the session object
		//
		pSession->Disconnect ();
		MyAssert (FALSE);
	}

MyExit:

	LDAP_ENUM *pEnum = NULL;
	if (hr != S_OK)
	{
		pEnum = (LDAP_ENUM *) MemAlloc (sizeof (LDAP_ENUM));
		if (pEnum != NULL)
		{
			pEnum->uSize = sizeof (*pEnum);
			pEnum->hResult = hr;
		}
	}

	return (LPARAM) pEnum;
}
#endif // ENABLE_MEETING_PLACE


/* ----------------------------------------------------------------------
	UlsLdap_ResolveClient

	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.
	10/30/96	Chu, Lon-Chan [lonchanc]
				Tested on ILS (7438)
	1/14/97		Chu, Lon-Chan [lonchanc]
				Collapsed user/app objects.
   ---------------------------------------------------------------------- */

HRESULT
UlsLdap_ResolveClient (
	SERVER_INFO		*pServer,
	TCHAR			*pszCN,
	TCHAR			*pszAppName,
	TCHAR			*pszProtName,
	TCHAR			*pszAnyAttrNameList,
	ULONG			cAnyAttrNames,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Maks sure the server name is valid
	//
	if (MyIsBadServerInfo (pServer))
		return ILS_E_POINTER;

	// Maks sure the user name is valid
	//
	if (MyIsBadString (pszCN))
		return ILS_E_POINTER;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Compute the total size of the data
	//
	ULONG cbServer = IlsGetLinearServerInfoSize (pServer);
	ULONG cbSizeCN = (lstrlen (pszCN) + 1) * sizeof (TCHAR);
	ULONG cbSizeAppName = (pszAppName != NULL) ? (lstrlen (pszAppName) + 1) * sizeof (TCHAR) : 0;
	ULONG cbSizeProtName = (pszProtName != NULL) ? (lstrlen (pszProtName) + 1) * sizeof (TCHAR) : 0;
	ULONG cbSizeAnyAttrNames = 0;
	TCHAR *psz = pszAnyAttrNameList;
	ULONG cch;
	for (ULONG i = 0; i < cAnyAttrNames; i++)
	{
		cch = lstrlen (psz) + 1;
		cbSizeAnyAttrNames += cch * sizeof (TCHAR);
		psz += cch;
	}
	ULONG cParams = 6;
	ULONG cbSize =  cbServer + cbSizeCN + cbSizeAppName + cbSizeProtName + cbSizeAnyAttrNames;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_RESOLVE_CLIENT, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Linearize parameters
	//
	MarshalReq_SetParamServer (pReq, 0, pServer, cbServer);
	MarshalReq_SetParam (pReq, 1, (DWORD_PTR) pszCN, cbSizeCN);
	MarshalReq_SetParam (pReq, 2, (DWORD_PTR) pszAppName, cbSizeAppName);
	MarshalReq_SetParam (pReq, 3, (DWORD_PTR) pszProtName, cbSizeProtName);
	MarshalReq_SetParam (pReq, 4, (DWORD_PTR) pszAnyAttrNameList, cbSizeAnyAttrNames);
	MarshalReq_SetParam (pReq, 5, (DWORD) cAnyAttrNames, 0);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

	if (hr == S_OK)
	{
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_ResolveClient ( MARSHAL_REQ *pReq )
{
	HRESULT hr = S_OK;
	SP_CSession *pSession = NULL;
	LDAP *ld;
	ULONG uMsgID = (ULONG) -1;

	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_RESOLVE_CLIENT);

	// Delinearize parameters
	//
	SERVER_INFO *pServer = (SERVER_INFO *) MarshalReq_GetParam (pReq, 0);
	TCHAR *pszCN = (TCHAR *) MarshalReq_GetParam (pReq, 1);
	TCHAR *pszAppName = (TCHAR *) MarshalReq_GetParam (pReq, 2);
	TCHAR *pszProtName = (TCHAR *) MarshalReq_GetParam (pReq, 3);
	TCHAR *pszAnyAttrNameList = (TCHAR *) MarshalReq_GetParam (pReq, 4);
	ULONG cAnyAttrNames = (ULONG) MarshalReq_GetParam (pReq, 5);

	// Create a resolve client filter
	//
	TCHAR *pszFilter = ClntCreateResolveFilter (pszCN, pszAppName, pszProtName);
	if (pszFilter == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Create an array of names of attributes to return
	//
	TCHAR *apszAttrNames[COUNT_ENUM_RES_CLIENT_INFO+1];
	TCHAR **ppszNameList;
	ppszNameList = &apszAttrNames[0];
	ULONG cTotalNames;
	cTotalNames = COUNT_ENUM_RES_CLIENT_INFO;
	if (pszAnyAttrNameList != NULL && cAnyAttrNames != 0)
	{
		// Prefix arbitrary attribute names
		//
		pszAnyAttrNameList = IlsPrefixNameValueArray (FALSE, cAnyAttrNames,
									(const TCHAR *) pszAnyAttrNameList);
		if (pszAnyAttrNameList == NULL)
		{
			MemFree (pszFilter);
			hr = ILS_E_MEMORY;
			goto MyExit;
		}

		// NOTE that pszAnyAttrNameList must be freed if failed in this routine
		// If success, it will be freed in notification.

		// Allocate memory for keeping returned attributes' names
		//
		cTotalNames += cAnyAttrNames;
		ppszNameList = (TCHAR **) MemAlloc (sizeof (TCHAR *) * (cTotalNames + 1));
		if (ppszNameList == NULL)
		{
			MemFree (pszFilter);
			MemFree (pszAnyAttrNameList);
			hr = ILS_E_MEMORY;
			goto MyExit;
		}
	}

	// Set standard attribute names
	//
	ULONG i;
	for (i = 0; i < COUNT_ENUM_RES_CLIENT_INFO; i++)
	{
		ppszNameList[i] = (TCHAR *) c_apszClientStdAttrNames[i];
	}

	// Set arbitrary attribute names if needed
	//
	TCHAR *psz;
	psz = pszAnyAttrNameList;
	for (i = COUNT_ENUM_RES_CLIENT_INFO; i < cTotalNames; i++)
	{
		ppszNameList[i] = psz;
		psz += lstrlen (psz) + 1;
	}

	// Terminate the list
	//
	ppszNameList[cTotalNames] = NULL;

	// Get the session object
	//
	hr = g_pSessionContainer->GetSession (&pSession, pServer);
	if (hr == S_OK)
	{
		// Get an ldap session
		//
		MyAssert (pSession != NULL);
		ld = pSession->GetLd ();
		MyAssert (ld != NULL);

		// Update options in ld
		//
		ld->ld_sizelimit = 0;	// no limit in the num of entries to return
		ld->ld_timelimit = 0;	// no limit on the time to spend on the search
		ld->ld_deref = LDAP_DEREF_ALWAYS;

		// Send the search query
		//
		uMsgID = ldap_search (	ld,
								(TCHAR *) &c_szDefClientBaseDN[0], // base DN
								LDAP_SCOPE_BASE, // scope
								pszFilter, // filter
								ppszNameList, // attrs[]
								0); // both type and value
		if (uMsgID == -1)
		{
			// This ldap_search failed.
			// Convert ldap error code to hr
			//
			hr = ::LdapError2Hresult (ld->ld_errno);
			MyAssert (hr != S_OK);

			// Free the session object
			//
			pSession->Disconnect ();
		}
	}

	// Free the filter string
	//
	MemFree (pszFilter);

	// Free the buffer holding all returned attribute names if needed
	//
	if (ppszNameList != &apszAttrNames[0])
		MemFree (ppszNameList);

	// If failed, exit with cleanup
	//
	if (hr != S_OK)
	{
		// Free extended attribute names list if needed
		//
		if (pszAnyAttrNameList != NULL && cAnyAttrNames != 0)
			MemFree (pszAnyAttrNameList);

		// Report failure
		//
		goto MyExit;
	}

	// Construct a pending info structure
	//
	RESP_INFO ri;
	FillDefRespInfo (&ri, pReq->uRespID, ld, uMsgID, INVALID_MSG_ID);
	ri.uNotifyMsg = WM_ILS_RESOLVE_CLIENT;
	ri.cAnyAttrs = cAnyAttrNames;
	ri.pszAnyAttrNameList = pszAnyAttrNameList;

	// Queue this pending response
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		// Abort the ldap_search
		//
		ldap_abandon (ld, uMsgID);

		// Free the session object
		//
		pSession->Disconnect ();
		MyAssert (FALSE);
	}

MyExit:

	LDAP_CLIENTINFO_RES *pcir = NULL;
	if (hr != S_OK)
	{
		pcir = (LDAP_CLIENTINFO_RES *) MemAlloc (sizeof (LDAP_CLIENTINFO_RES));
		if (pcir != NULL)
		{
			pcir->uSize = sizeof (*pcir);
			pcir->hResult = hr;
		}
	}

	return (LPARAM) pcir;
}


/* ----------------------------------------------------------------------
	UlsLdap_ResolveProtocol

	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.
	10/30/96	Chu, Lon-Chan [lonchanc]
				Blocked by ILS (7438, 7442)
   ---------------------------------------------------------------------- */

HRESULT UlsLdap_ResolveProtocol (
	SERVER_INFO		*pServer,
	TCHAR			*pszUserName,
	TCHAR			*pszAppName,
	TCHAR			*pszProtName,
	TCHAR			*pszAnyAttrNameList,
	ULONG			cAnyAttrNames,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	if (MyIsBadServerInfo (pServer)  || MyIsBadString (pszUserName) ||
		MyIsBadString (pszAppName) || MyIsBadString (pszProtName) ||
		pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Compute the total size of the data
	//
	ULONG cbServer = IlsGetLinearServerInfoSize (pServer);
	ULONG cbSizeUserName = (lstrlen (pszUserName) + 1) * sizeof (TCHAR);
	ULONG cbSizeAppName = (lstrlen (pszAppName) + 1) * sizeof (TCHAR);
	ULONG cbSizeProtName = (lstrlen (pszProtName) + 1) * sizeof (TCHAR);
	ULONG cbSizeAnyAttrNames = 0;
	TCHAR *psz = pszAnyAttrNameList;
	ULONG cch;
	for (ULONG i = 0; i < cAnyAttrNames; i++)
	{
		cch = lstrlen (psz) + 1;
		cbSizeAnyAttrNames += cch * sizeof (TCHAR);
		psz += cch;
	}
	ULONG cParams = 6;
	ULONG cbSize =  cbServer + cbSizeUserName + cbSizeAppName +
					cbSizeProtName + cbSizeAnyAttrNames;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_RESOLVE_PROTOCOL, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Linearize parameters
	//
	MarshalReq_SetParamServer (pReq, 0, pServer, cbServer);
	MarshalReq_SetParam (pReq, 1, (DWORD_PTR) pszUserName, cbSizeUserName);
	MarshalReq_SetParam (pReq, 2, (DWORD_PTR) pszAppName, cbSizeAppName);
	MarshalReq_SetParam (pReq, 3, (DWORD_PTR) pszProtName, cbSizeProtName);
	MarshalReq_SetParam (pReq, 4, (DWORD_PTR) pszAnyAttrNameList, cbSizeAnyAttrNames);
	MarshalReq_SetParam (pReq, 5, (DWORD) cAnyAttrNames, 0);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

	if (hr == S_OK)
	{
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_ResolveProtocol ( MARSHAL_REQ *pReq )
{
	HRESULT hr = S_OK;
	SP_CSession *pSession = NULL;
	LDAP *ld;
	ULONG uMsgID = (ULONG) -1;

	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_RESOLVE_PROTOCOL);

	// Delinearize parameters
	//
	SERVER_INFO *pServer = (SERVER_INFO *) MarshalReq_GetParam (pReq, 0);
	TCHAR *pszUserName = (TCHAR *) MarshalReq_GetParam (pReq, 1);
	TCHAR *pszAppName = (TCHAR *) MarshalReq_GetParam (pReq, 2);
	TCHAR *pszProtName = (TCHAR *) MarshalReq_GetParam (pReq, 3);
	TCHAR *pszAnyAttrNameList = (TCHAR *) MarshalReq_GetParam (pReq, 4);
	ULONG cAnyAttrNames = (ULONG) MarshalReq_GetParam (pReq, 5);

	TCHAR *pszFilter = NULL;

	// Duplicate the protocol name to resolve
	//
	TCHAR *pszProtNameToResolve = My_strdup (pszProtName);
	if (pszProtNameToResolve == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Create a resolve client filter
	//
	pszFilter = ProtCreateResolveFilter (pszUserName, pszAppName, pszProtName);
	if (pszFilter == NULL)
	{
		MemFree (pszProtNameToResolve);
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Create an array of names of attributes to return
	//
	TCHAR *apszAttrNames[COUNT_ENUM_PROTATTR+1];
	TCHAR **ppszNameList;
	ppszNameList = &apszAttrNames[0];
	ULONG cTotalNames;
	cTotalNames = COUNT_ENUM_PROTATTR;
	if (pszAnyAttrNameList != NULL && cAnyAttrNames != 0)
	{
		// Prefix arbitrary attribute names
		//
		pszAnyAttrNameList = IlsPrefixNameValueArray (FALSE, cAnyAttrNames,
												(const TCHAR *) pszAnyAttrNameList);
		if (pszAnyAttrNameList == NULL)
		{
			MemFree (pszProtNameToResolve);
			MemFree (pszFilter);
			hr = ILS_E_MEMORY;
			goto MyExit;
		}

		// Allocate memory for returned attributes' names
		//
		cTotalNames += cAnyAttrNames;
		ppszNameList = (TCHAR **) MemAlloc (sizeof (TCHAR *) * (cTotalNames + 1));
		if (ppszNameList == NULL)
		{
			MemFree (pszProtNameToResolve);
			MemFree (pszFilter);
			MemFree (pszAnyAttrNameList);
			hr = ILS_E_MEMORY;
			goto MyExit;
		}
	}

	// Set standard attribute names
	//
	ULONG i;
	for (i = 0; i < COUNT_ENUM_PROTATTR; i++)
	{
		ppszNameList[i] = (TCHAR *) c_apszProtStdAttrNames[i];
	}

	// Set arbitrary attribute names if needed
	//
	TCHAR *psz;
	psz = pszAnyAttrNameList;
	for (i = COUNT_ENUM_PROTATTR; i < cTotalNames; i++)
	{
		ppszNameList[i] = psz;
		psz += lstrlen (psz) + 1;
	}

	// Terminate the list
	//
	ppszNameList[cTotalNames] = NULL;

	// Get the session object
	//
	hr = g_pSessionContainer->GetSession (&pSession, pServer);
	if (hr == S_OK)
	{
		// Get an ldap session
		//
		MyAssert (pSession != NULL);
		ld = pSession->GetLd ();
		MyAssert (ld != NULL);

		// Update options in ld
		//
		ld->ld_sizelimit = 0;	// no limit in the num of entries to return
		ld->ld_timelimit = 0;	// no limit on the time to spend on the search
		ld->ld_deref = LDAP_DEREF_ALWAYS;

		// Send the search query
		//
		uMsgID = ldap_search (ld, (TCHAR *) &c_szDefClientBaseDN[0],	// base DN
									LDAP_SCOPE_BASE,	// scope
									pszFilter,
									ppszNameList,	// attrs[]
									0);	// both type and value
		if (uMsgID == -1)
		{
			// This ldap_search failed.
			// Convert ldap error code to hr
			//
			hr = ::LdapError2Hresult (ld->ld_errno);
			MyAssert (hr != S_OK);

			// Free the session object
			//
			pSession->Disconnect ();
		}
	}

	// Free the filter string
	//
	MemFree (pszFilter);

	// Free the buffer holding all returned attribute names if needed
	//
	if (ppszNameList != &apszAttrNames[0])
		MemFree (ppszNameList);

	// If failed, exit with cleanup
	//
	if (hr != S_OK)
	{
		// Free duplicated protocol name
		//
		MemFree (pszProtNameToResolve);

		// Free extended attribute names list if needed
		//
		if (cAnyAttrNames != 0)
			MemFree (pszAnyAttrNameList);

		// Report failure
		//
		goto MyExit;
	}

	// Construct a pending info structure
	//
	RESP_INFO ri;
	FillDefRespInfo (&ri, pReq->uRespID, ld, uMsgID, INVALID_MSG_ID);
	ri.uNotifyMsg = WM_ILS_RESOLVE_PROTOCOL;
	ri.cAnyAttrs = cAnyAttrNames;
	ri.pszAnyAttrNameList = pszAnyAttrNameList;
	ri.pszProtNameToResolve = pszProtNameToResolve;

	// Queue this pending response
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		// Free duplicated protocol name
		//
		MemFree (pszProtNameToResolve);

		// Free extended attribute names list if needed
		//
		if (cAnyAttrNames != 0)
			MemFree (pszAnyAttrNameList);

		// Abort the ldap_search
		//
		ldap_abandon (ld, uMsgID);

		// Free the session object
		//
		pSession->Disconnect ();
		MyAssert (FALSE);
	}

MyExit:

	LDAP_PROTINFO_RES *ppir = NULL;
	if (hr != S_OK)
	{
		ppir = (LDAP_PROTINFO_RES *) MemAlloc (sizeof (LDAP_PROTINFO_RES));
		if (ppir != NULL)
		{
			ppir->uSize = sizeof (*ppir);
			ppir->hResult = hr;
		}
	}

	return (LPARAM) ppir;
}


/* ----------------------------------------------------------------------
	UlsLdap_ResolveMeeting

	Input:
		pszServer: A server name.
		pszMeetingID: A meeting id string.
		pszAnyAttrName: A pointer to a series of strings.
		cAnyAttrNames: A count of strings in the series.
		pAsyncInfo: a pointer to async info structure.

	History:
	12/02/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

#ifdef ENABLE_MEETING_PLACE
HRESULT UlsLdap_ResolveMeeting (
	SERVER_INFO		*pServer,
	TCHAR			*pszMtgName,
	TCHAR			*pszAnyAttrNameList,
	ULONG			cAnyAttrNames,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	if (MyIsBadServerInfo (pServer) || MyIsBadString (pszMtgName))
		return ILS_E_POINTER;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Compute the total size of the data
	//
	ULONG cbServer = IlsGetLinearServerInfoSize (pServer);
	ULONG cbSizeMtgName = (lstrlen (pszMtgName) + 1) * sizeof (TCHAR);
	ULONG cbSizeAnyAttrNames = 0;
	TCHAR *psz = pszAnyAttrNameList;
	ULONG cch;
	for (ULONG i = 0; i < cAnyAttrNames; i++)
	{
		cch = lstrlen (psz) + 1;
		cbSizeAnyAttrNames += cch * sizeof (TCHAR);
		psz += cch;
	}
	ULONG cParams = 4;
	ULONG cbSize =  cbServer + cbSizeMtgName + cbSizeAnyAttrNames;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_RESOLVE_MEETING, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Linearize parameters
	//
	MarshalReq_SetParamServer (pReq, 0, pServer, cbServer);
	MarshalReq_SetParam (pReq, 1, (DWORD) pszMtgName, cbSizeMtgName);
	MarshalReq_SetParam (pReq, 2, (DWORD) pszAnyAttrNameList, cbSizeAnyAttrNames);
	MarshalReq_SetParam (pReq, 3, (DWORD) cAnyAttrNames, 0);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

	if (hr == S_OK)
	{
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_ResolveMeeting ( MARSHAL_REQ *pReq )
{
	HRESULT hr = S_OK;
	SP_CSession *pSession = NULL;
	LDAP *ld;
	ULONG uMsgID = (ULONG) -1;

	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_RESOLVE_MEETING);

	// Delinearize parameters
	//
	SERVER_INFO *pServer = (SERVER_INFO *) MarshalReq_GetParam (pReq, 0);
	TCHAR *pszMtgName = (TCHAR *) MarshalReq_GetParam (pReq, 1);
	TCHAR *pszAnyAttrNameList = (TCHAR *) MarshalReq_GetParam (pReq, 2);
	ULONG cAnyAttrNames = (ULONG) MarshalReq_GetParam (pReq, 3);

	// Create a resolve client filter
	//
	TCHAR *pszFilter = MtgCreateResolveFilter (pszMtgName);
	if (pszFilter == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Create an array of names of attributes to return
	//
	TCHAR *apszAttrNames[COUNT_ENUM_MTGATTR+1];
	TCHAR **ppszNameList;
	ppszNameList = &apszAttrNames[0];
	ULONG cTotalNames;
	cTotalNames = COUNT_ENUM_MTGATTR;
	if (pszAnyAttrNameList != NULL && cAnyAttrNames != 0)
	{
		// Prefix arbitrary attribute names
		//
		pszAnyAttrNameList = IlsPrefixNameValueArray (FALSE, cAnyAttrNames,
												(const TCHAR *) pszAnyAttrNameList);
		if (pszAnyAttrNameList == NULL)
		{
			MemFree (pszFilter);
			hr = ILS_E_MEMORY;
			goto MyExit;
		}

		// Allocate memory for returned attributes' names
		//
		cTotalNames += cAnyAttrNames;
		ppszNameList = (TCHAR **) MemAlloc (sizeof (TCHAR *) * (cTotalNames + 1));
		if (ppszNameList == NULL)
		{
			MemFree (pszFilter);
			MemFree (pszAnyAttrNameList);
			hr = ILS_E_MEMORY;
			goto MyExit;
		}
	}

	// Set standard attribute names
	//
	ULONG i;
	for (i = 0; i < COUNT_ENUM_MTGATTR; i++)
	{
		ppszNameList[i] = (TCHAR *) c_apszMtgStdAttrNames[i];
	}

	// Set arbitrary attribute names if needed
	//
	TCHAR *psz;
	psz = pszAnyAttrNameList;
	for (i = COUNT_ENUM_MTGATTR; i < cTotalNames; i++)
	{
		ppszNameList[i] = psz;
		psz += lstrlen (psz) + 1;
	}

	// Terminate the list
	//
	ppszNameList[cTotalNames] = NULL;

	// Get the session object
	//
	hr = g_pSessionContainer->GetSession (&pSession, pServer);
	if (hr == S_OK)
	{
		// Get an ldap session
		//
		MyAssert (pSession != NULL);
		ld = pSession->GetLd ();
		MyAssert (ld != NULL);

		// Update options in ld
		//
		ld->ld_sizelimit = 0;	// no limit in the num of entries to return
		ld->ld_timelimit = 0;	// no limit on the time to spend on the search
		ld->ld_deref = LDAP_DEREF_ALWAYS;

		// Send the search query
		//
		uMsgID = ldap_search (ld, (TCHAR *) &c_szDefMtgBaseDN[0],	// base DN
									LDAP_SCOPE_BASE,	// scope
									pszFilter,
									ppszNameList,	// attrs[]
									0);	// both type and value
		if (uMsgID == -1)
		{
			// This ldap_search failed.
			// Convert ldap error code to hr
			//
			hr = ::LdapError2Hresult (ld->ld_errno);
			MyAssert (hr != S_OK);

			// Free the session object
			//
			pSession->Disconnect ();
		}
	}

	// Free the filter string
	//
	MemFree (pszFilter);

	// Free the buffer holding all returned attribute names if needed
	//
	if (ppszNameList != &apszAttrNames[0])
		MemFree (ppszNameList);

	// If failed, exit with cleanup
	//
	if (hr != S_OK)
	{
		// Free extended attribute names list if needed
		//
		if (pszAnyAttrNameList != NULL && cAnyAttrNames != 0)
			MemFree (pszAnyAttrNameList);

		// Report failure
		//
		goto MyExit;
	}

	// Construct a pending info structure
	//
	RESP_INFO ri;
	FillDefRespInfo (&ri, pReq->uRespID, ld, uMsgID, INVALID_MSG_ID);
	ri.uNotifyMsg = WM_ILS_RESOLVE_MEETING;
	ri.cAnyAttrs = cAnyAttrNames;
	ri.pszAnyAttrNameList = pszAnyAttrNameList;

	// Queue this pending response
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		// Abort the ldap_search
		//
		ldap_abandon (ld, uMsgID);

		// Free the session object
		//
		pSession->Disconnect ();
		MyAssert (FALSE);
	}

MyExit:

	LDAP_MEETINFO_RES *pmir = NULL;
	if (hr != S_OK)
	{
		pmir = (LDAP_MEETINFO_RES *) MemAlloc (sizeof (LDAP_MEETINFO_RES));
		if (pmir != NULL)
		{
			pmir->uSize = sizeof (*pmir);
			pmir->hResult = hr;
		}
	}

	return (LPARAM) pmir;
}
#endif // ENABLE_MEETING_PLACE


/* ----------------------------------------------------------------------
	UlsLdap_AddAttendee

	Input:
		pszServer: server name.
		pszMeetingID: a meeting id string.
		pszAttendeeID: an attendee id string.
		pAsyncInfo: a pointer to async info structure.

	History:
	12/02/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

#ifdef ENABLE_MEETING_PLACE
HRESULT My_UpdateAttendees (
	ULONG			uNotifyMsg,
	SERVER_INFO		*pServer,
	TCHAR			*pszMtgName,
	ULONG			cMembers,
	TCHAR			*pszMemberNames,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	MyAssert (	uNotifyMsg == WM_ILS_ADD_ATTENDEE ||
				uNotifyMsg == WM_ILS_REMOVE_ATTENDEE);

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Make sure we there are members to add
	//
	if (cMembers == 0)
		return ILS_E_PARAMETER;

	// Make sure we have valid pointers
	//
	if (MyIsBadServerInfo (pServer) || MyIsBadString (pszMtgName) ||
		MyIsBadString (pszMemberNames))
		return ILS_E_POINTER;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Compute the total size of the data
	//
	ULONG cbServer = IlsGetLinearServerInfoSize (pServer);
	ULONG cbSizeMtgName = (lstrlen (pszMtgName) + 1) * sizeof (TCHAR);
	ULONG cbSizeMemberNames = 0;
	TCHAR *psz = pszMemberNames;
	for (ULONG i = 0; i < cMembers; i++)
	{
		ULONG cchName = lstrlen (psz) + 1;
		cbSizeMemberNames += cchName * sizeof (TCHAR);
		psz += cchName;
	}
	ULONG cParams = 4;
	ULONG cbSize =  cbServer + cbSizeMtgName + cbSizeMemberNames;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (uNotifyMsg, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Linearize parameters
	//
	MarshalReq_SetParamServer (pReq, 0, pServer, cbServer);
	MarshalReq_SetParam (pReq, 1, (DWORD) pszMtgName, cbSizeMtgName);
	MarshalReq_SetParam (pReq, 2, (DWORD) cMembers, 0);
	MarshalReq_SetParam (pReq, 3, (DWORD) pszMemberNames, cbSizeMemberNames);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

	if (hr == S_OK)
	{
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_UpdateAttendees ( MARSHAL_REQ *pReq )
{
	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (	pReq->uNotifyMsg == WM_ILS_ADD_ATTENDEE ||
				pReq->uNotifyMsg == WM_ILS_REMOVE_ATTENDEE);

	// Delinearize parameters
	//
	SERVER_INFO *pServer = (SERVER_INFO *) MarshalReq_GetParam (pReq, 0);
	TCHAR *pszMtgName = (TCHAR *) MarshalReq_GetParam (pReq, 1);
	ULONG cMembers = (ULONG) MarshalReq_GetParam (pReq, 2);
	TCHAR *pszMemberNames = (TCHAR *) MarshalReq_GetParam (pReq, 3);

	// Set standard attributes
	//
	return (LPARAM) MtgUpdateMembers (pReq->uNotifyMsg,
									pServer,
									pszMtgName,
									cMembers,
									pszMemberNames,
									pReq->uRespID);
}
#endif // ENABLE_MEETING_PLACE



#ifdef ENABLE_MEETING_PLACE
HRESULT UlsLdap_AddAttendee(
	SERVER_INFO		*pServer,
	TCHAR			*pszMtgName,
	ULONG			cMembers,
	TCHAR			*pszMemberNames,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	return My_UpdateAttendees (	WM_ILS_ADD_ATTENDEE,
								pServer,
								pszMtgName,
								cMembers,
								pszMemberNames,
								pAsyncInfo);
}
#endif // ENABLE_MEETING_PLACE


/* ----------------------------------------------------------------------
	UlsLdap_RemoveAttendee

	Input:
		pszServer: server name.
		pszMeetingID: a meeting id string.
		pszAttendeeID: an attendee id string.
		pAsyncInfo: a pointer to async info structure.

	History:
	12/02/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

#ifdef ENABLE_MEETING_PLACE
HRESULT UlsLdap_RemoveAttendee(
	SERVER_INFO		*pServer,
	TCHAR			*pszMtgName,
	ULONG			cMembers,
	TCHAR			*pszMemberNames,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	return My_UpdateAttendees (	WM_ILS_REMOVE_ATTENDEE,
								pServer,
								pszMtgName,
								cMembers,
								pszMemberNames,
								pAsyncInfo);
}
#endif // ENABLE_MEETING_PLACE


/* ----------------------------------------------------------------------
	UlsLdap_GetStdAttrNameString

	Input:
		StdName: a standard attribute index.

	History:
	12/02/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

typedef struct
{
	#ifdef DEBUG
	LONG		nIndex;
	#endif
	const TCHAR	**ppszName;
}
	ATTR_NAME_ENTRY;


const ATTR_NAME_ENTRY c_aAttrNameTbl[ILS_NUM_OF_STDATTRS] =
{
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_NULL,
		#endif
		NULL
	},

	// User standard attribute names
	//
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_USER_ID,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_CN]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_IP_ADDRESS,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_IP_ADDRESS]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_EMAIL_NAME,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_EMAIL_NAME]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_FIRST_NAME,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_FIRST_NAME]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_LAST_NAME,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_LAST_NAME]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_CITY_NAME,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_CITY_NAME]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_COUNTRY_NAME,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_C]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_COMMENT,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_COMMENT]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_FLAGS,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_FLAGS]
	},

	// Application standard attribute names
	//
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_APP_NAME,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_APP_NAME]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_APP_MIME_TYPE,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_APP_MIME_TYPE]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_APP_GUID,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_APP_GUID]
	},

	// Protocol standard attribute names
	//
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_PROTOCOL_NAME,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_PROT_NAME]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_PROTOCOL_MIME_TYPE,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_PROT_MIME]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_PROTOCOL_PORT,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_PROT_PORT]
	},

#ifdef ENABLE_MEETING_PLACE
	// Meeting place attribute names
	//
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_MEETING_ID,
		#endif
		&c_apszMtgStdAttrNames[ENUM_MTGATTR_CN]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_MEETING_HOST_NAME,
		#endif
		&c_apszMtgStdAttrNames[ENUM_MTGATTR_HOST_NAME]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_MEETING_HOST_IP_ADDRESS,
		#endif
		&c_apszMtgStdAttrNames[ENUM_MTGATTR_IP_ADDRESS]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_MEETING_DESCRIPTION,
		#endif
		&c_apszMtgStdAttrNames[ENUM_MTGATTR_DESCRIPTION]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_MEETING_TYPE,
		#endif
		&c_apszMtgStdAttrNames[ENUM_MTGATTR_MTG_TYPE]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_ATTENDEE_TYPE,
		#endif
		&c_apszMtgStdAttrNames[ENUM_MTGATTR_MEMBER_TYPE]
	},
#endif // ENABLE_MEETING_PLACE
};


const TCHAR *UlsLdap_GetStdAttrNameString ( ILS_STD_ATTR_NAME StdName )
{
	ULONG nIndex = (LONG) StdName;

	MyAssert (((LONG) ILS_STDATTR_NULL < nIndex) && (nIndex < (LONG) ILS_NUM_OF_STDATTRS));

	return *(c_aAttrNameTbl[nIndex].ppszName);
}


#ifdef DEBUG
VOID DbgValidateStdAttrNameArray ( VOID )
{
	MyAssert (ARRAY_ELEMENTS (c_aAttrNameTbl) == ILS_NUM_OF_STDATTRS);

	for (LONG i = 0; i < ILS_NUM_OF_STDATTRS; i++)
	{
		if (i == c_aAttrNameTbl[i].nIndex)
		{
			if (i != ILS_STDATTR_NULL &&
				My_lstrlen (*(c_aAttrNameTbl[i].ppszName)) == 0)
			{
				MyAssert (FALSE);
			}
		}
		else
		{
			MyAssert (FALSE);
			break;
		}
	}
}
#endif



/* =============== helper functions =============== */

const TCHAR g_szShowEntries[] = TEXT ("(cn=");
const INT g_nLengthShowEntries = ARRAY_ELEMENTS (g_szShowEntries) - 1;
const TCHAR g_szShowAllEntries[] = TEXT ("(cn=*)");
const INT g_nShowAllEntries = ARRAY_ELEMENTS (g_szShowAllEntries) - 1;

TCHAR *AddBaseToFilter ( TCHAR *pszFilter, const TCHAR *pszDefBase )
{
	MyAssert (pszDefBase != NULL);

	// Calculate the size for "(&(objectclass=RTPerson)())"
	//
	ULONG cbSize = (lstrlen (pszDefBase) + 8 + g_nShowAllEntries) * sizeof (TCHAR);

	// Look through the filter string to figure out that
	// will this string shows entries???
	//
	TCHAR *pszShowEntries = (TCHAR *) &g_szShowAllEntries[0];
	if (pszFilter != NULL)
	{
		for (TCHAR *psz = pszFilter; *psz != TEXT ('\0'); psz = CharNext (psz))
		{
			if (lstrlen (psz) > g_nLengthShowEntries)
			{
				TCHAR ch = psz[g_nLengthShowEntries]; // remember
				psz[g_nLengthShowEntries] = TEXT ('\0');

				INT nCmp = lstrcmpi (psz, &g_szShowEntries[0]);
				psz[g_nLengthShowEntries] = ch; // restore
				if (nCmp == 0)
				{
					// Matched
					//
					pszShowEntries = STR_EMPTY;
					break;
				}
			}
			else
			{
				// It is impossible to match it
				//
				break;
			}
		}
	}

	// If the filter is null, then only provide "(objectclass=RTPerson)"
	//
	if (pszFilter != NULL)
		cbSize += lstrlen (pszFilter) * sizeof (TCHAR);

	// Allocate new memory for filter
	//
	TCHAR *pszNewFilter = (TCHAR *) MemAlloc (cbSize);
	if (pszNewFilter != NULL)
	{
		wsprintf (pszNewFilter, TEXT ("(&(%s)%s"), pszDefBase, pszShowEntries);
		TCHAR *psz = pszNewFilter + lstrlen (pszNewFilter);

		if (pszFilter != NULL)
		{
			wsprintf (psz, (*pszFilter == TEXT ('(')) ? TEXT ("%s") : TEXT ("(%s)"),
							pszFilter);
		}
		lstrcat (psz, TEXT (")"));

		// Go through the filter and convert '*' to '%'
		//
		for (psz = pszNewFilter; *psz != TEXT ('\0'); psz = CharNext (psz))
		{
			if (*psz == TEXT ('*'))
				*psz = TEXT ('%');
		}
	}

	return pszNewFilter;
}


















=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\localapp.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       localapp.h
//  Content:    This file contains the LocalApplication object definition.
//  History:
//      Wed 17-Apr-1996 11:18:47  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#ifndef _CLOCALAPP_H_
#define _CLOCALAPP_H_

#include "connpt.h"

//****************************************************************************
// Enumeration type
//****************************************************************************
//
typedef enum {
    ULS_APP_SET_ATTRIBUTES,
    ULS_APP_REMOVE_ATTRIBUTES,
}   APP_CHANGE_ATTRS;

typedef enum {
    ULS_APP_ADD_PROT,
    ULS_APP_REMOVE_PROT,
}   APP_CHANGE_PROT;

//****************************************************************************
// CUls definition
//****************************************************************************
//
class CLocalApp : public IULSLocalApplication,
                  public IConnectionPointContainer 
{
private:
    ULONG                   cRef;
    LPTSTR                  szName;
    GUID                    guid;
    LPTSTR                  szMimeType;
    CAttributes             *pAttrs;
    CList                   ProtList;
    CConnectionPoint        *pConnPt;

    // Private methods
    STDMETHODIMP    NotifySink (void *pv, CONN_NOTIFYPROC pfn);
    STDMETHODIMP    ChangeAttributes (IULSAttributes *pAttributes,
                                      ULONG *puReqID,
                                      APP_CHANGE_ATTRS uCmd);
    STDMETHODIMP    ChangeProtocol (IULSLocalAppProtocol *pAttributes,
                                    ULONG *puReqID,
                                    APP_CHANGE_PROT uCmd);

public:
    // Constructor and destructor
    CLocalApp (void);
    ~CLocalApp (void);
    STDMETHODIMP    Init (BSTR bstrName, REFGUID rguid, BSTR bstrMimeType);

    // Internal methods
    STDMETHODIMP    GetAppInfo (PLDAP_APPINFO *ppAppInfo);

    // Asynchronous response handler
    //
    STDMETHODIMP    AttributesChangeResult (CAttributes *pAttributes,
                                            ULONG uReqID, HRESULT hResult,
                                            APP_CHANGE_ATTRS uCmd);
    STDMETHODIMP    ProtocolChangeResult (CLocalProt *pProtocol,
                                          ULONG uReqID, HRESULT hResult,
                                          APP_CHANGE_PROT uCmd);

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IULSLocalApplication
    STDMETHODIMP    CreateProtocol (BSTR bstrProtocolID, ULONG uPortNumber,
                                    BSTR bstrMimeType,
                                    IULSLocalAppProtocol **ppProtocol);
    STDMETHODIMP    AddProtocol (IULSLocalAppProtocol *pProtocol,
                                 ULONG *puReqID);
    STDMETHODIMP    RemoveProtocol (IULSLocalAppProtocol *pProtocol,
                                    ULONG *puReqID);
    STDMETHODIMP    EnumProtocols (IEnumULSLocalAppProtocols **ppEnumProtocol);
    STDMETHODIMP    SetAttributes (IULSAttributes *pAttributes,
                                   ULONG *puReqID);
    STDMETHODIMP    RemoveAttributes (IULSAttributes *pAttributes,
                                      ULONG *puReqID);

    // IConnectionPointContainer
    STDMETHODIMP    EnumConnectionPoints(IEnumConnectionPoints **ppEnum);
    STDMETHODIMP    FindConnectionPoint(REFIID riid,
                                        IConnectionPoint **ppcp);

#ifdef  DEBUG
    void            DebugProtocolDump(void);
#endif  // DEBUG
};

//****************************************************************************
// CEnumLocalAppProtocols definition
//****************************************************************************
//
class CEnumLocalAppProtocols : public IEnumULSLocalAppProtocols
{
private:
    ULONG                   cRef;
    CList                   ProtList;
    HANDLE                  hEnum;

public:
    // Constructor and Initialization
    CEnumLocalAppProtocols (void);
    ~CEnumLocalAppProtocols (void);
    STDMETHODIMP            Init (CList *pProtList);

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IEnumULSLocalAppProtocols
    STDMETHODIMP            Next(ULONG cProtocols, IULSLocalAppProtocol **rgpProt,
                                 ULONG *pcFetched);
    STDMETHODIMP            Skip(ULONG cProtocols);
    STDMETHODIMP            Reset();
    STDMETHODIMP            Clone(IEnumULSLocalAppProtocols **ppEnum);
};

#endif //_CLOCALAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\init.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       init.cpp
//  Content:    This file contains the module initialization.
//  History:
//      Tue 08-Oct-1996 08:51:15  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#include "ulsp.h"
#include "regunreg.h"
#include <ilsguid.h>
#include "classfac.h"

//****************************************************************************
// Constants
//****************************************************************************

//****************************************************************************
// Global Parameters
//****************************************************************************

HINSTANCE           g_hInstance = NULL;
LONG                g_cDllRef = 0;
#ifdef _DEBUG
LONG				g_cCritSec = 0;
#endif
CRITICAL_SECTION    g_ULSSem;

#ifdef DEBUG
HDBGZONE ghZoneUls = NULL; // ULS zones
static PTCHAR _rgZonesUls[] = {
	TEXT("ILS"),
	TEXT("Error"),
	TEXT("Warning"),
	TEXT("Trace"),
	TEXT("RefCount"),
	TEXT("KA"),
	TEXT("Filter"),
	TEXT("Request"),
	TEXT("Response"),
	TEXT("Connection"),
};
#endif


//****************************************************************************
// BOOL _Processattach (HINSTANCE)
//
// This function is called when a process is attached to the DLL
//
// History:
//  Tue 08-Oct-1996 08:53:03  -by-  Viroon  Touranachun [viroont]
// Ported from Shell.
//****************************************************************************

BOOL _ProcessAttach(HINSTANCE hDll)
{
	// Tracking critical section leaks
	//
#ifdef _DEBUG
	g_cCritSec = 0;
	g_cDllRef = 0;
#endif

    g_hInstance = hDll;
    MyInitializeCriticalSection (&g_ULSSem);
    return TRUE;
}

//****************************************************************************
// BOOL _ProcessDetach (HINSTANCE)
//
// This function is called when a process is detached from the DLL
//
// History:
//  Tue 08-Oct-1996 08:53:11  -by-  Viroon  Touranachun [viroont]
// Ported from Shell.
//****************************************************************************

BOOL _ProcessDetach(HINSTANCE hDll)
{
    MyDeleteCriticalSection (&g_ULSSem);

#ifdef _DEBUG
    DBG_REF("ULS g_cCritSec=%d", g_cCritSec);
    DBG_REF("ULS RefCount=%d", g_cDllRef);
#endif

    return TRUE;
}

//****************************************************************************
// BOOL APIENTRY DllMain(HINSTANCE hDll, DWORD dwReason,  LPVOID lpReserved)
//
// This function is called when the DLL is loaded
//
// History:
//  Tue 08-Oct-1996 08:53:22  -by-  Viroon  Touranachun [viroont]
// Ported from Shell.
//****************************************************************************

BOOL APIENTRY DllMain(HINSTANCE hDll, DWORD dwReason,  LPVOID lpReserved)
{
    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
			DBGINIT(&ghZoneUls, _rgZonesUls);
            DisableThreadLibraryCalls(hDll);
            DBG_INIT_MEMORY_TRACKING(hDll);
            _ProcessAttach(hDll);
            break;

        case DLL_PROCESS_DETACH:
            _ProcessDetach(hDll);
            DBG_CHECK_MEMORY_TRACKING(hDll);
			DBGDEINIT(&ghZoneUls);
            break;

        default:
            break;

    } // end switch()

    return TRUE;
}

//****************************************************************************
// STDAPI DllCanUnLoadNow()
//
// This function is called to check whether it can be unloaded.
//
// History:
//  Tue 08-Oct-1996 08:53:35  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDAPI DllCanUnloadNow(void)
{
    if (g_cDllRef)
        return S_FALSE;

    return S_OK;
}

//****************************************************************************
// STDAPI DllRegisterServer(void)
//
// This function is called to check whether it can be unloaded.
//
// History:
//  Tue 08-Oct-1996 08:53:35  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDAPI DllRegisterServer(void)
{
    if (RegisterUnknownObject(TEXT("Internet Location Services"),
                              CLSID_InternetLocationServices))
        return S_OK;
    else
        return ILS_E_FAIL;
}

//****************************************************************************
// STDAPI DllUnregisterServer(void)
//
// This function is called to check whether it can be unloaded.
//
// History:
//  Tue 08-Oct-1996 08:53:35  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDAPI DllUnregisterServer(void)
{
    if (UnregisterUnknownObject(CLSID_InternetLocationServices))
        return S_OK;
    else
        return ILS_E_FAIL;
}

//****************************************************************************
// void DllLock()
//
// This function is called to prevent the DLL from being unloaded.
//
// History:
//  Tue 08-Oct-1996 08:53:45  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void DllLock(void)
{
    InterlockedIncrement(&g_cDllRef);
}

//****************************************************************************
// void DllRelease()
//
// This function is called to allow the DLL to be unloaded.
//
// History:
//  Tue 08-Oct-1996 08:53:52  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void DllRelease(void)
{
    InterlockedDecrement(&g_cDllRef);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\localprt.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       localprt.h
//  Content:    This file contains the LocalProtocol object definition.
//  History:
//      Wed 17-Apr-1996 11:18:47  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#ifndef _CLOCALPROT_H_
#define _CLOCALPROT_H_

#include "connpt.h"

//****************************************************************************
// Enumeration type
//****************************************************************************
//
typedef enum {
    ILS_PROT_SET_ATTRIBUTES,
    ILS_PROT_REMOVE_ATTRIBUTES,
}   PROT_CHANGE_ATTRS;

//****************************************************************************
// CIls definition
//****************************************************************************
//
class CLocalProt : public IIlsProtocol,
                   public IConnectionPointContainer 
{
private:
    LONG                    m_cRef;
    BOOL                    m_fReadonly;
    HANDLE					m_hProt;
    LPTSTR                  m_pszUser;
    LPTSTR                  m_pszApp;
    LPTSTR                  m_szName;
    ULONG                   m_uPort;
    LPTSTR                  m_szMimeType;
    CAttributes             *m_pAttrs;
    CConnectionPoint        *m_pConnPt;

	// server object
	CIlsServer				*m_pIlsServer;

    // Private method
    //
    STDMETHODIMP    NotifySink (void *pv, CONN_NOTIFYPROC pfn);

public:
    // Constructor and destructor
    CLocalProt (void);
    ~CLocalProt (void);
    STDMETHODIMP    Init (BSTR bstrName, ULONG uPort, BSTR bstrMimeType);
    STDMETHODIMP            Init (CIlsServer *pIlsServer,
                                  LPTSTR szUserName,
                                  LPTSTR szAppName,
                                  PLDAP_PROTINFO ppi);

    // Internal methods
    STDMETHODIMP    IsSameAs (CLocalProt *pProtocol);
    STDMETHODIMP    GetProtocolInfo (PLDAP_PROTINFO *ppProtInfo);
	VOID			SetProviderHandle ( HANDLE hProt ) { m_hProt = hProt; };
	HANDLE			GetProviderHandle ( VOID ) { return m_hProt; };

    // Asynchronous response handler
    //

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IIlsLocalProtocol
    STDMETHODIMP IsWritable(
                BOOL *pValue);

    STDMETHODIMP GetPortNumber(ULONG *pulPortNumber);

    STDMETHODIMP GetStandardAttribute(
            ILS_STD_ATTR_NAME  enumUlsStdAttr,
            BSTR *pbstrName);

    STDMETHODIMP SetStandardAttribute(
            ILS_STD_ATTR_NAME  enumUlsStdAttr,
            BSTR pbstrName);

    STDMETHODIMP Update ( ULONG *puReqID );

    STDMETHODIMP GetExtendedAttribute ( BSTR bstrName, BSTR *pbstrValue );
    STDMETHODIMP SetExtendedAttribute ( BSTR bstrName, BSTR bstrValue );
    STDMETHODIMP RemoveExtendedAttribute ( BSTR bstrName );
    STDMETHODIMP GetAllExtendedAttributes ( IIlsAttributes **ppAttributes );

    // IConnectionPointContainer
    STDMETHODIMP    EnumConnectionPoints(IEnumConnectionPoints **ppEnum);
    STDMETHODIMP    FindConnectionPoint(REFIID riid,
                                        IConnectionPoint **ppcp);
};


#endif //_CLOCALPROT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\ldapstub.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       ldapstub.cpp
//  Content:    ULS/LDAP stubbed functions
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#include "ulsp.h"

HWND    g_hwndCB = NULL;
ULONG   uMsgID;

//
// Initialization
//
HRESULT UlsLdap_Initialize (
    HWND            hwndCallback)
{
    uMsgID = 1;
    g_hwndCB = hwndCallback;
    return S_OK;
}

HRESULT UlsLdap_Deinitialize (void)
{
    uMsgID = 0;
    g_hwndCB = NULL;
    return S_OK;
}

HRESULT UlsLdap_Cancel (
    ULONG uReqID)
{
    return S_OK;
}


//
// Local machine information
//
HRESULT UlsLdap_RegisterUser (
    LPTSTR          pszServer,
    PLDAP_USERINFO  pUserInfo,
    PHANDLE         phUser,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    *phUser = (HANDLE)(0x11111111);
    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_REGISTER_USER, uMsgID, NOERROR);
    uMsgID++;
    return NOERROR;
}

HRESULT UlsLdap_RegisterApp (
    HANDLE          hUser, 
    PLDAP_APPINFO   pAppInfo,
    PHANDLE         phApp,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    if (hUser != (HANDLE)(0x11111111))
    {
        ASSERT(0);
        return ULS_E_FAIL;
    };

    *phApp = (HANDLE)(0x22222222);
    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_REGISTER_APP, uMsgID, NOERROR);
    uMsgID++;
    return NOERROR;
}


HRESULT UlsLdap_RegisterProtocol (
    HANDLE          hApp,
    PLDAP_PROTINFO  pProtInfo,
    PHANDLE         phProtocol,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    if (hApp != (HANDLE)(0x22222222))
    {
        ASSERT(0);
        return ULS_E_FAIL;
    };

    *phProtocol = (HANDLE)(0x44444444);
    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_REGISTER_PROTOCOL, uMsgID, NOERROR);
    uMsgID++;
    return NOERROR;
}

HRESULT UlsLdap_UnRegisterUser (
    HANDLE          hUser,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    if (hUser != (HANDLE)(0x11111111))
    {
        ASSERT(0);
        return ULS_E_FAIL;
    };

    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_UNREGISTER_USER, uMsgID, NOERROR);
    uMsgID++;
    return NOERROR;
}

HRESULT UlsLdap_UnRegisterApp (
    HANDLE          hApp,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    if (hApp != (HANDLE)(0x22222222))
    {
        ASSERT(0);
        return ULS_E_FAIL;
    };

    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_UNREGISTER_APP, uMsgID, NOERROR);
    uMsgID++;
    return NOERROR;
}

HRESULT UlsLdap_UnRegisterProtocol (
    HANDLE          hProt,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    if (hProt != (HANDLE)(0x44444444))
    {
        ASSERT(0);
        return ULS_E_FAIL;
    };

    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_UNREGISTER_PROTOCOL, uMsgID, NOERROR);
    uMsgID++;
    return NOERROR;
}

HRESULT UlsLdap_SetUserInfo (
    HANDLE          hUser,
    PLDAP_USERINFO  pInfo,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_SET_USER_INFO, uMsgID, NOERROR);
    uMsgID++;
    return NOERROR;
}

HRESULT UlsLdap_SetAppAttrs (
    HANDLE          hApp,
    ULONG           cAttrs,
    LPTSTR          pszAttrs,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_SET_APP_ATTRS, uMsgID, NOERROR);
    uMsgID++;
    return NOERROR;
}

HRESULT UlsLdap_SetProtocolAttrs (
    HANDLE          hProt,
    ULONG           cAttrs,
    LPTSTR          pszAttrs,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_SET_PROTOCOL_ATTRS, uMsgID, NOERROR);
    uMsgID++;
    return NOERROR;
}

HRESULT UlsLdap_RemoveAppAttrs (
    HANDLE          hApp,
    ULONG           cAttrs,
    LPTSTR          pszAttrNames,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_REMOVE_APP_ATTRS, uMsgID, NOERROR);
    uMsgID++;
    return NOERROR;
}

HRESULT UlsLdap_RemoveProtocolAttrs (
    HANDLE          hApp,
    ULONG           cAttrs,
    LPTSTR          pszAttrNames,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_REMOVE_PROTOCOL_ATTRS, uMsgID, NOERROR);
    uMsgID++;
    return NOERROR;
}


//
// User Location Services request
//
static TCHAR c_szEnumNames_1[] = {TEXT("User_1") TEXT("\0")
                                  TEXT("User_2") TEXT("\0")
                                  TEXT("User_3") TEXT("\0")
                                  TEXT("User_4") TEXT("\0\0")};

static TCHAR c_szEnumNames_2[] = {TEXT("User_5") TEXT("\0")
                                  TEXT("User_6") TEXT("\0")
                                  TEXT("User_7") TEXT("\0")
                                  TEXT("User_8") TEXT("\0\0")};

HRESULT UlsLdap_EnumUsers (
    LPTSTR          pszServer,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    PLDAP_ENUM ple;

    // First batch
    //
    ple = (PLDAP_ENUM)LocalAlloc(LMEM_FIXED, sizeof(*ple)+sizeof(c_szEnumNames_1));
    ple->uSize = sizeof(*ple);
    ple->hResult = NOERROR;
    ple->cItems = 4;
    ple->uOffsetItems = ple->uSize;
    CopyMemory(((PBYTE)ple)+ple->uOffsetItems, c_szEnumNames_1,
               sizeof(c_szEnumNames_1));

    PostMessage(g_hwndCB, WM_ULS_ENUM_USERS, uMsgID, (LPARAM)ple);

    // Second batch
    //
    ple = (PLDAP_ENUM)LocalAlloc(LMEM_FIXED, sizeof(*ple)+sizeof(c_szEnumNames_2));
    ple->uSize = sizeof(*ple);
    ple->hResult = NOERROR;
    ple->cItems = 4;
    ple->uOffsetItems = ple->uSize;
    CopyMemory(((PBYTE)ple)+ple->uOffsetItems, c_szEnumNames_2,
               sizeof(c_szEnumNames_2));

    PostMessage(g_hwndCB, WM_ULS_ENUM_USERS, uMsgID, (LPARAM)ple);

    // Terminate
    //
    PostMessage(g_hwndCB, WM_ULS_ENUM_USERS, uMsgID, (LPARAM)NULL);

    pAsyncInfo->uMsgID = uMsgID;
    uMsgID++;
    return NOERROR;
}

HRESULT UlsLdap_ResolveUser (
    LPTSTR          pszServer,
    LPTSTR          pszUserName,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    PLDAP_USERINFO_RES plur;
    PLDAP_USERINFO     plu;
    ULONG   cLen;

    plur = (PLDAP_USERINFO_RES)LocalAlloc(LMEM_FIXED, sizeof(*plur)+
                                          (sizeof(TCHAR)*MAX_PATH));
    plur->uSize = sizeof(*plur);
    plur->hResult = NOERROR;

    plu = &(plur->lui);
    plu->uSize = sizeof(LDAP_USERINFO);
    plu->uOffsetName = plu->uSize;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetName), TEXT("%s"), pszUserName) + 1;

    plu->uOffsetFirstName = plu->uOffsetName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetFirstName), TEXT("%s_First"),
                    pszUserName) + 1;

    plu->uOffsetLastName = plu->uOffsetFirstName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetLastName), TEXT("%s_Last"),
                    pszUserName) + 1;

    plu->uOffsetEMailName = plu->uOffsetLastName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetEMailName), TEXT("%s"),
                    pszUserName) + 1;

    plu->uOffsetCityName = plu->uOffsetEMailName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetCityName), TEXT("%sville"),
                    pszUserName) + 1;

    plu->uOffsetCountryName = plu->uOffsetCityName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetCountryName), TEXT("%sland"),
                    pszUserName) + 1;

    plu->uOffsetComment = plu->uOffsetCountryName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetComment), TEXT("%s's comment"),
                    pszUserName) + 1;

    plu->uOffsetIPAddress = plu->uOffsetComment+cLen;
    lstrcpy((LPTSTR)(((PBYTE)plu)+plu->uOffsetIPAddress), TEXT("125.1.100.2"));
    plu->dwFlags = 1;

    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_RESOLVE_USER, uMsgID, (LPARAM)plur);
    uMsgID++;
    return S_OK;
}

HRESULT UlsLdap_EnumUserInfos (
    LPTSTR          pszServer,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    PLDAP_ENUM ple;
    PLDAP_USERINFO plu;
    LPTSTR  pszUserName;
    ULONG   uOffsetLast;
    ULONG   cLen;

    // First batch
    //
    ple = (PLDAP_ENUM)LocalAlloc(LMEM_FIXED, sizeof(*ple)+
                                             3*sizeof(LDAP_USERINFO)+
                                             3*sizeof(TCHAR)*MAX_PATH);
    ple->uSize = sizeof(*ple);
    ple->hResult = NOERROR;
    ple->cItems = 3;
    ple->uOffsetItems = ple->uSize;

    // First batch--First guy
    //
    pszUserName = c_szEnumNames_1;
    plu = (PLDAP_USERINFO)(((PBYTE)ple)+ple->uOffsetItems);
    plu->uSize = sizeof(LDAP_USERINFO);
    plu->uOffsetName = sizeof(*plu)*3;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetName), TEXT("%s"), pszUserName) + 1;

    plu->uOffsetFirstName = plu->uOffsetName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetFirstName), TEXT("%s_First"),
                    pszUserName) + 1;

    plu->uOffsetLastName = plu->uOffsetFirstName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetLastName), TEXT("%s_Last"),
                    pszUserName) + 1;

    plu->uOffsetEMailName = plu->uOffsetLastName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetEMailName), TEXT("%s"),
                    pszUserName) + 1;

    plu->uOffsetCityName = plu->uOffsetEMailName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetCityName), TEXT("%sville"),
                    pszUserName) + 1;

    plu->uOffsetCountryName = plu->uOffsetCityName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetCountryName), TEXT("%sland"),
                    pszUserName) + 1;

    plu->uOffsetComment = plu->uOffsetCountryName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetComment), TEXT("%s's comment"),
                    pszUserName) + 1;

    plu->uOffsetIPAddress = plu->uOffsetComment+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetIPAddress), TEXT("125.1.100.2"))+1;
    plu->dwFlags = 1;
    uOffsetLast = plu->uOffsetIPAddress+cLen;

    // First batch--Second guy
    //
    pszUserName += lstrlen(pszUserName)+1;
    plu = (PLDAP_USERINFO)plu+1;
    plu->uSize = sizeof(LDAP_USERINFO);
    plu->uOffsetName = uOffsetLast-sizeof(*plu);
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetName), TEXT("%s"), pszUserName) + 1;

    plu->uOffsetFirstName = plu->uOffsetName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetFirstName), TEXT("%s_First"),
                    pszUserName) + 1;

    plu->uOffsetLastName = plu->uOffsetFirstName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetLastName), TEXT("%s_Last"),
                    pszUserName) + 1;

    plu->uOffsetEMailName = plu->uOffsetLastName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetEMailName), TEXT("%s"),
                    pszUserName) + 1;

    plu->uOffsetCityName = plu->uOffsetEMailName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetCityName), TEXT("%sville"),
                    pszUserName) + 1;

    plu->uOffsetCountryName = plu->uOffsetCityName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetCountryName), TEXT("%sland"),
                    pszUserName) + 1;

    plu->uOffsetComment = plu->uOffsetCountryName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetComment), TEXT("%s's comment"),
                    pszUserName) + 1;

    plu->uOffsetIPAddress = plu->uOffsetComment+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetIPAddress), TEXT("125.2.100.2"))+1;
    plu->dwFlags = 1;
    uOffsetLast = plu->uOffsetIPAddress+cLen;

    // First batch--Third guy
    //
    pszUserName += lstrlen(pszUserName)+1;
    plu = (PLDAP_USERINFO)plu+1;
    plu->uSize = sizeof(LDAP_USERINFO);
    plu->uOffsetName = uOffsetLast-sizeof(*plu);
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetName), TEXT("%s"), pszUserName) + 1;

    plu->uOffsetFirstName = plu->uOffsetName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetFirstName), TEXT("%s_First"),
                    pszUserName) + 1;

    plu->uOffsetLastName = plu->uOffsetFirstName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetLastName), TEXT("%s_Last"),
                    pszUserName) + 1;

    plu->uOffsetEMailName = plu->uOffsetLastName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetEMailName), TEXT("%s"),
                    pszUserName) + 1;

    plu->uOffsetCityName = plu->uOffsetEMailName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetCityName), TEXT("%sville"),
                    pszUserName) + 1;

    plu->uOffsetCountryName = plu->uOffsetCityName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetCountryName), TEXT("%sland"),
                    pszUserName) + 1;

    plu->uOffsetComment = plu->uOffsetCountryName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetComment), TEXT("%s's comment"),
                    pszUserName) + 1;

    plu->uOffsetIPAddress = plu->uOffsetComment+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetIPAddress), TEXT("125.3.100.2"))+1;
    plu->dwFlags = 1;
    uOffsetLast = plu->uOffsetIPAddress+cLen;

    PostMessage(g_hwndCB, WM_ULS_ENUM_USERINFOS, uMsgID, (LPARAM)ple);

    // Second batch
    //
    ple = (PLDAP_ENUM)LocalAlloc(LMEM_FIXED, sizeof(*ple)+
                                             3*sizeof(LDAP_USERINFO)+
                                             3*sizeof(TCHAR)*MAX_PATH);
    ple->uSize = sizeof(*ple);
    ple->hResult = NOERROR;
    ple->cItems = 3;
    ple->uOffsetItems = ple->uSize;

    // Second batch--First guy
    //
    pszUserName = c_szEnumNames_2;
    plu = (PLDAP_USERINFO)(((PBYTE)ple)+ple->uOffsetItems);
    plu->uSize = sizeof(LDAP_USERINFO);
    plu->uOffsetName = sizeof(*plu)*3;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetName), TEXT("%s"), pszUserName) + 1;

    plu->uOffsetFirstName = plu->uOffsetName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetFirstName), TEXT("%s_First"),
                    pszUserName) + 1;

    plu->uOffsetLastName = plu->uOffsetFirstName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetLastName), TEXT("%s_Last"),
                    pszUserName) + 1;

    plu->uOffsetEMailName = plu->uOffsetLastName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetEMailName), TEXT("%s"),
                    pszUserName) + 1;

    plu->uOffsetCityName = plu->uOffsetEMailName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetCityName), TEXT("%sville"),
                    pszUserName) + 1;

    plu->uOffsetCountryName = plu->uOffsetCityName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetCountryName), TEXT("%sland"),
                    pszUserName) + 1;

    plu->uOffsetComment = plu->uOffsetCountryName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetComment), TEXT("%s's comment"),
                    pszUserName) + 1;

    plu->uOffsetIPAddress = plu->uOffsetComment+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetIPAddress), TEXT("125.1.100.2"))+1;
    plu->dwFlags = 1;
    uOffsetLast = plu->uOffsetIPAddress+cLen;

    // Second batch--Second guy
    //
    pszUserName += lstrlen(pszUserName)+1;
    plu = (PLDAP_USERINFO)plu+1;
    plu->uSize = sizeof(LDAP_USERINFO);
    plu->uOffsetName = uOffsetLast-sizeof(*plu);
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetName), TEXT("%s"), pszUserName) + 1;

    plu->uOffsetFirstName = plu->uOffsetName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetFirstName), TEXT("%s_First"),
                    pszUserName) + 1;

    plu->uOffsetLastName = plu->uOffsetFirstName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetLastName), TEXT("%s_Last"),
                    pszUserName) + 1;

    plu->uOffsetEMailName = plu->uOffsetLastName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetEMailName), TEXT("%s"),
                    pszUserName) + 1;

    plu->uOffsetCityName = plu->uOffsetEMailName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetCityName), TEXT("%sville"),
                    pszUserName) + 1;

    plu->uOffsetCountryName = plu->uOffsetCityName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetCountryName), TEXT("%sland"),
                    pszUserName) + 1;

    plu->uOffsetComment = plu->uOffsetCountryName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetComment), TEXT("%s's comment"),
                    pszUserName) + 1;

    plu->uOffsetIPAddress = plu->uOffsetComment+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetIPAddress), TEXT("125.2.100.2"))+1;
    plu->dwFlags = 1;
    uOffsetLast = plu->uOffsetIPAddress+cLen;

    // Second batch--Third guy
    //
    pszUserName += lstrlen(pszUserName)+1;
    plu = (PLDAP_USERINFO)plu+1;
    plu->uSize = sizeof(LDAP_USERINFO);
    plu->uOffsetName = uOffsetLast-sizeof(*plu);
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetName), TEXT("%s"), pszUserName) + 1;

    plu->uOffsetFirstName = plu->uOffsetName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetFirstName), TEXT("%s_First"),
                    pszUserName) + 1;

    plu->uOffsetLastName = plu->uOffsetFirstName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetLastName), TEXT("%s_Last"),
                    pszUserName) + 1;

    plu->uOffsetEMailName = plu->uOffsetLastName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetEMailName), TEXT("%s"),
                    pszUserName) + 1;

    plu->uOffsetCityName = plu->uOffsetEMailName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetCityName), TEXT("%sville"),
                    pszUserName) + 1;

    plu->uOffsetCountryName = plu->uOffsetCityName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetCountryName), TEXT("%sland"),
                    pszUserName) + 1;

    plu->uOffsetComment = plu->uOffsetCountryName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetComment), TEXT("%s's comment"),
                    pszUserName) + 1;

    plu->uOffsetIPAddress = plu->uOffsetComment+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetIPAddress), TEXT("125.3.100.2"))+1;
    plu->dwFlags = 1;
    uOffsetLast = plu->uOffsetIPAddress+cLen;

    PostMessage(g_hwndCB, WM_ULS_ENUM_USERINFOS, uMsgID, (LPARAM)ple);

    // Termination
    //
    PostMessage(g_hwndCB, WM_ULS_ENUM_USERINFOS, uMsgID, (LPARAM)NULL);

    pAsyncInfo->uMsgID = uMsgID;
    uMsgID++;
    return NOERROR;
}

static TCHAR c_szEnumApps[] = {TEXT("App_1") TEXT("\0")
                               TEXT("App_2") TEXT("\0")
                               TEXT("App_3") TEXT("\0")
                               TEXT("App_4") TEXT("\0\0")};
HRESULT UlsLdap_EnumApps (
    LPTSTR          pszServer,
    LPTSTR          pszUserName,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    PLDAP_ENUM ple;

    ple = (PLDAP_ENUM)LocalAlloc(LMEM_FIXED, sizeof(*ple)+sizeof(c_szEnumApps));
    ple->uSize = sizeof(*ple);
    ple->hResult = NOERROR;
    ple->cItems = 4;
    ple->uOffsetItems = ple->uSize;
    CopyMemory(((PBYTE)ple)+ple->uOffsetItems, c_szEnumApps,
               sizeof(c_szEnumApps));

    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_ENUM_APPS, uMsgID, (LPARAM)ple);
    uMsgID++;
    return NOERROR;
}

static TCHAR c_szAttributes[] = {TEXT("Attr_1") TEXT("\0") TEXT("Value_1") TEXT("\0")
                                 TEXT("Attr_2") TEXT("\0") TEXT("Value_2") TEXT("\0")
                                 TEXT("Attr_3") TEXT("\0") TEXT("Value_3") TEXT("\0")};

HRESULT UlsLdap_ResolveApp (
    LPTSTR          pszServer,
    LPTSTR          pszUserName,
    LPTSTR          pszAppName,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    PLDAP_APPINFO_RES plar;
    PLDAP_APPINFO     pla;
    ULONG   cLen;

    plar = (PLDAP_APPINFO_RES)LocalAlloc(LMEM_FIXED, sizeof(*plar)+
                                         (sizeof(TCHAR)*MAX_PATH));
    plar->uSize = sizeof(*plar);
    plar->hResult = NOERROR;

    pla = &(plar->lai);
    pla->uSize = sizeof(LDAP_APPINFO);
    pla->guid = IID_IEnumULSNames;

    pla->uOffsetName = pla->uSize;
    cLen = wsprintf((LPTSTR)(((PBYTE)pla)+pla->uOffsetName), TEXT("%s"), pszAppName) + 1;

    pla->uOffsetMimeType = pla->uOffsetName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)pla)+pla->uOffsetMimeType), TEXT("application\\%s"),
                    pszAppName) + 1;

    pla->cAttributes = 3;
    pla->uOffsetAttributes = pla->uOffsetMimeType+cLen;
    CopyMemory((LPBYTE)(((PBYTE)pla)+pla->uOffsetAttributes),
               c_szAttributes, sizeof(c_szAttributes));

    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_RESOLVE_APP, uMsgID, (LPARAM)plar);
    uMsgID++;
    return S_OK;
}

static TCHAR c_szEnumProts[] = {TEXT("Prot_1") TEXT("\0")
                               TEXT("Prot_2") TEXT("\0")
                               TEXT("Prot_3") TEXT("\0")
                               TEXT("Prot_4") TEXT("\0\0")};
HRESULT UlsLdap_EnumProtocols (
    LPTSTR          pszServer,
    LPTSTR          pszUserName,
    LPTSTR          pszAppName,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    PLDAP_ENUM ple;

    ple = (PLDAP_ENUM)LocalAlloc(LMEM_FIXED, sizeof(*ple)+sizeof(c_szEnumProts));
    ple->uSize = sizeof(*ple);
    ple->hResult = NOERROR;
    ple->cItems = 4;
    ple->uOffsetItems = ple->uSize;
    CopyMemory(((PBYTE)ple)+ple->uOffsetItems, c_szEnumProts,
               sizeof(c_szEnumProts));

    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_ENUM_PROTOCOLS, uMsgID, (LPARAM)ple);
    uMsgID++;
    return NOERROR;
}

HRESULT UlsLdap_ResolveProtocol (
    LPTSTR          pszServer,
    LPTSTR          pszUserName,
    LPTSTR          pszAppName,
    LPTSTR          pszProtName,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    PLDAP_PROTINFO_RES plpr;
    PLDAP_PROTINFO     plp;
    ULONG   cLen;

    plpr = (PLDAP_PROTINFO_RES)LocalAlloc(LMEM_FIXED, sizeof(*plpr)+
                                         (sizeof(TCHAR)*MAX_PATH));
    plpr->uSize = sizeof(*plpr);
    plpr->hResult = NOERROR;

    plp = &(plpr->lpi);
    plp->uSize = sizeof(LDAP_PROTINFO);
    plp->uPortNumber = 80;

    plp->uOffsetName = plp->uSize;
    cLen = wsprintf((LPTSTR)(((PBYTE)plp)+plp->uOffsetName), TEXT("%s"), pszProtName) + 1;

    plp->uOffsetMimeType = plp->uOffsetName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plp)+plp->uOffsetMimeType), TEXT("protocol\\%s"),
                    pszProtName) + 1;

    plp->cAttributes = 3;
    plp->uOffsetAttributes = plp->uOffsetMimeType+cLen;
    CopyMemory((LPBYTE)(((PBYTE)plp)+plp->uOffsetAttributes),
               c_szAttributes, sizeof(c_szAttributes));

    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_RESOLVE_PROTOCOL, uMsgID, (LPARAM)plpr);
    uMsgID++;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\localprt.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       localprt.cpp
//  Content:    This file contains the LocalProtocol object.
//  History:
//      Wed 17-Apr-1996 11:13:54  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#include "ulsp.h"
#include "localprt.h"
#include "attribs.h"
#include "callback.h"
#include "culs.h"

//****************************************************************************
// Event Notifiers
//****************************************************************************
//
//****************************************************************************
// Class Implementation
//****************************************************************************
//
//****************************************************************************
// CLocalProt::CLocalProt (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CLocalProt::CLocalProt (void)
:m_cRef (0),
 m_fReadonly (FALSE),
 m_hProt (NULL),
 m_szName (NULL),
 m_uPort (0),
 m_szMimeType (NULL),
 m_pAttrs (NULL),
 m_pConnPt (NULL),
 m_pIlsServer (NULL),
 m_pszUser (NULL),
 m_pszApp (NULL)
{
}

//****************************************************************************
// CLocalProt::~CLocalProt (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CLocalProt::~CLocalProt (void)
{
    // Release the connection point
    //
    if (m_pConnPt != NULL)
    {
        m_pConnPt->ContainerReleased();
        ((IConnectionPoint*)m_pConnPt)->Release();
    };

    // Release the attributes object
    //
    if (m_pAttrs != NULL)
    {
        m_pAttrs->Release();
    };

    // Release the buffer resources
    //
    ::MemFree (m_szName);
    ::MemFree (m_szMimeType);
    ::MemFree (m_pszUser);
    ::MemFree (m_pszApp);

    if (m_pIlsServer != NULL)
        m_pIlsServer->Release ();

    if (m_hProt != NULL)
        ::UlsLdap_VirtualUnRegisterProtocol(m_hProt);
}

//****************************************************************************
// STDMETHODIMP
// CLocalProt::Init (BSTR bstrName, ULONG uPort, BSTR bstrMimeType)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalProt::Init (BSTR bstrName, ULONG uPort, BSTR bstrMimeType)
{
    HRESULT hr;

    // Set the port number
    //
    this->m_uPort = uPort;

    hr = BSTR_to_LPTSTR(&m_szName, bstrName);
    if (SUCCEEDED(hr))
    {
        hr = BSTR_to_LPTSTR(&m_szMimeType, bstrMimeType);
        if (SUCCEEDED(hr))
        {
#ifdef LATER
            // Initialize the attributes list
            //
            m_pAttrs = new CAttributes;
            if (m_pAttrs != NULL)
            	m_pAttrs->SetAccessType (ILS_ATTRTYPE_NAME_VALUE);

#endif //LATER
                // Make the connection point
                //
                m_pConnPt = new CConnectionPoint (&IID_IIlsProtocolNotify,
                                                (IConnectionPointContainer *)this);
                if (m_pConnPt != NULL)
                {
                    ((IConnectionPoint*)m_pConnPt)->AddRef();
                    hr = NOERROR;
                }
                else
                {
                    hr = ILS_E_MEMORY;
                };
        };
    };

	// Make this as read/write access
	//
    ASSERT (! m_fReadonly);

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsProt::Init (LPTSTR szServerName, LPTSTR szUserName, 
//                 LPTSTR szAppName, PLDAP_PROTINFO ppi)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalProt::Init (CIlsServer *pIlsServer, LPTSTR szUserName, 
                LPTSTR szAppName, PLDAP_PROTINFO ppi)
{
    HRESULT hr;

    // Validate parameter
    //
    if (ppi == NULL)
    	return ILS_E_POINTER;

    if (ppi->uSize != sizeof(*ppi))
        return ILS_E_PARAMETER;

    // Make this a readonly guy
	//
    m_fReadonly = TRUE;

    // Remember port name
    //
    m_uPort = ppi->uPortNumber;

    // Remember the server name
    //
    m_pIlsServer = pIlsServer;
    pIlsServer->AddRef ();

    hr = SetLPTSTR(&m_pszUser, szUserName);
    if (SUCCEEDED(hr))
    {
        hr = SetLPTSTR(&m_pszApp, szAppName);

        if (SUCCEEDED(hr))
        {
            hr = SetLPTSTR(&m_szName,
                           (LPCTSTR)(((PBYTE)ppi)+ppi->uOffsetName));

            if (SUCCEEDED(hr))
            {
                hr = SetLPTSTR(&m_szMimeType,
                               (LPCTSTR)(((PBYTE)ppi)+ppi->uOffsetMimeType));

            };
        };
    };

	// cleanup is done in destructor

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CLocalProt::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalProt::QueryInterface (REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (riid == IID_IIlsProtocol || riid == IID_IUnknown)
    {
        *ppv = (IIlsMain *) this;
    }
    else
    {
        if (riid == IID_IConnectionPointContainer)
        {
            *ppv = (IConnectionPointContainer *) this;
        };
    };

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        return ILS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CLocalProt::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:14:17  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CLocalProt::AddRef (void)
{
    DllLock();

	MyDebugMsg ((DM_REFCOUNT, "CLocalProt::AddRef: ref=%ld\r\n", m_cRef));
    ::InterlockedIncrement (&m_cRef);
    return (ULONG) m_cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CLocalProt::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:14:26  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CLocalProt::Release (void)
{
    DllRelease();

	ASSERT (m_cRef > 0);

	MyDebugMsg ((DM_REFCOUNT, "CLocalProt::Release: ref=%ld\r\n", m_cRef));
    if (::InterlockedDecrement (&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return (ULONG) m_cRef;
}

//****************************************************************************
// STDMETHODIMP
// CLocalProt::IsWritable (BOOL *pfWriteable)
//
//****************************************************************************
STDMETHODIMP
CLocalProt::IsWritable(BOOL *pfWriteable)
{
    HRESULT hr;

    if (pfWriteable)
    {
        *pfWriteable = !m_fReadonly;
		hr = S_OK;
    }
    else
    {
    	hr = ILS_E_POINTER;
    }

    return (hr);
}


//****************************************************************************
// STDMETHODIMP
// CLocalProt::GetStandardAttribute (ILS_STD_ATTR_NAME   stdAttr, BSTR *pbstrStdAttr)
//
// History:
//  1-16-97 Shishir Pardikar
// Created.
//****************************************************************************
STDMETHODIMP
CLocalProt::GetStandardAttribute(
    ILS_STD_ATTR_NAME   stdAttr,
    BSTR                *pbstrStdAttr
)
{
    LPTSTR lpszAttr = NULL;
    BOOL    fValid = TRUE;
    HRESULT hr;
	TCHAR sz[16];

    if (pbstrStdAttr == NULL) {

        return ILS_E_POINTER;

    }
    switch(stdAttr) {

    case ILS_STDATTR_PROTOCOL_PORT:
    	lpszAttr = &sz[0];
    	wsprintf (&sz[0], TEXT ("%lu"), m_uPort);
    	break;

    case ILS_STDATTR_PROTOCOL_NAME:
        lpszAttr = m_szName;
        break;
    case ILS_STDATTR_PROTOCOL_MIME_TYPE:
        lpszAttr = m_szMimeType;
        break;

    default:
        fValid = FALSE;
        break;
    }

    if (fValid) {
        if (lpszAttr){

            hr = LPTSTR_to_BSTR(pbstrStdAttr, lpszAttr);
        }
        else {

            *pbstrStdAttr = NULL;
            hr = NOERROR;

        }
    }
    else {

        hr = ILS_E_PARAMETER;

    }

    return (hr);
}

//****************************************************************************
// STDMETHODIMP
// CLocalProt::SetStandardAttribute (ILS_STD_ATTR_NAME   stdAttr, BSTR bstrStdAttr)
//
// History:
//  1-16-97 Shishir Pardikar
// Created.
//****************************************************************************
STDMETHODIMP
CLocalProt::SetStandardAttribute(
    ILS_STD_ATTR_NAME   stdAttr,
    BSTR                bstrStdAttr
)
{
    return (ILS_E_FAIL);
}

//****************************************************************************
// STDMETHODIMP
// CLocalProt::Update(BSTR bstrServerName, ULONG *pulReqId)
//
// History:
//  1-16-97 Shishir Pardikar
// Created.
//****************************************************************************
STDMETHODIMP CLocalProt::
Update ( ULONG *pulReqID )
{
    return (ILS_E_FAIL);
}

//****************************************************************************
// STDMETHODIMP
// CLocalProt::IsSameAs (CLocalProt *pProtocol)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalProt::IsSameAs (CLocalProt *pProtocol)
{
    return (!lstrcmp(pProtocol->m_szName, this->m_szName) ?
            NOERROR : S_FALSE);
}

//****************************************************************************
// STDMETHODIMP
// CLocalProt::GetProtocolInfo (PLDAP_PROTINFO *ppProtInfo)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalProt::GetProtocolInfo (PLDAP_PROTINFO *ppProtInfo)
{
    PLDAP_PROTINFO ppi;
    ULONG cName, cMime;
    HRESULT hr;

    // Assume failure
    //
    *ppProtInfo = NULL;

    // Calculate the buffer size
    //
    cName = lstrlen(m_szName)+1;
    cMime = lstrlen(m_szMimeType)+1;

    // Allocate the buffer
    //
    ULONG cbTotalSize = sizeof (LDAP_PROTINFO) + (cName + cMime) * sizeof (TCHAR);
    ppi = (PLDAP_PROTINFO) ::MemAlloc (cbTotalSize);
    if (ppi == NULL)
    {
        hr = ILS_E_MEMORY;
    }
    else
    {
        // Fill the structure content
        //
        ppi->uSize              = cbTotalSize;
        ppi->uOffsetName        = sizeof(*ppi);
        ppi->uPortNumber        = m_uPort;
        ppi->uOffsetMimeType    = ppi->uOffsetName + (cName*sizeof(TCHAR));

        // Copy the user information
        //
        lstrcpy((LPTSTR)(((PBYTE)ppi)+ppi->uOffsetName), m_szName);
        lstrcpy((LPTSTR)(((PBYTE)ppi)+ppi->uOffsetMimeType), m_szMimeType);

        // Return the structure
        //
        *ppProtInfo = ppi;
    };

    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CLocalProt::NotifySink (void *pv, CONN_NOTIFYPROC pfn)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalProt::NotifySink (void *pv, CONN_NOTIFYPROC pfn)
{
    HRESULT hr = S_OK;

    if (m_pConnPt != NULL)
    {
        hr = m_pConnPt->Notify(pv, pfn);
    };
    return hr;
}


//****************************************************************************
// STDMETHODIMP
// CLocalProt::GetID (BSTR *pbstrID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalProt::GetPortNumber (ULONG *pulPort)
{
    // Validate parameter
    //
    if (pulPort == NULL)
    {
        return ILS_E_POINTER;
    };

    *pulPort = m_uPort;

    return (NOERROR);
}

//****************************************************************************
// STDMETHODIMP
// CLocalProt::SetAttributes (IIlsAttributes *pAttributes, ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP CLocalProt::
SetExtendedAttribute ( BSTR bstrName, BSTR bstrValue )
{
	return ILS_E_NOT_IMPL;
}

//****************************************************************************
// STDMETHODIMP
// CLocalProt::RemoveAttributes (IIlsAttributes *pAttributes, ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP CLocalProt::
RemoveExtendedAttribute ( BSTR bstrName )
{
    return ILS_E_NOT_IMPL;
}

//****************************************************************************
// STDMETHODIMP
// CLocalProt::GetAttributes (IIlsAttributes **pAttributes)
//
//****************************************************************************

STDMETHODIMP CLocalProt::
GetExtendedAttribute ( BSTR bstrName, BSTR *pbstrValue )
{
    return ILS_E_NOT_IMPL;
}

//****************************************************************************
// STDMETHODIMP
// CLocalProt::GetAllExtendedAttributes (IIlsAttributes **pAttributes)
//
//****************************************************************************

STDMETHODIMP CLocalProt::
GetAllExtendedAttributes ( IIlsAttributes **ppAttributes )
{
    return ILS_E_NOT_IMPL;
}

//****************************************************************************
// STDMETHODIMP
// CLocalProt::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
//
// History:
//  Wed 17-Apr-1996 11:15:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalProt::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
{
    CEnumConnectionPoints *pecp;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return ILS_E_POINTER;
    };
    
    // Assume failure
    //
    *ppEnum = NULL;

    // Create an enumerator
    //
    pecp = new CEnumConnectionPoints;
    if (pecp == NULL)
        return ILS_E_MEMORY;

    // Initialize the enumerator
    //
    hr = pecp->Init((IConnectionPoint *)m_pConnPt);
    if (FAILED(hr))
    {
        delete pecp;
        return hr;
    };

    // Give it back to the caller
    //
    pecp->AddRef();
    *ppEnum = pecp;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CLocalProt::FindConnectionPoint(REFIID riid, IConnectionPoint **ppcp)
//
// History:
//  Wed 17-Apr-1996 11:15:09  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalProt::FindConnectionPoint(REFIID riid, IConnectionPoint **ppcp)
{
    IID siid;
    HRESULT hr;

    // Validate parameters
    //
    if (ppcp == NULL)
    {
        return ILS_E_POINTER;
    };
    
    // Assume failure
    //
    *ppcp = NULL;

    if (m_pConnPt != NULL)
    {
        hr = m_pConnPt->GetConnectionInterface(&siid);

        if (SUCCEEDED(hr))
        {
            if (riid == siid)
            {
                *ppcp = (IConnectionPoint *)m_pConnPt;
                (*ppcp)->AddRef();
                hr = S_OK;
            }
            else
            {
                hr = ILS_E_NO_INTERFACE;
            };
        };
    }
    else
    {
        hr = ILS_E_NO_INTERFACE;
    };

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\localver.h ===
/* Version resource specific to uls.dll */

#define VER_DESCRIPTION_STR  "User Location Services Component Module\0"
#define VER_INTERNALNAME_STR "uls\0"
#define VER_ORIGNAME_STR     "uls.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\localusr.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       localusr.cpp
//  Content:    This file contains the LocalUser object.
//  History:
//      Wed 17-Apr-1996 11:13:54  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#include "ulsp.h"
#include "localusr.h"
#include "localprt.h"
#include "callback.h"
#include "attribs.h"
#include "culs.h"

#define DEFAULT_COUNTRY _T("-")

#ifdef OLD
//****************************************************************************
// Registry keys and values - defined in ULSREG.H
//****************************************************************************

#define REGSTR_ILS_CLIENT_KEY           ILS_REGISTRY TEXT("\\") ILS_REGFLD_CLIENT
#define REGSTR_ILS_FIRSTNAME_VALUE      ILS_REGKEY_FIRST_NAME
#define REGSTR_ILS_LASTNAME_VALUE       ILS_REGKEY_LAST_NAME
#define REGSTR_ILS_EMAIL_VALUE          ILS_REGKEY_EMAIL_NAME
#define REGSTR_ILS_CITY_VALUE           ILS_REGKEY_CITY
#define REGSTR_ILS_COUNTRY_VALUE        ILS_REGKEY_COUNTRY
#define REGSTR_ILS_COMMENT_VALUE        ILS_REGKEY_COMMENTS
#define REGSTR_ILS_FLAGS_VALUE          ILS_REGKEY_DONT_PUBLISH

#endif //OLD


#ifdef TEST
_cdecl main()
{
    return (0);
}
#endif //TEST

//****************************************************************************
// HRESULT
// OnNotifyRegisterResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
OnNotifyRegisterResult (IUnknown *pUnk, void *pv)
{
    PSRINFO psri = (PSRINFO)pv;

    ((IIlsUserNotify*)pUnk)->RegisterResult(psri->uReqID, psri->hResult);
    return S_OK;
}

//****************************************************************************
// HRESULT
// OnNotifyUpdateUserResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
OnNotifyUpdateResult (IUnknown *pUnk, void *pv)
{
    PSRINFO psri = (PSRINFO)pv;

    ((IIlsUserNotify*)pUnk)->UpdateResult(psri->uReqID, psri->hResult);
    return S_OK;
}

//****************************************************************************
// HRESULT
// OnNotifyProtocolChangeResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
OnNotifyProtocolChangeResult (IUnknown *pUnk, void *pv)
{
    PSRINFO psri = (PSRINFO)pv;

    ((IIlsUserNotify*)pUnk)->ProtocolChangeResult(psri->uReqID,
                                                      psri->hResult);
    return S_OK;
}

//****************************************************************************
// HRESULT
// OnNotifyGetProtocolResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
OnNotifyGetProtocolResult (IUnknown *pUnk, void *pv)
{
    POBJRINFO pobjri = (POBJRINFO)pv;

    ((IIlsUserNotify*)pUnk)->GetProtocolResult(pobjri->uReqID,
                                                      (IIlsProtocol *)pobjri->pv,
                                                      pobjri->hResult);
    return S_OK;
}

//****************************************************************************
// HRESULT
// OnNotifyEnumProtocolsResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
OnNotifyEnumProtocolsResult (IUnknown *pUnk, void *pv)
{
    CEnumNames  *penum  = NULL;
    PENUMRINFO  peri    = (PENUMRINFO)pv;
    HRESULT     hr      = peri->hResult;

    if (SUCCEEDED(hr))
    {
        penum = new CEnumNames;

        if (penum != NULL)
        {
            hr = penum->Init((LPTSTR)peri->pv, peri->cItems);

            if (SUCCEEDED(hr))
            {
                penum->AddRef();
            }
            else
            {
                delete penum;
                penum = NULL;
            };
        }
        else
        {
            hr = ILS_E_MEMORY;
        };
    };

    // Notify the sink object
    //
    ((IIlsUserNotify*)pUnk)->EnumProtocolsResult(peri->uReqID,
                                                        penum != NULL ? 
                                                        (IEnumIlsNames *)penum :
                                                        NULL,
                                                        hr);

    if (penum != NULL)
    {
        penum->Release();
    };
    return hr;
}

#ifdef MAYBE
//****************************************************************************
// HRESULT
// OnNotifyStateChanged ( IUnknown *pUnk, LONG State, VOID *pv )
//
// History:
//  Thu 07-Nov-1996 13:05:00  -by-  Chu, Lon-Chan [lonchanc]
// Created.
//****************************************************************************

HRESULT
CIlsUser::OnNotifyStateChanged ( IUnknown *pUnk, LONG State, BSTR bstrServerName, BOOL fPrimary )
{
    // If the server object does not exist, not registered
    //
    if (m_pServer == NULL)
        return NOERROR;

	// Set server internal state
	//
	SetULSState ((ULSSVRSTATE) State);

	// Notify the app to logoff and re-logon
	// This app must NOT pop up an UI upon receiving this
	//
    ((IIlsUserNotify *) pUnk)->StateChanged (fPrimary, bstrServerName);

    return NOERROR;
}

#endif //MAYBE

HRESULT
OnNotifyStateChanged_UI_NoSuchObject ( IUnknown *pUnk, VOID *pv )
{
	return ((IIlsUserNotify *)pUnk)->StateChanged (TRUE, (BSTR) pv);
}

HRESULT
OnNotifyStateChanged_NoUI_NoSuchObject ( IUnknown *pUnk, VOID *pv )
{
	return ((IIlsUserNotify *)pUnk)->StateChanged (FALSE, (BSTR) pv);
}

HRESULT
OnNotifyStateChanged_UI_NetworkDown ( IUnknown *pUnk, VOID *pv )
{
	return ((IIlsUserNotify *)pUnk)->StateChanged (TRUE, (BSTR) pv);
}

HRESULT
OnNotifyStateChanged_NoUI_NetworkDown ( IUnknown *pUnk, VOID *pv )
{
	return ((IIlsUserNotify *)pUnk)->StateChanged (FALSE, (BSTR) pv);
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::ProtocolChangeResult ( IIlsProtocol *pProtocol, ULONG uReqID, HRESULT hResult,
//                                  APP_CHANGE_PROT uCmd)
//
//****************************************************************************

STDMETHODIMP
CIlsUser::ProtocolChangeResult ( IIlsProtocol *pProtocol, ULONG uReqID, HRESULT hResult,
                                 APP_CHANGE_PROT uCmd)
{
    SRINFO sri;

    // If the server accepts the changes, modify the local information
    //
    if (FAILED (hResult))
    {
        // Update based on the command.
        //
        switch(uCmd)
        {
            case ILS_APP_ADD_PROT:
				m_ProtList.Remove ((CLocalProt *) pProtocol);
				pProtocol->Release (); // AddRef by RegisterLocalProtocol
                break;

            case ILS_APP_REMOVE_PROT:
            	// Release already by UnregisterLocalProtocol
                break;

            default:
                ASSERT(0);
                break;
        };
    }


    if (uReqID) {
        // Notify the sink object
        //
        sri.uReqID = uReqID;
        sri.hResult = hResult;
        hResult = NotifySink((void *)&sri, OnNotifyProtocolChangeResult);
    }

#ifdef DEBUG
    DPRINTF (TEXT("CIlsUser--current Protocols********************\r\n"));
    DPRINTF (TEXT("\r\n*************************************************"));
#endif // DEBUG;

    return hResult;
}

//****************************************************************************
// CIlsUser::CIlsUser (HANDLE hMutex)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CIlsUser::CIlsUser ()
:
 m_cRef (0),
// user
 m_fReadonly (FALSE),
 m_uModify (LU_MOD_NONE),
 m_cLock (0),
 m_szID (NULL),
 m_szFirstName (NULL),
 m_szLastName (NULL),
 m_szEMailName (NULL),
 m_szCityName (NULL),
 m_szCountryName (NULL),
 m_szComment (NULL),
 m_dwFlags (1), // default is visible
 m_szIPAddr (NULL),
 m_szAppName (NULL),
 m_szMimeType (NULL),
 m_pIlsServer (NULL),
 m_pConnPt (NULL),
// server
 m_uState (ULSSVR_INVALID),
 m_hLdapUser (NULL),
 m_pep (NULL),
 m_uReqID (0),
 m_uLastMsgID (0)
{
    m_guid = GUID_NULL;
	m_ExtendedAttrs.SetAccessType (ILS_ATTRTYPE_NAME_VALUE);
		// m_szCountryName can't be a NULL string... see notes on NetMeeting 3.0 Bug 1643 for the reason why...
	m_szCountryName = static_cast<LPTSTR>(MemAlloc( lstrlen( DEFAULT_COUNTRY ) + sizeof(TCHAR) ));
	lstrcpy( m_szCountryName, DEFAULT_COUNTRY );

}

//****************************************************************************
// CIlsUser::~CIlsUser (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CIlsUser::~CIlsUser (void)
{
    /* ------ server ------ */

    // Unregister everything, including protocols
    //
    InternalCleanupRegistration(FALSE);

    // We expect someone explicitly unregister this
    //
    ASSERT ((m_uState == ULSSVR_INVALID) || (m_uState == ULSSVR_INIT));
    ASSERT (m_hLdapUser == NULL);
    ASSERT (m_pep == NULL);
    ASSERT (m_uReqID == 0);
    ASSERT (m_uLastMsgID == 0);

    /* ------ user ------ */

    ::MemFree (m_szID);
    ::MemFree (m_szFirstName);
    ::MemFree (m_szLastName);
    ::MemFree (m_szEMailName);
    ::MemFree (m_szCityName);
    ::MemFree (m_szCountryName);
    ::MemFree (m_szComment);
    ::MemFree (m_szIPAddr);

    // Release the protocol objects
    //
    CLocalProt *plp = NULL;
    HANDLE hEnum = NULL;
    m_ProtList.Enumerate(&hEnum);
    while(m_ProtList.Next (&hEnum, (PVOID *)&plp) == NOERROR)
    {
        plp->Release(); // AddRef by RegisterLocalProtocol or UpdateProtocol
    }
    m_ProtList.Flush();

    // Release the buffer resources
    //
    ::MemFree (m_szAppName);
    ::MemFree (m_szMimeType);

    // Release the connection point
    //
    if (m_pConnPt != NULL)
    {
        m_pConnPt->ContainerReleased();
        ((IConnectionPoint*)m_pConnPt)->Release();
    };

	// Free server object
	//
	if (m_pIlsServer != NULL)
		m_pIlsServer->Release ();
}


//****************************************************************************
// STDMETHODIMP
// CIlsUser::Clone
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP CIlsUser::
Clone ( IIlsUser **ppUser )
{
	if (ppUser == NULL)
		return ILS_E_POINTER;

	// Create a new user object
	//
	CIlsUser *p = new CIlsUser;
	if (p == NULL)
		return ILS_E_MEMORY;

    // Snap-shot the user information now
	//
	LDAP_CLIENTINFO	*pci = NULL;
	HRESULT hr = InternalGetUserInfo (TRUE, &pci, LU_MOD_ALL);
	if (SUCCEEDED (hr))
	{
		// Fake the size to make it consistent with what Init() wants
		//
		pci->uSize = sizeof (*pci);

		// Unpack the user information
		//
		hr = p->Init (NULL, pci);
	}

	if (FAILED (hr))
	{
		delete p;
		p = NULL;
	}
	else
	{
		p->AddRef ();
		p->m_fReadonly = FALSE;
		p->m_uState = ULSSVR_INIT;
	}
	*ppUser = (IIlsUser *) p;

	return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::Init (BSTR bstrUserID, BSTR bstrAppName)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::Init (BSTR bstrUserID, BSTR bstrAppName)
{
    HRESULT hr;
    ASSERT(!m_szID && !m_szAppName);

    if (!bstrUserID || !bstrAppName) {

        return (ILS_E_PARAMETER);

    }

    hr = BSTR_to_LPTSTR(&m_szID, bstrUserID);

    if (FAILED(hr)) {

        m_szID = NULL;  // set it to NULL for safety
        return (hr);

    }

    hr = BSTR_to_LPTSTR(&m_szAppName, bstrAppName);
    
    if (SUCCEEDED(hr))
    {
        // Make the connection point
        //
        m_pConnPt = new CConnectionPoint (&IID_IIlsUserNotify,
                                        (IConnectionPointContainer *)this);
        if (m_pConnPt != NULL)
        {
            ((IConnectionPoint*)m_pConnPt)->AddRef();
            hr = NOERROR;

			m_ExtendedAttrs.SetAccessType (ILS_ATTRTYPE_NAME_VALUE);
        }
        else
        {
            hr = ILS_E_MEMORY;
        };
    };

    if (FAILED(hr)) {

        ::MemFree (m_szID);
        ::MemFree (m_szAppName);
        m_szID = m_szAppName = NULL;

        return hr;
    }

    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::Init (LPTSTR szServerName, PLDAP_CLIENTINFO *pui)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::Init (CIlsServer *pIlsServer, PLDAP_CLIENTINFO pui)
{
    // Validate parameter
    //
    if ((pui->uSize != sizeof(*pui))    ||
        (pui->uOffsetCN       == 0)     /*||
        (pui->uOffsetAppName  == 0)*/
        )
    {
        return ILS_E_PARAMETER;
    };

    // Remember the server if necessary
    //
    if (pIlsServer != NULL)
    {
	    pIlsServer->AddRef ();
	}
	m_pIlsServer = pIlsServer;

	// Allocate strings
	//
	BOOL fSuccess = SUCCEEDED (SetOffsetString (&m_szID, (BYTE *) pui, pui->uOffsetCN)) && (m_szID != NULL);
    fSuccess &= SUCCEEDED (SetOffsetString (&m_szAppName, (BYTE *) pui, pui->uOffsetAppName));
    fSuccess &= SUCCEEDED (SetOffsetString (&m_szFirstName, (BYTE *) pui, pui->uOffsetFirstName));
    fSuccess &= SUCCEEDED (SetOffsetString (&m_szLastName, (BYTE *) pui, pui->uOffsetLastName));
    fSuccess &= SUCCEEDED (SetOffsetString (&m_szEMailName, (BYTE *) pui, pui->uOffsetEMailName));
    fSuccess &= SUCCEEDED (SetOffsetString (&m_szCityName, (BYTE *) pui, pui->uOffsetCityName));
    fSuccess &= SUCCEEDED (SetOffsetString (&m_szCountryName, (BYTE *) pui, pui->uOffsetCountryName));
    fSuccess &= SUCCEEDED (SetOffsetString (&m_szComment, (BYTE *) pui, pui->uOffsetComment));
    fSuccess &= SUCCEEDED (SetOffsetString (&m_szIPAddr, (BYTE *) pui, pui->uOffsetIPAddress));
	fSuccess &= SUCCEEDED (SetOffsetString (&m_szMimeType, (BYTE *) pui, pui->uOffsetAppMimeType));

    HRESULT hr = fSuccess ? S_OK : ILS_E_MEMORY;
	if (SUCCEEDED(hr))
	{
		// Set non-allocation data
		//
        m_dwFlags = pui->dwFlags;
        m_guid = pui->AppGuid;

		// Set extended attributes
		//
		m_ExtendedAttrs.SetAccessType (ILS_ATTRTYPE_NAME_VALUE);
        if (pui->cAttrsReturned != 0)
        {
            hr = m_ExtendedAttrs.SetAttributePairs((LPTSTR)(((PBYTE)pui)+pui->uOffsetAttrsReturned),
                      pui->cAttrsReturned);
        }
    }

    if (SUCCEEDED(hr))
    {
        // Make the connection point
        //
        m_pConnPt = new CConnectionPoint (&IID_IIlsUserNotify,
                                        (IConnectionPointContainer *)this);
        if (m_pConnPt != NULL)
        {
            ((IConnectionPoint*)m_pConnPt)->AddRef();
            hr = NOERROR;

            m_fReadonly = TRUE;

        }
        else
        {
            hr = ILS_E_MEMORY;
        };
    };

    // cleanup is done in destructor

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::IsWritable (BOOL *pfWriteable)
//
//****************************************************************************
STDMETHODIMP
CIlsUser::IsWritable(BOOL *pfWriteable)
{
    HRESULT hr;

    if (pfWriteable != NULL)
    {
        *pfWriteable = !m_fReadonly;
		hr = S_OK;
    }
    else
    {
    	hr = ILS_E_POINTER;
    }
    return hr;
}


//****************************************************************************
// STDMETHODIMP
// CIlsUser::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::QueryInterface (REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (riid == IID_IIlsUser || riid == IID_IUnknown)
    {
        *ppv = (IIlsUser *) this;
    }
    else
    {
        if (riid == IID_IConnectionPointContainer)
        {
            *ppv = (IConnectionPointContainer *) this;
        };
    }

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        return ILS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CIlsUser::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:14:17  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CIlsUser::AddRef (void)
{
    DllLock();

	MyDebugMsg ((DM_REFCOUNT, "CIlsUser::AddRef: ref=%ld\r\n", m_cRef));
	::InterlockedIncrement (&m_cRef);
    return (ULONG) m_cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CIlsUser::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:14:26  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CIlsUser::Release (void)
{
    DllRelease();

	ASSERT (m_cRef > 0);

	MyDebugMsg ((DM_REFCOUNT, "CIlsUser::Release: ref=%ld\r\n", m_cRef));
	if (::InterlockedDecrement (&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return (ULONG) m_cRef;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::GetStandardAttribute (ILS_STD_ATTR_NAME   stdAttr, BSTR *pbstrStdAttr)
//
// History:
//  1-16-97 Shishir Pardikar
// Created.
//****************************************************************************
STDMETHODIMP
CIlsUser::GetStandardAttribute(
    ILS_STD_ATTR_NAME   stdAttr,
    BSTR                *pbstrStdAttr
)
{
    LPTSTR lpszAttr = NULL;
    BOOL    fValid = TRUE;
    HRESULT hr;

    if (pbstrStdAttr == NULL) {

        return ILS_E_POINTER;

    }
    switch(stdAttr) {

    case ILS_STDATTR_USER_ID:
        lpszAttr = m_szID;
        break;
    case ILS_STDATTR_APP_NAME:
        lpszAttr = m_szAppName;
        break;
    case ILS_STDATTR_IP_ADDRESS:
        lpszAttr = m_szIPAddr;
        break;
    case ILS_STDATTR_EMAIL_NAME:
        lpszAttr = m_szEMailName;
        break;

	case ILS_STDATTR_FIRST_NAME:
        lpszAttr = m_szFirstName;
        break;

	case ILS_STDATTR_LAST_NAME:
        lpszAttr = m_szLastName;
        break;

	case ILS_STDATTR_CITY_NAME:
        lpszAttr = m_szCityName;
        break;

	case ILS_STDATTR_COUNTRY_NAME:
        lpszAttr = m_szCountryName;
        break;

	case ILS_STDATTR_COMMENT:
        lpszAttr = m_szComment;
        break;

    case ILS_STDATTR_APP_MIME_TYPE:
        lpszAttr = m_szMimeType;
        break;

    default:
        fValid = FALSE;
        break;
    }

    if (fValid) {
        if (lpszAttr){

            hr = LPTSTR_to_BSTR(pbstrStdAttr, lpszAttr);
        }
        else {

            *pbstrStdAttr = NULL;
            hr = NOERROR;

        }
    }
    else {

        hr = ILS_E_PARAMETER;

    }

    return (hr);
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::SetStandardAttribute (ILS_STD_ATTR_NAME   stdAttr, BSTR bstrStdAttr)
//
// History:
//  1-16-97 Shishir Pardikar
// Created.
//****************************************************************************
STDMETHODIMP
CIlsUser::SetStandardAttribute(
    ILS_STD_ATTR_NAME   stdAttr,
    BSTR                bstrStdAttr
)
{
    LPTSTR *ppszAttr = NULL, pszNewAttr;
    BOOL    fValid = TRUE;
    ULONG   ulModBit = 0;
    HRESULT hr;

	// It is ok to have a null bstrStdAttr
	//

    // Make sure this is not a read-only object
    //
    if (m_fReadonly)
       return ILS_E_ACCESS_DENIED;

    switch(stdAttr) {

    case ILS_STDATTR_IP_ADDRESS:
        ppszAttr = &m_szIPAddr;
        ulModBit = LU_MOD_IP_ADDRESS;
        break;

    case ILS_STDATTR_EMAIL_NAME:
        ppszAttr = &m_szEMailName;
        ulModBit = LU_MOD_EMAIL;
        break;

	case ILS_STDATTR_FIRST_NAME:
        ppszAttr = &m_szFirstName;
        ulModBit = LU_MOD_FIRSTNAME;
        break;

	case ILS_STDATTR_LAST_NAME:
        ppszAttr = &m_szLastName;
        ulModBit = LU_MOD_LASTNAME;
        break;

	case ILS_STDATTR_CITY_NAME:
        ppszAttr = &m_szCityName;
        ulModBit = LU_MOD_CITY;
        break;

	case ILS_STDATTR_COUNTRY_NAME:
        ppszAttr = &m_szCountryName;
        ulModBit = LU_MOD_COUNTRY;
        break;

	case ILS_STDATTR_COMMENT:
        ppszAttr = &m_szComment;
        ulModBit = LU_MOD_COMMENT;
        break;

    case ILS_STDATTR_APP_MIME_TYPE:
        ppszAttr = &m_szMimeType;
        ulModBit = LU_MOD_MIME;
        break;

    default:
        fValid = FALSE;
        break;
    }

    if (fValid) {
		pszNewAttr = NULL;
		if (bstrStdAttr == NULL || *bstrStdAttr == L'\0')
		{
			// pszNewAttr is null now
			//
			hr = S_OK;
		}
		else
		{
			// Duplicate the string
			//
			hr = BSTR_to_LPTSTR (&pszNewAttr, bstrStdAttr);
		}

        if (SUCCEEDED(hr))
        {
            ::MemFree (*ppszAttr);
            *ppszAttr = pszNewAttr;
            m_uModify |= ulModBit;
        }
    }
    else {

        hr = ILS_E_PARAMETER;

    }

    return (hr);
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::GetVisible ( DWORD *pfVisible )
//
// History:
//  Tue 05-Nov-1996 10:30:00  -by-  Chu, Lon-Chan [lonchanc]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::GetVisible ( DWORD *pfVisible )
{
	HRESULT hr = ILS_E_POINTER;
    if (pfVisible != NULL)
    {
	    *pfVisible = m_dwFlags;
	    hr = S_OK;
	}
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::SetVisible ( DWORD fVisible )
//
// History:
//  Tue 05-Nov-1996 10:30:00  -by-  Chu, Lon-Chan [lonchanc]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::SetVisible ( DWORD fVisible )
{
    // Make sure this is not a read-only object
    //
    if (m_fReadonly)
       return ILS_E_ACCESS_DENIED;

    m_dwFlags = fVisible;
    m_uModify |= LU_MOD_FLAGS;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::GetGuid ( GUID *pGuid )
//
// History:
//  Tue 05-Nov-1996 10:30:00  -by-  Chu, Lon-Chan [lonchanc]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::GetGuid ( GUID *pGuid )
{
	HRESULT hr = ILS_E_POINTER;
	if (pGuid != NULL)
	{
		*pGuid = m_guid;
		hr = S_OK;
	}
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::SetGuid ( GUID *pGuid )
//
// History:
//  Tue 05-Nov-1996 10:30:00  -by-  Chu, Lon-Chan [lonchanc]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::SetGuid ( GUID *pGuid )
{
    // Make sure this is not a read-only object
    //
    if (m_fReadonly)
       return ILS_E_ACCESS_DENIED;

	HRESULT hr = ILS_E_POINTER;
	if (pGuid != NULL)
	{
	    m_guid = *pGuid;
	    m_uModify |= LU_MOD_GUID;
	    hr = S_OK;
	}
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::InternalGetUserInfo (BOOL fAddNew, PLDAP_CLIENTINFO *ppUserInfo, ULONG uFields)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::InternalGetUserInfo (BOOL fAddNew, PLDAP_CLIENTINFO *ppUserInfo, ULONG uFields)
{
    PLDAP_CLIENTINFO pui;
    ULONG cFName,
          cLName,
          cEName,
          cCity,
          cCountry,
          cComment;
    ULONG cName, cAppName, cMime;
    LPTSTR szAttrs;
    ULONG uOffsetDstAnyAttrs;
    ULONG cAttrs, cbAttrs;
    HRESULT hr;
	ULONG cchIPAddr;

    // Should not call this guy if nothing has been updated
    //
    ASSERT(uFields);

    // Assume failure
    //
    *ppUserInfo = NULL;

    // Calculate the buffer size
    //
    ASSERT(m_szID && m_szAppName);

    cName  = lstrlen(m_szID)+1;
    cAppName = lstrlen(m_szAppName)+1;

    cFName = (((uFields & LU_MOD_FIRSTNAME) && m_szFirstName) ? lstrlen(m_szFirstName)+1    : 0);
    cLName = (((uFields & LU_MOD_LASTNAME) && m_szLastName) ? lstrlen(m_szLastName)+1     : 0);
    cEName = (((uFields & LU_MOD_EMAIL)&& m_szEMailName) ? lstrlen(m_szEMailName)+1    : 0);
    cCity  = (((uFields & LU_MOD_CITY)&& m_szCityName)   ? lstrlen(m_szCityName)+1     : 0);
    cCountry=(((uFields & LU_MOD_COUNTRY)&& m_szCountryName) ? lstrlen(m_szCountryName)+1  : 0);
    cComment=(((uFields & LU_MOD_COMMENT)&& m_szComment) ? lstrlen(m_szComment)+1      : 0);
    cMime =  (((uFields & LU_MOD_MIME)&&m_szMimeType) ? lstrlen(m_szMimeType)+1       : 0);

	cchIPAddr = (((uFields & LU_MOD_IP_ADDRESS) && m_szIPAddr != NULL) ? lstrlen(m_szIPAddr)+1       : 0);

    if (uFields & LU_MOD_ATTRIB) {    
        // Get the attribute pairs
        //
        hr = m_ExtendedAttrs.GetAttributePairs(&szAttrs, &cAttrs, &cbAttrs);
        if (FAILED(hr))
        {
            return hr;
        };
    }
    else {
        cAttrs = 0;
        cbAttrs = 0;
        szAttrs = NULL;
    }
    uOffsetDstAnyAttrs = 0;

    // Allocate the buffer
    //
    ULONG cbTotalSize = sizeof (LDAP_CLIENTINFO) +
                        (cName + cAppName + cFName + cLName + cEName + cchIPAddr +
                         cCity + cCountry + cComment + cMime+cbAttrs) * sizeof (TCHAR);
    pui = (PLDAP_CLIENTINFO) ::MemAlloc (cbTotalSize);
    if (pui == NULL)
    {
        hr = ILS_E_MEMORY;
        goto bailout;
    };

    // Fill the structure content
    //
    pui->uSize              = cbTotalSize;
    pui->uOffsetCN          = sizeof(*pui);
    pui->uOffsetAppName     = pui->uOffsetCN + (cName*sizeof(TCHAR));
    pui->uOffsetFirstName   = pui->uOffsetAppName + (cAppName*sizeof(TCHAR));
    pui->uOffsetLastName    = pui->uOffsetFirstName + (cFName*sizeof(TCHAR));
    pui->uOffsetEMailName   = pui->uOffsetLastName  + (cLName*sizeof(TCHAR));
    pui->uOffsetCityName    = pui->uOffsetEMailName + (cEName*sizeof(TCHAR));
    pui->uOffsetCountryName = pui->uOffsetCityName  + (cCity*sizeof(TCHAR));
    pui->uOffsetComment     = pui->uOffsetCountryName + (cCountry*sizeof(TCHAR));
    pui->uOffsetIPAddress   = pui->uOffsetComment + (cComment * sizeof (TCHAR));
    pui->uOffsetAppMimeType = pui->uOffsetIPAddress + (cchIPAddr * sizeof(TCHAR));
    pui->dwFlags            = m_dwFlags;
    pui->AppGuid            = m_guid;

	// Fill in extended attributes
	//
    uOffsetDstAnyAttrs = (cAttrs != 0) ?
                         pui->uOffsetAppMimeType  + (cMime*sizeof(TCHAR)) :
                         0;
    if (fAddNew)
    {
        pui->cAttrsToAdd        = cAttrs;
        pui->uOffsetAttrsToAdd  = uOffsetDstAnyAttrs;
    }
    else
    {
        pui->cAttrsToModify        = cAttrs;
        pui->uOffsetAttrsToModify  = uOffsetDstAnyAttrs;
    }

    // Copy the user information
    //
    lstrcpy((LPTSTR)(((PBYTE)pui)+pui->uOffsetCN), m_szID);
    lstrcpy((LPTSTR)(((PBYTE)pui)+pui->uOffsetAppName), m_szAppName);

    if ((uFields & LU_MOD_FIRSTNAME)&&m_szFirstName)
    {
        lstrcpy((LPTSTR)(((PBYTE)pui)+pui->uOffsetFirstName), m_szFirstName);
    }
    else
    {
        pui->uOffsetFirstName = 0;
    };

    if ((uFields & LU_MOD_LASTNAME)&&m_szLastName)
    {
        lstrcpy((LPTSTR)(((PBYTE)pui)+pui->uOffsetLastName), m_szLastName);
    }
    else
    {
        pui->uOffsetLastName = 0;
    };

    if ((uFields & LU_MOD_EMAIL)&&m_szEMailName)
    {
        lstrcpy((LPTSTR)(((PBYTE)pui)+pui->uOffsetEMailName), m_szEMailName);
    }
    else
    {
        pui->uOffsetEMailName = 0;
    };

    if ((uFields & LU_MOD_CITY)&&m_szCityName)
    {
        lstrcpy((LPTSTR)(((PBYTE)pui)+pui->uOffsetCityName), m_szCityName);
    }
    else
    {
        pui->uOffsetCityName = 0;
    };

    if ((uFields & LU_MOD_COUNTRY)&&m_szCountryName)
    {
        lstrcpy((LPTSTR)(((PBYTE)pui)+pui->uOffsetCountryName), m_szCountryName);
    }
    else
    {
        pui->uOffsetCountryName = 0;
    };

    if ((uFields & LU_MOD_COMMENT)&&m_szComment)
    {
        lstrcpy((LPTSTR)(((PBYTE)pui)+pui->uOffsetComment), m_szComment);
    }
    else
    {
        pui->uOffsetComment = 0;
    };

    if ((uFields & LU_MOD_MIME)&&m_szMimeType)
    {
        lstrcpy((LPTSTR)(((PBYTE)pui)+pui->uOffsetAppMimeType), m_szMimeType);
    }
    else
    {
        pui->uOffsetAppMimeType = 0;
    }

    if ((uFields & LU_MOD_IP_ADDRESS) && m_szIPAddr != NULL)
    {
        lstrcpy((LPTSTR)(((PBYTE)pui)+pui->uOffsetIPAddress), m_szIPAddr);
    }
    else
    {
        pui->uOffsetIPAddress = 0;
    }

    if (cAttrs)
    {
        CopyMemory(((PBYTE)pui) + uOffsetDstAnyAttrs, szAttrs, cbAttrs);
    };

    // Return the structure
    //
    *ppUserInfo = pui;


    hr = NOERROR;

bailout:

    if (szAttrs != NULL)
    {
        ::MemFree (szAttrs);
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::Register (BSTR bstrServerName, ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP CIlsUser::
Register (
	IIlsServer		*pIlsServer,
	ULONG			*puReqID)
{
    HRESULT hr;

	// Make sure it is not registered
	//
	if (GetULSState () != ILS_UNREGISTERED)
		return ILS_E_ALREADY_REGISTERED;

    // Validate parameter
    //
    if (::MyIsBadServer (pIlsServer) || puReqID == NULL)
        return ILS_E_POINTER;

    // Make sure this is not a read-only object
    //
    if (m_fReadonly)
       return ILS_E_ACCESS_DENIED;

	// Clone the server object
	//
	pIlsServer = ((CIlsServer *) pIlsServer)->Clone ();
	if (pIlsServer == NULL)
		return ILS_E_MEMORY;

	// Free the old server object if necessary
	//
	if (m_pIlsServer != NULL)
		m_pIlsServer->Release ();

	// Keep the new server object
	//
	m_pIlsServer = (CIlsServer *) pIlsServer;

	// Initialize the state
	//
	m_uState = ULSSVR_INIT;

    // Prepare the asynchronous request
    //
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    ri.uReqType = WM_ILS_LOCAL_REGISTER;
    ri.uMsgID = 0;

	ReqInfo_SetUser (&ri, this);

	// Enter the request
	//
    hr = g_pReqMgr->NewRequest(&ri);
    if (SUCCEEDED(hr))
    {
        // Make sure the objects do not disappear before we get the response
        //
        this->AddRef();

        // Register the client
        //
        hr = InternalRegister (ri.uReqID);
        if (SUCCEEDED(hr))
        {
            Lock();
            *puReqID = ri.uReqID;
        }
        else
        {
            // Clean up the async pending request
            //
            this->Release();
            g_pReqMgr->RequestDone(&ri);
        };
    };
    
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::RegisterResult (ULONG uReqID, HRESULT hResult)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::RegisterResult (ULONG uReqID, HRESULT hResult)
{
    SRINFO sri;

    Unlock();

    // Notify the sink object
    //
    sri.uReqID = uReqID;
    sri.hResult = hResult;
    if (hResult == S_OK)
    {
    	m_uModify = LU_MOD_NONE;
    }
    hResult = NotifySink((void *)&sri, OnNotifyRegisterResult);
    return hResult;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::Unregister (BSTR bstrServerName, ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP CIlsUser::
Unregister ( ULONG *puReqID )
{
    HRESULT hr;

	// Make sure it is registered somehow (network down, need relogon, or registered)
	//
	if (GetULSState () == ILS_UNREGISTERED)
		return ILS_E_NOT_REGISTERED;

    // Make sure this is not a read-only object
    //
    if (m_fReadonly)
       return ILS_E_ACCESS_DENIED;

    // If puReqID is null, do it synchronously
    //
    if (puReqID == NULL)
    {
		hr = InternalCleanupRegistration (TRUE);
	}
	else
	{
        // Prepare the asynchronous request
        //
	    COM_REQ_INFO ri;
	    ReqInfo_Init (&ri);

        ri.uReqType = WM_ILS_LOCAL_UNREGISTER;
        ri.uMsgID = 0;

		ReqInfo_SetUser (&ri, this);

		// Enter new request
		//
        hr = g_pReqMgr->NewRequest(&ri);
        if (SUCCEEDED(hr))
        {
            // Make sure the objects do not disappear before we get the response
            //
            this->AddRef();

            // Unregister the application
            //
            hr = InternalUnregister (ri.uReqID);
            if (SUCCEEDED(hr))
            {
                Lock();
                *puReqID = ri.uReqID;
            }
            else
            {
                // Clean up the async pending request
                //
                this->Release();
                g_pReqMgr->RequestDone(&ri);
            };
        };
	}

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::UnregisterResult (ULONG uReqID, HRESULT hResult)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::UnregisterResult (ULONG uReqID, HRESULT hResult)
{
    SRINFO sri;

    Unlock();

    // Notify the sink object
    //
    sri.uReqID = uReqID;
    sri.hResult = hResult;
    hResult = NotifySink((void *)&sri, OnNotifyRegisterResult);
    return hResult;
}


//****************************************************************************
// STDMETHODIMP
// CIlsUser::Update(ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP CIlsUser::
Update ( ULONG *puReqID )
{
    PLDAP_CLIENTINFO pUserInfo;
    LDAP_ASYNCINFO ldai; 
    ULONG          uReqID;
    HRESULT        hr;

	if (GetULSState () != ILS_REGISTERED)
		return ILS_E_NOT_REGISTERED;

	if (puReqID == NULL)
		return ILS_E_POINTER;

	// We already registered with the server.
    // Get the user information
    //
    hr = (m_uModify == LU_MOD_NONE) ?
         S_FALSE :
         InternalGetUserInfo (FALSE, &pUserInfo, m_uModify);
    if (hr == NOERROR)
    {
		// Make sure that we do not update User ID and App Name
		//
		pUserInfo->uOffsetCN = INVALID_OFFSET;
		pUserInfo->uOffsetAppName = INVALID_OFFSET;

        // Some fields have been updated, notify the server first
        //
        hr = ::UlsLdap_SetClientInfo (m_hLdapUser, pUserInfo, &ldai);
        ::MemFree (pUserInfo);

        // If updating server was successfully requested, wait for the response
        //
	    COM_REQ_INFO ri;
	    ReqInfo_Init (&ri);

        ri.uReqType =  WM_ILS_SET_CLIENT_INFO;
        ri.uMsgID = ldai.uMsgID;

		ReqInfo_SetUser (&ri, this);

        hr = g_pReqMgr->NewRequest(&ri);

        if (SUCCEEDED(hr))
        {
            // Make sure the objects do not disappear before we get the response
            //
            this->AddRef();

            // Return the request ID
            //
            *puReqID = ri.uReqID;

            Lock();
        };
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::UpdateResult (ULONG uReqID, HRESULT hResult)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::UpdateResult (ULONG uReqID,
                        HRESULT hResult)
{
    SRINFO sri;

    Unlock ();

    // Notify the sink object
    //
    sri.uReqID = uReqID;
    sri.hResult = hResult;
	if (hResult == S_OK)
	{
		m_uModify = LU_MOD_NONE;
	}
    hResult = NotifySink((void *)&sri, OnNotifyUpdateResult);
    return hResult;
}


//****************************************************************************
// STDMETHODIMP
// CIlsUser::GetProtocolHandle (CLocalProt *pLocalProt, PHANDLE phProt)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CIlsUser::
GetProtocolHandle (CLocalProt *pLocalProt, PHANDLE phProt)
{
	ASSERT (pLocalProt != NULL);
	ASSERT (phProt != NULL);

    // Cannot retreive the handle if ULS is locked, i.e. registering something
    //
    if (IsLocked())
        return ILS_E_FAIL;

	/* ------ server ------ */

    if (m_uState != ULSSVR_CONNECT)
        return ILS_E_FAIL;

    // Find the matching protocol
    //
    *phProt = pLocalProt->GetProviderHandle ();
    return S_OK;
}


//****************************************************************************
// STDMETHODIMP
// CIlsUser::RegisterLocalProtocol (BOOL fAddToList, CLocalProt *plp, PLDAP_ASYNCINFO plai)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CIlsUser::
RegisterLocalProtocol ( BOOL fAddToList, CLocalProt *plp, PLDAP_ASYNCINFO plai )
{
	ASSERT (plp != NULL);
	ASSERT (plai != NULL);

	// Let's register the protocol now
	//
    ASSERT (m_hLdapUser != NULL);
    PLDAP_PROTINFO ppi = NULL;
    HRESULT hr = plp->GetProtocolInfo(&ppi);
    if (SUCCEEDED(hr))
    {
        // Remember the protocol to register
        //
        if (fAddToList)
        {
        	plp->AddRef ();
        	hr = m_ProtList.Insert(plp);
        }

        if (SUCCEEDED(hr))
        {
        	HANDLE hProt = NULL;
            hr = ::UlsLdap_RegisterProtocol (m_hLdapUser, ppi, &hProt, plai);
            plp->SetProviderHandle (hProt);
            if (FAILED(hr) && fAddToList)
            {
                m_ProtList.Remove(plp);
            };
        };

        if (FAILED (hr) && fAddToList)
        {
            plp->Release ();
        };
        ::MemFree (ppi);
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::UnregisterLocalProtocol (CLocalProt *plp, PLDAP_ASYNCINFO plai)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CIlsUser::
UnregisterLocalProtocol (CLocalProt *plp, PLDAP_ASYNCINFO plai)
{
	ASSERT (plp != NULL);
	ASSERT (plai != NULL);

    // Cannot retreive the handle if ULS is locked, i.e. registering something
    //
    if (IsLocked())
        return ILS_E_FAIL;

    // Must be registered to perform this operation
    //
    HRESULT hr;
    ILS_STATE uULSState = GetULSState ();
    if (uULSState == ILS_REGISTERED ||
    	uULSState == ILS_REGISTERED_BUT_INVALID ||
    	uULSState == ILS_NETWORK_DOWN)
    {
	    // Search for the protocol
	    //
	    if (m_ProtList.Remove (plp) == S_OK)
	    {
	    	ASSERT (plp != NULL);

	        // Another protocol to unregister
	        //
	        hr = ::UlsLdap_UnRegisterProtocol (plp->GetProviderHandle (), plai);
	        plp->Release (); // AddRef by RegisterLocalProtocol
	    }
	    else
	    {
	        hr = S_FALSE;
	    };
    }
    else
    {
        hr = ILS_E_FAIL;
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::GetState (BSTR bstrServerName, ULSSTATE *puULSState)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP CIlsUser::
GetState ( ILS_STATE *puULSState )
{
    HRESULT hr;

    if (puULSState != NULL)
    {
		*puULSState = GetULSState ();
		hr = S_OK;
    }
    else
    {
    	hr = ILS_E_POINTER;
    }

    return hr;
}


//****************************************************************************
// CEnumUsers::CEnumUsers (void)
//
// History:
//  Wed 17-Apr-1996 11:15:18  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CEnumUsers::CEnumUsers (void)
{
    m_cRef    = 0;
    m_ppu     = NULL;
    m_cUsers  = 0;
    m_iNext   = 0;
    return;
}

//****************************************************************************
// CEnumUsers::~CEnumUsers (void)
//
// History:
//  Wed 17-Apr-1996 11:15:18  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CEnumUsers::~CEnumUsers (void)
{
    ULONG i;

    if (m_ppu != NULL)
    {
        for (i = 0; i < m_cUsers; i++)
        {
            m_ppu[i]->Release();
        };
        ::MemFree (m_ppu);
    };
    return;
}

//****************************************************************************
// STDMETHODIMP
// CEnumUsers::Init (CIlsUser **ppuList, ULONG cUsers)
//
// History:
//  Wed 17-Apr-1996 11:15:25  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumUsers::Init (CIlsUser **ppuList, ULONG cUsers)
{
    HRESULT hr = NOERROR;

    // If no list, do nothing
    //
    if (cUsers != 0)
    {
        ASSERT(ppuList != NULL);

        // Allocate the snapshot buffer
        //
        m_ppu = (CIlsUser **) ::MemAlloc (cUsers*sizeof(CIlsUser *));

        if (m_ppu != NULL)
        {
            ULONG i;

            // Snapshot the object list
            //
            for (i =0; i < cUsers; i++)
            {
                m_ppu[i] = ppuList[i];
                m_ppu[i]->AddRef();
            };
            this->m_cUsers = cUsers;
        }
        else
        {
            hr = ILS_E_MEMORY;
        };
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CEnumUsers::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:15:31  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumUsers::QueryInterface (REFIID riid, void **ppv)
{
    if (riid == IID_IEnumIlsUsers || riid == IID_IUnknown)
    {
        *ppv = (IEnumIlsUsers *) this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return ILS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumUsers::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:15:37  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumUsers::AddRef (void)
{
    DllLock();

	MyDebugMsg ((DM_REFCOUNT, "CEnumUsers::AddRef: ref=%ld\r\n", m_cRef));
	::InterlockedIncrement (&m_cRef);
    return m_cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumUsers::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:15:43  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumUsers::Release (void)
{
    DllRelease();

	ASSERT (m_cRef > 0);

	MyDebugMsg ((DM_REFCOUNT, "CEnumUsers::Release: ref=%ld\r\n", m_cRef));
    if (::InterlockedDecrement (&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

//****************************************************************************
// STDMETHODIMP 
// CEnumUsers::Next (ULONG cUsers, IIlsUser **rgpu, ULONG *pcFetched)
//
// History:
//  Wed 17-Apr-1996 11:15:49  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP 
CEnumUsers::Next (ULONG cUsers, IIlsUser **rgpu, ULONG *pcFetched)
{
    ULONG   cCopied;
    HRESULT hr;

    // Validate the pointer
    //
    if (rgpu == NULL)
        return E_POINTER;

    // Validate the parameters
    //
    if ((cUsers == 0) ||
        ((cUsers > 1) && (pcFetched == NULL)))
        return ILS_E_PARAMETER;

    // Check the enumeration index
    //
    cCopied = 0;

    // Can copy if we still have more attribute names
    //
    while ((cCopied < cUsers) &&
           (m_iNext < this->m_cUsers))
    {
        m_ppu[m_iNext]->AddRef();
        rgpu[cCopied++] = m_ppu[m_iNext++];
    };

    // Determine the returned information based on other parameters
    //
    if (pcFetched != NULL)
    {
        *pcFetched = cCopied;
    };
    return (cUsers == cCopied ? S_OK : S_FALSE);
}

//****************************************************************************
// STDMETHODIMP
// CEnumUsers::Skip (ULONG cUsers)
//
// History:
//  Wed 17-Apr-1996 11:15:56  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumUsers::Skip (ULONG cUsers)
{
    ULONG iNewIndex;

    // Validate the parameters
    //
    if (cUsers == 0) 
        return ILS_E_PARAMETER;

    // Check the enumeration index limit
    //
    iNewIndex = m_iNext+cUsers;
    if (iNewIndex <= this->m_cUsers)
    {
        m_iNext = iNewIndex;
        return S_OK;
    }
    else
    {
        m_iNext = this->m_cUsers;
        return S_FALSE;
    };
}

//****************************************************************************
// STDMETHODIMP
// CEnumUsers::Reset (void)
//
// History:
//  Wed 17-Apr-1996 11:16:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumUsers::Reset (void)
{
    m_iNext = 0;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CEnumUsers::Clone(IEnumIlsUsers **ppEnum)
//
// History:
//  Wed 17-Apr-1996 11:16:11  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumUsers::Clone(IEnumIlsUsers **ppEnum)
{
    CEnumUsers *peu;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return E_POINTER;
    };

    *ppEnum = NULL;

    // Create an enumerator
    //
    peu = new CEnumUsers;
    if (peu == NULL)
        return ILS_E_MEMORY;

    // Clone the information
    //
    hr = peu->Init(m_ppu, m_cUsers);

    if (SUCCEEDED(hr))
    {
        peu->m_iNext = m_iNext;

        // Return the cloned enumerator
        //
        peu->AddRef();
        *ppEnum = peu;
    }
    else
    {
        delete peu;
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::SetExtendedAttributes (IIlsAttributes *pAttributes, ULONG *puReqID)
//
// History:
//****************************************************************************

STDMETHODIMP CIlsUser::
SetExtendedAttribute ( BSTR bstrName, BSTR bstrValue )
{
    // Make sure this is not a read-only object
    //
    if (m_fReadonly)
       return ILS_E_ACCESS_DENIED;

	m_uModify |= LU_MOD_ATTRIB;
	return m_ExtendedAttrs.SetAttribute (bstrName, bstrValue);
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::RemoveExtendedAttributes (IIlsAttributes *pAttributes, ULONG *puReqID)
//
// History:
//****************************************************************************

STDMETHODIMP CIlsUser::
RemoveExtendedAttribute ( BSTR bstrName )
{
    // Make sure this is not a read-only object
    //
    if (m_fReadonly)
       return ILS_E_ACCESS_DENIED;

	m_uModify |= LU_MOD_ATTRIB;
	return m_ExtendedAttrs.SetAttribute (bstrName, NULL);
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::GetExtendedAttributes (IIlsAttributes **pAttributes)
//
//****************************************************************************
STDMETHODIMP CIlsUser::
GetExtendedAttribute ( BSTR bstrName, BSTR *pbstrValue )
{
	return m_ExtendedAttrs.GetAttribute (bstrName, pbstrValue);
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::GetAllExtendedAttributes (IIlsAttributes **pAttributes)
//
//****************************************************************************
STDMETHODIMP CIlsUser::
GetAllExtendedAttributes ( IIlsAttributes **ppAttributes )
{
    if (ppAttributes == NULL)
        return ILS_E_PARAMETER;

    return m_ExtendedAttrs.CloneNameValueAttrib((CAttributes **) ppAttributes);
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::CreateProtocol(
//         BSTR bstrProtocolID,
//         ULONG uPortNumber,
//         BSTR bstrMimeType,
//         IIlsProtocol **ppProtocol)
//****************************************************************************


STDMETHODIMP
CIlsUser::CreateProtocol(
        BSTR bstrProtocolID,
        ULONG uPortNumber,
        BSTR bstrMimeType,
        IIlsProtocol **ppProtocol)
{
    HRESULT hr= NOERROR;
    CLocalProt *pProt;

    if (!ppProtocol) {

        return (ILS_E_POINTER);

    }    

    *ppProtocol = NULL;

    pProt = new CLocalProt;

    if (!pProt) {

        return ILS_E_MEMORY;

    }

    hr = pProt->Init(bstrProtocolID, uPortNumber, bstrMimeType);

    if (SUCCEEDED(hr)) {

        pProt->QueryInterface(IID_IIlsProtocol, (void **)ppProtocol);

    }
    else {

        delete pProt;

    }
    return hr;
    
}


//****************************************************************************
// STDMETHODIMP
// CIlsUser::UpdateProtocol (IIlsProtocol *pProtocol,
//                            ULONG *puReqID, APP_CHANGE_PROT uCmd)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CIlsUser::
UpdateProtocol (
	IIlsProtocol		*pProtocol,
	ULONG				*puReqID,
	APP_CHANGE_PROT		uCmd)
{
	ASSERT (uCmd == ILS_APP_ADD_PROT || uCmd == ILS_APP_REMOVE_PROT);

    // Validate parameters
    //
    if (pProtocol == NULL || puReqID == NULL)
        return ILS_E_POINTER;

    HRESULT hr;
    HANDLE  hLdapApp;
    LDAP_ASYNCINFO ldai; 

    // Check whether the protocol exists
    //
    CLocalProt *plp = NULL;
    HANDLE hEnum = NULL;
    m_ProtList.Enumerate(&hEnum);
    while(m_ProtList.Next(&hEnum, (VOID **)&plp) == NOERROR)
    {
    	ASSERT (plp != NULL);
        if (plp->IsSameAs((CLocalProt *)pProtocol) == NOERROR)
        {
            break;
        };

        plp = NULL;
    };

    if (plp != NULL)
    {
        // The protocol exists, fail if this add request
        //
        if (uCmd == ILS_APP_ADD_PROT)
        {
            return ILS_E_PARAMETER;
        };
    }
    else
    {
        // The protocol does not exist, fail if this remove request
        //
        if (uCmd == ILS_APP_REMOVE_PROT)
        {
            return ILS_E_PARAMETER;
        };
    };

	// Make sure we are not in the middle of registration/unregistration.
	//
	if (IsLocked ())
		return ILS_E_FAIL;

    // Must be registered to perform this operation
    //
    ILS_STATE uULSState = GetULSState ();
    if (uULSState == ILS_REGISTERED)
    {
        // Update the server information first
        //
        switch (uCmd)
        {
        case ILS_APP_ADD_PROT:
            hr = RegisterLocalProtocol(TRUE, (CLocalProt*)pProtocol, &ldai);
            break;

        case ILS_APP_REMOVE_PROT:
            hr = UnregisterLocalProtocol((CLocalProt*)pProtocol, &ldai);
            break;
        };
    
        switch (hr)
        {
        case NOERROR:
            //
            // Server starts updating the protocol successfullly
            // We will wait for the server response.
            //
            break;

        default:
            // ULS is locked. Return failure.
            //
            hr = ILS_E_ABORT;
            break; 
        }

        if (SUCCEEDED(hr))
        {
            ASSERT(ldai.uMsgID);

            ULONG   uMsg;
            switch(uCmd)
            {
            case ILS_APP_ADD_PROT:
                uMsg = WM_ILS_REGISTER_PROTOCOL;
                break;

            case ILS_APP_REMOVE_PROT:
                uMsg = WM_ILS_UNREGISTER_PROTOCOL;
                break;

            default:
                ASSERT(0);
                uCmd = ILS_APP_ADD_PROT;
                break;
            };

		    COM_REQ_INFO ri;
		    ReqInfo_Init (&ri);

            ri.uReqType = uMsg;
            ri.uMsgID = ldai.uMsgID;

			ReqInfo_SetUser (&ri, this);
			ReqInfo_SetProtocol (&ri, pProtocol);

            hr = g_pReqMgr->NewRequest(&ri);
            if (SUCCEEDED(hr))
            {
                // Make sure the objects do not disappear before we get the response
                //
                this->AddRef();
                pProtocol->AddRef();

                // Return the request ID
                //
                *puReqID = ri.uReqID;

            }
        }
    }
    else
    {
        // Just make local change
        //
        switch (uCmd)
        {
        case ILS_APP_ADD_PROT:
        	pProtocol->AddRef ();
        	hr = m_ProtList.Insert ((CLocalProt*)pProtocol);
            break;

        case ILS_APP_REMOVE_PROT:
        	ASSERT (plp != NULL && plp->IsSameAs((CLocalProt *)pProtocol) == S_OK);
        	if (plp != NULL)
        	{
	        	hr = m_ProtList.Remove (plp);
	        	if (hr == S_OK)
	        	{
	        		// The protocol object really exists in ths list
	        		//
	        		plp->Release (); // AddRef by above case
	        	}
        	}
            break;
        };

        *puReqID = 0;
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::AddProtocol (IIlsProtocol *pProtocol,
//                         ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP CIlsUser::
AddProtocol (IIlsProtocol *pProtocol, ULONG *puReqID)
{
    return UpdateProtocol (pProtocol, puReqID, ILS_APP_ADD_PROT);
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::RemoveProtocol (IIlsProtocol *pProtocol,
//                            ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP CIlsUser::
RemoveProtocol ( IIlsProtocol *pProtocol, ULONG *puReqID )
{
    return UpdateProtocol (pProtocol, puReqID, ILS_APP_REMOVE_PROT);
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::EnumProtocols (IEnumIlsProtocols **ppEnumProtocol)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
CIlsUser::EnumLocalProtocols (IEnumIlsProtocols **ppEnumProtocol)
{
    CEnumProtocols *pep;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnumProtocol == NULL)
    {
        return ILS_E_POINTER;
    };

    // Assume failure
    //
    *ppEnumProtocol = NULL;

    // Create a peer enumerator
    //
    pep = new CEnumProtocols;

    if (pep != NULL)
    {
        hr = pep->Init(&m_ProtList);

        if (SUCCEEDED(hr))
        {
            // Get the enumerator interface
            //
            pep->AddRef();
            *ppEnumProtocol = pep;
        }
        else
        {
            delete pep;
        };
    }
    else
    {
        hr = ILS_E_MEMORY;
    };
    return hr;
}




//****************************************************************************
// STDMETHODIMP 
// CIlsUser::EnumProtocols(
//                        IIlsFilter     *pFilter,
//                        IIlsAttributes *pAttributes,
//                        IEnumIlsProtocols **pEnumProtocol,
//                        ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::EnumProtocols(
                       IIlsFilter     *pFilter,
                       IIlsAttributes *pAttributes,
                       IEnumIlsProtocols **ppEnumProtocol,
                       ULONG *puReqID)
{
    LDAP_ASYNCINFO ldai; 
    HRESULT hr=ILS_E_FAIL;

    // Validate parameter
    //
    if (puReqID == NULL)
    {
        return ILS_E_POINTER;
    };

    // We do not implement synchronous operation
    //
    if (ppEnumProtocol != NULL)
        return ILS_E_NOT_IMPL;

    if (m_fReadonly)
    {
        hr = ::UlsLdap_EnumProtocols (m_pIlsServer->GetServerInfo (), m_szID, m_szAppName, &ldai);
    }
    else
    {
        return ILS_E_ACCESS_DENIED;
    }

    if (SUCCEEDED(hr))
    {
	    COM_REQ_INFO ri;
	    ReqInfo_Init (&ri);

        // If updating server was successfully requested, wait for the response
        //
        ri.uReqType = WM_ILS_ENUM_PROTOCOLS;
        ri.uMsgID = ldai.uMsgID;

		ReqInfo_SetUser (&ri, this);

        hr = g_pReqMgr->NewRequest(&ri);

        if (SUCCEEDED(hr))
        {
            // Make sure the objects do not disappear before we get the response
            //
            this->AddRef();

            // Return the request ID
            //
            *puReqID = ri.uReqID;
        };
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::GetProtocol (BSTR bstrProtocolID, IIlsAttributes *pAttributes,
//                          IIlsProtocol **ppProtocol, ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP CIlsUser::
GetProtocol (
	BSTR				bstrProtocolID,
	IIlsAttributes		*pAttributes,
	IIlsProtocol		**ppProtocol,
	ULONG				*puReqID )
{
    LDAP_ASYNCINFO ldai;
    LPTSTR pszID;
    HRESULT hr;
	TCHAR *pszAttrNameList = NULL;
	ULONG cAttrNames = 0;
	ULONG cbNames = 0;

    // Validate parameter
    //
    if (bstrProtocolID == NULL || puReqID == NULL)
        return ILS_E_POINTER;

    // Make sure this is a read-only object from server
    //
    if (! m_fReadonly)
        return ILS_E_ACCESS_DENIED;

	// Make sure we have a valid server object
	//
	if (m_pIlsServer == NULL)
		return ILS_E_FAIL;

	// Convert protocol name
	//
    hr = BSTR_to_LPTSTR(&pszID, bstrProtocolID);
	if (hr != S_OK)
		return hr;

	// Get arbitrary attribute name list if any
	//
	if (pAttributes != NULL)
	{
		hr = ((CAttributes *) pAttributes)->GetAttributeList (&pszAttrNameList, &cAttrNames, &cbNames);
		if (hr != S_OK)
            goto MyExit;
	}

	hr = ::UlsLdap_ResolveProtocol (m_pIlsServer->GetServerInfo (),
									m_szID,
									m_szAppName,
									pszID,
									pszAttrNameList,
									cAttrNames,
									&ldai);
	if (hr != S_OK)
		goto MyExit;

	// If updating server was successfully requested, wait for the response
	//
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

	ri.uReqType = WM_ILS_RESOLVE_PROTOCOL;
	ri.uMsgID = ldai.uMsgID;

	ReqInfo_SetUser (&ri, this);

	// Remember this request
	//
	hr = g_pReqMgr->NewRequest(&ri);
	if (SUCCEEDED(hr))
	{
	    // Make sure the objects do not disappear before we get the response
	    //
	    this->AddRef();

	    // Return the request ID
	    //
	    *puReqID = ri.uReqID;
	};

MyExit:

	::MemFree(pszAttrNameList);
	::MemFree (pszID);

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::EnumProtocolsResult (ULONG uReqID, PLDAP_ENUM ple)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::EnumProtocolsResult (ULONG uReqID, PLDAP_ENUM ple)
{
    ENUMRINFO eri;

    // Package the notification info
    //
    eri.uReqID  = uReqID;
    if (ple != NULL)
    {
	    eri.hResult = ple->hResult;
    	eri.cItems  = ple->cItems;
	    eri.pv      = (void *)(((PBYTE)ple)+ple->uOffsetItems);
	}
	else
	{
		eri.hResult = ILS_E_MEMORY;
		eri.cItems = 0;
		eri.pv = NULL;
	}
    NotifySink((void *)&eri, OnNotifyEnumProtocolsResult);
    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::StateChanged ( BOOL fPrimary, TCHAR *pszServerName )
//
// History:
//  Thu 07-Nov-1996 12:52:00  -by-  Chu, Lon-Chan [lonchanc]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::StateChanged ( LONG Type, BOOL fPrimary )
{
	BSTR bstrServerName;
	HRESULT hr;

	if (m_pIlsServer != NULL)
	{
		bstrServerName = m_pIlsServer->DuplicateServerNameBSTR ();
	}
	else
	{
		bstrServerName = NULL;
		ASSERT (FALSE);
	}

	switch (Type)
	{
	case WM_ILS_CLIENT_NEED_RELOGON:
        SetULSState(ULSSVR_RELOGON);

	    hr = NotifySink (bstrServerName, fPrimary ?
   										OnNotifyStateChanged_UI_NoSuchObject :
   										OnNotifyStateChanged_NoUI_NoSuchObject);
   		break;
   	case WM_ILS_CLIENT_NETWORK_DOWN:

        SetULSState(ULSSVR_NETWORK_DOWN);

	    hr = NotifySink (bstrServerName, fPrimary ?
   										OnNotifyStateChanged_UI_NetworkDown :
   										OnNotifyStateChanged_NoUI_NetworkDown);
   		break;
   	}

    if (NULL != bstrServerName)
    {
        SysFreeString(bstrServerName);
    }
    
   	return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::GetProtocolResult (ULONG uReqID, PLDAP_PROTINFO_RES ppir)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::GetProtocolResult (ULONG uReqID, PLDAP_PROTINFO_RES ppir)
{
    CLocalProt *pp;
    OBJRINFO objri;

    // Default to the server's result
    //
    objri.hResult = (ppir != NULL) ? ppir->hResult : ILS_E_MEMORY;

    if (SUCCEEDED(objri.hResult))
    {
        // The server returns PROTINFO, create a Application object
        //
        pp = new CLocalProt;

        if (pp != NULL)
        {
            objri.hResult = pp->Init(m_pIlsServer, m_szID, m_szAppName, &ppir->lpi);
            if (SUCCEEDED(objri.hResult))
            {
                pp->AddRef();
            }
            else
            {
                delete pp;
                pp = NULL;
            };
        }
        else
        {
            objri.hResult = ILS_E_MEMORY;
        };
    }
    else
    {
        pp = NULL;
    };

    // Package the notification info
    //
    objri.uReqID = uReqID;
    objri.pv = (void *)(pp == NULL ? NULL : (IIlsProtocol *)pp);
    NotifySink((void *)&objri, OnNotifyGetProtocolResult);

    if (pp != NULL)
    {
        pp->Release();
    };
    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::NotifySink (void *pv, CONN_NOTIFYPROC pfn)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::NotifySink (void *pv, CONN_NOTIFYPROC pfn)
{
    HRESULT hr = S_OK;

    if (m_pConnPt != NULL)
    {
        hr = m_pConnPt->Notify(pv, pfn);
    };
    return hr;
}

//****************************************************************************
// CEnumProtocols::CEnumProtocols (void)
//
// History:
//  Wed 17-Apr-1996 11:15:18  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CEnumProtocols::CEnumProtocols (void)
{
    m_cRef = 0;
    hEnum = NULL;
    return;
}

//****************************************************************************
// CEnumProtocols::~CEnumProtocols (void)
//
// History:
//  Wed 17-Apr-1996 11:15:18  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CEnumProtocols::~CEnumProtocols (void)
{
    CLocalProt *plp;

	ASSERT (m_cRef == 0);

    m_ProtList.Enumerate(&hEnum);
    while(m_ProtList.Next(&hEnum, (PVOID *)&plp) == NOERROR)
    {
        plp->Release();
    };
    m_ProtList.Flush();
    return;
}

//****************************************************************************
// STDMETHODIMP
// CEnumProtocols::Init (CList *pProtList)
//
// History:
//  Wed 17-Apr-1996 11:15:25  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumProtocols::Init (CList *pProtList)
{
    CLocalProt *plp;
    HRESULT hr;

    // Duplicate the protocol list
    //
    hr = m_ProtList.Clone (pProtList, NULL);

    if (SUCCEEDED(hr))
    {
        // Add reference to each protocol object
        //
        m_ProtList.Enumerate(&hEnum);
        while(m_ProtList.Next(&hEnum, (PVOID *)&plp) == NOERROR)
        {
            plp->AddRef();
        };

        // Reset the enumerator
        //
        m_ProtList.Enumerate(&hEnum);
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CEnumProtocols::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:15:31  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumProtocols::QueryInterface (REFIID riid, void **ppv)
{
    if (riid == IID_IEnumIlsProtocols || riid == IID_IUnknown)
    {
        *ppv = (IEnumIlsProtocols *) this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return ILS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumProtocols::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:15:37  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumProtocols::AddRef (void)
{
    DllLock();

	MyDebugMsg ((DM_REFCOUNT, "CEnumProtocols::AddRef: ref=%ld\r\n", m_cRef));
	::InterlockedIncrement (&m_cRef);
    return (ULONG) m_cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumProtocols::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:15:43  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumProtocols::Release (void)
{
    DllRelease();

	ASSERT (m_cRef > 0);

	MyDebugMsg ((DM_REFCOUNT, "CEnumProtocols::Release: ref=%ld\r\n", m_cRef));
    if (::InterlockedDecrement (&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return (ULONG) m_cRef;
}

//****************************************************************************
// STDMETHODIMP 
// CEnumProtocols::Next (ULONG cProtocols,
//                               IIlsProtocol **rgpProt,
//                               ULONG *pcFetched)
//
// History:
//  Wed 17-Apr-1996 11:15:49  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP 
CEnumProtocols::Next (ULONG cProtocols, IIlsProtocol **rgpProt,
                              ULONG *pcFetched)
{
    CLocalProt *plp;
    ULONG   cCopied;
    HRESULT hr;

    // Validate the pointer
    //
    if (rgpProt == NULL)
        return ILS_E_POINTER;

    // Validate the parameters
    //
    if ((cProtocols == 0) ||
        ((cProtocols > 1) && (pcFetched == NULL)))
        return ILS_E_PARAMETER;

    // Check the enumeration index
    //
    cCopied = 0;

    // Can copy if we still have more protocols
    //
    while ((cCopied < cProtocols) &&
           (m_ProtList.Next(&hEnum, (PVOID *)&plp) == NOERROR))
    {
        rgpProt[cCopied] = plp;
        plp->AddRef();
        cCopied++;
    };

    // Determine the returned information based on other parameters
    //
    if (pcFetched != NULL)
    {
        *pcFetched = cCopied;
    };
    return (cProtocols == cCopied ? S_OK : S_FALSE);
}

//****************************************************************************
// STDMETHODIMP
// CEnumProtocols::Skip (ULONG cProtocols)
//
// History:
//  Wed 17-Apr-1996 11:15:56  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumProtocols::Skip (ULONG cProtocols)
{
    CLocalProt *plp;
    ULONG cSkipped;

    // Validate the parameters
    //
    if (cProtocols == 0) 
        return ILS_E_PARAMETER;

    // Check the enumeration index limit
    //
    cSkipped = 0;

    // Can skip only if we still have more attributes
    //
    while ((cSkipped < cProtocols) &&
           (m_ProtList.Next(&hEnum, (PVOID *)&plp) == NOERROR))
    {
        cSkipped++;
    };

    return (cProtocols == cSkipped ? S_OK : S_FALSE);
}

//****************************************************************************
// STDMETHODIMP
// CEnumProtocols::Reset (void)
//
// History:
//  Wed 17-Apr-1996 11:16:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumProtocols::Reset (void)
{
    m_ProtList.Enumerate(&hEnum);
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CEnumProtocols::Clone(IEnumIlsProtocols **ppEnum)
//
// History:
//  Wed 17-Apr-1996 11:16:11  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumProtocols::Clone(IEnumIlsProtocols **ppEnum)
{
    CEnumProtocols *pep;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return ILS_E_POINTER;
    };

    *ppEnum = NULL;

    // Create an enumerator
    //
    pep = new CEnumProtocols;
    if (pep == NULL)
        return ILS_E_MEMORY;

    // Clone the information
    //
    pep->hEnum = hEnum;
    hr = pep->m_ProtList.Clone (&m_ProtList, &(pep->hEnum));

    if (SUCCEEDED(hr))
    {
        CLocalProt *plp;
        HANDLE hEnumTemp;

        // Add reference to each protocol object
        //
        pep->m_ProtList.Enumerate(&hEnumTemp);
        while(pep->m_ProtList.Next(&hEnumTemp, (PVOID *)&plp) == NOERROR)
        {
            plp->AddRef();
        };

        // Return the cloned enumerator
        //
        pep->AddRef();
        *ppEnum = pep;
    }
    else
    {
        delete pep;
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
//
// History:
//  Wed 17-Apr-1996 11:15:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
{
    CEnumConnectionPoints *pecp;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return E_POINTER;
    };
    
    // Assume failure
    //
    *ppEnum = NULL;

    // Create an enumerator
    //
    pecp = new CEnumConnectionPoints;
    if (pecp == NULL)
        return ILS_E_MEMORY;

    // Initialize the enumerator
    //
    hr = pecp->Init((IConnectionPoint *)m_pConnPt);
    if (FAILED(hr))
    {
        delete pecp;
        return hr;
    };

    // Give it back to the caller
    //
    pecp->AddRef();
    *ppEnum = pecp;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::FindConnectionPoint(REFIID riid, IConnectionPoint **ppcp)
//
// History:
//  Wed 17-Apr-1996 11:15:09  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::FindConnectionPoint(REFIID riid, IConnectionPoint **ppcp)
{
    IID siid;
    HRESULT hr;

    // Validate parameters
    //
    if (ppcp == NULL)
    {
        return E_POINTER;
    };
    
    // Assume failure
    //
    *ppcp = NULL;

    if (m_pConnPt != NULL)
    {
        hr = m_pConnPt->GetConnectionInterface(&siid);

        if (SUCCEEDED(hr))
        {
            if (riid == siid)
            {
                *ppcp = (IConnectionPoint *)m_pConnPt;
                (*ppcp)->AddRef();
                hr = S_OK;
            }
            else
            {
                hr = ILS_E_NO_INTERFACE;
            };
        };
    }
    else
    {
        hr = ILS_E_NO_INTERFACE;
    };

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\localusr.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       localusr.h
//  Content:    This file contains the User object definition.
//  History:
//      Wed 17-Apr-1996 11:18:47  -by-  Viroon  Touranachun [viroont]
//      Thu 1-16-97 combined localusr/localapp/ulsuser/ulsapp
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#ifndef _LOCALUSER_H_
#define _LOCALUSER_H_

#include "connpt.h"
#include "attribs.h"
#include "culs.h"

//****************************************************************************
// Constant definition
//****************************************************************************
//
#define LU_MOD_NONE         0x00000000
#define LU_MOD_FIRSTNAME    0x00000001
#define LU_MOD_LASTNAME     0x00000002
#define LU_MOD_EMAIL        0x00000004
#define LU_MOD_CITY         0x00000008
#define LU_MOD_COUNTRY      0x00000010
#define LU_MOD_COMMENT      0x00000020
#define LU_MOD_FLAGS        0x00000040
#define LU_MOD_IP_ADDRESS   0x00000080
#define LU_MOD_GUID         0x00000100
#define LU_MOD_MIME         0x00000200
#define LU_MOD_ATTRIB       0x00000400
#define LU_MOD_ALL          (LU_MOD_FIRSTNAME + LU_MOD_LASTNAME + \
                             LU_MOD_EMAIL + LU_MOD_CITY + \
                             LU_MOD_COUNTRY + LU_MOD_COMMENT +\
                             LU_MOD_FLAGS +\
                             LU_MOD_IP_ADDRESS +\
                             LU_MOD_GUID + LU_MOD_MIME +\
                             LU_MOD_ATTRIB \
                            )

//****************************************************************************
// Enumeration type
//****************************************************************************
//
typedef enum {
    ILS_APP_SET_ATTRIBUTES,
    ILS_APP_REMOVE_ATTRIBUTES,
}   APP_CHANGE_ATTRS;

typedef enum {
    ILS_APP_ADD_PROT,
    ILS_APP_REMOVE_PROT,
}   APP_CHANGE_PROT;



// server

typedef enum {
    ULSSVR_INVALID  = 0,
    ULSSVR_INIT,
    ULSSVR_REG_USER,
    ULSSVR_REG_PROT,
    ULSSVR_CONNECT,
    ULSSVR_UNREG_PROT,
    ULSSVR_UNREG_USER,
    ULSSVR_RELOGON,
    ULSSVR_NETWORK_DOWN,
}   ULSSVRSTATE;



//****************************************************************************
// CIlsUser definition
//****************************************************************************
//
class CIlsUser : public IIlsUser,
                 public IConnectionPointContainer
{
private:

	/* ------ user ------ */

    LONG                    m_cRef;
    BOOL                    m_fReadonly;
    ULONG                   m_cLock;
    ULONG                   m_uModify;
    LPTSTR                  m_szID;
    LPTSTR                  m_szFirstName;
    LPTSTR                  m_szLastName;
    LPTSTR                  m_szEMailName;
    LPTSTR                  m_szCityName;
    LPTSTR                  m_szCountryName;
    LPTSTR                  m_szComment;
    DWORD					m_dwFlags;
    LPTSTR                  m_szIPAddr;

    LPTSTR                  m_szAppName;
    GUID                    m_guid;
    LPTSTR                  m_szMimeType;
    CAttributes             m_ExtendedAttrs;
    CList                   m_ProtList;
    CIlsServer				*m_pIlsServer;
    CConnectionPoint        *m_pConnPt;

	/* ------ server ------ */

    ULSSVRSTATE             m_uState;
    HANDLE                  m_hLdapUser;
    ULONG                   m_uReqID;
    ULONG                   m_uLastMsgID;
    IEnumIlsProtocols       *m_pep;


private: // user

    STDMETHODIMP            InternalGetUserInfo (BOOL fAddNew,
                                                 PLDAP_CLIENTINFO *ppUserInfo,
                                                 ULONG uFields);

	HRESULT					RemoveProtocolFromList ( CLocalProt *pLocalProt );

public: // user

    // Constructor and destructor
    CIlsUser (void);
    ~CIlsUser (void);

    // Lock and unlock User operation
    //
    ULONG           Lock(void)      {m_cLock++; return m_cLock;}
    ULONG           Unlock(void)    {m_cLock--; return m_cLock;}
    BOOL            IsLocked(void)  {return (m_cLock != 0);}

    STDMETHODIMP            Init (BSTR bstrUserID, BSTR bstrAppName);
    STDMETHODIMP            Init (CIlsServer *pIlsServer, PLDAP_CLIENTINFO pui);

    STDMETHODIMP RegisterResult(ULONG ulRegID, HRESULT hr);
    STDMETHODIMP UnregisterResult (ULONG uReqID, HRESULT hResult);
    STDMETHODIMP UpdateResult(ULONG ulUpdateID, HRESULT hr);
    STDMETHODIMP StateChanged ( LONG Type, BOOL fPrimary);
    STDMETHODIMP ProtocolChangeResult ( IIlsProtocol *pProtcol,
                                        ULONG uReqID, HRESULT hResult,
                                        APP_CHANGE_PROT uCmd);

    STDMETHODIMP GetProtocolResult (ULONG uReqID, PLDAP_PROTINFO_RES ppir);
    STDMETHODIMP EnumProtocolsResult (ULONG uReqID, PLDAP_ENUM ple);
    STDMETHODIMP NotifySink (void *pv, CONN_NOTIFYPROC pfn);

    // Internal methods
    STDMETHODIMP            SaveChanges (void);
#ifdef LATER
    void                    LocalAsyncRespond (ULONG msg, ULONG uReqID, LPARAM lParam)
                            {PostMessage(g_hwndCulsWindow, msg, uReqID, lParam); return;}
#endif //LATER
    // Ldap Information
    //
    HRESULT    GetProtocolHandle (CLocalProt *pLocalProt, PHANDLE phProt);
    HRESULT    RegisterLocalProtocol( BOOL fAddToList, CLocalProt *pProt, PLDAP_ASYNCINFO plai );
    HRESULT    UnregisterLocalProtocol( CLocalProt *pProt, PLDAP_ASYNCINFO plai );
    HRESULT    UpdateProtocol ( IIlsProtocol *pProtocol, ULONG *puReqID, APP_CHANGE_PROT uCmd );

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IIlsLocalUser

	STDMETHODIMP	Clone ( IIlsUser **ppUser );

    STDMETHODIMP    GetState (ILS_STATE *puULSState);

    STDMETHODIMP    GetStandardAttribute(
                    ILS_STD_ATTR_NAME   stdAttr,
                    BSTR                *pbstrStdAttr);

    STDMETHODIMP    SetStandardAttribute(
                    ILS_STD_ATTR_NAME   stdAttr,
                    BSTR                pbstrStdAttr);

    STDMETHODIMP GetExtendedAttribute ( BSTR bstrName, BSTR *pbstrValue );
    STDMETHODIMP SetExtendedAttribute ( BSTR bstrName, BSTR bstrValue );
    STDMETHODIMP RemoveExtendedAttribute ( BSTR bstrName );
    STDMETHODIMP GetAllExtendedAttributes ( IIlsAttributes **ppAttributes );

    STDMETHODIMP IsWritable ( BOOL *pValue);

    STDMETHODIMP Register ( IIlsServer *pServer, ULONG *puReqID );

    STDMETHODIMP Unregister( ULONG *puReqID );

    STDMETHODIMP Update ( ULONG *puReqID );

    STDMETHODIMP GetVisible ( DWORD *pfVisible );

    STDMETHODIMP SetVisible ( DWORD fVisible );

    STDMETHODIMP GetGuid ( GUID *pGuid );

    STDMETHODIMP SetGuid ( GUID *pGuid );

    STDMETHODIMP CreateProtocol(
                        BSTR bstrProtocolID,
                        ULONG uPortNumber,
                        BSTR bstrMimeType,
                        IIlsProtocol **ppProtocol);

    STDMETHODIMP AddProtocol(
                        IIlsProtocol *pProtocol,
                        ULONG *puReqID);

    STDMETHODIMP RemoveProtocol(
                        IIlsProtocol *pProtocol,
                        ULONG *puReqID);

    STDMETHODIMP GetProtocol(
                        BSTR bstrProtocolID,
                        IIlsAttributes  *pAttributes,
                        IIlsProtocol **ppProtocol,
                        ULONG *puReqID);

    STDMETHODIMP EnumProtocols(
                        IIlsFilter     *pFilter,
                        IIlsAttributes *pAttributes,
                        IEnumIlsProtocols **ppEnumProtocol,
                        ULONG *puReqID);


    // IConnectionPointContainer
    STDMETHODIMP    EnumConnectionPoints(IEnumConnectionPoints **ppEnum);
    STDMETHODIMP    FindConnectionPoint(REFIID riid,
                                        IConnectionPoint **ppcp);

public: // server

    // Server registration result
    //
    HRESULT    InternalRegisterNext ( HRESULT );
    HRESULT    InternalUnregisterNext ( HRESULT );

    // Register/Unregister
    //
    HRESULT    InternalRegister (ULONG uReqID);
    HRESULT    InternalUnregister (ULONG uReqID);
    HRESULT    InternalCleanupRegistration ( BOOL fKeepProtList );
    HRESULT	   EnumLocalProtocols ( IEnumIlsProtocols **pEnumProtocol );

    // Server properties
    //
    ILS_STATE    GetULSState ( VOID );
    VOID		SetULSState ( ULSSVRSTATE State ) { m_uState = State; }

private: // server

    void       NotifyULSRegister(HRESULT hr);
    void       NotifyULSUnregister(HRESULT hr);
    HRESULT    AddPendingRequest(ULONG uReqType, ULONG uMsgID);
};

//****************************************************************************
// CEnumUsers definition
//****************************************************************************
//
class CEnumUsers : public IEnumIlsUsers
{
private:
    LONG                    m_cRef;
    CIlsUser                **m_ppu;
    ULONG                   m_cUsers;
    ULONG                   m_iNext;

public:
    // Constructor and Initialization
    CEnumUsers (void);
    ~CEnumUsers (void);
    STDMETHODIMP            Init (CIlsUser **ppuList, ULONG cUsers);

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IEnumIlsAttributes
    STDMETHODIMP            Next(ULONG cUsers, IIlsUser **rgpu,
                                 ULONG *pcFetched);
    STDMETHODIMP            Skip(ULONG cUsers);
    STDMETHODIMP            Reset();
    STDMETHODIMP            Clone(IEnumIlsUsers **ppEnum);
};

//****************************************************************************
// CEnumLocalAppProtocols definition
//****************************************************************************
//
class CEnumProtocols : public IEnumIlsProtocols
{
private:
    LONG                    m_cRef;
    CList                   m_ProtList;
    HANDLE                  hEnum;

public:
    // Constructor and Initialization
    CEnumProtocols (void);
    ~CEnumProtocols (void);
    STDMETHODIMP            Init (CList *pProtList);

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IEnumIlsProtocols
    STDMETHODIMP            Next(ULONG cProtocols, IIlsProtocol **rgpProt,
                                 ULONG *pcFetched);
    STDMETHODIMP            Skip(ULONG cProtocols);
    STDMETHODIMP            Reset();
    STDMETHODIMP            Clone(IEnumIlsProtocols **ppEnum);
};


#endif //_LOCALUSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\request.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       request.cpp
//  Content:    CReqMgr and CRequest classes implementation
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#include "ulsp.h"
#include "request.h"


//****************************************************************************
// CReqMgr::CReqMgr(void)
//
// Purpose: Constructor for the CReqMgr class
//
// Parameters: None
//****************************************************************************

CReqMgr::CReqMgr(void)
{
    uNextReqID = REQUEST_ID_INIT;
    return;
}

//****************************************************************************
// CReqMgr::~CReqMgr(void)
//
// Purpose: Destructor for the CReqMgr class
//
// Parameters: None
//****************************************************************************

CReqMgr::~CReqMgr(void)
{
    COM_REQ_INFO *pRequest;
    HANDLE hEnum;

    // Free all the pending request
    //
    ReqList.Enumerate(&hEnum);
    while (ReqList.Next(&hEnum, (LPVOID *)&pRequest) == NOERROR)
    {
        ::MemFree (pRequest);
    }
    ReqList.Flush();
    return;
}

//****************************************************************************
// HRESULT
// CReqMgr::NewRequest  (COM_REQ_INFO *pri)
//
// Purpose: Add a new pending request
//
// Parameters: None
//****************************************************************************

HRESULT
CReqMgr::NewRequest  (COM_REQ_INFO *pri)
{
    COM_REQ_INFO *pRequest;
    HRESULT  hr;

    // Allocate a new request node
    //
    pri->uReqID = uNextReqID;
    pRequest = (COM_REQ_INFO *) ::MemAlloc (sizeof (COM_REQ_INFO));
    if (pRequest == NULL)
    {
        return ILS_E_MEMORY;
    };
    *pRequest = *pri;

    // Append the new request to the list
    //
    hr = ReqList.Append((PVOID)pRequest);

    if (FAILED(hr))
    {
        delete pRequest;
    }
    else
    {
        if (++uNextReqID == ILS_INVALID_REQ_ID)
        	uNextReqID = REQUEST_ID_INIT;
    };
    return hr;
}

//****************************************************************************
// HRESULT
// CReqMgr::FindRequest (COM_REQ_INFO *pri, BOOL fRemove)
//
// Purpose: Find the request.
//
// Parameters: None
//****************************************************************************

HRESULT
CReqMgr::FindRequest (COM_REQ_INFO *pri, BOOL fRemove)
{
    COM_REQ_INFO *pRequest;
    ULONG    uMatchingID;
    HANDLE   hEnum;
    HRESULT  hr;

    // Get the ID we want to match
    //
    uMatchingID = (pri->uMsgID != 0 ? pri->uMsgID : pri->uReqID);

    // Look for the request matching the message ID
    //
    ReqList.Enumerate(&hEnum);
    while (ReqList.Next(&hEnum, (PVOID *)&pRequest) == NOERROR)
    {
        if (uMatchingID == (pri->uMsgID != 0 ? pRequest->uMsgID : 
                                               pRequest->uReqID))
        {
            break;
        };
    };
    
    if (pRequest != NULL)
    {
        // Return the request associates
        //
        *pri = *pRequest;

        // Remove the request
        //
        if (fRemove)
        {
            ReqList.Remove((PVOID)pRequest);
            ::MemFree (pRequest);
        };
        hr = NOERROR;
    }
    else
    {
        hr = ILS_E_FAIL;
    };

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\request.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       request.h
//  Content:    Declaration CReqMgr and CRequest classes
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#ifndef _REQUEST_H_
#define _REQUEST_H_

typedef struct  tagRequestInfo {
	DWORD	dwSignature;
    ULONG   uReqType;
    ULONG   uMsgID;
    ULONG   uReqID;
//    LPVOID  pv;
//    LPARAM  lParam;
	DWORD				dwFlags;
	CIlsServer			*pServer;
	CIlsMain			*pMain;
	CIlsUser			*pUser;
	CLocalProt			*pProtocol;
#ifdef ENABLE_MEETING_PLACE
	CIlsMeetingPlace	*pMeeting;
#endif
}   COM_REQ_INFO;

#define REQ_INFO_SIGNATURE	0x123456UL
VOID inline ReqInfo_Init ( COM_REQ_INFO *p )
{
	ZeroMemory (p, sizeof (*p));
	p->dwSignature = REQ_INFO_SIGNATURE;
}

BOOL inline ReqInfo_IsValid ( COM_REQ_INFO *p )
{
	return (p->dwSignature == REQ_INFO_SIGNATURE);
}

enum
{
	REQ_INFO_F_SERVER = 0x01, REQ_INFO_F_MAIN = 0x02,
	REQ_INFO_F_USER = 0x04, REQ_INFO_F_PROTOCOL = 0x08,
	REQ_INFO_F_MEETING = 0x10
};

VOID inline ReqInfo_SetServer ( COM_REQ_INFO *p, CIlsServer *pServer )
{
	ASSERT (p->pServer == NULL);
	p->dwFlags |= REQ_INFO_F_SERVER;
	p->pServer = pServer;
}

VOID inline ReqInfo_SetServer ( COM_REQ_INFO *p, IIlsServer *pServer )
{
	ReqInfo_SetServer (p, (CIlsServer *) pServer);
}

VOID inline ReqInfo_SetMain ( COM_REQ_INFO *p, CIlsMain *pMain )
{
	ASSERT (p->pMain == NULL);
	p->dwFlags |= REQ_INFO_F_MAIN;
	p->pMain = pMain;
}

VOID inline ReqInfo_SetUser ( COM_REQ_INFO *p, CIlsUser *pUser )
{
	ASSERT (p->pUser == NULL);
	p->dwFlags |= REQ_INFO_F_USER;
	p->pUser = pUser;
}

VOID inline ReqInfo_SetProtocol ( COM_REQ_INFO *p, CLocalProt *pProtocol )
{
	ASSERT (p->pProtocol == NULL);
	p->dwFlags |= REQ_INFO_F_PROTOCOL;
	p->pProtocol = pProtocol;
}

VOID inline ReqInfo_SetProtocol ( COM_REQ_INFO *p, IIlsProtocol *pProtocol )
{
	ReqInfo_SetProtocol (p, (CLocalProt *) pProtocol);
}

#ifdef ENABLE_MEETING_PLACE
VOID inline ReqInfo_SetMeeting ( COM_REQ_INFO *p, CIlsMeetingPlace *pMeeting )
{
	ASSERT (p->pMeeting == NULL);
	p->dwFlags |= REQ_INFO_F_MEETING;
	p->pMeeting = pMeeting;
}
#endif

CIlsServer inline *ReqInfo_GetServer ( COM_REQ_INFO *p )
{
	return ((p->dwFlags & REQ_INFO_F_SERVER) ? p->pServer : NULL);
}

CIlsMain inline *ReqInfo_GetMain ( COM_REQ_INFO *p )
{
	return ((p->dwFlags & REQ_INFO_F_MAIN) ? p->pMain : NULL);
}

CIlsUser inline *ReqInfo_GetUser ( COM_REQ_INFO *p )
{
	return ((p->dwFlags & REQ_INFO_F_USER) ? p->pUser : NULL);
}

CLocalProt inline *ReqInfo_GetProtocol ( COM_REQ_INFO *p )
{
	return ((p->dwFlags & REQ_INFO_F_PROTOCOL) ? p->pProtocol : NULL);
}

#ifdef ENABLE_MEETING_PLACE
CIlsMeetingPlace inline *ReqInfo_GetMeeting ( COM_REQ_INFO *p )
{
	return ((p->dwFlags & REQ_INFO_F_MEETING) ? p->pMeeting : NULL);
}
#endif

//****************************************************************************
// CReqMgr definition
//****************************************************************************
//
#define REQUEST_ID_INIT     1

class   CReqMgr
{
private:
    CList   ReqList;
    ULONG   uNextReqID;

    HRESULT FindRequest (COM_REQ_INFO *pri, BOOL fRemove);

public:
    CReqMgr (void);
    ~CReqMgr (void);

    HRESULT NewRequest  (COM_REQ_INFO *pri);
    HRESULT RequestDone (COM_REQ_INFO *pri)      {return FindRequest(pri,TRUE);}
    HRESULT GetRequestInfo (COM_REQ_INFO *pri)   {return FindRequest(pri,FALSE);}
};

#endif // _REQUEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\regunreg.cpp ===
//=--------------------------------------------------------------------------=
// RegUnReg.cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
#include "ulsp.h"
#include "regunreg.h"


//=--------------------------------------------------------------------------=
// miscellaneous [useful] numerical constants
//=--------------------------------------------------------------------------=
// the length of a guid once printed out with -'s, leading and trailing bracket,
// plus 1 for NULL
//
#define GUID_STR_LEN    40

#define CLEANUP_ON_ERROR(l)    if (l != ERROR_SUCCESS) goto CleanUp


//=--------------------------------------------------------------------------=
// StringFromGuid
//=--------------------------------------------------------------------------=
// returns a string from a CLSID or GUID
//
// Parameters:
//    REFIID               - [in]  clsid to make string out of.
//    LPTSTR               - [in]  buffer in which to place resultant GUID.
//
// Output:
//    int                  - number of chars written out.
//
// Notes:
//
static int StringFromGuid
(
    REFIID   riid,
    LPTSTR   pszBuf
)
{
    return wsprintf(pszBuf, TEXT("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
            riid.Data1, 
            riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], 
            riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7]);

}

//=--------------------------------------------------------------------------=
// RegisterUnknownObject
//=--------------------------------------------------------------------------=
// registers a simple CoCreatable object.  nothing terribly serious.
// we add the following information to the registry:
//
// HKEY_CLASSES_ROOT\CLSID\<CLSID> = <ObjectName> Object
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32 = <path to local server>
//
// Parameters:
//    LPCSTR       - [in] Object Name
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means couldn't register it all
//
// Notes:
//
BOOL RegisterUnknownObject
(
    LPCTSTR  pszObjectName,
    REFCLSID riidObject
)
{
    HKEY  hk = NULL, hkSub = NULL;
    TCHAR szGuidStr[GUID_STR_LEN];
    DWORD dwPathLen, dwDummy;
    TCHAR szScratch[MAX_PATH];
    long  l;

    // clean out any garbage
    //
    UnregisterUnknownObject(riidObject);

    // HKEY_CLASSES_ROOT\CLSID\<CLSID> = <ObjectName> Object
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32 = <path to local server>
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32  @ThreadingModel = Apartment
    //
    if (!StringFromGuid(riidObject, szGuidStr)) goto CleanUp;
    wsprintf(szScratch, TEXT("CLSID\\%s"), szGuidStr);
    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, TEXT(""), REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, TEXT("%s Object"), pszObjectName);
    l = RegSetValueEx(hk, NULL, 0, REG_SZ, (BYTE *)szScratch,
                      (lstrlen(szScratch) + 1)*sizeof(TCHAR));
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, TEXT("InprocServer32"), 0, TEXT(""), REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    dwPathLen = GetModuleFileName(g_hInstance, szScratch, sizeof(szScratch)/sizeof(TCHAR));
    if (!dwPathLen) goto CleanUp;

    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, (dwPathLen + 1)*sizeof(TCHAR));
    CLEANUP_ON_ERROR(l);

    l = RegSetValueEx(hkSub, TEXT("ThreadingModel"), 0, REG_SZ, (BYTE *)TEXT("Apartment"),
                      sizeof(TEXT("Apartment")));
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    RegCloseKey(hk);

    return TRUE;

    // we are not very happy!
    //
  CleanUp:
    if (hk) RegCloseKey(hk);
    if (hkSub) RegCloseKey(hkSub);
    return FALSE;

}

//=--------------------------------------------------------------------------=
// UnregisterUnknownObject
//=--------------------------------------------------------------------------=
// cleans up all the stuff that RegisterUnknownObject puts in the
// registry.
//
// Parameters:
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means not all of it was registered
//
// Notes:
//    - WARNING: this routine will blow away all other keys under the CLSID
//      for this object.  mildly anti-social, but likely not a problem.
//
BOOL UnregisterUnknownObject
(
    REFCLSID riidObject
)
{
    TCHAR szScratch[MAX_PATH];
    HKEY hk;
    BOOL f;
    long l;

    // delete everybody of the form
    //   HKEY_CLASSES_ROOT\CLSID\<CLSID> [\] *
    //
    if (!StringFromGuid(riidObject, szScratch))
        return FALSE;

    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("CLSID"), 0, KEY_ALL_ACCESS, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    f = DeleteKeyAndSubKeys(hk, szScratch);
    RegCloseKey(hk);

    return f;
}

//=--------------------------------------------------------------------------=
// DeleteKeyAndSubKeys
//=--------------------------------------------------------------------------=
// delete's a key and all of it's subkeys.
//
// Parameters:
//    HKEY                - [in] delete the descendant specified
//    LPTSTR              - [in] i'm the descendant specified
//
// Output:
//    BOOL                - TRUE OK, FALSE baaaad.
//
// Notes:
//    - I don't feel too bad about implementing this recursively, since the
//      depth isn't likely to get all the great.
//    - Despite the win32 docs claiming it does, RegDeleteKey doesn't seem to
//      work with sub-keys under windows 95.
//
BOOL DeleteKeyAndSubKeys
(
    HKEY    hkIn,
    LPTSTR  pszSubKey
)
{
    HKEY  hk;
    TCHAR szTmp[MAX_PATH];
    DWORD dwTmpSize;
    long  l;
    BOOL  f;
    int   x;

    l = RegOpenKeyEx(hkIn, pszSubKey, 0, KEY_ALL_ACCESS, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    // loop through all subkeys, blowing them away.
    //
    f = TRUE;
    x = 0;
    while (f) {
        dwTmpSize = MAX_PATH;
        l = RegEnumKeyEx(hk, x, szTmp, &dwTmpSize, 0, NULL, NULL, NULL);
        if (l != ERROR_SUCCESS) break;
        f = DeleteKeyAndSubKeys(hk, szTmp);
        x++;
    }

    // there are no subkeys left, [or we'll just generate an error and return FALSE].
    // let's go blow this dude away.
    //
    RegCloseKey(hk);
    l = RegDeleteKey(hkIn, pszSubKey);

    return (l == ERROR_SUCCESS) ? TRUE : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\regunreg.h ===
//=--------------------------------------------------------------------------=
// RegUnReg.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains utilities that we will find useful.
//
#ifndef _REGUNREG_H_

//=--------------------------------------------------------------------------=
// registry helpers.
//
// takes some information about an Automation Object, and places all the
// relevant information about it in the registry.
//
BOOL RegisterUnknownObject(LPCTSTR pszObjectName, REFCLSID riidObject);
BOOL UnregisterUnknownObject(REFCLSID riidObject);

// deletes a key in the registr and all of it's subkeys
//
BOOL DeleteKeyAndSubKeys(HKEY hk, LPTSTR pszSubKey);


#define _REGUNREG_H_
#endif // _REGUNREG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\spclient.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spclient.cpp
	Content:	This file contains the client object.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"


// Array of constant strings for user object's attribute names
//
const TCHAR *c_apszClientStdAttrNames[COUNT_ENUM_CLIENTATTR] =
{
	/* -- the following is for user -- */

	TEXT ("cn"),
	TEXT ("givenname"),
	TEXT ("surname"),
	TEXT ("rfc822mailbox"),
	TEXT ("location"),
	TEXT ("comment"),
	TEXT ("sipaddress"),
	TEXT ("sflags"),
	TEXT ("c"),

	/* -- the following is for app -- */

	TEXT ("sappid"),
	TEXT ("smimetype"),
	TEXT ("sappguid"),

	TEXT ("sprotid"),
	TEXT ("sprotmimetype"),
	TEXT ("sport"),

	/* -- the above are resolvable -- */

	TEXT ("ssecurity"),
	TEXT ("sttl"),

	/* -- the above are changeable standard attributes for RTPerson -- */

	TEXT ("objectClass"),
	TEXT ("o"),
};


/* ---------- public methods ----------- */


SP_CClient::
SP_CClient ( DWORD_PTR dwContext )
	:
	m_cRefs (0),						// Reference count
	m_uSignature (CLIENTOBJ_SIGNATURE),	// Client object's signature
	m_pszDN (NULL),						// Clean up DN
	m_pszAppPrefix (NULL),				// Clean up app prefix
	m_pszRefreshFilter (NULL),			// Clean up the refresh search filter
	m_fExternalIPAddress (FALSE),		// Default is I figure out the ip address
	m_dwIPAddress (0),					// Assume we are not connected to the network
	m_uTTL (ILS_DEF_REFRESH_MINUTE)		// Reset refresh time
{
	m_dwContext = dwContext;

	// Clean up attached server info structure
	//
	::ZeroMemory (&m_ServerInfo, sizeof (m_ServerInfo));

	// Clean up the scratch buffer for caching pointers to attribute values
	//
	::ZeroMemory (&m_ClientInfo, sizeof (m_ClientInfo));

	// Indicate this client is not registered yet
	//
	SetRegNone ();
}


SP_CClient::
~SP_CClient ( VOID )
{
	// Invalidate the client object's signature
	//
	m_uSignature = (ULONG) -1;

	// Free server info structure
	//
	::IlsFreeServerInfo (&m_ServerInfo);

	// Free DN and app prefix
	//
	MemFree (m_pszDN);
	MemFree (m_pszAppPrefix);

	// Free the refresh search filter
	//
	MemFree (m_pszRefreshFilter);

	// Release the previous prefix for extended attribute names
	//
	::IlsReleaseAnyAttrsPrefix (&(m_ClientInfo.AnyAttrs));
}


ULONG SP_CClient::
AddRef ( VOID )
{
	::InterlockedIncrement (&m_cRefs);
	return m_cRefs;
}


ULONG SP_CClient::
Release ( VOID )
{
	MyAssert (m_cRefs != 0);
	::InterlockedDecrement (&m_cRefs);

	ULONG cRefs = m_cRefs;
	if (cRefs == 0)
		delete this;

	return cRefs;
}


HRESULT SP_CClient::
Register (
	ULONG			uRespID,
	SERVER_INFO		*pServerInfo,
	LDAP_CLIENTINFO	*pInfo )
{
	MyAssert (pInfo != NULL);
	MyAssert (MyIsGoodString (pServerInfo->pszServerName));

	// Cache the server info
	//
	HRESULT hr = ::IlsCopyServerInfo (&m_ServerInfo, pServerInfo);
	if (hr != S_OK)
		return hr;

	// Cache client info
	//
	hr = CacheClientInfo (pInfo);
	if (hr != S_OK)
		return hr;

	// If the application sets an IP address,
	//		then we will use what the app provides,
	//		otherwise, we will get the IP address via winsock.
	//
	// CacheClientInfo() will set up the flag if ip address is passed in
	//
	if (IsExternalIPAddressPassedIn ())
	{
		// Use whatever passed in
		//
		m_fExternalIPAddress = TRUE;

		// Figure out the passed in ip address is done in CacheClientInfo()
		// The IP address string will be setup in CacheClientInfo() too.
		//
	}
	else
	{
		// I will figure out the ip address
		//
		m_fExternalIPAddress = FALSE;

		// Get IP address
		//
		hr = ::GetLocalIPAddress (&m_dwIPAddress);
		if (hr != S_OK)
			return hr;

		// Create IP address string
		//
		m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_IP_ADDRESS] = &m_ClientInfo.szIPAddress[0];
		::GetLongString (m_dwIPAddress, &m_ClientInfo.szIPAddress[0]);
	}

	// Create client signature string
	//
	m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_CLIENT_SIG] = &m_ClientInfo.szClientSig[0];
	::GetLongString (g_dwClientSig, &m_ClientInfo.szClientSig[0]);

	// Create TTL string
	//
	m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_TTL] = &m_ClientInfo.szTTL[0];
	::GetLongString (m_uTTL + ILS_DEF_REFRESH_MARGIN_MINUTE, &m_ClientInfo.szTTL[0]);

	// Set object class RTPerson
	//
	m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_OBJECT_CLASS] = (TCHAR *) &c_szRTPerson[0];

	// Ideally, o= should be read in from registiry
	// but for now, we simply hard code it
	//
	m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_O] = (TCHAR *) &c_szDefO[0];

	// Build DN
	//
	m_pszDN = ::IlsBuildDN (m_ServerInfo.pszBaseDN,
							m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_C],
							m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_O],
							m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_CN],
							m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_OBJECT_CLASS]);
	if (m_pszDN == NULL)
		return ILS_E_MEMORY;

	// Build refreh filter
	//
	m_pszRefreshFilter = ::ClntCreateRefreshFilter (m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_CN]);
	if (m_pszRefreshFilter == NULL)
		return ILS_E_MEMORY;

	// Cache generic protocol info (per KevinMa's suggestion)
	//
	// m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_PROT_NAME] = TEXT ("h323");
	// m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_PROT_MIME] = TEXT ("text/h323");
	// m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_PROT_PORT] = TEXT ("1720");
	m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_PROT_NAME] = STR_EMPTY;
	m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_PROT_MIME] = STR_EMPTY;
	m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_PROT_PORT] = STR_EMPTY;

	// Allocate app prefix here
	//
	ULONG cbPrefix = g_cbUserPrefix + sizeof (TCHAR) * (2 +
				::lstrlen (STR_CLIENT_APP_NAME) +
				::lstrlen (m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_APP_NAME]));
	m_pszAppPrefix = (TCHAR *) MemAlloc (cbPrefix);
	if (m_pszAppPrefix == NULL)
		return ILS_E_MEMORY;

	// Fill user prefix
	//
	::CopyMemory (m_pszAppPrefix, g_pszUserPrefix, g_cbUserPrefix);

	// Fill app prefix
	//
	TCHAR *psz = (TCHAR *) ((BYTE *) m_pszAppPrefix + g_cbUserPrefix);
	::lstrcpy (psz, STR_CLIENT_APP_NAME);
	psz += lstrlen (psz) + 1;
	::lstrcpy (psz, m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_APP_NAME]);

	// Build modify array for ldap_add()
	//
	LDAPMod **ppModUser = NULL;
	hr = CreateRegUserModArr (&ppModUser);
	if (hr != S_OK)
	{
		return hr;
	}
	MyAssert (ppModUser != NULL);

	// Build modify array for ldap_modify()
	//
	LDAPMod **ppModApp = NULL;
	hr = CreateRegAppModArr (&ppModApp);
	if (hr != S_OK)
	{
		MemFree (ppModUser);
		return hr;
	}
	MyAssert (ppModApp != NULL);

	// so far, we are done with local preparation
	//

	// Get the session object
	//
	SP_CSession *pSession = NULL;
	LDAP *ld;
	ULONG uMsgIDUser = (ULONG) -1, uMsgIDApp = (ULONG) -1;
	hr = g_pSessionContainer->GetSession (&pSession, &m_ServerInfo);
	if (hr == S_OK)
	{
		MyAssert (pSession != NULL);

		// Get the ldap session
		//
		ld = pSession->GetLd ();
		MyAssert (ld != NULL);

		// Send the data over the wire
		//
		uMsgIDUser = ::ldap_add (ld, m_pszDN, ppModUser);
		if (uMsgIDUser != -1)
		{
			uMsgIDApp = ::ldap_modify (ld, m_pszDN, ppModApp);
			if (uMsgIDApp == -1)
			{
				hr = ::LdapError2Hresult (ld->ld_errno);
			}
		}
		else
		{
			hr = ::LdapError2Hresult (ld->ld_errno);
		}
	}

	// Free modify arrays
	//
	MemFree (ppModUser);
	MemFree (ppModApp);

	// Report failure if so
	//
	if (hr != S_OK)
		goto MyExit;

	// Construct a pending info
	//
	RESP_INFO ri;
	::FillDefRespInfo (&ri, uRespID, ld, uMsgIDUser, uMsgIDApp);
	ri.uNotifyMsg = WM_ILS_REGISTER_CLIENT;
	ri.hObject = (HANDLE) this;

	// Queue the pending result
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		MyAssert (FALSE);
		goto MyExit;
	}

MyExit:

	if (hr != S_OK)
	{
		if (uMsgIDUser != (ULONG) -1)
			::ldap_abandon (ld, uMsgIDUser);

		if (uMsgIDApp != (ULONG) -1)
			::ldap_abandon (ld, uMsgIDApp);

		if (pSession != NULL)
			pSession->Disconnect ();
	}

	return hr;
}


HRESULT SP_CClient::
UnRegister ( ULONG uRespID )
{
	MyAssert (MyIsGoodString (m_pszDN));

	// Make sure that there is not refresh scheduled for this object
	//
	if (g_pRefreshScheduler != NULL)
	{
		g_pRefreshScheduler->RemoveClientObject (this);
	}
	else
	{
		MyAssert (FALSE);
	}

	// If it is not registered on the server,
	// the simply report success
	//
	if (! IsRegRemotely ())
	{
		SetRegNone ();
		::PostMessage (g_hWndNotify, WM_ILS_UNREGISTER_CLIENT, uRespID, S_OK);
		return S_OK;
	}

	// Indicate that we are not registered at all
	//
	SetRegNone ();

	// Get the session object
	//
	SP_CSession *pSession = NULL;
	LDAP *ld;
	ULONG uMsgID = (ULONG) -1;
	HRESULT hr = g_pSessionContainer->GetSession (&pSession, &m_ServerInfo);
	if (hr == S_OK)
	{
		// Get the ldap session
		//
		MyAssert (pSession != NULL);
		ld = pSession->GetLd ();
		MyAssert (ld != NULL);

		// Send the data over the wire
		//
		MyAssert (MyIsGoodString (m_pszDN));
		uMsgID = ::ldap_delete (ld, m_pszDN);
		if (uMsgID == -1)
		{
			hr = ::LdapError2Hresult (ld->ld_errno);
		}
	}

	// Report failure if so
	//
	if (hr != S_OK)
		goto MyExit;

	// Construct a pending info
	//
	RESP_INFO ri;
	::FillDefRespInfo (&ri, uRespID, ld, uMsgID, INVALID_MSG_ID);
	ri.uNotifyMsg = WM_ILS_UNREGISTER_CLIENT;

	// Queue this pending result
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		MyAssert (FALSE);
		goto MyExit;
	}

MyExit:

	if (hr != S_OK)
	{
		if (uMsgID != (ULONG) -1)
			::ldap_abandon (ld, uMsgID);

		if (pSession != NULL)
			pSession->Disconnect ();
	}

	return hr;
}


HRESULT SP_CClient::
SetAttributes (
	ULONG			uRespID,
	LDAP_CLIENTINFO	*pInfo )
{
	MyAssert (pInfo != NULL);

	MyAssert (MyIsGoodString (m_pszDN));

	// cache info
	//
	HRESULT hr = CacheClientInfo (pInfo);
	if (hr != S_OK)
		return hr;

	// Build modify array for user object's ldap_modify()
	//
	LDAPMod **ppModUser = NULL;
	hr = CreateSetUserAttrsModArr (&ppModUser);
	if (hr != S_OK)
		return hr;
	MyAssert (ppModUser != NULL);

	// Build modify array for app object's ldap_modify()
	//
	LDAPMod **ppModApp = NULL;
	hr = CreateSetAppAttrsModArr (&ppModApp);
	if (hr != S_OK)
	{
		MemFree (ppModUser);
		return hr;
	}
	MyAssert (ppModApp != NULL);

	// So far, we are done with local preparation
	//

	// Get the session object
	//
	SP_CSession *pSession = NULL;
	LDAP *ld;
	ULONG uMsgIDUser = (ULONG) -1, uMsgIDApp = (ULONG) -1;
	hr = g_pSessionContainer->GetSession (&pSession, &m_ServerInfo);
	if (hr == S_OK)
	{
		MyAssert (pSession != NULL);

		// Get the ldap session
		//
		ld = pSession->GetLd ();
		MyAssert (ld != NULL);

		// Send the data over the wire
		//
		uMsgIDUser = ::ldap_modify (ld, m_pszDN, ppModUser);
		if (uMsgIDUser != -1)
		{
			uMsgIDApp = ::ldap_modify (ld, m_pszDN, ppModApp);
			if (uMsgIDApp == -1)
			{
				hr = ::LdapError2Hresult (ld->ld_errno);
			}
		}
		else
		{
			hr = ::LdapError2Hresult (ld->ld_errno);
		}
	}

	// Free modify arrays
	//
	MemFree (ppModUser);
	MemFree (ppModApp);

	// Report failure if so
	//
	if (hr != S_OK)
		goto MyExit;

	// Initialize pending info
	//
	RESP_INFO ri;
	::FillDefRespInfo (&ri, uRespID, ld, uMsgIDUser, uMsgIDApp);
	ri.uNotifyMsg = WM_ILS_SET_CLIENT_INFO;

	// Queue the pending result
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		MyAssert (FALSE);
		goto MyExit;
	}

MyExit:

	if (hr != S_OK)
	{
		if (uMsgIDUser != (ULONG) -1)
			::ldap_abandon (ld, uMsgIDUser);

		if (uMsgIDApp != (ULONG) -1)
			::ldap_abandon (ld, uMsgIDApp);

		if (pSession != NULL)
			pSession->Disconnect ();
	}
	else
	{
		// If the user customizes the ip address
		// we need to remember this
		//
		m_fExternalIPAddress |= IsExternalIPAddressPassedIn ();
	}

	return hr;
}


HRESULT SP_CClient::
AddProtocol ( ULONG uNotifyMsg, ULONG uRespID, SP_CProtocol *pProt )
{
	HRESULT hr = m_Protocols.Append ((VOID *) pProt);
	if (hr == S_OK)
	{
		hr = UpdateProtocols (uNotifyMsg, uRespID, pProt);
	}

	return hr;
}


HRESULT SP_CClient::
RemoveProtocol ( ULONG uNotifyMsg, ULONG uRespID, SP_CProtocol *pProt )
{
	HRESULT hr = m_Protocols.Remove ((VOID *) pProt);
	if (hr == S_OK)
	{
		hr = UpdateProtocols (uNotifyMsg, uRespID, pProt);
	}
	else
	{
		hr = ILS_E_NOT_REGISTERED;
	}

	return hr;
}


HRESULT SP_CClient::
UpdateProtocols ( ULONG uNotifyMsg, ULONG uRespID, SP_CProtocol *pProt )
{
	MyAssert (	uNotifyMsg == WM_ILS_REGISTER_PROTOCOL ||
				uNotifyMsg == WM_ILS_UNREGISTER_PROTOCOL ||
				uNotifyMsg == WM_ILS_SET_PROTOCOL_INFO);
	
	MyAssert (MyIsGoodString (m_pszDN));

	HRESULT hr = S_OK;

	// Build modify array for protocol object's ldap_modify()
	//
	LDAPMod **ppModProt = NULL;
	hr = CreateSetProtModArr (&ppModProt);
	if (hr != S_OK)
		return hr;
	MyAssert (ppModProt != NULL);

	// So far, we are done with local preparation
	//

	// Get the session object
	//
	SP_CSession *pSession = NULL;
	LDAP *ld;
	ULONG uMsgIDProt = (ULONG) -1;
	hr = g_pSessionContainer->GetSession (&pSession, &m_ServerInfo);
	if (hr == S_OK)
	{
		MyAssert (pSession != NULL);

		// Get the ldap session
		//
		ld = pSession->GetLd ();
		MyAssert (ld != NULL);

		// Send the data over the wire
		//
		uMsgIDProt = ::ldap_modify (ld, m_pszDN, ppModProt);
		if (uMsgIDProt == -1)
		{
			hr = ::LdapError2Hresult (ld->ld_errno);
		}
	}

	// Free modify arrays
	//
	MemFree (ppModProt);

	// Report failure if so
	//
	if (hr != S_OK)
		goto MyExit;

	// Initialize pending info
	//
	RESP_INFO ri;
	::FillDefRespInfo (&ri, uRespID, ld, uMsgIDProt, INVALID_MSG_ID);
	ri.uNotifyMsg = uNotifyMsg;
	ri.hObject = (HANDLE) pProt;

	// Queue the pending result
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		MyAssert (FALSE);
		goto MyExit;
	}

MyExit:

	if (hr != S_OK)
	{
		if (uMsgIDProt != (ULONG) -1)
			::ldap_abandon (ld, uMsgIDProt);

		if (pSession != NULL)
			pSession->Disconnect ();
	}

	return hr;
}


HRESULT SP_CClient::
UpdateIPAddress ( VOID )
{
	MyAssert (MyIsGoodString (m_pszDN));

	// Update cached ip address
	//
	HRESULT hr = ::GetLocalIPAddress (&m_dwIPAddress);
	if (hr != S_OK)
		return hr;

	// Update the ip address string
	//
	::GetLongString (m_dwIPAddress, &m_ClientInfo.szIPAddress[0]);

	// Update IP address on the server
	//
	return ::IlsUpdateIPAddress (	&m_ServerInfo,
									m_pszDN,
									STR_CLIENT_IP_ADDR,
									&m_ClientInfo.szIPAddress[0],
									ISBU_MODOP_MODIFY_USER,
									1,
									g_pszUserPrefix);
}


/* ---------- protected methods ----------- */


HRESULT SP_CClient::
SendRefreshMsg ( VOID )
{
	MyAssert (m_pszRefreshFilter != NULL);

	HRESULT hr;

	// Send a refresh message to the server and parse the new TTL value
	//
	hr = ::IlsSendRefreshMsg (	&m_ServerInfo,
								STR_DEF_CLIENT_BASE_DN,
								STR_CLIENT_TTL,
								m_pszRefreshFilter,
								&m_uTTL);
	if (hr == ILS_E_NEED_RELOGON)
	{
		SetRegLocally ();
		::PostMessage (g_hWndNotify, WM_ILS_CLIENT_NEED_RELOGON,
							(WPARAM) this, (LPARAM) m_dwContext);
	}
	else
	if (hr == ILS_E_NETWORK_DOWN)
	{
		SetRegLocally ();
		::PostMessage (g_hWndNotify, WM_ILS_CLIENT_NETWORK_DOWN,
							(WPARAM) this, (LPARAM) m_dwContext);
	}

	// If the ip address is not provided by the app, then
	// we need to make sure that the current ip address is equal to
	// the one we used to register the user.
	//
	if (! m_fExternalIPAddress && hr == S_OK)
	{
		// Get local ip address
		//
		DWORD dwIPAddress = 0;
		if (::GetLocalIPAddress (&dwIPAddress) == S_OK)
		{
			// Now, the network appears to be up and running.
			// Update the ip address if they are different.
			//
			if (dwIPAddress != 0 && dwIPAddress != m_dwIPAddress)
				UpdateIPAddress ();
		}
	}

	return hr;
}


/* ---------- private methods ----------- */


HRESULT SP_CClient::
CreateRegUserModArr ( LDAPMod ***pppMod )
{
	MyAssert (pppMod != NULL);

	// Calculate the modify array size
	//
#ifdef ANY_IN_USER
	ULONG cStdAttrs = COUNT_ENUM_REG_USER;
	ULONG cAnyAttrs = m_ClientInfo.AnyAttrs.cAttrsToAdd;
	ULONG cTotal = cStdAttrs + cAnyAttrs;
	ULONG cbMod = ::IlsCalcModifyListSize (cTotal);
#else
	ULONG cStdAttrs = COUNT_ENUM_REG_USER;
	ULONG cTotal = cStdAttrs;
	ULONG cbMod = ::IlsCalcModifyListSize (cTotal);
#endif

	// Allocate the modify array
	//
	*pppMod = (LDAPMod **) MemAlloc (cbMod);
	if (*pppMod == NULL)
		return ILS_E_MEMORY;

	// Lay out the modify array
	//
	LDAPMod **apMod = *pppMod;
	LDAPMod *pMod;
	ULONG i, nIndex;
#ifdef ANY_IN_USER
	TCHAR *pszName2, *pszValue;
	pszName2 = m_ClientInfo.AnyAttrs.pszAttrsToAdd;
#endif
	for (i = 0; i < cTotal; i++)
	{
		// Locate modify element
		//
		pMod = ::IlsGetModifyListMod (pppMod, cTotal, i);
		pMod->mod_op = LDAP_MOD_ADD;
		apMod[i] = pMod;

#ifdef ANY_IN_USER
		if (i < cStdAttrs)
		{
			// Get attribute name and value
			//
			if (IsOverAppAttrLine (i))
			{
				nIndex = i + COUNT_ENUM_SKIP_APP_ATTRS;
			}
			else
			{
				nIndex = i;
			}

			// Put standard attributes
			//
			FillModArrAttr (pMod, nIndex);
		}
		else
		{
			// Put extended attributes
			//
			pszValue = pszName2 + lstrlen (pszName2) + 1;
			::IlsFillModifyListItem (pMod, pszName2, pszValue);
			pszName2 = pszValue + lstrlen (pszValue) + 1;
		}
#else
		// Get attribute name and value
		//
		if (IsOverAppAttrLine (i))
		{
			nIndex = i + COUNT_ENUM_SKIP_APP_ATTRS;
		}
		else
		{
			nIndex = i;
		}

		// Fill in modify element
		//
		FillModArrAttr (pMod, nIndex);
#endif
	}

	apMod[cTotal] = NULL;
	return S_OK;
}


HRESULT SP_CClient::
CreateRegAppModArr ( LDAPMod ***pppMod )
{
	MyAssert (pppMod != NULL);

	// Calculate the modify array size
	//
	ULONG cPrefix = 1; // Skip its own app id
	ULONG cStdAttrs = COUNT_ENUM_REG_APP;
#ifdef ANY_IN_USER
	ULONG cTotal = cPrefix + cStdAttrs;
	ULONG cbMod = ::IlsCalcModifyListSize (cTotal);
#else
	ULONG cAnyAttrs = m_ClientInfo.AnyAttrs.cAttrsToAdd;
	ULONG cTotal = cPrefix + cStdAttrs + cAnyAttrs;
	ULONG cbMod = ::IlsCalcModifyListSize (cTotal);
#endif

	// Allocate the modify array
	//
	*pppMod = (LDAPMod **) MemAlloc (cbMod);
	if (*pppMod == NULL)
		return ILS_E_MEMORY;

	// Lay out the modify array
	//
	LDAPMod **apMod = *pppMod;
	LDAPMod *pMod;
#ifdef ANY_IN_USER
	TCHAR *pszName1, *pszValue;
	pszName1 = m_pszAppPrefix;;
#else
	TCHAR *pszName1, *pszName2, *pszValue;
	pszName1 = m_pszAppPrefix;;
	pszName2 = m_ClientInfo.AnyAttrs.pszAttrsToAdd;
#endif
	for (ULONG i = 0; i < cTotal; i++)
	{
		// Locate modify element
		//
		pMod = ::IlsGetModifyListMod (pppMod, cTotal, i);
		pMod->mod_op = LDAP_MOD_ADD;
		apMod[i] = pMod;

		if (i < cPrefix)
		{
			// Put the prefix
			//
			pMod->mod_op = LDAP_MOD_REPLACE;
			pszValue = pszName1 + lstrlen (pszName1) + 1;
			::IlsFillModifyListItem (pMod, pszName1, pszValue);
			pszName1 = pszValue + lstrlen (pszValue) + 1;
		}
		else
#ifdef ANY_IN_USER
		{
			// Put standard attributes
			//
			FillModArrAttr (pMod, i - cPrefix + ENUM_CLIENTATTR_APP_NAME);
		}
#else
		if (i < cPrefix + cStdAttrs)
		{
			// Put standard attributes
			//
			FillModArrAttr (pMod, i - cPrefix + ENUM_CLIENTATTR_APP_NAME);
		}
		else
		{
			// Put extended attributes
			//
			pszValue = pszName2 + lstrlen (pszName2) + 1;
			::IlsFillModifyListItem (pMod, pszName2, pszValue);
			pszName2 = pszValue + lstrlen (pszValue) + 1;
		}
#endif
	}

	::IlsFixUpModOp (apMod[0], LDAP_MOD_ADD, ISBU_MODOP_ADD_APP);
	apMod[cTotal] = NULL;
	return S_OK;
}


HRESULT SP_CClient::
CreateSetUserAttrsModArr ( LDAPMod ***pppMod )
{
	MyAssert (pppMod != NULL);

	HRESULT hr;
	DWORD dwFlags = m_ClientInfo.dwFlags & CLIENTOBJ_F_USER_MASK;
#ifdef ANY_IN_USER
	ULONG cTotal  = m_ClientInfo.AnyAttrs.cAttrsToAdd +
					m_ClientInfo.AnyAttrs.cAttrsToModify +
					m_ClientInfo.AnyAttrs.cAttrsToRemove;
#else
	ULONG cTotal = 0; // must be initialized to zero
#endif

	// Lay out the modify array for modifying user standard attributes
	//
	hr = ::IlsFillDefStdAttrsModArr (pppMod,
									dwFlags,
									COUNT_ENUM_SET_USER_INFO,
									&cTotal,
									ISBU_MODOP_MODIFY_USER,
									1,
									g_pszUserPrefix);
	if (hr != S_OK)
		return hr;

	// Start to fill standard attributes
	//
	ULONG i = 1;
	LDAPMod **apMod = *pppMod;

	if (dwFlags & CLIENTOBJ_F_EMAIL_NAME)
		FillModArrAttr (apMod[i++], ENUM_CLIENTATTR_EMAIL_NAME);

	if (dwFlags & CLIENTOBJ_F_FIRST_NAME)
		FillModArrAttr (apMod[i++], ENUM_CLIENTATTR_FIRST_NAME);

	if (dwFlags & CLIENTOBJ_F_LAST_NAME)
		FillModArrAttr (apMod[i++], ENUM_CLIENTATTR_LAST_NAME);

	if (dwFlags & CLIENTOBJ_F_CITY_NAME)
		FillModArrAttr (apMod[i++], ENUM_CLIENTATTR_CITY_NAME);

	if (dwFlags & CLIENTOBJ_F_C)
		FillModArrAttr (apMod[i++], ENUM_CLIENTATTR_C);

	if (dwFlags & CLIENTOBJ_F_COMMENT)
		FillModArrAttr (apMod[i++], ENUM_CLIENTATTR_COMMENT);

	if (dwFlags & CLIENTOBJ_F_IP_ADDRESS)
		FillModArrAttr (apMod[i++], ENUM_CLIENTATTR_IP_ADDRESS);

	if (dwFlags & CLIENTOBJ_F_FLAGS)
		FillModArrAttr (apMod[i++], ENUM_CLIENTATTR_FLAGS);

#ifdef ANY_IN_USER
	// Start to fill extended attributes
	//
	::IlsFillModifyListForAnyAttrs (apMod, &i, &m_ClientInfo.AnyAttrs);
#else
#endif

	MyAssert (i == cTotal);
	return S_OK;
}


HRESULT SP_CClient::
CreateSetAppAttrsModArr ( LDAPMod ***pppMod )
{
	MyAssert (pppMod != NULL);

	HRESULT hr;
	DWORD dwFlags = m_ClientInfo.dwFlags & CLIENTOBJ_F_APP_MASK;
#ifdef ANY_IN_USER
	ULONG cTotal = 0; // must be initialized to zero
#else
	ULONG cTotal  = m_ClientInfo.AnyAttrs.cAttrsToAdd +
					m_ClientInfo.AnyAttrs.cAttrsToModify +
					m_ClientInfo.AnyAttrs.cAttrsToRemove;
#endif

	// Lay out the modify array for modifying app standard/extended attributes
	//
	hr = ::IlsFillDefStdAttrsModArr (pppMod,
									dwFlags,
									COUNT_ENUM_SET_APP_INFO,
									&cTotal,
									ISBU_MODOP_MODIFY_APP,
									2,
									m_pszAppPrefix);
	if (hr != S_OK)
		return hr;

	// Start to fill standard attributes
	//
	ULONG i = 2;
	LDAPMod **apMod = *pppMod;

	if (m_ClientInfo.dwFlags & CLIENTOBJ_F_APP_GUID)
		FillModArrAttr (apMod[i++], ENUM_CLIENTATTR_APP_GUID);

	if (m_ClientInfo.dwFlags & CLIENTOBJ_F_APP_NAME)
		FillModArrAttr (apMod[i++], ENUM_CLIENTATTR_APP_NAME);

	if (m_ClientInfo.dwFlags & CLIENTOBJ_F_APP_MIME_TYPE)
		FillModArrAttr (apMod[i++], ENUM_CLIENTATTR_APP_MIME_TYPE);

#ifdef ANY_IN_USER
#else
	// Start to fill extended attributes
	//
	::IlsFillModifyListForAnyAttrs (apMod, &i, &m_ClientInfo.AnyAttrs);
#endif

	MyAssert (i == cTotal);
	return S_OK;
}


HRESULT SP_CClient::
CreateSetProtModArr ( LDAPMod ***pppMod )
// We need to delete the attributes and then add the entire array back.
// This is due to the ILS server limitation. We agreed to live with that.
//
{
	MyAssert (pppMod != NULL);

	ULONG cPrefix = 2;
	TCHAR *pszPrefix = m_pszAppPrefix;

	ULONG cStdAttrs = COUNT_ENUM_PROTATTR;
	ULONG cTotal = cPrefix + cStdAttrs + cStdAttrs;
	ULONG cProts = 0;

	// Find out how many protocols
	//
   	HANDLE hEnum = NULL;
	SP_CProtocol *pProt;
    m_Protocols.Enumerate (&hEnum);
    while (m_Protocols.Next (&hEnum, (VOID **) &pProt) == NOERROR)
    	cProts++;

	// Calculate the modify array's total size
	//
	ULONG cbMod = ::IlsCalcModifyListSize (cTotal);

	// Add up for multi-valued attribute
	//
	if (cProts > 0)
	{
		cbMod += cStdAttrs * (cProts - 1) * sizeof (TCHAR *);
	}

	// Allocate the modify array
	//
	LDAPMod **apMod = *pppMod = (LDAPMod **) MemAlloc (cbMod);
	if (apMod == NULL)
		return ILS_E_MEMORY;

	// Fill in the modify list
	//
	LDAPMod *pMod;
	BYTE *pbData = (BYTE *) apMod + (cTotal + 1) * sizeof (LDAPMod *);
	ULONG uDispPrefix = sizeof (LDAPMod) + 2 * sizeof (TCHAR *);
	ULONG uDispStdAttrs = sizeof (LDAPMod) + (cProts + 1) * sizeof (TCHAR *);
	for (ULONG uOffset = 0, i = 0; i < cTotal; i++)
	{
		// Locate the modify structure
		//
		pMod = (LDAPMod *) (pbData + uOffset);
		apMod[i] = pMod;
		pMod->mod_values = (TCHAR **) (pMod + 1);

		// Fill in the modify structure
		//
		if (i < cPrefix)
		{
			pMod->mod_op = LDAP_MOD_REPLACE;
			pMod->mod_type = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
			*(pMod->mod_values) = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
		}
		else
		if (i < cPrefix + cStdAttrs)
		{
			// Work around the ISBU server implementation!!!
			// We agreed that we can live with the server implementation.
			//
			pMod->mod_op = LDAP_MOD_DELETE;

			ULONG nIndex = i - cPrefix;

			// Fill in attribute name
			//
			pMod->mod_type = (TCHAR *) c_apszProtStdAttrNames[nIndex];
		}
		else
		{
			pMod->mod_op = LDAP_MOD_ADD;

			ULONG nIndex = i - cPrefix - cStdAttrs;

			// Fill in attribute name
			//
			pMod->mod_type = (TCHAR *) c_apszProtStdAttrNames[nIndex];

		    // Fill in multi-valued modify array
		    //
		    if (cProts > 0)
		    {
				ULONG j = 0; // must initialized to zero
				TCHAR *pszVal;

			    m_Protocols.Enumerate (&hEnum);
			    MyAssert (hEnum != NULL);
			    while (m_Protocols.Next (&hEnum, (VOID **) &pProt) == NOERROR)
			    {
			    	MyAssert (pProt != NULL);
			    	pszVal = (pProt->GetProtInfo ())->apszStdAttrValues[nIndex];
			    	(pMod->mod_values)[j++] = (pszVal != NULL) ? pszVal : STR_EMPTY;
			    }
		    }
		    else
		    {
		    	(pMod->mod_values)[0] = STR_EMPTY;
		    }
		}

		// Calculate the modify structure's offset relative to the array's end
		//
		uOffset += (i < cPrefix + cStdAttrs) ? uDispPrefix : uDispStdAttrs;
	}

	// Fix up the first and the last ones
	//
	IlsFixUpModOp (apMod[0], LDAP_MOD_REPLACE, ISBU_MODOP_MODIFY_APP);
	apMod[cTotal] = NULL;

	return S_OK;
}


VOID SP_CClient::
FillModArrAttr ( LDAPMod *pMod, INT nIndex )
{
	MyAssert (pMod != NULL);
	MyAssert (0 <= nIndex && nIndex <= COUNT_ENUM_CLIENTATTR);

	::IlsFillModifyListItem (	pMod,
								(TCHAR *) c_apszClientStdAttrNames[nIndex],
								m_ClientInfo.apszStdAttrValues[nIndex]);
}


HRESULT SP_CClient::
CacheClientInfo ( LDAP_CLIENTINFO *pInfo )
{
	MyAssert (pInfo != NULL);

	// Release the previous prefix for extended attribute names
	//
	::IlsReleaseAnyAttrsPrefix (&(m_ClientInfo.AnyAttrs));

	// Clean up the buffer
	//
	ZeroMemory (&m_ClientInfo, sizeof (m_ClientInfo));

	// Start to cache user standard attributes
	//

	if (pInfo->uOffsetCN != INVALID_OFFSET)
	{
		m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_CN] =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetCN);
		// We do not want to change CN thru ldap_modify()
		// m_ClientInfo.dwFlags |= CLIENTOBJ_F_CN;
	}

	if (pInfo->uOffsetFirstName != INVALID_OFFSET)
	{
		m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_FIRST_NAME] =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetFirstName);
		m_ClientInfo.dwFlags |= CLIENTOBJ_F_FIRST_NAME;
	}

	if (pInfo->uOffsetLastName != INVALID_OFFSET)
	{
		m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_LAST_NAME] =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetLastName);
		m_ClientInfo.dwFlags |= CLIENTOBJ_F_LAST_NAME;
	}

	if (pInfo->uOffsetEMailName != INVALID_OFFSET)
	{
		m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_EMAIL_NAME] =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetEMailName);
		m_ClientInfo.dwFlags |= CLIENTOBJ_F_EMAIL_NAME;
	}

	if (pInfo->uOffsetCityName != INVALID_OFFSET)
	{
		m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_CITY_NAME] =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetCityName);
		m_ClientInfo.dwFlags |= CLIENTOBJ_F_CITY_NAME;
	}

	if (pInfo->uOffsetCountryName != INVALID_OFFSET)
	{
		m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_C] =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetCountryName);
		m_ClientInfo.dwFlags |= CLIENTOBJ_F_C;
	}

	if (pInfo->uOffsetComment != INVALID_OFFSET)
	{
		m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_COMMENT] =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetComment);
		m_ClientInfo.dwFlags |= CLIENTOBJ_F_COMMENT;
	}

	if (pInfo->uOffsetIPAddress != INVALID_OFFSET)
	{
		DWORD dwIPAddr = ::inet_addr ((TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetIPAddress));
		if (dwIPAddr != INADDR_NONE)
		{
			m_dwIPAddress = dwIPAddr;
			m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_IP_ADDRESS] = &m_ClientInfo.szIPAddress[0];
			::GetLongString (m_dwIPAddress, &m_ClientInfo.szIPAddress[0]);
			m_ClientInfo.dwFlags |= CLIENTOBJ_F_IP_ADDRESS;
		}
	}

	if (pInfo->dwFlags != INVALID_USER_FLAGS)
	{
		::GetLongString (pInfo->dwFlags, &m_ClientInfo.szFlags[0]);
		m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_FLAGS] = &m_ClientInfo.szFlags[0];
		m_ClientInfo.dwFlags |= CLIENTOBJ_F_FLAGS;
	}

	// Start to cache app standard attributes
	//

	if (pInfo->uOffsetAppName != INVALID_OFFSET)
	{
		m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_APP_NAME] =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetAppName);
		m_ClientInfo.dwFlags |= CLIENTOBJ_F_APP_NAME;
	}

	if (pInfo->uOffsetAppMimeType != INVALID_OFFSET)
	{
		m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_APP_MIME_TYPE] =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetAppMimeType);
		m_ClientInfo.dwFlags |= CLIENTOBJ_F_APP_MIME_TYPE;
	}

	if (::IsValidGuid (&(pInfo->AppGuid)))
	{
		::GetGuidString (&(pInfo->AppGuid), &m_ClientInfo.szGuid[0]);
		m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_APP_GUID] = &m_ClientInfo.szGuid[0];
		m_ClientInfo.dwFlags |= CLIENTOBJ_F_APP_GUID;
	}

	// Start to cache app extended attributes
	//

	if (pInfo->uOffsetAttrsToAdd != INVALID_OFFSET &&
		pInfo->cAttrsToAdd != 0)
	{
		m_ClientInfo.AnyAttrs.cAttrsToAdd = pInfo->cAttrsToAdd;
		m_ClientInfo.AnyAttrs.pszAttrsToAdd =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetAttrsToAdd);
	}

	if (pInfo->uOffsetAttrsToModify != INVALID_OFFSET &&
		pInfo->cAttrsToModify != 0)
	{
		m_ClientInfo.AnyAttrs.cAttrsToModify = pInfo->cAttrsToModify;
		m_ClientInfo.AnyAttrs.pszAttrsToModify =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetAttrsToModify);
	}

	if (pInfo->uOffsetAttrsToRemove != INVALID_OFFSET &&
		pInfo->cAttrsToRemove != 0)
	{
		m_ClientInfo.AnyAttrs.cAttrsToRemove = pInfo->cAttrsToRemove;
		m_ClientInfo.AnyAttrs.pszAttrsToRemove =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetAttrsToRemove);
	}

	// Create prefix for extended attribute names
	//
	return ::IlsCreateAnyAttrsPrefix (&(m_ClientInfo.AnyAttrs));
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\spanyatt.h ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spanyatt.h
	Content:	This file contains the arbitrary-attribute object definition.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#ifndef _ULS_SP_ANYATTR_H_
#define _ULS_SP_ANYATTR_H_

#include <pshpack8.h>


// this structure is used to remember which arbitrary attributes
// have been created at the server side.
// in isbu server implementation, all the applications' and
// protocols' arbitrary attributes are under RTPerson; therefore,
// it is important to clean up arbitrary attributes propertly.
typedef struct tagAnyAttr
{
	struct tagAnyAttr *prev;
	struct tagAnyAttr *next;
	LONG	mod_op;	// used in temp list only
	TCHAR	*pszAttrName;
	// followed by attr name
}
	ANY_ATTR;


class UlsLdap_CAnyAttrs
{
	friend class UlsLdap_CLocalApp;
	friend class UlsLdap_CLocalProt;

public:

	UlsLdap_CAnyAttrs ( VOID );
	~UlsLdap_CAnyAttrs ( VOID );

protected:

	HRESULT SetAnyAttrs ( ULONG *puRespID, ULONG *puMsgID, ULONG uNotifyMsg,
				ULONG cPrefix, TCHAR *pszPrefix,
				ULONG cAttrs, TCHAR *pszAttrs,
				LONG ModOp,	SERVER_INFO *pServerInfo, TCHAR *pszDN );
	HRESULT RemoveAnyAttrs ( ULONG *puRespID, ULONG *puMsgID, ULONG uNotifyMsg,
				ULONG cPrefix, TCHAR *pszPrefix,
				ULONG cAttrs, TCHAR *pszAttrs,
				SERVER_INFO *pServerInfo, TCHAR *pszDN );
	HRESULT RemoveAllAnyAttrs ( ULONG *puMsgID, ULONG cPrefix, TCHAR *pszPrefix,
				SERVER_INFO *pServerInfo, TCHAR *pszDN );

	ULONG GetAnyAttrsCount ( VOID ) { return m_cAttrs; }

private:

	HRESULT RemoveAnyAttrsEx ( ULONG *puRespID, ULONG *puMsgID, ULONG uNotifyMsg,
				ULONG cPrefix, TCHAR *pszPrefix,
				ULONG cAttrs, TCHAR *pszAttrs,
				SERVER_INFO *pServerInfo, TCHAR *pszDN );

	HRESULT SetAttrsAux ( ULONG cAttrs, TCHAR *pszAttrs,
				ULONG cPrefix, TCHAR *pszPrefix, LONG ModOp,
				LDAPMod ***pppMod );
	HRESULT RemoveAttrsAux ( ULONG cAttrs, TCHAR *pszAttrs,
				ULONG cPrefix, TCHAR *pszPrefix,
				LDAPMod ***pppMod );

	VOID RemoveAttrFromList ( TCHAR *pszAttrName );
	VOID FreeAttrList ( ANY_ATTR *AttrList );
	ANY_ATTR *LocateAttr ( TCHAR *pszAttrName );

	ULONG		m_cAttrs;
	ANY_ATTR	*m_AttrList;
};


const TCHAR *SkipAnyAttrNamePrefix ( const TCHAR *pszAttrName );
const TCHAR *IsAnyAttrName ( const TCHAR *pszAttrName );
TCHAR *PrefixNameValueArray ( BOOL fPair, ULONG cAttrs, const TCHAR *pszAttrs );

#include <poppack.h>

#endif // _ULS_SP_ANYATTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by uls.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\spconn.h ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spconn.h
	Content:	This file contains the ldap connection object definition.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#ifndef _ILS_SP_CONNECT_H_
#define _ILS_SP_CONNECT_H_

#include <pshpack8.h>

extern ULONG g_uResponseTimeout;


#define LDAP_CONN_SIGNATURE		((DWORD) 0xF9369606)
#define MAX_LDAP_DN				256

#ifdef USE_DEFAULT_COUNTRY
extern const TCHAR c_szDefC[];
#endif
extern const TCHAR c_szDefO[];
extern const TCHAR c_szRTPerson[];
extern const TCHAR c_szRTConf[];
extern const TCHAR c_szDefClientBaseDN[];
extern const TCHAR c_szDefMtgBaseDN[];
extern const TCHAR c_szEmptyString[];

#define STR_DEF_CLIENT_BASE_DN	((TCHAR *) &c_szDefClientBaseDN[0])
#define STR_DEF_MTG_BASE_DN		((TCHAR *) &c_szDefMtgBaseDN[0])

#define STR_EMPTY				((TCHAR *) &c_szEmptyString[0])


class SP_CSession
{
	friend class SP_CSessionContainer;

public:

	SP_CSession ( VOID );
	~SP_CSession ( VOID );

	// session management
	LDAP *GetLd ( VOID ) { return m_ld; }
	HRESULT Disconnect ( VOID );

	// server timeout
	ULONG GetServerTimeoutInSecond ( VOID )
	{ 
		return ((m_ServerInfo.uTimeoutInSecond != 0) ?
					m_ServerInfo.uTimeoutInSecond :
					g_uResponseTimeout / 1000);
	}
	ULONG GetServerTimeoutInTickCount ( VOID )
	{ 
		return ((m_ServerInfo.uTimeoutInSecond != 0) ?
					m_ServerInfo.uTimeoutInSecond * 1000 :
					g_uResponseTimeout);
	}

protected:

	// session management
	HRESULT Connect ( SERVER_INFO *pInfo, ULONG cConns, BOOL fAbortable );
	BOOL SameServerInfo ( SERVER_INFO *pInfo ) { return IlsSameServerInfo (&m_ServerInfo, pInfo); }

	// array management
	BOOL IsUsed ( VOID ) { return m_fUsed; }
	VOID SetUsed ( VOID ) { m_fUsed = TRUE; }
	VOID ClearUsed ( VOID ) { m_fUsed = FALSE; }

private:

	VOID FillAuthIdentity ( SEC_WINNT_AUTH_IDENTITY *pai );
	HRESULT Bind ( BOOL fAbortable );
	VOID InternalCleanup ( VOID );

	DWORD			m_dwSignature;
	SERVER_INFO		m_ServerInfo;
	LONG			m_cRefs;
	LDAP			*m_ld;
	BOOL			m_fUsed;
};


class SP_CSessionContainer
{
public:

	SP_CSessionContainer ( VOID );
	~SP_CSessionContainer ( VOID );

	HRESULT Initialize ( ULONG cEntries, SP_CSession *ConnArr );

	HRESULT GetSession ( SP_CSession **ppConn, SERVER_INFO *pInfo, ULONG cConns, BOOL fAbortable );	
	HRESULT GetSession ( SP_CSession **ppConn, SERVER_INFO *pInfo, BOOL fAbortable ) { return GetSession (ppConn, pInfo, 1, fAbortable); }
	HRESULT GetSession ( SP_CSession **ppConn, SERVER_INFO *pInfo ) { return GetSession (ppConn, pInfo, 1, TRUE); }

protected:

private:

	VOID ReadLock ( VOID ) { EnterCriticalSection (&m_csSessContainer); }
	VOID ReadUnlock ( VOID ) { LeaveCriticalSection (&m_csSessContainer); }
	VOID WriteLock ( VOID ) { ReadLock (); }
	VOID WriteUnlock ( VOID ) { ReadUnlock (); }

	ULONG			m_cEntries;
	SP_CSession		*m_aConns;

	CRITICAL_SECTION m_csSessContainer;
};


extern SP_CSessionContainer *g_pSessionContainer;

#include <poppack.h>

#endif // _ILS_SP_CONNECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\spfilter.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spfilter.cpp
	Content:	This file contains the ldap filters.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"

const TCHAR c_szClientRefreshFilter[] =
TEXT ("(&(objectClass=RTPerson)(cn=%s)(sttl=10))");
TCHAR *ClntCreateRefreshFilter ( TCHAR *pszClientName )
{
	TCHAR *pszFilter = (TCHAR *) MemAlloc (
							sizeof (c_szClientRefreshFilter) +
							(lstrlen (pszClientName) + 1) * sizeof (TCHAR));
	if (pszFilter != NULL)
	{
		wsprintf (	pszFilter,
					&c_szClientRefreshFilter[0],
					pszClientName);
	}

	return pszFilter;
}


const TCHAR c_szMtgRefreshFilter[] =
TEXT ("(&(objectClass=Conference)(cn=%s)(sttl=10))");
TCHAR *MtgCreateRefreshFilter ( TCHAR *pszMtgName )
{
	TCHAR *pszFilter = (TCHAR *) MemAlloc (
							sizeof (c_szMtgRefreshFilter) +
							(lstrlen (pszMtgName) + 1) * sizeof (TCHAR));
	if (pszFilter != NULL)
	{
		wsprintf (pszFilter, &c_szMtgRefreshFilter[0], pszMtgName);
	}

	return pszFilter;
}


const TCHAR c_szEnumProtsFilterFormat[] =
TEXT ("(&(objectClass=RTPerson)(cn=%s)(sappid=%s))");
TCHAR *ProtCreateEnumFilter ( TCHAR *pszUserName, TCHAR *pszAppName )
{
	TCHAR *pszFilter = (TCHAR *) MemAlloc (sizeof (c_szEnumProtsFilterFormat) +
										(lstrlen (pszUserName) + 1) * sizeof (TCHAR) +
										(lstrlen (pszAppName) + 1) * sizeof (TCHAR));
	if (pszFilter != NULL)
	{
		wsprintf (pszFilter, &c_szEnumProtsFilterFormat[0], pszUserName, pszAppName);
	}

	return pszFilter;
}



const TCHAR c_szResolveMtgFilterFormat[] =
TEXT ("(&(objectClass=Conference)(cn=%s))");
TCHAR *MtgCreateResolveFilter ( TCHAR *pszMtgName )
{
	TCHAR *pszFilter = (TCHAR *) MemAlloc (sizeof (c_szResolveMtgFilterFormat) +
										(lstrlen (pszMtgName) + 1) * sizeof (TCHAR));
	if (pszFilter != NULL)
	{
		wsprintf (pszFilter, &c_szResolveMtgFilterFormat[0], pszMtgName);
	}

	return pszFilter;
}


const TCHAR c_szResolveClientAppProt[] =
TEXT ("(&(objectClass=RTPerson)(cn=%s)(sappid=%s)(sprotid=%s))");
const TCHAR c_szResolveClientApp[] =
TEXT ("(&(objectClass=RTPerson)(cn=%s)(sappid=%s))");
const TCHAR c_szResolveClientProt[] =
TEXT ("(&(objectClass=RTPerson)(cn=%s)(sprotid=%s))");
const TCHAR c_szResolveClientOnly[] =
TEXT ("(&(objectClass=RTPerson)(cn=%s))");

TCHAR *ClntCreateResolveFilter ( TCHAR *pszClientName, TCHAR *pszAppName, TCHAR *pszProtName )
{
	ULONG cbSize = (lstrlen (pszClientName) + 1) * sizeof (TCHAR);
	LONG nChoice;

	enum { CLIENT_APP_PROT = 0, CLIENT_APP = 1, CLIENT_PROT = 2, CLIENT_ONLY = 3 };

	if (pszAppName != NULL)
	{
		if (pszProtName != NULL)
		{
			nChoice = CLIENT_APP_PROT;
			cbSize += sizeof (c_szResolveClientAppProt) +
						(lstrlen (pszAppName) + lstrlen (pszProtName)) * sizeof (TCHAR);
		}
		else
		{
			nChoice = CLIENT_APP;
			cbSize += sizeof (c_szResolveClientApp) +
						lstrlen (pszAppName) * sizeof (TCHAR);
		}
	}
	else
	{
		if (pszProtName != NULL)
		{
			nChoice = CLIENT_PROT;
			cbSize += sizeof (c_szResolveClientProt) +
						lstrlen (pszProtName) * sizeof (TCHAR);
		}
		else
		{
			nChoice = CLIENT_ONLY;
			cbSize += sizeof (c_szResolveClientOnly);
		}
	}

	TCHAR *pszFilter = (TCHAR *) MemAlloc (cbSize);
	if (pszFilter != NULL)
	{
		switch (nChoice)
		{
		case CLIENT_APP_PROT:
			wsprintf (pszFilter, &c_szResolveClientAppProt[0],
						pszClientName, pszAppName, pszProtName);
			break;
		case CLIENT_APP:
			wsprintf (pszFilter, &c_szResolveClientApp[0],
						pszClientName, pszAppName);
			break;
		case CLIENT_PROT:
			wsprintf (pszFilter, &c_szResolveClientProt[0],
						pszClientName, pszProtName);
			break;
		case CLIENT_ONLY:
			wsprintf (pszFilter, &c_szResolveClientOnly[0],
						pszClientName);
			break;
		default:
			MyAssert (FALSE);
			break;
		}
	}

	return pszFilter;
}


const TCHAR c_szResolveProtFilterFormat[] =
TEXT ("(&(objectClass=RTPerson)(cn=%s)(sappid=%s)(sprotid=%s))");
TCHAR *ProtCreateResolveFilter ( TCHAR *pszUserName, TCHAR *pszAppName, TCHAR *pszProtName )
{
	TCHAR *pszFilter = (TCHAR *) MemAlloc (sizeof (c_szResolveProtFilterFormat) +
										(lstrlen (pszUserName) + 1) * sizeof (TCHAR) +
										(lstrlen (pszAppName) + 1) * sizeof (TCHAR) +
										(lstrlen (pszProtName) + 1) * sizeof (TCHAR));
	if (pszFilter != NULL)
	{
		wsprintf (pszFilter, &c_szResolveProtFilterFormat[0], pszUserName, pszAppName, pszProtName);
	}

	return pszFilter;
}


TCHAR *MtgCreateEnumMembersFilter ( TCHAR *pszMtgName )
{
	return MtgCreateResolveFilter (pszMtgName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\spconn.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spconn.cpp
	Content:	This file contains the ldap connection object.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"
#include "rpcdce.h"

const TCHAR c_szRTPerson[] = TEXT ("RTPerson");
const TCHAR c_szRTConf[] = TEXT ("Conference");

const TCHAR c_szDefClientBaseDN[] = TEXT ("objectClass=RTPerson");
const TCHAR c_szDefMtgBaseDN[] = TEXT ("objectClass=Conference");

const TCHAR c_szDefO[] = TEXT ("Microsoft");
const TCHAR c_szEmptyString[] = TEXT ("");


SP_CSessionContainer *g_pSessionContainer = NULL;


/* ---------- public methods ----------- */


SP_CSession::
SP_CSession ( VOID ) :
	m_cRefs (0),
	m_dwSignature (0),
	m_ld (NULL),
	m_fUsed (FALSE)
{
	::ZeroMemory (&m_ServerInfo, sizeof (m_ServerInfo));
}


SP_CSession::
~SP_CSession ( VOID )
{
	InternalCleanup ();
}


/* ---------- public methods ----------- */


HRESULT SP_CSession::
Disconnect ( VOID )
{
	// if a connection is available, then simply the existing one
	if (m_dwSignature != LDAP_CONN_SIGNATURE)
	{
		return ILS_E_HANDLE;
	}

	MyAssert (m_cRefs > 0);

	HRESULT hr = S_OK;
	if (::InterlockedDecrement (&m_cRefs) == 0)
	{
		// m_cRefs == 0 now
		MyAssert (m_ld != NULL);

		InternalCleanup ();
		hr = S_OK;
	}

	return hr;
}


/* ---------- protected methods ----------- */


VOID SP_CSession::
FillAuthIdentity ( SEC_WINNT_AUTH_IDENTITY *pai )
{
	// Clean it up
	//
	::ZeroMemory (pai, sizeof (*pai));

	// Fill in NT auth identity
	//
	if ((pai->User = (BYTE *) m_ServerInfo.pszLogonName) != NULL)
		pai->UserLength = lstrlen (m_ServerInfo.pszLogonName);

	if ((pai->Domain = (BYTE *) m_ServerInfo.pszDomain) != NULL)
		pai->DomainLength = lstrlen (m_ServerInfo.pszDomain);

	if ((pai->Password = (BYTE *) m_ServerInfo.pszLogonPassword) != NULL)
		pai->PasswordLength = lstrlen (m_ServerInfo.pszLogonPassword);

#ifdef _UNICODE
	pai->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
#else
	pai->Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
#endif
}

				
HRESULT SP_CSession::
Bind ( BOOL fAbortable )
{
	ULONG uLdapAuthMethod = LDAP_AUTH_SIMPLE;
	TCHAR *pszLogonName = m_ServerInfo.pszLogonName;
	TCHAR *pszLogonPassword = m_ServerInfo.pszLogonPassword;
	SEC_WINNT_AUTH_IDENTITY ai;
	BOOL fSyncBind = TRUE;
	HRESULT hr = S_OK;

	switch (m_ServerInfo.AuthMethod)
	{
	default:
		MyAssert (FALSE);
		// Fall through...

	case ILS_AUTH_ANONYMOUS:
		fSyncBind = FALSE;
		uLdapAuthMethod = LDAP_AUTH_SIMPLE;
		pszLogonName = STR_EMPTY;
		pszLogonPassword = STR_EMPTY;
		break;

	case ILS_AUTH_CLEAR_TEXT:
		fSyncBind = FALSE;
		uLdapAuthMethod = LDAP_AUTH_SIMPLE;
		break;

	case ILS_AUTH_NTLM:
		uLdapAuthMethod = LDAP_AUTH_NTLM;
		FillAuthIdentity (&ai);
		pszLogonName = NULL;
		pszLogonPassword = (TCHAR *) &ai;
		break;

	case ILS_AUTH_DPA:
		uLdapAuthMethod = LDAP_AUTH_DPA;
		break;

	case ILS_AUTH_MSN:
		uLdapAuthMethod = LDAP_AUTH_MSN;
		break;

	case ILS_AUTH_SICILY:
		uLdapAuthMethod = LDAP_AUTH_SICILY;
		break;

	case ILS_AUTH_SSPI:
		uLdapAuthMethod = LDAP_AUTH_SSPI;
		break;
	}

	if (fSyncBind)
	{
		INT nRetCode = ::ldap_bind_s (m_ld, pszLogonName,
									pszLogonPassword,
									uLdapAuthMethod);
		hr = (nRetCode == LDAP_SUCCESS) ? S_OK : ILS_E_BIND;
	}
	else
	{
		INT uMsgID = ::ldap_bind (m_ld, pszLogonName,
									pszLogonPassword,
									uLdapAuthMethod);

		INT ResultType;
		LDAP_TIMEVAL TimeVal;
		LDAPMessage *pMsg;

		LONG i, nTimeoutInSecond;
		nTimeoutInSecond = GetServerTimeoutInSecond ();
	    for (i = 0; i < nTimeoutInSecond; i++)
		{
			TimeVal.tv_usec = 0;
			TimeVal.tv_sec = 1;
			pMsg = NULL;

			ResultType = ::ldap_result (m_ld, uMsgID, LDAP_MSG_ALL, &TimeVal, &pMsg);
			if (ResultType == LDAP_RES_BIND)
			{
				break;
			}
			else
			{
				// deal with timeout or error
				if (ResultType == 0)
				{
					MyAssert (g_pReqQueue != NULL);
					if (fAbortable && g_pReqQueue != NULL &&
						g_pReqQueue->IsCurrentRequestCancelled ())
					{
						hr = ILS_E_ABORT;
					}
					else
					{
						continue;
					}
				}
				else
				if (ResultType == -1)
				{
					hr = ILS_E_BIND;
				}
				else
				{
                                        // lonchanc: AndyHe said the return value
                                        // can be anything. Thus, removed the assertion.
					hr = ILS_E_FAIL;
				}

				::ldap_abandon (m_ld, uMsgID);
				::ldap_unbind (m_ld);
				m_ld = NULL;
				return hr;
			}
		}

		// Check if it times out
		//
		if (i >= nTimeoutInSecond)
		{
			hr = ILS_E_TIMEOUT;
			::ldap_abandon (m_ld, uMsgID);
			::ldap_unbind (m_ld);
			m_ld = NULL;
			return hr;
		}

		MyAssert (pMsg != NULL);

		::ldap_msgfree (pMsg);
		hr = S_OK;
	}

	return hr;
}


HRESULT SP_CSession::
Connect (
	SERVER_INFO			*pInfo,
	ULONG				cConns,
	BOOL				fAbortable )
{
	// If a connection is available,
	// then simply the existing one
	//
	if (m_dwSignature == LDAP_CONN_SIGNATURE)
	{
		m_cRefs += cConns;
		return S_OK;
	}

	// We need to create a new connection
	// let's cache the server info
	//
	HRESULT hr = ::IlsCopyServerInfo (&m_ServerInfo, pInfo);
	if (hr != S_OK)
		return hr;

	// Connect to ldap server
	//
	ULONG ulPort = LDAP_PORT;
	LPTSTR pszServerName = My_strdup(m_ServerInfo.pszServerName);
	if (NULL == pszServerName)
	{
		return E_OUTOFMEMORY;
	}
	LPTSTR pszSeparator = My_strchr(pszServerName, _T(':'));
	if (NULL != pszSeparator)
	{
		*pszSeparator = _T('\0');
		ulPort = GetStringLong(pszSeparator + 1);
	}
	
	m_ld = ::ldap_open (pszServerName, ulPort);
	MemFree(pszServerName);
	if (m_ld == NULL)
	{
		// We need to know why ldap_open() failed.
		// Is it because server name is not valid?
		// Or is it because server does not support LDAP?
		//
		// hr = (gethostbyname (m_ServerInfo.pszServerName) != NULL) ?
		// Winsock will set ERROR_OPEN_FAILED, but wldap32.dll sets ERROR_HOST_UNREACHABLE
		// The down side is that when the server was down, the client will try ULP.
		//
		DWORD dwErr = ::GetLastError ();
		MyDebugMsg ((ZONE_REQ, "ULS: ldap_open failed, err=%lu)\r\n", dwErr));
		hr = (dwErr == ERROR_OPEN_FAILED || dwErr == ERROR_HOST_UNREACHABLE) ?
			ILS_E_SERVER_SERVICE : ILS_E_SERVER_NAME;
		goto MyExit;
	}

	// Do the bind
	//
	hr = Bind (fAbortable);
	if (hr == S_OK)
	{
		// remember the handle and increment the reference count
		m_cRefs = cConns;
		m_dwSignature = LDAP_CONN_SIGNATURE;
	}

MyExit:

	MyDebugMsg ((ZONE_CONN, "ILS: Connect: hr=0x%p, m_ld=0x%p, server=%s\r\n", (DWORD) hr, m_ld, m_ServerInfo.pszServerName));

	if (hr != S_OK)
	{
		InternalCleanup ();
	}

	return hr;
}


/* ---------- private methods ----------- */


VOID SP_CSession::
InternalCleanup ( VOID )
{
	if (IsUsed ())
	{
		MyDebugMsg ((ZONE_CONN, "ILS: InternalCleanup: m_ld=0x%p, server=%s\r\n", m_ld, m_ServerInfo.pszServerName));

		// Clean up these two ASAP because ldap_unbind may delay
		//
		m_dwSignature = 0;
		::IlsFreeServerInfo (&m_ServerInfo);

		// Free the ldap infor
		//
		if (m_ld != NULL)
		{
			ldap_unbind (m_ld);
			m_ld = NULL;
		}

		// Clear it out
		//
		ClearUsed ();
	}
}


/* ==================== container ========================= */


/* ---------- public methods ----------- */


SP_CSessionContainer::
SP_CSessionContainer ( VOID ) :
	m_cEntries (0),
	m_aConns (NULL)
{
	::MyInitializeCriticalSection (&m_csSessContainer);
}


SP_CSessionContainer::
~SP_CSessionContainer ( VOID )
{
	::MyDeleteCriticalSection (&m_csSessContainer);
	m_cEntries = 0;
	delete [] m_aConns;
}


HRESULT SP_CSessionContainer::
Initialize (
	ULONG			cEntries,
	SP_CSession		*ConnArr )
{
	m_cEntries = cEntries;
	m_aConns = new SP_CSession[cEntries];
	return ((m_aConns != NULL) ? S_OK : ILS_E_MEMORY);
}


HRESULT SP_CSessionContainer::
GetSession (
	SP_CSession			**ppConn,
	SERVER_INFO			*pInfo,
	ULONG				cConns,
	BOOL				fAbortable )
{
	MyAssert (ppConn != NULL);
	MyAssert (pInfo != NULL);

	*ppConn = NULL;

	HRESULT hr;

	WriteLock ();

	// The first pass is to see any existing connection
	//
	for (ULONG i = 0; i < m_cEntries; i++)
	{
		if (m_aConns[i].IsUsed ())
		{
			if (m_aConns[i].SameServerInfo (pInfo))
			{
				*ppConn = &m_aConns[i];
				hr = m_aConns[i].Connect (pInfo, cConns, fAbortable);
				goto MyExit;
			}
		}
	}

	// The second pass is to see any empty slot
	//
	for (i = 0; i < m_cEntries; i++)
	{
		if (! m_aConns[i].IsUsed ())
		{
			m_aConns[i].SetUsed ();
			*ppConn = &m_aConns[i];
			hr = m_aConns[i].Connect (pInfo, cConns, fAbortable);
			goto MyExit;
		}
	}

	hr = ILS_E_MEMORY;

MyExit:

	WriteUnlock ();
	return hr;
}


/* ---------- protected methods ----------- */

/* ---------- private methods ----------- */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\spanyatt.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spanyatt.cpp
	Content:	This file contains the arbitrary-attribute object.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"


/* ---------- public methods ----------- */


UlsLdap_CAnyAttrs::UlsLdap_CAnyAttrs ( VOID )
{
	m_cAttrs = 0;
	m_AttrList = NULL;
}


UlsLdap_CAnyAttrs::~UlsLdap_CAnyAttrs ( VOID )
{
	FreeAttrList (m_AttrList);
}


/* ---------- protected methods ----------- */


HRESULT UlsLdap_CAnyAttrs::SetAnyAttrs (
	ULONG 		*puRespID,
	ULONG		*puMsgID,
	ULONG		uNotifyMsg,
	ULONG		cAttrs,
	TCHAR		*pszAttrs,
	ULONG		cPrefix,
	TCHAR		*pszPrefix,
	LONG		ModOp,
	SERVER_INFO	*pServerInfo,
	TCHAR		*pszDN )
{
	MyAssert (puRespID != NULL || puMsgID != NULL);
	MyAssert (cAttrs != 0);
	MyAssert (pszAttrs != NULL);
	MyAssert (cPrefix != 0);
	MyAssert (pszPrefix != NULL);
	MyAssert (pServerInfo != NULL);
	MyAssert (pszDN != NULL);
	MyAssert (ModOp == LDAP_MOD_REPLACE || ModOp == LDAP_MOD_ADD);

	// create a prefix for each attr name in the following pair
	pszAttrs = PrefixNameValueArray (TRUE, cAttrs, pszAttrs);
	if (pszAttrs == NULL)
		return ULS_E_MEMORY;

	// build modify array for ldap_modify()
	LDAPMod **ppMod = NULL;
	HRESULT hr = SetAttrsAux (cAttrs, pszAttrs,	cPrefix, pszPrefix, ModOp, &ppMod);
	if (hr != S_OK)
	{
		MemFree (pszAttrs);
		return hr;
	}
	MyAssert (ppMod != NULL);

	// so far, we are done with local preparation

	// get the connection object
	UlsLdap_CSession *pSession = NULL;
	hr = g_pSessionContainer->GetSession (&pSession, pServerInfo);
	if (hr != S_OK)
	{
		MemFree (pszAttrs);
		MemFree (ppMod);
		return hr;
	}
	MyAssert (pSession != NULL);

	// get the ldap session
	LDAP *ld = pSession->GetLd ();
	MyAssert (ld != NULL);

	// send the data over the wire
	ULONG uMsgID = ldap_modify (ld, pszDN, ppMod);
	MemFree (pszAttrs);
	MemFree (ppMod);
	if (uMsgID == -1)
	{
		hr = ::LdapError2Hresult (ld->ld_errno);
		pSession->Disconnect ();
		return hr;
	}

	// if the caller does not ask for notify id
	// then do not queue a pending info
	if (puRespID != NULL)
	{
		PENDING_INFO PendingInfo;
		::FillDefPendingInfo (&PendingInfo, ld, uMsgID, INVALID_MSG_ID);
		PendingInfo.uLdapResType = LDAP_RES_MODIFY;
		PendingInfo.uNotifyMsg = uNotifyMsg;

		// queue it
		hr = g_pPendingQueue->EnterRequest (pSession, &PendingInfo);
		if (hr != S_OK)
		{
			ldap_abandon (ld, uMsgID);
			pSession->Disconnect ();
			MyAssert (FALSE);
		}

		*puRespID = PendingInfo.uRespID;
	}

	if (puMsgID)
		*puMsgID = uMsgID;

	return hr;
}


HRESULT UlsLdap_CAnyAttrs::RemoveAllAnyAttrs (
	ULONG		*puMsgID,
	ULONG		cPrefix,
	TCHAR		*pszPrefix,
	SERVER_INFO	*pServerInfo,
	TCHAR		*pszDN )
{
	ULONG cbAttrs = 0;
	ULONG cAttrs = 0;
	
	for (ANY_ATTR *p = m_AttrList; p != NULL; p = p->next)
	{
		cAttrs++;
		if (p->pszAttrName != NULL)
			cbAttrs += (lstrlen (p->pszAttrName) + 1) * sizeof (TCHAR);
	}

	MyAssert (cAttrs == m_cAttrs);

	TCHAR *pszAttrs = (TCHAR *) MemAlloc (cbAttrs);
	if (pszAttrs == NULL)
		return ULS_E_MEMORY;

	TCHAR *psz = pszAttrs;
	for (p = m_AttrList; p != NULL; p = p->next)
	{
		if (p->pszAttrName != NULL)
		{
			lstrcpy (psz, p->pszAttrName);
			psz += lstrlen (psz) + 1;
		}
	}

	HRESULT hr = RemoveAnyAttrsEx (	NULL,
									puMsgID,
									0,
									cAttrs,
									pszAttrs,
									cPrefix,
									pszPrefix,
									pServerInfo,
									pszDN);
	MemFree (pszAttrs);
	return hr;
}


HRESULT UlsLdap_CAnyAttrs::RemoveAnyAttrs (
	ULONG 		*puRespID,
	ULONG		*puMsgID,
	ULONG		uNotifyMsg,
	ULONG		cAttrs,
	TCHAR		*pszAttrs,
	ULONG		cPrefix,
	TCHAR		*pszPrefix,
	SERVER_INFO	*pServerInfo,
	TCHAR		*pszDN)
{
	MyAssert (puRespID != NULL || puMsgID != NULL);
	MyAssert (cAttrs != 0);
	MyAssert (pszAttrs != NULL);
	MyAssert (cPrefix != 0);
	MyAssert (pszPrefix != NULL);
	MyAssert (pServerInfo != NULL);
	MyAssert (pszDN != NULL);

	pszAttrs = PrefixNameValueArray (FALSE, cAttrs, pszAttrs);
	if (pszAttrs == NULL)
		return ULS_E_MEMORY;

	HRESULT hr = RemoveAnyAttrsEx (	puRespID,
									puMsgID,
									uNotifyMsg,
									cAttrs,
									pszAttrs,
									cPrefix,
									pszPrefix,
									pServerInfo,
									pszDN);
	MemFree (pszAttrs);
	return hr;
}


HRESULT UlsLdap_CAnyAttrs::RemoveAnyAttrsEx (
	ULONG 		*puRespID,
	ULONG		*puMsgID,
	ULONG		uNotifyMsg,
	ULONG		cAttrs,
	TCHAR		*pszAttrs,
	ULONG		cPrefix,
	TCHAR		*pszPrefix,
	SERVER_INFO	*pServerInfo,
	TCHAR		*pszDN)
{
	MyAssert (puRespID != NULL || puMsgID != NULL);
	MyAssert (cAttrs != 0);
	MyAssert (pszAttrs != NULL);
	MyAssert (cPrefix != 0);
	MyAssert (pszPrefix != NULL);
	MyAssert (pServerInfo != NULL);
	MyAssert (pszDN != NULL);

	// build modify array for ldap_modify()
	LDAPMod **ppMod = NULL;
	HRESULT hr = RemoveAttrsAux (cAttrs, pszAttrs, cPrefix, pszPrefix, &ppMod);
	if (hr != S_OK)
		return hr;
	MyAssert (ppMod != NULL);

	// so far, we are done with local preparation

	// get the connection object
	UlsLdap_CSession *pSession = NULL;
	hr = g_pSessionContainer->GetSession (&pSession, pServerInfo);
	if (hr != S_OK)
	{
		MemFree (ppMod);
		return hr;
	}
	MyAssert (pSession != NULL);

	// get the ldap session
	LDAP *ld = pSession->GetLd ();
	MyAssert (ld != NULL);

	// send the data over the wire
	ULONG uMsgID = ldap_modify (ld, pszDN, ppMod);
	MemFree (ppMod);
	if (uMsgID == -1)
	{
		hr = ::LdapError2Hresult (ld->ld_errno);
		pSession->Disconnect ();
		return hr;
	}

	// if the caller does not ask for notify id
	// then do not queue a pending info
	if (puRespID != NULL)
	{
		PENDING_INFO PendingInfo;
		::FillDefPendingInfo (&PendingInfo, ld, uMsgID, INVALID_MSG_ID);
		PendingInfo.uLdapResType = LDAP_RES_MODIFY;
		PendingInfo.uNotifyMsg = uNotifyMsg;

		hr = g_pPendingQueue->EnterRequest (pSession, &PendingInfo);
		if (hr != S_OK)
		{
			ldap_abandon (ld, uMsgID);
			pSession->Disconnect ();
			MyAssert (FALSE);
		}

		*puRespID = PendingInfo.uRespID;
	}
	else
	{
		if (puMsgID != NULL)
			*puMsgID = uMsgID;
	}

	return hr;
}


/* ---------- private methods ----------- */


HRESULT UlsLdap_CAnyAttrs::SetAttrsAux (
	ULONG		cAttrs,
	TCHAR		*pszAttrs,
	ULONG		cPrefix,
	TCHAR		*pszPrefix,
	LONG		ModOp,
	LDAPMod		***pppMod )
{
	MyAssert (cAttrs != 0);
	MyAssert (pszAttrs != NULL);
	MyAssert (cPrefix != 0);
	MyAssert (pszPrefix != NULL);
	MyAssert (ModOp == LDAP_MOD_REPLACE || ModOp == LDAP_MOD_ADD);
	MyAssert (pppMod != NULL);

	// create modify list
	ULONG cTotal = cPrefix + cAttrs;
	ULONG cbMod = ::IlsCalcModifyListSize (cTotal);
	*pppMod = (LDAPMod **) MemAlloc (cbMod);
	if (*pppMod == NULL)
	{
		return ULS_E_MEMORY;
	}

	LDAPMod *pMod;
	for (ULONG i = 0; i < cTotal; i++)
	{
		pMod = ::IlsGetModifyListMod (pppMod, cTotal, i);
		(*pppMod)[i] = pMod;
		pMod->mod_values = (TCHAR **) (pMod + 1);

		if (i < cPrefix)
		{
			pMod->mod_op = LDAP_MOD_REPLACE;
			pMod->mod_type = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
			*(pMod->mod_values) = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
		}
		else
		{
			pMod->mod_op = ModOp;
			if (LocateAttr (pszAttrs) == NULL)
			{
				pMod->mod_op = LDAP_MOD_ADD;
				m_cAttrs++;
			}
			if (pMod->mod_op == LDAP_MOD_ADD)
			{
				ULONG cbAttrSize = sizeof (ANY_ATTR) + sizeof (TCHAR) *
									(lstrlen (pszAttrs) + 1);
				ANY_ATTR *pNew = (ANY_ATTR *) MemAlloc (cbAttrSize);
				if (pNew == NULL)
				{
					return ULS_E_MEMORY;
				}
				// fill in attr name
				pNew->pszAttrName = (TCHAR *) (pNew + 1);
				lstrcpy (pNew->pszAttrName, pszAttrs);
				// link to the list
				pNew->prev = NULL;
				pNew->next = m_AttrList;
				m_AttrList = pNew;
			}
			pMod->mod_type = pszAttrs;
			pszAttrs += lstrlen (pszAttrs) + 1;
			*(pMod->mod_values) = pszAttrs;
			pszAttrs += lstrlen (pszAttrs) + 1;
		}
	}

	(*pppMod)[cTotal] = NULL;
	::IlsFixUpModOp ((*pppMod)[0], ModOp, ISBU_MODOP_MODIFY_APP);
	return S_OK;
}


HRESULT UlsLdap_CAnyAttrs::RemoveAttrsAux (
	ULONG		cAttrs,
	TCHAR		*pszAttrs,
	ULONG		cPrefix,
	TCHAR		*pszPrefix,
	LDAPMod		***pppMod )
{
	MyAssert (cAttrs != 0);
	MyAssert (pszAttrs != NULL);
	MyAssert (cPrefix != 0);
	MyAssert (pszPrefix != NULL);
	MyAssert (pppMod != NULL);

	// create modify list
	ULONG cTotal = cPrefix + cAttrs;
	ULONG cbMod = ::IlsCalcModifyListSize (cTotal);
	*pppMod = (LDAPMod **) MemAlloc (cbMod);
	if (*pppMod == NULL)
	{
		return ULS_E_MEMORY;
	}

	LDAPMod *pMod;
	for (ULONG i = 0; i < cTotal; i++)
	{
		pMod = ::IlsGetModifyListMod (pppMod, cTotal, i);
		(*pppMod)[i] = pMod;

		if (i < cPrefix)
		{
			pMod->mod_op = LDAP_MOD_REPLACE;
			pMod->mod_type = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
			pMod->mod_values = (TCHAR **) (pMod + 1);
			*(pMod->mod_values) = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
		}
		else
		{
			pMod->mod_op = LDAP_MOD_DELETE;
			RemoveAttrFromList (pszAttrs);
			pMod->mod_type = pszAttrs;
			pszAttrs += lstrlen (pszAttrs) + 1;
		}
	}

	(*pppMod)[cTotal] = NULL;
	::IlsFixUpModOp ((*pppMod)[0], LDAP_MOD_REPLACE, ISBU_MODOP_MODIFY_APP);
	return S_OK;
}


VOID UlsLdap_CAnyAttrs::RemoveAttrFromList ( TCHAR *pszAttrName )
{
	ANY_ATTR *pOld = LocateAttr (pszAttrName);
	if (pOld != NULL)
	{
		// remove it
		if (pOld->prev != NULL)
		{
			pOld->prev->next = pOld->next;
		}
		else
		{
			m_AttrList = pOld->next;
		}
		if (pOld->next != NULL)
		{
			pOld->next->prev = pOld->prev;
		}

		MyAssert (m_cAttrs != 0);
		m_cAttrs--;
	}
}


VOID UlsLdap_CAnyAttrs::FreeAttrList ( ANY_ATTR *AttrList )
{
	ANY_ATTR *pCurr, *pNext;
	for (pCurr = AttrList; pCurr != NULL; pCurr = pNext)
	{
		pNext = pCurr->next;
		MemFree (pCurr);
	}
}


ANY_ATTR *UlsLdap_CAnyAttrs::LocateAttr ( TCHAR *pszAttrName )
{
	ANY_ATTR *pAttr;
	for (pAttr = m_AttrList; pAttr != NULL; pAttr = pAttr->next)
	{
		if (! My_lstrcmpi (pszAttrName, pAttr->pszAttrName))
		{
			break;
		}
	}
	return pAttr;
}

// const TCHAR c_szAnyAttrPrefix[] = TEXT ("ulsaan_");
const TCHAR c_szAnyAttrPrefix[] = TEXT ("ILSA");
#define SIZE_ANY_ATTR_PREFIX	(sizeof (c_szAnyAttrPrefix) / sizeof (TCHAR))

const TCHAR *SkipAnyAttrNamePrefix ( const TCHAR *pszAttrName )
{
	MyAssert (pszAttrName != NULL);

	const TCHAR *psz = IsAnyAttrName (pszAttrName);
	if (psz == NULL)
	{
		MyAssert (FALSE);
		psz = pszAttrName;
	}

	return psz;
}

const TCHAR *IsAnyAttrName ( const TCHAR *pszAttrName )
{
	BOOL fRet = FALSE;
	TCHAR *psz = (TCHAR *) pszAttrName;

	if (pszAttrName != NULL)
	{
		if (lstrlen (pszAttrName) > SIZE_ANY_ATTR_PREFIX)
		{
			TCHAR c = pszAttrName[SIZE_ANY_ATTR_PREFIX-1];
			psz[SIZE_ANY_ATTR_PREFIX-1] = TEXT ('\0');
			fRet = (My_lstrcmpi (pszAttrName, &c_szAnyAttrPrefix[0]) == 0);
			psz[SIZE_ANY_ATTR_PREFIX-1] = c;
		}
	}

	return (fRet ? &pszAttrName[SIZE_ANY_ATTR_PREFIX-1] : NULL);
}


TCHAR *PrefixNameValueArray ( BOOL fPair, ULONG cAttrs, const TCHAR *pszAttrs )
{
	if (cAttrs == 0 || pszAttrs == NULL)
	{
		MyAssert (FALSE);
		return NULL;
	}

	// compute the total size required
	ULONG cbTotalSize = 0;
	ULONG cbThisSize;
	TCHAR *pszSrc = (TCHAR *) pszAttrs;
	for (ULONG i = 0; i < cAttrs; i++)
	{
		// get name size
		cbThisSize = lstrlen (pszSrc) + 1;
		pszSrc += lstrlen (pszSrc) + 1;

		// get value size as needed
		if (fPair)
		{
			cbThisSize += lstrlen (pszSrc) + 1;
			pszSrc += lstrlen (pszSrc) + 1;
		}

		// adjust the size
		cbThisSize += SIZE_ANY_ATTR_PREFIX;
		cbThisSize *= sizeof (TCHAR);

		// accumulate it
		cbTotalSize += cbThisSize;
	}

	// allocate the new buffer
	TCHAR *pszPrefixAttrs = (TCHAR *) MemAlloc (cbTotalSize);
	if (pszPrefixAttrs == NULL)
		return NULL;

	// copy the strings over to the new buffer
	pszSrc = (TCHAR *) pszAttrs;
	TCHAR *pszDst = pszPrefixAttrs;
	for (i = 0; i < cAttrs; i++)
	{
		// copy prefix
		lstrcpy (pszDst, &c_szAnyAttrPrefix[0]);
		pszDst += lstrlen (pszDst); // no plus 1

		// copy name
		lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
		pszSrc += lstrlen (pszSrc) + 1;

		// copy value as needed
		if (fPair)
		{
			lstrcpy (pszDst, pszSrc);
			pszDst += lstrlen (pszDst) + 1;
			pszSrc += lstrlen (pszSrc) + 1;
		}
	}

	return pszPrefixAttrs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\spclient.h ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spclient.h
	Content:	This file contains the client object definition.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#ifndef _ILS_SP_CLIENTOBJ_H_
#define _ILS_SP_CLIENTOBJ_H_

#include <pshpack8.h>

// Enumeration constants to represent client object members
//
enum
{
	/* -- the following is for user -- */

	ENUM_CLIENTATTR_CN,
	ENUM_CLIENTATTR_FIRST_NAME,
	ENUM_CLIENTATTR_LAST_NAME,
	ENUM_CLIENTATTR_EMAIL_NAME,
	ENUM_CLIENTATTR_CITY_NAME,
	ENUM_CLIENTATTR_COMMENT,
	ENUM_CLIENTATTR_IP_ADDRESS,
	ENUM_CLIENTATTR_FLAGS,
	ENUM_CLIENTATTR_C,

	/* -- the following is for app -- */

	ENUM_CLIENTATTR_APP_NAME,
	ENUM_CLIENTATTR_APP_MIME_TYPE,
	ENUM_CLIENTATTR_APP_GUID,

	ENUM_CLIENTATTR_PROT_NAME,
	ENUM_CLIENTATTR_PROT_MIME,
	ENUM_CLIENTATTR_PROT_PORT,

	/* -- the above are resolvable -- */

	ENUM_CLIENTATTR_CLIENT_SIG,
	ENUM_CLIENTATTR_TTL,

	/* -- the above are changeable standard attributes for RTPerson -- */

	/* --- DO NOT ADD NEW ATTRIBUTES BELOW THIS LINE --- */
	/* --- COUNT_ENUM_REG_USER relies on this ---- */

	ENUM_CLIENTATTR_OBJECT_CLASS,
	ENUM_CLIENTATTR_O,
	COUNT_ENUM_CLIENTATTR
};

// Derived constants
//
#define COUNT_ENUM_REG_APP				6
#define COUNT_ENUM_SET_APP_INFO			16
#define COUNT_ENUM_SKIP_APP_ATTRS		COUNT_ENUM_REG_APP

#define COUNT_ENUM_CLIENT_INFO			(ENUM_CLIENTATTR_TTL + 1)
#define COUNT_ENUM_REG_USER				(COUNT_ENUM_CLIENTATTR - 2 - COUNT_ENUM_SKIP_APP_ATTRS) // excluding o and objectClass
#define COUNT_ENUM_SET_USER_INFO		(ENUM_CLIENTATTR_C + 1)

#define COUNT_ENUM_DIR_CLIENT_INFO		(ENUM_CLIENTATTR_C + 1)	// count of attrs in dir dlg
#define COUNT_ENUM_RES_CLIENT_INFO		(ENUM_CLIENTATTR_CLIENT_SIG - 1) // count of attrs resolvable


// Shorthands for commonly used names
//
extern const TCHAR *c_apszClientStdAttrNames[];
#define STR_CLIENT_CN		(TCHAR *) c_apszClientStdAttrNames[ENUM_CLIENTATTR_CN]
#define STR_CLIENT_O		(TCHAR *) c_apszClientStdAttrNames[ENUM_CLIENTATTR_O]
#define STR_CLIENT_C		(TCHAR *) c_apszClientStdAttrNames[ENUM_CLIENTATTR_C]
#define STR_CLIENT_IP_ADDR	(TCHAR *) c_apszClientStdAttrNames[ENUM_CLIENTATTR_IP_ADDRESS]
#define STR_CLIENT_TTL		(TCHAR *) c_apszClientStdAttrNames[ENUM_CLIENTATTR_TTL]
#define STR_CLIENT_APP_NAME	(TCHAR *) c_apszClientStdAttrNames[ENUM_CLIENTATTR_APP_NAME]

// Flags to indicate which fields are valid in CLIENT_INFO
//
#define CLIENTOBJ_F_CN				0x0001
#define CLIENTOBJ_F_FIRST_NAME		0x0002
#define CLIENTOBJ_F_LAST_NAME		0x0004
#define CLIENTOBJ_F_EMAIL_NAME		0x0008
#define CLIENTOBJ_F_CITY_NAME		0x0010
#define CLIENTOBJ_F_C				0x0020
#define CLIENTOBJ_F_COMMENT			0x0040
#define CLIENTOBJ_F_IP_ADDRESS		0x0080
#define CLIENTOBJ_F_FLAGS			0x0100

#define CLIENTOBJ_F_APP_NAME		0x1000
#define CLIENTOBJ_F_APP_MIME_TYPE	0x2000
#define CLIENTOBJ_F_APP_GUID		0x4000

#define CLIENTOBJ_F_USER_MASK		0x0FFF
#define CLIENTOBJ_F_APP_MASK		0xF000

// Client Info structure
//
typedef struct
{
	DWORD		dwFlags;
	// the following is to cache attributes
	TCHAR		*apszStdAttrValues[COUNT_ENUM_CLIENTATTR];
	ANY_ATTRS	AnyAttrs;
	// the following is scratch buffers
	TCHAR		szIPAddress[INTEGER_STRING_LENGTH];
	TCHAR		szFlags[INTEGER_STRING_LENGTH];
	TCHAR		szTTL[INTEGER_STRING_LENGTH];
	TCHAR		szClientSig[INTEGER_STRING_LENGTH];
	TCHAR		szGuid[sizeof (GUID) * 2 + 2];
}
	CLIENT_INFO;

// A flag to indicate that this client object is valid
//
#define CLIENTOBJ_SIGNATURE	((ULONG) 0x12345678UL)


// Client class
//
class SP_CClient
{
	friend class SP_CRefreshScheduler;
	friend class SP_CProtocol;

public:

	SP_CClient ( DWORD_PTR dwContext );
	~SP_CClient ( VOID );

	ULONG AddRef ( VOID );
	ULONG Release ( VOID );

	HRESULT Register ( ULONG uRespID, SERVER_INFO *pServerInfo, LDAP_CLIENTINFO *pInfo );
	HRESULT UnRegister ( ULONG uRespID );

	HRESULT SetAttributes ( ULONG uRespID, LDAP_CLIENTINFO *pInfo );
	HRESULT UpdateIPAddress ( VOID );

	VOID SetRegNone ( VOID ) { m_RegStatus = ILS_REG_STATUS_NONE; }
	VOID SetRegLocally ( VOID ) { m_RegStatus = ILS_REG_STATUS_LOCALLY; }
	VOID SetRegRemotely ( VOID ) { m_RegStatus = ILS_REG_STATUS_REMOTELY; }

	BOOL IsRegistered ( VOID ) { return (m_RegStatus > ILS_REG_STATUS_NONE); }
	BOOL IsRegLocally ( VOID ) { return (m_RegStatus == ILS_REG_STATUS_LOCALLY); }
	BOOL IsRegRemotely ( VOID ) { return (m_RegStatus == ILS_REG_STATUS_REMOTELY); }

	BOOL IsValidObject ( VOID ) { return m_uSignature == CLIENTOBJ_SIGNATURE; }

	SERVER_INFO *GetServerInfo ( VOID ) { return &m_ServerInfo; }

	ULONG GetTTL ( VOID ) { return m_uTTL; }
	DWORD_PTR GetContext ( VOID ) { return m_dwContext; }

protected:

	HRESULT AddProtocol ( ULONG uNotifyMsg, ULONG uRespID, SP_CProtocol *pProt );
	HRESULT RemoveProtocol ( ULONG uNotifyMsg, ULONG uRespID, SP_CProtocol *pProt );
	HRESULT UpdateProtocols ( ULONG uNotifyMsg, ULONG uRespID, SP_CProtocol *pProt );

	TCHAR *GetDN ( VOID ) { return m_pszDN; }

	ULONG GetAppPrefixCount ( VOID ) { return 2; }
	TCHAR *GetAppPrefixString ( VOID ) { return m_pszAppPrefix; }

	HRESULT SendRefreshMsg ( VOID );

private:

	HRESULT RegisterUser ( VOID );
	HRESULT RegisterApp ( VOID );
	HRESULT UnRegisterUser ( VOID );
	HRESULT UnRegisterApp ( VOID );

	HRESULT SetUserAttributes ( VOID );
	HRESULT SetAppAttributes ( VOID );

	HRESULT CacheClientInfo ( LDAP_CLIENTINFO *pInfo );

	HRESULT CreateRegUserModArr ( LDAPMod ***pppMod );
	HRESULT CreateRegAppModArr ( LDAPMod ***pppMod );

	HRESULT CreateSetUserAttrsModArr ( LDAPMod ***pppMod );
	HRESULT CreateSetAppAttrsModArr ( LDAPMod ***pppMod );

	HRESULT CreateSetProtModArr ( LDAPMod ***pppMod );

	VOID FillModArrAttr ( LDAPMod *pMod, INT nIndex );

	BOOL IsOverAppAttrLine ( LONG i ) { return (ENUM_CLIENTATTR_APP_NAME <= (i)); }

	BOOL IsExternalIPAddressPassedIn ( VOID ) { return (m_ClientInfo.dwFlags & CLIENTOBJ_F_IP_ADDRESS); }

	LONG		m_cRefs;
	ULONG		m_uSignature;

	SERVER_INFO	m_ServerInfo;
	CLIENT_INFO	m_ClientInfo;
	CList		m_Protocols;

	TCHAR		*m_pszDN;
	TCHAR		*m_pszAppPrefix;

	TCHAR		*m_pszRefreshFilter;

	REG_STATUS	m_RegStatus;

	BOOL		m_fExternalIPAddress;
	DWORD		m_dwIPAddress;
	ULONG		m_uTTL;

	DWORD_PTR	m_dwContext;	// COM layer context
};


#include <poppack.h>

#endif // _ILS_SP_USEROBJ_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\spinc.h ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spinc.h
	Content:	This file contains general definition for service provider.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#ifndef _SPINC_H_
#define _SPINC_H_

#include <windows.h>
#include <winsock.h>
#define LDAP_UNICODE	0
#include "winldap.h"
#define ANY_IN_USER  0
#include "spserver.h"
#include "ulsldap.h"
#include "uls.h"

// Timers
//
#define ID_TIMER_POLL_RESULT	1
#define KEEP_ALIVE_TIMER_BASE	100	// 100 -- 4196
#define CONN_PURGE_TIMER_BASE	10	// 10 and above

// Limits
//
#define INTEGER_STRING_LENGTH	16
#define MAX_DN_LENGTH			512

// General invalid IDs
//
#define INVALID_MSG_ID			((ULONG) -1)	// same as ldap_****()
#define INVALID_NOTIFY_ID		((ULONG) -1)

// Global enums
//
typedef enum
{
	ILS_REG_STATUS_NONE,
	ILS_REG_STATUS_LOCALLY,
	ILS_REG_STATUS_REMOTELY
}
	REG_STATUS;

// Extended attributes' cache for names/values lists
//
typedef struct
{
	ULONG	cAttrsToAdd;
	TCHAR	*pszAttrsToAdd;
	ULONG	cAttrsToModify;
	TCHAR	*pszAttrsToModify;
	ULONG	cAttrsToRemove;
	TCHAR	*pszAttrsToRemove;
}
	ANY_ATTRS;

// Service provider header files
//
extern TCHAR *g_pszUserPrefix;
extern TCHAR *g_pszMtgPrefix;
#include "spconn.h"
#include "spclient.h"
#include "splprot.h"
#include "splmtg.h"
#include "sppqueue.h"
#include "sputils.h"
#include "spserver.h"

// ldapsp.cpp
//
extern HINSTANCE g_hInstance;
extern HWND g_hWndHidden;
extern HWND g_hWndNotify;
extern DWORD g_dwReqThreadID;
extern ULONG g_uRespID;
extern DWORD g_dwClientSig;

// spils.cpp
//
extern const TCHAR c_szModOp[];
extern ULONG g_cbUserPrefix;
extern TCHAR *g_pszUserPrefix;
extern ULONG g_cbMtgPrefix;
extern TCHAR *g_pszMtgPrefix;
extern TCHAR c_szModOp_AddApp[];
extern TCHAR c_szModOp_DeleteApp[];
extern TCHAR c_szModOp_ModifyUser[];
extern TCHAR c_szModOp_ModifyApp[];
enum
{
	ISBU_MODOP_ADD_APP,
	ISBU_MODOP_DELETE_APP,
	ISBU_MODOP_MODIFY_USER,
	ISBU_MODOP_MODIFY_APP
};
HRESULT IlsInitialize ( VOID );
HRESULT IlsCleanup ( VOID );
ULONG IlsCalcModifyListSize ( ULONG cAttrs );
LDAPMod *IlsGetModifyListMod ( LDAPMod ***pppMod, ULONG cAttrs, LONG AttrIdx );
VOID IlsFillModifyListItem ( LDAPMod *pMod, TCHAR *pszAttrName, TCHAR *pszAttrValue );
VOID IlsFillModifyListForAnyAttrs ( LDAPMod *apMod[], ULONG *puIndex, ANY_ATTRS *pAnyAttrs );
VOID IlsFixUpModOp ( LDAPMod *pMod, LONG LdapModOp, LONG IsbuModOp );
HRESULT IlsParseRefreshPeriod ( LDAP *ld, LDAPMessage *pLdapMsg, const TCHAR *pszTtlAttrName, ULONG *puTTL );
HRESULT IlsUpdateOneAttr ( SERVER_INFO *pServerInfo, TCHAR *pszDN, TCHAR *pszAttrName, TCHAR *pszAttrValue, LONG nModifyMagic, ULONG cPrefix, TCHAR	*pszPrefix, SP_CSession **ppSession, ULONG *puMsgID );
HRESULT IlsUpdateIPAddress ( SERVER_INFO *pServerInfo, TCHAR *pszDN, TCHAR *pszIPAddrName, TCHAR *pszIPAddrValue, LONG nModifyMagic, ULONG cPrefix, TCHAR *pszPrefix );
HRESULT IlsSendRefreshMsg ( SERVER_INFO *pServerInfo, TCHAR *pszBaseDN, TCHAR *pszTTL, TCHAR *pszRefreshFilter, ULONG *puTTL );
HRESULT IlsFillDefStdAttrsModArr ( LDAPMod ***pppMod, DWORD dwFlags, ULONG cMaxAttrs, ULONG *pcTotal, LONG IsbuModOp, ULONG cPrefix, TCHAR *pszPrefix );
const TCHAR *IlsSkipAnyAttrNamePrefix ( const TCHAR *pszAttrName );
const TCHAR *IlsIsAnyAttrName ( const TCHAR *pszAttrName );
TCHAR *IlsPrefixNameValueArray ( BOOL fPair, ULONG cAttrs, const TCHAR *pszAttrs );
TCHAR *IlsBuildDN ( TCHAR *pszBaseDN, TCHAR *pszC, TCHAR *pszO, TCHAR *pszCN, TCHAR *pszObjectClass );
HRESULT IlsCreateAnyAttrsPrefix ( ANY_ATTRS *pAnyAttrs );
VOID IlsReleaseAnyAttrsPrefix ( ANY_ATTRS *pAnyAttrs );
TCHAR **my_ldap_get_values ( LDAP *ld, LDAPMessage *pEntry, TCHAR *pszRetAttrName );
ULONG my_ldap_count_1st_entry_attributes ( LDAP *ld, LDAPMessage *pLdapMsg );

// spnotify.cpp
//
ULONG GetUniqueNotifyID ( VOID );

// spfilter.cpp
//
TCHAR *ClntCreateRefreshFilter ( TCHAR *pszClientName );
TCHAR *MtgCreateRefreshFilter ( TCHAR *pszMtgName );
// TCHAR *ClntCreateEnumFilter ( VOID );
TCHAR *ProtCreateEnumFilter ( TCHAR *pszUserName, TCHAR *pszAppName );
TCHAR *ClntCreateResolveFilter ( TCHAR *pszClientName, TCHAR *pszAppName, TCHAR *pszProtName );
TCHAR *ProtCreateResolveFilter ( TCHAR *pszUserName, TCHAR *pszAppName, TCHAR *pszProtName );
TCHAR *MtgCreateResolveFilter ( TCHAR *pszMtgName );
TCHAR *MtgCreateEnumMembersFilter ( TCHAR *pszMtgName );

// sputils.cpp
//
enum
{
	THREAD_WAIT_FOR_EXIT,
	THREAD_WAIT_FOR_REQUEST,
	NUM_THREAD_WAIT_FOR,
};
extern BOOL g_fExitNow;
extern HANDLE g_ahThreadWaitFor[NUM_THREAD_WAIT_FOR];
#define g_hevExitReqThread		g_ahThreadWaitFor[THREAD_WAIT_FOR_EXIT]
#define g_hevNewRequest			g_ahThreadWaitFor[THREAD_WAIT_FOR_REQUEST]
#define g_hevReqThreadHasExited	g_ahThreadWaitFor[NUM_THREAD_WAIT_FOR]
DWORD WINAPI ReqThread ( VOID *lParam );
BOOL MyCreateWindow ( VOID );
VOID _MyAssert ( BOOL fAssertion );
HRESULT LdapError2Hresult ( ULONG );
HRESULT GetLocalIPAddress ( DWORD *pdwIPAddress );


#endif // _SPINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\splapp.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		splapp.cpp
	Content:	This file contains the local application object.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"

const TCHAR *c_apszAppStdAttrNames[COUNT_ENUM_APPATTR] =
{
	TEXT ("sappid"),
	TEXT ("smimetype"),
	TEXT ("sappguid"),		// app guid

	// protocol attributes
	TEXT ("sprotid"),
	TEXT ("sprotmimetype"),
	TEXT ("sport"),
};


/* ---------- public methods ----------- */


UlsLdap_CLocalApp::UlsLdap_CLocalApp ( UlsLdap_CLocalUser *pUser )
{
	MyAssert (pUser != NULL);

	m_cRefs = 0;
	m_uSignature = APPOBJ_SIGNATURE;
	m_pUser = pUser;

	m_cPrefix = 0;
	m_pszPrefix = NULL;
	ZeroMemory (&m_AppInfo, sizeof (m_AppInfo));
	SetRegNone ();
}


UlsLdap_CLocalApp::~UlsLdap_CLocalApp ( VOID )
{
	m_uSignature = (ULONG) -1;
	MemFree (m_pszPrefix);
}


ULONG UlsLdap_CLocalApp::AddRef ( VOID )
{
	InterlockedIncrement (&m_cRefs);
	return m_cRefs;
}


ULONG UlsLdap_CLocalApp::Release ( VOID )
{
	MyAssert (m_cRefs != 0);

	if (m_cRefs != 0)
	{
		InterlockedDecrement (&m_cRefs);
	}

	ULONG cRefs = m_cRefs;
	if (cRefs == 0)
		delete this;

	return cRefs;
}


HRESULT UlsLdap_CLocalApp::Register ( ULONG *puRespID, LDAP_APPINFO *pInfo )
{
	MyAssert (puRespID != NULL);
	MyAssert (pInfo != NULL);

	TCHAR *pszDN = GetDN ();
	if (pszDN == NULL)
	{
		MyAssert (FALSE);
		return ULS_E_HANDLE;
	}

	// get app name
	TCHAR *pszAppName = (TCHAR *) ((BYTE *) pInfo + pInfo->uOffsetName);
	if  (*pszAppName == TEXT ('\0'))
	{
		MyAssert (FALSE);
		return ULS_E_PARAMETER;
	}

	// cache app info
	HRESULT hr = CacheAppInfo (pInfo);
	if (hr != S_OK)
		return hr;

	// cache generic protocol info (per KevinMa's suggestion)
	m_AppInfo.apszStdAttrValues[ENUM_APPATTR_PROT_NAME] = TEXT ("h323");
	m_AppInfo.apszStdAttrValues[ENUM_APPATTR_PROT_MIME] = TEXT ("text/h323");
	m_AppInfo.apszStdAttrValues[ENUM_APPATTR_PROT_PORT] = TEXT ("1720");

	// create prefix info
	ULONG cbPrefix = sizeof (TCHAR) * (lstrlen (STR_APP_NAME) +
								lstrlen (pszAppName) + 2);

	ULONG cUserPrefix = GetUserPrefixCount ();
	TCHAR *pszUserPrefix = GetUserPrefixString ();
	for (ULONG i = 0; i < cUserPrefix; i++)
	{
		ULONG uLength = lstrlen (pszUserPrefix) + 1;
		cbPrefix += uLength * sizeof (TCHAR);
		pszUserPrefix += uLength;
		uLength = lstrlen (pszUserPrefix) + 1;
		cbPrefix += uLength * sizeof (TCHAR);
		pszUserPrefix += uLength;
	}

	TCHAR *psz = (TCHAR *) MemAlloc (cbPrefix);
	if (psz == NULL)
		return ULS_E_MEMORY;

	MemFree (m_pszPrefix);
	m_pszPrefix = psz;
	m_cPrefix = cUserPrefix + 1;

	// fill in prefix info
	pszUserPrefix = GetUserPrefixString ();
	for (i = 0; i < cUserPrefix; i++)
	{
		ULONG uLength = lstrlen (pszUserPrefix) + 1;
		lstrcpy (psz, pszUserPrefix);
		psz += uLength;
		pszUserPrefix += uLength;
		uLength = lstrlen (pszUserPrefix) + 1;
		lstrcpy (psz, pszUserPrefix);
		psz += uLength;
		pszUserPrefix += uLength;
	}
	lstrcpy (psz, STR_APP_NAME);
	psz += lstrlen (psz) + 1;
	lstrcpy (psz, pszAppName);

	// build modify array for ldap_modify()
	LDAPMod **ppMod = NULL;
	hr = CreateRegisterModArr (&ppMod);
	if (hr != S_OK)
		return hr;
	MyAssert (ppMod != NULL);

	// so far, we are done with local preparation

	// get the connection object
	UlsLdap_CSession *pSession = NULL;
	MyAssert (m_pUser != NULL);
	hr = g_pSessionContainer->GetSession (&pSession, GetServerInfo ());
	if (hr != S_OK)
	{
		MemFree (ppMod);
		return hr;
	}
	MyAssert (pSession != NULL);

	// get the ldap session
	LDAP *ld = pSession->GetLd ();
	MyAssert (ld != NULL);

	// send the data over the wire
	ULONG uMsgID = ldap_modify (ld, pszDN, ppMod);
	MemFree (ppMod);
	if (uMsgID == -1)
	{
		hr = ::LdapError2Hresult (ld->ld_errno);
		pSession->Disconnect ();
		return hr;
	}

	// if there is any arbitrary attributes,
	// then do not create pending info and we will use
	// SetAttrs's pending info
	ULONG u2ndMsgID = INVALID_MSG_ID;
	if (pInfo->cAttributes != 0)
	{
		hr = UlsLdap_CAnyAttrs::SetAnyAttrs (	NULL, // notify id (ignored)
										&u2ndMsgID, // out msg id
										0,	// notify msg (ignored)
										pInfo->cAttributes,
										(TCHAR *) ((BYTE *) pInfo + pInfo->uOffsetAttributes),
										m_cPrefix,
										m_pszPrefix,
										LDAP_MOD_ADD,
										GetServerInfo (),
										pszDN);
		if (hr != S_OK)
		{
			ldap_abandon (ld, uMsgID);
			pSession->Disconnect ();
			return hr;
		}
	}

	PENDING_INFO PendingInfo;
	::FillDefPendingInfo (&PendingInfo, ld, uMsgID, u2ndMsgID);
	PendingInfo.uLdapResType = LDAP_RES_MODIFY;
	PendingInfo.uNotifyMsg = WM_ULS_REGISTER_APP;
	PendingInfo.hObject = (HANDLE) this;

	hr = g_pPendingQueue->EnterRequest (pSession, &PendingInfo);
	if (hr != S_OK)
	{
		ldap_abandon (ld, uMsgID);
		if (u2ndMsgID != INVALID_MSG_ID)
			ldap_abandon (ld, u2ndMsgID);
		pSession->Disconnect ();
		return hr;
	}

	*puRespID = PendingInfo.uRespID;
	return S_OK;
}


HRESULT UlsLdap_CLocalApp::UnRegister ( ULONG *puRespID )
{
	MyAssert (puRespID != NULL);

	if (! IsRegRemotely ())
	{
		*puRespID = ::GetUniqueNotifyID ();
		SetRegNone ();
		PostMessage (g_hWndNotify, WM_ULS_UNREGISTER_APP, *puRespID, S_OK);
		return S_OK;
	}

	SetRegNone ();

	TCHAR *pszDN = GetDN ();
	if (pszDN == NULL)
	{
		MyAssert (FALSE);
		return ULS_E_HANDLE;
	}

	// build modify array for ldap_modify()
	LDAPMod **ppMod = NULL;
	HRESULT hr = CreateUnRegisterModArr (&ppMod);
	if (hr != S_OK)
		return hr;
	MyAssert (ppMod != NULL);

	// get the connection object
	UlsLdap_CSession *pSession = NULL;
	MyAssert (m_pUser != NULL);
	hr = g_pSessionContainer->GetSession (&pSession, GetServerInfo ());
	if (hr != S_OK)
		return hr;
	MyAssert (pSession != NULL);

	// get the ldap session
	LDAP *ld = pSession->GetLd ();
	MyAssert (ld != NULL);

	ULONG u2ndMsgID = INVALID_MSG_ID;
	if (UlsLdap_CAnyAttrs::GetAnyAttrsCount () != 0)
	{
		hr = UlsLdap_CAnyAttrs::RemoveAllAnyAttrs (	&u2ndMsgID,
											m_cPrefix,
											m_pszPrefix,
											GetServerInfo (),
											pszDN);
		if (hr != S_OK)
		{
			pSession->Disconnect ();
			return hr;
		}
	}

	// send the data over the wire
	ULONG uMsgID = ldap_modify (ld, pszDN, ppMod);
	MemFree (ppMod);
	if (uMsgID == -1)
	{
		hr = ::LdapError2Hresult (ld->ld_errno);
		pSession->Disconnect ();
		return hr;
	}

	// construct a pending info
	PENDING_INFO PendingInfo;
	::FillDefPendingInfo (&PendingInfo, ld, uMsgID, u2ndMsgID);
	PendingInfo.uLdapResType = LDAP_RES_MODIFY;
	PendingInfo.uNotifyMsg = WM_ULS_UNREGISTER_APP;

	// queue it
	hr = g_pPendingQueue->EnterRequest (pSession, &PendingInfo);
	if (hr != S_OK)
	{
		ldap_abandon (ld, uMsgID);
		pSession->Disconnect ();
		MyAssert (FALSE);
	}

	*puRespID = PendingInfo.uRespID;
	return hr;
}


HRESULT UlsLdap_CLocalApp::SetStdAttrs (
	ULONG			*puRespID,
	LDAP_APPINFO	*pInfo )
{
	MyAssert (puRespID != NULL);
	MyAssert (pInfo != NULL);

	TCHAR *pszDN = GetDN ();
	if (pszDN == NULL)
	{
		MyAssert (FALSE);
		return ULS_E_HANDLE;
	}

	return UlsLdap_CStdAttrs::SetStdAttrs (	puRespID,
									NULL,
									WM_ULS_SET_APP_INFO,
									(VOID *) pInfo,
									GetServerInfo (),
									pszDN);
}


HRESULT UlsLdap_CLocalApp::SetAnyAttrs (
	ULONG	*puRespID,
	ULONG	cAttrs,
	TCHAR	*pszAttrs )
{
	MyAssert (puRespID != NULL);
	MyAssert (cAttrs != 0);
	MyAssert (pszAttrs != NULL);

	TCHAR *pszDN = GetDN ();
	if (pszDN == NULL)
	{
		MyAssert (FALSE);
		return ULS_E_HANDLE;
	}

	return UlsLdap_CAnyAttrs::SetAnyAttrs (	puRespID,
									NULL,
									WM_ULS_SET_APP_ATTRS,
									cAttrs,
									pszAttrs,
									m_cPrefix,
									m_pszPrefix,
									LDAP_MOD_REPLACE,
									GetServerInfo (),
									pszDN);
}


HRESULT UlsLdap_CLocalApp::RemoveAnyAttrs (
	ULONG	*puRespID,
	ULONG	cAttrs,
	TCHAR	*pszAttrs )
{
	MyAssert (puRespID != NULL);
	MyAssert (cAttrs != 0);
	MyAssert (pszAttrs != NULL);

	TCHAR *pszDN = GetDN ();
	if (pszDN == NULL)
	{
		MyAssert (FALSE);
		return ULS_E_HANDLE;
	}

	return UlsLdap_CAnyAttrs::RemoveAnyAttrs (	puRespID,
										NULL,
										WM_ULS_REMOVE_APP_ATTRS,
										cAttrs,
										pszAttrs,
										m_cPrefix,
										m_pszPrefix,
										GetServerInfo (),
										pszDN);
}


/* ---------- protected methods ----------- */


/* ---------- private methods ----------- */


HRESULT UlsLdap_CLocalApp::CacheInfo ( VOID *pInfo )
{
	return CacheAppInfo ((LDAP_APPINFO *) pInfo);
}


HRESULT UlsLdap_CLocalApp::CacheAppInfo ( LDAP_APPINFO *pInfo )
{
	ZeroMemory (&m_AppInfo, sizeof (m_AppInfo));
	TCHAR *pszName;

	if (::IsValidGuid (&(pInfo->guid)))
	{
		m_AppInfo.apszStdAttrValues[ENUM_APPATTR_GUID] = &m_AppInfo.szGuid[0];
		::GetGuidString (&(pInfo->guid), &m_AppInfo.szGuid[0]);
		m_AppInfo.dwFlags |= APPOBJ_F_GUID;
	}

	if (pInfo->uOffsetName != 0)
	{
		pszName = (TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetName);
		m_AppInfo.apszStdAttrValues[ENUM_APPATTR_NAME] = pszName;
		m_AppInfo.dwFlags |= APPOBJ_F_NAME;
	}

	if (pInfo->uOffsetMimeType != 0)
	{
		pszName = (TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetMimeType);
		m_AppInfo.apszStdAttrValues[ENUM_APPATTR_MIME_TYPE] = pszName;
		m_AppInfo.dwFlags |= APPOBJ_F_MIME_TYPE;
	}

	return S_OK;
}


HRESULT UlsLdap_CLocalApp::CreateRegisterModArr ( LDAPMod ***pppMod )
{
	MyAssert (pppMod != NULL);

	ULONG cPrefix = m_cPrefix - 1; // skip its own app id
	TCHAR *pszPrefix = m_pszPrefix;

	ULONG cAttrs = COUNT_ENUM_APPATTR;
	ULONG cTotal = cPrefix + cAttrs;
	ULONG cbMod = ::IlsCalcModifyListSize (cTotal);
	*pppMod = (LDAPMod **) MemAlloc (cbMod);
	if (*pppMod == NULL)
		return ULS_E_MEMORY;

	LDAPMod *pMod;
	for (ULONG i = 0; i < cTotal; i++)
	{
		pMod = ::IlsGetModifyListMod (pppMod, cTotal, i);
		(*pppMod)[i] = pMod;
		pMod->mod_values = (TCHAR **) (pMod + 1);

		if (i < cPrefix)
		{
			pMod->mod_op = LDAP_MOD_REPLACE;
			pMod->mod_type = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
			*(pMod->mod_values) = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
		}
		else
		{
			pMod->mod_op = LDAP_MOD_ADD;
			ULONG AttrIdx = i - cPrefix;
			pMod->mod_type = (TCHAR *) c_apszAppStdAttrNames[AttrIdx];
			*(pMod->mod_values) = (m_AppInfo.apszStdAttrValues[AttrIdx] != NULL) ?
									m_AppInfo.apszStdAttrValues[AttrIdx] :
									(TCHAR *) &c_szEmptyString[0];
		}
	}

	::IlsFixUpModOp ((*pppMod)[0], LDAP_MOD_ADD, ISBU_MODOP_ADD_APP);
	(*pppMod)[cTotal] = NULL;
	return S_OK;
}


HRESULT UlsLdap_CLocalApp::CreateUnRegisterModArr ( LDAPMod ***pppMod )
{
	MyAssert (pppMod != NULL);

	ULONG cPrefix = m_cPrefix; // do NOT skip its own app id
	TCHAR *pszPrefix = m_pszPrefix;

	ULONG cAttrs = COUNT_ENUM_APPATTR;
	ULONG cTotal = cPrefix + cAttrs;
	ULONG cbMod = ::IlsCalcModifyListSize (cTotal);
	*pppMod = (LDAPMod **) MemAlloc (cbMod);
	if (*pppMod == NULL)
		return ULS_E_MEMORY;

	LDAPMod *pMod;
	for (ULONG i = 0; i < cTotal; i++)
	{
		pMod = ::IlsGetModifyListMod (pppMod, cTotal, i);
		(*pppMod)[i] = pMod;

		if (i < cPrefix)
		{
			pMod->mod_op = LDAP_MOD_REPLACE;
			pMod->mod_type = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
			pMod->mod_values = (TCHAR **) (pMod + 1);
			*(pMod->mod_values) = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
		}
		else
		{
			pMod->mod_op = LDAP_MOD_DELETE;
			pMod->mod_type = (TCHAR *) c_apszAppStdAttrNames[i - cPrefix];
		}
	}

	::IlsFixUpModOp ((*pppMod)[0], LDAP_MOD_DELETE, ISBU_MODOP_DELETE_APP);
	(*pppMod)[cTotal] = NULL;
	return S_OK;
}


HRESULT UlsLdap_CLocalApp::CreateSetStdAttrsModArr ( LDAPMod ***pppMod )
{
	MyAssert (pppMod != NULL);

	HRESULT hr;
	ULONG cTotal = 0;
	hr = ::FillDefStdAttrsModArr (	pppMod,
									m_AppInfo.dwFlags,
									COUNT_ENUM_APPATTR,
									&cTotal,
									ISBU_MODOP_MODIFY_APP,
									m_cPrefix,
									m_pszPrefix);
	if (hr != S_OK)
		return hr;

	// start indexing
	ULONG i = m_cPrefix;

	if (m_AppInfo.dwFlags & APPOBJ_F_GUID)
		FillModArrAttr ((*pppMod)[i++], ENUM_APPATTR_GUID);

	if (m_AppInfo.dwFlags & APPOBJ_F_NAME)
		FillModArrAttr ((*pppMod)[i++], ENUM_APPATTR_NAME);

	if (m_AppInfo.dwFlags & APPOBJ_F_MIME_TYPE)
		FillModArrAttr ((*pppMod)[i++], ENUM_APPATTR_MIME_TYPE);

	MyAssert (i == cTotal);
	return S_OK;
}


VOID UlsLdap_CLocalApp::FillModArrAttr ( LDAPMod *pMod, LONG AttrIdx )
{
	pMod->mod_type = (TCHAR *) c_apszAppStdAttrNames[AttrIdx];

	// single valued attr
	TCHAR **ppsz = (TCHAR **) (pMod + 1);
	pMod->mod_values = ppsz;
	*(pMod->mod_values) = (m_AppInfo.apszStdAttrValues[AttrIdx] != NULL) ?
				m_AppInfo.apszStdAttrValues[AttrIdx] :
				(TCHAR *) &c_szEmptyString[0];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\splmtg.h ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spmtg.h
	Content:	This file contains the meeting place object definition.
	History:
	12/9/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#ifndef _ILS_SP_MTGOBJ_H_
#define _ILS_SP_MTGOBJ_H_

#ifdef ENABLE_MEETING_PLACE

#include <pshpack8.h>

enum
{
	ENUM_MTGATTR_CN,
	ENUM_MTGATTR_MTG_TYPE,
	ENUM_MTGATTR_MEMBER_TYPE,
	ENUM_MTGATTR_DESCRIPTION,
	ENUM_MTGATTR_HOST_NAME,
	ENUM_MTGATTR_IP_ADDRESS,

	/* -- the above are resolvable -- */

	ENUM_MTGATTR_MEMBERS,
	ENUM_MTGATTR_CLIENT_SIG,
	ENUM_MTGATTR_TTL,

	/* -- the above are changeable standard attributes for RTConf -- */

	ENUM_MTGATTR_OBJECT_CLASS,
	ENUM_MTGATTR_O,
	ENUM_MTGATTR_C,

	COUNT_ENUM_MTGATTR
};

#define COUNT_ENUM_MTGINFO			(ENUM_MTGATTR_TTL + 1) // exclude uid, o, c
#define COUNT_ENUM_DIRMTGINFO		(ENUM_MTGATTR_IP_ADDRESS + 1)	// count of attrs in dir dlg
#define COUNT_ENUM_RESMTGINFO		(ENUM_MTGATTR_IP_ADDRESS + 1)	// count of attrs resolvable

extern const TCHAR *c_apszMtgStdAttrNames[COUNT_ENUM_MTGATTR];
#define STR_MTG_NAME				((TCHAR *) c_apszMtgStdAttrNames[ENUM_MTGATTR_CN])
#define STR_MTG_MEMBERS				((TCHAR *) c_apszMtgStdAttrNames[ENUM_MTGATTR_MEMBERS])
#define STR_MTG_IP_ADDR				((TCHAR *) c_apszMtgStdAttrNames[ENUM_MTGATTR_IP_ADDRESS])
#define STR_MTG_TTL					((TCHAR *) c_apszMtgStdAttrNames[ENUM_MTGATTR_TTL])
#define STR_DEF_MTG_BASE_DN			((TCHAR *) &c_szDefMtgBaseDN[0])

#define MTGOBJ_F_NAME			0x0001
#define MTGOBJ_F_MTG_TYPE		0x0002
#define MTGOBJ_F_MEMBER_TYPE	0x0004
#define MTGOBJ_F_DESCRIPTION	0x0008
#define MTGOBJ_F_HOST_NAME		0x0010
#define MTGOBJ_F_IP_ADDRESS		0x0020

typedef struct
{
	DWORD		dwFlags;
	TCHAR		*apszStdAttrValues[COUNT_ENUM_MTGATTR];
	ANY_ATTRS	AnyAttrs;
	TCHAR		szMtgType[INTEGER_STRING_LENGTH];
	TCHAR		szMemberType[INTEGER_STRING_LENGTH];
	TCHAR		szIPAddress[INTEGER_STRING_LENGTH];
	TCHAR		szFlags[INTEGER_STRING_LENGTH];
	TCHAR		szTTL[INTEGER_STRING_LENGTH];
	TCHAR		szClientSig[INTEGER_STRING_LENGTH];
	TCHAR		szGuid[sizeof (GUID) * 2 + 2];
}
	MTG_INFO;


#define MTGOBJ_SIGNATURE	((ULONG) 0x98007206UL)


class SP_CMeeting
{
	friend class SP_CRefreshScheduler;

public:

	SP_CMeeting ( DWORD dwContext );
	~SP_CMeeting ( VOID );

	ULONG AddRef ( VOID );
	ULONG Release ( VOID );

	HRESULT Register ( ULONG uRespID, SERVER_INFO *pServerInfo, LDAP_MEETINFO *pInfo );
	HRESULT UnRegister ( ULONG uRespID );

	VOID SetRegNone ( VOID ) { m_RegStatus = ILS_REG_STATUS_NONE; }
	VOID SetRegLocally ( VOID ) { m_RegStatus = ILS_REG_STATUS_LOCALLY; }
	VOID SetRegRemotely ( VOID ) { m_RegStatus = ILS_REG_STATUS_REMOTELY; }

	BOOL IsRegistered ( VOID ) { return (m_RegStatus > ILS_REG_STATUS_NONE); }
	BOOL IsRegLocally ( VOID ) { return (m_RegStatus == ILS_REG_STATUS_LOCALLY); }
	BOOL IsRegRemotely ( VOID ) { return (m_RegStatus == ILS_REG_STATUS_REMOTELY); }

	BOOL IsValidObject ( VOID ) { return m_uSignature == MTGOBJ_SIGNATURE; }

	SERVER_INFO *GetServerInfo ( VOID ) { return &m_ServerInfo; }

	TCHAR *GetMtgName ( VOID ) { return m_pszMtgName; }

	ULONG GetTTL ( VOID ) { return m_uTTL; }
	DWORD GetContext ( VOID ) { return m_dwContext; }

protected:

	HRESULT SendRefreshMsg ( VOID );

private:

	HRESULT CreateRegModArr ( LDAPMod ***pppMod );

	HRESULT UpdateIPAddress ( VOID );

	ULONG		m_uSignature;
	LONG		m_cRefs;

	MTG_INFO	m_MtgInfo;
	TCHAR		*m_pszMtgName;
	TCHAR		*m_pszDN;

	SERVER_INFO	m_ServerInfo;
	TCHAR		*m_pszRefreshFilter;

	REG_STATUS	m_RegStatus;

	DWORD		m_dwIPAddress;
	ULONG		m_uTTL;
	DWORD		m_dwContext;
};


#define MtgGetPrefixCount()			1
#define MtgGetPrefixString()		g_pszMtgPrefix


HRESULT MtgSetAttrs ( SERVER_INFO *pServerInfo, TCHAR *pszMtgName, LDAP_MEETINFO *pInfo, ULONG uRespID );
HRESULT MtgCreateSetAttrsModArr ( LDAPMod ***pppMod, MTG_INFO *pMtgInfo );
VOID MtgFillModArrAttr ( LDAPMod *pMod, MTG_INFO *pMtgInfo, INT nIndex );
HRESULT MtgCacheInfo ( LDAP_MEETINFO *pInfo, MTG_INFO *pMtgInfo );
HRESULT MtgUpdateMembers ( ULONG uNotifyMsg, SERVER_INFO *pServerInfo, TCHAR *pszMtgName, ULONG cMembers, TCHAR *pszMemberNames, ULONG uRespID );
HRESULT MtgCreateUpdateMemberModArr ( ULONG uNotifyMsg, LDAPMod ***pppMod, ULONG cMembers, TCHAR *pszMemberNames );

#include <poppack.h>

#endif // ENABLE_MEETING_PLACE

#endif // _ILS_SP_MTGOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\splmtg.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		splmtg.cpp
	Content:	This file contains the local meeting object.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"

#ifdef ENABLE_MEETING_PLACE

// Array of constant strings for user object's attribute names
//
const TCHAR *c_apszMtgStdAttrNames[COUNT_ENUM_MTGATTR] =
{
	TEXT ("CN"),				// Meeting ID
	TEXT ("ConfType"),			// Meeting Type
	TEXT ("ConfMemberType"),	// Attendee Type
	TEXT ("ConfDesc"),			// Description
	TEXT ("ConfHostName"),		// Host Name
	TEXT ("ConfHostAddress"),	// IP Address

	TEXT ("ConfMemberList"),	// Members
	TEXT ("ssecurity"),
	TEXT ("sttl"),

	TEXT ("objectClass"),
	TEXT ("o"),
	TEXT ("c"),
};


const TCHAR c_szMtgDefC[] = TEXT ("us");


/* ---------- public methods ----------- */


SP_CMeeting::
SP_CMeeting ( DWORD dwContext )
	:
	m_cRefs (0),						// Reference count
	m_uSignature (MTGOBJ_SIGNATURE),	// Mtg object's signature
	m_pszMtgName (NULL),				// Clean the meeting name
	m_pszDN (NULL),						// Clean DN
	m_pszRefreshFilter (NULL),			// Clean up the refresh search filter
	m_dwIPAddress (0),					// Clean local IP address
	m_uTTL (ILS_DEF_REFRESH_MINUTE)		// Reset time to live value (min)
{
	m_dwContext = dwContext;

	// Clean up attached server info structure
	//
	::ZeroMemory (&m_ServerInfo, sizeof (m_ServerInfo));

	// Clean up the scratch buffer for caching pointers to attribute values
	//
	::ZeroMemory (&m_MtgInfo, sizeof (m_MtgInfo));

	// Indicate this user is not registered yet
	//
	SetRegNone ();
}


SP_CMeeting::
~SP_CMeeting ( VOID )
{
	// Invalidate the user object's signature
	//
	m_uSignature = (ULONG) -1;

	// Free server info structure
	//
	::IlsFreeServerInfo (&m_ServerInfo);

	// Free meeting name
	//
	MemFree (m_pszMtgName);

	// Free DN
	//
	MemFree (m_pszDN);

	// Free the refresh search filter
	//
	MemFree (m_pszRefreshFilter);

	// Release the previous prefix for extended attribute names
	//
	::IlsReleaseAnyAttrsPrefix (&(m_MtgInfo.AnyAttrs));
}


ULONG
SP_CMeeting::
AddRef ( VOID )
{
	::InterlockedIncrement (&m_cRefs);
	return m_cRefs;
}


ULONG
SP_CMeeting::
Release ( VOID )
{
	MyAssert (m_cRefs != 0);
	::InterlockedDecrement (&m_cRefs);

	ULONG cRefs = m_cRefs;
	if (cRefs == 0)
		delete this;

	return cRefs;
}


HRESULT SP_CMeeting::
Register (
	ULONG				uRespID,
	SERVER_INFO			*pServerInfo,
	LDAP_MEETINFO		*pInfo )
{
	MyAssert (pInfo != NULL);
	MyAssert (MyIsGoodString (pServerInfo->pszServerName));

	// Cache the server info
	//
	HRESULT hr = ::IlsCopyServerInfo (&m_ServerInfo, pServerInfo);
	if (hr != S_OK)
		return hr;

	// Cache the meeting info
	// lonchanc: CacheInfo() is not a method in the meeting object
	// because we pass in meeting name in SetMeetingInfo()
	// rather than meeting object handle.
	//
	hr = ::MtgCacheInfo (pInfo, &m_MtgInfo);
	if (hr != S_OK)
		return hr;

	// If the application sets an IP address,
	//		then we will use what the app provides,
	//		otherwise, we will get the IP address via winsock.
	//
	if (pInfo->uOffsetHostIPAddress == INVALID_OFFSET)
	{
		// Get local IP address
		//
		m_dwIPAddress = 0;
		hr = ::GetLocalIPAddress (&m_dwIPAddress);
		if (hr != S_OK)
			return hr;

		// Create IP address string
		//
		m_MtgInfo.apszStdAttrValues[ENUM_MTGATTR_IP_ADDRESS] = &m_MtgInfo.szIPAddress[0];
		::GetLongString (m_dwIPAddress, &m_MtgInfo.szIPAddress[0]);
	}

	// Create client signature string
	//
	m_MtgInfo.apszStdAttrValues[ENUM_MTGATTR_CLIENT_SIG] = &m_MtgInfo.szClientSig[0];
	::GetLongString (g_dwClientSig, &m_MtgInfo.szClientSig[0]);

	// Create TTL string
	//
	m_MtgInfo.apszStdAttrValues[ENUM_MTGATTR_TTL] = &m_MtgInfo.szTTL[0];
	::GetLongString (m_uTTL, &m_MtgInfo.szTTL[0]);

	// Ideally, o= and c= should be read in from registiry
	// but for now, we simply hard code it
	//
	m_MtgInfo.apszStdAttrValues[ENUM_MTGATTR_OBJECT_CLASS] = (TCHAR *) &c_szRTConf[0];
	m_MtgInfo.apszStdAttrValues[ENUM_MTGATTR_O] = (TCHAR *) &c_szDefO[0];
	m_MtgInfo.apszStdAttrValues[ENUM_MTGATTR_C] = (TCHAR *) &c_szMtgDefC[0];

	// Duplicate the mtg name
	//
	m_pszMtgName = My_strdup (m_MtgInfo.apszStdAttrValues[ENUM_MTGATTR_CN]);
	if (m_pszMtgName == NULL)
		return ILS_E_MEMORY;

	// Build DN
	//
	m_pszDN = ::IlsBuildDN (m_ServerInfo.pszBaseDN,
							m_MtgInfo.apszStdAttrValues[ENUM_MTGATTR_C],
							m_MtgInfo.apszStdAttrValues[ENUM_MTGATTR_O],
							m_MtgInfo.apszStdAttrValues[ENUM_MTGATTR_CN],
							m_MtgInfo.apszStdAttrValues[ENUM_MTGATTR_OBJECT_CLASS]);
	if (m_pszDN == NULL)
		return ILS_E_MEMORY;

	// Build refreh filter
	//
	m_pszRefreshFilter = ::MtgCreateRefreshFilter (m_pszMtgName);
	if (m_pszRefreshFilter == NULL)
		return ILS_E_MEMORY;

	// Build modify array for ldap_add()
	//
	LDAPMod **ppMod = NULL;
	hr = CreateRegModArr (&ppMod);
	if (hr != S_OK)
		return hr;
	MyAssert (ppMod != NULL);

	// so far, we are done with local preparation
	//

	// Get the connection object
	//
	SP_CSession *pSession = NULL;
	LDAP *ld;
	ULONG uMsgID = (ULONG) -1;
	hr = g_pSessionContainer->GetSession (&pSession, &m_ServerInfo);
	if (hr == S_OK)
	{
		MyAssert (pSession != NULL);

		// Get the ldap session
		//
		ld = pSession->GetLd ();
		MyAssert (ld != NULL);

		// Send the data over the wire
		//
		uMsgID = ldap_add (ld, m_pszDN, ppMod);
		if (uMsgID == -1)
		{
			hr = ::LdapError2Hresult (ld->ld_errno);
		}

	}

	// Free modify array
	//
	MemFree (ppMod);

	// Report failure if so
	//
	if (hr != S_OK)
		goto MyExit;

	// Construct a pending info
	//
	RESP_INFO ri;
	::FillDefRespInfo (&ri, uRespID, ld, uMsgID, INVALID_MSG_ID);
	ri.uNotifyMsg = WM_ILS_REGISTER_MEETING;
	ri.hObject = (HANDLE) this;

	// Remember the pending result
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		MyAssert (FALSE);
		goto MyExit;
	}

MyExit:

	if (hr != S_OK)
	{
		if (uMsgID != (ULONG) -1)
			::ldap_abandon (ld, uMsgID);

		if (pSession != NULL)
			pSession->Disconnect ();
	}

	return hr;
}


HRESULT SP_CMeeting::
UnRegister ( ULONG uRespID )
{
	MyAssert (MyIsGoodString (m_pszDN));

	// Make sure that there is not refresh scheduled for this object
	//
	if (g_pRefreshScheduler != NULL)
	{
		g_pRefreshScheduler->RemoveMtgObject (this);
	}
	else
	{
		MyAssert (FALSE);
	}

	// If it is not registered on the server,
	// the simply report success
	//
	if (! IsRegRemotely ())
	{
		SetRegNone ();
		::PostMessage (g_hWndNotify, WM_ILS_UNREGISTER_MEETING, uRespID, S_OK);
		return S_OK;
	}

	// Indicate that we are not registered at all
	//
	SetRegNone ();

	// Get the session object
	//
	SP_CSession *pSession = NULL;
	LDAP *ld;
	ULONG uMsgID = (ULONG) -1;
	HRESULT hr = g_pSessionContainer->GetSession (&pSession, &m_ServerInfo);
	if (hr == S_OK)
	{
		// Get the ldap session
		//
		MyAssert (pSession != NULL);
		ld = pSession->GetLd ();
		MyAssert (ld != NULL);

		// Send the data over the wire
		//
		MyAssert (MyIsGoodString (m_pszDN));
		uMsgID = ::ldap_delete (ld, m_pszDN);
		if (uMsgID == -1)
		{
			hr = ::LdapError2Hresult (ld->ld_errno);
		}
	}

	// Report failure if so
	//
	if (hr != S_OK)
		goto MyExit;

	// Construct a pending info
	//
	RESP_INFO ri;
	::FillDefRespInfo (&ri, uRespID, ld, uMsgID, INVALID_MSG_ID);
	ri.uNotifyMsg = WM_ILS_UNREGISTER_MEETING;

	// Remember the pending request
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		MyAssert (FALSE);
		goto MyExit;
	}

MyExit:

	if (hr != S_OK)
	{
		if (uMsgID != (ULONG) -1)
			::ldap_abandon (ld, uMsgID);

		if (pSession != NULL)
			pSession->Disconnect ();
	}

	return hr;
}


HRESULT SP_CMeeting::
UpdateIPAddress ( VOID )
{
	MyAssert (MyIsGoodString (m_pszDN));

	// Update cached ip address
	//
	HRESULT hr = ::GetLocalIPAddress (&m_dwIPAddress);
	if (hr != S_OK)
		return hr;

	// Update the ip address string
	//
	::GetLongString (m_dwIPAddress, &m_MtgInfo.szIPAddress[0]);

	// Update IP address in the server
	//
	return ::IlsUpdateIPAddress (	&m_ServerInfo,
									m_pszDN,
									STR_MTG_IP_ADDR,
									&m_MtgInfo.szIPAddress[0],
									ISBU_MODOP_MODIFY_USER,
									MtgGetPrefixCount (),
									MtgGetPrefixString ());
}


/* ---------- protected methods ----------- */


HRESULT SP_CMeeting::
SendRefreshMsg ( VOID )
{
	MyAssert (m_pszRefreshFilter != NULL);

	// Get local IP address
	//
	DWORD dwIPAddress = 0;
	HRESULT hr = ::GetLocalIPAddress (&dwIPAddress);
	if (hr != S_OK)
	{
		MyDebugMsg ((ZONE_KA, "KA(Mtg): cannot get my ip address\r\n"));

		// Indicate that I am not connected to the server anymore
		//
		SetRegLocally ();

		// Second, notify this app of the network being down
		//
		::PostMessage (g_hWndNotify, WM_ILS_MEETING_NETWORK_DOWN,
							(WPARAM) this, (LPARAM) m_dwContext);

		// Report error
		//
		return ILS_E_NETWORK_DOWN;
	}

	// If dwIPAddress is 0, then we are not on the network any more
	// start relogon process
	//
	if (dwIPAddress == 0)
	{
		MyDebugMsg ((ZONE_KA, "KA(Mtg): ip-addr=0, network down.\r\n"));

		// Indicate that I am not connected to the server anymore
		//
		SetRegLocally ();

		// Second, notify this app of the network being down
		//
		::PostMessage (g_hWndNotify, WM_ILS_MEETING_NETWORK_DOWN,
							(WPARAM) this, (LPARAM) m_dwContext);

		// Report error
		//
		return ILS_E_NETWORK_DOWN;
	}
	else
	// If dwIPAddress and m_dwIPAddress, alert
	//
	if (dwIPAddress != m_dwIPAddress)
	{
		UpdateIPAddress ();
	}

	// Send a refresh message to the server and parse the new TTL value
	//
	hr = ::IlsSendRefreshMsg (	&m_ServerInfo,
								STR_DEF_MTG_BASE_DN,
								STR_MTG_TTL,
								m_pszRefreshFilter,
								&m_uTTL);
	if (hr == ILS_E_NEED_RELOGON)
	{
		SetRegLocally ();
		::PostMessage (g_hWndNotify, WM_ILS_MEETING_NEED_RELOGON,
							(WPARAM) this, (LPARAM) m_dwContext);
	}
	else
	if (hr == ILS_E_NETWORK_DOWN)
	{
		SetRegLocally ();
		::PostMessage (g_hWndNotify, WM_ILS_MEETING_NETWORK_DOWN,
							(WPARAM) this, (LPARAM) m_dwContext);
	}

	return hr;
}


/* ---------- private methods ----------- */


HRESULT SP_CMeeting::
CreateRegModArr ( LDAPMod ***pppMod )
{
	MyAssert (pppMod != NULL);

	// Calculate the modify array size
	//
	ULONG cStdAttrs = COUNT_ENUM_MTGATTR;
	ULONG cAnyAttrs = m_MtgInfo.AnyAttrs.cAttrsToAdd;
	ULONG cTotal = cStdAttrs + cAnyAttrs;
	ULONG cbMod = ::IlsCalcModifyListSize (cTotal);

	// Allocate modify list
	//
	*pppMod = (LDAPMod **) MemAlloc (cbMod);
	if (*pppMod == NULL)
		return ILS_E_MEMORY;

	// Lay out the modify array
	//
	LDAPMod **apMod = *pppMod;
	LDAPMod *pMod;
	TCHAR *pszName, *pszValue;
	pszName = m_MtgInfo.AnyAttrs.pszAttrsToAdd;
	for (ULONG i = 0; i < cTotal; i++)
	{
		pMod = ::IlsGetModifyListMod (pppMod, cTotal, i);
		pMod->mod_op = LDAP_MOD_ADD;
		apMod[i] = pMod;

		if (i < cStdAttrs)
		{
			// Put standard attributes
			//
			::MtgFillModArrAttr (pMod, &m_MtgInfo, i);
		}
		else
		{
			// Put extended attributes
			//
			pszValue = pszName + lstrlen (pszName) + 1;
			::IlsFillModifyListItem (pMod, pszName, pszValue);
			pszName = pszValue + lstrlen (pszValue) + 1;
		}
	}

	// Put null to terminate modify list
	//
	apMod[cTotal] = NULL;
	return S_OK;
}



/* ---------- helper functions ----------- */


HRESULT
MtgSetAttrs (
	SERVER_INFO			*pServerInfo,
	TCHAR				*pszMtgName,
	LDAP_MEETINFO		*pInfo,
	ULONG				uRespID )
{
	MyAssert (pServerInfo != NULL);
	MyAssert (MyIsGoodString (pszMtgName));
	MyAssert (pInfo != NULL);

	// Cannot change lMeetingPlaceType, lAttendeeType, and MeetingID
	//
	if (pInfo->lMeetingPlaceType		!= INVALID_MEETING_TYPE ||
		pInfo->lAttendeeType			!= INVALID_ATTENDEE_TYPE ||
		pInfo->uOffsetMeetingPlaceID	!= INVALID_OFFSET)
	{
		return ILS_E_PARAMETER;
	}

	// Initialize locals
	//
	TCHAR *pszDN = NULL;
	LDAPMod **ppMod = NULL;
	SP_CSession *pSession = NULL;
	ULONG uMsgID = (ULONG) -1;

	MTG_INFO MtgInfo;
	ZeroMemory (&MtgInfo, sizeof (MtgInfo));

	// Cache the meeting info
	//
	HRESULT hr = MtgCacheInfo  (pInfo, &MtgInfo);
	if (hr != S_OK)
		goto MyExit;

	// Build DN for meeting
	//
	pszDN = IlsBuildDN (pServerInfo->pszBaseDN,
						(TCHAR *) &c_szMtgDefC[0],
						(TCHAR *) &c_szDefO[0],
						pszMtgName,
						(TCHAR *) &c_szRTConf[0]);
	if (pszDN == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Build modify array for ldap_modify()
	//
	hr = MtgCreateSetAttrsModArr (&ppMod, &MtgInfo);
	if (hr != S_OK)
		goto MyExit;
	MyAssert (ppMod != NULL);

	// Get the session object
	//
	LDAP *ld;
	hr = g_pSessionContainer->GetSession (&pSession, pServerInfo);
	if (hr == S_OK)
	{
		MyAssert (pSession != NULL);

		// Get the ldap session
		//
		ld = pSession->GetLd ();
		MyAssert (ld != NULL);

		// Send the data over the wire
		//
		uMsgID = ldap_modify (ld, pszDN, ppMod);
		if (uMsgID == (ULONG) -1)
		{
			hr = ::LdapError2Hresult (ld->ld_errno);
		}
	}

	// Report failure if so
	//
	if (hr != S_OK)
		goto MyExit;

	// Construct pending info
	//
	RESP_INFO ri;
	FillDefRespInfo (&ri, uRespID, ld, uMsgID, INVALID_MSG_ID);
	ri.uNotifyMsg = WM_ILS_SET_MEETING_INFO;

	// Remember the pending request
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		MyAssert (FALSE);
		goto MyExit;
	}

MyExit:

	MemFree (pszDN);
	MemFree (ppMod);
	IlsReleaseAnyAttrsPrefix (&(MtgInfo.AnyAttrs));

	if (hr != S_OK)
	{
		if (uMsgID != (ULONG) -1)
			::ldap_abandon (ld, uMsgID);

		if (pSession != NULL)
			pSession->Disconnect ();
	}

	return hr;
}


VOID
MtgFillModArrAttr (
	LDAPMod				*pMod,
	MTG_INFO			*pMtgInfo,
	INT					nIndex )
{
	MyAssert (pMod != NULL);
	MyAssert (pMtgInfo != NULL);
	MyAssert (0 <= nIndex && nIndex <= COUNT_ENUM_MTGATTR);

	IlsFillModifyListItem (	pMod,
							(TCHAR *) c_apszMtgStdAttrNames[nIndex],
							pMtgInfo->apszStdAttrValues[nIndex]);
}


HRESULT
MtgCreateSetAttrsModArr (
	LDAPMod				***pppMod,
	MTG_INFO			*pMtgInfo )
{
	MyAssert (pppMod != NULL);

	HRESULT hr;
	DWORD dwFlags = pMtgInfo->dwFlags;
	ULONG cTotal  = pMtgInfo->AnyAttrs.cAttrsToAdd +
					pMtgInfo->AnyAttrs.cAttrsToModify +
					pMtgInfo->AnyAttrs.cAttrsToRemove;

	// Lay out the modify array for modifying standard/extended attributes
	//
	hr = IlsFillDefStdAttrsModArr (pppMod,
								dwFlags,
								COUNT_ENUM_MTGINFO,
								&cTotal,
								ISBU_MODOP_MODIFY_USER,
								MtgGetPrefixCount (),
								MtgGetPrefixString ());
	if (hr != S_OK)
		return hr;

	// Start to fill standard attributes
	//
	ULONG i = MtgGetPrefixCount ();
	LDAPMod **apMod = *pppMod;

	if (dwFlags & MTGOBJ_F_NAME)
		MtgFillModArrAttr (apMod[i++], pMtgInfo, ENUM_MTGATTR_CN);

	if (dwFlags & MTGOBJ_F_MTG_TYPE)
		MtgFillModArrAttr (apMod[i++], pMtgInfo, ENUM_MTGATTR_MTG_TYPE);

	if (dwFlags & MTGOBJ_F_MEMBER_TYPE)
		MtgFillModArrAttr (apMod[i++], pMtgInfo, ENUM_MTGATTR_MEMBER_TYPE);

	if (dwFlags & MTGOBJ_F_DESCRIPTION)
		MtgFillModArrAttr (apMod[i++], pMtgInfo, ENUM_MTGATTR_DESCRIPTION);

	if (dwFlags & MTGOBJ_F_HOST_NAME)
		MtgFillModArrAttr (apMod[i++], pMtgInfo, ENUM_MTGATTR_HOST_NAME);

	if (dwFlags & MTGOBJ_F_IP_ADDRESS)
		MtgFillModArrAttr (apMod[i++], pMtgInfo, ENUM_MTGATTR_IP_ADDRESS);

	// Start to fill extended attributes
	//
	::IlsFillModifyListForAnyAttrs (apMod, &i, &(pMtgInfo->AnyAttrs));

	MyAssert (i == cTotal);
	return S_OK;
}


HRESULT
MtgCacheInfo (
	LDAP_MEETINFO		*pInfo,
	MTG_INFO			*pMtgInfo )
{
	MyAssert (pInfo != NULL);
	MyAssert (pMtgInfo != NULL);

	// Release the previous prefix for extended attribute names
	//
	IlsReleaseAnyAttrsPrefix (&(pMtgInfo->AnyAttrs));

	// Clean up the buffer
	//
	ZeroMemory (pMtgInfo, sizeof (*pMtgInfo));

	// Start to cache mtg standard attributes
	//

	if (pInfo->lMeetingPlaceType != INVALID_MEETING_TYPE)
	{
		GetLongString (pInfo->lMeetingPlaceType, &(pMtgInfo->szMtgType[0]));
		pMtgInfo->apszStdAttrValues[ENUM_MTGATTR_MTG_TYPE] = &(pMtgInfo->szMtgType[0]);
		pMtgInfo->dwFlags |= MTGOBJ_F_MTG_TYPE;
	}

	if (pInfo->lAttendeeType != INVALID_ATTENDEE_TYPE)
	{
		GetLongString (pInfo->lAttendeeType, &(pMtgInfo->szMemberType[0]));
		pMtgInfo->apszStdAttrValues[ENUM_MTGATTR_MEMBER_TYPE] = &(pMtgInfo->szMemberType[0]);
		pMtgInfo->dwFlags |= MTGOBJ_F_MEMBER_TYPE;
	}

	if (pInfo->uOffsetMeetingPlaceID != INVALID_OFFSET)
	{
		pMtgInfo->apszStdAttrValues[ENUM_MTGATTR_CN] =
					(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetMeetingPlaceID);
		pMtgInfo->dwFlags |= MTGOBJ_F_NAME;
	}

	if (pInfo->uOffsetDescription != INVALID_OFFSET)
	{
		pMtgInfo->apszStdAttrValues[ENUM_MTGATTR_DESCRIPTION] =
					(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetDescription);
		pMtgInfo->dwFlags |= MTGOBJ_F_DESCRIPTION;
	}

	if (pInfo->uOffsetHostName != INVALID_OFFSET)
	{
		pMtgInfo->apszStdAttrValues[ENUM_MTGATTR_HOST_NAME] =
					(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetHostName);
		pMtgInfo->dwFlags |= MTGOBJ_F_HOST_NAME;
	}

	if (pInfo->uOffsetHostIPAddress != INVALID_OFFSET)
	{
		pMtgInfo->apszStdAttrValues[ENUM_MTGATTR_IP_ADDRESS] =
					(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetHostIPAddress);
		pMtgInfo->dwFlags |= MTGOBJ_F_IP_ADDRESS;
	}

	// Start to cache mtg extended attributes
	//

	if (pInfo->uOffsetAttrsToAdd != INVALID_OFFSET &&
		pInfo->cAttrsToAdd != 0)
	{
		pMtgInfo->AnyAttrs.cAttrsToAdd = pInfo->cAttrsToAdd;
		pMtgInfo->AnyAttrs.pszAttrsToAdd =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetAttrsToAdd);
	}

	if (pInfo->uOffsetAttrsToModify != INVALID_OFFSET &&
		pInfo->cAttrsToModify != 0)
	{
		pMtgInfo->AnyAttrs.cAttrsToModify = pInfo->cAttrsToModify;
		pMtgInfo->AnyAttrs.pszAttrsToModify =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetAttrsToModify);
	}

	if (pInfo->uOffsetAttrsToRemove != INVALID_OFFSET &&
		pInfo->cAttrsToRemove != 0)
	{
		pMtgInfo->AnyAttrs.cAttrsToRemove = pInfo->cAttrsToRemove;
		pMtgInfo->AnyAttrs.pszAttrsToRemove =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetAttrsToRemove);
	}

	// Create prefix for extended attribute names
	//
	return IlsCreateAnyAttrsPrefix (&(pMtgInfo->AnyAttrs));
}


HRESULT
MtgUpdateMembers (
	ULONG			uNotifyMsg,
	SERVER_INFO		*pServerInfo,
	TCHAR			*pszMtgName,
	ULONG			cMembers,
	TCHAR			*pszMemberNames,
	ULONG			uRespID )
{
	MyAssert (	uNotifyMsg == WM_ILS_ADD_ATTENDEE ||
				uNotifyMsg == WM_ILS_REMOVE_ATTENDEE);

	MyAssert (pServerInfo != NULL);
	MyAssert (MyIsGoodString (pszMtgName));
	MyAssert (MyIsGoodString (pszMemberNames));

	// Initialize locals
	//
	HRESULT hr = S_OK;
	TCHAR *pszDN = NULL;
	LDAPMod **ppMod = NULL;
	SP_CSession *pSession = NULL;
	ULONG uMsgID = (ULONG) -1;

	// Build DN for meeting
	//
	pszDN = IlsBuildDN (pServerInfo->pszBaseDN,
						(TCHAR *) &c_szMtgDefC[0],
						(TCHAR *) &c_szDefO[0],
						pszMtgName,
						(TCHAR *) &c_szRTConf[0]);
	if (pszDN == NULL)
		return ILS_E_MEMORY;

	// Build modify array for ldap_modify()
	//
	hr = MtgCreateUpdateMemberModArr (	uNotifyMsg,
										&ppMod,
										cMembers,
										pszMemberNames);
	if (hr != S_OK)
		goto MyExit;
	MyAssert (ppMod != NULL);

	// Get the session object
	//
	LDAP *ld;
	hr = g_pSessionContainer->GetSession (&pSession, pServerInfo);
	if (hr == S_OK)
	{
		MyAssert (pSession != NULL);

		// Get the ldap session
		//
		ld = pSession->GetLd ();
		MyAssert (ld != NULL);

		// Send the data over the wire
		//
		uMsgID = ldap_modify (ld, pszDN, ppMod);
		if (uMsgID == (ULONG) -1)
		{
			hr = ::LdapError2Hresult (ld->ld_errno);
		}
	}

	// Report failure if so
	//
	if (hr != S_OK)
		goto MyExit;

	// Construct pending info
	//
	RESP_INFO ri;
	FillDefRespInfo (&ri, uRespID, ld, uMsgID, INVALID_MSG_ID);
	ri.uNotifyMsg = uNotifyMsg;

	// Remember the pending request
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		MyAssert (FALSE);
		goto MyExit;
	}

MyExit:

	MemFree (pszDN);
	MemFree (ppMod);

	if (hr != S_OK)
	{
		if (uMsgID != (ULONG) -1)
			::ldap_abandon (ld, uMsgID);

		if (pSession != NULL)
			pSession->Disconnect ();
	}

	return hr;
}


HRESULT
MtgCreateUpdateMemberModArr (
	ULONG				uNotifyMsg,
	LDAPMod				***pppMod,
	ULONG				cMembers,
	TCHAR				*pszMemberNames )
{
	MyAssert (pppMod != NULL);
	MyAssert (pszMemberNames != NULL);

	// Get meeting object prefix
	//
	ULONG cPrefix = MtgGetPrefixCount ();
	TCHAR *pszPrefix = MtgGetPrefixString ();

	// The total number of attributes is the number of prefix attributes
	// plus the very only ConfMemberList
	//
	ULONG cStdAttrs = 1;
	ULONG cTotal = cPrefix + cStdAttrs;

	// Calculate the modify array's total size
	//
	ULONG cbMod = IlsCalcModifyListSize (cTotal);

	// Add up for multi-valued attribute
	//
	cbMod += cStdAttrs * (cMembers - 1) * sizeof (TCHAR *);

	// Allocate the modify array
	//
	LDAPMod **apMod = *pppMod = (LDAPMod **) MemAlloc (cbMod);
	if (apMod == NULL)
		return ILS_E_MEMORY;

	// Fill in the modify list
	//
	LDAPMod *pMod;
	BYTE *pbData = (BYTE *) apMod + (cTotal + 1) * sizeof (LDAPMod *);
	ULONG uDispPrefix = sizeof (LDAPMod) + 2 * sizeof (TCHAR *);
	ULONG uDispStdAttrs = sizeof (LDAPMod) + (cMembers + 1) * sizeof (TCHAR *);
	for (ULONG uOffset = 0, i = 0; i < cTotal; i++)
	{
		// Locate the modify structure
		//
		pMod = (LDAPMod *) (pbData + uOffset);
		apMod[i] = pMod;
		pMod->mod_values = (TCHAR **) (pMod + 1);

		// Fill in the modify structure
		//
		if (i < cPrefix)
		{
			pMod->mod_op = LDAP_MOD_REPLACE;
			pMod->mod_type = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
			*(pMod->mod_values) = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
		}
		else
		{
			// Fill in attribute name
			//
			pMod->mod_op = (uNotifyMsg == WM_ILS_ADD_ATTENDEE) ?
							LDAP_MOD_ADD : LDAP_MOD_DELETE;
			pMod->mod_type = (TCHAR *) c_apszMtgStdAttrNames[ENUM_MTGATTR_MEMBERS];

		    // Fill in multi-valued modify array
		    //
		    for (ULONG j = 0; j < cMembers; j++)
		    {
		    	(pMod->mod_values)[j++] = pszMemberNames;
		    	pszMemberNames += lstrlen (pszMemberNames) + 1;
		    }
		}

		// Calculate the modify structure's offset relative to the array's end
		//
		uOffset += (i < cPrefix) ? uDispPrefix : uDispStdAttrs;
	}

	// Fix up the first and the last ones
	//
	IlsFixUpModOp (apMod[0], LDAP_MOD_REPLACE, ISBU_MODOP_MODIFY_APP);
	apMod[cTotal] = NULL;

	return S_OK;
}


#endif // ENABLE_MEETING_PLACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\spils.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spils.cpp
	Content:	This file contains the ILS specifics.
	History:
	12/10/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"

#include "winsock.h"
#include "ping.h"

// Constant string for ISBU's special modify-operation attribute
//
const TCHAR c_szModOp[] = { TEXT ('s'), TEXT ('m'), TEXT ('o'), TEXT ('d'),
							TEXT ('o'), TEXT ('p'), TEXT ('\0'),
							TEXT ('0'), TEXT ('\0')}; //TEXT ("smodop\0000");

ULONG g_cbUserPrefix = sizeof (c_szModOp);
TCHAR *g_pszUserPrefix = NULL;
ULONG g_cbMtgPrefix = sizeof (c_szModOp);
TCHAR *g_pszMtgPrefix = NULL;


CPing *g_pPing = NULL;


HRESULT
IlsInitialize ( VOID )
{
	// Allocate the ping object
	//
	g_pPing = new CPing;
	if (g_pPing == NULL)
		return ILS_E_MEMORY;

	// Allocate user prefix
	//
	g_pszUserPrefix = (TCHAR *) MemAlloc (g_cbUserPrefix);
	if (g_pszUserPrefix == NULL)
		return ILS_E_MEMORY;

	// Fill in user prefix string
	//
	TCHAR *psz = g_pszUserPrefix;
	lstrcpy (psz, &c_szModOp[0]);
	psz += lstrlen (psz) + 1;
	lstrcpy (psz, TEXT ("0"));

	// Allocate mtg prefix
	//
	g_pszMtgPrefix = (TCHAR *) MemAlloc (g_cbMtgPrefix);
	if (g_pszMtgPrefix == NULL)
	{
		MemFree (g_pszUserPrefix);
		g_pszUserPrefix = NULL;
		return ILS_E_MEMORY;
	}

	// Fill in mtg prefix string
	//
	psz = g_pszMtgPrefix;
	lstrcpy (psz, &c_szModOp[0]);
	psz += lstrlen (psz) + 1;
	lstrcpy (psz, TEXT ("0"));

	return S_OK;
}


HRESULT
IlsCleanup ( VOID )
{
	// Free the ping object
	//
	if (g_pPing != NULL)
	{
		delete g_pPing;
		g_pPing = NULL;
	}

	// Free user prefix string
	//
	MemFree (g_pszUserPrefix);
	g_pszUserPrefix = NULL;

	// Free mtg prefix string
	//
	MemFree (g_pszMtgPrefix);
	g_pszMtgPrefix = NULL;

	return S_OK;
}


ULONG
IlsCalcModifyListSize ( ULONG cAttrs )
{
	ULONG cbSize;

	// array itself
	cbSize = (cAttrs + 1) * sizeof (LDAPMod *);

	// array elements
	cbSize += cAttrs * sizeof (LDAPMod);

	// single valued attribute requires two pointers
	cbSize += cAttrs * 2 * sizeof (TCHAR *);

	return cbSize;
}


LDAPMod *
IlsGetModifyListMod ( LDAPMod ***pppMod, ULONG cAttrs, LONG AttrIdx )
{
	return (LDAPMod *) (((BYTE *) *pppMod) +
							(cAttrs + 1) * sizeof (LDAPMod *) +
							AttrIdx * (sizeof (LDAPMod) + 2 * sizeof (TCHAR *)));
}


VOID
IlsFillModifyListItem (
	LDAPMod		*pMod,
	TCHAR		*pszAttrName,
	TCHAR		*pszAttrValue )
{
	MyAssert (pMod != NULL);
	MyAssert (pszAttrName != NULL);

	// Set attribute name
	//
	pMod->mod_type = pszAttrName;

	// Set single valued attribute value
	//
	TCHAR **ppsz = (TCHAR **) (pMod + 1);
	pMod->mod_values = ppsz;
	*ppsz++ = (pszAttrValue != NULL) ?	pszAttrValue : STR_EMPTY;

	// Set null string to terminate this array of values
	//
	*ppsz = NULL;
}


VOID
IlsFillModifyListForAnyAttrs (
	LDAPMod			*apMod[],
	ULONG			*puIndex,
	ANY_ATTRS		*pAnyAttrs )
{
	LDAPMod *pMod;
	TCHAR *pszName, *pszValue;
	ULONG i = *puIndex, j;

	// Put in extended attributes to add
	//
	pszName = pAnyAttrs->pszAttrsToAdd;
	for (j = 0; j < pAnyAttrs->cAttrsToAdd; j++)
	{
		pMod = apMod[i++];
		pMod->mod_op = LDAP_MOD_ADD;
		pszValue = pszName + lstrlen (pszName) + 1;
		IlsFillModifyListItem (pMod, pszName, pszValue);
		pszName = pszValue + lstrlen (pszValue) + 1;
	}

	// Put in extended attributes to modify
	//
	pszName = pAnyAttrs->pszAttrsToModify;
	for (j = 0; j < pAnyAttrs->cAttrsToModify; j++)
	{
		pMod = apMod[i++];
		pMod->mod_op = LDAP_MOD_REPLACE;
		pszValue = pszName + lstrlen (pszName) + 1;
		IlsFillModifyListItem (pMod, pszName, pszValue);
		pszName = pszValue + lstrlen (pszValue) + 1;
	}

	// Put in extended attributes to remove
	//
	pszName = pAnyAttrs->pszAttrsToRemove;
	for (j = 0; j < pAnyAttrs->cAttrsToRemove; j++)
	{
		pMod = apMod[i++];
		pMod->mod_op = LDAP_MOD_DELETE;
		IlsFillModifyListItem (pMod, pszName, NULL);
		pszName = pszName + lstrlen (pszName) + 1;
	}

	// Return the running index
	//
	*puIndex = i;
}


TCHAR c_szModOp_AddApp[] = TEXT ("0");
TCHAR c_szModOp_DeleteApp[] = TEXT ("1");
TCHAR c_szModOp_ModifyUser[] = TEXT ("2");
TCHAR c_szModOp_ModifyApp[] = TEXT ("3");


VOID
IlsFixUpModOp ( LDAPMod *pMod, LONG LdapModOp, LONG IsbuModOp )
{
	MyAssert (pMod != NULL);

	pMod->mod_op = LdapModOp;
	// pMod->mod_op = LDAP_MOD_ADD; // lonchanc: MUST MUST MUST
	pMod->mod_type = (TCHAR *) &c_szModOp[0];
	pMod->mod_values = (TCHAR **) (pMod + 1);

	switch (IsbuModOp)
	{
	case ISBU_MODOP_ADD_APP:
		*(pMod->mod_values) = &c_szModOp_AddApp[0];
		break;
	case ISBU_MODOP_DELETE_APP:
		*(pMod->mod_values) = &c_szModOp_DeleteApp[0];
		break;
	case ISBU_MODOP_MODIFY_USER:
		*(pMod->mod_values) = &c_szModOp_ModifyUser[0];
		break;
	case ISBU_MODOP_MODIFY_APP:
		*(pMod->mod_values) = &c_szModOp_ModifyApp[0];
		break;
	default:
		MyAssert (FALSE);
		break;
	}
}



HRESULT
IlsParseRefreshPeriod (
	LDAP		*ld,
	LDAPMessage	*pLdapMsg,
	const TCHAR	*pszTtlAttrName,
	ULONG		*puTTL )
{
	MyAssert (ld != NULL);
	MyAssert (pLdapMsg != NULL);
	MyAssert (pszTtlAttrName != NULL);
	MyAssert (puTTL != NULL);

	HRESULT hr;
	ULONG uRefreshPeriod;	
	ULONG tcRefreshPeriod;	

	// Get the first entry
	//
	LDAPMessage *pEntry = ldap_first_entry (ld, pLdapMsg);
	if (pEntry == NULL)
	{
		MyAssert (FALSE);
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Get the sTTL attribute
	//
	TCHAR **ppszAttrVal;
	ppszAttrVal = my_ldap_get_values (ld, pEntry, (TCHAR *) pszTtlAttrName);
	if (ppszAttrVal == NULL || *ppszAttrVal == NULL)
	{
		MyAssert (FALSE);
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Convert string to long
	//
	uRefreshPeriod = ::GetStringLong (*ppszAttrVal);

	// Reserve two-minute overhead
	//
	if (uRefreshPeriod > ILS_DEF_REFRESH_MARGIN_MINUTE)
		uRefreshPeriod -= ILS_DEF_REFRESH_MARGIN_MINUTE;

	// Make sure we have a safe, reasonable refresh period at least
	//
	if (uRefreshPeriod < ILS_DEF_REFRESH_MARGIN_MINUTE)
		uRefreshPeriod = ILS_DEF_REFRESH_MARGIN_MINUTE;

	// Convert min to ms
	//
	tcRefreshPeriod = Minute2TickCount (uRefreshPeriod);

	// Free the attribute value
	//
	ldap_value_free (ppszAttrVal);

	// Update ttl
	//
	*puTTL = uRefreshPeriod; // in unit of minute

	hr = S_OK;

MyExit:

	if (hr != S_OK)
	{
		MyAssert (FALSE);
	}

	return hr;
}


HRESULT
IlsUpdateOneAttr (
	SERVER_INFO	*pServerInfo,
	TCHAR		*pszDN,
	TCHAR 		*pszAttrName,
	TCHAR		*pszAttrValue,
	LONG		nModifyMagic,
	ULONG		cPrefix,
	TCHAR		*pszPrefix,
	SP_CSession **ppSession,	// output
	ULONG		*puMsgID )			// output
{
	MyAssert (pServerInfo != NULL);
	MyAssert (pszDN != NULL);
	MyAssert (pszAttrName != NULL);
	MyAssert (pszAttrValue != NULL);
	MyAssert (	nModifyMagic == ISBU_MODOP_MODIFY_USER ||
				nModifyMagic == ISBU_MODOP_MODIFY_APP);
	MyAssert (ppSession != NULL);
	MyAssert (puMsgID != NULL);

	// Build modify array for ldap_modify()
	//
	LDAP *ld;
	LDAPMod **ppMod = NULL;
	ULONG cTotal = 0;
	HRESULT hr = IlsFillDefStdAttrsModArr (&ppMod,
										1, // one attribute (i.e. IP addr)
										1, // max? there is only one attr, come on
										&cTotal,
										nModifyMagic,
										cPrefix,
										pszPrefix);
	if (hr != S_OK)
		goto MyExit;

	// Fill in modify list
	//
	MyAssert (ppMod != NULL);
	LDAPMod *pMod;
	pMod = ppMod[cPrefix];
	MyAssert (pMod != NULL);
	pMod->mod_type = pszAttrName;

	// Put in ip address
	//
	pMod->mod_values = (TCHAR **) (pMod + 1);
	*(pMod->mod_values) = pszAttrValue;

	// Get the session object
	//
	hr = g_pSessionContainer->GetSession (ppSession, pServerInfo, FALSE);
	if (hr != S_OK)
		goto MyExit;
	MyAssert (*ppSession != NULL);

	// Get the ldap session
	//
	ld = (*ppSession)->GetLd ();
	MyAssert (ld != NULL);

	// Send the data over the wire
	//
	*puMsgID = ldap_modify (ld, pszDN, ppMod);
	if (*puMsgID == -1)
	{
		hr = ::LdapError2Hresult (ld->ld_errno);
		(*ppSession)->Disconnect ();
		goto MyExit;
	}

	// Success
	//
	hr = S_OK;
		
MyExit:

	MemFree (ppMod);
	return hr;
}


HRESULT
IlsUpdateIPAddress (
	SERVER_INFO	*pServerInfo,
	TCHAR		*pszDN,
	TCHAR 		*pszIPAddrName,
	TCHAR		*pszIPAddrValue,
	LONG		nModifyMagic,
	ULONG		cPrefix,
	TCHAR		*pszPrefix )
{
	SP_CSession *pSession = NULL;
	LDAP *ld;
	ULONG uMsgID;

	// Update the ip address attribute on the server
	//
	HRESULT hr = IlsUpdateOneAttr (	pServerInfo,
									pszDN,
									pszIPAddrName,
									pszIPAddrValue,
									nModifyMagic,
									cPrefix,
									pszPrefix,
									&pSession,
									&uMsgID);
	if (hr != S_OK)
		return hr;

	// Get the ldap session
	//
	MyAssert (pSession != NULL);
	ld = pSession->GetLd ();
	MyAssert (ld != NULL);

	// Let's wait for the result
	//
	LDAP_TIMEVAL TimeVal;
	TimeVal.tv_usec = 0;
	TimeVal.tv_sec = pSession->GetServerTimeoutInSecond ();

	// We don't care the result.
	// Should it fails, nothing we can do.
	// We can try it again in next keep alive time.
	//
	LDAPMessage *pLdapMsg;
	pLdapMsg = NULL;
	ldap_result (ld, uMsgID, LDAP_MSG_ALL, &TimeVal, &pLdapMsg);

	// Free message
	//
	if (pLdapMsg != NULL)
		ldap_msgfree (pLdapMsg);

	
	// Free up the session
	//
	if (pSession != NULL)
		pSession->Disconnect ();

	return S_OK;
}



HRESULT
IlsSendRefreshMsg (
	SERVER_INFO		*pServerInfo,
	TCHAR			*pszBaseDN,
	TCHAR			*pszTTL,
	TCHAR			*pszRefreshFilter,
	ULONG			*puTTL )
{
	MyAssert (pServerInfo != NULL);
	MyAssert (MyIsGoodString (pszBaseDN));
	MyAssert (MyIsGoodString (pszTTL));
	MyAssert (MyIsGoodString (pszRefreshFilter));
	MyAssert (puTTL != NULL);

	// Let's check to see if we need to use Ping...
	//
	if (g_pPing != NULL && g_pPing->IsAutodialEnabled ())
	{
		LPTSTR pszServerName = My_strdup(pServerInfo->pszServerName);
		if (NULL == pszServerName)
		{
			return E_OUTOFMEMORY;
		}
		LPTSTR pszSeparator = My_strchr(pszServerName, _T(':'));
		if (NULL != pszSeparator)
		{
			*pszSeparator = _T('\0');
		}
	
		DWORD dwIPAddr = inet_addr (pszServerName);
		MemFree(pszServerName);
		if (dwIPAddr != INADDR_NONE)
		{
			if (g_pPing->Ping (dwIPAddr, 10 * 1000, 9) == S_FALSE)
			{
				MyDebugMsg ((ZONE_KA, "KA: ping failed, network down\r\n"));

				// The "ping" operation failed, but other operations failed
				//
				return ILS_E_NETWORK_DOWN;
			}
		}
	}

	// Get the connection object
	//
	SP_CSession *pSession = NULL;
	HRESULT hr = g_pSessionContainer->GetSession (&pSession, pServerInfo, FALSE);
	if (hr != S_OK)
	{
		MyDebugMsg ((ZONE_KA, "KA: network down, hr=0x%lX\r\n", hr));

		// Report error
		//
		return ILS_E_NETWORK_DOWN;
	}
	MyAssert (pSession != NULL);

	// Get the ldap session
	//
	LDAP *ld = pSession->GetLd ();
	MyAssert (ld != NULL);

	// Set attributes to return
	//
	TCHAR *apszAttrNames[2];
	apszAttrNames[0] = pszTTL;
	apszAttrNames[1] = NULL;

	// Update options in ld
	//
	ld->ld_sizelimit = 0;	// no limit in the num of entries to return
	ld->ld_timelimit = 0;	// no limit on the time to spend on the search
	ld->ld_deref = LDAP_DEREF_ALWAYS;

	// Send search query
	//
	MyDebugMsg ((ZONE_KA, "KA: calling ldap_search()...\r\n"));
	ULONG uMsgID = ::ldap_search (	ld,
									pszBaseDN, // base DN
									LDAP_SCOPE_BASE, // scope
									pszRefreshFilter, // filter
									&apszAttrNames[0], // attrs[]
									0);	// both type and value
	if (uMsgID == -1)
	{
		MyDebugMsg ((ZONE_KA, "KA: ldap_search() failed\r\n"));
		hr = ::LdapError2Hresult (ld->ld_errno);
		pSession->Disconnect ();
		return hr;
	}

	// Let's wait for the result
	//
	LDAP_TIMEVAL TimeVal;
	TimeVal.tv_usec = 0;
	TimeVal.tv_sec = pSession->GetServerTimeoutInSecond ();

	// Wait and get the result back
	//
	LDAPMessage *pLdapMsg = NULL;
	INT ResultType = ::ldap_result (ld, uMsgID, LDAP_MSG_ALL, &TimeVal, &pLdapMsg);
	if (ResultType == LDAP_RES_SEARCH_ENTRY ||
		ResultType == LDAP_RES_SEARCH_RESULT)
	{
		if (pLdapMsg != NULL)
		{
			switch (pLdapMsg->lm_returncode)
			{
			case LDAP_NO_SUCH_OBJECT:
				MyDebugMsg ((ZONE_KA, "KA: no such object!\r\n"));

				// Report error
				//
				hr = ILS_E_NEED_RELOGON;
				break;

			case LDAP_SUCCESS:
				// Get the new refresh period
				//
				hr = ::IlsParseRefreshPeriod (ld, pLdapMsg, pszTTL, puTTL);
				break;

			default:
				MyDebugMsg ((ZONE_KA, "KA: unknown lm_returncode=%ld\r\n", pLdapMsg->lm_returncode));
				MyAssert (FALSE);
				hr = ::LdapError2Hresult (ld->ld_errno);
				break;
			}
	
			// Free this message
			//
			ldap_msgfree (pLdapMsg);
		} // if (pLdapMsg != NULL)
		else
		{
			hr = ILS_E_FAIL;
		}
	} // not timeout
	else
	{
		// Timeout
		//
		hr = ILS_E_TIMEOUT;
	}

	// Free up the session
	//
	pSession->Disconnect ();
	return hr;
}


HRESULT
IlsFillDefStdAttrsModArr (
	LDAPMod			***pppMod,
	DWORD			dwFlags,
	ULONG			cMaxAttrs,
	ULONG			*pcTotal,	// in/out parameter!!!
	LONG			IsbuModOp,
	ULONG			cPrefix,
	TCHAR			*pszPrefix )
{

	MyAssert (pppMod != NULL);
	MyAssert (pcTotal != NULL);
	MyAssert (	(cPrefix == 0 && pszPrefix == NULL) ||
				(cPrefix != 0 && pszPrefix != NULL));

	// Figure out the num of attributes
	//
	ULONG cAttrs = 0;
	for (ULONG i = 0; i < cMaxAttrs; i++)
	{
		if (dwFlags & 0x01)
			cAttrs++;
		dwFlags >>= 1;
	}

	// Allocate modify list
	//
	ULONG cTotal = *pcTotal + cPrefix + cAttrs;
	ULONG cbMod = IlsCalcModifyListSize (cTotal);
	*pppMod = (LDAPMod **) MemAlloc (cbMod);
	if (*pppMod == NULL)
		return ILS_E_MEMORY;

	// Fill in the modify list
	//
	LDAPMod *pMod;
	for (i = 0; i < cTotal; i++)
	{
		pMod = IlsGetModifyListMod (pppMod, cTotal, i);
		(*pppMod)[i] = pMod;
		pMod->mod_values = (TCHAR **) (pMod + 1);

		if (i < cPrefix)
		{
			pMod->mod_op = LDAP_MOD_REPLACE;
			pMod->mod_type = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
			*(pMod->mod_values) = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
		}
	}

	// Fix up the first and the last ones
	//
	IlsFixUpModOp ((*pppMod)[0], LDAP_MOD_REPLACE, IsbuModOp);
	(*pppMod)[cTotal] = NULL;

	// Return the total number of entries
	//
	*pcTotal = cTotal;

	return S_OK;
}


const TCHAR c_szAnyAttrPrefix[] = TEXT ("ILSA");
#define SIZE_ANY_ATTR_PREFIX	(sizeof (c_szAnyAttrPrefix) / sizeof (TCHAR))


const TCHAR *
UlsLdap_GetExtAttrNamePrefix ( VOID )
{
	return &c_szAnyAttrPrefix[0];
}


const TCHAR *
IlsSkipAnyAttrNamePrefix ( const TCHAR *pszAttrName )
{
	MyAssert (pszAttrName != NULL);

	const TCHAR *psz = IlsIsAnyAttrName (pszAttrName);
	if (psz == NULL)
	{
		MyAssert (FALSE);
		psz = pszAttrName;
	}

	return psz;
}


const TCHAR *
IlsIsAnyAttrName ( const TCHAR *pszAttrName )
{
	BOOL fRet = FALSE;
	TCHAR *psz = (TCHAR *) pszAttrName;

	if (pszAttrName != NULL)
	{
		if (lstrlen (pszAttrName) > SIZE_ANY_ATTR_PREFIX)
		{
			TCHAR c = pszAttrName[SIZE_ANY_ATTR_PREFIX-1];
			psz[SIZE_ANY_ATTR_PREFIX-1] = TEXT ('\0');
			fRet = (My_lstrcmpi (pszAttrName, &c_szAnyAttrPrefix[0]) == 0);
			psz[SIZE_ANY_ATTR_PREFIX-1] = c;
		}
	}

	return (fRet ? &pszAttrName[SIZE_ANY_ATTR_PREFIX-1] : NULL);
}


TCHAR *
IlsPrefixNameValueArray (
	BOOL			fPair,
	ULONG			cAttrs,
	const TCHAR		*pszAttrs )
{
	if (cAttrs == 0 || pszAttrs == NULL)
	{
		MyAssert (FALSE);
		return NULL;
	}

	// compute the total size required
	ULONG cbTotalSize = 0;
	ULONG cbThisSize;
	TCHAR *pszSrc = (TCHAR *) pszAttrs;
	for (ULONG i = 0; i < cAttrs; i++)
	{
		// get name size
		cbThisSize = lstrlen (pszSrc) + 1;
		pszSrc += lstrlen (pszSrc) + 1;

		// get value size as needed
		if (fPair)
		{
			cbThisSize += lstrlen (pszSrc) + 1;
			pszSrc += lstrlen (pszSrc) + 1;
		}

		// adjust the size
		cbThisSize += SIZE_ANY_ATTR_PREFIX;
		cbThisSize *= sizeof (TCHAR);

		// accumulate it
		cbTotalSize += cbThisSize;
	}

	// allocate the new buffer
	TCHAR *pszPrefixAttrs = (TCHAR *) MemAlloc (cbTotalSize);
	if (pszPrefixAttrs == NULL)
		return NULL;

	// copy the strings over to the new buffer
	pszSrc = (TCHAR *) pszAttrs;
	TCHAR *pszDst = pszPrefixAttrs;
	for (i = 0; i < cAttrs; i++)
	{
		// copy prefix
		lstrcpy (pszDst, &c_szAnyAttrPrefix[0]);
		pszDst += lstrlen (pszDst); // no plus 1

		// copy name
		lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
		pszSrc += lstrlen (pszSrc) + 1;

		// copy value as needed
		if (fPair)
		{
			lstrcpy (pszDst, pszSrc);
			pszDst += lstrlen (pszDst) + 1;
			pszSrc += lstrlen (pszSrc) + 1;
		}
	}

	return pszPrefixAttrs;
}


TCHAR *
IlsBuildDN (
	TCHAR			*pszBaseDN,
	TCHAR			*pszC,
	TCHAR			*pszO,
	TCHAR			*pszCN,
	TCHAR			*pszObjectClass )
{
	MyAssert (MyIsGoodString (pszCN));
	MyAssert (MyIsGoodString (pszObjectClass));

	static TCHAR s_szC[] = TEXT ("c=");
	static TCHAR s_szO[] = TEXT ("o=");
	static TCHAR s_szCN[] = TEXT ("cn=");
	static TCHAR s_szObjectClass[] = TEXT ("objectClass=");
	static TCHAR s_szDelimiter[] = TEXT (", ");
	enum { C_LENGTH = 2 };
	enum { O_LENGTH = 2 };
	enum { CN_LENGTH = 3 };
	enum { OBJECTCLASS_LENGTH = 12 };
	enum { DELIMITER_LENGTH = 2 };

	ULONG	cchDN = 1;
	BOOL fInBaseDN;

	ASSERT(MyIsGoodString(pszC));

	cchDN += lstrlen (pszC) + DELIMITER_LENGTH + C_LENGTH;

	if (MyIsGoodString (pszBaseDN))
	{
		fInBaseDN = TRUE;

		cchDN += lstrlen (pszBaseDN) + DELIMITER_LENGTH;
	}
	else
	{
		fInBaseDN = FALSE;

		if (MyIsGoodString (pszO))
			cchDN += lstrlen (pszO) + DELIMITER_LENGTH + O_LENGTH;
	}

	if (MyIsGoodString (pszCN))
		cchDN += lstrlen (pszCN) + CN_LENGTH;

	if (MyIsGoodString (pszObjectClass))
		cchDN += lstrlen (pszObjectClass) + DELIMITER_LENGTH + OBJECTCLASS_LENGTH;

	TCHAR *pszDN = (TCHAR *) MemAlloc (cchDN * sizeof (TCHAR));
	if (pszDN != NULL)
	{
		TCHAR *psz = pszDN;
		psz[0] = TEXT ('\0');

		if (MyIsGoodString (pszC))
		{
			lstrcpy (psz, &s_szC[0]);
			psz += lstrlen (psz);
			lstrcpy (psz, pszC);
			psz += lstrlen (psz);
		}

		if (fInBaseDN)
		{
			if (psz != pszDN)
			{
				lstrcpy (psz, &s_szDelimiter[0]);
				psz += lstrlen (psz);
			}

			lstrcpy (psz, pszBaseDN);
			psz += lstrlen (psz);
		}
		else
		{
			if (MyIsGoodString (pszO))
			{
				if (psz != pszDN)
				{
					lstrcpy (psz, &s_szDelimiter[0]);
					psz += lstrlen (psz);
				}

				lstrcpy (psz, &s_szO[0]);
				psz += lstrlen (psz);
				lstrcpy (psz, pszO);
				psz += lstrlen (psz);
			}
		}

		if (MyIsGoodString (pszCN))
		{
			if (psz != pszDN)
			{
				lstrcpy (psz, &s_szDelimiter[0]);
				psz += lstrlen (psz);
			}

			lstrcpy (psz, &s_szCN[0]);
			psz += lstrlen (psz);
			lstrcpy (psz, pszCN);
			psz += lstrlen (psz);
		}

		if (MyIsGoodString (pszObjectClass))
		{
			if (psz != pszDN)
			{
				lstrcpy (psz, &s_szDelimiter[0]);
				psz += lstrlen (psz);
			}

			lstrcpy (psz, &s_szObjectClass[0]);
			psz += lstrlen (psz);
			lstrcpy (psz, pszObjectClass);
			psz += lstrlen (psz);
		}

		MyAssert (psz == pszDN + cchDN - 1);
	}

	return pszDN;
}



HRESULT
IlsCreateAnyAttrsPrefix ( ANY_ATTRS *pAnyAttrs )
{
	if (pAnyAttrs->cAttrsToAdd != 0)
	{
		MyAssert (pAnyAttrs->pszAttrsToAdd != NULL);
		pAnyAttrs->pszAttrsToAdd = IlsPrefixNameValueArray (
						TRUE,
						pAnyAttrs->cAttrsToAdd,
						(const TCHAR *) pAnyAttrs->pszAttrsToAdd);
		if (pAnyAttrs->pszAttrsToAdd == NULL)
			return ILS_E_MEMORY;
	}

	if (pAnyAttrs->cAttrsToModify != 0)
	{
		MyAssert (pAnyAttrs->pszAttrsToModify != NULL);
		pAnyAttrs->pszAttrsToModify = IlsPrefixNameValueArray (
						TRUE,
						pAnyAttrs->cAttrsToModify,
						(const TCHAR *) pAnyAttrs->pszAttrsToModify);
		if (pAnyAttrs->pszAttrsToModify == NULL)
		{
			MemFree (pAnyAttrs->pszAttrsToAdd);
			pAnyAttrs->pszAttrsToAdd = NULL;
			return ILS_E_MEMORY;
		}
	}

	if (pAnyAttrs->cAttrsToRemove != 0)
	{
		MyAssert (pAnyAttrs->pszAttrsToRemove != NULL);
		pAnyAttrs->pszAttrsToRemove = IlsPrefixNameValueArray (
						FALSE,
						pAnyAttrs->cAttrsToRemove,
						(const TCHAR *) pAnyAttrs->pszAttrsToRemove);
		if (pAnyAttrs->pszAttrsToRemove == NULL)
		{
			MemFree (pAnyAttrs->pszAttrsToAdd);
			MemFree (pAnyAttrs->pszAttrsToModify);
			pAnyAttrs->pszAttrsToAdd = NULL;
			pAnyAttrs->pszAttrsToModify = NULL;
			return ILS_E_MEMORY;
		}
	}

	return S_OK;
}


VOID
IlsReleaseAnyAttrsPrefix ( ANY_ATTRS *pAnyAttrs )
{
	MemFree (pAnyAttrs->pszAttrsToAdd);
	MemFree (pAnyAttrs->pszAttrsToModify);
	MemFree (pAnyAttrs->pszAttrsToRemove);
	ZeroMemory (pAnyAttrs, sizeof (*pAnyAttrs));
}




TCHAR **my_ldap_get_values ( LDAP *ld, LDAPMessage *pEntry, TCHAR *pszRetAttrName )
{
	MyAssert (ld != NULL);
	MyAssert (pEntry != NULL);
	MyAssert (pszRetAttrName != NULL);

	// Examine the first attribute
	//
	struct berelement *pContext = NULL;
	TCHAR *pszAttrName = ldap_first_attribute (ld, pEntry, &pContext);
	if (My_lstrcmpi (pszAttrName, pszRetAttrName) != 0)
	{
		// Examine the other attributes
		//
		while ((pszAttrName = ldap_next_attribute (ld, pEntry, pContext))
				!= NULL)
		{
			if (My_lstrcmpi (pszAttrName, pszRetAttrName) == 0)
				break;
		}
	}

	// Get the attribute value if needed
	//
	TCHAR **ppszAttrValue = NULL;
	if (pszAttrName != NULL)
		ppszAttrValue = ldap_get_values (ld, pEntry, pszAttrName);

	return ppszAttrValue;
}


ULONG my_ldap_count_1st_entry_attributes ( LDAP *ld, LDAPMessage *pLdapMsg )
{
	MyAssert (ld != NULL);
	MyAssert (pLdapMsg != NULL);

	ULONG cAttrs = 0;

	// there should be only an entry
	ULONG cEntries = ldap_count_entries (ld, pLdapMsg);
	if (cEntries > 0)
	{
		// there should be only one entry
		MyAssert (cEntries == 1);

		TCHAR *pszAttrName;

		// get this entry
		LDAPMessage *pEntry = ldap_first_entry (ld, pLdapMsg);
		if (pEntry == NULL)
		{
			MyAssert (FALSE);
			return cAttrs;
		}

		// examine the first attribute
		struct berelement *pContext = NULL;
		pszAttrName = ldap_first_attribute (ld, pEntry, &pContext);
		if (pszAttrName == NULL)
		{
			MyAssert (FALSE);
			return 0;
		}
		cAttrs = 1;

TCHAR **ppszAttrVal;
ppszAttrVal = ldap_get_values (ld, pEntry, pszAttrName);
if (ppszAttrVal != NULL)
	ldap_value_free (ppszAttrVal);

		// step through the others
		while ((pszAttrName = ldap_next_attribute (ld, pEntry, pContext)) != NULL)
		{
			cAttrs++;

ppszAttrVal = ldap_get_values (ld, pEntry, pszAttrName);
if (ppszAttrVal != NULL)
	ldap_value_free (ppszAttrVal);
		}
	} // if cEntries > 0

	return cAttrs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\splprot.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		splprot.cpp
	Content:	This file contains the local protocol object.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"

const TCHAR *c_apszProtStdAttrNames[COUNT_ENUM_PROTATTR] =
{
	TEXT ("sprotid"),
	TEXT ("sprotmimetype"),
	TEXT ("sport"),
};


/* ---------- public methods ----------- */


SP_CProtocol::
SP_CProtocol ( SP_CClient *pClient )
	:
	m_cRefs (0),						// Reference count
	m_uSignature (PROTOBJ_SIGNATURE)	// Protocol object's signature
{
	MyAssert (pClient != NULL);
	m_pClient = pClient;

	// Clean up the scratch buffer for caching pointers to attribute values
	//
	::ZeroMemory (&m_ProtInfo, sizeof (m_ProtInfo));

	// Indicate this protocol is not registered yet
	//
	SetRegNone ();
}


SP_CProtocol::
~SP_CProtocol ( VOID )
{
	// Invalidate the client object's signature
	//
	m_uSignature = (ULONG) -1;

	// Free cached strings
	//
	MemFree (m_ProtInfo.apszStdAttrValues[ENUM_PROTATTR_NAME]);
	MemFree (m_ProtInfo.apszStdAttrValues[ENUM_PROTATTR_MIME_TYPE]);
}


ULONG SP_CProtocol::
AddRef ( VOID )
{
	::InterlockedIncrement (&m_cRefs);
	return m_cRefs;
}


ULONG SP_CProtocol::
Release ( VOID )
{
	MyAssert (m_cRefs != 0);
	::InterlockedDecrement (&m_cRefs);

	ULONG cRefs = m_cRefs;
	if (cRefs == 0)
		delete this;

	return cRefs;
}


HRESULT SP_CProtocol::
Register (
	ULONG			uRespID,
	LDAP_PROTINFO	*pInfo )
{
	MyAssert (pInfo != NULL);

	// Cache protocol info
	//
	CacheProtInfo (pInfo);

	// Get protocol name
	//
	TCHAR *pszProtName = m_ProtInfo.apszStdAttrValues[ENUM_PROTATTR_NAME];
	if (! MyIsGoodString (pszProtName))
	{
		MyAssert (FALSE);
		return ILS_E_PARAMETER;
	}

	// Add the protocol object
	//
	return m_pClient->AddProtocol (WM_ILS_REGISTER_PROTOCOL, uRespID, this);
}


HRESULT SP_CProtocol::
UnRegister ( ULONG uRespID )
{
	// If it is not registered on the server,
	// the simply report success
	//
	if (! IsRegRemotely ())
	{
		SetRegNone ();
		PostMessage (g_hWndNotify, WM_ILS_UNREGISTER_PROTOCOL, uRespID, S_OK);
		return S_OK;
	}

	// Indicate that we are not registered at all
	//
	SetRegNone ();

	// remove the protocol object
	//
	return m_pClient->RemoveProtocol (WM_ILS_UNREGISTER_PROTOCOL, uRespID, this);
}


HRESULT SP_CProtocol::
SetAttributes (
	ULONG			uRespID,
	LDAP_PROTINFO	*pInfo )
{
	MyAssert (pInfo != NULL);

	// Cache protocol info
	//
	CacheProtInfo (pInfo);

	// remove the protocol object
	//
	return m_pClient->UpdateProtocols (WM_ILS_SET_PROTOCOL_INFO, uRespID, this);
}


/* ---------- protected methods ----------- */


/* ---------- private methods ----------- */


VOID SP_CProtocol::
CacheProtInfo ( LDAP_PROTINFO *pInfo )
{
	MyAssert (pInfo != NULL);

	// Free previous allocations
	//
	MemFree (m_ProtInfo.apszStdAttrValues[ENUM_PROTATTR_NAME]);
	MemFree (m_ProtInfo.apszStdAttrValues[ENUM_PROTATTR_MIME_TYPE]);

	// Clean up the buffer
	//
	ZeroMemory (&m_ProtInfo, sizeof (m_ProtInfo));

	// Start to cache protocol standard attributes
	//

	if (pInfo->uOffsetName != INVALID_OFFSET)
	{
		m_ProtInfo.apszStdAttrValues[ENUM_PROTATTR_NAME] =
						My_strdup ((TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetName));
		m_ProtInfo.dwFlags |= PROTOBJ_F_NAME;
	}

	if (pInfo->uPortNumber != INVALID_OFFSET)
	{
		m_ProtInfo.apszStdAttrValues[ENUM_PROTATTR_PORT_NUMBER] = &m_ProtInfo.szPortNumber[0];
		::GetLongString (pInfo->uPortNumber, &m_ProtInfo.szPortNumber[0]);
		m_ProtInfo.dwFlags |= PROTOBJ_F_PORT_NUMBER;
	}

	if (pInfo->uOffsetMimeType != INVALID_OFFSET)
	{
		m_ProtInfo.apszStdAttrValues[ENUM_PROTATTR_MIME_TYPE] =
						My_strdup ((TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetMimeType));
		m_ProtInfo.dwFlags |= PROTOBJ_F_MIME_TYPE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\splapp.h ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		splapp.h
	Content:	This file contains the local application object definition.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#ifndef _ULS_SP_APPOBJ_H_
#define _ULS_SP_APPOBJ_H_

#include <pshpack8.h>

enum
{
	ENUM_APPATTR_NAME,
	ENUM_APPATTR_MIME_TYPE,
	ENUM_APPATTR_GUID,

	ENUM_APPATTR_PROT_NAME,
	ENUM_APPATTR_PROT_MIME,
	ENUM_APPATTR_PROT_PORT,

	COUNT_ENUM_APPATTR
};

#define COUNT_ENUM_STDAPPATTR	ENUM_APPATTR_PROT_NAME

#define APPOBJ_F_NAME		0x0001
#define APPOBJ_F_MIME_TYPE	0x0002
#define APPOBJ_F_GUID		0x0004


extern const TCHAR *c_apszAppStdAttrNames[COUNT_ENUM_APPATTR];

#define STR_APP_NAME	((TCHAR *) c_apszAppStdAttrNames[ENUM_APPATTR_NAME])


typedef struct
{
	DWORD	dwFlags;
	TCHAR	*apszStdAttrValues[COUNT_ENUM_APPATTR];
	TCHAR	szGuid[sizeof (GUID) * 2 + 2];
}
	APP_INFO;


#define APPOBJ_SIGNATURE	((ULONG) 0x56781234UL)


class UlsLdap_CLocalApp : public UlsLdap_CStdAttrs, public UlsLdap_CAnyAttrs
{
	friend class UlsLdap_CLocalProt;

public:

	UlsLdap_CLocalApp ( UlsLdap_CLocalUser *pUser );
	~UlsLdap_CLocalApp ( VOID );

	ULONG AddRef ( VOID );
	ULONG Release ( VOID );

	HRESULT Register ( ULONG *puRespID, LDAP_APPINFO *pInfo );
	HRESULT UnRegister ( ULONG *puRespID );

	HRESULT SetStdAttrs ( ULONG *puRespID, LDAP_APPINFO *pInfo );
	HRESULT SetAnyAttrs ( ULONG *puRespID, ULONG cAttrs, TCHAR *pszAttrs );
	HRESULT RemoveAnyAttrs ( ULONG *puRespID, ULONG cAttrs, TCHAR *pszAttrs );

	VOID SetRegNone ( VOID ) { m_RegStatus = ULS_REG_STATUS_NONE; }
	VOID SetRegLocally ( VOID ) { m_RegStatus = ULS_REG_STATUS_LOCALLY; }
	VOID SetRegRemotely ( VOID ) { m_RegStatus = ULS_REG_STATUS_REMOTELY; }

	BOOL IsRegistered ( VOID ) { return (m_RegStatus > ULS_REG_STATUS_NONE &&
									 		m_pUser->IsRegistered ()); }
	BOOL IsRegLocally ( VOID ) { return (m_RegStatus == ULS_REG_STATUS_LOCALLY &&
											m_pUser->IsRegistered ()); }
	BOOL IsRegRemotely ( VOID ) { return (m_RegStatus == ULS_REG_STATUS_REMOTELY &&
											m_pUser->IsRegRemotely ()); }

	BOOL IsValidObject ( VOID ) { return m_uSignature == APPOBJ_SIGNATURE; }

protected:

	TCHAR *GetDN ( VOID ) { return m_pUser->GetDN (); }
	SERVER_INFO *GetServerInfo ( VOID ) { return m_pUser->GetServerInfo ();	}

	ULONG GetUserPrefixCount ( VOID ) { return m_pUser->GetPrefixCount (); }
	TCHAR *GetUserPrefixString ( VOID ) { return m_pUser->GetPrefixString (); }

	ULONG GetPrefixCount ( VOID ) { return m_cPrefix; }
	TCHAR *GetPrefixString ( VOID ) { return m_pszPrefix; }

private:

	HRESULT CacheInfo ( VOID *pInfo );
	HRESULT CacheAppInfo ( LDAP_APPINFO *pInfo );
	HRESULT CreateRegisterModArr ( LDAPMod ***pppMod );
	HRESULT CreateUnRegisterModArr ( LDAPMod ***pppMod );
	HRESULT CreateSetStdAttrsModArr ( LDAPMod ***pppMod );
	VOID FillModArrAttr ( LDAPMod *pMod, LONG AttrIdx );

	ULONG				m_uSignature;
	LONG				m_cRefs;
	UlsLdap_CLocalUser	*m_pUser;

	APP_INFO			m_AppInfo;
	REG_STATUS			m_RegStatus;

	ULONG				m_cPrefix;
	TCHAR				*m_pszPrefix;
};


#include <poppack.h>

#endif // _ULS_SP_APPOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\splprot.h ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		splprot.h
	Content:	This file contains the local protocol object definition.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#ifndef _ILS_SP_PROTOBJ_H_
#define _ILS_SP_PROTOBJ_H_

#include <pshpack8.h>

enum
{
	ENUM_PROTATTR_NAME,
	ENUM_PROTATTR_MIME_TYPE,
	ENUM_PROTATTR_PORT_NUMBER,
	COUNT_ENUM_PROTATTR
};


#define PROTOBJ_F_NAME			0x0001
#define PROTOBJ_F_MIME_TYPE		0x0002
#define PROTOBJ_F_PORT_NUMBER	0x0004


extern const TCHAR *c_apszProtStdAttrNames[];

#define STR_PROT_NAME	((TCHAR *) c_apszProtStdAttrNames[ENUM_PROTATTR_NAME])


typedef struct
{
	DWORD	dwFlags;
	TCHAR	*apszStdAttrValues[COUNT_ENUM_PROTATTR];
	TCHAR	szPortNumber[INTEGER_STRING_LENGTH];
}
	PROT_INFO;


#define PROTOBJ_SIGNATURE	((ULONG) 0xABCD1278UL)


class SP_CProtocol
{
	friend class SP_CClient;

public:

	SP_CProtocol ( SP_CClient *pClient );
	~SP_CProtocol ( VOID );

	ULONG AddRef ( VOID );
	ULONG Release ( VOID );

	HRESULT Register ( ULONG uRespID, LDAP_PROTINFO *pInfo );
	HRESULT UnRegister ( ULONG uRespID );

	HRESULT SetAttributes ( ULONG uRespID, LDAP_PROTINFO *pInfo );

	VOID SetRegNone ( VOID ) { m_RegStatus = ILS_REG_STATUS_NONE; }
	VOID SetRegLocally ( VOID ) { m_RegStatus = ILS_REG_STATUS_LOCALLY; }
	VOID SetRegRemotely ( VOID ) { m_RegStatus = ILS_REG_STATUS_REMOTELY; }

	BOOL IsRegistered ( VOID ) { return (m_RegStatus > ILS_REG_STATUS_NONE &&
									 		m_pClient->IsRegistered ()); }
	BOOL IsRegLocally ( VOID ) { return (m_RegStatus == ILS_REG_STATUS_LOCALLY &&
											m_pClient->IsRegistered ()); }
	BOOL IsRegRemotely ( VOID ) { return (m_RegStatus == ILS_REG_STATUS_REMOTELY &&
											m_pClient->IsRegRemotely ()); }

	BOOL IsValidObject ( VOID ) { return m_uSignature == PROTOBJ_SIGNATURE; }

protected:

	PROT_INFO *GetProtInfo ( VOID ) { return &m_ProtInfo; }

private:

	VOID CacheProtInfo ( LDAP_PROTINFO *pInfo );

	ULONG			m_uSignature;
	LONG			m_cRefs;
	SP_CClient		*m_pClient;

	PROT_INFO		m_ProtInfo;
	REG_STATUS		m_RegStatus;
};


#include <poppack.h>

#endif // _ILS_SP_PROTOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\spluser.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spluser.cpp
	Content:	This file contains the local user object.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"

// Array of constant strings for user object's attribute names
//
const TCHAR *c_apszUserStdAttrNames[COUNT_ENUM_USERATTR] =
{
	TEXT ("cn"),
	TEXT ("givenname"),
	TEXT ("surname"),
	TEXT ("rfc822mailbox"),
	TEXT ("location"),
#ifdef USE_DEFAULT_COUNTRY
	TEXT ("aCountryName"),
#endif
	TEXT ("comment"),
	TEXT ("sipaddress"),
	TEXT ("sflags"),
	TEXT ("c"),

	TEXT ("ssecurity"),
	TEXT ("sttl"),

	TEXT ("objectClass"),
	TEXT ("o"),
};


/* ---------- public methods ----------- */


UlsLdap_CLocalUser::
UlsLdap_CLocalUser ( VOID )
{
	// Reference count
	//
	m_cRefs = 0;

	// User object's signature
	//
	m_uSignature = USEROBJ_SIGNATURE;

	// Clean up attached server info structure
	//
	ZeroMemory (&m_ServerInfo, sizeof (m_ServerInfo));

	// Clean up the scratch buffer for caching pointers to attribute values
	//
	ZeroMemory (&m_UserInfo, sizeof (m_UserInfo));

	// Clean up DN (old and current ones)
	m_pszDN = NULL;
	m_pszOldDN = NULL;

	// Clean up the refresh search filter
	//
	m_pszRefreshFilter = NULL;

	// Indicate this user is not registered yet
	//
	SetRegNone ();

	// Reset time to live value
	m_uTTL = ULS_DEF_REFRESH_MINUTE; // in unit of minute: no effect on current ils, but to avoid legacy issue later
	m_dwIPAddress = 0;
}


UlsLdap_CLocalUser::
~UlsLdap_CLocalUser ( VOID )
{
	// Invalidate the user object's signature
	//
	m_uSignature = (ULONG) -1;

	// Free server info structure
	//
	::IlsFreeServerInfo (&m_ServerInfo);

	// Free DN (old and current ones)
	//
	MemFree (m_pszDN);
	MemFree (m_pszOldDN);

	// Free the refresh search filter
	//
	MemFree (m_pszRefreshFilter);
}


ULONG UlsLdap_CLocalUser::
AddRef ( VOID )
{
	InterlockedIncrement (&m_cRefs);
	return m_cRefs;
}


ULONG UlsLdap_CLocalUser::
Release ( VOID )
{
	MyAssert (m_cRefs != 0);

	if (m_cRefs != 0)
	{
		InterlockedDecrement (&m_cRefs);
	}

	ULONG cRefs = m_cRefs;
	if (cRefs == 0)
		delete this;

	return cRefs;
}


HRESULT UlsLdap_CLocalUser::
Register ( ULONG *puRespID, SERVER_INFO *pServerInfo, LDAP_USERINFO *pInfo )
{
	MyAssert (puRespID != NULL);
	MyAssert (pInfo != NULL);

	MyAssert (	pServerInfo->pszServerName != NULL &&
				pServerInfo->pszServerName[0] != TEXT ('\0'));
	MyAssert (	pServerInfo->pszBaseDN != NULL &&
				pServerInfo->pszBaseDN[0] != TEXT ('\0'));

	// cache the server info
	HRESULT hr = ::IlsCopyServerInfo (&m_ServerInfo, pServerInfo);
	if (hr != S_OK)
		return hr;

	// cache user info
	hr = CacheUserInfo (pInfo);
	if (hr != S_OK)
		return hr;

	// get ip address
	m_dwIPAddress = 0;
	hr = ::GetLocalIPAddress (&m_dwIPAddress);
	if (hr != S_OK)
		return hr;

	// Create IP address string
	//
	m_UserInfo.apszStdAttrValues[ENUM_USERATTR_IP_ADDRESS] = &m_UserInfo.szIPAddress[0];
	::GetLongString (m_dwIPAddress, &m_UserInfo.szIPAddress[0]);

	// Create client signature string
	//
	m_UserInfo.apszStdAttrValues[ENUM_USERATTR_CLIENT_SIG] = &m_UserInfo.szClientSig[0];
	::GetLongString (g_dwClientSig, &m_UserInfo.szClientSig[0]);

	// Create TTL string
	//
	m_UserInfo.apszStdAttrValues[ENUM_USERATTR_TTL] = &m_UserInfo.szTTL[0];
	::GetLongString (m_uTTL, &m_UserInfo.szTTL[0]);

	// ideally, o= and c= should be read in from registiry
	// but for now, we simply hard code it
	m_UserInfo.apszStdAttrValues[ENUM_USERATTR_OBJECT_CLASS] = (TCHAR *) &c_szRTPerson[0];
	m_UserInfo.apszStdAttrValues[ENUM_USERATTR_O] = (TCHAR *) &c_szDefO[0];
#ifdef USE_DEFAULT_COUNTRY
	m_UserInfo.apszStdAttrValues[ENUM_USERATTR_C] = (TCHAR *) &c_szDefC[0];
#endif

	// build DN
	hr = BuildDN ();
	if (hr != S_OK)
		return hr;

	// build refreh filter
	m_pszRefreshFilter = UserCreateRefreshFilter (m_UserInfo.apszStdAttrValues[ENUM_USERATTR_CN]);
	if (m_pszRefreshFilter == NULL)
		return ULS_E_MEMORY;

	// build modify array for ldap_add()
	LDAPMod **ppMod = NULL;
	hr = CreateRegisterModArr (&ppMod);
	if (hr != S_OK)
		return hr;
	MyAssert (ppMod != NULL);

	// so far, we are done with local preparation

	// get the connection object
	UlsLdap_CSession *pSession = NULL;
	hr = g_pSessionContainer->GetSession (&pSession, &m_ServerInfo);
	if (hr != S_OK)
	{
		MemFree (ppMod);
		return hr;
	}
	MyAssert (pSession != NULL);

	// get the ldap session
	LDAP *ld = pSession->GetLd ();
	MyAssert (ld != NULL);

	// send the data over the wire
	ULONG uMsgID = ldap_add (ld, GetDN (), ppMod);
	MemFree (ppMod);
	if (uMsgID == -1)
	{
		hr = ::LdapError2Hresult (ld->ld_errno);
		pSession->Disconnect ();
		return hr;
	}

	// construct a pending info
	PENDING_INFO PendingInfo;
	::FillDefPendingInfo (&PendingInfo, ld, uMsgID, INVALID_MSG_ID);
	PendingInfo.uLdapResType = LDAP_RES_ADD;
	PendingInfo.uNotifyMsg = WM_ULS_REGISTER_USER;
	PendingInfo.hObject = (HANDLE) this;

	// queue it
	hr = g_pPendingQueue->EnterRequest (pSession, &PendingInfo);
	if (hr != S_OK)
	{
		ldap_abandon (ld, uMsgID);
		pSession->Disconnect ();
		MyAssert (FALSE);
	}

	*puRespID = PendingInfo.uRespID;
	return hr;
}


HRESULT UlsLdap_CLocalUser::
UnRegister ( ULONG *puRespID )
{
	MyAssert (puRespID != NULL);

	// Make sure that there is not refresh scheduled for this object
	//
	if (g_pRefreshScheduler != NULL)
	{
		g_pRefreshScheduler->RemoveUserObject (this);
	}
	else
	{
		MyAssert (FALSE);
	}

	// Unregister it locally
	//
	if (! IsRegRemotely ())
	{
		*puRespID = ::GetUniqueNotifyID ();
		SetRegNone ();
		PostMessage (g_hWndNotify, WM_ULS_UNREGISTER_USER, *puRespID, S_OK);
		return S_OK;
	}

	SetRegNone ();

	// Get the session object
	//
	UlsLdap_CSession *pSession = NULL;
	HRESULT hr = g_pSessionContainer->GetSession (&pSession, &m_ServerInfo);
	if (hr != S_OK)
		return hr;
	MyAssert (pSession != NULL);

	// Get the ldap session
	//
	LDAP *ld = pSession->GetLd ();
	MyAssert (ld != NULL);

	// LONCHANC: notify global user object of this unregister user


	// send the data over the wire
	ULONG uMsgID = ldap_delete (ld, GetDN ());
	if (uMsgID == -1)
	{
		hr = ::LdapError2Hresult (ld->ld_errno);
		pSession->Disconnect ();
		return hr;
	}

	// construct a pending info
	PENDING_INFO PendingInfo;
	::FillDefPendingInfo (&PendingInfo, ld, uMsgID, INVALID_MSG_ID);
	PendingInfo.uLdapResType = LDAP_RES_DELETE;
	PendingInfo.uNotifyMsg = WM_ULS_UNREGISTER_USER;

	// queue it
	hr = g_pPendingQueue->EnterRequest (pSession, &PendingInfo);
	if (hr != S_OK)
	{
		ldap_abandon (ld, uMsgID);
		pSession->Disconnect ();
		MyAssert (FALSE);
	}

	*puRespID = PendingInfo.uRespID;
	return hr;
}


HRESULT UlsLdap_CLocalUser::
SetStdAttrs ( ULONG *puRespID, LDAP_USERINFO *pInfo )
{
	MyAssert (puRespID != NULL);
	MyAssert (pInfo != NULL);

	ULONG uMsgID_modify, uMsgID_modrdn;
	UlsLdap_CSession *pSession;
	LDAP *ld;
	HRESULT hr;

	// Get the session object
	//
	hr = g_pSessionContainer->GetSession (&pSession, GetServerInfo ());
	if (hr != S_OK)
		return hr;
	MyAssert (pSession != NULL);

	// Get the ldap session
	//
	ld = pSession->GetLd ();
	MyAssert (ld != NULL);

	// Change cn?
	//
	if (pInfo->uOffsetEMailName != 0)
	{
		// Cache user info such that cn is refreshed
		//
		hr = CacheUserInfo (pInfo);
		if (hr != S_OK)
		{
			pSession->Disconnect ();
			return hr;
		}

		// We have to use ldap_modrdn to modify cn and this must be
		// done before any other attribute changes
		//
		uMsgID_modrdn = ldap_modrdn2 (
							ld, GetDN (),
							m_UserInfo.apszStdAttrValues[ENUM_USERATTR_CN],
							1);
		if (uMsgID_modrdn == -1)
		{
			pSession->Disconnect ();
			hr = ::LdapError2Hresult (ld->ld_errno);
			return hr;
		}

		// Update DN
		//
		BuildDN ();
	}
	else
	{
		uMsgID_modrdn = INVALID_MSG_ID;
	}

	// Set standard attributes
	//
	hr = UlsLdap_CStdAttrs::SetStdAttrs (	NULL,
											&uMsgID_modify,
											0,
											(VOID *) pInfo,
											GetServerInfo (),
											GetDN ());
	if (hr != S_OK)
	{
		if (uMsgID_modrdn != INVALID_MSG_ID)
		{
			ldap_abandon (ld, uMsgID_modrdn);
			pSession->Disconnect ();
		}
		return hr;
	}

	// Construct a pending info
	//
	PENDING_INFO PendingInfo;
	if (uMsgID_modrdn == INVALID_MSG_ID)
		::FillDefPendingInfo (&PendingInfo, ld, uMsgID_modify, INVALID_MSG_ID);
	else
		::FillDefPendingInfo (&PendingInfo, ld, uMsgID_modrdn, uMsgID_modify);
	PendingInfo.uLdapResType = LDAP_RES_MODIFY;
	PendingInfo.uNotifyMsg = WM_ULS_SET_USER_INFO;
	PendingInfo.hObject = (HANDLE) this; // for DN rollback

	// Queue it
	//
	hr = g_pPendingQueue->EnterRequest (pSession, &PendingInfo);
	if (hr != S_OK)
	{
		if (uMsgID_modrdn != INVALID_MSG_ID)
		{
			ldap_abandon (ld, uMsgID_modrdn);
			pSession->Disconnect ();
		}
		ldap_abandon (ld, uMsgID_modify);
		MyAssert (FALSE);
	}

	*puRespID = PendingInfo.uRespID;
	return hr;
}


VOID UlsLdap_CLocalUser::
RollbackDN ( VOID )
{
	if (m_pszOldDN != NULL)
	{
		MemFree (m_pszDN);
		m_pszDN = m_pszOldDN;
		m_pszOldDN = NULL;
	}
}


HRESULT UlsLdap_CLocalUser::
UpdateIPAddress ( BOOL fPrimary )
{
	// Update cached ip address
	//
	HRESULT hr = ::GetLocalIPAddress (&m_dwIPAddress);
	if (hr != S_OK)
		return hr;

	// Update the ip address string
	//
	::GetLongString (m_dwIPAddress, &m_UserInfo.szIPAddress[0]);

	// Update ip address info on the server ONLY if primary
	//
	if (! fPrimary)
		return hr;

	// Update IP address on the server
	//
	return ::IlsUpdateIPAddress (	GetServerInfo (),
									GetDN (),
									(TCHAR *) c_apszUserStdAttrNames[ENUM_USERATTR_IP_ADDRESS],
									&m_UserInfo.szIPAddress[0],
									ISBU_MODOP_MODIFY_USER,
									GetPrefixCount (),
									GetPrefixString ());
}


/* ---------- protected methods ----------- */


HRESULT UlsLdap_CLocalUser::
SendRefreshMsg ( VOID )
{
	if (m_pszRefreshFilter == NULL)
		return ULS_E_POINTER;

	// Get local ip address
	//
	DWORD dwIPAddress = 0;
	HRESULT hr = ::GetLocalIPAddress (&dwIPAddress);
	if (hr != S_OK)
	{
		MyDebugMsg ((ZONE_KA, "KA: cannot get my ip address\r\n"));
		return hr;
	}

	// If dwIPAddress is 0, then we are not on the network any more
	// start relogon process
	//
	if (dwIPAddress == 0)
	{
		MyDebugMsg ((ZONE_KA, "KA: my ip address is null\r\n"));

		// Indicate that I am not connected to the server anymore
		//
		SetRegLocally ();

		// Second, notify this app of the network being down
		//
		PostMessage (g_hWndHidden, WM_ULS_NETWORK_DOWN, TRUE, (LPARAM) this);

		// Report error
		//
		return ULS_E_NETWORK_DOWN;
;
	}
	else
	// If dwIPAddress and m_dwIPAddress, alert
	//
	if (dwIPAddress != m_dwIPAddress)
	{
		// Notify the com to start changing ip address
		// the actual change can happen later
		//
		PostMessage (g_hWndHidden, WM_ULS_IP_ADDRESS_CHANGED, TRUE, (LPARAM) this);
	}

	// get the connection object
	UlsLdap_CSession *pSession = NULL;
	hr = g_pSessionContainer->GetSession (&pSession, &m_ServerInfo);
	if (hr != S_OK)
	{
		MyDebugMsg ((ZONE_KA, "KA: network down, hr=0x%lX\r\n", hr));

		// Indicate that I am not connected to the server anymore
		//
		SetRegLocally ();

		// Second, notify the com of network down
		//
		PostMessage (g_hWndHidden, WM_ULS_NETWORK_DOWN, TRUE, (LPARAM) this);

		// Report error
		//
		return ULS_E_NETWORK_DOWN;
	}
	MyAssert (pSession != NULL);

	// get the ldap session
	LDAP *ld = pSession->GetLd ();
	MyAssert (ld != NULL);

	// Set attributes to return
	//
	TCHAR *apszAttrNames[3];
	apszAttrNames[0] = STR_CN;
	apszAttrNames[1] = (TCHAR *) c_apszUserStdAttrNames[ENUM_USERATTR_TTL];
	apszAttrNames[2] = NULL;

	// Update options in ld
	//
	ld->ld_sizelimit = 0;	// no limit in the num of entries to return
	ld->ld_timelimit = 0;	// no limit on the time to spend on the search
	ld->ld_deref = LDAP_DEREF_ALWAYS;

	// Send search query
	//
	MyDebugMsg ((ZONE_KA, "KA: calling ldap_search()...\r\n"));
	ULONG uMsgID = ::ldap_search (ld, (TCHAR *) &c_szDefUserBaseDN[0],	// base DN
									LDAP_SCOPE_BASE,	// scope
									m_pszRefreshFilter,
									&apszAttrNames[0],	// attrs[]
									0	// both type and value
									);
	if (uMsgID == -1)
	{
		MyDebugMsg ((ZONE_KA, "KA: ldap_search() failed\r\n"));
		hr = ::LdapError2Hresult (ld->ld_errno);
		pSession->Disconnect ();
		return hr;
	}

	// Let's wait for the result
	//
	LDAP_TIMEVAL TimeVal;
	TimeVal.tv_usec = 0;
	TimeVal.tv_sec = (m_ServerInfo.nTimeout != 0) ?
							m_ServerInfo.nTimeout :
							90;
	LDAPMessage *pLdapMsg = NULL;
	INT ResultType = ::ldap_result (ld, uMsgID, 0, &TimeVal, &pLdapMsg);

	// Deal with timeout or error
	//
	if (ResultType != LDAP_RES_SEARCH_ENTRY &&
		ResultType != LDAP_RES_SEARCH_RESULT)
	{
		MyDebugMsg ((ZONE_KA, "KA: result type mismatches!\r\n"));
		hr = ULS_E_TIMEOUT;
		goto MyExit;
	}

	if (pLdapMsg != NULL)
	{
		switch (pLdapMsg->lm_returncode)
		{
		case LDAP_NO_SUCH_OBJECT:
			MyDebugMsg ((ZONE_KA, "KA: no such object!\r\n"));

			// Indicate that I am not connected to the server anymore
			//
			SetRegLocally ();

			// Second, notify this app to relogon
			//
			PostMessage (g_hWndHidden, WM_ULS_NEED_RELOGON, TRUE, (LPARAM) this);

			// Report error
			//
			hr = ULS_E_NEED_RELOGON;
			break;

		case LDAP_SUCCESS:
			// Get the new refresh period
			//
			hr = ::IlsParseRefreshPeriod (
						ld,
						pLdapMsg,
						c_apszUserStdAttrNames[ENUM_USERATTR_TTL],
						&m_uTTL);
			break;

		default:
			MyDebugMsg ((ZONE_KA, "KA: unknown lm_returncode=%ld\r\n", pLdapMsg->lm_returncode));
			MyAssert (FALSE);
			break;
		}
	}

MyExit:

	// Free message
	//
	if (pLdapMsg != NULL)
		ldap_msgfree (pLdapMsg);

	// Free up the session
	//
	pSession->Disconnect ();
	return hr;
}


/* ---------- private methods ----------- */


HRESULT UlsLdap_CLocalUser::
CreateRegisterModArr ( LDAPMod ***pppMod )
{
	if (pppMod == NULL)
		return ULS_E_POINTER;

	ULONG cAttrs = COUNT_ENUM_USERATTR;
	ULONG cbMod = ::IlsCalcModifyListSize (cAttrs);
	*pppMod = (LDAPMod **) MemAlloc (cbMod);
	if (*pppMod == NULL)
		return ULS_E_MEMORY;

	LDAPMod *pMod;
	for (ULONG i = 0; i < cAttrs; i++)
	{
		pMod = ::IlsGetModifyListMod (pppMod, cAttrs, i);
		(*pppMod)[i] = pMod;
		pMod->mod_op = LDAP_MOD_ADD;

		FillModArrAttr (pMod, i);
	}

// the following overwrote givenname attribute
//	::IlsFixUpModOp ((*pppMod)[0], LDAP_MOD_ADD);
	(*pppMod)[cAttrs] = NULL;
	return S_OK;
}


HRESULT UlsLdap_CLocalUser::
CreateSetStdAttrsModArr ( LDAPMod ***pppMod )
{
	MyAssert (pppMod != NULL);
	DWORD dwFlags = m_UserInfo.dwFlags;

	HRESULT hr;
	ULONG cTotal = 0;
	hr = ::FillDefStdAttrsModArr (	pppMod,
									dwFlags,
									COUNT_ENUM_USERINFO,
									&cTotal,
									ISBU_MODOP_MODIFY_USER,
									GetPrefixCount (),
									GetPrefixString ());
	if (hr != S_OK)
		return hr;

	// Start indexing
	//
	ULONG i = GetPrefixCount ();

	// Fill in standard attributes
	//
	if (dwFlags & USEROBJ_F_FIRST_NAME)
		FillModArrAttr ((*pppMod)[i++], ENUM_USERATTR_FIRST_NAME);

	if (dwFlags & USEROBJ_F_LAST_NAME)
		FillModArrAttr ((*pppMod)[i++], ENUM_USERATTR_LAST_NAME);

	if (dwFlags & USEROBJ_F_EMAIL_NAME)
		FillModArrAttr ((*pppMod)[i++], ENUM_USERATTR_EMAIL_NAME);

	if (dwFlags & USEROBJ_F_CITY_NAME)
		FillModArrAttr ((*pppMod)[i++], ENUM_USERATTR_CITY_NAME);

	if (dwFlags & USEROBJ_F_COUNTRY_NAME)
		FillModArrAttr ((*pppMod)[i++], ENUM_USERATTR_COUNTRY_NAME);

	if (dwFlags & USEROBJ_F_COMMENT)
		FillModArrAttr ((*pppMod)[i++], ENUM_USERATTR_COMMENT);

	if (dwFlags & USEROBJ_F_IP_ADDRESS)
		FillModArrAttr ((*pppMod)[i++], ENUM_USERATTR_IP_ADDRESS);

	if (dwFlags & USEROBJ_F_FLAGS)
		FillModArrAttr ((*pppMod)[i++], ENUM_USERATTR_FLAGS);

	MyAssert (i == cTotal);

	return S_OK;
}


VOID UlsLdap_CLocalUser::
FillModArrAttr ( LDAPMod *pMod, LONG AttrIdx )
{
	pMod->mod_type = (TCHAR *) c_apszUserStdAttrNames[AttrIdx];

	// single valued attr
	TCHAR **ppsz = (TCHAR **) (pMod + 1);
	pMod->mod_values = ppsz;
	*ppsz++ = (m_UserInfo.apszStdAttrValues[AttrIdx] != NULL) ?
				m_UserInfo.apszStdAttrValues[AttrIdx] :
				(TCHAR *) &c_szEmptyString[0];

	*ppsz = NULL;
}


HRESULT UlsLdap_CLocalUser::
CacheInfo ( VOID *pInfo )
{
	return CacheUserInfo ((LDAP_USERINFO *) pInfo);
}


HRESULT UlsLdap_CLocalUser::
CacheUserInfo ( LDAP_USERINFO *pInfo )
{
	ZeroMemory (&m_UserInfo, sizeof (m_UserInfo));
	TCHAR *pszName;

	if (pInfo->uOffsetName != INVALID_OFFSET)
	{
		pszName = (TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetName);
		m_UserInfo.apszStdAttrValues[ENUM_USERATTR_CN] = pszName;
		// m_UserInfo.dwFlags |= USEROBJ_F_NAME;
	}

	if (pInfo->uOffsetFirstName != INVALID_OFFSET)
	{
		pszName = (TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetFirstName);
		m_UserInfo.apszStdAttrValues[ENUM_USERATTR_FIRST_NAME] = pszName;
		m_UserInfo.dwFlags |= USEROBJ_F_FIRST_NAME;
	}

	if (pInfo->uOffsetLastName != INVALID_OFFSET)
	{
		pszName = (TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetLastName);
		m_UserInfo.apszStdAttrValues[ENUM_USERATTR_LAST_NAME] = pszName;
		m_UserInfo.dwFlags |= USEROBJ_F_LAST_NAME;
	}

	if (pInfo->uOffsetEMailName != INVALID_OFFSET)
	{
		pszName = (TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetEMailName);
		m_UserInfo.apszStdAttrValues[ENUM_USERATTR_EMAIL_NAME] = pszName;
		m_UserInfo.dwFlags |= USEROBJ_F_EMAIL_NAME;
	}

	if (pInfo->uOffsetCityName != INVALID_OFFSET)
	{
		pszName = (TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetCityName);
		m_UserInfo.apszStdAttrValues[ENUM_USERATTR_CITY_NAME] = pszName;
		m_UserInfo.dwFlags |= USEROBJ_F_CITY_NAME;
	}

	if (pInfo->uOffsetCountryName != INVALID_OFFSET)
	{
		pszName = (TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetCountryName);
		m_UserInfo.apszStdAttrValues[ENUM_USERATTR_COUNTRY_NAME] = pszName;
		m_UserInfo.dwFlags |= USEROBJ_F_COUNTRY_NAME;
	}

	if (pInfo->uOffsetComment != INVALID_OFFSET)
	{
		pszName = (TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetComment);
		m_UserInfo.apszStdAttrValues[ENUM_USERATTR_COMMENT] = pszName;
		m_UserInfo.dwFlags |= USEROBJ_F_COMMENT;
	}

	if (pInfo->uOffsetIPAddress != INVALID_OFFSET)
	{
		pszName = (TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetIPAddress);
		m_UserInfo.apszStdAttrValues[ENUM_USERATTR_IP_ADDRESS] = pszName;
		m_UserInfo.dwFlags |= USEROBJ_F_IP_ADDRESS;
	}

	if (pInfo->dwFlags != INVALID_USER_FLAGS)
	{
		::GetLongString (pInfo->dwFlags, &m_UserInfo.szFlags[0]);
		m_UserInfo.apszStdAttrValues[ENUM_USERATTR_FLAGS] = &m_UserInfo.szFlags[0];
		m_UserInfo.dwFlags |= USEROBJ_F_FLAGS;
	}

	return S_OK;
}


HRESULT UlsLdap_CLocalUser::
BuildDN ( VOID )
{
	MyAssert (m_UserInfo.apszStdAttrValues[ENUM_USERATTR_CN] != NULL);

	TCHAR szDN[MAX_DN_LENGTH];
	szDN[0] = TEXT ('\0');

	TCHAR *pszDN = &szDN[0];

	if (m_UserInfo.apszStdAttrValues[ENUM_USERATTR_CN] != NULL)
	{
		wsprintf (pszDN, TEXT ("%s=%s"),
					STR_CN, m_UserInfo.apszStdAttrValues[ENUM_USERATTR_CN]);
		pszDN += lstrlen (pszDN);
	}

	if (m_UserInfo.apszStdAttrValues[ENUM_USERATTR_O] != NULL)
	{
		wsprintf (pszDN, TEXT (", %s=%s"),
					STR_O, m_UserInfo.apszStdAttrValues[ENUM_USERATTR_O]);
		pszDN += lstrlen (pszDN);
	}

	if (m_UserInfo.apszStdAttrValues[ENUM_USERATTR_C] != NULL)
	{
		wsprintf (pszDN, TEXT (", %s=%s"),
					STR_C, m_UserInfo.apszStdAttrValues[ENUM_USERATTR_C]);
		pszDN += lstrlen (pszDN);
	}

	wsprintf (pszDN, TEXT (", %s"), &c_szDefUserBaseDN[0]);

	TCHAR *psz = My_strdup (&szDN[0]);
	if (psz == NULL)
		return ULS_E_MEMORY;

	MemFree (m_pszOldDN);
	m_pszOldDN = m_pszDN;
	m_pszDN = psz;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\spluser.h ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spluser.h
	Content:	This file contains the local user object definition.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#ifndef _ULS_SP_USEROBJ_H_
#define _ULS_SP_USEROBJ_H_

#include <pshpack8.h>

enum
{
	ENUM_USERATTR_CN,
	ENUM_USERATTR_FIRST_NAME,
	ENUM_USERATTR_LAST_NAME,
	ENUM_USERATTR_EMAIL_NAME,
	ENUM_USERATTR_CITY_NAME,
#ifdef USE_DEFAULT_COUNTRY
	ENUM_USERATTR_COUNTRY_NAME,
#endif
	ENUM_USERATTR_COMMENT,
	ENUM_USERATTR_IP_ADDRESS,
	ENUM_USERATTR_FLAGS,
	ENUM_USERATTR_C,

	/* -- the above are resolvable -- */

	ENUM_USERATTR_CLIENT_SIG,
	ENUM_USERATTR_TTL,

	/* -- the above are changeable standard attributes for RTPerson -- */

	ENUM_USERATTR_OBJECT_CLASS,
	ENUM_USERATTR_O,
	COUNT_ENUM_USERATTR
};


#ifdef USE_DEFAULT_COUNTRY
#else
#define ENUM_USERATTR_COUNTRY_NAME		ENUM_USERATTR_C
#endif


#define COUNT_ENUM_USERINFO			(ENUM_USERATTR_TTL + 1) // exclude uid, o, c
#define COUNT_ENUM_DIRUSERINFO		(ENUM_USERATTR_C + 1)	// count of attrs in dir dlg
#define COUNT_ENUM_RESUSERINFO		(ENUM_USERATTR_C + 1)	// count of attrs resolvable

extern const TCHAR *c_apszUserStdAttrNames[];

#define STR_CN		(TCHAR *) c_apszUserStdAttrNames[ENUM_USERATTR_CN]
#define STR_O		(TCHAR *) c_apszUserStdAttrNames[ENUM_USERATTR_O]
#define STR_C		(TCHAR *) c_apszUserStdAttrNames[ENUM_USERATTR_C]

#define USEROBJ_F_NAME			0x0001
#define USEROBJ_F_FIRST_NAME	0x0002
#define USEROBJ_F_LAST_NAME		0x0004
#define USEROBJ_F_EMAIL_NAME	0x0008
#define USEROBJ_F_CITY_NAME		0x0010
#define USEROBJ_F_COUNTRY_NAME	0x0020
#define USEROBJ_F_COMMENT		0x0040
#define USEROBJ_F_IP_ADDRESS	0x0080
#define USEROBJ_F_FLAGS			0x0100

typedef struct
{
	DWORD	dwFlags;
	TCHAR	*apszStdAttrValues[COUNT_ENUM_USERATTR];
	TCHAR	szIPAddress[INTEGER_STRING_LENGTH];
	TCHAR	szFlags[INTEGER_STRING_LENGTH];
	TCHAR	szTTL[INTEGER_STRING_LENGTH];
	TCHAR	szClientSig[INTEGER_STRING_LENGTH];
}
	USER_INFO;


#define USEROBJ_SIGNATURE	((ULONG) 0x12345678UL)


class UlsLdap_CLocalUser : public UlsLdap_CStdAttrs
{
	friend class UlsLdap_CRefreshScheduler;
	friend class UlsLdap_CLocalApp;
	friend class UlsLdap_CLocalProt;

public:

	UlsLdap_CLocalUser ( VOID );
	~UlsLdap_CLocalUser ( VOID );

	ULONG AddRef ( VOID );
	ULONG Release ( VOID );

	HRESULT Register ( ULONG *puRespID, SERVER_INFO *pServerInfo, LDAP_USERINFO *pInfo );
	HRESULT UnRegister ( ULONG *puRespID );
	HRESULT SetStdAttrs ( ULONG *puRespID, LDAP_USERINFO *pInfo );
	HRESULT UpdateIPAddress ( BOOL fPrimary );

	VOID SetRegNone ( VOID ) { m_RegStatus = ULS_REG_STATUS_NONE; }
	VOID SetRegLocally ( VOID ) { m_RegStatus = ULS_REG_STATUS_LOCALLY; }
	VOID SetRegRemotely ( VOID ) { m_RegStatus = ULS_REG_STATUS_REMOTELY; }

	BOOL IsRegistered ( VOID ) { return (m_RegStatus > ULS_REG_STATUS_NONE); }
	BOOL IsRegLocally ( VOID ) { return (m_RegStatus == ULS_REG_STATUS_LOCALLY); }
	BOOL IsRegRemotely ( VOID ) { return (m_RegStatus == ULS_REG_STATUS_REMOTELY); }

	BOOL IsValidObject ( VOID ) { return m_uSignature == USEROBJ_SIGNATURE; }

	VOID RollbackDN ( VOID );

	SERVER_INFO *GetServerInfo ( VOID ) { return &m_ServerInfo; }

	ULONG GetTTL ( VOID ) { return m_uTTL; }


protected:

	TCHAR *GetDN ( VOID ) { return m_pszDN; }

	ULONG GetPrefixCount ( VOID ) { return 1; }
	TCHAR *GetPrefixString ( VOID ) { return g_pszUserPrefix; }

	HRESULT SendRefreshMsg ( VOID );

private:

	HRESULT CacheInfo ( VOID *pInfo );
	HRESULT CacheUserInfo ( LDAP_USERINFO *pInfo );
	HRESULT CreateRegisterModArr ( LDAPMod ***pppMod );
	HRESULT CreateSetStdAttrsModArr ( LDAPMod ***pppMod );
	VOID FillModArrAttr ( LDAPMod *pMod, LONG AttrIdx );
	HRESULT BuildDN ( VOID );

	ULONG		m_uSignature;
	LONG		m_cRefs;

	USER_INFO	m_UserInfo;

	SERVER_INFO	m_ServerInfo;
	TCHAR		*m_pszDN;
	TCHAR		*m_pszOldDN;
	TCHAR		*m_pszRefreshFilter;

	REG_STATUS	m_RegStatus;

	DWORD		m_dwIPAddress;
	ULONG		m_uTTL;
};


#include <poppack.h>

#endif // _ULS_SP_USEROBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\sppqueue.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		sppqueue.cpp
	Content:	This file contains the pending item/queue objects.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"

// #define MEASURE_ENUM_USER_INFO	1

ULONG g_uResponseTimeout = ILS_DEF_RESP_TIMEOUT;
ULONG g_uResponsePollPeriod = ILS_DEF_RESP_POLL_PERIOD;
SP_CResponseQueue *g_pRespQueue = NULL;
SP_CRequestQueue *g_pReqQueue = NULL;
SP_CRefreshScheduler *g_pRefreshScheduler = NULL;


typedef BOOL (RESPONSE_HANDLER) ( HRESULT, SP_CResponse * );
typedef LPARAM (REQUEST_HANDLER) ( MARSHAL_REQ * );

extern RESPONSE_HANDLER *GetResponseHandler ( ULONG uNotifyMsg );
extern REQUEST_HANDLER *GetRequestHandler ( ULONG uNotifyMsg );


/* ---------- REQUEST QUEUE ----------- */


MARSHAL_REQ *
MarshalReq_Alloc (
	ULONG		uNotifyMsg,
	ULONG		cbSize,
	ULONG		cParams )
{
	// Align the chunk of data for each parameter on 4-byte boundary
	//
	cbSize += cParams * sizeof (DWORD);

	// Calculate the total size of marshal buffer
	//
	ULONG cbTotalSize = sizeof (MARSHAL_REQ) +
						cParams * sizeof (DWORD) +
						cbSize;

	// Allocate the marshal buffer
	//
	MARSHAL_REQ *p = (MARSHAL_REQ *) MemAlloc (cbTotalSize);
	if (p != NULL)
	{
		// p->next = NULL;
		p->cbTotalSize = cbTotalSize;
		p->pb = (BYTE *) ((ULONG_PTR) p + (cbTotalSize - cbSize));

		p->uRespID = GetUniqueNotifyID ();

		p->uNotifyMsg = uNotifyMsg;
		p->cParams = cParams;
	}

	return p;
}


HRESULT
MarshalReq_SetParam (
	MARSHAL_REQ		*p,
	ULONG			nIndex,
	DWORD_PTR		dwParam,
	ULONG			cbParamSize )
{
	if (p != NULL && nIndex < p->cParams)
	{
		MyAssert (p->aParams[nIndex] == 0); // not used before

		// If cbParamSize > 0, then
		// this means uParam is a pointer to a structure or
		// a pointer to a string
		//
		if (cbParamSize > 0)
		{
			// The pointer is now the one pointing to the new location
			//
			p->aParams[nIndex] = (DWORD_PTR) p->pb;

			// Copy the data chunk
			//
			CopyMemory (p->pb, (VOID *) dwParam, cbParamSize);

			// Make sure the data chunk is aligned on 4-byte boundary
			//
			if (cbParamSize & 0x3)
			{
				// Round it up
				//
				cbParamSize = (cbParamSize & (~0x3)) + 4;
			}

			// Adjust the running pointer
			//
			p->pb += cbParamSize;
		}
		else
		{
			// uParam can be an signed/unsigned integer,
			//
			p->aParams[nIndex] = dwParam;
		}
	}
	else
	{
		MyAssert (FALSE);
	}

	return S_OK;
}


DWORD_PTR
MarshalReq_GetParam (
	MARSHAL_REQ		*p,
	ULONG			nIndex )
{
	DWORD_PTR dwParam = 0;

	if (p != NULL && nIndex < p->cParams)
	{
		dwParam = p->aParams[nIndex];
	}
	else
	{
		MyAssert (FALSE);
	}

	return dwParam;
}


HRESULT
MarshalReq_SetParamServer (
	MARSHAL_REQ		*p,
	ULONG			nIndex,
	SERVER_INFO		*pServer,
	ULONG			cbServer )
{
	if (p != NULL && nIndex < p->cParams)
	{
		MyAssert (p->aParams[nIndex] == 0); // not used before
		MyAssert (cbServer > sizeof (SERVER_INFO));

		// The pointer is now the one pointing to the new location
		//
		p->aParams[nIndex] = (DWORD_PTR) p->pb;

		// Linearize the server info
		//
		IlsLinearizeServerInfo (p->pb, pServer);

		// Make sure the data chunk is aligned on 4-byte boundary
		//
		if (cbServer & 0x3)
		{
			// Round it up
			//
			cbServer = (cbServer & (~0x3)) + 4;
		}

		// Adjust the running pointer
		//
		p->pb += cbServer;
	}

	return S_OK;
}






SP_CRequestQueue::
SP_CRequestQueue ( VOID )
	:
	m_ItemList (NULL),
	m_uCurrOpRespID (INVALID_RESP_ID)
{
	// Create critical sections for thread safe access
	//
	::MyInitializeCriticalSection (&m_csReqQ);
	::MyInitializeCriticalSection (&m_csCurrOp);
}


SP_CRequestQueue::
~SP_CRequestQueue ( VOID )
{
	// when this is called, the hidden window thread exited already.
	// this is assured in UlsLdap_Deinitialize().
	//

	WriteLock ();

	// Free all the items in this list
	//
	MARSHAL_REQ *p, *next;
	for (p = m_ItemList; p != NULL; p = next)
	{
		next = p->next;
		MemFree (p);
	}
	m_ItemList = NULL;

	WriteUnlock ();

	// Delete critical sections
	//
	::MyDeleteCriticalSection (&m_csReqQ);
	::MyDeleteCriticalSection (&m_csCurrOp);
}


HRESULT SP_CRequestQueue::
Enter ( MARSHAL_REQ *p )
{
	// Make sure we have valid pointers
	//
	if (p == NULL)
	{
		MyAssert (FALSE);
		return ILS_E_POINTER;
	}
	MyAssert (! MyIsBadWritePtr (p, p->cbTotalSize));
	MyAssert (p->next == NULL);
	MyAssert (p->uRespID != 0);

	WriteLock ();

	// Append the new request
	//
	p->next = NULL;
	if (m_ItemList == NULL)
	{
		m_ItemList = p;
	}
	else
	{
		for (	MARSHAL_REQ *prev = m_ItemList;
				prev->next != NULL;
				prev = prev->next)
			;

		MyAssert (prev != NULL);
		prev->next = p;
	}

	WriteUnlock ();

	// Signal the internal request thread to pick up this request
	//
	SetEvent (g_hevNewRequest);

	return S_OK;
}


VOID SP_CRequestQueue::
Schedule ( VOID )
{
	MARSHAL_REQ *p;

	while (IsAnyReqInQueue () && ! g_fExitNow)
	{
		// Reset to null, we will use this as an indicator
		// to see if we need to process the request
		//
		p = NULL;

		// Lock request queue
		//
		WriteLock ();

		// Get a request to process
		//
		if (IsAnyReqInQueue ())
		{
			p = m_ItemList;
			m_ItemList = m_ItemList->next;
		}

		// We want to lock both request queue and CurrOp at the same time
		// because we cannot have a temporal window that either one can change.

		// Set CurrOp
		//
		if (p != NULL)
		{
			// Lock CurrOp
			//
			LockCurrOp ();

			// Set CurrOp
			//
			m_uCurrOpRespID = p->uRespID;

			// Unlock CurrOp
			//
			UnlockCurrOp ();
		}

		// Unlock request queue
		//
		WriteUnlock ();

		// Make sure we have something to process
		//
		if (p == NULL)
		{
			// Nothing to do any more
			//
			MyAssert (FALSE);
			break;
		}

		// Let's process the request
		//
		Dispatch (p);

		MemFree(p);
	}
}


HRESULT SP_CRequestQueue::
Cancel ( ULONG uRespID )
{
	HRESULT hr;
	MARSHAL_REQ *p, *next, *prev;

	// The locking order is always in
	// Lock(PendingOpQueue), Lock(RequestQueue), Lock (CurrOp)
	//
	WriteLock ();
	LockCurrOp ();

	if (m_uCurrOpRespID == uRespID)
	{
		// Invalidate the curr op.
		// When the curr op is done, then the request thread will remove it
		// from the pending op queue.
		//
		m_uCurrOpRespID = INVALID_RESP_ID;
		hr = S_OK;
	}
	else
	{
		// Look for the item with a matching response id
		//
		for (prev = NULL, p = m_ItemList; p != NULL; prev = p, p = next)
		{
			// Cache the next pointer
			//
			next = p->next;

			// See if the response id matches
			//
			if (p->uRespID == uRespID)
			{
				// It is a match
				//
				MyDebugMsg ((ZONE_REQ, "ULS: cancelled request(0x%lX) in ReqQ\r\n", p->uNotifyMsg));

				// Let's destroy this item
				//
				if (p == m_ItemList)
				{
					m_ItemList = next;
				}
				else
				{
					MyAssert (prev != NULL);
					prev->next = next;
				}

				// Free this structure
				//
				MemFree (p);

				// Get out of the loop
				//
				break;
			}
		} // for

		hr = (p == NULL) ? ILS_E_NOTIFY_ID : S_OK;
	} // else

	UnlockCurrOp ();
	WriteUnlock ();

	return hr;
}


VOID SP_CRequestQueue::
Dispatch ( MARSHAL_REQ *p )
{
	// Make sure we have a valid pointer
	//
	if (p == NULL)
	{
		MyAssert (FALSE);
		return;
	}

	// If it is keep alive, then do it
	//
	HRESULT hr;
	if (p->uNotifyMsg == WM_ILS_REFRESH)
	{
		// Keep alive handler
		//
		if (g_pRefreshScheduler != NULL)
		{
			ULONG uTTL = (ULONG) MarshalReq_GetParam (p, 0);
			hr = g_pRefreshScheduler->SendRefreshMessages (uTTL);
		}
		else
		{
			MyAssert (FALSE);
		}

		return;
	}

	// Locate the appropriate handler
	//
	REQUEST_HANDLER *pfn = ::GetRequestHandler (p->uNotifyMsg);
	if (pfn == NULL)
	{
		MyAssert (FALSE);
		return;
	}

	// Send the request to the server
	//
	MyDebugMsg ((ZONE_REQ, "ULS: sending request(0x%lX)\r\n", p->uNotifyMsg));
	ULONG uRespID = p->uRespID;
	LPARAM lParam = (*pfn) (p);
	MyDebugMsg ((ZONE_REQ, "ULS: sent request(0x%lX), lParam=0x%lX\r\n", p->uNotifyMsg, lParam));
	if (lParam != 0)
	{
		::PostMessage (g_hWndNotify, p->uNotifyMsg, p->uRespID, lParam);
		return;
	}
	// BUGBUG: this is a workaround for a server bug which results in lost requests if several
	// are sent very quickly.  Remove this Sleep() as soon as the bug is fixed!!!
//	Sleep(100);

	// Lock CurrOp again
	//
	LockCurrOp ();

	// Is this request cancelled
	//
	BOOL fCancelled = (m_uCurrOpRespID == INVALID_RESP_ID) ? TRUE : FALSE;

	// Clean up CurrOp
	//
	m_uCurrOpRespID = INVALID_RESP_ID;

	// Unlock CurrOp
	//
	UnlockCurrOp ();

	// If this request was cancelled, then remove it from the pending op queue
	//
	if (fCancelled)
	{
		// Redirect the call to the pending op queue object
		//
		if (g_pRespQueue != NULL)
		{
			g_pRespQueue->Cancel (uRespID);
		}
		else
		{
			MyAssert (FALSE);
		}
	}
}


/* ---------- RESPONSE ITEM ----------- */

/* ---------- public methods ----------- */


SP_CResponse::
SP_CResponse ( VOID )
	:
	m_pSession (NULL),			// Clean up session pointer
	m_pLdapMsg (NULL),			// Clean up ldap msg pointer
	m_next (NULL)				// Clean up the pointer to the next pending item
{
	// Clean up pending info structure
	//
	::ZeroMemory (&m_ri, sizeof (m_ri));

	// Fill in creation time
	//
	UpdateLastModifiedTime ();
	m_tcTimeout = g_uResponseTimeout;
}


SP_CResponse::
~SP_CResponse ( VOID )
{
	// Release the session if needed
	//
	if (m_pSession != NULL)
		m_pSession->Disconnect ();

	// Free the ldap msg if needed
	//
	if (m_pLdapMsg != NULL)
		::ldap_msgfree (m_pLdapMsg);

	// Free extended attribute name list
	//
	::MemFree (m_ri.pszAnyAttrNameList);

	// Free protocol names to resolve
	//
	::MemFree (m_ri.pszProtNameToResolve);
}


/* ---------- protected methods ----------- */


VOID SP_CResponse::
EnterResult ( LDAPMessage *pLdapMsg )
{
	// Free the old ldap msg if needed
	//
	if (m_pLdapMsg != NULL)
		::ldap_msgfree (m_pLdapMsg);

	// Keep the new ldap msg
	//
	m_pLdapMsg = pLdapMsg;
}


/* ---------- private methods ----------- */




/* ---------- RESPONSE QUEUE ----------- */


/* ---------- public methods ----------- */


SP_CResponseQueue::
SP_CResponseQueue ( VOID )
	:
	m_ItemList (NULL)		// Clean up the item list
{
	// Create a critical section for thread safe access
	//
	::MyInitializeCriticalSection (&m_csRespQ);
}


SP_CResponseQueue::
~SP_CResponseQueue ( VOID )
{
	// when this is called, the hidden window thread exited already.
	// this is assured in UlsLdap_Deinitialize().
	//

	WriteLock ();

	// Free all the items in this list
	//
	SP_CResponse *pItem, *next;
	for (pItem = m_ItemList; pItem != NULL; pItem = next)
	{
		next = pItem->GetNext ();
		delete pItem;
	}
	m_ItemList = NULL;

	WriteUnlock ();

	// Delete the critical section
	//
	::MyDeleteCriticalSection (&m_csRespQ);
}


HRESULT SP_CResponseQueue::
EnterRequest (
	SP_CSession		*pSession,
	RESP_INFO		*pInfo )
{
	// Make sure we have valid pointers
	//
	if (pSession == NULL || pInfo == NULL)
	{
		MyAssert (FALSE);
		return ILS_E_POINTER;
	}

	// Sanity checks
	//
	MyAssert (! MyIsBadWritePtr (pInfo, sizeof (*pInfo)));
	MyAssert (! MyIsBadWritePtr (pSession, sizeof (*pSession)));
	MyAssert (pInfo->ld != NULL && pInfo->uMsgID[0] != INVALID_MSG_ID);
	MyAssert (pInfo->uRespID != 0);

	// Create a new pending item
	//
	SP_CResponse *pItem = new SP_CResponse;
	if (pItem == NULL)
		return ILS_E_MEMORY;

	// Remember the contents of pending info
	//
	pItem->EnterRequest (pSession, pInfo);

	WriteLock ();

	// If this is the first item on the list, then
	// let's start the timer
	//
	if (m_ItemList == NULL)
		::SetTimer (g_hWndHidden, ID_TIMER_POLL_RESULT, g_uResponsePollPeriod, NULL);

	// Append the new pending op
	//
	pItem->SetNext (NULL);
	if (m_ItemList == NULL)
	{
		m_ItemList = pItem;
	}
	else
	{
		for (	SP_CResponse *prev = m_ItemList;
				prev->GetNext () != NULL;
				prev = prev->GetNext ())
			;

		MyAssert (prev != NULL);
		prev->SetNext (pItem);
	}

	WriteUnlock ();

	return S_OK;
}


HRESULT SP_CResponseQueue::
PollLdapResults ( LDAP_TIMEVAL *pTimeout )
{
	MyAssert (pTimeout != NULL);

	SP_CResponse *pItem, *next, *prev;
	INT RetCode;
	RESP_INFO *pInfo;
	LDAPMessage *pLdapMsg;
	HRESULT hr;
	RESPONSE_HANDLER *pfn;
	ULONG uResultSetType;

	::KillTimer (g_hWndHidden, ID_TIMER_POLL_RESULT); // avoid overrun

	WriteLock ();

	// Enumerate all the items to get available results for them
	//
	for (prev = NULL, pItem = m_ItemList; pItem != NULL; pItem = next)
	{
		// Cache the next pointer
		//
		next = pItem->GetNext ();

		// Get the pinding info structure
		//
		pInfo = pItem->GetRespInfo ();

		// Clean up ldap msg pointer
		//
		pLdapMsg = NULL;

		// Make sure ew have valid ld and msg id
		//
		MyAssert (pInfo->ld != NULL);
		MyAssert (pInfo->uMsgID[0] != INVALID_MSG_ID ||
					pInfo->uMsgID[1] != INVALID_MSG_ID);

		// Check integrity in pending info
		//
		MyAssert (pInfo->uRespID != 0);

		// Set the result set type
		//
		switch (pInfo->uNotifyMsg)
		{
		case WM_ILS_ENUM_CLIENTS:
		case WM_ILS_ENUM_CLIENTINFOS:
#ifdef ENABLE_MEETING_PLACE
		case WM_ILS_ENUM_MEETINGS:
		case WM_ILS_ENUM_MEETINGINFOS:
#endif
			uResultSetType = LDAP_MSG_RECEIVED;	// partial result set
			break;
		default:
			uResultSetType = LDAP_MSG_ALL;		// complete result set
			break;
		}

#ifdef _DEBUG
		if (MyIsBadWritePtr (pInfo->ld, sizeof (*(pInfo->ld))))
		{
			MyDebugMsg ((ZONE_CONN, "ILS:: poll result, bad ld=0x%p\r\n", pInfo->ld));
			MyAssert (FALSE);
		}
		if (pInfo->ld != pItem->GetSession()->GetLd())
		{
			MyDebugMsg ((ZONE_CONN, "ILS:: poll result, inconsistent pInfo->ld=0x%p, pItem->pSession->ld=0x%p\r\n", pInfo->ld, pItem->GetSession()->GetLd()));
			MyAssert (FALSE);
		}
#endif // _DEBUG

		// If primary msg id is valid
		//
		if (pInfo->uMsgID[0] != INVALID_MSG_ID)
			RetCode = ::ldap_result (pInfo->ld,
									pInfo->uMsgID[0],
									uResultSetType,
									pTimeout,
									&pLdapMsg);
		else
		// If secondary msg id is valid
		//
		if (pInfo->uMsgID[1] != INVALID_MSG_ID)
			RetCode = ::ldap_result (pInfo->ld,
									pInfo->uMsgID[1],
									uResultSetType,
									pTimeout,
									&pLdapMsg);

		// If timeout, ignore this item
		//
		if (RetCode == 0)
		{
			// Let's see if this item is expired
			//
			if (! pItem->IsExpired ())
			{
				// Not timed out, next please!
				//
				prev = pItem;
				continue;
			}

			// Timed out
			//
			hr = ILS_E_TIMEOUT;
		}

		// If error, delete this request item
		//
		if (RetCode == -1)
		{
			// Convert the error
			//
			hr = ::LdapError2Hresult (pInfo->ld->ld_errno);
		}
		else
		// If not timed out
		//
		if (RetCode != 0)
		{
			// It appears to be successful!
			//
			MyAssert (pLdapMsg != NULL);

			// Cache the ldap msg pointer
			pItem->EnterResult (pLdapMsg);

			// Get the ldap error code
			//
			hr = (pLdapMsg != NULL) ? ::LdapError2Hresult (pLdapMsg->lm_returncode) :
										S_OK;
		}

		// Get the result handler based on uNotifyMsg
		//
		pfn = ::GetResponseHandler (pInfo->uNotifyMsg);
		if (pfn == NULL)
		{
			prev = pItem;
			continue;
		}

		// Check integrity in pending info
		//
		MyAssert (pInfo->uRespID != 0);

		// Deal with the result or error
		//
		MyDebugMsg ((ZONE_RESP, "ULS: response(0x%lX), hr=0x%lX\r\n", pInfo->uNotifyMsg, hr));
		if ((*pfn) (hr, pItem))
		{
			// Let's destroy this item
			//
			if (pItem == m_ItemList)
			{
				m_ItemList = next;
			}
			else
			{
				MyAssert (prev != NULL);
				prev->SetNext (next);
			}
			delete pItem; // SP_CSession::Disconnect() and ldap_msgfree() will be called in destructor
		}
		else
		{
			// Let's keep this item around.
			// There are pending results coming in.
			//
			pItem->UpdateLastModifiedTime ();

			// Update the pointer
			//
			prev = pItem;
		}
	} // for

	// If there is no more items on the list, then stop the timer
	//
	if (m_ItemList != NULL)
		::SetTimer (g_hWndHidden, ID_TIMER_POLL_RESULT, g_uResponsePollPeriod, NULL);

	WriteUnlock ();

	return S_OK;
}


HRESULT SP_CResponseQueue::
Cancel ( ULONG uRespID )
{
	SP_CResponse *pItem, *next, *prev;
	RESP_INFO *pInfo;
	BOOL fNeedCleanup = FALSE;

	WriteLock ();

	// Look for the item with a matching response id
	//
	for (prev = NULL, pItem = m_ItemList; pItem != NULL; prev = pItem, pItem = next)
	{
		// Cache the next pointer
		//
		next = pItem->GetNext ();

		// Get the pinding info structure
		//
		pInfo = pItem->GetRespInfo ();
		MyAssert (pInfo != NULL);

		// See if the response id matches
		//
		if (pInfo->uRespID == uRespID)
		{
			// It is a match
			//
			SP_CSession *pSession = pItem->GetSession ();
			MyAssert (pSession != NULL);

			// Make sure we have a valid ldap session
			//
			MyAssert (pInfo->ld != NULL);

			// If we are NOT in the request thread, then we need to marshal it
			// to the request thread!!! Exit and report success!!!
			//
			if (GetCurrentThreadId () != g_dwReqThreadID)
			{
				MyDebugMsg ((ZONE_RESP, "ULS: marshalling request(0x%lX) in RespQ\r\n", pInfo->uNotifyMsg));
				MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_CANCEL, 0, 1);
				if (pReq != NULL)
				{
					MarshalReq_SetParam (pReq, 0, (DWORD) uRespID, 0);
					if (g_pReqQueue != NULL)
					{
						// This means that the locking order is
						// Lock(PendingOpQueue), Lock(RequestQueue)
						//
						g_pReqQueue->Enter (pReq);
					}
					else
					{
						MyAssert (FALSE);
					}
				}

				// Exit this loop
				//
				break;
			}

			// Indicate that we need to clean up item. Why?
			// because we should not have any network operation inside critical section.
			// this is to avoid any possible network blocking.
			//
			fNeedCleanup = TRUE;

			// Let's destroy this item
			//
			if (pItem == m_ItemList)
			{
				m_ItemList = next;
			}
			else
			{
				MyAssert (prev != NULL);
				prev->SetNext (next);
			}

			// Get out of the loop
			//
			break;
		} // if matched
	} // for

	// If there is no more items on the list, then stop the timer
	//
	if (m_ItemList == NULL)
		::KillTimer (g_hWndHidden, ID_TIMER_POLL_RESULT);

	WriteUnlock ();

	if (fNeedCleanup && pItem != NULL)
	{
		MyDebugMsg ((ZONE_RESP, "ULS: cancelled request(0x%lX) in RespQ\r\n", pInfo->uNotifyMsg));

		// Get resp info pointer
		//
		pInfo = pItem->GetRespInfo ();
		MyAssert (pInfo != NULL);

		// Abandon the primary response if needed
		//
		if (pInfo->uMsgID[1] != INVALID_MSG_ID)
			::ldap_abandon (pInfo->ld, pInfo->uMsgID[1]);

		// Abandon the secondary response if needed
		//
		if (pInfo->uMsgID[0] != INVALID_MSG_ID)
			::ldap_abandon (pInfo->ld, pInfo->uMsgID[0]);

		// SP_CSession::Disconnect() and ldap_msgfree() will be called in destructor
		//
		delete pItem;
	}

	return ((pItem == NULL) ? ILS_E_NOTIFY_ID : S_OK);
}


/* ---------- protected methods ----------- */


/* ---------- private methods ----------- */



/* ==================== utilities ====================== */


VOID
FillDefRespInfo (
	RESP_INFO		*pInfo,
	ULONG			uRespID,
	LDAP			*ld,
	ULONG			uMsgID,
	ULONG			u2ndMsgID )
{
	// Clean up
	//
	ZeroMemory (pInfo, sizeof (*pInfo));

	// Cache the ldap session
	//
	pInfo->ld = ld;

	// Generate a unique notify id
	//
	pInfo->uRespID = uRespID;

	// Store the primary and seconary msg ids
	//
	pInfo->uMsgID[0] = uMsgID;
	pInfo->uMsgID[1] = u2ndMsgID;
}



/* ---------- REFRESH SCHEDULER ----------- */


/* ---------- public methods ----------- */


SP_CRefreshScheduler::
SP_CRefreshScheduler ( VOID )
	:
	m_ListHead (NULL)		// Initialize the item list
{
	// Create a critical section for thread safe access
	//
	::MyInitializeCriticalSection (&m_csRefreshScheduler);
}


SP_CRefreshScheduler::
~SP_CRefreshScheduler ( VOID )
{
	WriteLock ();

	// Clean up the item list
	//
	REFRESH_ITEM *p, *next;
	for (p = m_ListHead; p != NULL; p = next)
	{
		next = p->next;
		MemFree (p);
	}
	m_ListHead = NULL;

	WriteUnlock ();

	// Delete the critical section
	//
	::MyDeleteCriticalSection (&m_csRefreshScheduler);
}


HRESULT SP_CRefreshScheduler::
SendRefreshMessages ( UINT uTimerID )
{
	SP_CClient *pClient;
#ifdef ENABLE_MEETING_PLACE
	SP_CMeeting *pMtg;
#endif
	REFRESH_ITEM *prev, *curr;
	INT nIndex;

	// Lock the lists
	//
	ReadLock ();

	// Locate this object in the list
	//
	nIndex = TimerID2Index (uTimerID);
	for (prev = NULL, curr = m_ListHead;
			curr != NULL;
			curr = (prev = curr)->next)
	{
		if (curr->nIndex == nIndex)
		{
			// Find it. Let's send a refresh message for this object
			//
			switch (curr->ObjectType)
			{
			case CLIENT_OBJ:
				pClient = (SP_CClient *) curr->pObject;

				// Make sure this object is not deleted already
				//
				if (! MyIsBadWritePtr (pClient, sizeof (*pClient)) &&
					pClient->IsValidObject ())
				{
					// Make sure this object is valid and registered
					//
					if (pClient->IsRegistered ())
					{
						MyDebugMsg ((ZONE_KA, "KA: send refresh msg for client\r\n"));

						// Let's send a refresh message for this client object
						// and update the new ttl value
						//
						pClient->AddRef ();
						pClient->SendRefreshMsg ();
						curr->uTTL = pClient->GetTTL ();
						pClient->Release ();
					}
				}
				else
				{
					MyAssert (FALSE);
				}
				break;

#ifdef ENABLE_MEETING_PLACE
			case MTG_OBJ:
				pMtg = (SP_CMeeting *) curr->pObject;

				// Make sure this object is not deleted already
				//
				if (! MyIsBadWritePtr (pMtg, sizeof (*pMtg)) &&
					pMtg->IsValidObject ())
				{
					// Make sure this object is valid and registered
					//
					if (pMtg->IsRegistered ())
					{
						MyDebugMsg ((ZONE_KA, "KA: send refresh msg for mtg\r\n"));

						// Let's send a refresh message for this user object
						// and update the new ttl value
						//
						pMtg->AddRef ();
						pMtg->SendRefreshMsg ();
						curr->uTTL = pMtg->GetTTL ();
						pMtg->Release ();
					}
				}
				else
				{
					MyAssert (FALSE);
				}
				break;
#endif

			default:
				MyAssert (FALSE);
				break;
			}

			// Start the timer again and exit
			// Note that curr->uTTL is the new TTL value from the server
			// Also note that uTTL is in unit of minute
			//
			MyDebugMsg ((ZONE_KA, "KA: new ttl=%lu\r\n", curr->uTTL));
			::SetTimer (g_hWndHidden, uTimerID, Minute2TickCount (curr->uTTL), NULL);
			break;
		} // if
	} // for

	ReadUnlock ();
	return S_OK;
}


HRESULT SP_CRefreshScheduler::
EnterClientObject ( SP_CClient *pClient )
{
	if (pClient == NULL)
		return ILS_E_POINTER;

	return EnterObject (CLIENT_OBJ, (VOID *) pClient, pClient->GetTTL ());
}


#ifdef ENABLE_MEETING_PLACE
HRESULT SP_CRefreshScheduler::
EnterMtgObject ( SP_CMeeting *pMtg )
{
	if (pMtg == NULL)
		return ILS_E_POINTER;

	return EnterObject (MTG_OBJ, (VOID *) pMtg, pMtg->GetTTL ());
}
#endif


VOID *SP_CRefreshScheduler::
AllocItem ( BOOL fNeedLock )
{
	REFRESH_ITEM *p, *curr, *prev;
	INT nIndex, nLargestIndex;
	BOOL fGotTheNewIndex;

	// Allocate the structure
	//
	p = (REFRESH_ITEM *) MemAlloc (sizeof (REFRESH_ITEM));
	if (p != NULL)
	{
		if (fNeedLock)
			WriteLock ();

		// Find out what should be the index for the new item
		//
		nLargestIndex = -1; // Yes, it is -1 for the case m_ListHead==NULL
		fGotTheNewIndex = FALSE;
		for (nIndex = 0, prev = NULL, curr = m_ListHead;
				curr != NULL;
					nIndex++, curr = (prev = curr)->next)
		{
			if (curr->nIndex > nIndex)
			{
				p->nIndex = nIndex;
				fGotTheNewIndex = TRUE;
				break;
			}

			nLargestIndex = curr->nIndex;
		}

		// Put the new item in the list in its appropriate position
		//
		if (fGotTheNewIndex)
		{
			if (prev == NULL)
			{
				// The new one must be the first one
				//
				MyAssert (p->nIndex == 0);
				p->next = m_ListHead;
				m_ListHead = p;
			}
			else
			{
				// The new one in the middle of the list
				//
				MyAssert (prev->nIndex < p->nIndex && p->nIndex < curr->nIndex);
				MyAssert (prev->next == curr);
				(prev->next = p)->next = curr;
			}
		}
		else
		{
			MyAssert (m_ListHead == NULL || prev != NULL);

			if (m_ListHead == NULL)
			{
				// The new one will be the only one in the list
				//
				p->nIndex = 0;
				(m_ListHead = p)->next = NULL;
			}
			else
			{
				// The new one is at the end of the list
				//
				MyAssert (prev != NULL && prev->next == NULL && curr == NULL);
				p->nIndex = nLargestIndex + 1;
				(prev->next = p)->next = curr;
			}
		}

		if (fNeedLock)
			WriteUnlock ();
	} // if (p != NULL)

	return p;
}


HRESULT SP_CRefreshScheduler::
EnterObject ( PrivateObjType ObjectType, VOID *pObject, ULONG uInitialTTL )
{
	HRESULT hr = S_OK;

	WriteLock ();

	// Enter this object to the list
	//
	REFRESH_ITEM *p = (REFRESH_ITEM *) AllocItem (FALSE);
	if (p == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Fill in fields
	//
	p->ObjectType = ObjectType;
	p->pObject = pObject;
	p->uTTL = uInitialTTL;

	// Turn on the timer
	// Note that uTTL is in unit of minutes...
	//
	::SetTimer (g_hWndHidden, Index2TimerID (p->nIndex), Minute2TickCount (p->uTTL), NULL);

MyExit:

	WriteUnlock ();

	return hr;
}


HRESULT SP_CRefreshScheduler::
RemoveObject ( VOID *pObject )
{
	REFRESH_ITEM *prev, *curr;

	WriteLock ();

	// Locate this object in the list
	//
	for (prev = NULL, curr = m_ListHead;
			curr != NULL;
			curr = (prev = curr)->next)
	{
		if (curr->pObject == pObject)
		{
			// Find it, let's kill the timer first
			//
			KillTimer (g_hWndHidden, Index2TimerID (curr->nIndex));

			// Remove it from the list
			//
			if (prev == NULL)
			{
				// This one is the first one on the list
				//
				MyAssert (m_ListHead == curr);
				m_ListHead = curr->next;
			}
			else
			{
				// This one is in the middle of the list
				//
				MyAssert (prev->next == curr);
				prev->next = curr->next;
			}
            ::MemFree(curr);

			// Exit the loop
			//
			break;
		}
	}

	WriteUnlock ();

	return (curr != NULL ? S_OK : S_FALSE);
}




extern BOOL NotifyGeneric ( HRESULT, SP_CResponse * );
extern BOOL NotifyRegister ( HRESULT, SP_CResponse * );
extern BOOL NotifyResolveClient ( HRESULT, SP_CResponse * );
extern BOOL NotifyEnumClients ( HRESULT, SP_CResponse * );
extern BOOL NotifyEnumClientInfos ( HRESULT, SP_CResponse * );
extern BOOL NotifyResolveProt ( HRESULT, SP_CResponse * );
extern BOOL NotifyEnumProts ( HRESULT, SP_CResponse * );
extern BOOL NotifyResolveMtg ( HRESULT, SP_CResponse * );
extern BOOL NotifyEnumMtgInfos ( HRESULT, SP_CResponse * );
extern BOOL NotifyEnumMtgs ( HRESULT, SP_CResponse * );
extern BOOL NotifyEnumAttendees ( HRESULT, SP_CResponse * );

extern LPARAM AsynReq_RegisterClient ( MARSHAL_REQ * );
extern LPARAM AsynReq_RegisterProtocol ( MARSHAL_REQ * );
extern LPARAM AsynReq_RegisterMeeting ( MARSHAL_REQ * );
extern LPARAM AsynReq_UnRegisterClient ( MARSHAL_REQ * );
extern LPARAM AsynReq_UnRegisterProt ( MARSHAL_REQ * );
extern LPARAM AsynReq_UnRegisterMeeting ( MARSHAL_REQ * );
extern LPARAM AsynReq_SetClientInfo ( MARSHAL_REQ * );
extern LPARAM AsynReq_SetProtocolInfo ( MARSHAL_REQ * );
extern LPARAM AsynReq_SetMeetingInfo ( MARSHAL_REQ * );
extern LPARAM AsynReq_EnumClientsEx ( MARSHAL_REQ * );
extern LPARAM AsynReq_EnumProtocols ( MARSHAL_REQ * );
extern LPARAM AsynReq_EnumMtgsEx ( MARSHAL_REQ * );
extern LPARAM AsynReq_EnumAttendees ( MARSHAL_REQ * );
extern LPARAM AsynReq_ResolveClient ( MARSHAL_REQ * );
extern LPARAM AsynReq_ResolveProtocol ( MARSHAL_REQ * );
extern LPARAM AsynReq_ResolveMeeting ( MARSHAL_REQ * );
extern LPARAM AsynReq_UpdateAttendees ( MARSHAL_REQ * );
extern LPARAM AsynReq_Cancel ( MARSHAL_REQ * );


typedef struct
{
	#ifdef DEBUG
	LONG				nMsg;
	#endif
	RESPONSE_HANDLER	*pfnRespHdl;
	REQUEST_HANDLER		*pfnReqHdl;
}
	RES_HDL_TBL;



RES_HDL_TBL g_ResHdlTbl[] =
{
	{
		#ifdef DEBUG
		WM_ILS_REGISTER_CLIENT,
		#endif
		NotifyRegister,
		AsynReq_RegisterClient
	},
	{
		#ifdef DEBUG
		WM_ILS_UNREGISTER_CLIENT,
		#endif
		NotifyGeneric,
		AsynReq_UnRegisterClient
	},
	{
		#ifdef DEBUG
		WM_ILS_SET_CLIENT_INFO,
		#endif
		NotifyGeneric,
		AsynReq_SetClientInfo
	},
	{
		#ifdef DEBUG
		WM_ILS_RESOLVE_CLIENT,
		#endif
		NotifyResolveClient,
		AsynReq_ResolveClient
	},
	{
		#ifdef DEBUG
		WM_ILS_ENUM_CLIENTS,
		#endif
		NotifyEnumClients,
		AsynReq_EnumClientsEx
	},
	{
		#ifdef DEBUG
		WM_ILS_ENUM_CLIENTINFOS,
		#endif
		NotifyEnumClientInfos,
		AsynReq_EnumClientsEx
	},

	{
		#ifdef DEBUG
		WM_ILS_REGISTER_PROTOCOL,
		#endif
		NotifyRegister,
		AsynReq_RegisterProtocol
	},
	{
		#ifdef DEBUG
		WM_ILS_UNREGISTER_PROTOCOL,
		#endif
		NotifyGeneric,
		AsynReq_UnRegisterProt
	},
	{
		#ifdef DEBUG
		WM_ILS_SET_PROTOCOL_INFO,
		#endif
		NotifyGeneric,
		AsynReq_SetProtocolInfo
	},
	{
		#ifdef DEBUG
		WM_ILS_RESOLVE_PROTOCOL,
		#endif
		NotifyResolveProt,
		AsynReq_ResolveProtocol
	},
	{
		#ifdef DEBUG
		WM_ILS_ENUM_PROTOCOLS,
		#endif
		NotifyEnumProts,
		AsynReq_EnumProtocols
	},

#ifdef ENABLE_MEETING_PLACE
	{
		#ifdef DEBUG
		WM_ILS_REGISTER_MEETING,
		#endif
		NotifyRegister,
		AsynReq_RegisterMeeting
	},
	{
		#ifdef DEBUG
		WM_ILS_UNREGISTER_MEETING,
		#endif
		NotifyGeneric,
		AsynReq_UnRegisterMeeting
	},
	{
		#ifdef DEBUG
		WM_ILS_SET_MEETING_INFO,
		#endif
		NotifyGeneric,
		AsynReq_SetMeetingInfo
	},
	{
		#ifdef DEBUG
		WM_ILS_RESOLVE_MEETING,
		#endif
		NotifyResolveMtg,
		AsynReq_ResolveMeeting
	},
	{
		#ifdef DEBUG
		WM_ILS_ENUM_MEETINGINFOS,
		#endif
		NotifyEnumMtgInfos,
		AsynReq_EnumMtgsEx
	},
	{
		#ifdef DEBUG
		WM_ILS_ENUM_MEETINGS,
		#endif
		NotifyEnumMtgs,
		AsynReq_EnumMtgsEx
	},
	{
		#ifdef DEBUG
		WM_ILS_ADD_ATTENDEE,
		#endif
		NotifyGeneric,
		AsynReq_UpdateAttendees
	},
	{
		#ifdef DEBUG
		WM_ILS_REMOVE_ATTENDEE,
		#endif
		NotifyGeneric,
		AsynReq_UpdateAttendees
	},
	{
		#ifdef DEBUG
		WM_ILS_ENUM_ATTENDEES,
		#endif
		NotifyEnumAttendees,
		AsynReq_EnumAttendees
	},
#endif // ENABLE_MEETING_PLACE

	{
		#ifdef DEBUG
		WM_ILS_CANCEL,
		#endif
		NULL,
		AsynReq_Cancel
	}
};



#ifdef DEBUG
VOID DbgValidateHandlerTable ( VOID )
{
	MyAssert (ARRAY_ELEMENTS (g_ResHdlTbl) == WM_ILS_LAST_ONE - WM_ILS_ASYNC_RES + 1);

	for (LONG i = 0; i < ARRAY_ELEMENTS (g_ResHdlTbl); i++)
	{
		if (g_ResHdlTbl[i].nMsg - WM_ILS_ASYNC_RES != i)
		{
			MyAssert (FALSE);
			break;
		}
	}
}
#endif


RES_HDL_TBL *
GetHandlerTableEntry ( ULONG uNotifyMsg )
{
	ULONG nIndex = uNotifyMsg - WM_ILS_ASYNC_RES;

	if (nIndex > WM_ILS_LAST_ONE)
	{
		MyAssert (FALSE);
		return NULL;
	}

	return &g_ResHdlTbl[nIndex];
}


RESPONSE_HANDLER *
GetResponseHandler ( ULONG uNotifyMsg )
{
	RES_HDL_TBL *p = GetHandlerTableEntry (uNotifyMsg);
	return ((p != NULL) ? p->pfnRespHdl : NULL);
}


REQUEST_HANDLER *
GetRequestHandler ( ULONG uNotifyMsg )
{
	RES_HDL_TBL *p = GetHandlerTableEntry (uNotifyMsg);
	return ((p != NULL) ? p->pfnReqHdl : NULL);
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\spserver.h ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spserver.h
	Content:	This file contains the help functions for the service provider.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#ifndef _ILS_SP_SERVER_H_
#define _ILS_SP_SERVER_H_

#include <pshpack8.h>


typedef struct
{
	ULONG					uTimeoutInSecond;
	ILS_ENUM_AUTH_METHOD	AuthMethod;

	TCHAR		*pszServerName;
	TCHAR		*pszLogonName;
	TCHAR		*pszLogonPassword;
	TCHAR		*pszDomain;
	TCHAR		*pszCredential;
	TCHAR		*pszBaseDN;
}
	SERVER_INFO;


BOOL IlsSameServerInfo ( const SERVER_INFO *p1, const SERVER_INFO *p2 );
HRESULT IlsCopyServerInfo ( SERVER_INFO *pDst, const SERVER_INFO *pSrc );
VOID IlsFreeServerInfo ( SERVER_INFO *psi );

ULONG IlsGetLinearServerInfoSize ( const SERVER_INFO *psi );
VOID IlsLinearizeServerInfo ( BYTE *pData, const SERVER_INFO *pSrc );

HRESULT IlsFillDefServerInfo ( SERVER_INFO *p, TCHAR *pszServerName );

inline BOOL MyIsBadServerInfo ( SERVER_INFO *p )
{
	return (p == NULL || MyIsBadString (p->pszServerName));
}

#include <poppack.h>

#endif // _ILS_SP_SERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\spstdatt.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spstdatt.cpp
	Content:	This file contains the standard-attribute object.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"

/* ---------- public methods ----------- */


UlsLdap_CStdAttrs::UlsLdap_CStdAttrs ( VOID )
{
}


UlsLdap_CStdAttrs::~UlsLdap_CStdAttrs ( VOID )
{
}


/* ---------- protected methods ----------- */


HRESULT UlsLdap_CStdAttrs::SetStdAttrs (
	ULONG		*puRespID,
	ULONG		*puMsgID,
	ULONG		uNotifyMsg,
	VOID		*pInfo,
	SERVER_INFO	*pServerInfo,
	TCHAR		*pszDN )
{
	MyAssert (puRespID != NULL || puMsgID != NULL);
	MyAssert (pInfo != NULL);
	MyAssert (pServerInfo != NULL);
	MyAssert (pszDN != NULL);

	// cache info
	//
	HRESULT hr = CacheInfo (pInfo);
	if (hr != S_OK)
		return hr;

	// Build modify array for ldap_modify()
	//
	LDAPMod **ppMod = NULL;
	hr = CreateSetStdAttrsModArr (&ppMod);
	if (hr != S_OK)
		return hr;
	MyAssert (ppMod != NULL);

	// so far, we are done with local preparation
	//

	// Get the session object
	//
	UlsLdap_CSession *pSession = NULL;
	hr = g_pSessionContainer->GetSession (&pSession, pServerInfo);
	if (hr != S_OK)
	{
		MemFree (ppMod);
		return hr;
	}
	MyAssert (pSession != NULL);

	// Get the ldap session
	//
	LDAP *ld = pSession->GetLd ();
	MyAssert (ld != NULL);

	// Send the data over the wire
	//
	ULONG uMsgID = ldap_modify (ld, pszDN, ppMod);
	MemFree (ppMod);
	if (uMsgID == -1)
	{
		hr = ::LdapError2Hresult (ld->ld_errno);
		pSession->Disconnect ();
		return hr;
	}

	// If the caller requests a response id,
	// then submit this pending item.
	// else free up the session object
	//
	if (puRespID != NULL)
	{
		// Initialize pending info
		//
		PENDING_INFO PendingInfo;
		::FillDefPendingInfo (&PendingInfo, ld, uMsgID, INVALID_MSG_ID);
		PendingInfo.uLdapResType = LDAP_RES_MODIFY;
		PendingInfo.uNotifyMsg = uNotifyMsg;

		// Queue it
		//
		hr = g_pPendingQueue->EnterRequest (pSession, &PendingInfo);
		if (hr != S_OK)
		{
			// If queueing failed, then clean up
			//
			ldap_abandon (ld, uMsgID);
			pSession->Disconnect ();
			MyAssert (FALSE);
		}

		// Return the reponse id
		//
		*puRespID = PendingInfo.uRespID;
	}
	else
	{
		// Free up session (i.e. decrement the reference count)
		//
		pSession->Disconnect ();
	}

	if (puMsgID != NULL)
		*puMsgID = uMsgID;

	return hr;
}



HRESULT 
FillDefStdAttrsModArr (
	LDAPMod		***pppMod,
	DWORD		dwFlags,
	ULONG		cMaxAttrs,
	ULONG		*pcTotal,	// in/out parameter!!!
	LONG		IsbuModOp,
	ULONG		cPrefix,
	TCHAR		*pszPrefix )
{

	MyAssert (pppMod != NULL);
	MyAssert (pcTotal != NULL);
	MyAssert (	(cPrefix == 0 && pszPrefix == NULL) ||
				(cPrefix != 0 && pszPrefix != NULL));

	// Figure out the num of attributes
	//
	ULONG cAttrs = 0;
	for (ULONG i = 0; i < cMaxAttrs; i++)
	{
		if (dwFlags & 0x01)
			cAttrs++;
		dwFlags >>= 1;
	}

	// Allocate modify list
	//
	ULONG cTotal = *pcTotal + cPrefix + cAttrs;
	ULONG cbMod = IlsCalcModifyListSize (cTotal);
	*pppMod = (LDAPMod **) MemAlloc (cbMod);
	if (*pppMod == NULL)
		return ULS_E_MEMORY;

	// Fill in the modify list
	//
	LDAPMod *pMod;
	for (i = 0; i < cTotal; i++)
	{
		pMod = IlsGetModifyListMod (pppMod, cTotal, i);
		(*pppMod)[i] = pMod;
		pMod->mod_values = (TCHAR **) (pMod + 1);

		if (i < cPrefix)
		{
			pMod->mod_op = LDAP_MOD_REPLACE;
			pMod->mod_type = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
			*(pMod->mod_values) = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
		}
	}

	// Fix up the last one
	//
	IlsFixUpModOp ((*pppMod)[0], LDAP_MOD_REPLACE, IsbuModOp);
	(*pppMod)[cTotal] = NULL;

	// Return the total number of entries if needed
	//
	if (pcTotal)
		*pcTotal = cTotal;

	return S_OK;
}


/* ---------- private methods ----------- */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\spserver.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spserver.cpp
	Content:	This file contains the server and its authentication.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"


BOOL IlsSameServerInfo ( const SERVER_INFO *p1, const SERVER_INFO *p2 )
{
	return (p1->uTimeoutInSecond == p2->uTimeoutInSecond 				&&
			p1->AuthMethod		 == p2->AuthMethod						&&
		My_lstrcmpi (p1->pszServerName, 	p2->pszServerName) 	  == 0	&&
		My_lstrcmpi (p1->pszLogonName, 		p2->pszLogonName) 	  == 0	&&
		My_lstrcmpi (p1->pszLogonPassword, 	p2->pszLogonPassword) == 0	&&
		My_lstrcmpi (p1->pszDomain, 		p2->pszDomain) 	  	  == 0  &&
		My_lstrcmpi (p1->pszBaseDN, 		p2->pszBaseDN) 	  	  == 0  &&
		My_lstrcmpi (p1->pszCredential, 	p2->pszCredential) 	  == 0);
}


HRESULT IlsCopyServerInfo ( SERVER_INFO *pDst, const SERVER_INFO *pSrc )
{
	MyAssert (pDst != NULL && pSrc != NULL);

	SERVER_INFO si;
	ZeroMemory (&si, sizeof (si));
	si.uTimeoutInSecond = pSrc->uTimeoutInSecond;
	si.AuthMethod = pSrc->AuthMethod;
	si.pszServerName = My_strdup (pSrc->pszServerName);
	si.pszLogonName = My_strdup (pSrc->pszLogonName);
	si.pszLogonPassword = My_strdup (pSrc->pszLogonPassword);
	si.pszDomain = My_strdup (pSrc->pszDomain);
	si.pszCredential = My_strdup (pSrc->pszCredential);
	si.pszBaseDN = My_strdup (pSrc->pszBaseDN);

	if ((pSrc->pszServerName != NULL && si.pszServerName == NULL) ||
		(pSrc->pszLogonName != NULL && si.pszLogonName == NULL) ||
		(pSrc->pszLogonPassword != NULL && si.pszLogonPassword == NULL) ||
		(pSrc->pszDomain != NULL && si.pszDomain == NULL) ||
		(pSrc->pszCredential != NULL && si.pszCredential == NULL) ||
		(pSrc->pszBaseDN != NULL && si.pszBaseDN == NULL)
		)
	{
		IlsFreeServerInfo (&si);
		return ILS_E_MEMORY;
	}

	*pDst = si;
 	return S_OK;
}


VOID IlsFreeServerInfo ( SERVER_INFO *psi )
{
	if (psi != NULL)
	{
		MemFree (psi->pszServerName);
		MemFree (psi->pszLogonName);
		MemFree (psi->pszLogonPassword);
		MemFree (psi->pszDomain);
		MemFree (psi->pszCredential);
		MemFree (psi->pszBaseDN);

		ZeroMemory (psi, sizeof (*psi));
	}
}


ULONG IlsGetLinearServerInfoSize ( const SERVER_INFO *psi )
{
	ULONG cbSize = sizeof (SERVER_INFO);

	cbSize += (My_lstrlen (psi->pszServerName) + 1) * sizeof (TCHAR);
	cbSize += (My_lstrlen (psi->pszLogonName) + 1) * sizeof (TCHAR);
	cbSize += (My_lstrlen (psi->pszLogonPassword) + 1) * sizeof (TCHAR);
	cbSize += (My_lstrlen (psi->pszDomain) + 1) * sizeof (TCHAR);
	cbSize += (My_lstrlen (psi->pszCredential) + 1) * sizeof (TCHAR);
	cbSize += (My_lstrlen (psi->pszBaseDN) + 1) * sizeof (TCHAR);

	return cbSize;
}


VOID IlsLinearizeServerInfo ( BYTE *pData, const SERVER_INFO *pSrc )
{
	SERVER_INFO *p = (SERVER_INFO *) pData;
	pData = (BYTE *) (p + 1);

	CopyMemory (p, pSrc, sizeof (SERVER_INFO));

	if (pSrc->pszServerName != NULL)
	{
		p->pszServerName = (TCHAR *) pData;
		My_lstrcpy ((TCHAR *) pData, pSrc->pszServerName);
		pData += (lstrlen (pSrc->pszServerName) + 1) * sizeof (TCHAR);	
	}

	if (pSrc->pszLogonName != NULL)
	{
		p->pszLogonName = (TCHAR *) pData;
		My_lstrcpy ((TCHAR *) pData, pSrc->pszLogonName);
		pData += (lstrlen (pSrc->pszLogonName) + 1) * sizeof (TCHAR);	
	}

	if (pSrc->pszLogonPassword != NULL)
	{
		p->pszLogonPassword = (TCHAR *) pData;
		My_lstrcpy ((TCHAR *) pData, pSrc->pszLogonPassword);
		pData += (lstrlen (pSrc->pszLogonPassword) + 1) * sizeof (TCHAR);	
	}

	if (pSrc->pszDomain != NULL)
	{
		p->pszDomain = (TCHAR *) pData;
		My_lstrcpy ((TCHAR *) pData, pSrc->pszDomain);
		pData += (lstrlen (pSrc->pszDomain) + 1) * sizeof (TCHAR);	
	}

	if (pSrc->pszCredential != NULL)
	{
		p->pszCredential = (TCHAR *) pData;
		My_lstrcpy ((TCHAR *) pData, pSrc->pszCredential);
		pData += (lstrlen (pSrc->pszCredential) + 1) * sizeof (TCHAR);	
	}

	if (pSrc->pszBaseDN != NULL)
	{
		p->pszBaseDN = (TCHAR *) pData;
		My_lstrcpy ((TCHAR *) pData, pSrc->pszBaseDN);
		pData += (lstrlen (pSrc->pszBaseDN) + 1) * sizeof (TCHAR);	
	}
}

HRESULT IlsFillDefServerInfo ( SERVER_INFO *p, TCHAR *pszServerName )
{
	ZeroMemory (p, sizeof (*p));
	p->pszServerName = My_strdup (pszServerName);
	return ((p->pszServerName != NULL) ? S_OK : ILS_E_MEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\sppqueue.h ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		sppqueue.h
	Content:	This file contains the pending item/queue objects definition.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#ifndef _ILS_SP_PRQUEUE_H_
#define _ILS_SP_PRQUEUE_H_

#include <pshpack8.h>


/* ------------- Request Scheduler --------------- */

#define WM_ILS_REFRESH			((ULONG) -1)

typedef struct tagReqMarshal
{
	struct tagReqMarshal	*next;
	ULONG	cbTotalSize;	// for debug checking
	BYTE	*pb;			// running pointer

	ULONG	uRespID;		// for cancel and error notification

	ULONG	uNotifyMsg;
	ULONG	cParams;
	DWORD_PTR aParams[1];
	// more data follows...
}
	MARSHAL_REQ;


MARSHAL_REQ *MarshalReq_Alloc ( ULONG uNotifyMsg, ULONG cbSize, ULONG cParams );
HRESULT MarshalReq_SetParam ( MARSHAL_REQ *p, ULONG nIndex, DWORD_PTR dwParam, ULONG cbParamSize );
DWORD_PTR MarshalReq_GetParam ( MARSHAL_REQ *p, ULONG nIndex );
HRESULT MarshalReq_SetParamServer ( MARSHAL_REQ *p, ULONG nIndex, SERVER_INFO *pServer, ULONG cbServer );


enum { INVALID_RESP_ID = -1 };


class SP_CRequestQueue
{
	friend class SP_CResponseQueue;
	friend HRESULT UlsLdap_Cancel ( ULONG );

public:

	SP_CRequestQueue ( VOID );
	~SP_CRequestQueue ( VOID );

	HRESULT Enter ( MARSHAL_REQ *p );
	VOID Schedule ( VOID );
	VOID Dispatch ( MARSHAL_REQ *p );
	HRESULT Cancel ( ULONG uRespID );

	BOOL IsEmptyQueue ( VOID ) { return (m_ItemList == NULL); }
	BOOL IsAnyReqInQueue ( VOID ) { return (m_ItemList != NULL); }

	BOOL IsCurrentRequestCancelled ( VOID ) { return (m_uCurrOpRespID == INVALID_RESP_ID); }

protected:

	VOID LockCurrOp ( VOID ) { EnterCriticalSection (&m_csCurrOp); }
	VOID UnlockCurrOp ( VOID ) { LeaveCriticalSection (&m_csCurrOp); }

	VOID WriteLock ( VOID ) { EnterCriticalSection (&m_csReqQ); }
	VOID WriteUnlock ( VOID ) { LeaveCriticalSection (&m_csReqQ); }

private:

	VOID ReadLock ( VOID ) { WriteLock (); }
	VOID ReadUnlock ( VOID ) { WriteUnlock (); }

	MARSHAL_REQ 		*m_ItemList;

	CRITICAL_SECTION	m_csReqQ;

	ULONG				m_uCurrOpRespID;
	CRITICAL_SECTION	m_csCurrOp;
};

extern SP_CRequestQueue *g_pReqQueue;


/* ------------- Response Scheduler --------------- */

#define ILS_MIN_RESP_TIMEOUT	((ULONG) (20 * 1000))	// 20 seconds
#define ILS_DEF_RESP_TIMEOUT	((ULONG) (90 * 1000))	// 90 seconds
#define ILS_BK_RESP_TIMEOUT_SEC	90						// 90 seconds
extern ULONG g_uResponseTimeout;

#define ILS_MIN_RESP_POLL_PERIOD	((ULONG) 50)	// 50 ms
#define ILS_DEF_RESP_POLL_PERIOD	((ULONG) 100)	// 100 ms per PatLam's experiment
extern ULONG g_uResponsePollPeriod;

#define Minute2TickCount(m)				((m) * 60 * 1000)
#define ILS_DEF_REFRESH_MINUTE			2
#define ILS_DEF_REFRESH_MARGIN_MINUTE	2


typedef struct
{
	// ldap specific
	LDAP		*ld;
	ULONG		uMsgID[2];
	// notification specific
	ULONG		uRespID;
	ULONG		uNotifyMsg;
	// object specific
	HANDLE		hObject;	// user, app, prot object
	// mutual dependency specific
	HRESULT		hrDependency;	// S_OK if not used
	// for extended attributes
	ULONG		cAnyAttrs;
	TCHAR		*pszAnyAttrNameList;
	// for resolving protocol
	TCHAR		*pszProtNameToResolve;
}
	RESP_INFO;

class SP_CResponse
{
	friend class SP_CResponseQueue;

public:

	SP_CResponse ( VOID );
	~SP_CResponse ( VOID );

	LDAPMessage *GetResult ( VOID ) { return m_pLdapMsg; }

	RESP_INFO *GetRespInfo ( VOID ) { return &m_ri; }

	SP_CSession *GetSession ( VOID ) { return m_pSession; }
	LDAP *GetLd ( VOID ) { return m_ri.ld; }

protected:

	VOID EnterResult ( LDAPMessage *pLdapMsg );

	VOID EnterRequest ( SP_CSession *pSession, RESP_INFO *pInfo )
	{
		m_pSession = pSession;
		m_ri = *pInfo;
		m_tcTimeout = m_pSession->GetServerTimeoutInTickCount ();
	}

	SP_CResponse *GetNext ( VOID ) { return m_next; }
	VOID SetNext ( SP_CResponse *pItem ) { m_next = pItem; }

private:

	VOID UpdateLastModifiedTime ( VOID ) { m_tcLastModifiedTime = GetTickCount (); }

	BOOL IsExpired ( VOID ) { return (GetTickCount () - m_tcLastModifiedTime >= m_tcTimeout); }

	RESP_INFO		m_ri;

	SP_CSession		*m_pSession;
	LDAPMessage		*m_pLdapMsg;
	SP_CResponse	*m_next;

	ULONG			m_tcLastModifiedTime;
	ULONG			m_tcTimeout;
};


class SP_CResponseQueue
{
	friend class SP_CRequestQueue;
	friend HRESULT UlsLdap_Cancel ( ULONG );

public:

	SP_CResponseQueue ( VOID );
	~SP_CResponseQueue ( VOID );

	HRESULT EnterRequest ( SP_CSession *pSession, RESP_INFO *pInfo );
	HRESULT PollLdapResults ( LDAP_TIMEVAL *pTimeout );

	HRESULT Cancel ( ULONG uRespID );

protected:

	VOID WriteLock ( VOID ) { EnterCriticalSection (&m_csRespQ); }
	VOID WriteUnlock ( VOID ) { LeaveCriticalSection (&m_csRespQ); }

private:

	VOID ReadLock ( VOID ) { WriteLock (); }
	VOID ReadUnlock ( VOID ) { WriteUnlock (); }

	SP_CResponse 	*m_ItemList;

	CRITICAL_SECTION m_csRespQ;
};


extern SP_CResponseQueue *g_pRespQueue;


VOID FillDefRespInfo ( RESP_INFO *pInfo, ULONG uRespID, LDAP *ld, ULONG uMsgID, ULONG u2ndMsgID );


/* ------------- Refersh Message Scheduler --------------- */

class SP_CRefreshScheduler
{
public:

	SP_CRefreshScheduler ( VOID );
	~SP_CRefreshScheduler ( VOID );

	HRESULT SendRefreshMessages ( UINT uTimerID );

	HRESULT EnterClientObject ( SP_CClient *pClient );
	HRESULT RemoveClientObject ( SP_CClient *pClient ) { return RemoveObject ((VOID *) pClient); }

#ifdef ENABLE_MEETING_PLACE
	HRESULT EnterMtgObject ( SP_CMeeting *pMtg );
	HRESULT RemoveMtgObject ( SP_CMeeting *pMtg ) { return RemoveObject ((VOID *) pMtg); }
#endif

protected:

private:

	VOID WriteLock ( VOID ) { EnterCriticalSection (&m_csRefreshScheduler); }
	VOID WriteUnlock ( VOID ) { LeaveCriticalSection (&m_csRefreshScheduler); }
	VOID ReadLock ( VOID ) { WriteLock (); }
	VOID ReadUnlock ( VOID ) { WriteUnlock (); }

	typedef enum { UNK_OBJ, CLIENT_OBJ, MTG_OBJ } PrivateObjType;
	typedef struct tagREFRESH_ITEM
	{
		INT				nIndex;
		PrivateObjType	ObjectType;
		VOID			*pObject;
		ULONG			uTTL;
		struct tagREFRESH_ITEM *next;
	}
		REFRESH_ITEM;

	INT TimerID2Index ( UINT uTimerID ) { return (INT) uTimerID - KEEP_ALIVE_TIMER_BASE; }
	UINT Index2TimerID ( INT nIndex ) { return (UINT) (nIndex + KEEP_ALIVE_TIMER_BASE); }

	VOID *AllocItem ( BOOL fNeedLock );
	HRESULT EnterObject ( PrivateObjType ObjectType, VOID *pObject, ULONG uInitialTTL );
	HRESULT RemoveObject ( VOID *pObject );

	REFRESH_ITEM	*m_ListHead;
	CRITICAL_SECTION m_csRefreshScheduler;
};


extern SP_CRefreshScheduler *g_pRefreshScheduler;


#include <poppack.h>

#endif // _ILS_SP_PRQUEUE_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\spnotify.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spnotify.cpp
	Content:	This file contains the notification handlers.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"


typedef struct
{
	TCHAR	*pszName;
	TCHAR	*pszValue;
}
	ATTR_PAIR;

typedef struct
{
	ULONG		cMaxAttrs;
	ULONG		cCurrAttrs;
	ATTR_PAIR	aPairs[1];
}
	ATTR_PAIRS;	

typedef struct
{
	CLIENT_INFO	ClientInfo;
	ATTR_PAIRS	Attrs;
}
	CLIENT_INFO_ATTRS;


#ifdef ENABLE_MEETING_PLACE
typedef struct
{
	MTG_INFO	MtgInfo;
	ATTR_PAIRS	Attrs;
}
	MTG_INFO_ATTRS;
#endif


ULONG
GetUniqueNotifyID ( VOID )
{
	// Always positive number
	//
	if (g_uRespID & 0x80000000UL)
		g_uRespID = 1;

	return g_uRespID++;
}


BOOL
NotifyGeneric (
	HRESULT			hrServer,
	SP_CResponse	*pItem )
{
	MyAssert (pItem != NULL);

	// Get the pending info
	//
	RESP_INFO *pInfo = pItem->GetRespInfo ();
	MyAssert (pInfo != NULL);

	// Do not use the result (pLdapMsg)
	//

	// Check dependency such as modify/modrdn
	//
	if (pInfo->uMsgID[0] != INVALID_MSG_ID)
	{
		// Do we wait for the second result?
		// If so, remember the hr from the first result.
		//
		if (pInfo->uMsgID[1] != INVALID_MSG_ID)
		{
			// We need two results; the first one just comes in.
			// We still need to wait for the second one
			//
			pInfo->uMsgID[0] = INVALID_MSG_ID;
			pInfo->hrDependency = hrServer;

			// Don't destroy this item
			//
			return FALSE;
		}
	}
	else
	{
		// This is the second result
		//
		MyAssert (pInfo->uMsgID[1] != INVALID_MSG_ID);

		// Propagate the hr from the first result if needed
		//
		if (pInfo->hrDependency != S_OK)
			hrServer = pInfo->hrDependency;
	}

	// Post the result to the com layer
	//
	PostMessage (g_hWndNotify, pInfo->uNotifyMsg, pInfo->uRespID, hrServer);

	// Destroy this pending item
	//
	return TRUE;
}


BOOL
NotifyRegister (
	HRESULT			hrServer,
	SP_CResponse	*pItem )
{
	MyAssert (pItem != NULL);

	// Get pending info
	//
	RESP_INFO *pInfo = pItem->GetRespInfo ();
	MyAssert (pInfo != NULL);

	// Get the object of user/app/prot/mtg
	//
	HANDLE hObject = pInfo->hObject;
	MyAssert (hObject != NULL);

	// Do not use the result (pLdapMsg)
	//

	// Check dependency such as modify/modrdn
	//
	if (pInfo->uMsgID[0] != INVALID_MSG_ID)
	{
		// Do we wait for the second result?
		// If so, remember the hr from the first result.
		//
		if (pInfo->uMsgID[1] != INVALID_MSG_ID)
		{
			// We need two results; the first one just comes in.
			// We still need to wait for the second one
			//
			pInfo->uMsgID[0] = INVALID_MSG_ID;
			pInfo->hrDependency = hrServer;

			// Don't destroy this item
			//
			return FALSE;
		}
	}
	else
	{
		// This is the second result
		//
		MyAssert (pInfo->uMsgID[1] != INVALID_MSG_ID);

		// Propagate the hr from the first result if needed
		//
		if (pInfo->hrDependency != S_OK)
			hrServer = pInfo->hrDependency;
	}

	// Notify the object of success/failure
	//
	SP_CClient *pClient;
	SP_CProtocol *pProt;
#ifdef ENABLE_MEETING_PLACE
	SP_CMeeting *pMtg;
#endif
	if (hrServer != S_OK)
	{
		// Release the object when failure
		//
		switch (pInfo->uNotifyMsg)
		{
		case WM_ILS_REGISTER_CLIENT:
			pClient = (SP_CClient *) hObject;
			if (pClient->IsValidObject ())
			{
				pClient->Release ();
			}
			break;
		case WM_ILS_REGISTER_PROTOCOL:
			pProt = (SP_CProtocol *) hObject;
			if (pProt->IsValidObject ())
			{
				pProt->Release ();
			}
			break;
#ifdef ENABLE_MEETING_PLACE
		case WM_ILS_REGISTER_MEETING:
			pMtg = (SP_CMeeting *) hObject;
			if (pMtg->IsValidObject ())
			{
				pMtg->Release ();
			}
			break;
#endif
		default:
			MyAssert (FALSE);
			break;
		}
	}
	else
	{
		// Set as successful registration when success
		//
		switch (pInfo->uNotifyMsg)
		{
		case WM_ILS_REGISTER_CLIENT:
			pClient = (SP_CClient *) hObject;
			if (pClient->IsValidObject ())
			{
				pClient->SetRegRemotely ();

				if (g_pRefreshScheduler != NULL)
				{
					g_pRefreshScheduler->EnterClientObject (pClient);
				}
				else
				{
					MyAssert (FALSE);
				}
			}
			break;
		case WM_ILS_REGISTER_PROTOCOL:
			pProt = (SP_CProtocol *) hObject;
			if (pProt->IsValidObject ())
			{
				pProt->SetRegRemotely ();
			}
			break;
#ifdef ENABLE_MEETING_PLACE
		case WM_ILS_REGISTER_MEETING:
			pMtg = (SP_CMeeting *) hObject;
			if (pMtg->IsValidObject ())
			{
				pMtg->SetRegRemotely ();

				if (g_pRefreshScheduler != NULL)
				{
					g_pRefreshScheduler->EnterMtgObject (pMtg);
				}
				else
				{
					MyAssert (FALSE);
				}
			}
			break;
#endif
		default:
			MyAssert (FALSE);
			break;
		}
	}

	// Post the result to the com layer
	//
	PostMessage (g_hWndNotify, pInfo->uNotifyMsg, pInfo->uRespID, (LPARAM) hrServer);

	// Destroy this pending item
	//
	return TRUE;
}


/* =========== ENUMERATION ============ */

typedef struct
{
	ULONG		uEnumUsers; // WM_ILS_ENUM_USERS, WM_ILS_ENUM_USERINFOS, or 0
	ULONG		cItems;
	ULONG		cbEntrySize;
	BYTE		bData[8];	// data starting from here
}
	ENUM_LIST;


extern HRESULT CacheEnumInfos ( ULONG uNotifyMsg, LDAP *ld, LDAPMessage *pEntry, VOID *p );
extern VOID BuildEnumObjectNames ( LDAP_ENUM *pEnum, ENUM_LIST *pEnumList );
extern VOID BuildEnumClientInfos ( LDAP_ENUM *pEnum, ENUM_LIST *pEnumList );
extern VOID SizeEnumClientInfos ( ULONG *pcbTotalSize, CLIENT_INFO_ATTRS *pcia );
extern VOID TotalSizeEnumObjectNames ( ULONG *pcbTotalSize, ULONG cEntries, TCHAR **appszObjectNames[] );
extern VOID FreeStdAttrCache ( TCHAR *apszStdAttrValues[], ULONG cStdAttrs );
extern VOID FreeAttrPairArrayCache ( ATTR_PAIR aAttrPair[], ULONG cPairs );
extern VOID CacheAnyAttrNamesInAttrPairs ( ULONG cNames, TCHAR *pszSrcNameList, ATTR_PAIR aAttrPairs[] );
#ifdef ENABLE_MEETING_PLACE
extern VOID BuildEnumMtgInfos ( LDAP_ENUM *pEnum, ENUM_LIST *pEnumList );
extern VOID SizeEnumMtgInfos ( ULONG *pcbTotalSize, MTG_INFO_ATTRS *pmia );
#endif


BOOL NotifyEnumX (
	ULONG			uEnumType,
	HRESULT			hrServer,
	SP_CResponse	*pItem,
	TCHAR			*pszRetAttrName ) // returned attribute's name
{
	MyAssert (pItem != NULL);

#if defined (DEBUG) || defined (_DEBUG)
	// Consistency checks
	//
	switch (uEnumType)
	{
	case WM_ILS_ENUM_CLIENTS:
#ifdef ENABLE_MEETING_PLACE
	case WM_ILS_ENUM_MEETINGS:
#endif
		MyAssert (pszRetAttrName != NULL && *pszRetAttrName != TEXT ('\0'));
		break;		
	case WM_ILS_ENUM_CLIENTINFOS:
#ifdef ENABLE_MEETING_PLACE
	case WM_ILS_ENUM_MEETINGINFOS:
#endif
		MyAssert (pszRetAttrName == NULL);
		break;
	default:
		MyAssert (FALSE);
		break;
	}
#endif

	// Get pending info
	//
	RESP_INFO *pInfo = pItem->GetRespInfo ();
	MyAssert (pInfo != NULL);

	// Initialize minimal info
	//
	LDAP_ENUM *pEnum = NULL;
	ENUM_LIST *pEnumList = NULL;

	// If error, simply report the error
	//
	if (hrServer != S_OK)
		goto MyExit;

	// Get the ldap result
	//
	LDAPMessage *pLdapMsg;
	pLdapMsg = pItem->GetResult ();
	if (pLdapMsg == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_POINTER;
		goto MyExit;
	}

	// Get ld
	//
	LDAP *ld;
	ld = pItem->GetLd ();
	if (ld == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_HANDLE;
		goto MyExit;
	}

	// Initialize the total size of LDAP_ENUM
	//
	ULONG cbTotalSize;
	cbTotalSize =	sizeof (LDAP_ENUM) +	// the minimal info
					sizeof (TCHAR); 		// the last null terminator

	// Let's get the count of entries in this result set
	//
	ULONG cEntries, i;
	cEntries = ldap_count_entries (ld, pLdapMsg);

	// Return now if there is nothing to handle
	//
	if (cEntries <= 0)
	{
		// I want to make sure this case happens or not
		//
		MyAssert (cEntries == 0);

		// Simply return without deleting this pending item
		//
		return FALSE;
	}

	// In the following, we only deal with the case (cEntries > 0)
	//

	// Calculate enum list size
	//
	ULONG cbEntrySize , cbSizeEnumList;
	switch (uEnumType)
	{
	case WM_ILS_ENUM_CLIENTINFOS:
		cbEntrySize = sizeof (CLIENT_INFO_ATTRS) +
						pInfo->cAnyAttrs * sizeof (ATTR_PAIR);
		break;
#ifdef ENABLE_MEETING_PLACE
	case WM_ILS_ENUM_MEETINGINFOS:
		cbEntrySize = sizeof (MTG_INFO_ATTRS) +
						pInfo->cAnyAttrs * sizeof (ATTR_PAIR);
		break;
#endif
	default:
		cbEntrySize = sizeof (TCHAR **);
		break;
	}
	cbSizeEnumList = sizeof (ENUM_LIST) + cEntries * cbEntrySize;

	// Allocate the enum list that is a temporary cache
	// for all attributes from wldap32.dll
	//
	pEnumList = (ENUM_LIST *) MemAlloc (cbSizeEnumList);
	if (pEnumList == NULL)
	{
		// Fails probably due to insane cbSizeEnumList
		//
		MyAssert (FALSE);
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}

	// Fill in enum list
	//
	pEnumList->uEnumUsers = uEnumType;
	pEnumList->cItems = cEntries;
	pEnumList->cbEntrySize = cbEntrySize;

	// Fill in names of extended attributes if needed
	//
	if (pInfo->cAnyAttrs > 0)
	{
		switch (uEnumType)
		{
		case WM_ILS_ENUM_CLIENTINFOS:
			for (i = 0; i < cEntries; i++)
			{
				CLIENT_INFO_ATTRS *p = (CLIENT_INFO_ATTRS *) (&(pEnumList->bData[0]) + i * cbEntrySize);
				p->Attrs.cMaxAttrs = pInfo->cAnyAttrs;
				CacheAnyAttrNamesInAttrPairs (	pInfo->cAnyAttrs,
												pInfo->pszAnyAttrNameList,
												&(p->Attrs.aPairs[0]));
			}
			break;
#ifdef ENABLE_MEETING_PLACE
		case WM_ILS_ENUM_MEETINGINFOS:
			for (i = 0; i < cEntries; i++)
			{
				MTG_INFO_ATTRS *p = (MTG_INFO_ATTRS *) (&(pEnumList->bData[0]) + i * cbEntrySize);
				p->Attrs.cMaxAttrs = pInfo->cAnyAttrs;
				CacheAnyAttrNamesInAttrPairs (	pInfo->cAnyAttrs,
												pInfo->pszAnyAttrNameList,
												&(p->Attrs.aPairs[0]));
			}
			break;
#endif
		default:
			break;
		}
	}

	// Get the first entry
	//
	LDAPMessage *pEntry;
	pEntry = ldap_first_entry (ld, pLdapMsg);
	if (pEntry == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}

	// Cache the attributes in the first entry
	//
	TCHAR ***appszObjectNames = NULL;
	switch (uEnumType)
	{
	case WM_ILS_ENUM_CLIENTINFOS:
#ifdef ENABLE_MEETING_PLACE
	case WM_ILS_ENUM_MEETINGINFOS:
#endif
		hrServer = CacheEnumInfos (uEnumType, ld, pEntry, (VOID *) &(pEnumList->bData[0]));
		if (hrServer != S_OK)
		{
			MyAssert (FALSE);
			goto MyExit;
		}
		break;
	default:
		appszObjectNames = (TCHAR ***) &(pEnumList->bData[0]);
		appszObjectNames[0] = my_ldap_get_values (ld, pEntry, pszRetAttrName);
		if (appszObjectNames[0] == NULL)
		{
			MyAssert (FALSE);
			hrServer = ILS_E_MEMORY;
			goto MyExit;
		}
		break;
	} // switch (uEnumType)

	// Loop through the other entries
	//
	for (i = 1; i < cEntries; i++)
	{
		// Next entry, please
		//
		pEntry = ldap_next_entry (ld, pEntry);
		if (pEntry == NULL)
		{
			MyAssert (FALSE);

			// Failed, adjust the count to return partial result
			//
			pEnumList->cItems = cEntries = i;
			break;
		}

		// Cache the attributes in the subsequent entries
		//
		switch (uEnumType)
		{
		case WM_ILS_ENUM_CLIENTINFOS:
#ifdef ENABLE_MEETING_PLACE
		case WM_ILS_ENUM_MEETINGINFOS:
#endif
			hrServer = CacheEnumInfos (uEnumType, ld, pEntry, (CLIENT_INFO_ATTRS *)
							(&(pEnumList->bData[0]) + i * cbEntrySize));
			if (hrServer != S_OK)
			{
				MyAssert (FALSE);
				goto MyExit;
			}
			break;
		default:
			appszObjectNames[i] = my_ldap_get_values (ld, pEntry, pszRetAttrName);
			if (appszObjectNames[i] == NULL)
			{
				MyAssert (FALSE);
				hrServer = ILS_E_MEMORY;
				goto MyExit;
			}
			break;
		} // switch (uEnumType)
	} // for (i = 1; i < cEntries; i++)

	// We just cache all the attribute names and values.
	// Now, we need to calculate the total size of the return buffer.
	//

	// Calculate the total size of the LDAP_ENUM structure...
	//
	switch (uEnumType)
	{
	case WM_ILS_ENUM_CLIENTINFOS:
		for (i = 0; i < cEntries; i++)
		{
			SizeEnumClientInfos (&cbTotalSize, (CLIENT_INFO_ATTRS *)
						(&(pEnumList->bData[0]) + i * cbEntrySize));
		}
		break;
#ifdef ENABLE_MEETING_PLACE
	case WM_ILS_ENUM_MEETINGINFOS:
		for (i = 0; i < cEntries; i++)
		{
			SizeEnumMtgInfos (&cbTotalSize, (MTG_INFO_ATTRS *)
								(&(pEnumList->bData[0]) + i * cbEntrySize));
		}
		break;
#endif
	default:
		TotalSizeEnumObjectNames (&cbTotalSize, cEntries, &(appszObjectNames[0]));
		break;
	} // switch (uEnumType)

	// Allocate the returned LDAP_ENUM structure
	//
	pEnum = (LDAP_ENUM *) MemAlloc (cbTotalSize);
	if (pEnum == NULL)
	{
		// Fails probably due to insane cbTotalSize
		//
		MyAssert (FALSE);
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}

	// Fill in LDAP_ENUM common fields
	//
	pEnum->uSize = sizeof (*pEnum);
	pEnum->hResult = hrServer;
	pEnum->cItems = cEntries;
	pEnum->uOffsetItems = sizeof (*pEnum);

	// Fill in LDAP_ENUM items
	//
	switch (uEnumType)
	{
	case WM_ILS_ENUM_CLIENTINFOS:
		BuildEnumClientInfos (pEnum, pEnumList);
		break;
#ifdef ENABLE_MEETING_PLACE
	case WM_ILS_ENUM_MEETINGINFOS:
		BuildEnumMtgInfos (pEnum, pEnumList);
		break;
#endif
	default:
		BuildEnumObjectNames (pEnum, pEnumList);
		break;
	}

	MyAssert (hrServer == S_OK);

MyExit:

	// Free the temporary cache
	//
	if (pEnumList != NULL)
	{
		switch (uEnumType)
		{
		case WM_ILS_ENUM_CLIENTINFOS:
			for (i = 0; i < pEnumList->cItems; i++)
			{
				CLIENT_INFO_ATTRS *p = (CLIENT_INFO_ATTRS *)
							(&(pEnumList->bData[0]) + i * cbEntrySize);

				// Free standard attributes
				//
				FreeStdAttrCache (&(p->ClientInfo.apszStdAttrValues[0]), COUNT_ENUM_DIR_CLIENT_INFO);

				// Free extended attributes
				//
				FreeAttrPairArrayCache (&(p->Attrs.aPairs[0]), pInfo->cAnyAttrs);
			}
			break;
#ifdef ENABLE_MEETING_PLACE
		case WM_ILS_ENUM_MEETINGINFOS:
			for (i = 0; i < pEnumList->cItems; i++)
			{
				MTG_INFO_ATTRS *p = (MTG_INFO_ATTRS *)
										(&(pEnumList->bData[0]) + i * cbEntrySize);

				// Free standard attributes
				//
				FreeStdAttrCache (&(p->MtgInfo.apszStdAttrValues[0]), COUNT_ENUM_DIRMTGINFO);

				// Free extended attributes
				//
				FreeAttrPairArrayCache (&(p->Attrs.aPairs[0]), pInfo->cAnyAttrs);
			}
			break;
#endif
		default:
			for (i = 0; i < pEnumList->cItems; i++)
			{
				if (appszObjectNames && appszObjectNames[i] != NULL)
					ldap_value_free (appszObjectNames[i]);
			}
			break;
		}
		MemFree (pEnumList);
	} // if

	// Clean up if failure
	//
	if (hrServer != S_OK)
	{
		// Special treatment of enum termination for wldap32.dll
		//
		if (hrServer == ILS_E_PARAMETER)
		{
			MemFree (pEnum);
			pEnum = NULL; // enum termination
		}
		else
		{
			// Make sure we have at least LDAP_ENUM buffer to return
			//
			if (pEnum != NULL)
				ZeroMemory (pEnum, sizeof (*pEnum));
			else
				pEnum = (LDAP_ENUM *) MemAlloc (sizeof (LDAP_ENUM));

			// Set up the LDAP_ENUM info
			//
			if (pEnum != NULL)
			{
				pEnum->uSize = sizeof (*pEnum);
				pEnum->hResult = hrServer;
			}
		}

		// Force to delete this pending item
		//
		cEntries = 0;
	}

	// Post a message to the com layer of this enum result
	//
	PostMessage (g_hWndNotify, pInfo->uNotifyMsg, pInfo->uRespID, (LPARAM) pEnum);

	return (cEntries == 0);
}


BOOL
NotifyEnumClients (
	HRESULT				hrServer,
	SP_CResponse		*pItem )
{
	return NotifyEnumX (WM_ILS_ENUM_CLIENTS,
						hrServer,
						pItem,
						STR_CLIENT_CN);
}


BOOL
NotifyEnumClientInfos (
	HRESULT				hrServer,
	SP_CResponse		*pItem )
{
	return NotifyEnumX (WM_ILS_ENUM_CLIENTINFOS,
						hrServer,
						pItem,
						NULL);
}


BOOL NotifyEnumProts ( HRESULT hrServer, SP_CResponse *pItem )
{
	MyAssert (pItem != NULL);

	// Clean up locals
	//
	LDAP_ENUM *pEnum = NULL;
	TCHAR **apszProtNames = NULL;

	// Get the pending info
	//
	RESP_INFO *pInfo = pItem->GetRespInfo ();
	MyAssert (pInfo != NULL);

	// If error, simply report the error
	//
	if (hrServer != S_OK)
		goto MyExit;

	// Get the ldap result
	//
	LDAPMessage *pLdapMsg;
	pLdapMsg = pItem->GetResult ();
	MyAssert (pLdapMsg != NULL);
	if (pLdapMsg == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_POINTER;
		goto MyExit;
	}

	// Get ld
	//
	LDAP *ld;
	ld = pItem->GetLd ();
	if (ld == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_HANDLE;
		goto MyExit;
	}

	// Get the array
	//
	apszProtNames = my_ldap_get_values (ld, pLdapMsg, STR_PROT_NAME);
	if (apszProtNames == NULL)
	{
		hrServer = ILS_E_NO_SUCH_OBJECT;
		goto MyExit;
	}

	// Initialize minimal info size
	//
	ULONG cbEnumList;
	cbEnumList = sizeof (LDAP_ENUM) +	// the minimal info
				 sizeof (TCHAR);   		// the last null terminator

	// Let's see how many strings in the array
	//
	ULONG cNames;
	for (cNames = 0; apszProtNames[cNames] != NULL; cNames++)
	{
		cbEnumList += (lstrlen (apszProtNames[cNames]) + 1) * sizeof (TCHAR);
	}

	// Allocate the enum structure
	//
	pEnum = (LDAP_ENUM *) MemAlloc (cbEnumList);
	if (pEnum == NULL)
	{
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}

	// Fill in header
	//
	pEnum->uSize = sizeof (*pEnum);
	pEnum->hResult = hrServer;
	pEnum->cItems = cNames;
	pEnum->uOffsetItems = sizeof (*pEnum);

	// Fill in name strings
	//
	ULONG i;
	TCHAR *pszName;
	pszName = (TCHAR *) (pEnum + 1);
	for (i = 0; i < cNames; i++)
	{
		My_lstrcpy (pszName, apszProtNames[i]);
		pszName += lstrlen (pszName) + 1;
	}

	MyAssert (hrServer == S_OK);

MyExit:

	// Free the array if allocated
	//
	if (apszProtNames != NULL)
		ldap_value_free (apszProtNames);

	// Post messages back to the COM layer
	//
	if (hrServer != S_OK)
	{
		// Make sure we have at least LDAP_ENUM buffer to return
		//
		if (pEnum != NULL)
			ZeroMemory (pEnum, sizeof (*pEnum));
		else
			pEnum = (LDAP_ENUM *) MemAlloc (sizeof (LDAP_ENUM));

		// Set up the LDAP_ENUM info
		//
		if (pEnum != NULL)
		{
			pEnum->uSize = sizeof (*pEnum);
			pEnum->hResult = hrServer;
		}
	}

	// Post a message to the com layer of this enum result
	//
	PostMessage (g_hWndNotify, pInfo->uNotifyMsg, pInfo->uRespID, (LPARAM) pEnum);

	// Terminate enumeration if success
	//
	if (hrServer == S_OK)
	{
		PostMessage (g_hWndNotify, pInfo->uNotifyMsg, pInfo->uRespID, (LPARAM) NULL);
	}

	// Destroy this pending item
	//
	return TRUE;
}


#ifdef ENABLE_MEETING_PLACE
BOOL NotifyEnumMtgs ( HRESULT hrServer, SP_CResponse *pItem )
{
	return NotifyEnumX (WM_ILS_ENUM_MEETINGS,
						hrServer,
						pItem,
						STR_MTG_NAME);
}
#endif


#ifdef ENABLE_MEETING_PLACE
BOOL NotifyEnumMtgInfos ( HRESULT hrServer, SP_CResponse *pItem )
{
	return NotifyEnumX (WM_ILS_ENUM_MEETINGINFOS,
						hrServer,
						pItem,
						NULL);
}
#endif


#ifdef ENABLE_MEETING_PLACE
BOOL NotifyEnumAttendees ( HRESULT hrServer, SP_CResponse *pItem )
{
	MyAssert (pItem != NULL);

	// Get pending info
	//
	RESP_INFO *pInfo = pItem->GetRespInfo ();
	MyAssert (pInfo != NULL);

	// Initialize minimal info
	//
	LDAP_ENUM *pEnum = NULL;

	// If error, simply report the error
	//
	if (hrServer != S_OK)
		goto MyExit;

	// Get the ldap result
	//
	LDAPMessage *pLdapMsg;
	pLdapMsg = pItem->GetResult ();
	if (pLdapMsg == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_POINTER;
		goto MyExit;
	}

	// Get ld
	//
	LDAP *ld;
	ld = pItem->GetLd ();
	if (ld == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_HANDLE;
		goto MyExit;
	}

	// Initialize the total size of LDAP_ENUM
	//
	ULONG cbTotalSize;
	cbTotalSize =	sizeof (LDAP_ENUM) +	// the minimal info
					sizeof (TCHAR); 		// the last null terminator

	// Get the first entry that we care about
	//
	LDAPMessage *pEntry;
	pEntry = ldap_first_entry (ld, pLdapMsg);
	if (pEntry == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}

	// Get the Members attribute
	//
	ULONG cItems;
	cItems = 0;
	TCHAR **apszMembers;
	apszMembers = my_ldap_get_values (ld, pEntry, STR_MTG_MEMBERS);
	if (apszMembers != NULL)
	{
		// Find out how many attendees
		//
		for (TCHAR **ppsz = apszMembers; *ppsz != NULL; ppsz++)
		{
			cItems++;
			cbTotalSize += (lstrlen (*ppsz) + 1) * sizeof (TCHAR);
		}
	}

	// Allocate the returned LDAP_ENUM structure
	//
	pEnum = (LDAP_ENUM *) MemAlloc (cbTotalSize);
	if (pEnum == NULL)
	{
		// Fails probably due to insane cbTotalSize
		//
		MyAssert (FALSE);
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}

	// Fill in LDAP_ENUM common fields
	//
	pEnum->uSize = sizeof (*pEnum);
	pEnum->hResult = hrServer;
	pEnum->cItems = cItems;
	pEnum->uOffsetItems = sizeof (*pEnum);

	// Fill in LDAP_ENUM items
	//
	TCHAR *pszDst;
	ULONG i;
	pszDst = (TCHAR *) (pEnum + 1);
	for (i = 0; i < cItems; i++)
	{
		lstrcpy (pszDst, apszMembers[i]);
		pszDst += lstrlen (pszDst) + 1;
	}

	MyAssert (hrServer == S_OK);

MyExit:

	// Clean up if failure
	//
	if (hrServer != S_OK)
	{
		// Make sure we have at least LDAP_ENUM buffer to return
		//
		if (pEnum != NULL)
			ZeroMemory (pEnum, sizeof (*pEnum));
		else
			pEnum = (LDAP_ENUM *) MemAlloc (sizeof (LDAP_ENUM));

		// Fill in the minimal info
		//
		if (pEnum != NULL)
		{
			pEnum->uSize = sizeof (*pEnum);
			pEnum->hResult = hrServer;
		}
	}

	// Post a message to the com layer of this enum result
	//
	PostMessage (g_hWndNotify, pInfo->uNotifyMsg, pInfo->uRespID, (LPARAM) pEnum);

	// Delete this pending item
	//
	return TRUE;
}
#endif // ENABLE_MEETING_PLACE



VOID CacheEnumClientInfoAttr (
	CLIENT_INFO_ATTRS	*puia,
	TCHAR				*pszAttrName,
	TCHAR				**ppszAttrValue )
{
	ULONG i;

	// See if this attribute is arbitrary?
	//
	if (IlsIsAnyAttrName (pszAttrName) != NULL)
	{
		// Deal with extended attributes
		//
		for (i = 0; i < puia->Attrs.cMaxAttrs; i++)
		{
			if (My_lstrcmpi (pszAttrName, puia->Attrs.aPairs[i].pszName) == 0)
			{
				puia->Attrs.aPairs[i].pszValue = (TCHAR *) ppszAttrValue;
				break;
			}
		}
	}
	else
	{
		// Deal with standard attributes
		//
		for (i = 0; i < COUNT_ENUM_DIR_CLIENT_INFO; i++)
		{
			if (My_lstrcmpi (pszAttrName, c_apszClientStdAttrNames[i]) == 0)
			{
				puia->ClientInfo.apszStdAttrValues[i] = (TCHAR *) ppszAttrValue;
				break;
			}
		}
	}
}


#ifdef ENABLE_MEETING_PLACE
VOID CacheEnumMtgInfoAttr (
	MTG_INFO_ATTRS		*pmia,
	TCHAR				*pszAttrName,
	TCHAR				**ppszAttrValue )
{
	ULONG i;

	// See if this attribute is arbitrary?
	//
	if (IlsIsAnyAttrName (pszAttrName) != NULL)
	{
		// Deal with extended attributes
		//
		for (i = 0; i < pmia->Attrs.cMaxAttrs; i++)
		{
			if (My_lstrcmpi (pszAttrName, pmia->Attrs.aPairs[i].pszName) == 0)
			{
				pmia->Attrs.aPairs[i].pszValue = (TCHAR *) ppszAttrValue;
				break;
			}
		}
	}
	else
	{
		// Deal with standard attributes
		//
		for (i = 0; i < COUNT_ENUM_DIRMTGINFO; i++)
		{
			if (My_lstrcmpi (pszAttrName, c_apszMtgStdAttrNames[i]) == 0)
			{
				pmia->MtgInfo.apszStdAttrValues[i] = (TCHAR *) ppszAttrValue;
				break;
			}
		}
	}
}
#endif // ENABLE_MEETING_PLACE


HRESULT CacheEnumInfos (
	ULONG			uNotifyMsg,
	LDAP			*ld,
	LDAPMessage		*pEntry,
	VOID			*p )
{
	MyAssert (ld != NULL);
	MyAssert (pEntry != NULL);
	MyAssert (p != NULL);

	struct berelement *pContext = NULL;

	// Examine the first attribute
	//
	TCHAR *pszAttrName = ldap_first_attribute (ld, pEntry, &pContext);
	TCHAR **ppszAttrValue = ldap_get_values (ld, pEntry, pszAttrName);
	if (ppszAttrValue == NULL)
		return ILS_E_MEMORY;

	// Cache the first attribute
	//
	switch (uNotifyMsg)
	{
	case WM_ILS_ENUM_CLIENTINFOS:
		CacheEnumClientInfoAttr (	(CLIENT_INFO_ATTRS *) p,
									pszAttrName, ppszAttrValue);
		break;
#ifdef ENABLE_MEETING_PLACE
	case WM_ILS_ENUM_MEETINGINFOS:
		CacheEnumMtgInfoAttr (	(MTG_INFO_ATTRS *) p,
								pszAttrName, ppszAttrValue);
		break;
#endif
	default:
		MyAssert (FALSE);
		break;
	}

	// Step through the others
	//
	while ((pszAttrName = ldap_next_attribute (ld, pEntry, pContext))
			!= NULL)
	{
		// Examine the other attributes one by one
		//
		ppszAttrValue = ldap_get_values (ld, pEntry, pszAttrName);
		if (ppszAttrValue == NULL)
			return ILS_E_MEMORY;

		// Cache the other attributes one by one
		//
		switch (uNotifyMsg)
		{
		case WM_ILS_ENUM_CLIENTINFOS:
			CacheEnumClientInfoAttr (	(CLIENT_INFO_ATTRS *) p,
										pszAttrName, ppszAttrValue);
			break;
#ifdef ENABLE_MEETING_PLACE
		case WM_ILS_ENUM_MEETINGINFOS:
			CacheEnumMtgInfoAttr (	(MTG_INFO_ATTRS *) p,
									pszAttrName, ppszAttrValue);
			break;
#endif
		default:
			MyAssert (FALSE);
			break;
		}
	}

	return S_OK;
}


VOID
BuildEnumObjectNames (
	LDAP_ENUM			*pEnum,
	ENUM_LIST			*pEnumList )
{
	MyAssert (pEnum != NULL);
	MyAssert (pEnumList != NULL);

	ULONG cEntries = pEnum->cItems;

	// appszObjectNames are an array of names from server
	//
	TCHAR *pszName = (TCHAR *) (pEnum + 1);
	TCHAR ***appszObjectNames = (TCHAR ***) &(pEnumList->bData[0]);
	for (ULONG i = 0; i < cEntries; i++)
	{
		TCHAR **ppsz = appszObjectNames[i];
		if (ppsz != NULL && *ppsz != NULL)
		{
			My_lstrcpy (pszName, *ppsz);
			pszName += lstrlen (pszName) + 1;
		}
		else
		{
			*pszName++ = TEXT ('\0'); // empty strings
		}
	}
}


VOID
BuildEnumClientInfos (
	LDAP_ENUM			*pEnum,
	ENUM_LIST			*pEnumList )
{
	MyAssert (pEnum != NULL);
	MyAssert (pEnumList != NULL);

	ULONG i, j;

	ULONG cEntries = pEnumList->cItems;
	ULONG cbEntrySize = pEnumList->cbEntrySize;
	LDAP_CLIENTINFO *plci = (LDAP_CLIENTINFO *) (pEnum + 1);
	TCHAR *pszStringBuffer = (TCHAR *) (plci + cEntries);
	TCHAR **ppsz;

	CLIENT_INFO_ATTRS *p;
	ULONG cAttrs;

	// Loop through all entries
	//
	for (i = 0; i < cEntries; i++, plci++)
	{
		// Get to cached structure
		//
		p = (CLIENT_INFO_ATTRS *) (&(pEnumList->bData[0]) + i * cbEntrySize);

		// Set the size of LDAP_USERINFO
		//
		plci->uSize = sizeof (*plci);

		// Copy the User Name if needed
		//
		ppsz = (TCHAR **) p->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_CN];
		if (ppsz != NULL)
		{
			plci->uOffsetCN = (ULONG)((ULONG_PTR) pszStringBuffer - (ULONG_PTR) plci);
			My_lstrcpy (pszStringBuffer, *ppsz);
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;
		}

		// Copy the First Name if needed
		//
		ppsz = (TCHAR **) p->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_FIRST_NAME];
		if (ppsz != NULL)
		{
			plci->uOffsetFirstName = (ULONG)((ULONG_PTR) pszStringBuffer - (ULONG_PTR) plci);
			My_lstrcpy (pszStringBuffer, *ppsz);
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;
		}

		// Copy the Last Name if needed
		//
		ppsz = (TCHAR **) p->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_LAST_NAME];
		if (ppsz != NULL)
		{
			plci->uOffsetLastName = (ULONG)((ULONG_PTR) pszStringBuffer - (ULONG_PTR) plci);
			My_lstrcpy (pszStringBuffer, *ppsz);
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;
		}

		// Copy the Email Name if needed
		//
		ppsz = (TCHAR **) p->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_EMAIL_NAME];
		if (ppsz != NULL)
		{
			plci->uOffsetEMailName = (ULONG)((ULONG_PTR) pszStringBuffer - (ULONG_PTR) plci);
			My_lstrcpy (pszStringBuffer, *ppsz);
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;
		}

		// Copy the City Name if needed
		//
		ppsz = (TCHAR **) p->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_CITY_NAME];
		if (ppsz != NULL)
		{
			plci->uOffsetCityName = (ULONG)((ULONG_PTR) pszStringBuffer - (ULONG_PTR) plci);
			My_lstrcpy (pszStringBuffer, *ppsz);
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;
		}

		// Copy the Country Name if needed
		//
		ppsz = (TCHAR **) p->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_C];
		if (ppsz != NULL)
		{
			plci->uOffsetCountryName = (ULONG)((ULONG_PTR) pszStringBuffer - (ULONG_PTR) plci);
			My_lstrcpy (pszStringBuffer, *ppsz);
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;
		}

		// Copy the Comment Name if needed
		//
		ppsz = (TCHAR **) p->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_COMMENT];
		if (ppsz != NULL)
		{
			plci->uOffsetComment = (ULONG)((ULONG_PTR) pszStringBuffer - (ULONG_PTR) plci);
			My_lstrcpy (pszStringBuffer, *ppsz);
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;
		}

		// Copy the IP Address if needed
		//
		ppsz = (TCHAR **) p->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_IP_ADDRESS];
		if (ppsz != NULL)
		{
			plci->uOffsetIPAddress = (ULONG)((ULONG_PTR) pszStringBuffer - (ULONG_PTR) plci);
			GetIPAddressString (pszStringBuffer, GetStringLong (*ppsz));
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;
		}

		// Copy the Flags if needed
		//
		ppsz = (TCHAR **) p->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_FLAGS];
		if (ppsz != NULL)
		{
			plci->dwFlags = (*ppsz != NULL) ?	GetStringLong (*ppsz) :
												INVALID_USER_FLAGS;
		}

		// Copy extended attributes if needed
		//
		plci->cAttrsReturned = cAttrs = p->Attrs.cMaxAttrs;
		plci->uOffsetAttrsReturned = (ULONG)((ULONG_PTR) pszStringBuffer - (ULONG_PTR) plci);
		for (j = 0; j < cAttrs; j++)
		{
			// Extended attribute name
			//
			My_lstrcpy (pszStringBuffer, IlsSkipAnyAttrNamePrefix (
							(const TCHAR *)	p->Attrs.aPairs[j].pszName));
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;

			// Extended attribute value
			//
			ppsz = (TCHAR **) p->Attrs.aPairs[j].pszValue;
			if (ppsz != NULL)
			{
				My_lstrcpy (pszStringBuffer, *ppsz);
			}
			else
			{
				ASSERT(FALSE);
			}
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;
		} // for j
	} // for i
}


#ifdef ENABLE_MEETING_PLACE
VOID BuildEnumMtgInfos (
	LDAP_ENUM			*pEnum,
	ENUM_LIST			*pEnumList )
{
	MyAssert (pEnum != NULL);
	MyAssert (pEnumList != NULL);

	ULONG i, j;

	ULONG cEntries = pEnumList->cItems;
	ULONG cbEntrySize = pEnumList->cbEntrySize;
	LDAP_MEETINFO *plmi = (LDAP_MEETINFO *) (pEnum + 1);
	TCHAR *pszStringBuffer = (TCHAR *) (plmi + cEntries);
	TCHAR **ppsz;

	MTG_INFO_ATTRS *p;
	ULONG cAttrs;

	// Loop through all entries
	//
	for (i = 0; i < cEntries; i++, plmi++)
	{
		// Get to the cache structure
		//
		p = (MTG_INFO_ATTRS *) (&(pEnumList->bData[0]) + i * cbEntrySize);

		// Set the size of LDAP_MEETINFO
		//
		plmi->uSize = sizeof (*plmi);

		// Copy the Meeting Name if needed
		//
		ppsz = (TCHAR **) p->MtgInfo.apszStdAttrValues[ENUM_MTGATTR_CN];
		if (ppsz != NULL)
		{
			plmi->uOffsetMeetingPlaceID = (ULONG) pszStringBuffer - (ULONG) plmi;
			My_lstrcpy (pszStringBuffer, *ppsz);
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;
		}

		// Copy the Meeting Type if needed
		//
		ppsz = (TCHAR **) p->MtgInfo.apszStdAttrValues[ENUM_MTGATTR_MTG_TYPE];
		if (ppsz != NULL)
		{
			plmi->lMeetingPlaceType = (*ppsz != NULL) ?	GetStringLong (*ppsz) :
													INVALID_MEETING_TYPE;
		}

		// Copy the Attendee Type if needed
		//
		ppsz = (TCHAR **) p->MtgInfo.apszStdAttrValues[ENUM_MTGATTR_MEMBER_TYPE];
		if (ppsz != NULL)
		{
			plmi->lAttendeeType = (*ppsz != NULL) ?	GetStringLong (*ppsz) :
													INVALID_ATTENDEE_TYPE;
		}

		// Copy the Description if needed
		//
		ppsz = (TCHAR **) p->MtgInfo.apszStdAttrValues[ENUM_MTGATTR_DESCRIPTION];
		if (ppsz != NULL)
		{
			plmi->uOffsetDescription = (ULONG) pszStringBuffer - (ULONG) plmi;
			My_lstrcpy (pszStringBuffer, *ppsz);
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;
		}

		// Copy the Host Name if needed
		//
		ppsz = (TCHAR **) p->MtgInfo.apszStdAttrValues[ENUM_MTGATTR_HOST_NAME];
		if (ppsz != NULL)
		{
			plmi->uOffsetHostName = (ULONG) pszStringBuffer - (ULONG) plmi;
			My_lstrcpy (pszStringBuffer, *ppsz);
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;
		}

		// Copy the Host IP Address if needed
		//
		ppsz = (TCHAR **) p->MtgInfo.apszStdAttrValues[ENUM_MTGATTR_IP_ADDRESS];
		if (ppsz != NULL)
		{
			plmi->uOffsetHostIPAddress = (ULONG) pszStringBuffer - (ULONG) plmi;
			GetIPAddressString (pszStringBuffer, GetStringLong (*ppsz));
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;
		}

		// Copy extended attributes if needed
		//
		plmi->cAttrsReturned = cAttrs = p->Attrs.cMaxAttrs;
		plmi->uOffsetAttrsReturned = (ULONG) pszStringBuffer - (ULONG) plmi;
		for (j = 0; j < cAttrs; j++)
		{
			// Extended attribute name
			//
			My_lstrcpy (pszStringBuffer, IlsSkipAnyAttrNamePrefix (
							(const TCHAR *) p->Attrs.aPairs[j].pszName));
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;

			// Extended attribute value
			//
			ppsz = (TCHAR **) p->Attrs.aPairs[j].pszValue;
			My_lstrcpy (pszStringBuffer, *ppsz);
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;
		} // for j
	} // for i
}
#endif // ENABLE_MEETING_PLACE


VOID TotalSizeEnumObjectNames (
	ULONG			*pcbTotalSize,
	ULONG			cEntries,
	TCHAR			**appszObjectNames[] )
{
	ULONG i, cbThisSize;
	TCHAR **ppsz;

	// Loop through all the entries and compute the total size
	//
	for (i = 0; i < cEntries; i++)
	{
		ppsz = appszObjectNames[i];

		// Calcualte the attribute string length
		//
		cbThisSize = 1;
		if (ppsz != NULL && *ppsz != NULL)
			cbThisSize += My_lstrlen (*ppsz);

		// Convert string length to string size
		//
		cbThisSize *= sizeof (TCHAR);

		// Add up this entry size
		//
		// lonchanc: BUGS BUGS the size is wrong. need to figure out the exact size
		*pcbTotalSize += sizeof (LDAP_CLIENTINFO) + cbThisSize;
	}
}


VOID SizeEnumClientInfos (
	ULONG				*pcbTotalSize,
	CLIENT_INFO_ATTRS	*pcia )
{
	ULONG i, cbThisSize;
	TCHAR **ppsz;

	// Add up user info header
	//
	*pcbTotalSize += sizeof (LDAP_CLIENTINFO);

	// Add up the total size for standard attributes
	//
	for (i = 0; i < COUNT_ENUM_DIR_CLIENT_INFO; i++)
	{
		// Get the attribute value
		//
		ppsz = (TCHAR **) pcia->ClientInfo.apszStdAttrValues[i];

		// Calcualte the attribute string length
		//
		cbThisSize = 1;
		if (ppsz != NULL && *ppsz != NULL)
			cbThisSize += My_lstrlen (*ppsz);

		// Compensate the string length if it is ip address
		//
		if (i == ENUM_CLIENTATTR_IP_ADDRESS)
			cbThisSize += 16;

		// Convert string length to string size
		//
		cbThisSize *= sizeof (TCHAR);

		// Add up this entry size
		//
		*pcbTotalSize += cbThisSize;
	}

	// Add up the total size for extended attributes
	//
	for (i = 0; i < pcia->Attrs.cMaxAttrs; i++)
	{
		// Get the extended attribute value
		//
		ppsz = (TCHAR **) pcia->Attrs.aPairs[i].pszValue;

		// Calcualte the attribute string length
		//
		cbThisSize = 1;
		if (ppsz != NULL && *ppsz != NULL)
			cbThisSize += My_lstrlen (*ppsz);

		// Get the extended attribute name
		//
		cbThisSize += lstrlen (IlsSkipAnyAttrNamePrefix ((const TCHAR *)
									pcia->Attrs.aPairs[i].pszName)) + 1;

		// Convert string length to string size
		//
		cbThisSize *= sizeof (TCHAR);

		// Add up this entry size
		//
		*pcbTotalSize += cbThisSize;
	}
}


#ifdef ENABLE_MEETING_PLACE
VOID SizeEnumMtgInfos (
	ULONG			*pcbTotalSize,
	MTG_INFO_ATTRS	*pmia )
{
	ULONG i, cbThisSize;
	TCHAR **ppsz;

	// Add up meeting info header
	//
	*pcbTotalSize += sizeof (LDAP_MEETINFO);

	// Add up the total size for standard attributes
	//
	for (i = 0; i < COUNT_ENUM_DIRMTGINFO; i++)
	{
		// Get the standard attribute value
		//
		ppsz = (TCHAR **) pmia->MtgInfo.apszStdAttrValues[i];

		// Calcualte the attribute string length
		//
		cbThisSize = 1;
		if (ppsz != NULL && *ppsz != NULL)
			cbThisSize += My_lstrlen (*ppsz);

		// Compensate the string length if it is ip address
		//
		if (i == ENUM_MTGATTR_IP_ADDRESS)
			cbThisSize += 16;

		// Convert string length to string size
		//
		cbThisSize *= sizeof (TCHAR);

		// Add up this entry size
		//
		*pcbTotalSize += cbThisSize;
	}

	// Add up the total size for extended attributes
	//
	for (i = 0; i < pmia->Attrs.cMaxAttrs; i++)
	{
		// Get the extended attribute value
		//
		ppsz = (TCHAR **) pmia->Attrs.aPairs[i].pszValue;

		// Calcualte the attribute string length
		//
		cbThisSize = 1;
		if (ppsz != NULL && *ppsz != NULL)
			cbThisSize += My_lstrlen (*ppsz);

		// Get the extended attribute name
		//
		cbThisSize += lstrlen (IlsSkipAnyAttrNamePrefix ((const TCHAR *)
									pmia->Attrs.aPairs[i].pszName)) + 1;

		// Convert string length to string size
		//
		cbThisSize *= sizeof (TCHAR);

		// Add up this entry size
		//
		*pcbTotalSize += cbThisSize;
	}
}
#endif // ENABLE_MEETING_PLACE


/* =========== RESOLVE ============ */

typedef HRESULT (INFO_HANDLER) ( VOID *, const TCHAR *, const TCHAR ** );
extern HRESULT CacheResolveClientInfoAttr ( VOID *, const TCHAR *, const TCHAR ** );
extern HRESULT CacheResolveProtInfoAttr ( VOID *, const TCHAR *, const TCHAR ** );
extern HRESULT CacheResolveMtgInfoAttr ( VOID *, const TCHAR *, const TCHAR ** );


HRESULT
NotifyResolveX (
	HRESULT			hrServer,
	SP_CResponse	*pItem,
	VOID			*pInfo,
	INFO_HANDLER	*pHandler )
{
	MyAssert (pItem != NULL);
	MyAssert (pInfo != NULL);
	MyAssert (pHandler != NULL);

	// Get the ldap result
	//
	LDAPMessage *pLdapMsg = pItem->GetResult ();
	MyAssert (pLdapMsg != NULL);
	if (pLdapMsg == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_POINTER;
		goto MyExit;
	}

	// Get ld
	//
	LDAP *ld;
	ld = pItem->GetLd ();
	if (ld == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_HANDLE;
		goto MyExit;
	}

	// Get the first entry that we care only
	//
	LDAPMessage *pEntry;
	pEntry = ldap_first_entry (ld, pLdapMsg);
	if (pEntry == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}

	// Initialize wldap32.dll context
	//
	struct berelement *pContext;
	pContext = NULL;

	// Examine the first attribute
	//
	TCHAR *pszAttrName;
	pszAttrName = ldap_first_attribute (ld, pEntry, &pContext);
	if (pszAttrName == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}
	TCHAR **ppszAttrVal;
	ppszAttrVal = ldap_get_values (ld, pEntry, pszAttrName);
	if (ppszAttrVal == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}

	// Cache this attribute name (if needed) and value
	//
	HRESULT hr;
	hr = (*pHandler) (pInfo, pszAttrName,(const TCHAR **) ppszAttrVal);
	ldap_value_free (ppszAttrVal);
	if (hr != S_OK)
	{
		hrServer = hr;
		goto MyExit;
	}

	// Step through the other attributes
	//
	while ((pszAttrName = ldap_next_attribute (ld, pEntry, pContext))
			!= NULL)
	{
		ppszAttrVal = ldap_get_values (ld, pEntry, pszAttrName);
		if (ppszAttrVal == NULL)
		{
			MyAssert (FALSE);
			hrServer = ILS_E_MEMORY;
			goto MyExit;
		}

		// Cache the other attribute names (if needed) and values
		//
		hr = (*pHandler) (pInfo, pszAttrName, (const TCHAR **) ppszAttrVal);
		ldap_value_free (ppszAttrVal);
		if (hr != S_OK)
		{
			hrServer = hr;
			goto MyExit;
		}
	}

	MyAssert (hrServer == S_OK);

MyExit:

	return hrServer;
}


BOOL
NotifyResolveClient (
	HRESULT			hrServer,
	SP_CResponse	*pItem )
{
	MyAssert (pItem != NULL);
	ULONG i;

	// Get the pending info
	//
	RESP_INFO *pInfo = pItem->GetRespInfo ();
	MyAssert (pInfo != NULL);

	// Initialize minimal info
	//
	LDAP_CLIENTINFO_RES *pClientRes = NULL;
	CLIENT_INFO_ATTRS *pcia = NULL;

	// If error, simply report the error
	//
	if (hrServer != S_OK)
		goto MyExit;

	// Get the ldap result
	//
	LDAPMessage *pLdapMsg;
	pLdapMsg = pItem->GetResult ();
	if (pLdapMsg == NULL)
	{
		MyAssert (FALSE);
		goto MyExit;
	}

	// Get ld
	//
	LDAP *ld;
	ld = pItem->GetLd ();
	if (ld == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_HANDLE;
		goto MyExit;
	}

	// Get the count of attributes
	//
	ULONG cAttrs;
	cAttrs = my_ldap_count_1st_entry_attributes (ld, pLdapMsg);
	if (cAttrs == 0)
	{
		hrServer = ILS_E_NO_MORE;
		goto MyExit;
	}

	// Allocate result set holder
	//
	pcia = (CLIENT_INFO_ATTRS *) MemAlloc (
								sizeof (CLIENT_INFO_ATTRS) +
								cAttrs * sizeof (ATTR_PAIR));
	if (pcia == NULL)
	{
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}

	// Initialize result set holder
	//
	pcia->Attrs.cMaxAttrs = cAttrs;

	// Cache resolve set
	//
	hrServer = NotifyResolveX (	hrServer,
								pItem,
								pcia,
								CacheResolveClientInfoAttr);
	if (hrServer != S_OK)
	{
		goto MyExit;
	}

	// Initialize the total size
	//
	ULONG cbTotalSize, cbThisSize;
	cbTotalSize = sizeof (LDAP_CLIENTINFO_RES);

	// Loop through all attributes in order to compute the total size
	//
	for (i = 0; i < COUNT_ENUM_RES_CLIENT_INFO; i++)
	{
		if (pcia->ClientInfo.apszStdAttrValues[i] != NULL)
		{
			// Get the string length
			//
			cbThisSize = My_lstrlen (pcia->ClientInfo.apszStdAttrValues[i]) + 1;

			// Compensate for the ip address
			//
			if (i == ENUM_CLIENTATTR_IP_ADDRESS)
				cbThisSize += 16;

			// Convert string length to string size
			//
			cbThisSize *= sizeof (TCHAR);

			// Add up to the total size
			//
			cbTotalSize += cbThisSize;
		}
	}

	// Loop through extended attributes
	//
	for (i = 0; i < pcia->Attrs.cCurrAttrs; i++)
	{
		cbThisSize = My_lstrlen (pcia->Attrs.aPairs[i].pszName) + 1;
		cbThisSize += My_lstrlen (pcia->Attrs.aPairs[i].pszValue) + 1;
		cbThisSize *= sizeof (TCHAR);
		cbTotalSize += cbThisSize;
	}

	// Allocate LDAP_USERINFO_RES structure
	//
	pClientRes = (LDAP_CLIENTINFO_RES *) MemAlloc (cbTotalSize);
	if (pClientRes == NULL)
	{
		MyAssert (FALSE); // we are in deep trouble here
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}

	// Fill in common fields
	//
	pClientRes->uSize = sizeof (*pClientRes);
	pClientRes->hResult = hrServer;
	pClientRes->lci.uSize = sizeof (pClientRes->lci);

	// Prepare to copy strings
	//
	TCHAR *pszDst, *pszSrc;
	pszDst = (TCHAR *) (pClientRes + 1);

	// Copy user object's standard attributes
	//
	pszSrc = pcia->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_CN];
	if (pszSrc != NULL)
	{
		pClientRes->lci.uOffsetCN = (ULONG)((ULONG_PTR) pszDst - (ULONG_PTR) &(pClientRes->lci));
		My_lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
	}

	pszSrc = pcia->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_FIRST_NAME];
	if (pszSrc != NULL)
	{
		pClientRes->lci.uOffsetFirstName = (ULONG)((ULONG_PTR) pszDst - (ULONG_PTR) &(pClientRes->lci));
		My_lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
	}

	pszSrc = pcia->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_LAST_NAME];
	if (pszSrc != NULL)
	{
		pClientRes->lci.uOffsetLastName = (ULONG)((ULONG_PTR) pszDst - (ULONG_PTR) &(pClientRes->lci));
		My_lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
	}

	pszSrc = pcia->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_EMAIL_NAME];
	if (pszSrc != NULL)
	{
		pClientRes->lci.uOffsetEMailName = (ULONG)((ULONG_PTR) pszDst - (ULONG_PTR) &(pClientRes->lci));
		My_lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
	}

	pszSrc = pcia->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_CITY_NAME];
	if (pszSrc != NULL)
	{
		pClientRes->lci.uOffsetCityName = (ULONG)((ULONG_PTR) pszDst - (ULONG_PTR) &(pClientRes->lci));
		My_lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
	}

	pszSrc = pcia->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_C];
	if (pszSrc != NULL)
	{
		pClientRes->lci.uOffsetCountryName = (ULONG)((ULONG_PTR) pszDst - (ULONG_PTR) &(pClientRes->lci));
		My_lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
	}

	pszSrc = pcia->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_COMMENT];
	if (pszSrc != NULL)
	{
		pClientRes->lci.uOffsetComment = (ULONG)((ULONG_PTR) pszDst - (ULONG_PTR) &(pClientRes->lci));
		My_lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
	}

	pszSrc = pcia->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_IP_ADDRESS];
	if (pszSrc != NULL)
	{
		pClientRes->lci.uOffsetIPAddress = (ULONG)((ULONG_PTR) pszDst - (ULONG_PTR) &(pClientRes->lci));
		GetIPAddressString (pszDst, GetStringLong (pszSrc));
		pszDst += lstrlen (pszDst) + 1;
	}

	pszSrc = pcia->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_FLAGS];
	if (pszSrc != NULL)
	{
		pClientRes->lci.dwFlags = (pszSrc != NULL)?	GetStringLong (pszSrc) :
													INVALID_USER_FLAGS;
	}

	// Copy app object's standard attributes
	//
	pszSrc = pcia->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_APP_NAME];
	if (pszSrc != NULL)
	{
		pClientRes->lci.uOffsetAppName = (ULONG)((ULONG_PTR) pszDst - (ULONG_PTR) &(pClientRes->lci));
		My_lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
	}

	pszSrc = pcia->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_APP_MIME_TYPE];
	if (pszSrc != NULL)
	{
		pClientRes->lci.uOffsetAppMimeType = (ULONG)((ULONG_PTR) pszDst - (ULONG_PTR) &(pClientRes->lci));
		My_lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
	}

	pszSrc = pcia->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_APP_GUID];
	if (MyIsGoodString (pszSrc))
	{
		GetStringGuid (pszSrc, &(pClientRes->lci.AppGuid));
	}
	else
	{
		ZeroMemory (&(pClientRes->lci.AppGuid), sizeof (pClientRes->lci.AppGuid));
	}

	// Copy app object's extended attributes
	//
	pClientRes->lci.cAttrsReturned = pcia->Attrs.cCurrAttrs;
	if (pClientRes->lci.cAttrsReturned > 0)
	{
		pClientRes->lci.uOffsetAttrsReturned = (ULONG)((ULONG_PTR) pszDst - (ULONG_PTR) &(pClientRes->lci));
		for (i = 0; i < pcia->Attrs.cCurrAttrs; i++)
		{
			My_lstrcpy (pszDst, pcia->Attrs.aPairs[i].pszName);
			pszDst += lstrlen (pszDst) + 1;
			My_lstrcpy (pszDst, pcia->Attrs.aPairs[i].pszValue);
			pszDst += lstrlen (pszDst) + 1;
		}
	}

	MyAssert (hrServer == S_OK);

MyExit:

	// Free temporary result set holder
	//
	if (pcia != NULL)
	{
		// Free standard attributes
		//
		for (INT k = 0;k < COUNT_ENUM_CLIENT_INFO; k++)
		{
			MemFree (pcia->ClientInfo.apszStdAttrValues[k]);
		}

		// Free arbitrary attributes
		//
		for (ULONG j = 0; j < pcia->Attrs.cCurrAttrs; j++)
		{
			MemFree (pcia->Attrs.aPairs[j].pszName);
			MemFree (pcia->Attrs.aPairs[j].pszValue);
		}

		// Free the holder itself
		//
		MemFree (pcia);
	}

	// Clean up the return structure if failure
	//
	if (hrServer != S_OK)
	{
		// Make sure we have a return structure
		//
		if (pClientRes != NULL)
			ZeroMemory (pClientRes, sizeof (*pClientRes));
		else
			pClientRes = (LDAP_CLIENTINFO_RES *) MemAlloc (sizeof (LDAP_CLIENTINFO_RES));

		// Fill in the minimal info
		//
		if (pClientRes != NULL)
		{
			pClientRes->uSize = sizeof (*pClientRes);
			pClientRes->hResult = hrServer;
		}
	}

	// Post a message to the com layer
	//
	PostMessage (g_hWndNotify, pInfo->uNotifyMsg, pInfo->uRespID, (LPARAM) pClientRes);

	// Delete this pending item
	//
	return TRUE;
}


HRESULT CacheResolveClientInfoAttr (
	VOID			*pInfo,
	const TCHAR		*pszAttrName,
	const TCHAR		**ppszAttrVal )
{
	MyAssert (pInfo != NULL);
	MyAssert (pszAttrName != NULL);

	// Shorthand meeting info pointer
	//
	CLIENT_INFO_ATTRS *pcia = (CLIENT_INFO_ATTRS *) pInfo;

	// See if this attribute is arbitrary?
	//
	const TCHAR *pszRealAnyName = IlsIsAnyAttrName (pszAttrName);
	if (pszRealAnyName != NULL)
	{
		MyAssert (pcia->Attrs.cCurrAttrs < pcia->Attrs.cMaxAttrs);

		// Duplicate the name
		//
		pcia->Attrs.aPairs[pcia->Attrs.cCurrAttrs].pszName =
			My_strdup (pszRealAnyName);

		// Duplicate the value
		// BUGS: we should avoid duplicate the string here (cf. enum-user-infos)
		//
		if (ppszAttrVal != NULL)
		{
			pcia->Attrs.aPairs[pcia->Attrs.cCurrAttrs++].pszValue =
				My_strdup (*ppszAttrVal);
		}
		else
		{
			// ILS server bug or wldap32.dll bug
			//
			MyAssert (FALSE);
		}
	}
	else
	{
		// Loop through all standard attributes
		//
		for (INT i = 0; i < COUNT_ENUM_RES_CLIENT_INFO; i++)
		{
			// Figure out what attribute it is
			//
			if (My_lstrcmpi (c_apszClientStdAttrNames[i], pszAttrName) == 0)
			{
				// Free the previously allocated value if any
				//
				MemFree (pcia->ClientInfo.apszStdAttrValues[i]);

				// Duplicate the value
				// BUGS: we should avoid duplicate the string here (cf. enum-user-infos)
				//
				if (ppszAttrVal != NULL)
				{
					pcia->ClientInfo.apszStdAttrValues[i] = DuplicateGoodString (*ppszAttrVal);
				}
				else
				{
					// ILS server bug or wldap32.dll bug
					//
					MyAssert (FALSE);
				}
				break;
			}
		}
	}

	return S_OK;
}


typedef struct
{
	PROT_INFO	ProtInfo;
	TCHAR		*pszProtNameToResolve;
	BOOL		fFindIndex;
	LONG		nIndex;
}
	PROT_INFO_EX;

enum { INVALID_INDEX = -1 };

BOOL NotifyResolveProt ( HRESULT hrServer, SP_CResponse *pItem )
{
	MyAssert (pItem != NULL);

	// Get the pending info
	//
	RESP_INFO *pInfo = pItem->GetRespInfo ();
	MyAssert (pInfo != NULL);

	// Initialize minimal info
	//
	LDAP_PROTINFO_RES *pProtRes = NULL;
	PROT_INFO_EX *ppi = NULL;

	// If error, simply report the error
	//
	if (hrServer != S_OK)
		goto MyExit;

	// Allocate result holder
	//
	ppi = (PROT_INFO_EX *) MemAlloc (sizeof (PROT_INFO_EX));
	if (ppi == NULL)
	{
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}

	// Cache the protocol name to resolve
	//
	MyAssert (pInfo->pszProtNameToResolve != NULL);
	ppi->pszProtNameToResolve = pInfo->pszProtNameToResolve;
	ppi->nIndex = INVALID_INDEX;

	// Call the common routine to find the index
	//
	ppi->fFindIndex = TRUE;
	hrServer = NotifyResolveX (hrServer, pItem, ppi, CacheResolveProtInfoAttr);
	if (hrServer != S_OK)
		goto MyExit;

	// Check to see if we found the index
	//
	if (ppi->nIndex == INVALID_INDEX)
	{
		hrServer = ILS_E_NO_SUCH_OBJECT;
		goto MyExit;
	}

	// Call the common routine AGAIN to save attribute values
	//
	ppi->fFindIndex = FALSE;
	hrServer = NotifyResolveX (hrServer, pItem, ppi, CacheResolveProtInfoAttr);
	if (hrServer != S_OK)
		goto MyExit;

	// Initialize the size
	//
	ULONG cbTotalSize, cbThisSize;
	cbTotalSize = sizeof (LDAP_PROTINFO_RES);

	// Loop through standard attrs
	//
	ULONG i;
	for (i = 0; i < COUNT_ENUM_PROTATTR; i++)
	{
		if (ppi->ProtInfo.apszStdAttrValues[i] != NULL)
		{
			cbThisSize = My_lstrlen (ppi->ProtInfo.apszStdAttrValues[i]) + 1;
			cbThisSize *= sizeof (TCHAR);
			cbTotalSize += cbThisSize;
		}
	}

	// Allocate LDAP_PROTINFO_RES structure
	//
	pProtRes = (LDAP_PROTINFO_RES *) MemAlloc (cbTotalSize);
	if (pProtRes == NULL)
	{
		MyAssert (FALSE); // we are in deep trouble here
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}

	// Fill in fields
	//
	pProtRes->uSize = sizeof (*pProtRes);
	pProtRes->hResult = hrServer;
	pProtRes->lpi.uSize = sizeof (pProtRes->lpi);
	TCHAR *pszSrc, *pszDst;
	pszDst = (TCHAR *) (pProtRes + 1);

	// Copy protocol name
	//
	pszSrc = ppi->ProtInfo.apszStdAttrValues[ENUM_PROTATTR_NAME];
	if (pszSrc != NULL)
	{
		pProtRes->lpi.uOffsetName = (ULONG)((ULONG_PTR) pszDst - (ULONG_PTR) &(pProtRes->lpi));
		My_lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
	}

	// Copy protocol mime type
	//
	pszSrc = ppi->ProtInfo.apszStdAttrValues[ENUM_PROTATTR_MIME_TYPE];
	if (pszSrc != NULL)
	{
		pProtRes->lpi.uOffsetMimeType = (ULONG)((ULONG_PTR) pszDst - (ULONG_PTR) &(pProtRes->lpi));
		My_lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
	}

	// Copy protocol prot number
	//
	pszSrc = ppi->ProtInfo.apszStdAttrValues[ENUM_PROTATTR_PORT_NUMBER];
	if (pszSrc != NULL)
	{
		pProtRes->lpi.uPortNumber = GetStringLong (pszSrc);
	}

	MyAssert (hrServer == S_OK);

MyExit:

	// Free temporary app result holder
	//
	if (ppi != NULL)
	{
		for (INT k = 0; k < COUNT_ENUM_PROTATTR; k++)
		{
			MemFree (ppi->ProtInfo.apszStdAttrValues[k]);
		}
		MemFree (ppi);
	}

	// Clean up the return structure if failure
	//
	if (hrServer != S_OK)
	{
		// Make sure we have a valid returned structure
		//
		if (pProtRes != NULL)
			ZeroMemory (pProtRes, sizeof (*pProtRes));
		else
			pProtRes = (LDAP_PROTINFO_RES *) MemAlloc (sizeof (LDAP_PROTINFO_RES));

		// Fill in the minimal info
		//
		if (pProtRes != NULL)
		{
			pProtRes->uSize = sizeof (*pProtRes);
			pProtRes->hResult = hrServer;
		}
	}

	// Post the result to the com layer
	//
	PostMessage (g_hWndNotify, pInfo->uNotifyMsg, pInfo->uRespID, (LPARAM) pProtRes);

	// Destroy this pending item
	//
	return TRUE;
}


HRESULT CacheResolveProtInfoAttr (
	VOID			*pInfo,
	const TCHAR		*pszAttrName,
	const TCHAR		**ppszAttrVal )
{
	MyAssert (pInfo != NULL);
	MyAssert (pszAttrName != NULL);

	// Shorthand prot info pointer
	//
	PROT_INFO_EX *ppi = (PROT_INFO_EX *) pInfo;

	// Are we trying to find the index of the protocol to resolve?
	//
	if (ppi->fFindIndex)
	{
		// If we already located the index, then simply return
		//
		if (ppi->nIndex == INVALID_INDEX)
		{
			// Looking for "sprotid"
			//
			if (My_lstrcmpi (STR_PROT_NAME, pszAttrName) == 0)
			{
				// Get to the protocol name attribute
				//
				if (ppszAttrVal != NULL)
				{
					TCHAR *pszVal;
					for (LONG nIndex = 0;
								(pszVal = (TCHAR *) ppszAttrVal[nIndex]) != NULL;
								nIndex++)
					{
						if (My_lstrcmpi (ppi->pszProtNameToResolve, pszVal) == 0)
						{
							// Locate the same protocol name, remember the index
							//
							ppi->nIndex = nIndex;
							break;
							// return S_OK; // we should be able to return from here
						}
					}
				}
				else
				{
					// ILS server bug or wldap32.dll bug
					//
					MyAssert (FALSE);
				}
			}
		}
	}
	else
	{
		// Loop through all standard attributes
		//
		for (INT i = 0; i < COUNT_ENUM_PROTATTR; i++)
		{
			// Figure out what attribute it is
			//
			if (My_lstrcmpi (c_apszProtStdAttrNames[i], pszAttrName) == 0)
			{
				// Free the previously allocated value if any
				//
				MemFree (ppi->ProtInfo.apszStdAttrValues[i]);

				// Duplicate the value
				// BUGS: we should avoid duplicate the string here (cf. enum-user-infos)
				//
				if (ppszAttrVal != NULL)
				{
					// Make sure that we do not fault when the ILS server or wldap32.dll has a bug
					//
					for (LONG nIndex = 0; nIndex <= ppi->nIndex; nIndex++)
					{
						if (ppszAttrVal[nIndex] == NULL)
						{
							// ILS server bug
							//
							MyAssert (FALSE);
							return S_OK;
						}
					}

					// Duplicate the attribute value
					//
					ppi->ProtInfo.apszStdAttrValues[i] = My_strdup (ppszAttrVal[ppi->nIndex]);
				}
				else
				{
					// ILS server bug or wldap32.dll bug
					//
					MyAssert (FALSE);
				}
				break;
			}
		}
	}

	return S_OK;
}


#ifdef ENABLE_MEETING_PLACE
BOOL NotifyResolveMtg ( HRESULT hrServer, SP_CResponse *pItem )
{
	MyAssert (pItem != NULL);

	// Get pending info
	//
	RESP_INFO *pInfo = pItem->GetRespInfo ();
	MyAssert (pInfo != NULL);

	// Initialize minimal return info
	//
	LDAP_MEETINFO_RES *pMtgRes = NULL;
	MTG_INFO_ATTRS *pmia = NULL;

	// If error, simply report the error
	//
	if (hrServer != S_OK)
		goto MyExit;

	// Get the ldap result
	//
	LDAPMessage *pLdapMsg;
	pLdapMsg = pItem->GetResult ();
	if (pLdapMsg == NULL)
	{
		MyAssert (FALSE);
		goto MyExit;
	}

	// Get ld
	//
	LDAP *ld;
	ld = pItem->GetLd ();
	if (ld == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_HANDLE;
		goto MyExit;
	}

	// Get the count of attributes
	//
	ULONG cAttrs;
	cAttrs = my_ldap_count_1st_entry_attributes (ld, pLdapMsg);
	if (cAttrs == 0)
	{
		hrServer = ILS_E_NO_MORE;
		goto MyExit;
	}

	// Allocate result set holder
	//
	pmia = (MTG_INFO_ATTRS *) MemAlloc (
						sizeof (MTG_INFO_ATTRS) +
						cAttrs * sizeof (ATTR_PAIR));
	if (pmia == NULL)
	{
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}

	// Initialize result set holder
	//
	pmia->Attrs.cMaxAttrs = cAttrs;

	// Cache resolve set
	//
	hrServer = NotifyResolveX (	hrServer,
								pItem,
								pmia,
								CacheResolveMtgInfoAttr);
	if (hrServer != S_OK)
		goto MyExit;

	// Initialize the size
	//
	ULONG cbTotalSize, cbThisSize;
	cbTotalSize = sizeof (LDAP_MEETINFO_RES);

	// Loop through standard attrs to calculate the total size
	//
	ULONG i;
	for (i = 0; i < COUNT_ENUM_MTGATTR; i++)
	{
		if (pmia->MtgInfo.apszStdAttrValues[i] != NULL)
		{
			// Compute the string length
			//
			cbThisSize = My_lstrlen (pmia->MtgInfo.apszStdAttrValues[i]) + 1;

			// Compensate the string length if it is ip address
			//
			if (i == ENUM_MTGATTR_IP_ADDRESS)
				cbThisSize += 16;

			// Convert the string length to string size
			//
			cbThisSize *= sizeof (TCHAR);

			// Add up to the total size
			//
			cbTotalSize += cbThisSize;
		}
	}

	// Loop through arbitrary attrs to calculate the total size
	//
	for (i = 0; i < pmia->Attrs.cCurrAttrs; i++)
	{
		cbThisSize = My_lstrlen (pmia->Attrs.aPairs[i].pszName) + 1;
		cbThisSize += My_lstrlen (pmia->Attrs.aPairs[i].pszValue) + 1;
		cbThisSize *= sizeof (TCHAR);
		cbTotalSize += cbThisSize;
	}

	// Allocate LDAP_MTGINFO_RES structure
	//
	pMtgRes = (LDAP_MEETINFO_RES *) MemAlloc (cbTotalSize);
	if (pMtgRes == NULL)
	{
		MyAssert (FALSE); // we are in deep trouble here
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}

	// Fill in common fields
	//
	pMtgRes->uSize = sizeof (*pMtgRes);
	pMtgRes->hResult = hrServer;
	pMtgRes->lmi.uSize = sizeof (pMtgRes->lmi);
	TCHAR *pszSrc, *pszDst;
	pszDst = (TCHAR *) (pMtgRes + 1);

	// Copy Meeting Name if needed
	//
	pszSrc = pmia->MtgInfo.apszStdAttrValues[ENUM_MTGATTR_CN];
	if (pszSrc != NULL)
	{
		pMtgRes->lmi.uOffsetMeetingPlaceID = (ULONG) pszDst - (ULONG) &(pMtgRes->lmi);
		My_lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
	}

	// Copy Meeting Type if needed
	//
	pszSrc = pmia->MtgInfo.apszStdAttrValues[ENUM_MTGATTR_MTG_TYPE];
	if (pszSrc != NULL)
	{
		pMtgRes->lmi.lMeetingPlaceType = (pszSrc != NULL) ?	GetStringLong (pszSrc) :
														INVALID_MEETING_TYPE;
	}

	// Copy Attendee Type if needed
	//
	pszSrc = pmia->MtgInfo.apszStdAttrValues[ENUM_MTGATTR_MEMBER_TYPE];
	if (pszSrc != NULL)
	{
		pMtgRes->lmi.lAttendeeType = (pszSrc != NULL) ?	GetStringLong (pszSrc) :
														INVALID_ATTENDEE_TYPE;
	}

	// Copy Description if needed
	//
	pszSrc = pmia->MtgInfo.apszStdAttrValues[ENUM_MTGATTR_DESCRIPTION];
	if (pszSrc != NULL)
	{
		pMtgRes->lmi.uOffsetDescription = (ULONG) pszDst - (ULONG) &(pMtgRes->lmi);
		My_lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
	}

	// Copy Host Name if needed
	//
	pszSrc = pmia->MtgInfo.apszStdAttrValues[ENUM_MTGATTR_HOST_NAME];
	if (pszSrc != NULL)
	{
		pMtgRes->lmi.uOffsetHostName = (ULONG) pszDst - (ULONG) &(pMtgRes->lmi);
		My_lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
	}

	// Copy Host IP Address if needed
	//
	pszSrc = pmia->MtgInfo.apszStdAttrValues[ENUM_MTGATTR_IP_ADDRESS];
	if (pszSrc != NULL)
	{
		pMtgRes->lmi.uOffsetHostIPAddress = (ULONG) pszDst - (ULONG) &(pMtgRes->lmi);
		GetIPAddressString (pszDst, GetStringLong (pszSrc));
		pszDst += lstrlen (pszDst) + 1;
	}

	// Copy extended attributes
	//
	pMtgRes->lmi.cAttrsReturned = pmia->Attrs.cCurrAttrs;
	if (pMtgRes->lmi.cAttrsReturned > 0)
	{
		pMtgRes->lmi.uOffsetAttrsReturned = (ULONG) pszDst - (ULONG) &(pMtgRes->lmi);
		for (i = 0; i < pmia->Attrs.cCurrAttrs; i++)
		{
			My_lstrcpy (pszDst, pmia->Attrs.aPairs[i].pszName);
			pszDst += lstrlen (pszDst) + 1;
			My_lstrcpy (pszDst, pmia->Attrs.aPairs[i].pszValue);
			pszDst += lstrlen (pszDst) + 1;
		}
	}

	MyAssert (hrServer == S_OK);

MyExit:

	// Free temporary result set holder
	//
	if (pmia != NULL)
	{
		// Free standard attributes
		//
		for (INT i = 0; i < COUNT_ENUM_MTGATTR; i++)
		{
			MemFree (pmia->MtgInfo.apszStdAttrValues[i]);
		}

		// Free arbitrary attributes
		//
		for (ULONG j = 0; j < pmia->Attrs.cCurrAttrs; j++)
		{
			MemFree (pmia->Attrs.aPairs[j].pszName);
			MemFree (pmia->Attrs.aPairs[j].pszValue);
		}

		// Free the holder itself
		//
		MemFree (pmia);
	}

	// Clean up the return structure if failure
	//
	if (hrServer != S_OK)
	{
		// Make sure we have a return structure
		//
		if (pMtgRes != NULL)
			ZeroMemory (pMtgRes, sizeof (*pMtgRes));
		else
			pMtgRes = (LDAP_MEETINFO_RES *) MemAlloc (sizeof (LDAP_MEETINFO_RES));

		// Fill in the minimal info
		//
		if (pMtgRes != NULL)
		{
			pMtgRes->uSize = sizeof (*pMtgRes);
			pMtgRes->hResult = hrServer;
		}
	}

	// Post a message to the com layer
	//
	PostMessage (g_hWndNotify, pInfo->uNotifyMsg, pInfo->uRespID, (LPARAM) pMtgRes);

	// Delete this pending item
	//
	return TRUE;
}
#endif // ENABLE_MEETING_PLACE


#ifdef ENABLE_MEETING_PLACE
HRESULT CacheResolveMtgInfoAttr (
	VOID			*pInfo,
	const TCHAR		*pszAttrName,
	const TCHAR		**ppszAttrVal )
{
	MyAssert (pInfo != NULL);
	MyAssert (pszAttrName != NULL);

	// Shorthand meeting info pointer
	//
	MTG_INFO_ATTRS *pmia = (MTG_INFO_ATTRS *) pInfo;

	// See if this attribute is arbitrary?
	//
	const TCHAR *pszRealAnyName = IlsIsAnyAttrName (pszAttrName);
	if (pszRealAnyName != NULL)
	{
		MyAssert (pmia->Attrs.cCurrAttrs < pmia->Attrs.cMaxAttrs);

		// Duplicate the name
		//
		pmia->Attrs.aPairs[pmia->Attrs.cCurrAttrs].pszName =
			My_strdup (pszRealAnyName);

		// Duplicate the value
		// BUGS: we should avoid duplicate the string here (cf. enum-user-infos)
		//
		if (ppszAttrVal != NULL)
		{
			pmia->Attrs.aPairs[pmia->Attrs.cCurrAttrs++].pszValue =
				My_strdup (*ppszAttrVal);
		}
		else
		{
			// ILS server bug or wldap32.dll bug
			//
			MyAssert (FALSE);
		}
	}
	else
	{
		// Loop through all standard attributes
		//
		for (INT i = 0; i < COUNT_ENUM_RESMTGINFO; i++)
		{
			// Figure out what attribute it is
			//
			if (My_lstrcmpi (c_apszMtgStdAttrNames[i], pszAttrName) == 0)
			{
				// Free the previously allocated value if any
				//
				MemFree (pmia->MtgInfo.apszStdAttrValues[i]);

				// Duplicate the value
				// BUGS: we should avoid duplicate the string here (cf. enum-user-infos)
				//
				if (ppszAttrVal != NULL)
				{
					pmia->MtgInfo.apszStdAttrValues[i] = My_strdup (*ppszAttrVal);
				}
				else
				{
					// ILS server bug or wldap32.dll bug
					//
					MyAssert (FALSE);
				}
				break;
			}
		}
	}

	return S_OK;
}
#endif // ENABLE_MEETING_PLACE


VOID FreeStdAttrCache ( TCHAR *apszStdAttrValues[], ULONG cStdAttrs )
{
	for (ULONG i = 0; i < cStdAttrs; i++)
	{
		if (apszStdAttrValues[i] != NULL)
		{
			ldap_value_free ((TCHAR **) apszStdAttrValues[i]);
		}
	}
}


VOID FreeAttrPairArrayCache ( ATTR_PAIR aAttrPair[], ULONG cPairs )
{
	if (aAttrPair != NULL)
	{
		for (ULONG j = 0; j < cPairs; j++)
		{
			if (aAttrPair[j].pszValue != NULL)
			{
				ldap_value_free ((TCHAR **) aAttrPair[j].pszValue);
			}
		}
	}
}


VOID CacheAnyAttrNamesInAttrPairs (
	ULONG			cNames,
	TCHAR			*pszSrcNameList,
	ATTR_PAIR		aPairs[] )
{
	MyAssert (cNames != 0);
	MyAssert (pszSrcNameList != NULL);
	MyAssert (aPairs != NULL);

	// Note that all these extended attribute names are already PREFIXED
	//
	for (ULONG i = 0; i < cNames; i++)
	{
		aPairs[i].pszName = pszSrcNameList;
		pszSrcNameList += lstrlen (pszSrcNameList) + 1;
	}
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\spstdatt.h ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spstdatt.h
	Content:	This file contains the standard-attribute object definition.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#ifndef _ULS_SP_STDATTR_H_
#define _ULS_SP_STDATTR_H_

#include <pshpack8.h>


class UlsLdap_CStdAttrs
{
	friend class UlsLdap_CLocalUser;
	friend class UlsLdap_CLocalApp;
	friend class UlsLdap_CLocalProt;

public:

	UlsLdap_CStdAttrs ( VOID );
	~UlsLdap_CStdAttrs ( VOID );

protected:

	HRESULT SetStdAttrs ( ULONG *puRespID, ULONG *puMsgID,
						ULONG uNotifyMsg, VOID *pInfo,
						SERVER_INFO *pServerInfo, TCHAR *pszDN );

private:

	virtual HRESULT CacheInfo ( VOID *pInfo ) = 0;
	virtual HRESULT CreateSetStdAttrsModArr ( LDAPMod ***pppMod ) = 0;

	ULONG	m_uDontCare; // avoid zero size
};

HRESULT FillDefStdAttrsModArr ( LDAPMod ***pppMod, DWORD dwFlags,
								ULONG cMaxAttrs, ULONG *pcTotal,
								LONG IsbuModOp,
								ULONG cPrefix, TCHAR *pszPrefix );


#include <poppack.h>

#endif // _ULS_SP_STDATTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\sputils.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		sputils.cpp
	Content:	This file contains the utilities for service provider.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"


TCHAR c_szWindowClassName[] = TEXT ("UlsLdapSp");

BOOL g_fExitNow = FALSE;
HANDLE g_ahThreadWaitFor[NUM_THREAD_WAIT_FOR] = { 0 };


DWORD WINAPI
ReqThread ( VOID *lParam )
{
	BOOL fStayInThisThread = TRUE;
	DWORD dwExitCode = 0;
	DWORD dwResult;

	// Start WSA for subsequent host query in this service provider
	//
	WSADATA WSAData;
	if (WSAStartup (MAKEWORD (1, 1), &WSAData))
	{
		dwExitCode = ILS_E_WINSOCK;
		goto MyExit;
	}

	// Make sure that all the event are initialized
	//
	INT i;
	for (i = 0; i < NUM_THREAD_WAIT_FOR; i++)
	{
		if (g_ahThreadWaitFor[i] == NULL)
		{
			MyAssert (FALSE);
			dwExitCode = ILS_E_THREAD;
			goto MyExit;
		}
	}

	// Wait for events to happen!!!
	//
	do
	{
		dwResult = MsgWaitForMultipleObjects (	NUM_THREAD_WAIT_FOR,
												&g_ahThreadWaitFor[0],
												FALSE,		// OR logic
												INFINITE,	// infinite
												QS_ALLINPUT); // any message in queue
		switch (dwResult)
		{
		case WAIT_OBJECT_0 + THREAD_WAIT_FOR_REQUEST:
			if (g_pReqQueue != NULL)
			{
				g_pReqQueue->Schedule ();
				MyAssert (fStayInThisThread);
			}
			else
			{
				MyAssert (FALSE);
				fStayInThisThread = FALSE;
			}
			break;

		case WAIT_OBJECT_0 + THREAD_WAIT_FOR_EXIT:
		case WAIT_ABANDONED_0 + THREAD_WAIT_FOR_EXIT:
		case WAIT_ABANDONED_0 + THREAD_WAIT_FOR_REQUEST:
		case WAIT_TIMEOUT:
			// Exit this thread
			//
			fStayInThisThread = FALSE;
			break;

		default:
			// If a message in the queue, then dispatch it.
			// Right now, wldap32 does not have a message pump.
			// However, for possible update of wldap32, we need to
			// protect ourselves from being fried.
			//
			if (! KeepUiResponsive ())
				fStayInThisThread = FALSE;
			break;
		}
	}
	while (fStayInThisThread);

MyExit:

	if (dwExitCode != ILS_E_WINSOCK)
		WSACleanup ();

	// ExitThread (dwExitCode);
	return 0;
}


BOOL KeepUiResponsive ( VOID )
{
	MSG msg;
	while (PeekMessage (&msg, NULL, 0, 0, PM_REMOVE))
	{
		if (msg.message != WM_QUIT)
		{
			TranslateMessage (&msg);
			DispatchMessage (&msg);
		}
		else
		{
			PostQuitMessage ((int)msg.wParam);
			return FALSE;
		}
	}

	return TRUE;
}


LRESULT CALLBACK
SP_WndProc ( HWND hWnd, UINT uMsg, WPARAM uParam, LPARAM lParam )
{
	switch (uMsg)
	{
	case WM_CREATE:
		break;

	case WM_TIMER:
		switch (LOWORD (uParam))
		{
		case ID_TIMER_POLL_RESULT:
			if (g_pRespQueue != NULL)
			{
				// No-wait polling
				//
				LDAP_TIMEVAL PollTimeout;
				ZeroMemory (&PollTimeout, sizeof (PollTimeout));
				// PollTimeout.tv_sec = 0;
				// PollTimeout.tv_usec = 0;
				g_pRespQueue->PollLdapResults (&PollTimeout);
			}
			else
			{
				MyAssert (FALSE);
			}
			break;

		default:
			if (LOWORD (uParam) >= KEEP_ALIVE_TIMER_BASE)
			{
				// Allocate marshall request buffer
				//
				MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_REFRESH, 0, 1);
				if (pReq != NULL)
				{
					HRESULT hr = ILS_E_FAIL;
					ULONG uTimerID = LOWORD (uParam);

					// Fill in parameters
					//
					MarshalReq_SetParam (pReq, 0, (DWORD) uTimerID, 0);

					// Enter the request
					//
					if (g_pReqQueue != NULL)
					{
						hr = g_pReqQueue->Enter (pReq);
					}
					else
					{
						MyAssert (FALSE);
					}

					// Avoid timer overrun if the request is submitted successfully
					//
					if (hr == S_OK)
					{
						KillTimer (hWnd, uTimerID);
					}
					else
					{
						MemFree (pReq);
					}
				}
			}
			else
			{
				MyAssert (FALSE);
			}
			break;
		} // switch (LOWORD (uParam))
		break;

	case WM_ILS_CLIENT_NEED_RELOGON:
	case WM_ILS_CLIENT_NETWORK_DOWN:
		#if 1
		MyAssert (FALSE); // we should post to com directly
		#else
		{
			// Get the local user object
			//
			SP_CClient *pClient = (SP_CClient *) lParam;

			// Make sure the parent local user object is valid
			//
			if (MyIsBadWritePtr (pClient, sizeof (*pClient)) ||
				! pClient->IsValidObject () ||
				! pClient->IsRegistered ())
			{
				MyAssert (FALSE);
				break; // exit
			}

			// Indicate this user object is not remotely connected to the server
			//
			pClient->SetRegLocally ();

			// Get the server info
			//
			SERVER_INFO *pServerInfo = pClient->GetServerInfo ();
			if (pServerInfo == NULL)
			{
				MyAssert (FALSE);
				break; // exit
			}

			// Duplicate the server name
			//
			TCHAR *pszServerName = My_strdup (pServerInfo->pszServerName);
			if (pszServerName == NULL)
				break; // exit

			// Notify the com layer
			//
			PostMessage (g_hWndNotify, uMsg, (WPARAM) pClient, (LPARAM) pszServerName);
		}
		#endif
		break;

#ifdef ENABLE_MEETING_PLACE
	case WM_ILS_MEETING_NEED_RELOGON:
	case WM_ILS_MEETING_NETWORK_DOWN:
		#if 1
		MyAssert (FALSE); // we should post to com directly
		#else
		{
			// Get the local user object
			//
			SP_CMeeting *pMtg = (SP_CMeeting *) lParam;

			// Make sure the parent local user object is valid
			//
			if (MyIsBadWritePtr (pMtg, sizeof (*pMtg)) ||
				! pMtg->IsValidObject () ||
				! pMtg->IsRegistered ())
			{
				MyAssert (FALSE);
				break; // exit
			}

			// Indicate this user object is not remotely connected to the server
			//
			pMtg->SetRegLocally ();

			// Get the server info
			//
			SERVER_INFO *pServerInfo = pMtg->GetServerInfo ();
			if (pServerInfo == NULL)
			{
				MyAssert (FALSE);
				break; // exit
			}

			// Duplicate the server name
			//
			TCHAR *pszServerName = My_strdup (pServerInfo->pszServerName);
			if (pszServerName == NULL)
				break; // exit

			// Notify the com layer
			//
			PostMessage (g_hWndNotify, uMsg, (WPARAM) pMtg, (LPARAM) pszServerName);
		}
		#endif
		break;
#endif // ENABLE_MEETING_PLACE

#if 0
	case WM_ILS_IP_ADDRESS_CHANGED:
		{
			// Get the local user object
			//
			SP_CClient *pClient = (SP_CClient *) lParam;

			// Make sure the parent local user object is valid
			//
			if (MyIsBadWritePtr (pClient, sizeof (*pClient)) ||
				! pClient->IsValidObject () ||
				! pClient->IsRegistered ())
			{
				MyAssert (FALSE);
				break; // exit
			}

			// Change IP address now
			//
			pClient->UpdateIPAddress ();
		}
		break;
#endif

	case WM_CLOSE:
		DestroyWindow (hWnd);
		break;

	case WM_DESTROY:
		g_hWndHidden = NULL;
#ifdef USE_HIDDEN_THREAD
		PostQuitMessage (0);
#endif
		break;

	default:
		return DefWindowProc (hWnd, uMsg, uParam, lParam);
	}

	return 0;
}


BOOL MyCreateWindow ( VOID )
{
	WNDCLASS	wc;

	// do the stuff to create a hidden window
	ZeroMemory (&wc, sizeof (wc));
	// wc.style = 0;
	wc.lpfnWndProc = SP_WndProc;
	// wc.cbClsExtra = 0;
	// wc.cbWndExtra = 0;
	// wc.hIcon = NULL;
	wc.hInstance = g_hInstance;
	// wc.hCursor = NULL;
	// wc.hbrBackground = NULL;
	// wc.lpszMenuName =  NULL;
	wc.lpszClassName = c_szWindowClassName;

	// register the class
	// it is ok, if the class is already registered by another app
	RegisterClass (&wc);

	// create a window for socket notification
	g_hWndHidden = CreateWindow (
		wc.lpszClassName,
		NULL,
		WS_POPUP,		   /* Window style.   */
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		NULL,			   /* the application window is the parent. */
		NULL,				/* hardcoded ID		 */
		g_hInstance,		   /* the application owns this window.	*/
		NULL);			  /* Pointer not needed.				*/

	return (g_hWndHidden != NULL);
}


HRESULT
GetLocalIPAddress ( DWORD *pdwIPAddress )
{
	MyAssert (pdwIPAddress != NULL);

	// get local host name
	CHAR szLocalHostName[MAX_PATH];
	szLocalHostName[0] = '\0';
	gethostname (&szLocalHostName[0], MAX_PATH);

	// get the host entry by name
	PHOSTENT phe = gethostbyname (&szLocalHostName[0]);
	if (phe == NULL)
		return ILS_E_WINSOCK;

	// get info from the host entry
	*pdwIPAddress = *(DWORD *) phe->h_addr;
	return S_OK;
}


// guid --> string
VOID
GetGuidString ( GUID *pGuid, TCHAR *pszGuid )
{
	MyAssert (! MyIsBadWritePtr (pGuid, sizeof (GUID)));
	MyAssert (pszGuid != NULL);

	CHAR *psz = (CHAR *) pGuid;

	for (ULONG i = 0; i < sizeof (GUID); i++)
	{
		wsprintf (pszGuid, TEXT ("%02x"), (0x0FF & (ULONG) *psz));
		pszGuid += 2;
		psz++;
	}
	*pszGuid = TEXT ('\0');
}


// string --> guid
VOID
GetStringGuid ( TCHAR *pszGuid, GUID *pGuid )
{
	ULONG cchGuid = lstrlen (pszGuid);

	MyAssert (cchGuid == 2 * sizeof (GUID));
	MyAssert (! MyIsBadWritePtr (pGuid, sizeof (GUID)));

	// Clean up target GUID structure
	//
	ZeroMemory (pGuid, sizeof (GUID));

	// Translate guid string to guid
	//
	CHAR *psz = (CHAR *) pGuid;
	cchGuid >>= 1;
	for (ULONG i = 0; i < cchGuid; i++)
	{
		*psz++ = (CHAR) ((HexChar2Val (pszGuid[0]) << 4) |
						HexChar2Val (pszGuid[1]));
		pszGuid += 2;
	}
}


INT
HexChar2Val ( TCHAR c )
{
	INT Val;
	if (TEXT ('0') <= c && c <= TEXT ('9'))
		Val = c - TEXT ('0');
	else
	if (TEXT ('a') <= c && c <= TEXT ('f'))
		Val = c - TEXT ('a') + 10;
	else
	if (TEXT ('A') <= c && c <= TEXT ('F'))
		Val = c - TEXT ('A') + 10;
	else
		Val = 0;

	MyAssert (0 <= Val && Val <= 15);
	return Val & 0x0F;
}


INT
DecimalChar2Val ( TCHAR c )
{
	INT Val;
	if (TEXT ('0') <= c && c <= TEXT ('9'))
		Val = c - TEXT ('0');
	else
		Val = 0;

	MyAssert (0 <= Val && Val <= 9);
	return Val & 0x0F;
}


BOOL
IsValidGuid ( GUID *pGuid )
{
	DWORD *pdw = (DWORD *) pGuid;

	return (pdw[0] != 0 || pdw[1] != 0 || pdw[2] != 0 || pdw[3] != 0);
}


// long --> string
VOID
GetLongString ( LONG Val, TCHAR *pszVal )
{
	MyAssert (pszVal != NULL);
	wsprintf (pszVal, TEXT ("%lu"), Val);
}


// string --> long
LONG
GetStringLong ( TCHAR *pszVal )
{
	MyAssert (pszVal != NULL);

	LONG Val = 0;
	for (INT i = 0; i < INTEGER_STRING_LENGTH && *pszVal != TEXT ('\0'); i++)
	{
		Val = 10 * Val + DecimalChar2Val (*pszVal++);
	}

	return Val;
}


// it is the caller's responsibility to make sure
// the buffer is sufficient and
// the ip address is in network order
VOID
GetIPAddressString ( TCHAR *pszIPAddress, DWORD dwIPAddress )
{
	BYTE temp[4];

	*(DWORD *) &temp[0] = dwIPAddress;
	wsprintf (pszIPAddress, TEXT ("%u.%u.%u.%u"),
				(UINT) temp[0], (UINT) temp[1],
				(UINT) temp[2], (UINT) temp[3]);
}


ULONG
My_lstrlen ( const TCHAR *psz )
{
	return ((psz != NULL) ? lstrlen (psz) : 0);
}


VOID
My_lstrcpy ( TCHAR *pszDst, const TCHAR *pszSrc )
{
	if (pszDst != NULL)
	{
		if (pszSrc != NULL)
		{
			lstrcpy (pszDst, pszSrc);
		}
		else
		{
			*pszDst = TEXT ('\0');
		}
	}
}


INT
My_lstrcmpi ( const TCHAR *p, const TCHAR *q )
{
	INT retcode;

	if (p == q)
	{
		retcode = 0;
	}
	else
	if (p == NULL)
	{
		retcode = -1;
	}
	else
	if (q == NULL)
	{
		retcode = 1;
	}
	else
	{
		retcode = lstrcmpi (p, q);
	}

	return retcode;
}


TCHAR *
My_strdup ( const TCHAR *pszToDup )
{
	TCHAR *psz = NULL;

	if (pszToDup != NULL)
	{
		psz = (TCHAR *) MemAlloc ((lstrlen (pszToDup) + 1) * sizeof (TCHAR));
		if (psz != NULL)
		{
			lstrcpy (psz, pszToDup);
		}
	}

	return psz;
}


TCHAR *
My_strchr ( const TCHAR *psz, TCHAR c )
{
	TCHAR *pszFound = NULL;

	if (psz)
	{
		while (*psz)
		{
			if (*psz == c)
			{
				pszFound = (TCHAR *) psz;
				break;
			}

			psz++;
		}
	}

	return pszFound;
}


BOOL
My_isspace ( TCHAR ch )
{
	return (ch == TEXT (' ')  || ch == TEXT ('\t') ||
			ch == TEXT ('\r') || ch == TEXT ('\n'));
}


BOOL
IsSameMemory ( const BYTE *pb1, const BYTE *pb2, DWORD cbSize )
{
	while (cbSize--)
	{
		if (*pb1++ != *pb2++)
		{
			return FALSE;
		}
	}

	return TRUE;
}



BYTE *
MyBinDup ( const BYTE *pbToDup, ULONG cbToDup )
{
	BYTE *pb = NULL;

	if (pbToDup)
	{
		pb = (BYTE *) MemAlloc (cbToDup);
		if (pb)
		{
			CopyMemory (pb, pbToDup, cbToDup);
		}
	}

	return pb;
}


/* ---------- registry ------------- */


const TCHAR c_szUlsLdapSpReg[] = TEXT("Software\\Microsoft\\User Location Service\\LDAP Provider");
const TCHAR c_szResponseTimeout[] = TEXT("Response Timeout");
const TCHAR c_szResponsePollPeriod[] = TEXT("Response Poll Period");
const TCHAR c_szClientSig[] = TEXT ("Client Signature");

BOOL
GetRegistrySettings ( VOID )
{
	// Open the LDAP Provider settings
	//
	HKEY hKey;
	if (RegOpenKeyEx (	HKEY_CURRENT_USER,
						&c_szUlsLdapSpReg[0],
						0,
						KEY_READ,
						&hKey) != NOERROR)
	{
		// The folder does not exist
		//
		g_uResponseTimeout = ILS_MIN_RESP_TIMEOUT;
		g_uResponsePollPeriod = ILS_DEF_RESP_POLL_PERIOD;
		g_dwClientSig = (ULONG) -1;
	}
	else
	{
		// Get response timeout
		//
		GetRegValueLong (	hKey,
							&c_szResponseTimeout[0],
							(LONG *) &g_uResponseTimeout,
							ILS_DEF_RESP_TIMEOUT);

		// Make sure the value is within the range
		//
		if (g_uResponseTimeout < ILS_MIN_RESP_TIMEOUT)
			g_uResponseTimeout = ILS_MIN_RESP_TIMEOUT;

		// Get response poll period
		//
		GetRegValueLong (	hKey,
							&c_szResponsePollPeriod[0],
							(LONG *) &g_uResponsePollPeriod,
							ILS_DEF_RESP_POLL_PERIOD);
		
		// Make sure the value is within the range
		//
		if (g_uResponsePollPeriod < ILS_MIN_RESP_POLL_PERIOD)
			g_uResponsePollPeriod = ILS_MIN_RESP_POLL_PERIOD;

		// Get client signature
		//
		GetRegValueLong (	hKey,
							&c_szClientSig[0],
							(LONG *) &g_dwClientSig,
							(LONG) -1);

		RegCloseKey (hKey);
	}

	// Make sure this value is not -1
	//
	if (g_dwClientSig == (ULONG) -1)
	{
		// The client signature does not exist.
		// We need to generate a new one
		//
		g_dwClientSig = GetTickCount ();

		// Save it back to the registry
		//
		DWORD dwDontCare;
		if (RegCreateKeyEx (HKEY_CURRENT_USER,
							&c_szUlsLdapSpReg[0],
							0,
							TEXT (""),
							REG_OPTION_NON_VOLATILE,
							KEY_READ | KEY_WRITE,
							NULL,
							&hKey,
							&dwDontCare) == NOERROR)
		{
			RegSetValueEx (	hKey,
							&c_szClientSig[0],
							0,
							REG_DWORD,
							(BYTE *) &g_dwClientSig,
							sizeof (&g_dwClientSig));
		}
	}

	return TRUE;
}


BOOL
GetRegValueLong (
	HKEY		hKey,
	const TCHAR	*pszKey,
	LONG		*plValue,
	LONG		lDefValue )
{
	MyAssert (hKey != NULL);
	MyAssert (pszKey != NULL);
	MyAssert (plValue != NULL);

	*plValue = lDefValue;

	DWORD dwType;
	ULONG cb;
	TCHAR szText[MAX_PATH];

	cb = sizeof (szText);

	if (RegQueryValueEx (	hKey,
							pszKey,
							NULL,
							&dwType,
							(BYTE *) &szText[0],
							&cb)
		== ERROR_SUCCESS)
	{
		switch (dwType)
		{
		case REG_DWORD:
		case REG_BINARY:
			*plValue = *(LONG *) &szText[0];
			break;
		case REG_SZ:
			*plValue = GetStringLong (&szText[0]);
			break;
		default:
			return FALSE;
		}
	}

	return TRUE;
}


/* ------- LDAP error codes ---------- */

const LONG c_LdapErrToHrShort[] =
{
	// End of search (per AndyHe info)
	LDAP_PARAM_ERROR,				ILS_E_PARAMETER,
	// Keep alive fails
	LDAP_NO_SUCH_OBJECT,			ILS_E_NO_SUCH_OBJECT,
	// Logon with conflicting email name
	LDAP_ALREADY_EXISTS,			ILS_E_NAME_CONFLICTS,

	LDAP_OPERATIONS_ERROR,			ILS_E_LDAP_OPERATIONS_ERROR,
	LDAP_PROTOCOL_ERROR,			ILS_E_LDAP_PROTOCOL_ERROR,
	LDAP_TIMELIMIT_EXCEEDED,		ILS_E_LDAP_TIMELIMIT_EXCEEDED,
	LDAP_SIZELIMIT_EXCEEDED,		ILS_E_LDAP_SIZELIMIT_EXCEEDED,
	LDAP_COMPARE_FALSE,				ILS_E_LDAP_COMPARE_FALSE,
	LDAP_COMPARE_TRUE,				ILS_E_LDAP_COMPARE_TRUE,
	LDAP_AUTH_METHOD_NOT_SUPPORTED,	ILS_E_LDAP_AUTH_METHOD_NOT_SUPPORTED,
	LDAP_STRONG_AUTH_REQUIRED,		ILS_E_LDAP_STRONG_AUTH_REQUIRED,
	LDAP_REFERRAL_V2,				ILS_E_LDAP_REFERRAL_V2,
	LDAP_PARTIAL_RESULTS,			ILS_E_LDAP_PARTIAL_RESULTS,
	LDAP_REFERRAL,					ILS_E_LDAP_REFERRAL,
	LDAP_ADMIN_LIMIT_EXCEEDED,		ILS_E_LDAP_ADMIN_LIMIT_EXCEEDED,
	LDAP_UNAVAILABLE_CRIT_EXTENSION,ILS_E_LDAP_UNAVAILABLE_CRIT_EXTENSION,

	LDAP_NO_SUCH_ATTRIBUTE,			ILS_E_LDAP_NO_SUCH_ATTRIBUTE,
	LDAP_UNDEFINED_TYPE,			ILS_E_LDAP_UNDEFINED_TYPE,
	LDAP_INAPPROPRIATE_MATCHING,	ILS_E_LDAP_INAPPROPRIATE_MATCHING,
	LDAP_CONSTRAINT_VIOLATION,		ILS_E_LDAP_CONSTRAINT_VIOLATION,
	LDAP_ATTRIBUTE_OR_VALUE_EXISTS,	ILS_E_LDAP_ATTRIBUTE_OR_VALUE_EXISTS,
	LDAP_INVALID_SYNTAX,			ILS_E_LDAP_INVALID_SYNTAX,

	LDAP_ALIAS_PROBLEM,				ILS_E_LDAP_ALIAS_PROBLEM,
	LDAP_INVALID_DN_SYNTAX,			ILS_E_LDAP_INVALID_DN_SYNTAX,
	LDAP_IS_LEAF,					ILS_E_LDAP_IS_LEAF,
	LDAP_ALIAS_DEREF_PROBLEM,		ILS_E_LDAP_ALIAS_DEREF_PROBLEM,

	LDAP_INAPPROPRIATE_AUTH,		ILS_E_LDAP_INAPPROPRIATE_AUTH,
	LDAP_INVALID_CREDENTIALS,		ILS_E_LDAP_INVALID_CREDENTIALS,
	LDAP_INSUFFICIENT_RIGHTS,		ILS_E_LDAP_INSUFFICIENT_RIGHTS,
	LDAP_BUSY,						ILS_E_LDAP_BUSY,
	LDAP_UNAVAILABLE,				ILS_E_LDAP_UNAVAILABLE,
	LDAP_UNWILLING_TO_PERFORM,		ILS_E_LDAP_UNWILLING_TO_PERFORM,
	LDAP_LOOP_DETECT,				ILS_E_LDAP_LOOP_DETECT,

	LDAP_NAMING_VIOLATION,			ILS_E_LDAP_NAMING_VIOLATION,
	LDAP_OBJECT_CLASS_VIOLATION,	ILS_E_LDAP_OBJECT_CLASS_VIOLATION,
	LDAP_NOT_ALLOWED_ON_NONLEAF,	ILS_E_LDAP_NOT_ALLOWED_ON_NONLEAF,
	LDAP_NOT_ALLOWED_ON_RDN,		ILS_E_LDAP_NOT_ALLOWED_ON_RDN,
	LDAP_NO_OBJECT_CLASS_MODS,		ILS_E_LDAP_NO_OBJECT_CLASS_MODS,
	LDAP_RESULTS_TOO_LARGE,			ILS_E_LDAP_RESULTS_TOO_LARGE,
	LDAP_AFFECTS_MULTIPLE_DSAS,		ILS_E_LDAP_AFFECTS_MULTIPLE_DSAS,

	LDAP_OTHER,						ILS_E_LDAP_OTHER,
	LDAP_SERVER_DOWN,				ILS_E_LDAP_SERVER_DOWN,
	LDAP_LOCAL_ERROR,				ILS_E_LDAP_LOCAL_ERROR,
	LDAP_ENCODING_ERROR,			ILS_E_LDAP_ENCODING_ERROR,
	LDAP_DECODING_ERROR,			ILS_E_LDAP_DECODING_ERROR,
	LDAP_TIMEOUT,					ILS_E_LDAP_TIMEOUT,
	LDAP_AUTH_UNKNOWN,				ILS_E_LDAP_AUTH_UNKNOWN,
	LDAP_FILTER_ERROR,				ILS_E_LDAP_FILTER_ERROR,
	LDAP_USER_CANCELLED,			ILS_E_LDAP_USER_CANCELLED,
	LDAP_NO_MEMORY,					ILS_E_LDAP_NO_MEMORY,
};


HRESULT
LdapError2Hresult ( ULONG uLdapError )
{
	HRESULT	hr;

	switch (uLdapError)
	{
	case LDAP_SUCCESS:
		hr = S_OK;
		break;

	default:
		// If nothing appears to be appropriate
		//
		hr = ILS_E_SERVER_EXEC;

		// Go through the loop to find a matching error code
		//
		for (	INT i = 0;
				i < ARRAY_ELEMENTS (c_LdapErrToHrShort);
				i += 2)
		{
			if (c_LdapErrToHrShort[i] == (LONG) uLdapError)
			{
				hr = (HRESULT) c_LdapErrToHrShort[i+1];
				break;
			}
		}

		MyAssert (hr != ILS_E_SERVER_EXEC);
		break;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\ulsapp.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       ulsapp.h
//  Content:    This file contains the Application object definition.
//  History:
//      Wed 17-Apr-1996 11:18:47  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#ifndef _ULSAPP_H_
#define _ULSAPP_H_

#include "connpt.h"

//****************************************************************************
// CUlsApp definition
//****************************************************************************
//
class CUlsApp : public IULSApplication,
                public IConnectionPointContainer
{
private:
    ULONG                   cRef;
    LPTSTR                  szServer;
    LPTSTR                  szUser;
    GUID                    guid;
    LPTSTR                  szName;
    LPTSTR                  szMimeType;
    CAttributes             *pAttrs;
    CConnectionPoint        *pConnPt;

    // Private method
    //
    STDMETHODIMP    NotifySink (void *pv, CONN_NOTIFYPROC pfn);

public:
    // Constructor and destructor
    CUlsApp (void);
    ~CUlsApp (void);
    STDMETHODIMP            Init (LPTSTR szServerName,
                                  LPTSTR szUserName,
                                  PLDAP_APPINFO pai);

    // Asynchronous response
    //
    STDMETHODIMP    GetProtocolResult (ULONG uReqID,
                                       PLDAP_PROTINFO_RES plar);
    STDMETHODIMP    EnumProtocolsResult (ULONG uReqID,
                                         PLDAP_ENUM ple);

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IULSApplication
    STDMETHODIMP    GetID (GUID *pGUID);
    STDMETHODIMP    GetName (BSTR *pbstrAppName);
    STDMETHODIMP    GetMimeType (BSTR *pbstrMimeType);
    STDMETHODIMP    GetAttributes (IULSAttributes **ppAttributes);
    STDMETHODIMP    GetProtocol (BSTR bstrProtocolID,
    							 IULSAttributes *pAttributes,
                                 ULONG *puReqID);
    STDMETHODIMP    EnumProtocols (ULONG *puReqID);

    // IConnectionPointContainer
    STDMETHODIMP    EnumConnectionPoints(IEnumConnectionPoints **ppEnum);
    STDMETHODIMP    FindConnectionPoint(REFIID riid,
                                        IConnectionPoint **ppcp);
};

#endif //_ULSAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\sputils.h ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		sputils.h
	Content:	This file contains the help functions for the service provider.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#ifndef _ILS_SP_UTILS_H_
#define _ILS_SP_UTILS_H_

#include <pshpack8.h>

inline BOOL MyIsBadWritePtr ( VOID *p, ULONG cb )
{
	return (p == NULL || IsBadWritePtr (p, cb));
}

inline BOOL MyIsBadReadPtr ( VOID *p, ULONG cb )
{
	return (p == NULL || IsBadReadPtr (p, cb));
}

inline BOOL MyIsBadExecPtr ( VOID *p, ULONG cb )
{
	return MyIsBadReadPtr (p, cb);
}

inline BOOL MyIsWindow ( HWND h )
{
	return (h != NULL && IsWindow (h));
}

inline BOOL MyIsGoodString ( const TCHAR *psz )
{
	return (psz != NULL && *psz != TEXT ('\0'));
}

inline BOOL MyIsBadString ( const TCHAR *psz )
{
	return (psz == NULL || *psz == TEXT ('\0'));
}


TCHAR *My_strdup ( const TCHAR *pszToDup );

inline TCHAR *DuplicateGoodString ( const TCHAR *pszSrc )
{
	return (MyIsGoodString (pszSrc) ? My_strdup (pszSrc) : NULL);
}


BOOL KeepUiResponsive ( VOID );

VOID GetGuidString ( GUID *pGuid, TCHAR *pszGuid ); // guid --> string
VOID GetStringGuid ( TCHAR *pszGuid, GUID *pGuid ); // string --> guid
INT HexChar2Val ( TCHAR c );
BOOL IsValidGuid ( GUID *pGuid );
VOID GetLongString ( LONG, TCHAR * ); // long --> string
LONG GetStringLong ( TCHAR *pszVal ); // string --> long
VOID GetIPAddressString ( TCHAR *pszIPAddress, DWORD dwIPAddress );

ULONG My_lstrlen ( const TCHAR *psz );
VOID My_lstrcpy ( TCHAR *pszDst, const TCHAR *pszSrc );
INT My_lstrcmpi ( const TCHAR *p, const TCHAR *q );
TCHAR *My_strchr ( const TCHAR *psz, TCHAR c );
BOOL My_isspace ( TCHAR ch );
BOOL IsSameMemory ( const BYTE *pb1, const BYTE *pb2, DWORD cbSize );
BYTE *MyBinDup ( const BYTE *pbToDup, ULONG cbToDup );

BOOL GetRegistrySettings ( VOID );
BOOL GetRegValueLong ( HKEY hKey, const TCHAR *pszKey, LONG	*plValue, LONG lDefValue );


#include <poppack.h>

#endif // _ILS_SP_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\ulsldap.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       ulsldap.h
//  Content:    This file contains the declaration for LDAP function calls
//  History:
//      Tue 08-Oct-1996 08:54:45  -by-  Lon-Chan Chu [lonchanc]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#ifndef _ILS_LDAP_H_
#define _ILS_LDAP_H_

#include <pshpack8.h>

//
// Asynchronous request result:
//
// **********************************************************************************
//      Message                                                 wParam  lParam
// **********************************************************************************
//
#define WM_ILS_ASYNC_RES                (WM_USER+0x1001)

// client object
#define WM_ILS_REGISTER_CLIENT          (WM_ILS_ASYNC_RES+0) // uMsgID  hResult
#define WM_ILS_UNREGISTER_CLIENT        (WM_ILS_ASYNC_RES+1) // uMsgID  hResult
#define WM_ILS_SET_CLIENT_INFO          (WM_ILS_ASYNC_RES+2) // uMsgID  hResult
#define WM_ILS_RESOLVE_CLIENT           (WM_ILS_ASYNC_RES+3)// uMsgID  PLDAP_USERINFO_RES
#define WM_ILS_ENUM_CLIENTS             (WM_ILS_ASYNC_RES+4)// uMsgID  PLDAP_ENUM
#define WM_ILS_ENUM_CLIENTINFOS         (WM_ILS_ASYNC_RES+5)// uMsgID  PLDAP_ENUM

// protocol object
#define WM_ILS_REGISTER_PROTOCOL        (WM_ILS_ASYNC_RES+6) // uMsgID  hResult
#define WM_ILS_UNREGISTER_PROTOCOL      (WM_ILS_ASYNC_RES+7) // uMsgID  hResult
#define WM_ILS_SET_PROTOCOL_INFO        (WM_ILS_ASYNC_RES+8) // uMsgID  hResult
#define WM_ILS_RESOLVE_PROTOCOL         (WM_ILS_ASYNC_RES+9)// uMsgID  PLDAP_PROTINFO_RES
#define WM_ILS_ENUM_PROTOCOLS           (WM_ILS_ASYNC_RES+10)// uMsgID  PLDAP_ENUM

#ifdef ENABLE_MEETING_PLACE
// meeting object
#define WM_ILS_REGISTER_MEETING         (WM_ILS_ASYNC_RES+11)
#define WM_ILS_UNREGISTER_MEETING       (WM_ILS_ASYNC_RES+12)
#define WM_ILS_SET_MEETING_INFO         (WM_ILS_ASYNC_RES+13)
#define WM_ILS_RESOLVE_MEETING          (WM_ILS_ASYNC_RES+14)
#define WM_ILS_ENUM_MEETINGINFOS        (WM_ILS_ASYNC_RES+15)
#define WM_ILS_ENUM_MEETINGS            (WM_ILS_ASYNC_RES+16)
#define WM_ILS_ADD_ATTENDEE             (WM_ILS_ASYNC_RES+17)
#define WM_ILS_REMOVE_ATTENDEE          (WM_ILS_ASYNC_RES+18)
#define WM_ILS_ENUM_ATTENDEES           (WM_ILS_ASYNC_RES+19)
#define WM_ILS_CANCEL                   (WM_ILS_ASYNC_RES+20)
#else
#define WM_ILS_CANCEL                   (WM_ILS_ASYNC_RES+11)
#endif

#define WM_ILS_LAST_ONE                 WM_ILS_CANCEL

// client notification
#define WM_ILS_CLIENT_NEED_RELOGON      (WM_ILS_ASYNC_RES+51)// fPrimary  pszServerName
#define WM_ILS_CLIENT_NETWORK_DOWN      (WM_ILS_ASYNC_RES+52)// fPrimary  pszServerName

#ifdef ENABLE_MEETING_PLACE
// meeting notification
#define WM_ILS_MEETING_NEED_RELOGON     (WM_ILS_ASYNC_RES+61)
#define WM_ILS_MEETING_NETWORK_DOWN     (WM_ILS_ASYNC_RES+62)
#endif


//
// Constants
//
#define INVALID_OFFSET			0
#define INVALID_USER_FLAGS		-1	// used in LDAP_USERINFO dwFlags

#ifdef ENABLE_MEETING_PLACE
#define INVALID_MEETING_FLAGS	0	// used in LDAP_MEETINFO dwFlags
#define INVALID_MEETING_TYPE	0	// used in LDAP_MEETINFO lMeetingType
#define INVALID_ATTENDEE_TYPE	0	// used in LDAP_MEETINFO lAttendeeType
#endif

//
// Asynchronous response info structures
//
typedef struct tagLDAPAsyncInfo
{
    ULONG           uMsgID;
}
    LDAP_ASYNCINFO, *PLDAP_ASYNCINFO;

typedef struct tagLDAPEnum
{
    ULONG           uSize;
    HRESULT         hResult;
    ULONG           cItems;
    ULONG           uOffsetItems;
}
    LDAP_ENUM, *PLDAP_ENUM;

typedef struct tagLDAPClientInfo
{
    ULONG           uSize;
    // user object attributes
    ULONG           uOffsetCN;
    ULONG           uOffsetFirstName;
    ULONG           uOffsetLastName;
    ULONG           uOffsetEMailName;
    ULONG           uOffsetCityName;
    ULONG           uOffsetCountryName;
    ULONG           uOffsetComment;
    ULONG           uOffsetIPAddress;
    DWORD           dwFlags;        // 0, private; 1, public
    // app object attributes
    ULONG           uOffsetAppName;
    ULONG           uOffsetAppMimeType;
    GUID            AppGuid;
    // app extended attributes to add, modify, and remove
    ULONG           cAttrsToAdd;
    ULONG           uOffsetAttrsToAdd;
    ULONG           cAttrsToModify;
    ULONG           uOffsetAttrsToModify;
    ULONG           cAttrsToRemove;
    ULONG           uOffsetAttrsToRemove;
	// for notification of enum-user-infos
	ULONG			cAttrsReturned;
	ULONG			uOffsetAttrsReturned;
}
	LDAP_CLIENTINFO, *PLDAP_CLIENTINFO;


typedef struct tagLDAPClientInfoRes
{
    ULONG           uSize;
    HRESULT         hResult;
    LDAP_CLIENTINFO lci;
}
	LDAP_CLIENTINFO_RES, *PLDAP_CLIENTINFO_RES;

typedef struct tagLDAPProtocolInfo
{
    ULONG           uSize;
	// protocol standard attributes
    ULONG           uOffsetName;
    ULONG           uPortNumber;
    ULONG           uOffsetMimeType;
}
    LDAP_PROTINFO, *PLDAP_PROTINFO;

typedef struct tagLDAPProtInfoRes
{
    ULONG           uSize;
    HRESULT         hResult;
    LDAP_PROTINFO   lpi;
}
    LDAP_PROTINFO_RES, *PLDAP_PROTINFO_RES;

#ifdef ENABLE_MEETING_PLACE
typedef struct tagLDAPMeetingInfo
{
    ULONG           uSize;
	// meeting standard attributes
    LONG            lMeetingPlaceType;
    LONG            lAttendeeType;
    ULONG           uOffsetMeetingPlaceID;
    ULONG           uOffsetDescription;
    ULONG           uOffsetHostName;
    ULONG           uOffsetHostIPAddress;
    // meeting extended attributes to add, modify, and remove
    ULONG           cAttrsToAdd;
    ULONG           uOffsetAttrsToAdd;
    ULONG           cAttrsToModify;
    ULONG           uOffsetAttrsToModify;
    ULONG           cAttrsToRemove;
    ULONG           uOffsetAttrsToRemove;
	// for notification of enum-meeting-infos
	ULONG			cAttrsReturned;
	ULONG			uOffsetAttrsReturned;
}
    LDAP_MEETINFO, *PLDAP_MEETINFO;
#endif


#ifdef ENABLE_MEETING_PLACE
typedef struct tagLDAPMeetingInfoRes
{
    ULONG               uSize;
    HRESULT             hResult;
    LDAP_MEETINFO       lmi;
}
    LDAP_MEETINFO_RES, *PLDAP_MEETINFO_RES;
#endif


// Initialization

HRESULT UlsLdap_Initialize (
    HWND            hwndCallback);

HRESULT UlsLdap_Deinitialize (void);

HRESULT UlsLdap_Cancel (
    ULONG           uMsgID);


// Clients related

HRESULT UlsLdap_RegisterClient (
    DWORD_PTR           dwContext,
    SERVER_INFO         *pServer,
    PLDAP_CLIENTINFO    pCleintInfo,
    PHANDLE             phClient,
    PLDAP_ASYNCINFO     pAsyncInfo );

HRESULT UlsLdap_UnRegisterClient (
    HANDLE              hClient,
    PLDAP_ASYNCINFO     pAsyncInfo );

HRESULT UlsLdap_SetClientInfo (
    HANDLE              hClient,
    PLDAP_CLIENTINFO    pInfo,
    PLDAP_ASYNCINFO     pAsyncInfo );

HRESULT UlsLdap_EnumClients (
    SERVER_INFO         *pServer,
    LPTSTR              pszFilter,
    PLDAP_ASYNCINFO     pAsyncInfo );

HRESULT UlsLdap_ResolveClient (
    SERVER_INFO         *pServer,
    LPTSTR              pszUserName,
    LPTSTR              pszAppName,
    LPTSTR              pszProtName,
    LPTSTR              pszAttrNameList,
    ULONG               cAttrNames,
    PLDAP_ASYNCINFO     pAsyncInfo );

HRESULT UlsLdap_EnumClientInfos (
    SERVER_INFO         *pServer,
    LPTSTR              pszAttrNameList,
    ULONG               cAttrNames,
    LPTSTR              pszFilter,
    PLDAP_ASYNCINFO     pAsyncInfo );


// Protocols related

HRESULT UlsLdap_RegisterProtocol (
    HANDLE          hApp,
    PLDAP_PROTINFO  pProtInfo,
    PHANDLE         phProt,
    PLDAP_ASYNCINFO pAsyncInfo );

HRESULT UlsLdap_UnRegisterProtocol (
    HANDLE          hProt,
    PLDAP_ASYNCINFO pAsyncInfo );

HRESULT UlsLdap_VirtualUnRegisterProtocol (
    HANDLE          hProt );

HRESULT UlsLdap_SetProtocolInfo (
    HANDLE          hProt,
    PLDAP_PROTINFO  pInfo,
    PLDAP_ASYNCINFO pAsyncInfo );

HRESULT UlsLdap_EnumProtocols (
    SERVER_INFO     *pServer,
    LPTSTR          pszUserName,
    LPTSTR          pszAppName,
    PLDAP_ASYNCINFO pAsyncInfo );

HRESULT UlsLdap_ResolveProtocol (
    SERVER_INFO     *pServer,
    LPTSTR          pszUserName,
    LPTSTR          pszAppName,
    LPTSTR          pszProtName,
    LPTSTR          pszAnyAttrNameList,
    ULONG           cAttrNames,
    PLDAP_ASYNCINFO pAsyncInfo );


#ifdef ENABLE_MEETING_PLACE
// Meetings related

HRESULT UlsLdap_RegisterMeeting(
    DWORD           dwContext,
    SERVER_INFO     *pServer,
    PLDAP_MEETINFO  pMeetInfo,
    PHANDLE         phMeeting,
    PLDAP_ASYNCINFO pAsyncInfo );

HRESULT UlsLdap_UnRegisterMeeting(
    HANDLE          hMeeting,
    PLDAP_ASYNCINFO pAsyncInfo );

HRESULT UlsLdap_EnumMeetingInfos(
    SERVER_INFO     *pServer,
    LPTSTR          pszAnyAttrNameList,
    ULONG           cAnyAttrNames,
    LPTSTR          pszFilter,
    PLDAP_ASYNCINFO pAsyncInfo );

HRESULT UlsLdap_EnumMeetings(
    SERVER_INFO     *pServer,
    LPTSTR          pszFilter,
    PLDAP_ASYNCINFO pAsyncInfo );

HRESULT UlsLdap_ResolveMeeting(
    SERVER_INFO     *pServer,
    LPTSTR          pszMeetingID,
    LPTSTR          pszAnyAttrNameList,
    ULONG           cAnyAttrNames,
    PLDAP_ASYNCINFO pAsyncInfo );

HRESULT UlsLdap_SetMeetingInfo(
    SERVER_INFO     *pServer,
    LPTSTR          pszMeetingID,
    PLDAP_MEETINFO  pMeetInfo,
    PLDAP_ASYNCINFO pAsyncInfo );

HRESULT UlsLdap_AddAttendee(
    SERVER_INFO     *pServer,
    LPTSTR          pszMeetingID,
    ULONG           cAttendees,
    LPTSTR          pszAttendeeID,
    PLDAP_ASYNCINFO pAsyncInfo  );

HRESULT UlsLdap_RemoveAttendee(
    SERVER_INFO     *pServer,
    LPTSTR          pszMeetingID,
    ULONG           cAttendees,
    LPTSTR          pszAttendeeID,
    PLDAP_ASYNCINFO pAsyncInfo  );

HRESULT UlsLdap_EnumAttendees(
    SERVER_INFO     *pServer,
    LPTSTR          pszMeetingID,
    LPTSTR          pszFilter,
    PLDAP_ASYNCINFO pAsyncInfo  );

#endif // ENABLE_MEETING_PLACE



const TCHAR *UlsLdap_GetStdAttrNameString (
    ILS_STD_ATTR_NAME StdName );

const TCHAR *UlsLdap_GetExtAttrNamePrefix ( VOID );


#include <poppack.h>

#endif // _ILS_LDAP_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\ulsapp.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       ulsapp.cpp
//  Content:    This file contains the Application object.
//  History:
//      Wed 17-Apr-1996 11:13:54  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#include "ulsp.h"
#include "ulsapp.h"
#include "ulsprot.h"
#include "attribs.h"
#include "callback.h"

//****************************************************************************
// Event Notifiers
//****************************************************************************
//
//****************************************************************************
// HRESULT
// OnNotifyGetProtocolResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
OnNotifyGetProtocolResult (IUnknown *pUnk, void *pv)
{
    POBJRINFO pobjri = (POBJRINFO)pv;

    ((IULSApplicationNotify*)pUnk)->GetProtocolResult(pobjri->uReqID,
                                                      (IULSAppProtocol *)pobjri->pv,
                                                      pobjri->hResult);
    return S_OK;
}

//****************************************************************************
// HRESULT
// OnNotifyEnumProtocolsResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
OnNotifyEnumProtocolsResult (IUnknown *pUnk, void *pv)
{
    CEnumNames  *penum  = NULL;
    PENUMRINFO  peri    = (PENUMRINFO)pv;
    HRESULT     hr      = peri->hResult;

    if (SUCCEEDED(hr))
    {
        // Create a Application enumerator
        //
        penum = new CEnumNames;

        if (penum != NULL)
        {
            hr = penum->Init((LPTSTR)peri->pv, peri->cItems);

            if (SUCCEEDED(hr))
            {
                penum->AddRef();
            }
            else
            {
                delete penum;
                penum = NULL;
            };
        }
        else
        {
            hr = ULS_E_MEMORY;
        };
    };

    // Notify the sink object
    //
    ((IULSApplicationNotify*)pUnk)->EnumProtocolsResult(peri->uReqID,
                                                        penum != NULL ? 
                                                        (IEnumULSNames *)penum :
                                                        NULL,
                                                        hr);

    if (penum != NULL)
    {
        penum->Release();
    };
    return hr;
}

//****************************************************************************
// Class Implementation
//****************************************************************************
//
//****************************************************************************
// CUlsApp::CUlsApp (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CUlsApp::CUlsApp (void)
{
    cRef        = 0;
    szServer    = NULL;
    szUser      = NULL;
    guid        = GUID_NULL;
    szName      = NULL;
    szMimeType  = NULL;
    pAttrs      = NULL;
    pConnPt     = NULL;

    return;
}

//****************************************************************************
// CUlsApp::~CUlsApp (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CUlsApp::~CUlsApp (void)
{
    if (szServer != NULL)
        FreeLPTSTR(szServer);
    if (szUser != NULL)
        FreeLPTSTR(szUser);
    if (szName != NULL)
        FreeLPTSTR(szName);
    if (szMimeType != NULL)
        FreeLPTSTR(szMimeType);

    // Release attribute object
    //
    if (pAttrs != NULL)
    {
        pAttrs->Release();
    };

    // Release the connection point
    //
    if (pConnPt != NULL)
    {
        pConnPt->ContainerReleased();
        ((IConnectionPoint*)pConnPt)->Release();
    };

    return;
}

//****************************************************************************
// STDMETHODIMP
// CUlsApp::Init (LPTSTR szServerName, LPTSTR szUserName, PLDAP_APPINFO pai)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsApp::Init (LPTSTR szServerName, LPTSTR szUserName, PLDAP_APPINFO pai)
{
    HRESULT hr;

    // Validate parameter
    //
    if ((pai->uSize != sizeof(*pai))    ||
//      (pai->guid  == GUID_NULL)       || // Allow null GUID for http register
        (pai->uOffsetName       == 0)   ||
        (pai->uOffsetMimeType  == 0))
    {
        return ULS_E_PARAMETER;
    };

    if ((pai->cAttributes != 0) && (pai->uOffsetAttributes == 0))
    {
        return ULS_E_PARAMETER;        
    };

    // Remember application GUID
    //
    guid = pai->guid;

    // Remember the server name
    //
    hr = SetLPTSTR(&szServer, szServerName);

    if (SUCCEEDED(hr))
    {
        hr = SetLPTSTR(&szUser, szUserName);

        if (SUCCEEDED(hr))
        {
            hr = SetLPTSTR(&szName,
                           (LPCTSTR)(((PBYTE)pai)+pai->uOffsetName));

            if (SUCCEEDED(hr))
            {
                hr = SetLPTSTR(&szMimeType,
                               (LPCTSTR)(((PBYTE)pai)+pai->uOffsetMimeType));

                if (SUCCEEDED(hr))
                {
                    CAttributes *pNewAttrs;

                    // Build the attribute object
                    //
                    pNewAttrs = new CAttributes (ULS_ATTRACCESS_NAME_VALUE);

                    if (pNewAttrs != NULL)
                    {
                        if (pai->cAttributes != 0)
                        {
                            hr = pNewAttrs->SetAttributePairs((LPTSTR)(((PBYTE)pai)+pai->uOffsetAttributes),
                                                              pai->cAttributes);
                        };

                        if (SUCCEEDED(hr))
                        {
                            pAttrs = pNewAttrs;
                            pNewAttrs->AddRef();
                        }
                        else
                        {
                            delete pNewAttrs;
                        };
                    }
                    else
                    {
                        hr = ULS_E_MEMORY;
                    };
                };
            };
        };
    };

    if (SUCCEEDED(hr))
    {
        // Make the connection point
        //
        pConnPt = new CConnectionPoint (&IID_IULSApplicationNotify,
                                        (IConnectionPointContainer *)this);
        if (pConnPt != NULL)
        {
            ((IConnectionPoint*)pConnPt)->AddRef();
            hr = NOERROR;
        }
        else
        {
            hr = ULS_E_MEMORY;
        };
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CUlsApp::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsApp::QueryInterface (REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (riid == IID_IULSApplication || riid == IID_IUnknown)
    {
        *ppv = (IULSUser *) this;
    }
    else
    {
        if (riid == IID_IConnectionPointContainer)
        {
            *ppv = (IConnectionPointContainer *) this;
        };
    };

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        return ULS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CUlsApp::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:14:17  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CUlsApp::AddRef (void)
{
    cRef++;
    return cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CUlsApp::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:14:26  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CUlsApp::Release (void)
{
    cRef--;

    if (cRef == 0)
    {
        delete this;
        return 0;
    }
    else
    {
        return cRef;
    };
}

//****************************************************************************
// STDMETHODIMP
// CUlsApp::NotifySink (void *pv, CONN_NOTIFYPROC pfn)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsApp::NotifySink (void *pv, CONN_NOTIFYPROC pfn)
{
    HRESULT hr = S_OK;

    if (pConnPt != NULL)
    {
        hr = pConnPt->Notify(pv, pfn);
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CUlsApp::GetID (GUID *pGUID)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsApp::GetID (GUID *pGUID)
{
    // Validate parameter
    //
    if (pGUID == NULL)
    {
        return ULS_E_POINTER;
    };
    
    *pGUID = guid;

    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CUlsApp::GetName (BSTR *pbstrAppName)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsApp::GetName (BSTR *pbstrAppName)
{
    // Validate parameter
    //
    if (pbstrAppName == NULL)
    {
        return ULS_E_POINTER;
    };

    return LPTSTR_to_BSTR(pbstrAppName, szName);
}

//****************************************************************************
// STDMETHODIMP
// CUlsApp::GetMimeType (BSTR *pbstrMimeType)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsApp::GetMimeType (BSTR *pbstrMimeType)
{
    // Validate parameter
    //
    if (pbstrMimeType == NULL)
    {
        return ULS_E_POINTER;
    };

    return LPTSTR_to_BSTR(pbstrMimeType, szMimeType);
}

//****************************************************************************
// STDMETHODIMP
// CUlsApp::GetAttributes (IULSAttributes **ppAttributes)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsApp::GetAttributes (IULSAttributes **ppAttributes)
{
    // Validate parameter
    //
    if (ppAttributes == NULL)
    {
        return ULS_E_POINTER;
    };

    *ppAttributes = pAttrs;
    pAttrs->AddRef();

    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CUlsApp::GetProtocol (BSTR bstrProtocolID, ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsApp::GetProtocol (BSTR bstrProtocolID, IULSAttributes *pAttributes, ULONG *puReqID)
{
    LDAP_ASYNCINFO ldai; 
    LPTSTR pszID;
    HRESULT hr;

    // Validate parameter
    //
    if (bstrProtocolID == NULL || puReqID == NULL)
        return ULS_E_POINTER;

	// Convert protocol name
	//
    hr = BSTR_to_LPTSTR(&pszID, bstrProtocolID);
	if (hr != S_OK)
		return hr;

	// Get arbitrary attribute name list if any
	//
	ULONG cAttrNames = 0;
	ULONG cbNames = 0;
	TCHAR *pszAttrNameList = NULL;
	if (pAttributes != NULL)
	{
		hr = ((CAttributes *) pAttributes)->GetAttributeList (&pszAttrNameList, &cAttrNames, &cbNames);
		if (hr != S_OK)
			return hr;
	}

	hr = ::UlsLdap_ResolveProtocol (szServer, szUser, szName, pszID,
										pszAttrNameList, cAttrNames, &ldai);
	if (hr != S_OK)
		goto MyExit;

	// If updating server was successfully requested, wait for the response
	//
	REQUESTINFO ri;
	ZeroMemory (&ri, sizeof (ri));
	ri.uReqType = WM_ULS_RESOLVE_PROTOCOL;
	ri.uMsgID = ldai.uMsgID;
	ri.pv     = (PVOID) this;
	ri.lParam = NULL;

	// Remember this request
	//
	hr = g_pReqMgr->NewRequest(&ri);
	if (SUCCEEDED(hr))
	{
	    // Make sure the objects do not disappear before we get the response
	    //
	    this->AddRef();

	    // Return the request ID
	    //
	    *puReqID = ri.uReqID;
	};

MyExit:

	if (pszAttrNameList != NULL)
		FreeLPTSTR (pszAttrNameList);

	if (pszID != NULL)
		FreeLPTSTR(pszID);

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CUlsApp::GetProtocolResult (ULONG uReqID, PLDAP_PROTINFO_RES ppir)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsApp::GetProtocolResult (ULONG uReqID, PLDAP_PROTINFO_RES ppir)
{
    CUlsProt *pp;
    OBJRINFO objri;

    // Default to the server's result
    //
    objri.hResult = ppir->hResult;

    if (SUCCEEDED(objri.hResult))
    {
        // The server returns PROTINFO, create a Application object
        //
        pp = new CUlsProt;

        if (pp != NULL)
        {
            objri.hResult = pp->Init(szServer, szUser, szName, &ppir->lpi);
            if (SUCCEEDED(objri.hResult))
            {
                pp->AddRef();
            }
            else
            {
                delete pp;
                pp = NULL;
            };
        }
        else
        {
            objri.hResult = ULS_E_MEMORY;
        };
    }
    else
    {
        pp = NULL;
    };

    // Package the notification info
    //
    objri.uReqID = uReqID;
    objri.pv = (void *)(pp == NULL ? NULL : (IULSAppProtocol *)pp);
    NotifySink((void *)&objri, OnNotifyGetProtocolResult);

    if (pp != NULL)
    {
        pp->Release();
    };
    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CUlsApp::EnumProtocols (ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsApp::EnumProtocols (ULONG *puReqID)
{
    LDAP_ASYNCINFO ldai; 
    HRESULT hr;

    // Validate parameter
    //
    if (puReqID == NULL)
    {
        return ULS_E_POINTER;
    };

    hr = ::UlsLdap_EnumProtocols(szServer, szUser, szName, &ldai);

    if (SUCCEEDED(hr))
    {
        REQUESTINFO ri;

        // If updating server was successfully requested, wait for the response
        //
        ri.uReqType = WM_ULS_ENUM_PROTOCOLS;
        ri.uMsgID = ldai.uMsgID;
        ri.pv     = (PVOID)this;
        ri.lParam = (LPARAM)NULL;

        hr = g_pReqMgr->NewRequest(&ri);

        if (SUCCEEDED(hr))
        {
            // Make sure the objects do not disappear before we get the response
            //
            this->AddRef();

            // Return the request ID
            //
            *puReqID = ri.uReqID;
        };
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CUlsApp::EnumProtocolsResult (ULONG uReqID, PLDAP_ENUM ple)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsApp::EnumProtocolsResult (ULONG uReqID, PLDAP_ENUM ple)
{
    ENUMRINFO eri;

    // Package the notification info
    //
    eri.uReqID  = uReqID;
    eri.hResult = ple->hResult;
    eri.cItems  = ple->cItems;
    eri.pv      = (void *)(((PBYTE)ple)+ple->uOffsetItems);
    NotifySink((void *)&eri, OnNotifyEnumProtocolsResult);
    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CUlsApp::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
//
// History:
//  Wed 17-Apr-1996 11:15:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsApp::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
{
    CEnumConnectionPoints *pecp;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return ULS_E_POINTER;
    };
    
    // Assume failure
    //
    *ppEnum = NULL;

    // Create an enumerator
    //
    pecp = new CEnumConnectionPoints;
    if (pecp == NULL)
        return ULS_E_MEMORY;

    // Initialize the enumerator
    //
    hr = pecp->Init((IConnectionPoint *)pConnPt);
    if (FAILED(hr))
    {
        delete pecp;
        return hr;
    };

    // Give it back to the caller
    //
    pecp->AddRef();
    *ppEnum = pecp;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CUlsApp::FindConnectionPoint(REFIID riid, IConnectionPoint **ppcp)
//
// History:
//  Wed 17-Apr-1996 11:15:09  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsApp::FindConnectionPoint(REFIID riid, IConnectionPoint **ppcp)
{
    IID siid;
    HRESULT hr;

    // Validate parameters
    //
    if (ppcp == NULL)
    {
        return ULS_E_POINTER;
    };
    
    // Assume failure
    //
    *ppcp = NULL;

    if (pConnPt != NULL)
    {
        hr = pConnPt->GetConnectionInterface(&siid);

        if (SUCCEEDED(hr))
        {
            if (riid == siid)
            {
                *ppcp = (IConnectionPoint *)pConnPt;
                (*ppcp)->AddRef();
                hr = S_OK;
            }
            else
            {
                hr = ULS_E_NO_INTERFACE;
            };
        };
    }
    else
    {
        hr = ULS_E_NO_INTERFACE;
    };

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\ulsmeet.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       ulsmeet.cpp
//
//  Contents:   MeetingPlace Object implementation
//
//  Classes:    CIlsMeetingPlace, CEnumMeetingPlace, CIlsAttendee, CEnumAttendee
//
//  Functions:  
//
//  History:    11/25/96 Shishir Pardikar [shishirp] Created
//
//  Notes:
//
//----------------------------------------------------------------------------

#include "ulsp.h"

#ifdef ENABLE_MEETING_PLACE

#include "ulsmeet.h"
#include "callback.h"
#include "filter.h"



/***************************************************************************
Notification functions.
These functions are called by the general purpose connectionpoint object.
These are called for each Sink object attached to the connection point using
"Advise" member function of the IConnectionPoint interface
****************************************************************************/

//****************************************************************************
//
// HRESULT OnNotifyRegisterMeetingPlaceResult(IUnknown *pUnk, void *pv) 
// 
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
//  Notes:
//
//****************************************************************************
HRESULT
OnNotifyRegisterMeetingPlaceResult(IUnknown *pUnk, void *pv)
{
    POBJRINFO pobjri = (POBJRINFO)pv;

    ((IIlsMeetingPlaceNotify *)pUnk)->RegisterResult(pobjri->uReqID, pobjri->hResult);

    return S_OK;

}

//****************************************************************************
//
// HRESULT OnNotifyUnregisterMeetingPlaceResult(IUnknown *pUnk, void *pv) 
// 
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
//  Notes:
//
//****************************************************************************
HRESULT
OnNotifyUnregisterMeetingPlaceResult(IUnknown *pUnk, void *pv)
{
    POBJRINFO pobjri = (POBJRINFO)pv;

    ((IIlsMeetingPlaceNotify *)pUnk)->RegisterResult(pobjri->uReqID, pobjri->hResult);

    return S_OK;

}

//****************************************************************************
//
// HRESULT OnNotifyUpdateMeetingPlaceResult(IUnknown *pUnk, void *pv) 
// 
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
//  Notes:
//
//****************************************************************************
HRESULT
OnNotifyUpdateMeetingPlaceResult(IUnknown *pUnk, void *pv)
{
    POBJRINFO pobjri = (POBJRINFO)pv;

    ((IIlsMeetingPlaceNotify *)pUnk)->UpdateResult(pobjri->uReqID, pobjri->hResult);

    return S_OK;

}

//****************************************************************************
//
// HRESULT OnNotifyAddAttendeeResult(IUnknown *pUnk, void *pv) 
// 
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
//  Notes:
//
//****************************************************************************
HRESULT
OnNotifyAddAttendeeResult(IUnknown *pUnk, void *pv)
{
    POBJRINFO pobjri = (POBJRINFO)pv;

    ((IIlsMeetingPlaceNotify *)pUnk)->AttendeeChangeResult(pobjri->uReqID, pobjri->hResult);

    return S_OK;

}

//****************************************************************************
//
// HRESULT OnNotifyRemoveAttendeeResult(IUnknown *pUnk, void *pv) 
// 
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
//  Notes:
//
//****************************************************************************
HRESULT
OnNotifyRemoveAttendeeResult(IUnknown *pUnk, void *pv)
{
    POBJRINFO pobjri = (POBJRINFO)pv;

    ((IIlsMeetingPlaceNotify *)pUnk)->AttendeeChangeResult(pobjri->uReqID, pobjri->hResult);

    return S_OK;
}

//****************************************************************************
//
// HRESULT OnNotifyEnumAttendeeNamesResult(IUnknown *pUnk, void *pv) 
// 
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
//  Notes:
//
//****************************************************************************
HRESULT OnNotifyEnumAttendeeNamesResult(IUnknown *pUnk, void *pv)
{
    CEnumNames  *penum   = NULL;
    PENUMRINFO  peri    = (PENUMRINFO)pv;
    HRESULT     hr      = peri->hResult;

    // Create the enumerator only when there is anything to be enumerated
    //
    if (hr == NOERROR)
    {
        ASSERT (peri->pv != NULL);

        // Create an AttendeeName enumerator
        //
        penum = new CEnumNames;

        if (penum != NULL)
        {
            hr = penum->Init((LPTSTR)peri->pv, peri->cItems);

            if (SUCCEEDED(hr))
            {
                penum->AddRef();
            }
            else
            {
                delete penum;
                penum = NULL;
            };
        }
        else
        {
            hr = ILS_E_MEMORY;
        };
    };

    // Notify the sink object
    //
    ((IIlsMeetingPlaceNotify*)pUnk)->EnumAttendeeNamesResult(peri->uReqID,
                                             penum != NULL ? 
                                             (IEnumIlsNames *)penum :
                                             NULL,
                                             hr);

    if (penum != NULL)
    {
        penum->Release();
    };
    return hr;
}


//****************************************************************************
//
//CIlsMeetingPlace class implementation
//
//****************************************************************************



//****************************************************************************
// Method:  CIlsMeetingPlace::CIlsMeetingPlace (void)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

CIlsMeetingPlace::
CIlsMeetingPlace ( VOID )
:m_cRef (0),
 m_ulState (NULL),
 m_pszMeetingPlaceID (NULL),
 m_lMeetingPlaceType (UNDEFINED_TYPE),
 m_lAttendeeType (UNDEFINED_TYPE),
 m_pszHostName (NULL),
 m_pszHostIPAddress (NULL),
 m_pszDescription (NULL),
 m_hMeetingPlace (NULL),
 m_dwFlags (0),
 m_pIlsServer (NULL),
 m_pConnectionPoint (NULL)
{
	m_ExtendedAttrs.SetAccessType (ILS_ATTRTYPE_NAME_VALUE);
}


//****************************************************************************
// CIlsMeetingPlace::~CIlsMeetingPlace (void)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

CIlsMeetingPlace::
~CIlsMeetingPlace ( VOID )
{
	::MemFree (m_pszMeetingPlaceID);
    ::MemFree (m_pszHostName);
    ::MemFree (m_pszHostIPAddress);
    ::MemFree (m_pszDescription);

    // Release the connection point
    //
    if (m_pConnectionPoint != NULL)
    {
        m_pConnectionPoint->ContainerReleased();
        ((IConnectionPoint*)m_pConnectionPoint)->Release();
    }

    // Free up the server object
    //
    if (m_pIlsServer != NULL)
    	m_pIlsServer->Release ();
}


//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::AllocMeetInfo(PLDAP_MEETINFO *ppMeetInfo, ULONG ulMask)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************
STDMETHODIMP
CIlsMeetingPlace::AllocMeetInfo(PLDAP_MEETINFO *ppMeetInfo, ULONG ulMask)
{
    HRESULT hr = NOERROR;

    PLDAP_MEETINFO pMeetInfo = NULL;
    LPBYTE  pBuffRunning;
    DWORD   cbT, cbAttribSize, cntAttrs;
    DWORD   cbTotalSize = sizeof(LDAP_MEETINFO);
    TCHAR   *pszPairs = NULL;

    ASSERT(m_pIlsServer != NULL);
    ASSERT(m_pszMeetingPlaceID != NULL);

    cbTotalSize += lstrlen(m_pszMeetingPlaceID)+1;
    cbTotalSize +=  (
                    (((ulMask & ILS_MEET_FLAG_DESCRIPTION_MODIFIED) 
                        && m_pszDescription)?(lstrlen(m_pszDescription)+1):0)
                    +(((ulMask & ILS_MEET_FLAG_HOST_NAME_MODIFIED) 
                        && m_pszHostName)?(lstrlen(m_pszHostName)+1):0)
                    +(((ulMask & ILS_MEET_FLAG_HOST_ADDRESS_MODIFIED) 
                        && m_pszHostIPAddress)?(lstrlen(m_pszHostIPAddress)+1):0)
                    );

    cbTotalSize *= sizeof(TCHAR);

    // if we need to send in the extended attributes, do that

    cbAttribSize = 0;
    if ((ulMask & ILS_MEET_FLAG_EXTENDED_ATTRIBUTES_MODIFIED)) {

        hr = m_ExtendedAttrs.GetAttributePairs(&pszPairs, &cntAttrs, &cbAttribSize);            

        if (!SUCCEEDED(hr)) {

            goto bailout;

        }        

    }

    
    cbTotalSize += cbAttribSize;

    // zeroized buffer
    pMeetInfo = (PLDAP_MEETINFO) ::MemAlloc (cbTotalSize);

    if (pMeetInfo == NULL) {

        hr = ILS_E_MEMORY;
        goto bailout;

    }    

    pMeetInfo->uSize = cbTotalSize;

    pMeetInfo->lMeetingPlaceType = m_lMeetingPlaceType;
    pMeetInfo->lAttendeeType = m_lAttendeeType;

    pBuffRunning = (LPBYTE)(pMeetInfo+1);

    memcpy(pBuffRunning, m_pszMeetingPlaceID, cbT = (lstrlen(m_pszMeetingPlaceID)+1)*sizeof(TCHAR));
    pMeetInfo->uOffsetMeetingPlaceID = (ULONG)((LPBYTE)pBuffRunning - (LPBYTE)pMeetInfo);
    pBuffRunning += cbT;

    if ((ulMask & ILS_MEET_FLAG_DESCRIPTION_MODIFIED) && m_pszDescription) {

        memcpy(pBuffRunning, m_pszDescription, cbT = (lstrlen(m_pszDescription)+1)*sizeof(TCHAR));
        pMeetInfo->uOffsetDescription = (ULONG)((LPBYTE)pBuffRunning - (LPBYTE)pMeetInfo);
        pBuffRunning += cbT;

    }

    if ((ulMask & ILS_MEET_FLAG_HOST_NAME_MODIFIED) && m_pszHostName) {

        memcpy(pBuffRunning, m_pszHostName, cbT = (lstrlen(m_pszHostName)+1)*sizeof(TCHAR));
        pMeetInfo->uOffsetHostName = (ULONG)((LPBYTE)pBuffRunning - (LPBYTE)pMeetInfo);
        pBuffRunning += cbT;

    }

    if ((ulMask & ILS_MEET_FLAG_HOST_ADDRESS_MODIFIED) && m_pszHostIPAddress) {

        memcpy(pBuffRunning, m_pszHostIPAddress, cbT = lstrlen(m_pszHostIPAddress)+1);
        pMeetInfo->uOffsetHostIPAddress = (ULONG)((LPBYTE)pBuffRunning - (LPBYTE)pMeetInfo);
        pBuffRunning += cbT;

    }

    if((ulMask & ILS_MEET_FLAG_EXTENDED_ATTRIBUTES_MODIFIED)) {

        if (pszPairs) {

            memcpy(pBuffRunning, pszPairs, cbAttribSize);
            pMeetInfo->uOffsetAttrsToAdd = (ULONG)((LPBYTE)pBuffRunning - (LPBYTE)pMeetInfo);
            pMeetInfo->cAttrsToAdd = cntAttrs;

            pBuffRunning += cbAttribSize;
        }

    }

    *ppMeetInfo = pMeetInfo;


bailout:

    if (!SUCCEEDED(hr)) {

        if (pMeetInfo) {

            ::MemFree (pMeetInfo);

        }

    }

    // the attribute pairs list needs to be freed 
    // whether we succeeded or not
    if (pszPairs) {
        
        ::MemFree (pszPairs);

    }

    return hr;
}


//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::Init(BSTR bstrMeetingPlaceID, LONG lMeetingPlaceType
//                            , LONG lAttendeeType)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************
STDMETHODIMP
CIlsMeetingPlace::Init(
        BSTR bstrMeetingPlaceID,
        LONG lMeetingPlaceType,
        LONG lAttendeeType)
{
    HRESULT hr;

    if (bstrMeetingPlaceID==NULL){
        return (ILS_E_PARAMETER);
    }

    ASSERT(m_ulState == ILS_UNREGISTERED);

    ASSERT(m_pIlsServer == NULL);

    ASSERT(m_pszMeetingPlaceID == NULL);

    hr = BSTR_to_LPTSTR(&m_pszMeetingPlaceID, bstrMeetingPlaceID);

    if (!SUCCEEDED(hr)) {
        goto bailout;
    }

    // Make the single connection point
    // When enumerating the ConnectionPointContainer
    // he is the single guy we will give out

    if (SUCCEEDED(hr)) {
        m_pConnectionPoint = new CConnectionPoint (&IID_IIlsMeetingPlaceNotify,
                                    (IConnectionPointContainer *)this);
        if (m_pConnectionPoint != NULL)
        {
            ((IConnectionPoint*)m_pConnectionPoint)->AddRef();
            hr = S_OK;
        }
        else
        {
            hr = ILS_E_MEMORY;
        }
    }
    
    if (SUCCEEDED(hr)) {
        m_lMeetingPlaceType = lMeetingPlaceType;
        m_lAttendeeType = lAttendeeType;
    }

bailout:
    if (!SUCCEEDED(hr)) {

        // do cleanup

        if (m_pszMeetingPlaceID) {
            ::MemFree (m_pszMeetingPlaceID);
            m_pszMeetingPlaceID = NULL; // general paranoia
        }

        if (m_pConnectionPoint) {
            delete m_pConnectionPoint;
            m_pConnectionPoint = NULL;
        }        
    }

    return hr;
}


//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::Init(LPTSTR lpszServer, PLDAP_MEETINFO pmi);
//
// Synopsis: This initializes the MeetingPlace object based on the MEETINFO structure
//           This is used to stuff data into the meeting object from
//           the response obtained from the server to the query _MEETINFO
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************
STDMETHODIMP
CIlsMeetingPlace::Init(
        CIlsServer *pIlsServer,
        PLDAP_MEETINFO  pmi
    )
{
    HRESULT hr;

    ASSERT(NULL==m_pszMeetingPlaceID);
    ASSERT(NULL==m_pIlsServer);

    //validate bstrMeetingPlaceID

    hr = SafeSetLPTSTR(&m_pszMeetingPlaceID, (LPCTSTR)(((PBYTE)pmi)+pmi->uOffsetMeetingPlaceID));

    if (!SUCCEEDED(hr)){
        goto bailout;
    }

    // set the state to registered

    m_ulState =  ILS_REGISTERED;

    // set the server field
	m_pIlsServer = pIlsServer;
	pIlsServer->AddRef ();

    hr = SafeSetLPTSTR(&m_pszDescription, (LPCTSTR)(((PBYTE)pmi)+pmi->uOffsetDescription));

    if (!SUCCEEDED(hr)) {
        goto bailout;
    }

    hr = SafeSetLPTSTR(&m_pszHostName, (LPCTSTR)(((PBYTE)pmi)+pmi->uOffsetHostName));

    if (!SUCCEEDED(hr)) {
        goto bailout;
    }

    hr = SafeSetLPTSTR(&m_pszHostIPAddress, (LPCTSTR)(((PBYTE)pmi)+pmi->uOffsetHostIPAddress));

    if (!SUCCEEDED(hr)) {
        goto bailout;
    }

    // Make the single connection point
    // When enumerating the ConnectionPointContainer
    // he is the single guy we will give out

    m_pConnectionPoint = new CConnectionPoint (&IID_IIlsMeetingPlaceNotify,
                                (IConnectionPointContainer *)this);
    if (m_pConnectionPoint != NULL)
    {
        ((IConnectionPoint*)m_pConnectionPoint)->AddRef();
        hr = S_OK;
    }
    else
    {
        hr = ILS_E_MEMORY;
    }
    if (SUCCEEDED(hr)) {

        m_lMeetingPlaceType =  pmi->lMeetingPlaceType;
        m_lAttendeeType = pmi->lAttendeeType;

    }

bailout:
    if (!SUCCEEDED(hr)) {

        // do cleanup

        if (m_pIlsServer != NULL)
        {
        	m_pIlsServer->Release ();
        	m_pIlsServer = NULL;
        }

        if (m_pszMeetingPlaceID) {
            ::MemFree (m_pszMeetingPlaceID);
            m_pszMeetingPlaceID = NULL; // general paranoia
        }

        if (m_pszDescription) {
            ::MemFree (m_pszDescription);
            m_pszDescription = NULL; // general paranoia
        }

        if (m_pszHostName) {
            ::MemFree (m_pszHostName);
            m_pszHostName = NULL;
        }

        if (m_pszHostIPAddress) {
            ::MemFree (m_pszHostIPAddress);
            m_pszHostIPAddress = NULL;
        }

        if (m_pConnectionPoint) {
            delete m_pConnectionPoint;
            m_pConnectionPoint = NULL;
        }        
        m_ulState = ILS_UNREGISTERED;
    }
    else {
        m_ulState = ILS_IN_SYNC;
    }

    return (hr);
}


//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::QueryInterface (REFIID riid, void **ppv)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP
CIlsMeetingPlace::QueryInterface (REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (riid == IID_IIlsMeetingPlace || riid == IID_IUnknown)
    {
        *ppv = (IIlsUser *) this;
    }
    else
    {
        if (riid == IID_IConnectionPointContainer)
        {
            *ppv = (IConnectionPointContainer *) this;
        };
    };

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        return ILS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CIlsMeetingPlace::AddRef (void)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP_(ULONG)
CIlsMeetingPlace::AddRef (void)
{
    DllLock();

	MyDebugMsg ((DM_REFCOUNT, "CIlsMeetingPlace::AddRef: ref=%ld\r\n", m_cRef));
    ::InterlockedIncrement (&m_cRef);
    return (ULONG) m_cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CIlsMeetingPlace::Release (void)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP_(ULONG)
CIlsMeetingPlace::Release (void)
{
    DllRelease();

	ASSERT (m_cRef > 0);

	MyDebugMsg ((DM_REFCOUNT, "CIlsMeetingPlace::Release: ref=%ld\r\n", m_cRef));
    if(::InterlockedDecrement (&m_cRef) == 0)
    {
	    delete this;
	    return 0;
    }
    return (ULONG) m_cRef;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::NotifySink (void *pv, CONN_NOTIFYPROC pfn)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP
CIlsMeetingPlace::NotifySink (void *pv, CONN_NOTIFYPROC pfn)
{
    HRESULT hr = S_OK;

    if (m_pConnectionPoint != NULL)
    {
        hr = m_pConnectionPoint->Notify(pv, pfn);
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::GetState (ULONG *pulState)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 12/10/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP
CIlsMeetingPlace::GetState (ULONG *pulState)
{

    // Validate parameter
    //

    *pulState = m_ulState;

    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::GetMeetingPlaceType (LONG *plMeetingPlaceType)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP
CIlsMeetingPlace::GetMeetingPlaceType (LONG *plMeetingPlaceType)
{

    // Validate parameter
    //

    *plMeetingPlaceType = m_lMeetingPlaceType;

    return NOERROR;
}


//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::GetAttendeeType (LONG *plAttendeeType)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP
CIlsMeetingPlace::GetAttendeeType (LONG *plAttendeeType)
{

    // Validate parameter
    //

    *plAttendeeType = m_lAttendeeType;

    return NOERROR;

}


//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::GetStandardAttribute (ILS_STD_ATTR_NAME   stdAttr, BSTR *pbstrStdAttr)
//
// History:
//  1-16-97 Shishir Pardikar
// Created.
//****************************************************************************
STDMETHODIMP
CIlsMeetingPlace::GetStandardAttribute(
    ILS_STD_ATTR_NAME   stdAttr,
    BSTR                *pbstrStdAttr
)
{
    LPTSTR lpszAttr = NULL;
    BOOL    fValid = TRUE;
    HRESULT hr;

    if (pbstrStdAttr == NULL) {

        return ILS_E_POINTER;

    }
    switch(stdAttr) {

    case ILS_STDATTR_MEETING_ID:
        lpszAttr = m_pszMeetingPlaceID;
        break;
    case ILS_STDATTR_MEETING_HOST_NAME:
        lpszAttr = m_pszHostName;
        break;

    case ILS_STDATTR_MEETING_HOST_IP_ADDRESS:
        lpszAttr = m_pszHostIPAddress;
        break;

    case ILS_STDATTR_MEETING_DESCRIPTION:
        lpszAttr = m_pszDescription;
        break;

    default:
        fValid = FALSE;
        break;
    }

    if (fValid) {
        if (lpszAttr){

            hr = LPTSTR_to_BSTR(pbstrStdAttr, lpszAttr);
        }
        else {

            *pbstrStdAttr = NULL;
            hr = NOERROR;

        }
    }
    else {

        hr = ILS_E_PARAMETER;

    }

    return (hr);
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::SetStandardAttribute (ILS_STD_ATTR_NAME   stdAttr, BSTR bstrStdAttr)
//
// History:
//  1-16-97 Shishir Pardikar
// Created.
//****************************************************************************
STDMETHODIMP
CIlsMeetingPlace::SetStandardAttribute(
    ILS_STD_ATTR_NAME   stdAttr,
    BSTR                bstrStdAttr
)
{
    LPTSTR *ppszAttr = NULL, pszNewAttr;
    BOOL    fValid = TRUE;
    ULONG   ulModBit = 0;
    HRESULT hr;

    if (bstrStdAttr == NULL) {

        return ILS_E_POINTER;

    }

    switch(stdAttr) {

    case ILS_STDATTR_MEETING_HOST_NAME:
        ppszAttr = &m_pszHostName;
        ulModBit = ILS_MEET_FLAG_HOST_NAME_MODIFIED;
        break;

    case ILS_STDATTR_MEETING_HOST_IP_ADDRESS:
        ppszAttr = &m_pszHostIPAddress;
        ulModBit = ILS_MEET_FLAG_HOST_ADDRESS_MODIFIED;
        break;

    case ILS_STDATTR_MEETING_DESCRIPTION:
        ppszAttr = &m_pszDescription;
        ulModBit = ILS_MEET_FLAG_DESCRIPTION_MODIFIED;
        break;

    default:
        fValid = FALSE;
        break;
    }

    if (fValid) {
        // Duplicate the string
        //
        hr = BSTR_to_LPTSTR (&pszNewAttr, bstrStdAttr);

        if (SUCCEEDED(hr))
        {
            ::MemFree (*ppszAttr);
            *ppszAttr = pszNewAttr;
            m_dwFlags |= ulModBit;
        };
    }
    else {

        hr = ILS_E_PARAMETER;

    }

    return (hr);
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::SetExtendedAttributes (IIlsAttributes *pAttributes, ULONG *puReqID)
//
// History:
//****************************************************************************

STDMETHODIMP CIlsMeetingPlace::
SetExtendedAttribute ( BSTR bstrName, BSTR bstrValue )
{
	m_dwFlags |= ILS_MEET_FLAG_EXTENDED_ATTRIBUTES_MODIFIED;
	return m_ExtendedAttrs.SetAttribute (bstrName, bstrValue);
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::RemoveExtendedAttributes (IIlsAttributes *pAttributes, ULONG *puReqID)
//
// History:
//****************************************************************************

STDMETHODIMP CIlsMeetingPlace::
RemoveExtendedAttribute ( BSTR bstrName )
{
	m_dwFlags |= ILS_MEET_FLAG_EXTENDED_ATTRIBUTES_MODIFIED;
	return m_ExtendedAttrs.SetAttribute (bstrName, NULL);
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::GetExtendedAttributes (IIlsAttributes **pAttributes)
//
//****************************************************************************
STDMETHODIMP CIlsMeetingPlace::
GetExtendedAttribute ( BSTR bstrName, BSTR *pbstrValue )
{
	return m_ExtendedAttrs.GetAttribute (bstrName, pbstrValue);
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::GetAllExtendedAttributes (IIlsAttributes **pAttributes)
//
//****************************************************************************
STDMETHODIMP CIlsMeetingPlace::
GetAllExtendedAttributes ( IIlsAttributes **ppAttributes )
{
    if (ppAttributes == NULL)
        return ILS_E_PARAMETER;

    return m_ExtendedAttrs.CloneNameValueAttrib((CAttributes **) ppAttributes);
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::Register (
//  BSTR    bstrServerName,
//  BSTR    bstrAuthInfo,
//  ILS_ENUM_AUTH_TYPE  ulsAuthInfo,
//  ULONG *pulID)
//
// Synopsis:
//
// Arguments:
//          pulID - ID to identify the asynchronous transaction
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP CIlsMeetingPlace::
Register (
	IIlsServer		*pServer,
	ULONG			*pulID )
{
    HRESULT hr;
    LDAP_ASYNCINFO ldai; 

    ASSERT(m_pszMeetingPlaceID != NULL);

    // Validate parameters
    //
	if (::MyIsBadServer (pServer) || pulID == NULL)
        return ILS_E_POINTER;

	// Make sure we have not done registration before
	//
	if (m_pIlsServer != NULL)
		return ILS_E_FAIL;

	// Clone ther server object
	//
	CIlsServer *pis = ((CIlsServer *) pServer)->Clone ();
	if (pis == NULL)
		return ILS_E_MEMORY;

	// Free the old server object if any
	//
	::MemFree (m_pIlsServer);

	// Keep the new server object
	//
	m_pIlsServer = pis;

    // Allocate memory for LDAP_MEETINFO structure
    //
    PLDAP_MEETINFO pMeetInfo = NULL;
    hr = AllocMeetInfo(&pMeetInfo, ILS_MEET_ALL_MODIFIED);
    if (SUCCEEDED(hr))
    {
        ASSERT(m_hMeetingPlace == NULL);
    
        hr = ::UlsLdap_RegisterMeeting ((DWORD) this,
        								m_pIlsServer->GetServerInfo (),
        								pMeetInfo,
        								&m_hMeetingPlace,
        								&ldai);
        if (SUCCEEDED(hr))
        {
		    COM_REQ_INFO ri;
		    ReqInfo_Init (&ri);

            // If updating server was successfully requested, wait for the response
            //
            ri.uReqType = WM_ILS_REGISTER_MEETING;
            ri.uMsgID = ldai.uMsgID;

			ReqInfo_SetMeeting (&ri, this);

            hr = g_pReqMgr->NewRequest(&ri);
            if (SUCCEEDED(hr))
            {
                // Make sure the objects do not disappear before we get the response
                //
                this->AddRef();

                // Return the request ID
                //
                *pulID = ri.uReqID;
            };
                
        };
    }
    ::MemFree (pMeetInfo);

    if (FAILED (hr))
    {
		m_pIlsServer->Release ();
		m_pIlsServer = NULL;
    }
    else
    {
        m_ulState = ILS_REGISTERING;
    }

    return hr;
}



//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::Unregister (ULONG *pulID)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************
STDMETHODIMP
CIlsMeetingPlace::Unregister (ULONG *pulID)
{
    LDAP_ASYNCINFO ldai; 
    HRESULT hr = ILS_E_NOT_REGISTERED;
    
    ASSERT(m_pszMeetingPlaceID != NULL);

    // BUGBUG how about ILS_MEETING_PLACE_IN_SYNC

    if (m_ulState == ILS_REGISTERED)
    {
        ASSERT(m_pIlsServer != NULL);
        ASSERT(m_hMeetingPlace != NULL);

        hr = ::UlsLdap_UnRegisterMeeting(m_hMeetingPlace, &ldai);
        if (SUCCEEDED(hr))
        {
		    COM_REQ_INFO ri;
		    ReqInfo_Init (&ri);

            // If updating server was successfully requested, wait for the response
            //
            ri.uReqType = WM_ILS_UNREGISTER_MEETING;
            ri.uMsgID = ldai.uMsgID;

			ReqInfo_SetMeeting (&ri, this);

            hr = g_pReqMgr->NewRequest(&ri);
            if (SUCCEEDED(hr))
            {
                // Make sure the objects do not disappear before we get the response
                //
                this->AddRef();

                // Return the request ID
                //
                *pulID = ri.uReqID;
            };

            m_ulState = ILS_UNREGISTERING;
        }
    }
    else
    {
        hr = ILS_E_NOT_REGISTERED;
    }

    return (hr);
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::Update (ULONG *pulID)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP CIlsMeetingPlace::
Update ( ULONG *pulID )
{
    HRESULT hr;
    LDAP_ASYNCINFO ldai; 
    PLDAP_MEETINFO pMeetInfo = NULL;

    if ((m_ulState!=ILS_REGISTERED) 
        &&(m_ulState!=ILS_IN_SYNC)) {

        return (ILS_E_NOT_REGISTERED);

    }

    ASSERT(m_pIlsServer != NULL);

    if (!(m_dwFlags & ILS_MEET_MODIFIED_MASK)) {

        return NOERROR;

    }

    // allocate memory for LDAP_MEETINFO structure
    pMeetInfo = NULL;

    hr = AllocMeetInfo(&pMeetInfo, m_dwFlags & ILS_MEET_MODIFIED_MASK);

    if (SUCCEEDED(hr)) {

        ASSERT(m_hMeetingPlace != NULL);

        pMeetInfo->uOffsetMeetingPlaceID = 
        pMeetInfo->uOffsetDescription = INVALID_OFFSET;
        
        pMeetInfo->lMeetingPlaceType = INVALID_MEETING_TYPE;
        pMeetInfo->lAttendeeType = INVALID_ATTENDEE_TYPE;
    
        hr = ::UlsLdap_SetMeetingInfo ( m_pIlsServer->GetServerInfo (),
										m_pszMeetingPlaceID,
										pMeetInfo,
										&ldai);
    
        if (SUCCEEDED(hr))
        {
		    COM_REQ_INFO ri;
		    ReqInfo_Init (&ri);

            // If updating server was successfully requested, wait for the response
            //
            ri.uReqType = WM_ILS_SET_MEETING_INFO;
            ri.uMsgID = ldai.uMsgID;

			ReqInfo_SetMeeting (&ri, this);

            hr = g_pReqMgr->NewRequest(&ri);

            if (SUCCEEDED(hr))
            {
                // Make sure the objects do not disappear before we get the response
                //
                this->AddRef();

                // Return the request ID
                //
                *pulID = ri.uReqID;
            };
                
        };
    }

    ::MemFree (pMeetInfo);

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::AddAttendee (BSTR  bstrAttendeeID, ULONG *pulID)
//
// Synopsis:
//
// Arguments:
//          pbstrAttendeeID - ID of the Attendee to be added, should conform to Attendeetype
//          pulID - ID to identify the asynchronous transaction
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP CIlsMeetingPlace::
AddAttendee ( BSTR bstrAttendeeID, ULONG *pulID )
{
    LDAP_ASYNCINFO ldai; 
    HRESULT hr;
    LPTSTR pszAttendeeID = NULL;

    if ((m_ulState != ILS_REGISTERED)&&
        (m_ulState != ILS_IN_SYNC))
    {
        return(ILS_E_FAIL); // BUGBUG refine the error
    }

    ASSERT(NULL != m_pIlsServer);
    ASSERT(NULL != m_pszMeetingPlaceID);

    hr = BSTR_to_LPTSTR(&pszAttendeeID, bstrAttendeeID);
    if (SUCCEEDED(hr))
    {
        hr = ::UlsLdap_AddAttendee (m_pIlsServer->GetServerInfo (),
        							m_pszMeetingPlaceID,
        							1,
        							pszAttendeeID,
        							&ldai);
        if (SUCCEEDED(hr))
        {
		    COM_REQ_INFO ri;
		    ReqInfo_Init (&ri);

            // If the request was successfully sent to the server
            // wait for the response

            ri.uReqType = WM_ILS_ADD_ATTENDEE;
            ri.uMsgID = ldai.uMsgID;

			ReqInfo_SetMeeting (&ri, this);

            hr = g_pReqMgr->NewRequest(&ri);
            if (SUCCEEDED(hr))
            {
                // Make sure the objects do not disappear before we get the response
                //
                this->AddRef();

                // Return the request ID
                //
                *pulID = ri.uReqID;
            };
            
        }

        ::MemFree (pszAttendeeID);
    }

    return (hr);
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::RemoveAttendee (BSTR  bstrAttendeeID, ULONG *pulID)
//
// Synopsis:
//
// Arguments:
//          pbstrAttendeeID - ID of the Attendee to be removed, should conform to Attendeetype
//          pulID - ID to identify the asynchronous transaction
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP CIlsMeetingPlace::
RemoveAttendee ( BSTR bstrAttendeeID, ULONG *pulID )
{
    LDAP_ASYNCINFO ldai; 
    HRESULT hr;
    LPTSTR pszAttendeeID = NULL;
    
    if ((m_ulState != ILS_REGISTERED)&&
        (m_ulState != ILS_IN_SYNC))
    {
        return(ILS_E_FAIL); // BUBGUG refine
    }

    ASSERT(NULL != m_pIlsServer);
    ASSERT(NULL != m_pszMeetingPlaceID);

    hr = BSTR_to_LPTSTR (&pszAttendeeID, bstrAttendeeID);
    if (SUCCEEDED(hr))
    {
        hr = ::UlsLdap_RemoveAttendee ( m_pIlsServer->GetServerInfo (),
        								m_pszMeetingPlaceID,
        								1,
        								pszAttendeeID,
        								&ldai);
        if (SUCCEEDED(hr))
        {
		    COM_REQ_INFO ri;
		    ReqInfo_Init (&ri);

            // If the request was successfully sent to the server
            // wait for the response

            ri.uReqType = WM_ILS_REMOVE_ATTENDEE;
            ri.uMsgID = ldai.uMsgID;

			ReqInfo_SetMeeting (&ri, this);

            hr = g_pReqMgr->NewRequest(&ri);
            if (SUCCEEDED(hr))
            {
                // Make sure the objects do not disappear before we get the response
                //
                this->AddRef();

                // Return the request ID
                //
                *pulID = ri.uReqID;
            };
            
        }

        ::MemFree (pszAttendeeID);
    }

    return (hr);
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::EnumAttendeeNames(IIlsFilter *pFilter, ULONG *pulID)
//
// Synopsis: enumerate attendees in a meeting based on a filter
//
// Arguments: 
//          [pFilter]           specifies the filter to be used by the server
//                              NULL => no filter
//          [pulID]             request ID returned for keeping track of the
//                              asynchronous operation
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP CIlsMeetingPlace::
EnumAttendeeNames ( IIlsFilter *pFilter, ULONG *pulID )
{
    LDAP_ASYNCINFO ldai; 
    HRESULT hr;

    if ((m_ulState != ILS_REGISTERED)&&
        (m_ulState != ILS_IN_SYNC))
    {
        return(ILS_E_FAIL);
    }

	// Create a ldap-like filter
	//
	TCHAR *pszFilter = NULL;
	hr = ::FilterToLdapString ((CFilter *) pFilter, &pszFilter);
	if (hr != S_OK)
		return hr;

	// Send the request over the wire
	//
    hr = ::UlsLdap_EnumAttendees (	m_pIlsServer->GetServerInfo (),
    								m_pszMeetingPlaceID,
    								pszFilter,
    								&ldai);
    ::MemFree (pszFilter);
    if (SUCCEEDED(hr))
    {
        // If the request was successfully sent to the server
        // wait for the response
        //
	    COM_REQ_INFO ri;
	    ReqInfo_Init (&ri);

        ri.uReqType = WM_ILS_ENUM_ATTENDEES;
        ri.uMsgID = ldai.uMsgID;

		ReqInfo_SetMeeting (&ri, this);

		// Enter the request
		//
        hr = g_pReqMgr->NewRequest(&ri);
        if (SUCCEEDED(hr))
        {
            // Make sure the objects do not disappear before we get the response
            //
            this->AddRef();

            // Return the request ID
            //
            *pulID = ri.uReqID;
        };
    }

    return (hr);
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::RegisterResult(ULONG ulID, HRESULT hr)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************
STDMETHODIMP
CIlsMeetingPlace::RegisterResult(ULONG uReqID, HRESULT hr)
{
    OBJRINFO objri;

    if (SUCCEEDED(hr)) {

        m_dwFlags |= ILS_MEET_FLAG_REGISTERED;
        m_ulState = ILS_REGISTERED;

    }        
    else {

        ASSERT(!(m_dwFlags & ILS_MEET_FLAG_REGISTERED));

        m_hMeetingPlace = NULL;  // null out the service provider's handle
        m_ulState = ILS_UNREGISTERED;

    }

    objri.uReqID = uReqID;
    objri.hResult = hr;
    objri.pv = NULL;
    
    NotifySink((VOID *)&objri, OnNotifyRegisterMeetingPlaceResult);

    return NOERROR;    
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::UnregisterResult(ULONG ulID, HRESULT hr)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************
STDMETHODIMP
CIlsMeetingPlace::UnregisterResult(ULONG uReqID, HRESULT hr)
{
    OBJRINFO objri;

    if (SUCCEEDED(hr)) {
        m_dwFlags &= ~ILS_MEET_FLAG_REGISTERED;
        m_ulState = ILS_UNREGISTERED;
    }        
    else {
        // BUGBUG, we need an m_oldState variable

        m_ulState = ILS_REGISTERED;
    }

    objri.uReqID = uReqID;
    objri.hResult = hr;
    objri.pv = NULL;
    
    NotifySink((VOID *)&objri, OnNotifyUnregisterMeetingPlaceResult);

    return NOERROR;    
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::UpdateResult(ULONG ulID, HRESULT hr)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************
STDMETHODIMP
CIlsMeetingPlace::UpdateResult(ULONG ulID, HRESULT hr)
{
    OBJRINFO objri;

    objri.uReqID = ulID;
    objri.hResult = hr;
    objri.pv = NULL;

    if (SUCCEEDED(hr)) {

        m_dwFlags &= ~ILS_MEET_MODIFIED_MASK;

    }

    NotifySink((VOID *)&objri, OnNotifyUpdateMeetingPlaceResult);

    return NOERROR;    
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::AttendeeChangeResult(ULONG ulID, HRESULT hr)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************
STDMETHODIMP
CIlsMeetingPlace::AddAttendeeResult(ULONG uReqID, HRESULT hr)
{
    OBJRINFO objri;

    objri.uReqID = uReqID;
    objri.hResult = hr;
    objri.pv = NULL;
    
    NotifySink((VOID *)&objri, OnNotifyAddAttendeeResult);

    return NOERROR;    
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::RemoveAttendeeResult(ULONG ulID, HRESULT hr)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************
STDMETHODIMP
CIlsMeetingPlace::RemoveAttendeeResult(ULONG uReqID, HRESULT hr)
{
    OBJRINFO objri;

    objri.uReqID = uReqID;
    objri.hResult = hr;
    objri.pv = NULL;
    
    NotifySink((VOID *)&objri, OnNotifyRemoveAttendeeResult);

    return NOERROR;    
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::EnumAttendeeNamesResult(ULONG ulID, PLDAP_ENUM ple)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************
STDMETHODIMP
CIlsMeetingPlace::EnumAttendeeNamesResult(ULONG uReqID, PLDAP_ENUM ple)
{
    ENUMRINFO eri;

    // Package the notification info
    //
    eri.uReqID  = uReqID;

    // PLDAP_ENUM is NULL when the enumeration is terminated successfully
    //
    if (ple != NULL)
    {
        eri.hResult = ple->hResult;
        eri.cItems  = ple->cItems;
        eri.pv      = (void *)(((PBYTE)ple)+ple->uOffsetItems);
    }
    else
    {
        eri.hResult = S_FALSE;
        eri.cItems  = 0;
        eri.pv      = NULL;
    };
    NotifySink((void *)&eri, OnNotifyEnumAttendeeNamesResult);
    return NOERROR;

}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP
CIlsMeetingPlace::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
{
    CEnumConnectionPoints *pecp;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return E_POINTER;
    };
    
    // Assume failure
    //
    *ppEnum = NULL;

    // Create an enumerator
    //
    pecp = new CEnumConnectionPoints;
    if (pecp == NULL)
        return ILS_E_MEMORY;

    // Initialize the enumerator
    //
    hr = pecp->Init((IConnectionPoint *)m_pConnectionPoint);
    if (FAILED(hr))
    {
        delete pecp;
        return hr;
    };

    // Give it back to the caller
    //
    pecp->AddRef();
    *ppEnum = pecp;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::FindConnectionPoint(REFIID riid, IConnectionPoint **ppcp)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************
STDMETHODIMP
CIlsMeetingPlace::FindConnectionPoint(REFIID riid, IConnectionPoint **ppcp)
{
    IID siid;
    HRESULT hr;

    // Validate parameters
    //
    if (ppcp == NULL)
    {
        return E_POINTER;
    };
    
    // Assume failure
    //
    *ppcp = NULL;

    if (m_pConnectionPoint != NULL)
    {
        hr = m_pConnectionPoint->GetConnectionInterface(&siid);

        if (SUCCEEDED(hr))
        {
            if (riid == siid)
            {
                *ppcp = (IConnectionPoint *)m_pConnectionPoint;
                (*ppcp)->AddRef();
                hr = S_OK;
            }
            else
            {
                hr = ILS_E_NO_INTERFACE;
            };
        };
    }
    else
    {
        hr = ILS_E_NO_INTERFACE;
    };

    return hr;
}


//****************************************************************************
//
//CEnumMeetingPlaces class implementation
//
//****************************************************************************


//****************************************************************************
// CEnumMeetingPlaces::CEnumMeetingPlaces (void)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

CEnumMeetingPlaces::CEnumMeetingPlaces (void)
{
    m_cRef    = 0;
    m_ppMeetingPlaces     = NULL;
    m_cMeetingPlaces  = 0;
    m_iNext   = 0;
    return;
}

//****************************************************************************
// CEnumMeetingPlaces::~CEnumMeetingPlaces (void)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

CEnumMeetingPlaces::~CEnumMeetingPlaces (void)
{
    ULONG i;

    if (m_ppMeetingPlaces != NULL)
    {
        for (i = 0; i < m_cMeetingPlaces; i++)
        {
            m_ppMeetingPlaces[i]->Release();
        };
        ::MemFree (m_ppMeetingPlaces);
    };
    return;
}

//****************************************************************************
// STDMETHODIMP
// CEnumMeetingPlaces::Init (CIlsMeetingPlace **ppMeetingPlacesList, ULONG cMeetingPlaces)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP
CEnumMeetingPlaces::Init (CIlsMeetingPlace **ppMeetingPlacesList, ULONG cMeetingPlaces)
{
    HRESULT hr = NOERROR;

    // If no list, do nothing
    //
    if (cMeetingPlaces != 0)
    {
        ASSERT(ppMeetingPlacesList != NULL);

        // Allocate the snapshot buffer
        //
        m_ppMeetingPlaces = (CIlsMeetingPlace **) ::MemAlloc (cMeetingPlaces*sizeof(CIlsMeetingPlace *));

        if (m_ppMeetingPlaces != NULL)
        {
            ULONG i;

            // Snapshot the object list
            //
            for (i =0; i < cMeetingPlaces; i++)
            {
                m_ppMeetingPlaces[i] = ppMeetingPlacesList[i];
                m_ppMeetingPlaces[i]->AddRef();
            };
            m_cMeetingPlaces = cMeetingPlaces;
        }
        else
        {
            hr = ILS_E_MEMORY;
        };
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CEnumMeetingPlaces::QueryInterface (REFIID riid, void **ppv)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP
CEnumMeetingPlaces::QueryInterface (REFIID riid, void **ppv)
{
    if (riid == IID_IEnumIlsMeetingPlaces || riid == IID_IUnknown)
    {
        *ppv = (IEnumIlsMeetingPlaces *) this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return ILS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumMeetingPlaces::AddRef (void)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumMeetingPlaces::AddRef (void)
{
    DllLock();

	MyDebugMsg ((DM_REFCOUNT, "CEnumMeetingPlaces::AddRef: ref=%ld\r\n", m_cRef));
    ::InterlockedIncrement ((LONG *) &m_cRef);
    return m_cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumMeetingPlaces::Release (void)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumMeetingPlaces::Release (void)
{
    DllRelease();

	ASSERT (m_cRef > 0);

	MyDebugMsg ((DM_REFCOUNT, "CEnumMeetingPlaces::Release: ref=%ld\r\n", m_cRef));
    if (::InterlockedDecrement ((LONG *) &m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

//****************************************************************************
// STDMETHODIMP 
// CEnumMeetingPlaces::Next (ULONG cMeetingPlaces, IIlsMeetingPlace **rgpm, ULONG *pcFetched)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP 
CEnumMeetingPlaces::Next (ULONG cMeetingPlaces, IIlsMeetingPlace **rgpm, ULONG *pcFetched)
{
    ULONG   cCopied;
    HRESULT hr;

    // Validate the pointer
    //
    if (rgpm == NULL) {

        return E_POINTER;
    }

    // Validate the parameters
    //
    if ((cMeetingPlaces == 0) ||
        ((cMeetingPlaces > 1) && (pcFetched == NULL))) {

        return ILS_E_PARAMETER;
    }

    // Check the enumeration index
    //
    cCopied = 0;

    // Can copy if we still have more attribute names
    //
    while ((cCopied < cMeetingPlaces) &&
           (m_iNext < this->m_cMeetingPlaces))
    {
        m_ppMeetingPlaces[m_iNext]->AddRef();
        rgpm[cCopied++] = m_ppMeetingPlaces[m_iNext++];
    };

    // Determine the returned information based on other parameters
    //
    if (pcFetched != NULL)
    {
        *pcFetched = cCopied;
    };
    return (cMeetingPlaces == cCopied ? S_OK : S_FALSE);
}

//****************************************************************************
// STDMETHODIMP
// CEnumMeetingPlaces::Skip (ULONG cMeetingPlaces)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP
CEnumMeetingPlaces::Skip (ULONG cMeetingPlaces)
{
    ULONG iNewIndex;

    // Validate the parameters
    //
    if (cMeetingPlaces == 0){

        return ILS_E_PARAMETER;
    }

    // Check the enumeration index limit
    //
    iNewIndex = m_iNext+cMeetingPlaces;
    if (iNewIndex <= m_cMeetingPlaces)
    {
        m_iNext = iNewIndex;
        return S_OK;
    }
    else
    {
        m_iNext = m_cMeetingPlaces;
        return S_FALSE;
    };
}

//****************************************************************************
// STDMETHODIMP
// CEnumMeetingPlaces::Reset (void)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP
CEnumMeetingPlaces::Reset (void)
{
    m_iNext = 0;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CEnumMeetingPlaces::Clone(IEnumIlsMeetingPlaces **ppEnum)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP
CEnumMeetingPlaces::Clone(IEnumIlsMeetingPlaces **ppEnum)
{
    CEnumMeetingPlaces *pEnumMeetingPlaces;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return E_POINTER;
    };

    *ppEnum = NULL;

    // Create an enumerator
    //
    pEnumMeetingPlaces = new CEnumMeetingPlaces;

    if (pEnumMeetingPlaces == NULL) {

        return ILS_E_MEMORY;
    }

    // Clone the information
    //
    hr = pEnumMeetingPlaces->Init(m_ppMeetingPlaces, m_cMeetingPlaces);

    if (SUCCEEDED(hr))
    {
        pEnumMeetingPlaces->m_iNext = m_iNext;

        // Return the cloned enumerator
        //
        pEnumMeetingPlaces->AddRef();
        *ppEnum = pEnumMeetingPlaces;
    }
    else
    {
        delete pEnumMeetingPlaces;
    };
    return hr;
}




#endif // ENABLE_MEETING_PLACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\ulsp.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       ulsp.h
//  Content:    This file contains the declaration for ULS.DLL
//  History:
//      Tue 08-Oct-1996 08:54:45  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#ifndef _ULSP_H_
#define _ULSP_H_

// LonChanC: ENABLE_MEETING_PLACE is to enable the meeting place code.
// The meeting place code is disabled for NM 2.0 Beta 4.
//
// #define ENABLE_MEETING_PLACE

//****************************************************************************
// Global Include File
//****************************************************************************

#define _INC_OLE

#include <windows.h>        // also includes windowsx.h
#include <tchar.h>          // Unicode-aware code
#include <ole2.h>
#include <olectl.h>

#include <stock.h>          // Standard NetMeeting definitions
#include <ulsreg.h>         // Registry key/value definitions for ULS
#include <memtrack.h>

#include "uls.h"            // User Location Services COM object


#include "utils.h"


//****************************************************************************
// Class Forward Definitions
//****************************************************************************

class CEnumConnectionPoints;
class CConnectionPoint;
class CEnumConnections;
class CEnumNames;
class CIlsMain;
class CIlsServer;
class CAttributes;
class CLocalProt;
class CIlsUser;
class CIlsMeetingPlace;

class CFilter;
class CFilterParser;

#include "debug.h"
#include "request.h"

//****************************************************************************
// Constant Definitions
//****************************************************************************

#ifdef __cplusplus
extern "C" {
#endif

//****************************************************************************
// Macros
//****************************************************************************

#define ARRAYSIZE(x)        (sizeof(x)/sizeof(x[0]))

//****************************************************************************
// Global Parameters
//****************************************************************************

extern  HINSTANCE           g_hInstance;
extern  CRITICAL_SECTION    g_ULSSem;
extern  CIlsMain            *g_pCIls;
extern  CReqMgr             *g_pReqMgr;

//****************************************************************************
// Global routine
//****************************************************************************

void DllLock(void);
void DllRelease(void);

#ifdef __cplusplus
}
#endif

//****************************************************************************
// Local Header Files
//****************************************************************************

#include "sputils.h"
#include "spserver.h"
#include "ulsldap.h"


#endif  //_ULSP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\ulsmeet.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       ulsmeet.h
//  Content:    This file contains the MeetingPlace object definition.
//  History:
//              Mon 11-Nov-96 -by-  Shishir Pardikar    [shishirp]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#ifndef _ULSMEET_H_
#define _ULSMEET_H_

#ifdef ENABLE_MEETING_PLACE

#include "connpt.h"
#include "attribs.h"
#include "culs.h"

class CIlsMeetingPlace: public IIlsMeetingPlace,
                        public IConnectionPointContainer
{
#define UNDEFINED_TYPE  -1
#define ILS_MEET_FLAG_REGISTERED            0x00000001

#define ILS_MEET_MODIFIED_MASK                      0xffff0000
#define ILS_MEET_FLAG_HOST_NAME_MODIFIED            0x00010000
#define ILS_MEET_FLAG_HOST_ADDRESS_MODIFIED         0x00020000
#define ILS_MEET_FLAG_DESCRIPTION_MODIFIED          0x00040000
#define ILS_MEET_FLAG_EXTENDED_ATTRIBUTES_MODIFIED  0x00080000

#define ILS_MEET_ALL_MODIFIED                       ILS_MEET_MODIFIED_MASK

    private:

        LONG    m_cRef;             // ref count on this object

        
        // members to keep track of properties
        ULONG   m_ulState;              // the current state of this object
                                        // as defined by ULSState enum type
        LPTSTR  m_pszMeetingPlaceID;    // globally unique ID for the MeetingPlace 
        LONG    m_lMeetingPlaceType;    // meetingtype, eg: netmeeting, doom etc.
        LONG    m_lAttendeeType;        // type of Attendees, eg: urls, rtperson DNs etc.   

        LPTSTR  m_pszHostName;          // Host who registered this MeetingPlace
        LPTSTR  m_pszHostIPAddress;     // IP address of the host
        LPTSTR  m_pszDescription;       // description eg: discussing ski trip
        CAttributes m_ExtendedAttrs;          // User defined attributes
        HANDLE  m_hMeetingPlace;             // handle from ulsldap_register
        CConnectionPoint *m_pConnectionPoint;

        // bookkeeping
        DWORD   m_dwFlags;              // Always a good idea

		// server object
		CIlsServer	*m_pIlsServer;


        STDMETHODIMP AllocMeetInfo(PLDAP_MEETINFO *ppMeetInfo, ULONG ulMask);

    public:                         

        // Constructor        
        CIlsMeetingPlace();

        // destructor
        ~CIlsMeetingPlace(VOID);

        STDMETHODIMP Init(BSTR bstrMeetingPlaceID, LONG lMeetingPlaceType, LONG lAttendeeType);
        STDMETHODIMP Init(CIlsServer *pIlsServer, PLDAP_MEETINFO pMeetInfo);

        STDMETHODIMP NotifySink(VOID *pv, CONN_NOTIFYPROC pfn);

        STDMETHODIMP RegisterResult(ULONG ulRegID, HRESULT hr);
        STDMETHODIMP UnregisterResult(ULONG ulRegID, HRESULT hr);
        STDMETHODIMP UpdateResult(ULONG ulUpdateID, HRESULT hr);
        STDMETHODIMP AddAttendeeResult(ULONG ulID, HRESULT hr);
        STDMETHODIMP RemoveAttendeeResult(ULONG ulID, HRESULT hr);
        STDMETHODIMP EnumAttendeeNamesResult(ULONG ulEnumAttendees, PLDAP_ENUM ple);



        // IUnknown members

        STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
        STDMETHODIMP_(ULONG)    AddRef (void);
        STDMETHODIMP_(ULONG)    Release (void);


        // IIlsMeetingPlace Interface members

        // Interfaces related to attributes
        // all these operate locally on the object and generate
        // no net traffic.


        // Get the type of meeting and Attendee
        // these are not changeable once the
        // meeting is registered

        STDMETHODIMP GetState(ULONG *ulState);

        STDMETHODIMP GetMeetingPlaceType(LONG *plMeetingPlaceType);
        STDMETHODIMP GetAttendeeType(LONG *plAttendeeType);

        STDMETHODIMP GetStandardAttribute(
                    ILS_STD_ATTR_NAME   stdAttr,
                    BSTR                *pbstrStdAttr);

        STDMETHODIMP SetStandardAttribute(
                    ILS_STD_ATTR_NAME   stdAttr,
                    BSTR                pbstrStdAttr);

	    STDMETHODIMP GetExtendedAttribute ( BSTR bstrName, BSTR *pbstrValue );
	    STDMETHODIMP SetExtendedAttribute ( BSTR bstrName, BSTR bstrValue );
	    STDMETHODIMP RemoveExtendedAttribute ( BSTR bstrName );
	    STDMETHODIMP GetAllExtendedAttributes ( IIlsAttributes **ppAttributes );

        // Registers a meeting with the server
        STDMETHODIMP Register ( IIlsServer *pServer, ULONG *pulRegID );

        // The following 5 interfaces work only on an object that has been
        // a) used to register a meeting
        // or b) obtained from IIls::EnumMeetingPlaces


        STDMETHODIMP Unregister(ULONG *pulUnregID);

        STDMETHODIMP Update(ULONG *pulUpdateID);

        STDMETHODIMP AddAttendee(BSTR bstrAttendeeID, ULONG *pulAddAttendeeID);
        STDMETHODIMP RemoveAttendee(BSTR bstrAttendeeID, ULONG *pulRemoveAttendeeID);

        STDMETHODIMP EnumAttendeeNames(IIlsFilter *pFilter, ULONG *pulEnumAttendees);


        // Connection point container. It has only one
        // connection interface, and that is to notify
        
        // IConnectionPointContainer
        STDMETHODIMP    EnumConnectionPoints(IEnumConnectionPoints **ppEnum);
        STDMETHODIMP    FindConnectionPoint(REFIID riid,
                                        IConnectionPoint **ppcp);
};

//****************************************************************************
// CEnumMeetingPlaces definition
//****************************************************************************
//
class CEnumMeetingPlaces : public IEnumIlsMeetingPlaces
{
private:
    LONG                    m_cRef;
    CIlsMeetingPlace        **m_ppMeetingPlaces;
    ULONG                   m_cMeetingPlaces;
    ULONG                   m_iNext;

public:
    // Constructor and Initialization
    CEnumMeetingPlaces (void);
    ~CEnumMeetingPlaces (void);
    STDMETHODIMP            Init (CIlsMeetingPlace **ppMeetingPlacesList, ULONG cMeetingPlaces);

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IEnumIlsMeetingPlaces
    STDMETHODIMP            Next(ULONG cMeetingPlaces, IIlsMeetingPlace **rgpMeetingPlaces,
                                 ULONG *pcFetched);
    STDMETHODIMP            Skip(ULONG cMeetingPlaces);
    STDMETHODIMP            Reset();
    STDMETHODIMP            Clone(IEnumIlsMeetingPlaces **ppEnum);
};

#endif // ENABLE_MEETING_PLACE

#endif //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\ulsprot.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       ulsprot.h
//  Content:    This file contains the Protocol object definition.
//  History:
//      Wed 17-Apr-1996 11:18:47  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#ifndef _ULSPROT_H_
#define _ULSPROT_H_

//****************************************************************************
// CUlsProt definition
//****************************************************************************
//
class CUlsProt : public IULSAppProtocol
{
private:
    ULONG                   cRef;
    LPTSTR                  szServer;
    LPTSTR                  szUser;
    LPTSTR                  szApp;
    LPTSTR                  szName;
    LPTSTR                  szMimeType;
    ULONG                   uPort;
    CAttributes             *pAttrs;

public:
    // Constructor and destructor
    CUlsProt (void);
    ~CUlsProt (void);
    STDMETHODIMP            Init (LPTSTR szServerName,
                                  LPTSTR szUserName,
                                  LPTSTR szAppName,
                                  PLDAP_PROTINFO ppi);

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IULSAppProtocol
    STDMETHODIMP    GetID (BSTR *pbstrID);
    STDMETHODIMP    GetPortNumber (ULONG *puPortNumber);
    STDMETHODIMP    GetMimeType (BSTR *pbstrMimeType);
    STDMETHODIMP    GetAttributes (IULSAttributes **ppAttributes);
};

#endif //_ULSPROT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\ulsprot.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       ulsprot.cpp
//  Content:    This file contains the Protocol object.
//  History:
//      Wed 17-Apr-1996 11:13:54  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#include "ulsp.h"
#include "ulsprot.h"
#include "attribs.h"

//****************************************************************************
// CUlsProt::CUlsProt (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CUlsProt::CUlsProt (void)
{
    cRef        = 0;
    szServer    = NULL;
    szUser      = NULL;
    szApp       = NULL;
    szName      = NULL;
    szMimeType  = NULL;
    uPort       = 0;
    pAttrs      = NULL;

    return;
}

//****************************************************************************
// CUlsProt::~CUlsProt (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CUlsProt::~CUlsProt (void)
{
    if (szServer != NULL)
        FreeLPTSTR(szServer);
    if (szUser != NULL)
        FreeLPTSTR(szUser);
    if (szApp != NULL)
        FreeLPTSTR(szApp);
    if (szName != NULL)
        FreeLPTSTR(szName);
    if (szMimeType != NULL)
        FreeLPTSTR(szMimeType);

    // Release attribute object
    //
    if (pAttrs != NULL)
    {
        pAttrs->Release();
    };

    return;
}

//****************************************************************************
// STDMETHODIMP
// CUlsProt::Init (LPTSTR szServerName, LPTSTR szUserName, 
//                 LPTSTR szAppName, PLDAP_PROTINFO ppi)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsProt::Init (LPTSTR szServerName, LPTSTR szUserName, 
                LPTSTR szAppName, PLDAP_PROTINFO ppi)
{
    HRESULT hr;

    // Validate parameter
    //
    if ((ppi->uSize != sizeof(*ppi))    ||
        (ppi->uPortNumber == 0)         ||
        (ppi->uOffsetName == 0)   ||
        (ppi->uOffsetMimeType  == 0))
    {
        return ULS_E_PARAMETER;
    };

    if ((ppi->cAttributes != 0) && (ppi->uOffsetAttributes == 0))
    {
        return ULS_E_PARAMETER;        
    };

    // Remember port name
    //
    uPort = ppi->uPortNumber;

    // Remember the server name
    //
    hr = SetLPTSTR(&szServer, szServerName);

    if (SUCCEEDED(hr))
    {
        hr = SetLPTSTR(&szUser, szUserName);

        if (SUCCEEDED(hr))
        {
            hr = SetLPTSTR(&szApp, szAppName);

            if (SUCCEEDED(hr))
            {
                hr = SetLPTSTR(&szName,
                               (LPCTSTR)(((PBYTE)ppi)+ppi->uOffsetName));

                if (SUCCEEDED(hr))
                {
                    hr = SetLPTSTR(&szMimeType,
                                   (LPCTSTR)(((PBYTE)ppi)+ppi->uOffsetMimeType));

                    if (SUCCEEDED(hr))
                    {
                        CAttributes *pNewAttrs;

                        // Build the attribute object
                        //
                        pNewAttrs = new CAttributes (ULS_ATTRACCESS_NAME_VALUE);

                        if (pNewAttrs != NULL)
                        {
                            if (ppi->cAttributes != 0)
                            {
                                hr = pNewAttrs->SetAttributePairs((LPTSTR)(((PBYTE)ppi)+ppi->uOffsetAttributes),
                                                                  ppi->cAttributes);
                            };

                            if (SUCCEEDED(hr))
                            {
                                pAttrs = pNewAttrs;
                                pNewAttrs->AddRef();
                            }
                            else
                            {
                                delete pNewAttrs;
                            };
                        }
                        else
                        {
                            hr = ULS_E_MEMORY;
                        };
                    };
                };
            };
        };
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CUlsProt::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsProt::QueryInterface (REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (riid == IID_IULSAppProtocol || riid == IID_IUnknown)
    {
        *ppv = (IULSUser *) this;
    };

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        return ULS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CUlsProt::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:14:17  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CUlsProt::AddRef (void)
{
    cRef++;
    return cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CUlsProt::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:14:26  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CUlsProt::Release (void)
{
    cRef--;

    if (cRef == 0)
    {
        delete this;
        return 0;
    }
    else
    {
        return cRef;
    };
}

//****************************************************************************
// STDMETHODIMP
// CUlsProt::GetID (BSTR *pbstrID)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsProt::GetID (BSTR *pbstrID)
{
    // Validate parameter
    //
    if (pbstrID == NULL)
    {
        return ULS_E_POINTER;
    };

    return LPTSTR_to_BSTR(pbstrID, szName);
}

//****************************************************************************
// STDMETHODIMP
// CUlsProt::GetPortNumber (ULONG *puPortNumber)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsProt::GetPortNumber (ULONG *puPortNumber)
{
    // Validate parameter
    //
    if (puPortNumber == NULL)
    {
        return ULS_E_POINTER;
    };
    
    *puPortNumber = uPort;

    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CUlsProt::GetMimeType (BSTR *pbstrMimeType)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsProt::GetMimeType (BSTR *pbstrMimeType)
{
    // Validate parameter
    //
    if (pbstrMimeType == NULL)
    {
        return ULS_E_POINTER;
    };

    return LPTSTR_to_BSTR(pbstrMimeType, szMimeType);
}

//****************************************************************************
// STDMETHODIMP
// CUlsProt::GetAttributes (IULSAttributes **ppAttributes)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsProt::GetAttributes (IULSAttributes **ppAttributes)
{
    // Validate parameter
    //
    if (ppAttributes == NULL)
    {
        return ULS_E_POINTER;
    };

    *ppAttributes = pAttrs;
    pAttrs->AddRef();

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\ulsuser.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       ulsuser.h
//  Content:    This file contains the User object definition.
//  History:
//      Wed 17-Apr-1996 11:18:47  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#ifndef _ULSUSER_H_
#define _ULSUSER_H_

#include "connpt.h"

//****************************************************************************
// CUlsUser definition
//****************************************************************************
//
class CUlsUser : public IULSUser,
                 public IConnectionPointContainer 
{
private:
    ULONG                   cRef;
    LPTSTR                  szServer;
    LPTSTR                  szID;
    LPTSTR                  szFirstName;
    LPTSTR                  szLastName;
    LPTSTR                  szEMailName;
    LPTSTR                  szCityName;
    LPTSTR                  szCountryName;
    LPTSTR                  szComment;
    LPTSTR                  szIPAddr;
    DWORD					m_dwFlags;
    CConnectionPoint        *pConnPt;

    // Private method
    //
    STDMETHODIMP    NotifySink (void *pv, CONN_NOTIFYPROC pfn);

public:
    // Constructor and destructor
    CUlsUser (void);
    ~CUlsUser (void);
    STDMETHODIMP            Init (LPTSTR szServerName,
                                  PLDAP_USERINFO pui);

    // Asynchronous response
    //
    STDMETHODIMP    GetApplicationResult (ULONG uReqID,
                                          PLDAP_APPINFO_RES plar);
    STDMETHODIMP    EnumApplicationsResult (ULONG uReqID,
                                            PLDAP_ENUM ple);

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IULSUser
    STDMETHODIMP    GetID (BSTR *pbstrID);
    STDMETHODIMP    GetFirstName (BSTR *pbstrName);
    STDMETHODIMP    GetLastName (BSTR *pbstrName);
    STDMETHODIMP    GetEMailName (BSTR *pbstrName);
    STDMETHODIMP    GetCityName (BSTR *pbstrName);
    STDMETHODIMP    GetCountryName (BSTR *pbstrName);
    STDMETHODIMP    GetComment (BSTR *pbstrComment);
    STDMETHODIMP    GetFlags (DWORD *pdwFlags);
    STDMETHODIMP    GetIPAddress (BSTR *pbstrIPAddress);
    STDMETHODIMP    GetApplication (BSTR bstrAppName,
    								IULSAttributes *pAttributes,
                                    ULONG *puReqID);
    STDMETHODIMP    EnumApplications (ULONG *puReqID);

    // IConnectionPointContainer
    STDMETHODIMP    EnumConnectionPoints(IEnumConnectionPoints **ppEnum);
    STDMETHODIMP    FindConnectionPoint(REFIID riid,
                                        IConnectionPoint **ppcp);
};

//****************************************************************************
// CEnumUsers definition
//****************************************************************************
//
class CEnumUsers : public IEnumULSUsers
{
private:
    ULONG                   cRef;
    CUlsUser                **ppu;
    ULONG                   cUsers;
    ULONG                   iNext;

public:
    // Constructor and Initialization
    CEnumUsers (void);
    ~CEnumUsers (void);
    STDMETHODIMP            Init (CUlsUser **ppuList, ULONG cUsers);

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IEnumULSAttributes
    STDMETHODIMP            Next(ULONG cUsers, IULSUser **rgpu,
                                 ULONG *pcFetched);
    STDMETHODIMP            Skip(ULONG cUsers);
    STDMETHODIMP            Reset();
    STDMETHODIMP            Clone(IEnumULSUsers **ppEnum);
};

#endif //_ULSUSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\ulsuser.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       ulsuser.cpp
//  Content:    This file contains the User object.
//  History:
//      Wed 17-Apr-1996 11:13:54  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#include "ulsp.h"
#include "ulsuser.h"
#include "ulsapp.h"
#include "culs.h"
#include "attribs.h"
#include "callback.h"

//****************************************************************************
// Event Notifiers
//****************************************************************************
//
//****************************************************************************
// HRESULT
// OnNotifyGetApplicationResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
OnNotifyGetApplicationResult (IUnknown *pUnk, void *pv)
{
    POBJRINFO pobjri = (POBJRINFO)pv;

    ((IULSUserNotify*)pUnk)->GetApplicationResult(pobjri->uReqID,
                                                  (IULSApplication *)pobjri->pv,
                                                  pobjri->hResult);
    return S_OK;
}

//****************************************************************************
// HRESULT
// OnNotifyEnumApplicationsResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
OnNotifyEnumApplicationsResult (IUnknown *pUnk, void *pv)
{
    CEnumNames  *penum  = NULL;
    PENUMRINFO  peri    = (PENUMRINFO)pv;
    HRESULT     hr      = peri->hResult;

    if (SUCCEEDED(hr))
    {
        // Create a Application enumerator
        //
        penum = new CEnumNames;

        if (penum != NULL)
        {
            hr = penum->Init((LPTSTR)peri->pv, peri->cItems);

            if (SUCCEEDED(hr))
            {
                penum->AddRef();
            }
            else
            {
                delete penum;
                penum = NULL;
            };
        }
        else
        {
            hr = ULS_E_MEMORY;
        };
    };

    // Notify the sink object
    //
    ((IULSUserNotify*)pUnk)->EnumApplicationsResult(peri->uReqID,
                                                    penum != NULL ? 
                                                    (IEnumULSNames *)penum :
                                                    NULL,
                                                    hr);

    if (penum != NULL)
    {
        penum->Release();
    };
    return hr;
}

//****************************************************************************
// Class Implementation
//****************************************************************************
//
//****************************************************************************
// CUlsUser::CUlsUser (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CUlsUser::CUlsUser (void)
{
    cRef        = 0;
    szServer    = NULL;
    szID        = NULL;
    szFirstName = NULL;
    szLastName  = NULL;
    szEMailName = NULL;
    szCityName  = NULL;
    szCountryName= NULL;
    szComment   = NULL;
    szIPAddr    = NULL;
	m_dwFlags   = 0;
    pConnPt     = NULL;

    return;
}

//****************************************************************************
// CUlsUser::~CUlsUser (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CUlsUser::~CUlsUser (void)
{
    if (szServer != NULL)
        FreeLPTSTR(szServer);
    if (szID != NULL)
        FreeLPTSTR(szID);
    if (szFirstName != NULL)
        FreeLPTSTR(szFirstName);
    if (szLastName != NULL)
        FreeLPTSTR(szLastName);
    if (szEMailName != NULL)
        FreeLPTSTR(szEMailName);
    if (szCityName != NULL)
        FreeLPTSTR(szCityName);
    if (szCountryName != NULL)
        FreeLPTSTR(szCountryName);
    if (szComment != NULL)
        FreeLPTSTR(szComment);
    if (szIPAddr != NULL)
        FreeLPTSTR(szIPAddr);

    // Release the connection point
    //
    if (pConnPt != NULL)
    {
        pConnPt->ContainerReleased();
        ((IConnectionPoint*)pConnPt)->Release();
    };

    return;
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::Init (LPTSTR szServerName, PLDAP_USERINFO *pui)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::Init (LPTSTR szServerName, PLDAP_USERINFO pui)
{
    HRESULT hr;

    // Validate parameter
    //
    if ((pui->uSize != sizeof(*pui))    ||
        (pui->uOffsetName       == 0))
    {
        return ULS_E_PARAMETER;
    };

    // Remember the server name
    //
    hr = SafeSetLPTSTR(&szServer, szServerName);

    if (SUCCEEDED(hr))
    {
        hr = SafeSetLPTSTR(&szID, (LPCTSTR)(((PBYTE)pui)+pui->uOffsetName));

        if (SUCCEEDED(hr))
        {
            hr = SafeSetLPTSTR(&szFirstName,
                           (LPCTSTR)(((PBYTE)pui)+pui->uOffsetFirstName));

            if (SUCCEEDED(hr))
            {
                hr = SafeSetLPTSTR(&szLastName,
                               (LPCTSTR)(((PBYTE)pui)+pui->uOffsetLastName));

                if (SUCCEEDED(hr))
                {
                    hr = SafeSetLPTSTR(&szEMailName,
                                   (LPCTSTR)(((PBYTE)pui)+pui->uOffsetEMailName));

                    if (SUCCEEDED(hr))
                    {
                        hr = SafeSetLPTSTR(&szCityName,
                                       (LPCTSTR)(((PBYTE)pui)+pui->uOffsetCityName));

                        if (SUCCEEDED(hr))
                        {
                            hr = SafeSetLPTSTR(&szCountryName, (LPCTSTR)(((PBYTE)pui)+
                                                           pui->uOffsetCountryName));

                            if (SUCCEEDED(hr))
                            {
                                hr = SafeSetLPTSTR(&szComment, (LPCTSTR)(((PBYTE)pui)+
                                                           pui->uOffsetComment));

                                if (SUCCEEDED(hr))
                                {
                                    hr = SafeSetLPTSTR(&szIPAddr, (LPCTSTR)(((PBYTE)pui)+
                                                              pui->uOffsetIPAddress));
                                    m_dwFlags = pui->dwFlags;
                                };
                            };
                        };
                    };
                };
            };
        };
    };

    if (SUCCEEDED(hr))
    {
        // Make the connection point
        //
        pConnPt = new CConnectionPoint (&IID_IULSUserNotify,
                                        (IConnectionPointContainer *)this);
        if (pConnPt != NULL)
        {
            ((IConnectionPoint*)pConnPt)->AddRef();
            hr = NOERROR;
        }
        else
        {
            hr = ULS_E_MEMORY;
        };
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::QueryInterface (REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (riid == IID_IULSUser || riid == IID_IUnknown)
    {
        *ppv = (IULSUser *) this;
    }
    else
    {
        if (riid == IID_IConnectionPointContainer)
        {
            *ppv = (IConnectionPointContainer *) this;
        };
    };

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        return ULS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CUlsUser::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:14:17  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CUlsUser::AddRef (void)
{
    cRef++;
    return cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CUlsUser::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:14:26  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CUlsUser::Release (void)
{
    cRef--;

    if (cRef == 0)
    {
        delete this;
        return 0;
    }
    else
    {
        return cRef;
    };
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::NotifySink (void *pv, CONN_NOTIFYPROC pfn)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::NotifySink (void *pv, CONN_NOTIFYPROC pfn)
{
    HRESULT hr = S_OK;

    if (pConnPt != NULL)
    {
        hr = pConnPt->Notify(pv, pfn);
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::GetID (BSTR *pbstrID)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::GetID (BSTR *pbstrID)
{
    // Validate parameter
    //
    if (pbstrID == NULL)
    {
        return E_POINTER;
    };

    return LPTSTR_to_BSTR(pbstrID, szID);
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::GetFirstName (BSTR *pbstrName)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::GetFirstName (BSTR *pbstrName)
{
    // Validate parameter
    //
    if (pbstrName == NULL)
    {
        return E_POINTER;
    };

    return LPTSTR_to_BSTR(pbstrName, szFirstName);
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::GetLastName (BSTR *pbstrName)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::GetLastName (BSTR *pbstrName)
{
    // Validate parameter
    //
    if (pbstrName == NULL)
    {
        return E_POINTER;
    };

    return LPTSTR_to_BSTR(pbstrName, szLastName);
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::GetEMailName (BSTR *pbstrName)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::GetEMailName (BSTR *pbstrName)
{
    // Validate parameter
    //
    if (pbstrName == NULL)
    {
        return E_POINTER;
    };

    return LPTSTR_to_BSTR(pbstrName, szEMailName);
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::GetCityName (BSTR *pbstrName)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::GetCityName (BSTR *pbstrName)
{
    // Validate parameter
    //
    if (pbstrName == NULL)
    {
        return E_POINTER;
    };

    return LPTSTR_to_BSTR(pbstrName, szCityName);
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::GetCountryName (BSTR *pbstrName)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::GetCountryName (BSTR *pbstrName)
{
    // Validate parameter
    //
    if (pbstrName == NULL)
    {
        return E_POINTER;
    };

    return LPTSTR_to_BSTR(pbstrName, szCountryName);
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::GetComment (BSTR *pbstrComment)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::GetComment (BSTR *pbstrComment)
{
    // Validate parameter
    //
    if (pbstrComment == NULL)
    {
        return E_POINTER;
    };

    return LPTSTR_to_BSTR(pbstrComment, szComment);
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::GetFlags ( DWORD *pdwFlags )
//
// History:
//  Tue 05-Nov-1996 10:30:00  -by-  Chu, Lon-Chan [lonchanc]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::GetFlags ( DWORD *pdwFlags )
{
    // Validate parameter
    //
    if (pdwFlags == NULL)
        return ULS_E_POINTER;

	*pdwFlags = m_dwFlags;
	return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::GetIPAddress (BSTR *pbstrAddr)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::GetIPAddress (BSTR *pbstrAddr)
{
    // Validate parameter
    //
    if (pbstrAddr == NULL)
    {
        return E_POINTER;
    };

    return LPTSTR_to_BSTR(pbstrAddr, szIPAddr);
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::GetApplication (REFGUID rguid, ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::GetApplication (BSTR bstrAppName, IULSAttributes *pAttributes, ULONG *puReqID)
{
    LDAP_ASYNCINFO ldai; 
    LPTSTR pszAppName;
    HRESULT hr;

    // Validate parameter
    //
    if (bstrAppName == NULL || puReqID == NULL)
        return E_POINTER;

	// Convert application name
	//
    hr = BSTR_to_LPTSTR (&pszAppName, bstrAppName);
    if (hr != S_OK)
    	return hr;

	// Get arbitrary attribute name list if any
	//
	ULONG cAttrNames = 0;
	ULONG cbNames = 0;
	TCHAR *pszAttrNameList = NULL;
	if (pAttributes != NULL)
	{
		hr = ((CAttributes *) pAttributes)->GetAttributeList (&pszAttrNameList, &cAttrNames, &cbNames);
		if (hr != S_OK)
			return hr;
	}

    hr = ::UlsLdap_ResolveApp (szServer, szID, pszAppName,
    							pszAttrNameList, cAttrNames, &ldai);
    if (hr != S_OK)
    	goto MyExit;

	// If updating server was successfully requested, wait for the response
	//
	REQUESTINFO ri;
	ZeroMemory (&ri, sizeof (ri));
	ri.uReqType = WM_ULS_RESOLVE_APP;
	ri.uMsgID = ldai.uMsgID;
	ri.pv     = (PVOID) this;
	ri.lParam = NULL;

	// Remember this request
	//
	hr = g_pReqMgr->NewRequest (&ri);
	if (SUCCEEDED(hr))
	{
	    // Make sure the objects do not disappear before we get the response
	    //
	    this->AddRef();

	    // Return the request ID
	    //
	    *puReqID = ri.uReqID;
	}

MyExit:

	if (pszAttrNameList != NULL)
		FreeLPTSTR (pszAttrNameList);

	if (pszAppName != NULL)
		FreeLPTSTR(pszAppName);

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::GetApplicationResult (ULONG uReqID, PLDAP_APPINFO_RES pair)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::GetApplicationResult (ULONG uReqID, PLDAP_APPINFO_RES pair)
{
    CUlsApp *pa;
    OBJRINFO objri;

    // Default to the server's result
    //
    objri.hResult = pair->hResult;

    if (SUCCEEDED(objri.hResult))
    {
        // The server returns APPINFO, create a Application object
        //
        pa = new CUlsApp;

        if (pa != NULL)
        {
            objri.hResult = pa->Init(szServer, szID, &pair->lai);
            if (SUCCEEDED(objri.hResult))
            {
                pa->AddRef();
            }
            else
            {
                delete pa;
                pa = NULL;
            };
        }
        else
        {
            objri.hResult = ULS_E_MEMORY;
        };
    }
    else
    {
        pa = NULL;
    };

    // Package the notification info
    //
    objri.uReqID = uReqID;
    objri.pv = (void *)(pa == NULL ? NULL : (IULSApplication *)pa);
    NotifySink((void *)&objri, OnNotifyGetApplicationResult);

    if (pa != NULL)
    {
        pa->Release();
    };
    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::EnumApplications (ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::EnumApplications (ULONG *puReqID)
{
    LDAP_ASYNCINFO ldai; 
    HRESULT hr;

    // Validate parameter
    //
    if (puReqID == NULL)
    {
        return E_POINTER;
    };

    hr = ::UlsLdap_EnumApps(szServer, szID, &ldai);

    if (SUCCEEDED(hr))
    {
        REQUESTINFO ri;

        // If updating server was successfully requested, wait for the response
        //
        ri.uReqType = WM_ULS_ENUM_APPS;
        ri.uMsgID = ldai.uMsgID;
        ri.pv     = (PVOID)this;
        ri.lParam = (LPARAM)NULL;

        hr = g_pReqMgr->NewRequest(&ri);

        if (SUCCEEDED(hr))
        {
            // Make sure the objects do not disappear before we get the response
            //
            this->AddRef();

            // Return the request ID
            //
            *puReqID = ri.uReqID;
        };
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::EnumApplicationsResult (ULONG uReqID, PLDAP_ENUM ple)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::EnumApplicationsResult (ULONG uReqID, PLDAP_ENUM ple)
{
    ENUMRINFO eri;

    // Package the notification info
    //
    eri.uReqID  = uReqID;
    eri.hResult = ple->hResult;
    eri.cItems  = ple->cItems;
    eri.pv      = (void *)(((PBYTE)ple)+ple->uOffsetItems);
    NotifySink((void *)&eri, OnNotifyEnumApplicationsResult);
    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
//
// History:
//  Wed 17-Apr-1996 11:15:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
{
    CEnumConnectionPoints *pecp;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return E_POINTER;
    };
    
    // Assume failure
    //
    *ppEnum = NULL;

    // Create an enumerator
    //
    pecp = new CEnumConnectionPoints;
    if (pecp == NULL)
        return ULS_E_MEMORY;

    // Initialize the enumerator
    //
    hr = pecp->Init((IConnectionPoint *)pConnPt);
    if (FAILED(hr))
    {
        delete pecp;
        return hr;
    };

    // Give it back to the caller
    //
    pecp->AddRef();
    *ppEnum = pecp;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::FindConnectionPoint(REFIID riid, IConnectionPoint **ppcp)
//
// History:
//  Wed 17-Apr-1996 11:15:09  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::FindConnectionPoint(REFIID riid, IConnectionPoint **ppcp)
{
    IID siid;
    HRESULT hr;

    // Validate parameters
    //
    if (ppcp == NULL)
    {
        return E_POINTER;
    };
    
    // Assume failure
    //
    *ppcp = NULL;

    if (pConnPt != NULL)
    {
        hr = pConnPt->GetConnectionInterface(&siid);

        if (SUCCEEDED(hr))
        {
            if (riid == siid)
            {
                *ppcp = (IConnectionPoint *)pConnPt;
                (*ppcp)->AddRef();
                hr = S_OK;
            }
            else
            {
                hr = ULS_E_NO_INTERFACE;
            };
        };
    }
    else
    {
        hr = ULS_E_NO_INTERFACE;
    };

    return hr;
}

//****************************************************************************
// CEnumUsers::CEnumUsers (void)
//
// History:
//  Wed 17-Apr-1996 11:15:18  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CEnumUsers::CEnumUsers (void)
{
    cRef    = 0;
    ppu     = NULL;
    cUsers  = 0;
    iNext   = 0;
    return;
}

//****************************************************************************
// CEnumUsers::~CEnumUsers (void)
//
// History:
//  Wed 17-Apr-1996 11:15:18  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CEnumUsers::~CEnumUsers (void)
{
    ULONG i;

    if (ppu != NULL)
    {
        for (i = 0; i < cUsers; i++)
        {
            ppu[i]->Release();
        };
        LocalFree(ppu);
    };
    return;
}

//****************************************************************************
// STDMETHODIMP
// CEnumUsers::Init (CUlsUser **ppuList, ULONG cUsers)
//
// History:
//  Wed 17-Apr-1996 11:15:25  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumUsers::Init (CUlsUser **ppuList, ULONG cUsers)
{
    HRESULT hr = NOERROR;

    // If no list, do nothing
    //
    if (cUsers != 0)
    {
        ASSERT(ppuList != NULL);

        // Allocate the snapshot buffer
        //
        ppu = (CUlsUser **)LocalAlloc(LPTR, cUsers*sizeof(CUlsUser *));

        if (ppu != NULL)
        {
            ULONG i;

            // Snapshot the object list
            //
            for (i =0; i < cUsers; i++)
            {
                ppu[i] = ppuList[i];
                ppu[i]->AddRef();
            };
            this->cUsers = cUsers;
        }
        else
        {
            hr = ULS_E_MEMORY;
        };
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CEnumUsers::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:15:31  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumUsers::QueryInterface (REFIID riid, void **ppv)
{
    if (riid == IID_IEnumULSUsers || riid == IID_IUnknown)
    {
        *ppv = (IEnumULSUsers *) this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return ULS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumUsers::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:15:37  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumUsers::AddRef (void)
{
    cRef++;
    return cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumUsers::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:15:43  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumUsers::Release (void)
{
    cRef--;

    if (cRef == 0)
    {
        delete this;
        return 0;
    }
    else
    {
        return cRef;
    };
}

//****************************************************************************
// STDMETHODIMP 
// CEnumUsers::Next (ULONG cUsers, IULSUser **rgpu, ULONG *pcFetched)
//
// History:
//  Wed 17-Apr-1996 11:15:49  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP 
CEnumUsers::Next (ULONG cUsers, IULSUser **rgpu, ULONG *pcFetched)
{
    ULONG   cCopied;
    HRESULT hr;

    // Validate the pointer
    //
    if (rgpu == NULL)
        return E_POINTER;

    // Validate the parameters
    //
    if ((cUsers == 0) ||
        ((cUsers > 1) && (pcFetched == NULL)))
        return ULS_E_PARAMETER;

    // Check the enumeration index
    //
    cCopied = 0;

    // Can copy if we still have more attribute names
    //
    while ((cCopied < cUsers) &&
           (iNext < this->cUsers))
    {
        ppu[iNext]->AddRef();
        rgpu[cCopied++] = ppu[iNext++];
    };

    // Determine the returned information based on other parameters
    //
    if (pcFetched != NULL)
    {
        *pcFetched = cCopied;
    };
    return (cUsers == cCopied ? S_OK : S_FALSE);
}

//****************************************************************************
// STDMETHODIMP
// CEnumUsers::Skip (ULONG cUsers)
//
// History:
//  Wed 17-Apr-1996 11:15:56  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumUsers::Skip (ULONG cUsers)
{
    ULONG iNewIndex;

    // Validate the parameters
    //
    if (cUsers == 0) 
        return ULS_E_PARAMETER;

    // Check the enumeration index limit
    //
    iNewIndex = iNext+cUsers;
    if (iNewIndex <= this->cUsers)
    {
        iNext = iNewIndex;
        return S_OK;
    }
    else
    {
        iNext = this->cUsers;
        return S_FALSE;
    };
}

//****************************************************************************
// STDMETHODIMP
// CEnumUsers::Reset (void)
//
// History:
//  Wed 17-Apr-1996 11:16:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumUsers::Reset (void)
{
    iNext = 0;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CEnumUsers::Clone(IEnumULSUsers **ppEnum)
//
// History:
//  Wed 17-Apr-1996 11:16:11  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumUsers::Clone(IEnumULSUsers **ppEnum)
{
    CEnumUsers *peu;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return E_POINTER;
    };

    *ppEnum = NULL;

    // Create an enumerator
    //
    peu = new CEnumUsers;
    if (peu == NULL)
        return ULS_E_MEMORY;

    // Clone the information
    //
    hr = peu->Init(ppu, cUsers);

    if (SUCCEEDED(hr))
    {
        peu->iNext = iNext;

        // Return the cloned enumerator
        //
        peu->AddRef();
        *ppEnum = peu;
    }
    else
    {
        delete peu;
    };
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\published\dload\odbc32.c ===
#include "enduserpch.h"
#pragma hdrstop

#include <sql.h>
#include <sqlext.h>
#include <sqltypes.h>

static
SQLRETURN  SQL_API SQLAllocConnect(SQLHENV EnvironmentHandle,
           SQLHDBC *ConnectionHandle)
{
    return SQL_ERROR;
}

static
SQLRETURN  SQL_API SQLAllocEnv(SQLHENV *EnvironmentHandle)
{
    return SQL_ERROR;
}

static
SQLRETURN  SQL_API SQLDisconnect(SQLHDBC ConnectionHandle)
{
    return SQL_ERROR;
}

static
SQLRETURN  SQL_API SQLExecute(SQLHSTMT StatementHandle)
{
    return SQL_ERROR;
}

static
SQLRETURN  SQL_API SQLAllocHandle(SQLSMALLINT HandleType,
           SQLHANDLE InputHandle, SQLHANDLE *OutputHandle)
{
    return SQL_ERROR;
}

static
SQLRETURN  SQL_API SQLFreeHandle(SQLSMALLINT HandleType, SQLHANDLE Handle)
{
    return SQL_ERROR;
}

static
SQLRETURN  SQL_API SQLSetConnectAttr(SQLHDBC ConnectionHandle,
           SQLINTEGER Attribute, SQLPOINTER Value,
           SQLINTEGER StringLength)
{
    return SQL_ERROR;
}

static
SQLRETURN SQL_API SQLBindParameter(
    SQLHSTMT           hstmt,
    SQLUSMALLINT       ipar,
    SQLSMALLINT        fParamType,
    SQLSMALLINT        fCType,
    SQLSMALLINT        fSqlType,
    SQLULEN            cbColDef,
    SQLSMALLINT        ibScale,
    SQLPOINTER         rgbValue,
    SQLLEN             cbValueMax,
    SQLLEN     		   *pcbValue)
{
    return SQL_ERROR;
}

static
SQLRETURN  SQL_API SQLSetEnvAttr(SQLHENV EnvironmentHandle,
           SQLINTEGER Attribute, SQLPOINTER Value,
           SQLINTEGER StringLength)
{
    return SQL_ERROR;
}

static
SQLRETURN SQL_API SQLErrorW(
    SQLHENV            henv,
    SQLHDBC            hdbc,
    SQLHSTMT           hstmt,
    SQLWCHAR        *szSqlState,
    SQLINTEGER     *pfNativeError,
    SQLWCHAR        *szErrorMsg,
    SQLSMALLINT        cbErrorMsgMax,
    SQLSMALLINT    *pcbErrorMsg)
{
    return SQL_ERROR;
}

static
SQLRETURN SQL_API SQLPrepareW(
    SQLHSTMT           hstmt,
    SQLWCHAR        *szSqlStr,
    SQLINTEGER         cbSqlStr)
{
    return SQL_ERROR;
}

static
SQLRETURN SQL_API SQLDriverConnectW(
    SQLHDBC            hdbc,
    SQLHWND            hwnd,
    SQLWCHAR        *szConnStrIn,
    SQLSMALLINT        cbConnStrIn,
    SQLWCHAR        *szConnStrOut,
    SQLSMALLINT        cbConnStrOutMax,
    SQLSMALLINT    *pcbConnStrOut,
    SQLUSMALLINT       fDriverCompletion)
{
    return SQL_ERROR;
}



//
// !! WARNING !! The entries below must be in order by ORDINAL
//

DEFINE_ORDINAL_ENTRIES(odbc32)
{
    DLOENTRY(1,SQLAllocConnect)
    DLOENTRY(2,SQLAllocEnv)
    DLOENTRY(9,SQLDisconnect)
    DLOENTRY(12,SQLExecute)
    DLOENTRY(24,SQLAllocHandle)
    DLOENTRY(31,SQLFreeHandle)
    DLOENTRY(39,SQLSetConnectAttr)
    DLOENTRY(72,SQLBindParameter)
    DLOENTRY(75,SQLSetEnvAttr)
    DLOENTRY(110,SQLErrorW)
    DLOENTRY(119,SQLPrepareW)
    DLOENTRY(139,SQLSetConnectAttr)     // this is really SQLSetConnectAttrW, but the calling convention is the same as SQLSetConnectAttr
    DLOENTRY(141,SQLDriverConnectW)
};

DEFINE_ORDINAL_MAP(odbc32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\published\dload\enduserpch.h ===
#pragma once

#include <dloadexcept.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\published\dload\hlink.c ===
#include "enduserpch.h"
#pragma hdrstop

#include <hlink.h>

static 
STDMETHODIMP HlinkCreateFromMoniker(
             IMoniker * pimkTrgt,
             LPCWSTR pwzLocation,
             LPCWSTR pwzFriendlyName,
             IHlinkSite * pihlsite,
             DWORD dwSiteData,
             IUnknown * piunkOuter,
             REFIID riid,
             void ** ppvObj)
               
{
    *ppvObj = NULL;
    return E_FAIL;
}

//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(hlink)
{
    DLOENTRY(3, HlinkCreateFromMoniker)
};

DEFINE_ORDINAL_MAP(hlink)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\utils.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       utils.h
//  Content:    Declaration utiltity functions and classes
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

//****************************************************************************
// Global Utilities
//****************************************************************************
//

#ifdef _DEBUG
extern LONG g_cCritSec;
#endif

inline VOID MyInitializeCriticalSection ( LPCRITICAL_SECTION pcs )
{
	InitializeCriticalSection (pcs);
#ifdef _DEBUG
	g_cCritSec++;
#endif
}

inline VOID MyDeleteCriticalSection ( LPCRITICAL_SECTION pcs )
{
	DeleteCriticalSection (pcs);
#ifdef _DEBUG
	g_cCritSec--;
#endif
}


HRESULT     SetLPTSTR (LPTSTR *ppszName, LPCTSTR pszUserName);
HRESULT     SafeSetLPTSTR (LPTSTR *ppszName, LPCTSTR pszUserName);
HRESULT		SetOffsetString ( TCHAR **ppszDst, BYTE *pSrcBase, ULONG uSrcOffset );
HRESULT     LPTSTR_to_BSTR (BSTR *pbstr, LPCTSTR psz);
HRESULT     BSTR_to_LPTSTR (LPTSTR *ppsz, BSTR bstr);
BOOL IsLegalEmailName ( TCHAR *pszName );

//****************************************************************************
// CList definition
//****************************************************************************
//
typedef struct  tagpNode {
    struct  tagpNode    *pNext;
    LPVOID              pv;
} NODE, *PNODE;

class   CList
{
private:
    PNODE   pHead;
    PNODE   pTail;

public:
    CList(void);
    ~CList(void);

    HRESULT Insert      (LPVOID pv);
    HRESULT Append      (LPVOID pv);
    HRESULT Remove      (LPVOID pv);

    HRESULT Find        (LPVOID pv);
    HRESULT FindStorage (LPVOID *ppv, LPVOID pv);

    HRESULT Enumerate   (HANDLE *phEnum);
    HRESULT Next        (HANDLE *phEnum, LPVOID *ppv);
    HRESULT NextStorage (HANDLE *phEnum, LPVOID *ppv);
    
    HRESULT Flush       (void);

    HRESULT Clone       (CList *pList, HANDLE *phEnum);
};

//****************************************************************************
// CEnumNames definition
//****************************************************************************
//
class CEnumNames : public IEnumIlsNames
{
private:

    ULONG                   cRef;
    LPTSTR                  pNext;
    LPTSTR                  pszNames;
    ULONG                   cbSize;

public:
    // Constructor and Initialization
    CEnumNames (void);
    ~CEnumNames (void);
    STDMETHODIMP            Init (LPTSTR pList, ULONG cNames);

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IEnumIlsAttributes
    STDMETHODIMP            Next(ULONG cNames, BSTR *rgpbstrName,
                                 ULONG *pcFetched);
    STDMETHODIMP            Skip(ULONG cNames);
    STDMETHODIMP            Reset();
    STDMETHODIMP            Clone(IEnumIlsNames **ppEnum);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ulsldap\utils.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       utils.cpp
//  Content:    Miscellaneous utility functions and classes
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#include "ulsp.h"

//****************************************************************************
// HRESULT
// SetLPTSTR (LPTSTR *ppszName, LPCTSTR pszUserName)
//
// Purpose: Clone the provided string into a newly allocated buffer.
//
// Parameters:
//  ppszName        The buffer to receive a newly allocated string buffer.
//  pszUserName     The provided name string.
//
// Return Value:  
//  S_OK            success if the string can be cloned.
//  ILS_E_MEMORY   if the string cannot be cloned.
//****************************************************************************

HRESULT
SetLPTSTR (LPTSTR *ppszName, LPCTSTR pszUserName)
{
	HRESULT hr;

    TCHAR *pszNew = My_strdup (pszUserName);
    if (pszNew != NULL)
    {
        // Free the old name
        //
        ::MemFree (*ppszName);
        *ppszName = pszNew;
        hr = S_OK;
    }
    else
    {
        hr = ILS_E_MEMORY;
    }

    return hr;
}

//****************************************************************************
// HRESULT
// SafeSetLPTSTR (LPTSTR *ppszName, LPCTSTR pszUserName)
//
// Purpose: Clone the provided string into a newly allocated buffer.
//          It is ok that the provided string is NULL.
//
// Parameters:
//  ppszName        The buffer to receive a newly allocated string buffer.
//  pszUserName     The provided name string.
//
// Return Value:  
//  S_OK            success if the string can be cloned.
//  ILS_E_MEMORY   if the non-null string cannot be cloned.
//****************************************************************************

HRESULT
SafeSetLPTSTR (LPTSTR *ppszName, LPCTSTR pszUserName)
{
	if (pszUserName == NULL)
	{
		MemFree (*ppszName);
		*ppszName = NULL;
		return S_FALSE;
	}

	return SetLPTSTR (ppszName, pszUserName);
}

//****************************************************************************
// HRESULT
// SetOffsetString ( TCHAR **ppszDst, BYTE *pSrcBase, ULONG uSrcOffset )
//
// Purpose: Clone the provided string into a newly allocated buffer.
//			If the source string is null or empty, the destination string
//			will be null.
//
// Parameters:
//
// Return Value:  
//  S_OK            success if the string can be cloned.
//  S_FALSE			the destination string is null
//  ILS_E_MEMORY   if the string cannot be cloned.
//****************************************************************************

HRESULT
SetOffsetString ( TCHAR **ppszDst, BYTE *pSrcBase, ULONG uSrcOffset )
{
	HRESULT hr = S_FALSE;
	TCHAR *pszNew = NULL;

	if (uSrcOffset != INVALID_OFFSET)
	{
		TCHAR *pszSrc = (TCHAR *) (pSrcBase + uSrcOffset);
		if (*pszSrc != TEXT ('\0'))
		{
			pszNew = My_strdup (pszSrc);
			hr = (pszNew != NULL) ? S_OK : ILS_E_MEMORY;
		}
	}

	if (SUCCEEDED (hr))
	{
		::MemFree (*ppszDst);
	     *ppszDst = pszNew;
    }

    return hr;
}

//****************************************************************************
// HRESULT
// LPTSTR_to_BSTR (BSTR *pbstr, LPCTSTR psz)
//
// Purpose: Make a BSTR string from an LPTSTR string
//
// Parameters:
//  pbstr       The buffer to receive a newly allocated BSTR string.
//  psz         The LPTSTR string.
//
// Return Value:  
//  S_OK            success if the string can be cloned.
//  ILS_E_FAIL          cannot convert the string to BSTR
//  ILS_E_MEMORY   cannot allocate enough memory for the BSTR string.
//****************************************************************************

HRESULT
LPTSTR_to_BSTR (BSTR *pbstr, LPCTSTR psz)
{
#ifndef _UNICODE

    BSTR bstr;
    int i;
    HRESULT hr;

    // compute the length of the required BSTR
    //
    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0)
    {
        return ILS_E_FAIL;
    };

    // allocate the widestr, +1 for terminating null
    //
    bstr = SysAllocStringLen(NULL, i-1); // SysAllocStringLen adds 1

    if (bstr != NULL)
    { 
        MultiByteToWideChar(CP_ACP, 0, psz, -1, (LPWSTR)bstr, i);
        ((LPWSTR)bstr)[i - 1] = 0;
        *pbstr = bstr;
        hr = S_OK;
    }
    else
    {
        hr = ILS_E_MEMORY;
    };
    return hr;

#else

    BSTR bstr;

    bstr = SysAllocString(psz);

    if (bstr != NULL)
    {
        *pbstr = bstr;
        return S_OK;
    }
    else
    {
        return ILS_E_MEMORY;
    };

#endif // _UNICODE
}

//****************************************************************************
// HRESULT
// BSTR_to_LPTSTR (LPTSTR *ppsz, BSTR bstr)
//
// Purpose: Make a LPTSTR string from an BSTR string
//
// Parameters:
//  ppsz        The buffer to receive a newly allocated LPTSTR string.
//  bstr        The BSTR string.
//
// Return Value:  
//  S_OK            success if the string can be cloned.
//  ILS_E_FAIL          cannot convert the string to BSTR
//  ILS_E_MEMORY   cannot allocate enough memory for the BSTR string.
//****************************************************************************

HRESULT
BSTR_to_LPTSTR (LPTSTR *ppsz, BSTR bstr)
{
#ifndef _UNICODE

    LPTSTR psz;
    int i;
    HRESULT hr;

    // compute the length of the required BSTR
    //
    i =  WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, NULL, 0, NULL, NULL);
    if (i <= 0)
    {
        return ILS_E_FAIL;
    };

    // allocate the widestr, +1 for terminating null
    //
    psz = (TCHAR *) ::MemAlloc (i * sizeof (TCHAR));
    if (psz != NULL)
    { 
        WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, psz, i, NULL, NULL);
        *ppsz = psz;
        hr = S_OK;
    }
    else
    {
        hr = ILS_E_MEMORY;
    };
    return hr;

#else

    LPTSTR psz = NULL;
    HRESULT hr;

    hr = SetLPTSTR(&psz, (LPTSTR)bstr);

    if (hr == S_OK)
    {
        *ppsz = psz;
    };
    return hr;

#endif // _UNICODE
}

//****************************************************************************
// CList::CList (void)
//
// Purpose: Constructor for the CList class
//
// Parameters: None
//****************************************************************************

CList::CList (void)
{
    pHead = NULL;
    pTail = NULL;
    return;
}

//****************************************************************************
// CList::~CList (void)
//
// Purpose: Constructor for the CList class
//
// Parameters: None
//****************************************************************************

CList::~CList (void)
{
    Flush();
    return;
}

//****************************************************************************
// HRESULT
// CList::Insert (LPVOID pv)
//
// Purpose: Insert an object at the beginning of the list
//
// Parameters: None
//****************************************************************************

HRESULT
CList::Insert (LPVOID pv)
{
    PNODE pNode;

    pNode        = new NODE;
    if (pNode == NULL)
    {
        return ILS_E_MEMORY;
    };

    pNode->pNext = pHead;
    pNode->pv    = pv;
    pHead        = pNode;

    if (pTail == NULL)
    {
        // This is the first node
        //
        pTail = pNode;
    };
    return NOERROR;
}

//****************************************************************************
// HRESULT
// CList::Append (LPVOID pv)
//
// Purpose: Append an object to the end of the list
//
// Parameters: None
//****************************************************************************

HRESULT
CList::Append (LPVOID pv)
{
    PNODE pNode;

    pNode        = new NODE;
    if (pNode == NULL)
    {
        return ILS_E_MEMORY;
    };

    pNode->pNext = NULL;
    pNode->pv    = pv;
    
    if (pHead == NULL)
    {
        pHead = pNode;
    };

    if (pTail != NULL)
    {
        pTail->pNext = pNode;
    };
    pTail        = pNode;

    return NOERROR;
}

//****************************************************************************
// HRESULT
// CList::Remove (LPVOID pv)
//
// Purpose: Append an object to the end of the list
//
// Parameters: None
//****************************************************************************

HRESULT
CList::Remove (LPVOID pv)
{
    PNODE pNode, pPrev;
    HRESULT hr;

    pNode = pHead;
    pPrev = NULL;
    while (pNode != NULL)
    {
        // Matching the requested node
        //
        if (pNode->pv == pv)
        {
            break;  // found!!!
        };

        pPrev = pNode;
        pNode = pNode->pNext;
    };

    if (pNode != NULL)
    {
        // We found the node to remove
        // Update relevant pointer
        //
        if (pTail == pNode)
        {
            pTail = pPrev;
        };

        if (pPrev != NULL)
        {
            pPrev->pNext = pNode->pNext;
        }
        else
        {
            pHead = pNode->pNext;
        };
        delete pNode;
        hr = NOERROR;
    }
    else
    {
        hr = S_FALSE;
    };
    return hr;
}

//****************************************************************************
// HRESULT
// CList::Find (LPVOID pv)
//
// Purpose: Find an object in the list
//
// Parameters: None
//****************************************************************************

HRESULT
CList::Find (LPVOID pv)
{
    PNODE pNode;

    pNode = pHead;
    while (pNode != NULL)
    {
        // Matching the requested node
        //
        if (pNode->pv == pv)
        {
            break;  // found!!!
        };
        pNode = pNode->pNext;
    };

    return (pNode != NULL ? NOERROR : S_FALSE);
}

//****************************************************************************
// HRESULT
// CList::FindStorage (LPVOID *ppv, LPVOID pv)
//
// Purpose: Find an object in the list and returns the object storage.
//          This call is useful for search-and-replace operations.
//
// Parameters: None
//****************************************************************************

HRESULT
CList::FindStorage (LPVOID *ppv, LPVOID pv)
{
    PNODE pNode;
    HRESULT hr;

    pNode = pHead;
    while (pNode != NULL)
    {
        // Matching the requested node
        //
        if (pNode->pv == pv)
        {
            break;  // found!!!
        };
        pNode = pNode->pNext;
    };

    if (pNode != NULL)
    {
        *ppv = &(pNode->pv);
        hr = NOERROR;
    }
    else
    {
        *ppv = NULL;
        hr = S_FALSE;
    };
    return hr;
}

//****************************************************************************
// HRESULT
// CList::Enumerate (HANDLE *phEnum)
//
// Purpose: Start object enumeration
//
// Parameters: None
//****************************************************************************

HRESULT
CList::Enumerate (HANDLE *phEnum)
{
    *phEnum = (HANDLE)pHead;
    return NOERROR;
}

//****************************************************************************
// HRESULT
// CList::Next (HANDLE *phEnum, LPVOID *ppv)
//
// Purpose: Obtain the next enumerated object
//
// Parameters: None
//****************************************************************************

HRESULT
CList::Next (HANDLE *phEnum, LPVOID *ppv)
{
    PNODE pNext;
    HRESULT hr;

    pNext = (PNODE)*phEnum;

    if (pNext == NULL)
    {
        *ppv = NULL;
        hr = S_FALSE;
    }
    else
    {
        *ppv = pNext->pv;
        *phEnum = (HANDLE)(pNext->pNext);
        hr = NOERROR;
    };
    return hr;
}

//****************************************************************************
// HRESULT
// CList::NextStorage (HANDLE *phEnum, LPVOID *ppv)
//
// Purpose: Obtain the storage of the next enumerated object. This call is
//          useful for search-and-replace operations.
//
// Parameters: None
//****************************************************************************

HRESULT
CList::NextStorage (HANDLE *phEnum, LPVOID *ppv)
{
    PNODE pNext;
    HRESULT hr;

    pNext = (PNODE)*phEnum;

    if (pNext == NULL)
    {
        *ppv = NULL;
        hr = S_FALSE;
    }
    else
    {
        *ppv = &(pNext->pv);
        *phEnum = (HANDLE)(pNext->pNext);
        hr = NOERROR;
    };
    return hr;
}

//****************************************************************************
// HRESULT
// CList::Flush (void)
//
// Purpose: Flush all the nodes in the list
//
// Parameters: None
//****************************************************************************

HRESULT
CList::Flush (void)
{
    PNODE pNode;

    while (pHead != NULL)
    {
        pNode = pHead;
        pHead = pHead->pNext;
        delete pNode;
    };
    return NOERROR;
}

//****************************************************************************
// HRESULT
// CList::Clone (CList *pList, HANDLE *phEnum)
//
// Purpose: Flush all the nodes in the list
//
// Parameters: None
//****************************************************************************

HRESULT
CList::Clone (CList *pList, HANDLE *phEnum)
{
    PNODE pNode;
    HRESULT hr;

    // Only allow a null list to be cloned
    //
    if (pHead != NULL)
    {
        return ILS_E_FAIL;
    };

    // Traverse the source list
    //
    hr = S_OK; // lonchanc: in case of null list
    pNode = pList->pHead;
    while(pNode != NULL)
    {
        // Use append to maintain the order
        //
        hr = Append(pNode->pv);
        if (FAILED(hr))
        {
            break;
        };

        // Get the enumerator info
        //
        if ((phEnum != NULL) &&
            (*phEnum == (HANDLE)pNode))
        {
            *phEnum = (HANDLE)pTail;
        };
        pNode = pNode->pNext;
    };
    return hr;
}

//****************************************************************************
// CEnumNames::CEnumNames (void)
//
// History:
//  Wed 17-Apr-1996 11:15:18  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CEnumNames::CEnumNames (void)
{
    cRef = 0;
    pNext = NULL;
    pszNames = NULL;
    cbSize = 0;
    return;
}

//****************************************************************************
// CEnumNames::~CEnumNames (void)
//
// History:
//  Wed 17-Apr-1996 11:15:18  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CEnumNames::~CEnumNames (void)
{
    if (pszNames != NULL)
    {
        ::MemFree (pszNames);
    };
    return;
}

//****************************************************************************
// STDMETHODIMP
// CEnumNames::Init (LPTSTR pList, ULONG cNames)
//
// History:
//  Wed 17-Apr-1996 11:15:25  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumNames::Init (LPTSTR pList, ULONG cNames)
{
    HRESULT hr = NOERROR;

    // If no list, do nothing
    //
    if (cNames != 0)
    {
        LPTSTR pNextSrc;
        ULONG i, cLen, cbSize;

        ASSERT(pList != NULL);

        // Calculate the list size
        //
        pNextSrc = pList;

        for (i = 0, cbSize = 0; i < cNames; i++)
        {
            cLen = lstrlen(pNextSrc)+1;
            pNextSrc += cLen;
            cbSize += cLen;
        };

        // Allocate the snapshot buffer with the specified length
        // plus one for doubly null-termination
        //
        pszNames = (TCHAR *) ::MemAlloc ((cbSize+1) * sizeof (TCHAR));
        if (pszNames != NULL)
        {
            // Snapshot the name list
            //
            CopyMemory(pszNames, pList, cbSize*sizeof(TCHAR));
            pszNames[cbSize] = '\0';
            pNext = pszNames;
            this->cbSize = cbSize+1;
        }
        else
        {
            hr = ILS_E_MEMORY;
        };
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CEnumNames::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:15:31  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumNames::QueryInterface (REFIID riid, void **ppv)
{
    if (riid == IID_IEnumIlsNames || riid == IID_IUnknown)
    {
        *ppv = (IEnumIlsNames *) this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return ILS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumNames::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:15:37  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumNames::AddRef (void)
{
    DllLock();

	MyDebugMsg ((DM_REFCOUNT, "CEnumNames::AddRef: ref=%ld\r\n", cRef));
	::InterlockedIncrement ((LONG *) &cRef);
    return cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumNames::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:15:43  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumNames::Release (void)
{
    DllRelease();

	ASSERT (cRef > 0);

	MyDebugMsg ((DM_REFCOUNT, "CEnumNames::Release: ref=%ld\r\n", cRef));
	if (::InterlockedDecrement ((LONG *) &cRef) == 0)
    {
        delete this;
        return 0;
    }
    return cRef;
}

//****************************************************************************
// STDMETHODIMP 
// CEnumNames::Next (ULONG cNames, BSTR *rgpbstrName, ULONG *pcFetched)
//
// History:
//  Wed 17-Apr-1996 11:15:49  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP 
CEnumNames::Next (ULONG cNames, BSTR *rgpbstrName, ULONG *pcFetched)
{
    ULONG   cCopied;
    HRESULT hr;

    // Validate the pointer
    //
    if (rgpbstrName == NULL)
        return ILS_E_POINTER;

    // Validate the parameters
    //
    if ((cNames == 0) ||
        ((cNames > 1) && (pcFetched == NULL)))
        return ILS_E_PARAMETER;

    // Check the enumeration index
    //
    cCopied = 0;

    if (pNext != NULL)
    {
        // Can copy if we still have more names
        //
        while ((cCopied < cNames) &&
               (*pNext != '\0'))
        {
            if (SUCCEEDED(LPTSTR_to_BSTR(&rgpbstrName[cCopied], pNext)))
            {
                cCopied++;
            };
            pNext += lstrlen(pNext)+1;
        };
    };

    // Determine the returned information based on other parameters
    //
    if (pcFetched != NULL)
    {
        *pcFetched = cCopied;
    };
    return (cNames == cCopied ? S_OK : S_FALSE);
}

//****************************************************************************
// STDMETHODIMP
// CEnumNames::Skip (ULONG cNames)
//
// History:
//  Wed 17-Apr-1996 11:15:56  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumNames::Skip (ULONG cNames)
{
    ULONG cSkipped;

    // Validate the parameters
    //
    if (cNames == 0) 
        return ILS_E_PARAMETER;

    // Check the enumeration index limit
    //
    cSkipped = 0;

    if (pNext != NULL)
    {
        // Can skip only if we still have more attributes
        //
        while ((cSkipped < cNames) &&
               (*pNext != '\0'))
        {
            pNext += lstrlen(pNext)+1;
            cSkipped++;
        };
    };

    return (cNames == cSkipped ? S_OK : S_FALSE);
}

//****************************************************************************
// STDMETHODIMP
// CEnumNames::Reset (void)
//
// History:
//  Wed 17-Apr-1996 11:16:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumNames::Reset (void)
{
    pNext = pszNames;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CEnumNames::Clone(IEnumIlsNames **ppEnum)
//
// History:
//  Wed 17-Apr-1996 11:16:11  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumNames::Clone(IEnumIlsNames **ppEnum)
{
    CEnumNames *peun;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return ILS_E_POINTER;
    };

    *ppEnum = NULL;

    // Create an enumerator
    //
    peun = new CEnumNames;
    if (peun == NULL)
        return ILS_E_MEMORY;

    // Clone the information
    //
    hr = NOERROR;
    peun->cbSize = cbSize;
    if (cbSize != 0)
    {
        peun->pszNames = (TCHAR *) ::MemAlloc (cbSize * sizeof (TCHAR));
        if (peun->pszNames != NULL)
        {
            CopyMemory(peun->pszNames, pszNames, cbSize*sizeof(TCHAR));
            peun->pNext = peun->pszNames+(pNext-pszNames);
        }
        else
        {
            hr = ILS_E_MEMORY;
        };
    }
    else
    {
        peun->pNext = NULL;
        peun->pszNames = NULL;
    };

    if (SUCCEEDED(hr))
    {
        // Return the cloned enumerator
        //
        peun->AddRef();
        *ppEnum = peun;
    }
    else
    {
        delete peun;
    };
    return hr;
}

/*  F  L E G A L  E M A I L  S Z  */
/*-------------------------------------------------------------------------
    %%Function: FLegalEmailSz

    RobD created
		A legal email name contains only ANSI characters.
		"a-z, A-Z, numbers 0-9 and some common symbols"
		It cannot include extended characters or < > ( ) /

	loncahnc modified
		IsLegalEmailName ( TCHAR *pszName ).
		A legal email name contains RFC 822 compliant characters.
-------------------------------------------------------------------------*/

BOOL IsLegalEmailName ( TCHAR *pszName )
{
	// Null string is not legal
	//
	if (pszName == NULL)
    	return FALSE;

	TCHAR ch;
	while ((ch = *pszName++) != TEXT ('\0'))
    {
		switch (ch)
		{
		default:
			// Check if ch is in the range
			//
			if (ch > TEXT (' ') && ch <= TEXT ('~'))
				break;

			// Fall thru to error code
			//

		case TEXT ('('): case TEXT (')'):
		case TEXT ('<'): case TEXT ('>'):
		case TEXT ('['): case TEXT (']'):
		case TEXT ('/'): case TEXT ('\\'):
		case TEXT (','):
		case TEXT (';'):
		case TEXT (':'):
		case TEXT ('\"'):
			return FALSE;
		}
	} // while

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\buildmsi\preparecab\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	SAWebInstall.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\buildmsi\preparecab\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__0599CE33_6217_43B6_9A8B_1AF91CD515A8__INCLUDED_)
#define AFX_STDAFX_H__0599CE33_6217_43B6_9A8B_1AF91CD515A8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <stdio.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__0599CE33_6217_43B6_9A8B_1AF91CD515A8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\accountinfo.c ===
//
// This file contains two routines to map a given RID to the corresponding
// user name or group name
// It may become part of a bigger library at some later date, but for now
// it is just included in the source files
// Main purpose? Localization support
//

#ifndef _ACCOUNT_INFO_C_

#define _ACCOUNT_INFO_C

BOOL LookupAliasFromRid(LPWSTR TargetComputer, DWORD Rid, LPWSTR Name, PDWORD cchName)
{ 
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    SID_NAME_USE snu;
    PSID pSid;
    WCHAR DomainName[DNLEN+1];
    DWORD cchDomainName = DNLEN;
    BOOL bSuccess = FALSE;

    //
    // Sid is the same regardless of machine, since the well-known
    // BUILTIN domain is referenced.
    //

    if(AllocateAndInitializeSid(
                                &sia,
                                2,
                                SECURITY_BUILTIN_DOMAIN_RID,
                                Rid,
                                0, 0, 0, 0, 0, 0,
                                &pSid
                               )) 
    {
        bSuccess = LookupAccountSidW(
                                     TargetComputer,
                                     pSid,
                                     Name,
                                     cchName,
                                     DomainName,
                                     &cchDomainName,
                                     &snu
                                    );

        FreeSid(pSid);
    }

    return bSuccess;
} 

BOOL LookupUserGroupFromRid(LPWSTR TargetComputer, DWORD Rid, LPWSTR Name, PDWORD cchName)
{ 
    PUSER_MODALS_INFO_2 umi2;
    NET_API_STATUS nas;
    UCHAR SubAuthorityCount;
    PSID pSid;
    SID_NAME_USE snu;
    WCHAR DomainName[DNLEN+1];
    DWORD cchDomainName = DNLEN;
    BOOL bSuccess = FALSE; // assume failure

    //
    // get the account domain Sid on the target machine
    // note: if you were looking up multiple sids based on the same
    // account domain, only need to call this once.
    //

    nas = NetUserModalsGet(TargetComputer, 2, (LPBYTE *)&umi2);

    if(nas != NERR_Success) 
    {
        SetLastError(nas);
        return FALSE;
    }

    SubAuthorityCount = *GetSidSubAuthorityCount(umi2->usrmod2_domain_id);

    //
    // allocate storage for new Sid. account domain Sid + account Rid
    //

    pSid = (PSID)HeapAlloc(GetProcessHeap(), 
                           0,
                           GetSidLengthRequired((UCHAR)(SubAuthorityCount + 1)));

    if(pSid != NULL) 
    {
        if(InitializeSid(
                         pSid,
                         GetSidIdentifierAuthority(umi2->usrmod2_domain_id),
                         (BYTE)(SubAuthorityCount+1)
                        )) 
        {
            DWORD SubAuthIndex = 0;

            //
            // copy existing subauthorities from account domain Sid into
            //  new Sid
            //

            for( ; SubAuthIndex < SubAuthorityCount ; SubAuthIndex++) 
            {
                *GetSidSubAuthority(pSid, SubAuthIndex) =
                           *GetSidSubAuthority(umi2->usrmod2_domain_id, SubAuthIndex);
            }

            //
            // append Rid to new Sid
            //

            *GetSidSubAuthority(pSid, SubAuthorityCount) = Rid;

            bSuccess = LookupAccountSidW(
                                         TargetComputer,
                                         pSid,
                                         Name,
                                         cchName,
                                         DomainName,
                                         &cchDomainName,
                                         &snu
                                        );
        }

        HeapFree(GetProcessHeap(), 0, pSid);
    }

    NetApiBufferFree(umi2);

    return bSuccess;
} 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\debug\debug.cpp ===
//+----------------------------------------------------------------------------
//
// File: cmdebug.cpp         
//
// Module:    Chameleon 
//
// Synopsis: Provide the functionality of ASSERT and TRACE 
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:     fengsun Created    8/3/98
//
//+----------------------------------------------------------------------------

#if    ( defined(DEBUG) || defined(_DEBUG) )

#ifndef UNICODE
#define UNICODE
#endif

#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <winuser.h>

#include "debug.h"

#ifndef MB_SERVICE_NOTIFICATION
#define MB_SERVICE_NOTIFICATION 0
#endif

static long dwAssertCount = 0;  // Avoid another assert while the messagebox is up


//+----------------------------------------------------------------------------
//
// Function:  TraceMessage
//
// Synopsis:  Output debug string
//
// Arguments: const char *pszFmt ...-  Printf style arguments list
//             
//
// Returns:   Nothing
//
// History:   fengsun Created Header    8/3/98
//
//+----------------------------------------------------------------------------
extern "C" void TraceMessageW(const TCHAR *pszFmt, ...) 
{
    va_list valArgs;
    TCHAR szOutput[512];

    va_start(valArgs,pszFmt);
    wvsprintf(szOutput,pszFmt,valArgs);
    va_end(valArgs);
    
    lstrcat(szOutput,TEXT("\r\n"));
    
    OutputDebugString(szOutput);

}




//+----------------------------------------------------------------------------
//
// Function:  AssertMessage
//
// Synopsis:  Popup a message box for asserting failure.  Has three options:
//            ignore/debug/abort.
//
// Arguments: const char *pszFile - File name
//            unsigned nLine - Line number
//            const char *pszMsg - Message in the dialog box
//
// Returns:   Nothing
//
// History:   fengsun Created Header    8/3/98
//
//+----------------------------------------------------------------------------
extern "C" void AssertMessageW(const TCHAR *pszFile, unsigned nLine, const TCHAR *pszMsg) 
{
    TCHAR szOutput[1024];

    wsprintf(szOutput,TEXT("%s(%u) - %s\n"),pszFile,nLine,pszMsg);
    OutputDebugString(szOutput);

    wsprintf(szOutput,TEXT("%s(%u) - %s\n( Press Retry to debug )"),pszFile,nLine,pszMsg);
    int nCode = IDIGNORE;


    //
    // If there is no Assertion messagebox, popup one
    //
    if (dwAssertCount <2 )
    {
        dwAssertCount++;

        //
        // Title format: Assertion Failed - hello.dll
        //

        //
        // Find the base address of this module.
        //

        MEMORY_BASIC_INFORMATION mbi;
        mbi.AllocationBase = NULL; // current process by if VirtualQuery failed
        VirtualQuery(
                    AssertMessageW,   // any pointer with in the module
                    &mbi,
                    sizeof(mbi) );

        //
        // Get the module filename.
        //

        WCHAR szFileName[MAX_PATH + 1], *basename, *suffix;
        szFileName[0] = L'\0';   // in case of failure

        GetModuleFileNameW(
                    (HINSTANCE)mbi.AllocationBase,
                    szFileName,
                    MAX_PATH );

        //
        // Get the filename out of the full path
        //
        for (int i=lstrlen(szFileName);i != 0 && szFileName[i-1] != L'\\'; i--)
           ;

        WCHAR szTitle[48];
        lstrcpyW(szTitle, L"Assertion Failed - ");
        lstrcpynW(&szTitle[lstrlenW(szTitle)], szFileName+i, 
                sizeof(szTitle)/sizeof(szTitle[0]) - lstrlenW(szTitle) -1);  // there is no lstrcatn


        nCode = MessageBoxEx(NULL,szOutput,szTitle,
            MB_TOPMOST | MB_ICONHAND | MB_ABORTRETRYIGNORE | MB_SERVICE_NOTIFICATION,LANG_USER_DEFAULT);


        dwAssertCount--;
    }


    if (nCode == IDIGNORE)
    {
        return;     // ignore
    }
    else if (nCode == IDRETRY)
    {
        
#ifdef _X86_
        //
        // break into the debugger .
        // Step out of this fuction to get to your ASSERT() code
        //
        _asm { int 3 };     
#else
        DebugBreak();
#endif
        return; // ignore and continue in debugger to diagnose problem
    }
    // else fall through and call Abort

    ExitProcess((DWORD)-1);

}




//+----------------------------------------------------------------------------
//
// Function:  TraceMessage
//
// Synopsis:  Output debug string
//
// Arguments: const char *pszFmt ...-  Printf style arguments list
//             
//
// Returns:   Nothing
//
// History:   fengsun Created Header    8/3/98
//
//+----------------------------------------------------------------------------
extern "C" void TraceMessageA(const CHAR *pszFmt, ...) 
{
    va_list valArgs;
    CHAR szOutput[512];

    va_start(valArgs,pszFmt);
    wvsprintfA(szOutput,pszFmt,valArgs);
    va_end(valArgs);
    
    lstrcatA(szOutput,("\r\n"));
    
    OutputDebugStringA(szOutput);

}




//+----------------------------------------------------------------------------
//
// Function:  AssertMessageA
//
// Synopsis:  Popup a message box for asserting failure.  Has three options:
//            ignore/debug/abort.
//
// Arguments: const char *pszFile - File name
//            unsigned nLine - Line number
//            const char *pszMsg - Message in the dialog box
//
// Returns:   Nothing
//
// History:   fengsun Created Header    8/3/98
//
//+----------------------------------------------------------------------------
extern "C" void AssertMessageA(const CHAR *pszFile, unsigned nLine, const CHAR *pszMsg) 
{
    CHAR szOutput[1024];

    wsprintfA(szOutput,("%s(%u) - %s\n"),pszFile,nLine,pszMsg);
    OutputDebugStringA(szOutput);

    wsprintfA(szOutput,("%s(%u) - %s\n( Press Retry to debug )"),pszFile,nLine,pszMsg);
    int nCode = IDIGNORE;

    //
    // If there is no Assertion messagebox, popup one
    //
    if (dwAssertCount <2 )
    {
        dwAssertCount++;

        //
        // Title format: Assertion Failed - hello.dll
        //

        //
        // Find the base address of this module.
        //

        MEMORY_BASIC_INFORMATION mbi;
        mbi.AllocationBase = NULL; // current process by if VirtualQuery failed
        VirtualQuery(
                    AssertMessageW,   // any pointer with in the module
                    &mbi,
                    sizeof(mbi) );

        //
        // Get the module filename.
        //

        CHAR szFileName[MAX_PATH + 1], *basename, *suffix;
        szFileName[0] = '\0';   // in case of failure

        GetModuleFileNameA(
                    (HINSTANCE)mbi.AllocationBase,
                    szFileName,
                    MAX_PATH );

        //
        // Get the filename out of the full path
        //
        for (int i=lstrlenA(szFileName);i != 0 && szFileName[i-1] != '\\'; i--)
           ;

        CHAR szTitle[48];
        lstrcpyA(szTitle, "Assertion Failed - ");
        lstrcpynA(&szTitle[lstrlenA(szTitle)], szFileName+i, 
                sizeof(szTitle)/sizeof(szTitle[0]) - lstrlenA(szTitle) -1);  // there is no lstrcatn

        nCode = MessageBoxExA(NULL,szOutput,szTitle,
            MB_TOPMOST | MB_ICONHAND | MB_ABORTRETRYIGNORE | MB_SERVICE_NOTIFICATION,LANG_USER_DEFAULT);

        dwAssertCount--;
    }

    dwAssertCount--;

    if (nCode == IDIGNORE)
    {
        return;     // ignore
    }
    else if (nCode == IDRETRY)
    {
        
#ifdef _X86_
        //
        // break into the debugger .
        // Step out of this fuction to get to your ASSERT() code
        //
        _asm { int 3 };     
#else
        DebugBreak();
#endif
        return; // ignore and continue in debugger to diagnose problem
    }
    // else fall through and call Abort

    ExitProcess((DWORD)-1);

}

#endif //_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\appmgrobjs.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1998-1999 Microsoft Corporation all rights reserved.
//
// Module:      appmgrobj.h
//
// Project:     Chameleon
//
// Description: Core Object Properties
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 12/03/98     TLP    Initial Version
// 03/19/99     TLP    Added new alert method  
//
//////////////////////////////////////////////////////////////////////////////

#ifndef __INC_CORE_OBJECT_PROPERTIES_H
#define __INC_CORE_OBJECT_PROPERTIES_H

//////////////////////////////////////////////////////////////////////////////
//
// Appliance Manager Class

// Appliance Manager Class Name 
#define        CLASS_WBEM_APPMGR                L"Microsoft_SA_Manager"

// "Microsoft_SA_Manager" Class Properties
#define        PROPERTY_APPMGR_CURRENT_BUILD    L"CurrentBuildNumber"
#define        PROPERTY_APPMGR_PRODUCT_ID      L"ProductId"

// "Microsoft_SA_Manager" Class Methods
#define        METHOD_APPMGR_RAISE_ALERT        L"RaiseAlert"
#define        METHOD_APPMGR_CLEAR_ALERT        L"ClearAlert"
#define        METHOD_APPMGR_CLEAR_ALERT_ALL    L"ClearAlertAll"
#define        METHOD_APPMGR_RESET_APPLIANCE    L"ResetAppliance"

// Appliance Manager Method Parameters
#define        PROPERTY_RESET_APPLIANCE_POWER_OFF    L"PowerOff"

// Common Method Names
#define        METHOD_APPMGR_ENABLE_OBJECT        L"Enable"
#define        METHOD_APPMGR_DISABLE_OBJECT    L"Disable"
#define        METHOD_APPMGR_EXECUTE_TASK        L"Execute"

//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
// Alert Class

// Alert Class Name 
#define        CLASS_WBEM_ALERT                L"Microsoft_SA_Alert"

// "Microsoft_SA_Alert" Class Properties
#define        PROPERTY_ALERT_TYPE                L"AlertType"
#define        PROPERTY_ALERT_ID                L"AlertID"
#define        PROPERTY_ALERT_SOURCE            L"AlertSource"
#define        PROPERTY_ALERT_LOG                L"AlertLog"
#define        PROPERTY_ALERT_STRINGS            L"ReplacementStrings"
#define        PROPERTY_ALERT_DATA                L"AlertData"
#define        PROPERTY_ALERT_TTL                L"TimeToLive"
#define        PROPERTY_ALERT_COOKIE            L"Cookie"
#define        PROPERTY_ALERT_FLAGS            L"AlertFlags"

// Default alert source and alert log
#define        DEFAULT_ALERT_SOURCE            L"Microsoft_SA_Resource"
#define     DEFAULT_ALERT_LOG                L"svrapp"

//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//
// Service Class

// Service Class Name 
#define        CLASS_WBEM_SERVICE                L"Microsoft_SA_Service"

// "Microsoft_SA_Service" Class Properties
#define        PROPERTY_SERVICE_STATUS            L"IsEnabled"
#define        PROPERTY_SERVICE_CONTROL        L"CanDisable"
#define        PROPERTY_SERVICE_NAME            L"ServiceName"
#define        PROPERTY_SERVICE_PROGID            L"ServiceProgID"
#define        PROPERTY_SERVICE_CONTEXT        L"InProcDLL"
#define        PROPERTY_SERVICE_MERIT            L"Merit"
#define        PROPERTY_SERVICE_PROVIDER_CLSID L"WMIProviderCLSID"

// "Microsoft_SA_Service" Class Methods
#define        METHOD_SERVICE_ENABLE_OBJECT    METHOD_APPMGR_ENABLE_OBJECT
#define        METHOD_SERVICE_DISABLE_OBJECT    METHOD_APPMGR_DISABLE_OBJECT

// Names of Stock Chameleon Services (note the naming convention... :) )
#define        SERVICE_NAME_APPLIANCE_INIT        L"ApplianceInitService"
#define        SERVICE_NAME_CLIENT_ALERT        L"ClientAlertService"
#define        SERVICE_NAME_DISK_MANAGEMENT    L"DiskManagement"
#define        SERVICE_NAME_FILE_SHARING        L"File Service"
#define        SERVICE_NAME_INET_SHARING        L"Inet Sharing"
#define        SERVICE_NAME_PRINT_SHARING        L"Print Sharing"
#define        SERVICE_NAME_SECURITY            L"Security"
#define        SERVICE_NAME_USER_MANAGEMENT    L"User Management"
#define        SERVICE_NAME_SSL                L"SSLSvc"

//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//
// Task Class

// Task Class Name 
#define        CLASS_WBEM_TASK                    L"Microsoft_SA_Task"

// "Microsoft_SA_Task" Class Properties
#define        PROPERTY_TASK_STATUS            L"IsEnabled"
#define        PROPERTY_TASK_CONTROL            L"CanDisable"
#define        PROPERTY_TASK_NAME                L"TaskName"
#define        PROPERTY_TASK_EXECUTABLES        L"TaskExecutables"
#define        PROPERTY_TASK_MET                L"MaxExecutionTime"
#define        PROPERTY_TASK_CONCURRENCY        L"IsSingleton"
#define        PROPERTY_TASK_AVAILABILITY        L"IsAvailable"
#define        PROPERTY_TASK_RESTART_ACTION    L"RestartAction"


#define        TASK_RESTART_ACTION_NONE        0
#define        TASK_RESTART_ACTION_RUN            1


// Task Context Stock Properties
#define     PROPERTY_TASK_METHOD_NAME        L"MethodName"
#define        PROPERTY_TASK_CONTEXT            L"TaskContextPtr"

// Task Context Optional Properties
#define        PROPERTY_TASK_ASYNC                L"IsAsync"
#define        PROPERTY_TASK_NICE_NAME            L"TaskNiceName"
#define        PROPERTY_TASK_URL                L"TaskURL"

// "Microsoft_SA_Task" Class Methods
#define        METHOD_TASK_ENABLE_OBJECT        METHOD_APPMGR_ENABLE_OBJECT
#define        METHOD_TASK_DISABLE_OBJECT        METHOD_APPMGR_DISABLE_OBJECT
#define        METHOD_TASK_EXECUTE                METHOD_APPMGR_EXECUTE_TASK

// Names of Stock Appliance Tasks
#define        APPLIANCE_INITIALIZATION_TASK    L"ApplianceInitializationTask"
#define        APPLIANCE_SHUTDOWN_TASK            L"ApplianceShutdownTask"
#define        RESET_CONFIGURATION_TASK        L"ResetConfigurationTask"
#define        INET_TO_EVERYONE_TASK            L"AddEveryoneInetAccess"
#define        ADD_INET_USER_TASK                L"AddInetUser"
#define        ADD_APPLIANCE_DISK_TASK            L"AddSADisk"
#define        CHANGE_ADMIN_STATUS_TASK        L"ChangeSAUserAdminStatus"
#define        CHANGE_USER_NAME_TASK            L"ChangeSAUserFullName"
#define        CHANGE_USER_PASSWORD_TASK        L"ChangeSAUserPassword"
#define        CONFIG_CHANGE_ALERT_TASK        L"ConfigChangeAlert"
#define        CREATE_USER_TASK                L"CreateSAUser"
#define        DELETE_USER_TASK                L"DeleteSAUser"
#define        ENABLE_SECURITY_TASK            L"EnableSecurity"
#define        FORCE_CHANGE_PASSWORD_TASK        L"ForceSAUserChangePwd"
#define        INET_FROM_EVERYONE_TASK            L"RemoveEveryoneInetAccess"
#define        REMOVE_INET_USER_TASK            L"RemoveInetUser"
#define        ROLLBACK_TASK                    L"RollbackTask"
#define        SET_DATE_TIME_TASK                L"SetDateTime"
#define        SET_TIME_ZONE_TASK                L"SetTimeZone"
#define        TAKE_OWNERSHIP_TASK                L"TakeOwnership"
#define        SYSTEM_UPDATE_TASK                L"Update Task"
#define        APPLIANCE_FIRSTBOOT_TASK        L"FirstBootTask"
#define        APPLIANCE_SECONDBOOT_TASK       L"SecondBootTask"
#define        APPLIANCE_EVERYBOOT_TASK        L"EveryBootTask"


//////////////////////////////////////////////////////////////////////////////
//
// User Class

// User Class  Name 
#define        CLASS_WBEM_USER                    L"Microsoft_SA_User"

// "Microsoft_SA_Task" Class Properties
#define        PROPERTY_USER_SAMNAME            L"UserName"
#define        PROPERTY_USER_FULLNAME            L"FullName"
#define        PROPERTY_USER_ISADMIN            L"IsUserAdmin"
#define        PROPERTY_USER_SID                L"UserSid"
#define        PROPERTY_USER_CONTROL            L"CanDisable"
#define        PROPERTY_USER_STATUS            L"IsEnabled"
#define        PROPERTY_USER_RESOURCE_CLASS    L"ResourceClass"

// "Microsoft_SA_User" Class Methods
#define        METHOD_USER_ENABLE_OBJECT        METHOD_APPMGR_ENABLE_OBJECT
#define        METHOD_USER_DISABLE_OBJECT        METHOD_APPMGR_DISABLE_OBJECT


//////////////////////////////////////////////////////////////////////////////
//
// Event Classes

// Alert Event Classes
#define        CLASS_WBEM_RAISE_ALERT            L"Microsoft_SA_RaiseAlert"
#define        CLASS_WBEM_CLEAR_ALERT            L"Microsoft_SA_ClearAlert"


//////////////////////////////////////////////////////////////////////////////

//
// Server Appliance Named Events
//
#define  SA_STOPPED_SERVICES_EVENT          L"ServerApplianceStoppedServices"
#define  SA_INDICATE_SHUTDOWN_EVENT         L"ServerApplianceIndicateShutdown"

//////////////////////////////////////////////////////////////////////////////

//
// Registry key name of Microsoft_SA_Alert
//
#define  SA_ALERT_REGISTRY_KEYNAME L"SOFTWARE\\Microsoft\\ServerAppliance\\ApplianceManager\\ObjectManagers\\Microsoft_SA_Alert"

#endif // __INC_CORE_OBJECT_PROPERTIES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\atlhlpr.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1998-1999 Microsoft Corporation all rights reserved.
//
// Module:      sa_atl.h
//
// Project:     Chameleon
//
// Description: Helper classes the require ATL
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 12/03/98     TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_SA_ATL_H_
#define __INC_SA_ATL_H_

///////////////////////////////////////////////////////////////////////////////////////
// 1) Critical section class
///////////////////////////////////////////////////////////////////////////////////////

class CLockIt
{

public: 

    CLockIt(CComObjectRootEx<CComMultiThreadModel>& T) throw() 
        : m_theLock(T)
    { m_theLock.Lock(); }

    ~CLockIt() throw()
    { m_theLock.Unlock(); }

protected:

    CComObjectRootEx<CComMultiThreadModel>& m_theLock;
};


///////////////////////////////////////////////////////////////////////////////////////
// 2) Enum VARIANT class
///////////////////////////////////////////////////////////////////////////////////////

typedef CComEnum< IEnumVARIANT,
                  &__uuidof(IEnumVARIANT),
                  VARIANT,
                  _Copy<VARIANT>,
                  CComSingleThreadModel 
                > EnumVARIANT;

#endif // __INC_SA_ATL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\buildmsi\preparecab\buildcab.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft Corporation
//
//  Module Name:
//      BuildCab.cpp
//
//  Description:
//      Prepares files to generate the CAB file, which will be streamed
//      into sasetup.msi.  
//
//      The directory structure for files to be searched is:
//        <SAKBuild>  Directory where all files are binplaced, passed from the command line
//                    ie. C:\binaries.x86fre\sacomponents
//        <SAKBuild>\sasetup.msi   MSI in which the Files table is searched
//        <SAKBuild>\tmpCab  Temp directory where files are placed
//
//  History:
//      travisn   28-FEB-2002    Created
//
//////////////////////////////////////////////////////////////////////////////

#include <crtdbg.h>
#include <atlbase.h>
#include <string>
#include <msi.h>
#include <msiquery.h>
#include <search.h>
#include <shellapi.h>
#include <stdio.h>

LPCWSTR MSI_FILENAME = L"sasetup.msi";
LPCWSTR FILENAME_QUERY = L"SELECT File FROM File";

const DWORD MAX_FILES = 500;

//
// Indexes to the array representing indexes to the data string
// DO NOT CHANGE THESE SINCE THE BINARY SEARCH RELIES ON THEM IN THIS ORDER
//
const DWORD ELEMENTS_IN_SORT_ARRAY = 3;
const DWORD SHORT_FILENAME = 0;
const DWORD LONG_FILENAME = 1;
const DWORD FOUND_FILE = 2;

using namespace std;

//Global list of filenames read from the MSI
wstring g_wsAllFilenames;


//////////////////////////////////////////////////////////////////////////////
//++
//  CompareFilenames
//
//  Description:
//    Function to sort the filenames found in the File table of sasetup.msi.
//    It ignores the file key that was prepended by sasetup.msi. 
//    For example, it compares appmgr.exe instead of F12345_appmgr.exe
//    
//  Parameters:
//    e1  Pointer to a WCHAR that the search function is seeking
//    e2  Pointer to an offset in g_wsAllFilenames
//--
//////////////////////////////////////////////////////////////////////////////
int __cdecl CompareFilenames(const void *e1, const void *e2)
{
    DWORD *dwElement1 = (DWORD*)e1;
    DWORD *dwElement2 = (DWORD*)e2;

    //Get the short filename for the first string
    wstring wstr1(g_wsAllFilenames.substr(
                    *dwElement1, 
                    g_wsAllFilenames.find_first_of(L",", *dwElement1) - *dwElement1));

    //Get the short filename for the second string
    wstring wstr2(g_wsAllFilenames.substr(
                    *dwElement2, 
                    g_wsAllFilenames.find_first_of(L",", *dwElement2) - *dwElement2));

    return _wcsicmp(wstr1.data(), wstr2.data());
}

//////////////////////////////////////////////////////////////////////////////
//++
//  CompareStringToFilename
//
//  Description:
//    Function to search for a string that is equal to the given key
//
//  Parameters:
//    pKey           Pointer to a WCHAR that the search function is seeking
//    pFilenameIndex Pointer to an offset in g_wsAllFilenames
//--
//////////////////////////////////////////////////////////////////////////////
int __cdecl CompareStringToFilename(const void *pKey, const void *pFilenameIndex)
{
    WCHAR *wszKey = (WCHAR*)pKey;
    DWORD *dwElement2 = (DWORD*)pFilenameIndex;

    //Create a wstring out of the key
    wstring wstr1(wszKey);

    //Create a wstring out of the short filename to compare to
    wstring wstr2(g_wsAllFilenames.substr(
                    *dwElement2, 
                    g_wsAllFilenames.find_first_of(L",", *dwElement2) - *dwElement2));

    return _wcsicmp(wstr1.data(), wstr2.data());
}

//////////////////////////////////////////////////////////////////////////////
//++
//  RenameFilesFromMSI
//
//  Description:
//    Recursively traverses a directory to look for files that also are listed
//    in sasetup.msi and copy them to a temp directory for CAB generation.
//    Files are renamed in the temp directory to the file key name in the msi.
//    For example, appmgr.exe might be renamed to F12345_appmgr.exe.
//    Files not listed in the MSI are ignored.  If a file is listed in the msi,
//    but not found on the system, a fatal error occurs after this function exits.
//
//  Parameters:
//     pwsSourceDir  [in] The source directory to search for files and recursively call
//                   this function with its subdirectories (no trailing backslash)
//     pwsDestDir    [in] The temp directory where the files are copied to for CAB creation
//     adwLongAndShortFilenameOffsets  [in] Array of pointers to the offsets in 
//                    g_wsAllFilenames where the filenames can be found.
//                   The long filename might be: F12345_appmgr.exe
//                   The short filename might be: appmgr.exe (simply an offset to the
//                    first _ in the long filename)
//     dwNumRecords  [in] The total number of files in the File table of sasetup.msi
//     dwNumFilesCopied [in, out] The running total of the number of files copied to the
//                   temp directory
//     dwLevel       [in] The level of recursion, used for debug printing
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT RenameFilesFromMSI(const LPCWSTR pwsSourceDir, 
                           const LPCWSTR pwsDestDir,
                           const DWORD **adwLongAndShortFilenameOffsets, 
                           const DWORD dwNumRecords, 
                           DWORD &dwNumFilesCopied,
                           const DWORD dwLevel)
{
    HRESULT hr = S_OK;

    wstring wsCurrentDir(pwsSourceDir);
    wsCurrentDir += L"\\";
    wstring wsSearch(pwsSourceDir);
    wsSearch += L"\\*.*";
    WIN32_FIND_DATA FindFileData;
    HANDLE hFind = FindFirstFile(wsSearch.data(), &FindFileData);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        //printf("%d: Invalid Handle Value: %ws", dwLevel, pwsSourceDir);
    }
    else
    {
        //printf("%d: Directory: %ws", dwLevel, pwsSourceDir);
        BOOL bValidFile = TRUE;
        while (bValidFile)
        {
            if (wcscmp(FindFileData.cFileName, L".") != 0 && wcscmp(FindFileData.cFileName, L"..") != 0)
            {

                //
                // If it's a directory, recurse down the directory structure. 
                // If it's a file, rename it if it's found in the MSI.
                //
                if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                {
                    wstring wsChildDir(pwsSourceDir);
                    wsChildDir += L"\\";
                    wsChildDir += FindFileData.cFileName;
                    hr = RenameFilesFromMSI(wsChildDir.data(), 
                                            pwsDestDir, 
                                            adwLongAndShortFilenameOffsets, 
                                            dwNumRecords, 
                                            dwNumFilesCopied,
                                            dwLevel + 1);
                    if (FAILED(hr))
                    {
                        break;
                    }
                }
                else
                {
                    //printf("%d: File: %ws", dwLevel, FindFileData.cFileName);
                    DWORD *pFilenameIndex = (DWORD*) bsearch(FindFileData.cFileName, 
                                                    (void*)adwLongAndShortFilenameOffsets, 
                                                    dwNumRecords,
                                                    sizeof(DWORD)*ELEMENTS_IN_SORT_ARRAY,
                                                    CompareStringToFilename);
                    
                    //
                    // Rename the file to the name in the MSI
                    //
                    if (pFilenameIndex != NULL)
                    {
                        //Get the pointer to the long filename instead of the short filename
                        pFilenameIndex += 1;

                        //Create the path and filename for the file for the CAB
                        wstring wsNewFilename(pwsDestDir);
                        wsNewFilename += g_wsAllFilenames.substr(*pFilenameIndex, 
                            g_wsAllFilenames.find_first_of(L",", *pFilenameIndex) - *pFilenameIndex);
                        
                        //Create the path and filename for the original file
                        wstring wsOldFilename(wsCurrentDir);
                        wsOldFilename += FindFileData.cFileName;

                        if (CopyFile(wsOldFilename.data(), wsNewFilename.data(), TRUE))
                        {
                            //printf(" Successfully copied file to temp CAB folder");
                            fwprintf(stdout, L".");
                            dwNumFilesCopied++;
                        }
                        else
                        {
                            fwprintf(stdout, L"\nYOU HAVE A DUPLICATE FILE. FAILED copying file: %ws, to temp CAB folder: %ws", wsOldFilename.data(), wsNewFilename.data());
                            hr = E_FAIL;
                            break;
                        }
                        pFilenameIndex += 1;
                        if (*pFilenameIndex != 0)
                            fwprintf(stdout, L"\nERROR: pFilenameIndex = %d", (*pFilenameIndex));
                        else
                            (*pFilenameIndex) = 1;//Mark this string as found
                    }
                    //else
                    //    printf("  Did NOT find %ws in MSI", FindFileData.cFileName);
                }
            }

            if (!FindNextFile(hFind, &FindFileData))
            {
                bValidFile = FALSE;
            }
            
        }

        FindClose(hFind);
    }
    
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//++
//  ReadMSIFilenamesAndRenameFiles
//
//  Description:
//    Opens sasetup.msi in the given source directory, reads all the filenames
//    in the File table, sorts the filenames, then calls RenameFilesFromMSI
//    to copy and rename the files that will be placed in the CAB and streamed
//    into the MSI.
//
//  Parameters:
//     pwsSakSourceDir [in] The source directory where sasetup.msi is found, with 
//                     no trailing backslash
//                     ie. C:\binaries.x86fre\sakit
//     pwsTempCabDir   [in] The directory where all files should be copied to that
//                     will be packaged in the CAB
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT ReadMSIFilenamesAndRenameFiles(LPCWSTR pwsSakSourceDir, LPCWSTR pwsTempCabDir)
{
    wstring wsMsiFilename(pwsSakSourceDir);
    wsMsiFilename += L"\\";
    wsMsiFilename += MSI_FILENAME;

    HRESULT hr = E_FAIL;
    fwprintf(stdout, L"\nOpen MSI file: %ws\n", wsMsiFilename.data());
    MSIHANDLE hMSI = NULL;
    MSIHANDLE hView = NULL;
    do
    {
        //
        // Open sasetup.msi
        //
        UINT rVal = MsiOpenDatabase(wsMsiFilename.data(), MSIDBOPEN_READONLY, &hMSI);
        if (rVal != ERROR_SUCCESS)
        {
            fwprintf(stdout, L"\nFailed opening MSI");
            break;
        }
        //printf("Successfully opened MSI");

        //
        // Query the msi for the filenames
        //
        rVal = MsiDatabaseOpenView(hMSI, FILENAME_QUERY, &hView);
        if (rVal != ERROR_SUCCESS)
        {
            fwprintf(stdout, L"\nFailed query to retrieve filenames");
            break;
        }
        //printf("Successfully queried the filenames");

        //
        // Finalize the query for the filenames
        //
        rVal = MsiViewExecute(hView, 0);
        if (rVal != ERROR_SUCCESS)
        {
            fwprintf(stdout, L"\nFailed query to finalize the query");
            break;
        }
        //printf("Successfully finalized the query");

        //
        // Extract the filenames from the MSI one by one
        //
        DWORD adwLongAndShortFilenameOffsets[MAX_FILES][ELEMENTS_IN_SORT_ARRAY];
        MSIHANDLE hRecord;
        rVal = MsiViewFetch(hView, &hRecord);
        DWORD dwRecord = 0;
        DWORD dwOffset = 0;
        hr = S_OK;
        while (rVal == ERROR_SUCCESS)
        {
            if (dwRecord >= MAX_FILES)
            {
                fwprintf(stdout, L"\nExceeded maximum number of files");
                hr = E_FAIL;
                break;
            }

            WCHAR wszFilename[MAX_PATH];
            DWORD dwLength = MAX_PATH;
            rVal = MsiRecordGetString(hRecord, 1, wszFilename, &dwLength);
            if (rVal != ERROR_SUCCESS)
            {
                fwprintf(stdout, L"\nCOULD NOT fetch record %d", dwRecord);
                hr = E_FAIL;
                break;
            }
 
            wstring wsFilename(wszFilename);
            wstring wsNewFilename;
            int nUnderscore = wsFilename.find_first_of(L"_");
            if (nUnderscore == -1)
            {
                fwprintf(stdout, L"\nCOULD NOT find underscore in %ws", wsFilename.data());
                hr = E_FAIL;
                break;
            }
            adwLongAndShortFilenameOffsets[dwRecord][LONG_FILENAME] = dwOffset;
            adwLongAndShortFilenameOffsets[dwRecord][SHORT_FILENAME]= dwOffset + nUnderscore + 1;//Add 1 to skip the _
            adwLongAndShortFilenameOffsets[dwRecord][FOUND_FILE]= 0;

            //wsNewFilename = wsFilename.substr(nUnderscore+1);
            g_wsAllFilenames += wsFilename + L",";
            
            MsiCloseHandle(hRecord);
            rVal = MsiViewFetch(hView, &hRecord);
            dwRecord++;
            dwOffset += dwLength + 1;//Add 1 for the comma
        }

        //If the While loop failed, break out of the function
        if (FAILED(hr))
        {
            break;
        }

        //
        // Sort by the short filename
        //
        qsort(&adwLongAndShortFilenameOffsets[0][0], dwRecord, sizeof(DWORD)*ELEMENTS_IN_SORT_ARRAY, CompareFilenames);

        //Print out the sorted list of filenames
        //for (int i=0; i < dwRecord; i++)
        //{
        //    //Get the substrings and print them to make sure they were restored correctly
        //    DWORD dwLongIndex = adwLongAndShortFilenameOffsets[i][LONG_FILENAME];
        //    DWORD dwShortIndex = adwLongAndShortFilenameOffsets[i][SHORT_FILENAME];
        //    wstring wsLongName(g_wsAllFilenames.substr(dwLongIndex, g_wsAllFilenames.find_first_of(L",", dwLongIndex) - dwLongIndex));
        //    wstring wsShortName(g_wsAllFilenames.substr(dwShortIndex, g_wsAllFilenames.find_first_of(L",", dwShortIndex) - dwShortIndex));
        //    //printf("%d: %ws -> %ws", i, wsLongName.data(), wsShortName.data());
        //}

        // Create the directory used to search for files to put in the CAB
        wstring wsSourceDir(pwsSakSourceDir);
        
        //Create the directory used to copy and rename the files temporarily for CAB creation
        wstring wsTmpCabDir(pwsTempCabDir);
        wsTmpCabDir += L"\\";
        if (!CreateDirectory(wsTmpCabDir.data(), NULL) 
             && GetLastError() != ERROR_ALREADY_EXISTS)
        {
            fwprintf(stdout, L"\nCOULD NOT create directory %ws", wsTmpCabDir.data());
            hr = E_FAIL;
            break;
        }

        DWORD dwNumFilesForCAB = 0;
        //Copy and rename files for the CAB file
        hr = RenameFilesFromMSI(wsSourceDir.data(), 
                                wsTmpCabDir.data(), 
                                (const DWORD**)adwLongAndShortFilenameOffsets, 
                                dwRecord, 
                                dwNumFilesForCAB,
                                1);

        if (FAILED(hr))
        {
            break;
        }

        //
        // Check to make sure there are the same number of files copied for CAB creation
        // as there are in the MSI table
        // 
        if (dwNumFilesForCAB != dwRecord)
        {
            fwprintf(stdout, L"\nERROR: %d files listed in the MSI were not found in the source directory", dwRecord - dwNumFilesForCAB);
            for (int i=0; i < dwRecord; i++)
            {
                if (adwLongAndShortFilenameOffsets[i][FOUND_FILE] != 1)
                {
                    DWORD dwIndex = adwLongAndShortFilenameOffsets[i][LONG_FILENAME];
                    DWORD dwFirst = g_wsAllFilenames.find_first_of(L",", dwIndex);
                    fwprintf(stdout, L"\n Missing file: %ws", 
                        g_wsAllFilenames.substr(dwIndex, dwFirst - dwIndex).data());
                }
            }
            hr = E_FAIL;
            break;
        }

    } while (false);

    if (hMSI)
    {
        MsiCloseHandle(hMSI);
    }

    if (hView)
    {   
        MsiCloseHandle(hView);
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//++
//  WinMain
//
//  Description:
//    Main entry point to prepare the files for cab generation
//    One command line argument is expected, which is the base directory
//    where everything is located.
//--
//////////////////////////////////////////////////////////////////////////////
int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    HRESULT hr = E_FAIL;
    LPWSTR *argvCommandLine = NULL;
    do 
    {
        int nArgs;
        argvCommandLine = CommandLineToArgvW(
                            GetCommandLine(),// pointer to a command-line string
                            &nArgs);       // receives the argument count

        if (argvCommandLine == NULL || nArgs < 3)
        {
            fwprintf(stdout, L"\nCommand line syntax: PrepareCabFiles.exe <sakitBuildDir> <TempCabDir>\n");
            break;
        }
        fwprintf(stdout, L"\nSAK build directory: %ws", argvCommandLine[1]);
        fwprintf(stdout, L"\nTemp Cab Directory: %ws", argvCommandLine[2]);

        hr = ReadMSIFilenamesAndRenameFiles(argvCommandLine[1], argvCommandLine[2]);
        if (FAILED(hr))
        {
            fwprintf(stdout, L"\nThere was a FAILURE\n\n");
        }
        else
        {
            fwprintf(stdout, L"\nSUCCESS!!\n\n");
        }

    } while (false);

    GlobalFree(argvCommandLine);
    
    if (FAILED(hr))
        return 1;//The build script expects a 1 if an error occurred.
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\basedefs.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1998-1999 Microsoft Corporation all rights reserved.
//
// Module:      basedefs.h
//
// Project:     Chameleon
//
// Description: Common classes and definitions
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 12/03/98     TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_BASE_DEFS_H_
#define __INC_BASE_DEFS_H_

#include <comdef.h>

#pragma warning( disable : 4786 )
#include <string>
using namespace std;

/////////////////////////////////////////////////////////
// 1) Object Management Classes
/////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////
//
// Master Pointer Tasks 
//
// 1) Object instance counting
// 2) Object construction and destruction
// 3) Object lifetime control through reference counting
//
////////////////////////////////////////////////////////

template <class T>
class CMasterPtr
{

public:

    /////////////////////////////////////////
    CMasterPtr()
        : m_pT(new T), m_dwRefCount(0) 
    { m_dwInstances++; }

    /////////////////////////////////////////
    CMasterPtr(T* pT)    // Take ownership of an existing object of type T
        : m_pT(pT), m_dwRefCount(0) 
    { m_dwInstances++; }

    /////////////////////////////////////////
    ~CMasterPtr() 
    { _ASSERT( 0 == m_dwRefCount ); delete m_pT; }

    /////////////////////////////////////////
    CMasterPtr<T>& operator = (const CMasterPtr<T>& mp)
    {
        // Check for assignment to self
        //
        if ( this != &mp )
        {
            // Delete object pointed at and create a new one
            // User of the master pointer is responsible for catching
            // any exception thrown as a result of creating a object
            //
            delete m_pT;
            m_dwInstances--;
            m_pT = new T(*(mp.m_pT));
        }
        return *this;
    }

    
    /////////////////////////////////////////
    T* operator->() 
    { _ASSERT( NULL != m_pT ); return m_pT; }

    
    /////////////////////////////////////////
    void Hold(void)
    {
        m_dwRefCount++;
    }

    /////////////////////////////////////////
    void Release(void)
    {
        // Handle case where someone calls Release when ref count is 0.
        //
        if ( m_dwRefCount > 0 )
            m_dwRefCount--;
        
        if ( 0 >= m_dwRefCount )
        {
            m_dwInstances--;
            delete this;    // ~CSdoMasterPtr() deletes m_pT
        }
    }

    /////////////////////////////////////////
    DWORD GetInstanceCount(void);

private:

    // T must have a copy constructor or must work with the default C++ 
    // copy constructor. This is not the case here...
    //
    /////////////////////////////////////////
    CMasterPtr(const CMasterPtr<T>& mp)
        : m_pT(new T(*(mp.m_pT))), m_dwRefCount(0) 
    { m_dwInstances++; }


    //////////////////////////////////////////

    T*                    m_pT;            // Actual object
    DWORD                m_dwRefCount;    // Ref count
    static DWORD        m_dwInstances;    // Number of instances
};


/////////////////////////////////////////////////////////
//
// Handle Tasks 
//
// 1) Master Pointer Object creation
// 2) Hide use of reference counting from programmer
//
////////////////////////////////////////////////////////

template <class T> 
class CHandle
{

public:

    /////////////////////////////////////////
    CHandle()
        : m_mp(NULL) { }

    /////////////////////////////////////////
    CHandle(CMasterPtr<T>* mp) 
        : m_mp(mp) 
    { 
        _ASSERT( NULL != m_mp );
        m_mp->Hold(); 
    }

    /////////////////////////////////////////
    CHandle(const CHandle<T>& h)
        : m_mp(h.m_mp) 
    { 
        if ( NULL != m_mp )
            m_mp->Hold(); 
    }

    /////////////////////////////////////////
    ~CHandle()
    { 
        if ( NULL != m_mp )
            m_mp->Release(); 
    }

    /////////////////////////////////////////
    CHandle<T>& operator = (const CHandle<T>& h)
    {
        // Check for reference to self and instance where
        // h points to the same mp we do.
        //
        if ( this != &h && m_mp != h.m_mp )
        {
            if ( NULL != m_mp )
                m_mp->Release();
            m_mp = h.m_mp;
            if ( NULL != m_mp )
                m_mp->Hold();
        }

        return *this;
    }

    /////////////////////////////////////////
    CMasterPtr<T>& operator->() 
    { 
        _ASSERT( NULL != m_mp ); 
        return *m_mp; 
    }
    
    
    /////////////////////////////////////////
    bool IsValid()
    {
        return (NULL != m_mp ? true : false);
    }


private:

    CMasterPtr<T>*    m_mp;
};

///////////////////////////////////////////////////////////////////////////////////////
// 3) Scanner for string of tokens seperated by specified delimiter
///////////////////////////////////////////////////////////////////////////////////////

class CScanIt
{

public:

    CScanIt() { }

    CScanIt(WCHAR Delimiter, LPCWSTR pszString)
    {
        m_Delimiter = Delimiter;
        m_String = pszString;
        m_pOffset = m_String.c_str();
    }

    ~CScanIt() { }

    void Reset(void)
    {
        m_pOffset = m_String.c_str();
    }

    bool NextToken(DWORD dwSize, LPWSTR pszToken)
    {
        if ( '\0' != *m_pOffset )
        {
            // Eat delimiters...
            while ( m_Delimiter == *m_pOffset )
                m_pOffset++;
            // Check for EOL
            if ( '\0' != *m_pOffset )
            {
                // Token is at least 1 character in length...
                ULONG ulCount = 1;
                while ( m_Delimiter != *(m_pOffset + ulCount) && '\0' != *(m_pOffset + ulCount) )
                    ulCount++;
                _ASSERT( dwSize > ulCount );
                if ( dwSize > ulCount )
                {
                    // Return the token to the caller
                    wcsncpy( pszToken, m_pOffset, ulCount );
                    *(pszToken + ulCount) = '\0';
                    m_pOffset += ulCount;
                    return true;
                }                    
            }
        }
        return false;
    }


private:

    CScanIt(const CScanIt& rhs);
    CScanIt& operator = (CScanIt& rhs);

    wchar_t        m_Delimiter;
    wstring        m_String;
    LPCWSTR        m_pOffset;
};


///////////////////////////////////////////////////////////////////////////////////////
// 4) TRY - CATCH Macros
///////////////////////////////////////////////////////////////////////////////////////

// Return the error code from a failed COM invocation.  Useful if you don't
// have to do any special clean-up.
#define RETURN_ERROR(expr) \
   { HRESULT __hr__ = (expr); if (FAILED(__hr__)) return __hr__; }

// Try and catch macros
#define    TRY_IT    try {

#define    CATCH_AND_SET_HR    } \
    catch(const std::bad_alloc&) { hr = E_OUTOFMEMORY; } \
    catch(const _com_error ce)   { hr = ce.Error(); }    \
    catch(...)                   { hr = E_FAIL; }

// Safely release an object.
#define DEREF_COMPONENT(obj) \
   if (obj) { (obj)->Release(); (obj) = NULL; }

#endif //__INC_BASE_DEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\chat.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    Chat.h

    This file contains constants & type definitions shared between the
    CHAT Service, Installer, and Administration UI.


    FILE HISTORY:
        KeithMo     10-Mar-1993 Created.
        KentCe      11-Dec-1995 Imported for new chat server

*/


#ifndef _CHAT_H_
#define _CHAT_H_

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus

#if !defined(MIDL_PASS)
#include <winsock.h>
#endif


//
//  Name of directory annotation file.  If this file exists
//  in the target directory of a CWD command, its contents
//  will be sent to the user as part of the CWD reply.
//

#define CHAT_ANNOTATION_FILE_A           "~CHATSVC~.CKM"
#define CHAT_ANNOTATION_FILE_W          L"~CHATSVC~.CKM"


//
//  Configuration parameters registry key.
//
# define CHAT_SERVICE_KEY_A  \
  "System\\CurrentControlSet\\Services\\" ## CHAT_SERVICE_NAME_A

# define CHAT_SERVICE_KEY_W \
  L"System\\CurrentControlSet\\Services\\" ## CHAT_SERVICE_NAME_W

#define CHAT_PARAMETERS_KEY_A   CHAT_SERVICE_KEY_A ## "\\Parameters"
  
#define CHAT_PARAMETERS_KEY_W   CHAT_SERVICE_KEY_W ## L"\\Parameters"


//
//  Performance key.
//

#define CHAT_PERFORMANCE_KEY_A  CHAT_SERVICE_KEY_A ## "\\Performance"

#define CHAT_PERFORMANCE_KEY_W  CHAT_SERVICE_KEY_W ## L"\\Performance"


//
//  If this registry key exists under the Parameters key,
//  it is used to validate CHATSVC access.  Basically, all new users
//  must have sufficient privilege to open this key before they
//  may access the CHAT Server.
//

#define CHAT_ACCESS_KEY_A                "AccessCheck"
#define CHAT_ACCESS_KEY_W               L"AccessCheck"


//
//  Configuration value names.
//

#define CHAT_ALLOW_ANONYMOUS_A           "AllowAnonymous"
#define CHAT_ALLOW_ANONYMOUS_W          L"AllowAnonymous"

#define CHAT_ALLOW_GUEST_ACCESS_A        "AllowGuestAccess"
#define CHAT_ALLOW_GUEST_ACCESS_W       L"AllowGuestAccess"

#define CHAT_ANONYMOUS_ONLY_A            "AnonymousOnly"
#define CHAT_ANONYMOUS_ONLY_W           L"AnonymousOnly"

#define CHAT_MSDOS_DIR_OUTPUT_A          "MsdosDirOutput"
#define CHAT_MSDOS_DIR_OUTPUT_W         L"MsdosDirOutput"

#define CHAT_GREETING_MESSAGE_A          "GreetingMessage"
#define CHAT_GREETING_MESSAGE_W         L"GreetingMessage"

#define CHAT_EXIT_MESSAGE_A              "ExitMessage"
#define CHAT_EXIT_MESSAGE_W             L"ExitMessage"

#define CHAT_MAX_CLIENTS_MSG_A           "MaxClientsMessage"
#define CHAT_MAX_CLIENTS_MSG_W          L"MaxClientsMessage"

#define CHAT_DEBUG_FLAGS_A               "DebugFlags"
#define CHAT_DEBUG_FLAGS_W              L"DebugFlags"

#define CHAT_ANNOTATE_DIRS_A             "AnnotateDirectories"
#define CHAT_ANNOTATE_DIRS_W            L"AnnotateDirectories"

#define CHAT_LOWERCASE_FILES_A           "LowercaseFiles"
#define CHAT_LOWERCASE_FILES_W          L"LowercaseFiles"

#define CHAT_LISTEN_BACKLOG_A            "ListenBacklog"
#define CHAT_LISTEN_BACKLOG_W           L"ListenBacklog"

#define CHAT_ENABLE_LICENSING_A          "EnableLicensing"
#define CHAT_ENABLE_LICENSING_W         L"EnableLicensing"

#define CHAT_DEFAULT_LOGON_DOMAIN_A      "DefaultLogonDomain"
#define CHAT_DEFAULT_LOGON_DOMAIN_W     L"DefaultLogonDomain"


//
//  Name of the LSA Secret Object containing the password for
//  anonymous logon and virtual UNC roots
//

#define CHAT_ANONYMOUS_SECRET_A          "CHAT_ANONYMOUS_DATA"
#define CHAT_ANONYMOUS_SECRET_W         L"CHAT_ANONYMOUS_DATA"

#define CHAT_ROOT_SECRET_A               "CHAT_ROOT_DATA"
#define CHAT_ROOT_SECRET_W              L"CHAT_ROOT_DATA"

//
//  Handle ANSI/UNICODE sensitivity.
//

#ifdef UNICODE

#define CHAT_ANNOTATION_FILE            CHAT_ANNOTATION_FILE_W
#define CHAT_PARAMETERS_KEY             CHAT_PARAMETERS_KEY_W
#define CHAT_PERFORMANCE_KEY            CHAT_PERFORMANCE_KEY_W
#define CHAT_ACCESS_KEY                 CHAT_ACCESS_KEY_W
#define CHAT_ALLOW_ANONYMOUS            CHAT_ALLOW_ANONYMOUS_W
#define CHAT_ALLOW_GUEST_ACCESS         CHAT_ALLOW_GUEST_ACCESS_W
#define CHAT_ANONYMOUS_ONLY             CHAT_ANONYMOUS_ONLY_W
#define CHAT_MSDOS_DIR_OUTPUT           CHAT_MSDOS_DIR_OUTPUT_W
#define CHAT_GREETING_MESSAGE           CHAT_GREETING_MESSAGE_W
#define CHAT_EXIT_MESSAGE               CHAT_EXIT_MESSAGE_W
#define CHAT_MAX_CLIENTS_MSG            CHAT_MAX_CLIENTS_MSG_W
#define CHAT_DEBUG_FLAGS                CHAT_DEBUG_FLAGS_W
#define CHAT_ANNOTATE_DIRS              CHAT_ANNOTATE_DIRS_W
#define CHAT_ANONYMOUS_SECRET           CHAT_ANONYMOUS_SECRET_W
#define CHAT_LOWERCASE_FILES            CHAT_LOWERCASE_FILES_W
#define CHAT_LISTEN_BACKLOG             CHAT_LISTEN_BACKLOG_W
#define CHAT_ENABLE_LICENSING           CHAT_ENABLE_LICENSING_W
#define CHAT_DEFAULT_LOGON_DOMAIN       CHAT_DEFAULT_LOGON_DOMAIN_W

#else   // !UNICODE

#define CHAT_ANNOTATION_FILE            CHAT_ANNOTATION_FILE_A
#define CHAT_PARAMETERS_KEY             CHAT_PARAMETERS_KEY_A
#define CHAT_PERFORMANCE_KEY            CHAT_PERFORMANCE_KEY_A
#define CHAT_ACCESS_KEY                 CHAT_ACCESS_KEY_A
#define CHAT_ANONYMOUS_ONLY             CHAT_ANONYMOUS_ONLY_A
#define CHAT_ALLOW_ANONYMOUS            CHAT_ALLOW_ANONYMOUS_A
#define CHAT_ALLOW_GUEST_ACCESS         CHAT_ALLOW_GUEST_ACCESS_A
#define CHAT_MSDOS_DIR_OUTPUT           CHAT_MSDOS_DIR_OUTPUT_A
#define CHAT_GREETING_MESSAGE           CHAT_GREETING_MESSAGE_A
#define CHAT_EXIT_MESSAGE               CHAT_EXIT_MESSAGE_A
#define CHAT_MAX_CLIENTS_MSG            CHAT_MAX_CLIENTS_MSG_A
#define CHAT_DEBUG_FLAGS                CHAT_DEBUG_FLAGS_A
#define CHAT_ANNOTATE_DIRS              CHAT_ANNOTATE_DIRS_A
#define CHAT_ANONYMOUS_SECRET           CHAT_ANONYMOUS_SECRET_A
#define CHAT_LOWERCASE_FILES            CHAT_LOWERCASE_FILES_A
#define CHAT_LISTEN_BACKLOG             CHAT_LISTEN_BACKLOG_A
#define CHAT_ENABLE_LICENSING           CHAT_ENABLE_LICENSING_A
#define CHAT_DEFAULT_LOGON_DOMAIN       CHAT_DEFAULT_LOGON_DOMAIN_A

  
#endif  // UNICODE



//
// Structures for APIs
//

typedef struct _CHAT_USER_INFO
{
    DWORD    idUser;          //  User id
    LPWSTR   pszUser;         //  User name
    BOOL     fAnonymous;      //  TRUE if the user is logged on as
                              //  Anonymous, FALSE otherwise
    DWORD    inetHost;        //  Host Address
    DWORD    tConnect;        //  User Connection Time (elapsed seconds)

} CHAT_USER_INFO, * LPCHAT_USER_INFO;

typedef struct _CHAT_STATISTICS_0
{
    LARGE_INTEGER TotalBytesSent;
    LARGE_INTEGER TotalBytesReceived;
    DWORD         TotalFilesSent;
    DWORD         TotalFilesReceived;
    DWORD         CurrentAnonymousUsers;
    DWORD         CurrentNonAnonymousUsers;
    DWORD         TotalAnonymousUsers;
    DWORD         TotalNonAnonymousUsers;
    DWORD         MaxAnonymousUsers;
    DWORD         MaxNonAnonymousUsers;
    DWORD         CurrentConnections;
    DWORD         MaxConnections;
    DWORD         ConnectionAttempts;
    DWORD         LogonAttempts;
    DWORD         TimeOfLastClear;

} CHAT_STATISTICS_0, * LPCHAT_STATISTICS_0;


//
// API Prototypes
//

NET_API_STATUS
I_ChatEnumerateUsers(
    IN LPWSTR   pszServer OPTIONAL,
    OUT LPDWORD  lpdwEntriesRead,
    OUT LPCHAT_USER_INFO * Buffer
    );

NET_API_STATUS
I_ChatDisconnectUser(
    IN LPWSTR  pszServer OPTIONAL,
    IN DWORD   idUser
    );

NET_API_STATUS
I_ChatQueryVolumeSecurity(
    IN LPWSTR  pszServer OPTIONAL,
    OUT LPDWORD lpdwReadAccess,
    OUT LPDWORD lpdwWriteAccess
    );

NET_API_STATUS
I_ChatSetVolumeSecurity(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  dwReadAccess,
    IN DWORD  dwWriteAccess
    );

NET_API_STATUS
I_ChatQueryStatistics(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD Level,
    OUT LPBYTE * Buffer
    );

NET_API_STATUS
I_ChatClearStatistics(
    IN LPWSTR pszServer OPTIONAL
    );

#ifdef __cplusplus
}
#endif  // _cplusplus


#endif  // _CHAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\callback.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1998-1999 Microsoft Corporation all rights reserved.
//
// Module:      callback.h
//
// Project:     Chameleon
//
// Description: Callback classes
//
// Author:      TLP 
//
// When         Who    What
// ----         ---    ----
// 2/13/98      TLP    Original version
//
///////////////////////////////////////////////////////////////////////////

#ifndef __INC_CALLBACK_H_
#define __INC_CALLBACK_H_

//////////////////////////////////////////////////////////////////////
//
// The base class "Callback" contains a pointer to the static callback
// function "CallbackRoutine()" located in the derived parameterized
// class Callback_T. An instance of the derived parameterized class 
// Callback_T is created by using the parameterized MakeCallback() 
// function. Note that MakeCallback() returns a pointer to the base
// class part of the class which can be used as a function object. 
// 
//////////////////////////////////////////////////////////////////////

typedef struct Callback *PCALLBACK;

typedef void (WINAPI *PCALLBACKROUTINE)(PCALLBACK This);

//////////////////////////////////////////////////////////////////////
struct Callback
{
   Callback(PCALLBACKROUTINE pFn)
   { pfnCallbackRoutine = pFn; }

   // Invoke the static callback function...
   void DoCallback(void) { pfnCallbackRoutine(this); }

   PCALLBACKROUTINE pfnCallbackRoutine;
};

//////////////////////////////////////////////////////////////////////
template <class Ty, class Fn>
struct Callback_T : Callback
{
   typedef Callback_T<Ty, Fn> _Myt;

   Callback_T(Ty* pObj, Fn pFn)
      : Callback(CallbackRoutine), m_pObj(pObj), m_pFn(pFn) { }

   void operator()() { (m_pObj->*m_pFn)(); }

protected:

   Ty* m_pObj;
   Fn  m_pFn;

   // Here's the static routine invoked from the base class that
   // invokes the actual member function
   static VOID WINAPI CallbackRoutine(Callback* This)
   { 
       (*((_Myt*)This))(); 
       // delete This; 
   }
};

//////////////////////////////////////////////////////////////////////
//
// Function: MakeCallback()
//
// Description:
//
// This template function does the following:
//
// Ty* is bound to pObj
// If pObj points at a class of type Foo then Ty* is the same as Foo*
//
// Fn is bound to pFn 
// Where pFn is a pointer to a function Bar of class Foo with the 
// following signature: void Foo::Bar(void);
// 
// The returned class object pointer can be used to invoke
// the function void Foo::Bar()
//
// This mechanism is useful for invoking class memeber functions 
// from Win32 thread functions.
//
// Example:
//
// MyCallback* pCallback = MakeBoundCallback (this, &Foo::Bar);
//
//////////////////////////////////////////////////////////////////////
template <class Ty, class Fn>
inline Callback* MakeCallback(Ty* pObj, Fn pFn)
{
   return new Callback_T<Ty, Fn>(pObj, pFn);
}


#endif // __INC_CALLBACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\exception.h ===
#ifndef CExExceptionHandler_Included
#define CExExceptionHandler_Included

//+-------------------------------------------------------------
//
// Class:        CExException
//
// Synopsis:    Base class for all exceptions thrown by exception
//                error handling classes.
//
// History:        JKountz    07/22/2000    Created
//
//+-------------------------------------------------------------
class CExException : public _com_error
{
public:
    CExException(HRESULT hr): _com_error(hr){};
};

//+-------------------------------------------------------------
//
// Class:        CExWinException
//
// Synopsis:    Exception for Win32 API error codes
//
// History:        JKountz    07/22/2000    Created
//
//+-------------------------------------------------------------
class CExWinException : public CExException
{
public:
    CExWinException(HRESULT hr): CExException(hr){};
};

//+-------------------------------------------------------------
//
// Class:        CExHResultException
//
// Synopsis:    Exception for HRESULT failures
//
// History:        JKountz    07/22/2000    Created
//
//+-------------------------------------------------------------
class CExHResultException : public CExException
{
public:
    CExHResultException(HRESULT hr): CExException(hr){};
};


//+-------------------------------------------------------------
//
// Class:        CExHResultError
//
// Synopsis:    Exception handler for HRESULT failures. This class 
//                throws exceptions when FAILED(hr)==true
//
// Example:        CExHResultError exHResult;
//                
//                exHResult = CoCreateInstance(...)
//            
//
// History:        JKountz    07/22/2000    Created
//
//+-------------------------------------------------------------
class CExHResultError
{
public:
    CExHResultError()
        : m_hr(S_OK)
    {};

    CExHResultError(HRESULT hr)
        : m_hr(hr)
    {};

    inline void operator=(HRESULT hr)
    {
        if ( m_hr != hr )
        {
            throw CExHResultException(hr);
        }
    }
private:
    HRESULT m_hr;
};


//+-------------------------------------------------------------
//
// Class:        CExWinError
//
// Synopsis:    Exception handler for Win32 error codes. This class 
//                throws exceptions for Win32 API's that return errors.
//
// Example:        CExWinError exWinError;
//                
//                exWinError = GetLastErrorCode();
//            
//
// History:        JKountz    07/22/2000    Created
//
//+-------------------------------------------------------------
class CExWinError
{
public:
    CExWinError() 
        : m_lSuccess(NO_ERROR)
    {};
    
    CExWinError(LONG lSuccess)
        : m_lSuccess(lSuccess)
    {};

    inline void operator=(LONG lRc)
    {
        if ( m_lSuccess != lRc )
        {
            throw CExWinException(HRESULT_FROM_WIN32(lRc));
        }
    }
private:
    LONG m_lSuccess;
        
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\getvalue.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1998-1999 Microsoft Corporation all rights reserved.
//
// Module:      getvalue.h
//
// Project:     Chameleon
//
// Description: Get/Set a property bag value
//
// Author:      TLP 
//
// When         Who    What
// ----         ---    ----
// 12/3/98      TLP    Original version
//
///////////////////////////////////////////////////////////////////////////

#ifndef __INC_GETSET_OBJECT_VALUE_H_
#define __INC_SETSET_OBJECT_VALUE_H_

#include "stdafx.h"

bool
GetObjectValue(
       /*[in]*/ LPCWSTR  pszObjectPath,
       /*[in]*/ LPCWSTR  pszValueName, 
       /*[in]*/ VARIANT* pValue,
       /*[in]*/ UINT     uExpectedType
              );

bool
SetObjectValue(
       /*[in]*/ LPCWSTR  pszObjectPath,
       /*[in]*/ LPCWSTR  pszValueName, 
       /*[in]*/ VARIANT* pValue
              );

#endif // __INC_SETSET_OBJECT_VALUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\eventlog.h ===
#ifndef EVENTLOG_H
#define EVENTLOG_H

#ifndef UNICODE
#error "UNICODE has to be defined"
#endif

//+----------------------------------------------------------------------------
//
// File:eventlog.h     
//
// Module:     
//
// Synopsis: Define eventlog helper class CEventLog
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:     fengsun Created    9/16/98
//
//+----------------------------------------------------------------------------


//+---------------------------------------------------------------------------
//
//    class CEventLog
//
//    Description: A wraper class to report event to eventlog
//
//    History:    fengsun    Created        9/16/98
//
//----------------------------------------------------------------------------
class CEventLog
{
public:
    CEventLog();
    ~CEventLog();

    BOOL Open(LPCTSTR lpSourceName);
    void Close();

    BOOL ReportEvent0(WORD wType, DWORD dwEventID);
    BOOL ReportEvent1(WORD wType, DWORD dwEventID,
                          const TCHAR* pszS1);
    BOOL ReportEvent2(WORD wType, DWORD dwEventID,
                          const TCHAR* pszS1,
                          const TCHAR* pszS2);
    BOOL ReportEvent3(WORD wType, DWORD dwEventID,
                          const TCHAR* pszS1,
                          const TCHAR* pszS2,
                          const TCHAR* pszS3);
    BOOL IsEventLogOpen() const;

protected:
    BOOL ReportEvent(WORD wType, DWORD dwEventID,
                          const TCHAR* pszS1 = NULL,
                          const TCHAR* pszS2 = NULL,
                          const TCHAR* pszS3 = NULL);

    HANDLE m_hEventLog;  // the eventlog handle returned by ::RegisterEventSource
};

//
// inline fuctions
//

inline CEventLog::CEventLog()
{m_hEventLog = NULL;}

inline CEventLog::~CEventLog()
{Close();}

inline void CEventLog::Close()
{
    if (m_hEventLog != NULL)
    {
        ::DeregisterEventSource(m_hEventLog);
    }

    m_hEventLog = NULL;
}

inline BOOL CEventLog::IsEventLogOpen() const
{return m_hEventLog != NULL;}

inline BOOL CEventLog::ReportEvent0(WORD wType, DWORD dwEventID)
{ return ReportEvent(wType, dwEventID);}

inline BOOL CEventLog::ReportEvent1(WORD wType, DWORD dwEventID,
                      const TCHAR* pszS1)
{ return ReportEvent(wType, dwEventID, pszS1);}

inline BOOL CEventLog::ReportEvent2(WORD wType, DWORD dwEventID,
                      const TCHAR* pszS1,
                      const TCHAR* pszS2)
{ return ReportEvent(wType, dwEventID, pszS1, pszS2);}

inline BOOL CEventLog::ReportEvent3(WORD wType, DWORD dwEventID,
                      const TCHAR* pszS1,
                      const TCHAR* pszS2,
                      const TCHAR* pszS3)
{ return ReportEvent(wType, dwEventID, pszS1, pszS2, pszS3);}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\ftpd.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    ftpd.h

    This file contains constants & type definitions shared between the
    FTPD Service, Installer, and Administration UI.


    FILE HISTORY:
        KeithMo     10-Mar-1993 Created.
        MuraliK     23-Oct-1995 Imported for new ftp server
        MuraliK     14-Dec-1995 service name imported from inetinfo.h

*/


#ifndef _FTPD_H_
#define _FTPD_H_

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus

#if !defined(MIDL_PASS)
#include <winsock.h>
#endif

# include <inetinfo.h>

//
//  Name of directory annotation file.  If this file exists
//  in the target directory of a CWD command, its contents
//  will be sent to the user as part of the CWD reply.
//

#define FTPD_ANNOTATION_FILE_A           "~FTPSVC~.CKM"
#define FTPD_ANNOTATION_FILE_W          L"~FTPSVC~.CKM"


//
//  Configuration parameters registry key.
//
# define FTPD_SERVICE_KEY_A  \
  "System\\CurrentControlSet\\Services\\" ## FTPD_SERVICE_NAME_A

# define FTPD_SERVICE_KEY_W \
  L"System\\CurrentControlSet\\Services\\" ## FTPD_SERVICE_NAME_W

#define FTPD_PARAMETERS_KEY_A   FTPD_SERVICE_KEY_A ## "\\Parameters"
  
#define FTPD_PARAMETERS_KEY_W   FTPD_SERVICE_KEY_W ## L"\\Parameters"


//
//  Performance key.
//

#define FTPD_PERFORMANCE_KEY_A  FTPD_SERVICE_KEY_A ## "\\Performance"

#define FTPD_PERFORMANCE_KEY_W  FTPD_SERVICE_KEY_W ## L"\\Performance"


//
//  If this registry key exists under the Parameters key,
//  it is used to validate FTPSVC access.  Basically, all new users
//  must have sufficient privilege to open this key before they
//  may access the FTP Server.
//

#define FTPD_ACCESS_KEY_A                "AccessCheck"
#define FTPD_ACCESS_KEY_W               L"AccessCheck"


//
//  Configuration value names.
//

#define FTPD_ALLOW_ANONYMOUS_A           "AllowAnonymous"
#define FTPD_ALLOW_ANONYMOUS_W          L"AllowAnonymous"

#define FTPD_ALLOW_GUEST_ACCESS_A        "AllowGuestAccess"
#define FTPD_ALLOW_GUEST_ACCESS_W       L"AllowGuestAccess"

#define FTPD_ANONYMOUS_ONLY_A            "AnonymousOnly"
#define FTPD_ANONYMOUS_ONLY_W           L"AnonymousOnly"

#define FTPD_MSDOS_DIR_OUTPUT_A          "MsdosDirOutput"
#define FTPD_MSDOS_DIR_OUTPUT_W         L"MsdosDirOutput"

#define FTPD_GREETING_MESSAGE_A          "GreetingMessage"
#define FTPD_GREETING_MESSAGE_W         L"GreetingMessage"

#define FTPD_EXIT_MESSAGE_A              "ExitMessage"
#define FTPD_EXIT_MESSAGE_W             L"ExitMessage"

#define FTPD_MAX_CLIENTS_MSG_A           "MaxClientsMessage"
#define FTPD_MAX_CLIENTS_MSG_W          L"MaxClientsMessage"

#define FTPD_DEBUG_FLAGS_A               "DebugFlags"
#define FTPD_DEBUG_FLAGS_W              L"DebugFlags"

#define FTPD_ANNOTATE_DIRS_A             "AnnotateDirectories"
#define FTPD_ANNOTATE_DIRS_W            L"AnnotateDirectories"

#define FTPD_LOWERCASE_FILES_A           "LowercaseFiles"
#define FTPD_LOWERCASE_FILES_W          L"LowercaseFiles"

#define FTPD_LISTEN_BACKLOG_A            "ListenBacklog"
#define FTPD_LISTEN_BACKLOG_W           L"ListenBacklog"

#define FTPD_ENABLE_LICENSING_A          "EnableLicensing"
#define FTPD_ENABLE_LICENSING_W         L"EnableLicensing"

#define FTPD_DEFAULT_LOGON_DOMAIN_A      "DefaultLogonDomain"
#define FTPD_DEFAULT_LOGON_DOMAIN_W     L"DefaultLogonDomain"


//
//  Name of the LSA Secret Object containing the password for
//  anonymous logon and virtual UNC roots
//

#define FTPD_ANONYMOUS_SECRET_A          "FTPD_ANONYMOUS_DATA"
#define FTPD_ANONYMOUS_SECRET_W         L"FTPD_ANONYMOUS_DATA"

#define FTPD_ROOT_SECRET_A               "FTPD_ROOT_DATA"
#define FTPD_ROOT_SECRET_W              L"FTPD_ROOT_DATA"

//
//  Handle ANSI/UNICODE sensitivity.
//

#ifdef UNICODE

#define FTPD_ANNOTATION_FILE            FTPD_ANNOTATION_FILE_W
#define FTPD_PARAMETERS_KEY             FTPD_PARAMETERS_KEY_W
#define FTPD_PERFORMANCE_KEY            FTPD_PERFORMANCE_KEY_W
#define FTPD_ACCESS_KEY                 FTPD_ACCESS_KEY_W
#define FTPD_ALLOW_ANONYMOUS            FTPD_ALLOW_ANONYMOUS_W
#define FTPD_ALLOW_GUEST_ACCESS         FTPD_ALLOW_GUEST_ACCESS_W
#define FTPD_ANONYMOUS_ONLY             FTPD_ANONYMOUS_ONLY_W
#define FTPD_MSDOS_DIR_OUTPUT           FTPD_MSDOS_DIR_OUTPUT_W
#define FTPD_GREETING_MESSAGE           FTPD_GREETING_MESSAGE_W
#define FTPD_EXIT_MESSAGE               FTPD_EXIT_MESSAGE_W
#define FTPD_MAX_CLIENTS_MSG            FTPD_MAX_CLIENTS_MSG_W
#define FTPD_DEBUG_FLAGS                FTPD_DEBUG_FLAGS_W
#define FTPD_ANNOTATE_DIRS              FTPD_ANNOTATE_DIRS_W
#define FTPD_ANONYMOUS_SECRET           FTPD_ANONYMOUS_SECRET_W
#define FTPD_LOWERCASE_FILES            FTPD_LOWERCASE_FILES_W
#define FTPD_LISTEN_BACKLOG             FTPD_LISTEN_BACKLOG_W
#define FTPD_ENABLE_LICENSING           FTPD_ENABLE_LICENSING_W
#define FTPD_DEFAULT_LOGON_DOMAIN       FTPD_DEFAULT_LOGON_DOMAIN_W

#else   // !UNICODE

#define FTPD_ANNOTATION_FILE            FTPD_ANNOTATION_FILE_A
#define FTPD_PARAMETERS_KEY             FTPD_PARAMETERS_KEY_A
#define FTPD_PERFORMANCE_KEY            FTPD_PERFORMANCE_KEY_A
#define FTPD_ACCESS_KEY                 FTPD_ACCESS_KEY_A
#define FTPD_ANONYMOUS_ONLY             FTPD_ANONYMOUS_ONLY_A
#define FTPD_ALLOW_ANONYMOUS            FTPD_ALLOW_ANONYMOUS_A
#define FTPD_ALLOW_GUEST_ACCESS         FTPD_ALLOW_GUEST_ACCESS_A
#define FTPD_MSDOS_DIR_OUTPUT           FTPD_MSDOS_DIR_OUTPUT_A
#define FTPD_GREETING_MESSAGE           FTPD_GREETING_MESSAGE_A
#define FTPD_EXIT_MESSAGE               FTPD_EXIT_MESSAGE_A
#define FTPD_MAX_CLIENTS_MSG            FTPD_MAX_CLIENTS_MSG_A
#define FTPD_DEBUG_FLAGS                FTPD_DEBUG_FLAGS_A
#define FTPD_ANNOTATE_DIRS              FTPD_ANNOTATE_DIRS_A
#define FTPD_ANONYMOUS_SECRET           FTPD_ANONYMOUS_SECRET_A
#define FTPD_LOWERCASE_FILES            FTPD_LOWERCASE_FILES_A
#define FTPD_LISTEN_BACKLOG             FTPD_LISTEN_BACKLOG_A
#define FTPD_ENABLE_LICENSING           FTPD_ENABLE_LICENSING_A
#define FTPD_DEFAULT_LOGON_DOMAIN       FTPD_DEFAULT_LOGON_DOMAIN_A

  
#endif  // UNICODE



//
// Structures for APIs
//

typedef struct _FTP_USER_INFO
{
    DWORD    idUser;          //  User id
    LPWSTR   pszUser;         //  User name
    BOOL     fAnonymous;      //  TRUE if the user is logged on as
                              //  Anonymous, FALSE otherwise
    DWORD    inetHost;        //  Host Address
    DWORD    tConnect;        //  User Connection Time (elapsed seconds)

} FTP_USER_INFO, * LPFTP_USER_INFO;

typedef struct _FTP_STATISTICS_0
{
    LARGE_INTEGER TotalBytesSent;
    LARGE_INTEGER TotalBytesReceived;
    DWORD         TotalFilesSent;
    DWORD         TotalFilesReceived;
    DWORD         CurrentAnonymousUsers;
    DWORD         CurrentNonAnonymousUsers;
    DWORD         TotalAnonymousUsers;
    DWORD         TotalNonAnonymousUsers;
    DWORD         MaxAnonymousUsers;
    DWORD         MaxNonAnonymousUsers;
    DWORD         CurrentConnections;
    DWORD         MaxConnections;
    DWORD         ConnectionAttempts;
    DWORD         LogonAttempts;
    DWORD         TimeOfLastClear;

} FTP_STATISTICS_0, * LPFTP_STATISTICS_0;


//
// API Prototypes
//

NET_API_STATUS
I_FtpEnumerateUsers(
    IN LPWSTR   pszServer OPTIONAL,
    OUT LPDWORD  lpdwEntriesRead,
    OUT LPFTP_USER_INFO * Buffer
    );

NET_API_STATUS
I_FtpDisconnectUser(
    IN LPWSTR  pszServer OPTIONAL,
    IN DWORD   idUser
    );

NET_API_STATUS
I_FtpQueryVolumeSecurity(
    IN LPWSTR  pszServer OPTIONAL,
    OUT LPDWORD lpdwReadAccess,
    OUT LPDWORD lpdwWriteAccess
    );

NET_API_STATUS
I_FtpSetVolumeSecurity(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  dwReadAccess,
    IN DWORD  dwWriteAccess
    );

NET_API_STATUS
I_FtpQueryStatistics(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD Level,
    OUT LPBYTE * Buffer
    );

NET_API_STATUS
I_FtpClearStatistics(
    IN LPWSTR pszServer OPTIONAL
    );

#ifdef __cplusplus
}
#endif  // _cplusplus


#endif  // _FTPD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\debug.h ===
#ifndef DEBUG_H
#define DEBUG_H

#ifdef __cplusplus
extern "C" {
#endif

#include <windows.h>


//
// Macros for debugging support.
//
// ASSERT(exp)   Popup a dialogbox, if exp is FALSE
// ASSERTMSG(exp, msg)  Similar to ASSERT.  Except the msg is displayed instead of the expression
//
// Use TRACE(x) for output, where x is a list of printf()-style parameters.  
//     TRACEn() is TRACE with n printf arguments
//     For example, TRACE2("This shows how to print stuff, like a string %s, and a number %u.","string",5);
//
// USE VERIFY for expressions executed for both debug and release version
//

#undef ASSERT
#undef ASSERTMSG

//
// Used by atl
//
#ifdef _ATL_NO_DEBUG_CRT
#define _ASSERTE ASSERT
#define _ASSERT ASSERT
#endif

//
// Trace out the function name
//
#ifdef ENABLE_PROFILE
#define PROFILE(pszFunctionName) TRACE(pszFunctionName)
#else
#define PROFILE(pszFunctionName) ((void)0)
#endif

//
// Define TRACE here. To disable TRACE in retail version, define NO_RETAIL_TRACE
//
#if    ( defined(DEBUG) || defined(_DEBUG) || !defined(NO_RETAIL_TRACE))

#include "satrace.h"
#define TRACE(pszFmt)                    SATraceString(pszFmt)
#define TRACE1(pszFmt, arg1)             SATracePrintf(pszFmt, arg1)
#define TRACE2(pszFmt, arg1, arg2)       SATracePrintf(pszFmt, arg1, arg2)
#define TRACE3(pszFmt, arg1, arg2, arg3) SATracePrintf(pszFmt, arg1, arg2, arg3)

#else

#define TRACE(pszFmt)       ((void)0)             
#define TRACE1(pszFmt, arg1)    ((void)0)             
#define TRACE2(pszFmt, arg1, arg2)  ((void)0)       
#define TRACE3(pszFmt, arg1, arg2, arg3)    ((void)0)

#endif  

/*
#define TRACE(pszFmt)                    TraceMessageA(pszFmt)
#define TRACE1(pszFmt, arg1)             TraceMessageA(pszFmt, arg1)
#define TRACE2(pszFmt, arg1, arg2)       TraceMessageA(pszFmt, arg1, arg2)
#define TRACE3(pszFmt, arg1, arg2, arg3) TraceMessageA(pszFmt, arg1, arg2, arg3)
*/

#if    ( defined(DEBUG) || defined(_DEBUG))

#ifdef UNICODE
#define AssertMessage AssertMessageW
#else
#define AssertMessage AssertMessageA
#endif

void AssertMessage(const TCHAR *pszFile, unsigned nLine, const TCHAR *pszMsg);

#define ASSERT(x)        (void)((x) || (AssertMessage(TEXT(__FILE__),__LINE__,TEXT(#x)),0))
#define ASSERTMSG(exp, msg)   (void)((exp) || (AssertMessage(TEXT(__FILE__),__LINE__,msg),0))

#define VERIFY(x)            ASSERT(x)

// {ASSERT(pObj);pObj->AssertValid();} 
#define ASSERT_VALID(pObj) ((ASSERT(pObj),1) && ((pObj)->AssertValid(),1))

#else // DEBUG

#define ASSERT_VALID(pObj) 
#define ASSERT(x)           ((void)0)
#define ASSERTMSG(exp, msg) ((void)0)
#define VERIFY(x)           (x)       
#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\componentfactory.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      componentfactory.h
//
// Project:     Chameleon
//
// Description: Component Factory Class
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_COMPONENT_FACTORY_H_
#define __INC_COMPONENT_FACTORY_H_

#include "propertybag.h"

#pragma warning( disable : 4786 )
#include <memory>
using namespace std;

//////////////////////////////////////////////////////////////////////////////
// WBEM Object Factory Class

template <class TypeClass, class TypeInterface>
class CComponentFactoryImpl
{

public:

    CComponentFactoryImpl() { }
    ~CComponentFactoryImpl() { }

    //////////////////////////////////////////////////////////////////////////
    // Component Factory Function
    //
    // Inputs: 
    //
    //   pPropertyBag:   Property bag containing the components
    //                   persistent state.
    //
    // Outputs:
    //
    //   Pointer to the new component or NULL if the component could not
    //   be created and initialized
    //
    //////////////////////////////////////////////////////////////////////////
    static IUnknown* WINAPI MakeComponent(
                                  /*[in]*/ PPROPERTYBAG pPropertyBag
                                         )
    {
        TypeInterface* pObj = NULL;
        // Objects create in this fashion require a default constructor
        auto_ptr< CComObjectNoLock<TypeClass> > pNewObj (new CComObjectNoLock<TypeClass>);
        // InternalInitialize() is used to initialize the new component
        if ( SUCCEEDED(pNewObj->InternalInitialize(pPropertyBag)) )
        {
            pObj = dynamic_cast<TypeInterface*>(pNewObj.release());
        }
        return pObj;
    }

private:

    // No copy or assignment
    CComponentFactoryImpl(const CComponentFactoryImpl& rhs);
    CComponentFactoryImpl& operator = (const CComponentFactoryImpl& rhs);
};


//////////////////////////////////////////////////////////////////////////////
// Component Factory Class Macros 
// (include in classes created by the factory)

//////////////////////////////////////////////////////////////////////////////
#define    DECLARE_COMPONENT_FACTORY(TypeClass, TypeInterface)    \
        static CComponentFactoryImpl<TypeClass, TypeInterface> m_Factory;

//////////////////////////////////////////////////////////////////////////////
// Global Component Factory Function Prototype 
//////////////////////////////////////////////////////////////////////////////
IUnknown* MakeComponent(
                /*[in]*/ LPCWSTR      pszClassId,
                /*[in]*/ PPROPERTYBAG pPropertyBag
                       );

//////////////////////////////////////////////////////////////////////////////
// Component Factory Structure - ClassId to Factory Function Mapping 
// (used by global component factory function implementation)
//////////////////////////////////////////////////////////////////////////////
typedef IUnknown* (WINAPI *PFNCOMPONENTFACTORY)(
                                        /*[in]*/ PPROPERTYBAG pPropertyBag
                                               );

//////////////////////////////////////////////////////////////////////////////

typedef struct _COMPONENT_FACTORY_INFO
{
    LPCWSTR            pszClassId;
    PFNCOMPONENTFACTORY    pfnFactory;
        
} COMPONENT_FACTORY_INFO, *PCOMPONENT_FACTORY_INFO;


//////////////////////////////////////////////////////////////////////////////
// Component Factory Map Macros
//////////////////////////////////////////////////////////////////////////////

#define        BEGIN_COMPONENT_FACTORY_MAP(x)                   COMPONENT_FACTORY_INFO x[] = {

#define        DEFINE_COMPONENT_FACTORY_ENTRY(szClassId, Class) { szClassId, Class::m_Factory.MakeComponent },

#define        END_COMPONENT_FACTORY_MAP()                      { NULL, NULL } }; 

#endif // __INC_COMPONENT_FACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\inetcom.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetcom.h

Abstract:

    This file contains contains global definitions for internet products.


Author:

    Madan Appiah (madana) 10-Oct-1995

Revision History:

--*/

#ifndef _INETCOM_H_
#define _INETCOM_H_

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus

# include <lmcons.h>              // for definitions of NET_API*


//
//  Server bitfield mask definitions
//
//  The services using the tsunami cache must be the lowest bits in the
//  bitfield.
//

#define INET_FTP                0x0001
#define INET_GOPHER             0x0002
#define INET_HTTP               0x0004
#define INET_DNS                0x0008
#define INET_HTTP_PROXY         0x0010
#define INET_MSN                0x0020
#define INET_NNTP               0x0040
#define INET_SMTP               0x0080
#define INET_GATEWAY            0x0100
#define INET_POP3               0x0200
#define INET_CHAT               0x0400
#define INET_LDAP               0x0800
#define INET_IMAP               0x1000


//
//  structure Field Control defines
//

typedef DWORD FIELD_CONTROL;
typedef DWORD FIELD_FLAG;

//
//  Returns TRUE if the field specified by bitFlag is set
//

#define IsFieldSet(fc, bitFlag) \
    (((FIELD_CONTROL)(fc) & (FIELD_FLAG)(bitFlag)) != 0)

//
//  Indicates the field specified by bitFlag contains a valid value
//

#define SetField(fc, bitFlag) \
    ((FIELD_CONTROL)(fc) |= (FIELD_FLAG)(bitFlag))

//
//  Simple macro that sets the ith bit
//

#define BitFlag(i)                    ((0x1) << (i))


//
//  Values for Logging related parameters should match with values in
//       internet\svcs\inc\inetlog.h
//

//
// Log Type
//

#define INET_LOG_INVALID              ((DWORD ) -1)
#define INET_LOG_DISABLED             0
#define INET_LOG_TO_FILE              1
#define INET_LOG_TO_SQL               2


// Log File Periods -- options identifying logging periods for InetaLogToFile
#define INET_LOG_PERIOD_NONE          0
#define INET_LOG_PERIOD_DAILY         1
#define INET_LOG_PERIOD_WEEKLY        2
#define INET_LOG_PERIOD_MONTHLY       3
#define INET_LOG_PERIOD_YEARLY        4


// Log Format
#define INET_LOG_FORMAT_INTERNET_STD  0
#define INET_LOG_FORMAT_NCSA          3


# define MAX_TABLE_NAME_LEN            ( 30) // Most DBs support only 30 bytes
# define MAX_USER_NAME_LEN             ( UNLEN + 1)
# define MAX_PASSWORD_LEN              ( PWLEN + 1)


typedef struct _INET_LOG_CONFIGURATION
{

    DWORD   inetLogType;    // type of log.

    // File specific logging. (valid if inetLogType == INET_LOG_TO_FILE)
    DWORD   ilPeriod;              // one of Log File Periods

    // Empty string means do not modify existing default
    WCHAR   rgchLogFileDirectory[MAX_PATH]; // dest for log files

    // Zero value means do not modify the existing default.
    DWORD   cbSizeForTruncation;   // max size for each log file.


    // Sql specific logging (valid if inetLogType == INET_LOG_TO_SQL)
    // Empty string means do not modify existing default

    // rgchDataSource last 4 bytes will be the ilFormat for the log format

    WCHAR   rgchDataSource[MAX_PATH];    // ODBC data source name
    WCHAR   rgchTableName[MAX_TABLE_NAME_LEN];    // table name on data source
    WCHAR   rgchUserName[MAX_USER_NAME_LEN];
                                         // name of user for ODBC connections
    WCHAR   rgchPassword[MAX_PASSWORD_LEN];     // password for ODBC connection

} INET_LOG_CONFIGURATION, * LPINET_LOG_CONFIGURATION;


//
// Field Control common for Gateway services
//

#define FC_INET_COM_CONNECTION_TIMEOUT    ((FIELD_CONTROL)BitFlag(0))
#define FC_INET_COM_MAX_CONNECTIONS       ((FIELD_CONTROL)BitFlag(1))
#define FC_INET_COM_LOG_CONFIG            ((FIELD_CONTROL)BitFlag(2))
#define FC_INET_COM_ADMIN_NAME            ((FIELD_CONTROL)BitFlag(3))
#define FC_INET_COM_SERVER_COMMENT        ((FIELD_CONTROL)BitFlag(4))
#define FC_INET_COM_ADMIN_EMAIL           ((FIELD_CONTROL)BitFlag(5))

#define FC_INET_COM_ALL \
                                     (  FC_INET_COM_CONNECTION_TIMEOUT |\
                                        FC_INET_COM_MAX_CONNECTIONS    |\
                                        FC_INET_COM_LOG_CONFIG         |\
                                        FC_INET_COM_ADMIN_NAME         |\
                                        FC_INET_COM_SERVER_COMMENT     |\
                                        FC_INET_COM_ADMIN_EMAIL         \
                                       )

//
// common config info.
//

typedef struct _INET_COM_CONFIG_INFO
{
    DWORD       dwConnectionTimeout;     // how long to hold connections
    DWORD       dwMaxConnections;        // max connections allowed

    LPWSTR      lpszAdminName;
    LPWSTR      lpszAdminEmail;
    LPWSTR      lpszServerComment;

    LPINET_LOG_CONFIGURATION  lpLogConfig;

    LANGID      LangId;                  // These are read only
    LCID        LocalId;
    BYTE        ProductId[64];

} INET_COM_CONFIG_INFO, *LPINET_COM_CONFIG_INFO;

typedef struct _INET_COMMON_CONFIG_INFO
{
    FIELD_CONTROL FieldControl;
    INET_COM_CONFIG_INFO CommonConfigInfo;

} *LPINET_COMMON_CONFIG_INFO;

//
// Global statistics
//

typedef struct _INET_COM_CACHE_STATISTICS {

    //
    //  These are memory cache counters
    //

    DWORD         CacheBytesTotal;       // Only returned for global statistics
    DWORD         CacheBytesInUse;
    DWORD         CurrentOpenFileHandles;
    DWORD         CurrentDirLists;
    DWORD         CurrentObjects;
    DWORD         FlushesFromDirChanges;
    DWORD         CacheHits;
    DWORD         CacheMisses;

} INET_COM_CACHE_STATISTICS;

typedef struct _INET_COM_ATQ_STATISTICS {

    // Numbers related to Atq Blocking, Rejections of requests
    DWORD         TotalBlockedRequests;
    DWORD         TotalRejectedRequests;
    DWORD         TotalAllowedRequests;
    DWORD         CurrentBlockedRequests;
    DWORD         MeasuredBandwidth;

} INET_COM_ATQ_STATISTICS;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// preserve back ward compatibility                                    //
//                                                                     //
/////////////////////////////////////////////////////////////////////////
typedef INET_COM_CACHE_STATISTICS  INETA_CACHE_STATISTICS,
                               * LPINETA_CACHE_STATISTICS;

typedef INET_COM_ATQ_STATISTICS  INETA_ATQ_STATISTICS,
                               * LPINETA_ATQ_STATISTICS;

/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Stuff from Wininet.h, which is no longer included in the server     //
// files                                                               //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//
// service types for InternetConnect() and dirlist
//

#define INTERNET_SERVICE_FTP    1
#define INTERNET_SERVICE_GOPHER 2
#define INTERNET_SERVICE_HTTP   3


#ifdef __cplusplus
}
#endif  // _cplusplus


#endif  // _INETCOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\mem.h ===
//+----------------------------------------------------------------------------
//
// File:     mem.h     
//      
// Module:   common
//
// Synopsis: Defined memory allocation routines: new delete SaAlloc SaFree and SaRealloc
//
//           In retail version, HeapAlloc and HeapFree will be called
//
//           In debug version, all allocated memory blocks are tracked and guarded with  
//           special flag to watch for memory overwritten and memory leak.  The memory  
//           leak is reported when the binary is unloaded.  The file name and line number 
//           are also recorded and will be reported.
//
//           You need to link with utils.lib and debug.lib
//           If you are using ATL, make sure to include mem.h and debug.h before 
//                  atlbase.h in stdafx.h
//           If you are using STL.  undef _ATL_NO_DEBUG_CRT before include debug.h and 
//           mem.h to allow crtdbg.h.  However fileName/lineNumber for new will not 
//           be recorded.
//           
// Copyright (C) 1997-1998 Microsoft Corporation.  All rights reserved.
//
// Author:     fengsun
//
// Created   9/24 98
//
//+----------------------------------------------------------------------------


#ifndef _MEM_INC_
#define _MEM_INC_
#include <windows.h>

#if (defined(_DEBUG) || defined(DEBUG) )
#define DEBUG_MEM   // Enabled DEBUG_MEM in debug version
#endif   // _DEBUG || DEBUG

//
// If DEBUG_MEM is defined, keep track of all the allocations
// Otherwise, only keep the count for memory leak
//
#if defined(DEBUG_MEM)
//
// Track all the allocated blocks with file name and line number
//
void* AllocDebugMem(long nSize, const char* lpFileName,int nLine);
BOOL FreeDebugMem(void* lpMem);
void* ReAllocDebugMem(void* lpMem, long nSize, const char* lpFileName,int nLine);
BOOL CheckDebugMem();

#define SaAlloc(nSize) AllocDebugMem(nSize,__FILE__, __LINE__)
#define SaFree(lpMem)  ((void)FreeDebugMem(lpMem))
#define SaRealloc(pvPtr, nSize) ReAllocDebugMem(pvPtr, nSize,__FILE__, __LINE__)

inline void   __cdecl operator delete(void* p) 
{SaFree(p);}
inline void*  __cdecl operator new(size_t nSize, const char* lpszFileName, int nLine)
{    return AllocDebugMem(nSize, lpszFileName, nLine);   }

inline void*  __cdecl operator new(size_t nSize)
{    return AllocDebugMem(nSize, NULL, 0);   }


#ifdef _ATL_NO_DEBUG_CRT    // new and delete is also defined by crtdbg.h
//
// Redefine new to keep track of the file name and line number
//
#define DEBUG_NEW new(__FILE__, __LINE__)
#define new DEBUG_NEW

#endif  // _ATL_NO_DEBUG_CRT


#else // DEBUG_MEM

#define CheckDebugMem() (TRUE)

//
// if _ATL_MIN_CRT is defined, ATL will implement these new/delete and CRT functions
//
#ifdef _ATL_MIN_CRT

#include <stdlib.h>
inline void *SaRealloc(void *pvPtr, size_t nBytes) {return realloc(pvPtr, nBytes);};
inline void *SaAlloc(size_t nBytes) {return malloc(nBytes);};
inline void SaFree(void *pvPtr) {free(pvPtr);};


//
// be consist with debug version. atlimpl.cpp will zero out upon allocation
//
#define _MALLOC_ZEROINIT

#else   // _ATL_MIN_CRT
//
// Use our own implementation
//
void *SaRealloc(void *pvPtr, size_t nBytes);
void *SaAlloc(size_t nBytes);
void SaFree(void *pvPtr);

#ifndef NO_INLINE_NEW   // sometime, these functions are not inlined and cause link problem, not sure why
inline void   __cdecl operator delete(void* p) {SaFree(p);}
inline void* __cdecl operator new( size_t cSize ) { return SaAlloc(cSize); }
#endif // NO_INLINE_NEW

#endif // _ATL_MIN_CRT


 
#endif  // DEBUG_MEM


#endif _MEM_INC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\locationinfo.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1998-1999 Microsoft Corporation all rights reserved.
//
// Module:      locationinfo.h
//
// Project:     Chameleon
//
// Description: Data store location information class
//
// Author:      TLP 
//
// When         Who    What
// ----         ---    ----
// 12/3/98      TLP    Original version
//
///////////////////////////////////////////////////////////////////////////

#ifndef __INC_DATASTORE_LOCATION_INFO_H_    
#define __INC_DATASTORE_LOCATION_INFO_H_

#pragma warning( disable : 4786 )  // template produced long name warning
#include <string>
using namespace std;

//////////////////////////////////////////////////////////////////////////////
class CLocationInfo
{
    
public:

    CLocationInfo()
        : m_hObj(NULL) { }

    CLocationInfo(HANDLE hObj, LPCWSTR pObjName)
        : m_hObj(hObj), m_pObjName(pObjName) 
    { _ASSERT(NULL != hObj); _ASSERT( NULL != pObjName); }

    CLocationInfo(CLocationInfo& rhs)
        : m_hObj(rhs.m_hObj), m_pObjName(rhs.m_pObjName) 
    {  }

    CLocationInfo& operator = (CLocationInfo& rhs)
    {
        if ( this != &rhs )
        { 
            m_hObj = rhs.m_hObj;
            m_pObjName = rhs.m_pObjName;
        }
        return *this;
    }

    virtual ~CLocationInfo() { }

    //////////////////////////////////////////////////////////////////////////
    HANDLE getHandle(void) const
    { return m_hObj; }

    //////////////////////////////////////////////////////////////////////////
    LPCWSTR getName(void) const
    { return m_pObjName.c_str(); }

    //////////////////////////////////////////////////////////////////////////
    void setHandle(HANDLE hObj)
    { _ASSERT(NULL != hObj); m_hObj = hObj; }

    //////////////////////////////////////////////////////////////////////////
    void setName(LPCWSTR pObjName)
    { _ASSERT(NULL != pObjName); m_pObjName = pObjName; }

    //////////////////////////////////////////////////////////////////////////
    LPCWSTR getShortName(void)
    {
        LPCWSTR q = wcsrchr(m_pObjName.c_str(), '\\');
        if ( q )
        {
            q++;
        }
        else
        {
            q = m_pObjName.c_str();
        }
        return q;
    }

private:

    HANDLE        m_hObj;
    wstring        m_pObjName;
};

#endif // __INC_DATASTORE_LOCATION_INFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\nocopy.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    nocopy.h
//
// SYNOPSIS
//
//    This file describes the class NonCopyable.
//
// MODIFICATION HISTORY
//
//    10/19/1997    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _NOCOPY_H_
#define _NOCOPY_H_
#if _MSC_VER >= 1000
#pragma once
#endif

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NonCopyable
//
// DESCRIPTION
//
//    Prevents instances of derived classes from being copied.
//
///////////////////////////////////////////////////////////////////////////////
class NonCopyable
{
protected:
   NonCopyable() {}
private:
   NonCopyable(const NonCopyable&);
   NonCopyable& operator=(const NonCopyable&);
};

#endif  // _NOCOPY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\oahelp.inl ===
// **************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
// File:  OAHELP.INL
//
// Description:
//        OLE Automation Helpers for client code
//
// History:
//
// **************************************************************************
#ifndef _OAHELP_INL_
#define _OAHELP_INL_

class CBSTR
{
private:
    BSTR m_pStr;
public:
    CBSTR() { m_pStr = 0; }
    CBSTR(LPWSTR pSrc) { m_pStr = SysAllocString(pSrc); }
    ~CBSTR() { if (m_pStr) SysFreeString(m_pStr); }
    operator BSTR() { return m_pStr; }

    void Unbind() { m_pStr = 0; }
};

class CVARIANT
{
private:
    VARIANT v;
public:
    CVARIANT() { VariantInit(&v); }
    ~CVARIANT() { VariantClear(&v); }
    void Clear()  { VariantClear(&v); }

    operator VARIANT *() { return &v; }
    VARIANT *operator &() { return &v; }

    CVARIANT(LPWSTR pSrc)   { VariantInit(&v); SetStr(pSrc); }
    CVARIANT(LONG lSrc)     { VariantInit(&v); SetLONG(lSrc); }
    CVARIANT(BOOL b)        { VariantInit(&v); SetBool(b); }
    CVARIANT(short i)       { VariantInit(&v); SetShort(i); }
    CVARIANT(double d)      { VariantInit(&v); SetDouble(d); }
    CVARIANT(BYTE b)        { VariantInit(&v); SetByte(b); }

    CVARIANT(IDispatch * pDisp)
    { 
        VariantInit(&v); pDisp->AddRef();
        SetDispatch(pDisp);
    }

    void   SetStr(LPWSTR pSrc)
    {
        Clear();
        V_VT(&v) = pSrc ? VT_BSTR : VT_NULL; 
        V_BSTR(&v) = pSrc ? SysAllocString(pSrc) : 0; 
    }

    LPWSTR GetStr() { return V_VT(&v) == VT_BSTR ? V_BSTR(&v) : 0; }
    operator LPWSTR() { return V_VT(&v) == VT_BSTR ? V_BSTR(&v) : 0; }

    void SetLONG(LONG lSrc) { Clear(); V_VT(&v) = VT_I4; V_I4(&v) = lSrc; }
    LONG GetLONG() { return V_I4(&v); }
    operator LONG() { return V_I4(&v);  }

    void SetDouble(double dSrc) 
    { 
        Clear();
        V_VT(&v) = VT_R8;
        V_R8(&v) = dSrc;
    }
    double GetDouble() { return V_R8(&v); }
    operator double() { return V_R8(&v);  }

    void SetByte(BYTE bySrc) { Clear(); V_VT(&v) = VT_UI1; V_UI1(&v) = bySrc;}
    BYTE GetByte() { return V_UI1(&v); }
    operator BYTE() { return V_UI1(&v);  }

    void SetBool(BOOL b) 
    {
        V_VT(&v) = VT_BOOL; 
        V_BOOL(&v) = b ? VARIANT_TRUE : VARIANT_FALSE;
    }
    BOOL GetBool() { return V_BOOL(&v) == VARIANT_TRUE; }
    operator BOOL() { return V_BOOL(&v); }

    void SetDispatch(IDispatch* pDisp) 
    {
        V_VT(&v) = VT_DISPATCH; 
        V_DISPATCH(&v) = pDisp;
    }
    IDispatch * GetDispatch() { return V_DISPATCH(&v); }

    void SetUnknown(IUnknown* pUnk) 
    {
        V_VT(&v) = VT_UNKNOWN; 
        V_UNKNOWN(&v) = pUnk;
    }
    IUnknown * GetUnknown() { return V_UNKNOWN(&v); }

    void SetShort(short i) { V_VT(&v) = VT_I2; V_I2(&v) = i; }
    short GetShort() { return V_I2(&v); }
    operator short() { return V_I2(&v); }

    VARTYPE GetType() { return V_VT(&v); }

    void SetArray(SAFEARRAY *p, VARTYPE vt) 
    { 
        Clear(); 
        V_VT(&v) = vt;
        V_ARRAY(&v) = p;
    }

    operator SAFEARRAY *() { return (V_VT(&v) & VT_ARRAY ? V_ARRAY(&v) : 0); }

    void Unbind() { VariantInit(&v); }
};

class CSAFEARRAY
{
private:
    SAFEARRAY *p;
public:
    CSAFEARRAY(VARTYPE v, int nSize) 
    {
        SAFEARRAYBOUND rgsabound[1];
        rgsabound[0].lLbound = 0;
        rgsabound[0].cElements = nSize;
        p = SafeArrayCreate(v, 1, rgsabound);
    }
    
    ~CSAFEARRAY() { if (p) SafeArrayDestroy(p); }
    CSAFEARRAY(SAFEARRAY *pSrc) { p = pSrc; }

    HRESULT Put(long nLocation, LPVOID pData) {
        return SafeArrayPutElement(p, &nLocation, pData);                
    }

    HRESULT Get(long nLocation, LPVOID pData) { 
        return SafeArrayGetElement(p, &nLocation, pData);                
    }

    HRESULT Access(void **pData) { return SafeArrayAccessData(p, pData); }
    HRESULT Unaccess() { return SafeArrayUnaccessData(p); }

    operator SAFEARRAY *() { return p; }
    long GetNumElements() 
    {
        long upper; 
        SafeArrayGetUBound(p, 1, &upper);
        return upper + 1;
    }

    void Unbind() { p = 0; }
};
#endif    //#ifndef _OAHELP_INL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\propertybagfactory.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1998-1999 Microsoft Corporation all rights reserved.
//
// Module:      propbagfactory.h
//
// Project:     Chameleon
//
// Description: Property bag factory function declarations
//
// Author:      TLP 
//
// When         Who    What
// ----         ---    ----
// 12/3/98      TLP    Original version
//
///////////////////////////////////////////////////////////////////////////

#ifndef __INC_PROPERTY_BAG_FACTORY_H_    
#define __INC_PROPERTY_BAG_FACTORY_H_

#include "propertybag.h"

/////////////////////////////////////////////////////////////////////////////
// Factory functions used to create property bags and property bag containers
/////////////////////////////////////////////////////////////////////////////

typedef enum _PROPERTY_BAG_TYPE
{
    PROPERTY_BAG_REGISTRY,    // Registry based property bag
    PROPERTY_BAG_WBEMOBJ,    // WBEM IWbemClassObject based property bag
    // New types here...

    PROPERTY_BAG_INVALID    // Error checking

} PROPERTY_BAG_TYPE;


//////////////////////////////////////////////////////////////////////////////
PPROPERTYBAG
MakePropertyBag(
        /*[in]*/ PROPERTY_BAG_TYPE    eType,
        /*[in]*/ CLocationInfo&        locationInfo
               );

//////////////////////////////////////////////////////////////////////////////
PPROPERTYBAGCONTAINER 
MakePropertyBagContainer(
                 /*[in]*/ PROPERTY_BAG_TYPE    eType,
                 /*[in]*/ CLocationInfo&    locationInfo
                        );

#endif // __INC_PROPERTY_BAG_FACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\ntservice.h ===
//+----------------------------------------------------------------------------
//
// File: ntservice.h
//
// Module: Server Appliance 
//
// Synopsis: Definitions for class CNTService
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:     fengsun Created    3/11/99
//
//+----------------------------------------------------------------------------

#ifndef NTSERVICE_H
#define NTSERVICE_H

#include <windows.h>
#include <stdio.h>


//+----------------------------------------------------------------------------
//
// class CNTService
//
// Synopsis: A class for writing NT service
// 
// History:   fengsun Created Header    3/10/99
//
//+----------------------------------------------------------------------------

class CNTService
{
public:
    CNTService();
    ~CNTService();

    BOOL StartService(const TCHAR* pszServiceName, BOOL bRunAsService);

    static BOOL Install(const TCHAR* pszServiceName, const TCHAR* pszDisplayName,
                        DWORD dwStartType = SERVICE_DEMAND_START,
                        DWORD dwServiceType = SERVICE_WIN32_OWN_PROCESS);

protected:
    void SetStatus(DWORD dwState);
    BOOL InitializeService();

    virtual void Run() {};  // No pure virtual function, which need purecall from CRT

     //
    // Whether the service can be loaded
    // called in ServiceMain , if return false, will stop the service
    //
    virtual BOOL CanLoad() {return TRUE;}
    virtual BOOL OnStop() {return TRUE;}

    void OnShutdown(){};      // change this to virtual, if overwriting is needed
    void OnControlMessage(DWORD /*dwOpcode*/){};

    // static member functions
    static void WINAPI ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    static void WINAPI Handler(DWORD dwOpcode);
    static void CreateConsoleThread(void);
    static DWORD __stdcall ConsoleThread(LPVOID);
    static BOOL IsInstalled(const TCHAR* pszServiceName);

public:
    TCHAR m_szServiceName[32];   // The short name of the service
    SERVICE_STATUS_HANDLE m_hServiceStatus;  // the handle to report status
    SERVICE_STATUS m_Status;  // The service status structure
    BOOL m_bRunAsService;  // whether running as a service or a console application

public:
    static CNTService* m_pThis; // Point to the only instance
};

#endif // NTSERVICE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\propertybag.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1998-1999 Microsoft Corporation all rights reserved.
//
// Module:      propertybag.h
//
// Project:     Chameleon
//
// Description: Property bag classes definitions
//
// Author:      TLP 
//
// When         Who    What
// ----         ---    ----
// 12/3/98      TLP    Original version
//
///////////////////////////////////////////////////////////////////////////

#ifndef __INC_PROPERTY_BAG_H_
#define __INC_PROPERTY_BAG_H_

#include "basedefs.h"
#include "locationinfo.h"

class CPropertyBag;                 // forward declaraion
typedef CHandle<CPropertyBag>     PPROPERTYBAG;
typedef CMasterPtr<CPropertyBag> MPPROPERTYBAG;

///////////////////////////////////////////////////////////////////////////
// CPropertyBagContainer
//
class CPropertyBagContainer
{

public:

    virtual ~CPropertyBagContainer() { }

    // Open the container
    virtual bool open(void) = 0;

    // Close the container
    virtual void close(void) = 0;

    // Get the container's location information
    virtual void getLocation(CLocationInfo& location) = 0;

    // Get the name of the container
    virtual LPCWSTR    getName(void) = 0;

    // Get the number of objects in the container
    virtual DWORD count(void) = 0;                        

    // Create a new object and add it to the container    
    virtual PPROPERTYBAG add(LPCWSTR pszName) = 0;                

    // Remove the specified object from the container
    virtual bool remove(LPCWSTR pszName) = 0;            

    // Find the specified object in the container
    virtual PPROPERTYBAG find(LPCWSTR pszName) = 0;            

    // Reset the iterator to the start of the container
    virtual bool reset(void) = 0;                        

    // Get the item at the current iterator position
    virtual PPROPERTYBAG current(void) = 0;                        

    // Move the iterator to the next poisition in the container
    virtual bool next(void) = 0;                            
};

typedef CMasterPtr<CPropertyBagContainer>    MPPROPERTYBAGCONTAINER;
typedef CHandle<CPropertyBagContainer>        PPROPERTYBAGCONTAINER;


///////////////////////////////////////////////////////////////////////////
// CPropertyBag
//
class CPropertyBag
{

public:

    virtual ~CPropertyBag() { }

    // Open the bag
    virtual bool open(void) = 0;

    // Close the bag
    virtual void close(void) = 0;

    // Get the bag's location information
    virtual void getLocation(CLocationInfo& location) = 0;

    // Get the name of the bag
    virtual LPCWSTR    getName(void) = 0;

    // Ask the bag to load its properties from the underlying persistent store
    virtual bool load(void) = 0;

    // Ask the bag to save its properties to the underlying persistent store
    virtual bool save(void) = 0;

    // Determine if the bag is a container of other bags
    virtual bool IsContainer() = 0;

    // Get the bags container object (container of subobjects)
    virtual PPROPERTYBAGCONTAINER getContainer(void) = 0;

    // Determine if a property is in the bag
    virtual bool IsProperty(LPCWSTR pszPropertyName) = 0;

    // Get the value for a specified property
    virtual bool get(LPCWSTR pszPropertyName, VARIANT* pValue) = 0;

    // Set the value for a specified property
    virtual bool put(LPCWSTR pszPropertyName, VARIANT* pValue) = 0;

    // Reset the property bag iterator to the first property in the bag
    virtual bool reset(void) = 0;

    // Get the length of the longest property name
    virtual DWORD getMaxPropertyName(void) = 0;

    // Get the value at the current property bag iterator
    virtual bool current(LPWSTR pszPropertyName, VARIANT* pValue) = 0;

    // Move the property bag iterator to the next property position
    virtual bool next(void) = 0;
};

#endif // __INC_PROPERTY_BAG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\saconst.h ===
//+----------------------------------------------------------------------------
//
// File:  SaConst.h     
//
// Module:     Server Appliance
//
// Synopsis: Define const values that are shared by multiple sub projects
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:     fengsun Created    10/7/98
//
//+----------------------------------------------------------------------------

#ifndef _SACONST_H_
#define _SACONST_H_

//
// The registry key root under HKEY_LOCAL_MACHINE
//
#define REGKEY_SERVER_APPLIANCE TEXT("SOFTWARE\\Microsoft\\ServerAppliance")

//
// The ServiceDirectory sub key
//
#define REGKEY_SERVICE_DIRECTORY REGKEY_SERVER_APPLIANCE TEXT("\\ServiceDirectory")

//
// The user name for IIS anonymous account
//
#define INET_ANONYMOUS_USERNAME     TEXT("IUSR_CHAMELEON")


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\sacomguid.h ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    sacomguid.h

Abstract:

    defines the guids for sacom components
Author:

    Serdar Unal (serdarun) 8-April-2002


Notes:


--*/

#ifndef _SACOMGUID_
#define _SACOMGUID_


#if !defined(__midl)

DEFINE_GUID( IID_ISaNvram, 0x38362A9B, 0xB73B, 0x46D2, 0xBB, 0x7A, 0x51, 0xA5, 0x0A, 0xC6, 0xC5, 0x71 );
//38362A9B-B73B-46D2-BB7A-51A50AC6C571
DEFINE_GUID( CLSID_SaNvram,0x1CB8F970, 0x7742, 0x4B1C, 0x80, 0x37, 0x66, 0xD0, 0xCE, 0xA2, 0xAB, 0x57 );
//1CB8F970-7742-4B1C-8037-66D0CEA2AB57

DEFINE_GUID( IID_ISaKeypad, 0xA6B88613, 0x2668, 0x44EF, 0xA4, 0x18, 0x10, 0x9B, 0x06, 0x23, 0x01, 0xE4 );
//A6B88613-2668-44EF-A418-109B062301E4
DEFINE_GUID( CLSID_SaKeypad,0x59BAE4E1, 0x3604, 0x489A, 0xA6, 0x01, 0xAC, 0x95, 0x58, 0xA5, 0x17, 0x3D );
//59BAE4E1-3604-489A-A601-AC9558A5173D

DEFINE_GUID( IID_ISaDisplay, 0x17797AF6, 0xE4AA, 0x46EC, 0xB9, 0xC5, 0xC5, 0xB3, 0x91, 0xFE, 0x19, 0x21 );
//17797AF6-E4AA-46EC-B9C5-C5B391FE1921
DEFINE_GUID( CLSID_SaDisplay,0x750CE1C2, 0x4BE7, 0x44D7, 0x97, 0xBD, 0x16, 0x4F, 0x6C, 0xF0, 0xD3, 0x73 );
//750CE1C2-4BE7-44D7-97BD-164F6CF0D373


#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\randgen.h ===
/*
 * FILE: RandGen.h 
 * 
 * PURPOSE: Header file for a random number generator, based on
 *          original code by George Marsaglia.
 *
 * AUTHOR: Karl Denninghoff, November 1998
 *
 * Copyright: Microsoft Corporation, 1998
 */


#ifndef RANDGEN_H
#define RANDGEN_H


#ifndef _BASETSD_H_ // if the base sized types not defined (header file not included)
    typedef unsigned __int32 UINT32 ;
#endif

typedef unsigned __int16 UINT16 ;

    // maximum number returned by RandInt()
const UINT32 MAX_RANDGEN = 0xffffffffL; 

//-------------------------------------------------------------
//
// CLASS CSARandGen
//
// PURPOSE: Generates random numbers of 32 bits with a period of
//          about 2^250. However, since the seed is 32 bits, there
//          are only 2^32 different possible sequences accessible
//          through the interface provided.
//
// USAGE RULES and REMARKS: 
//       1) You may have as many instances (random number generators)
//          as you wish simultneously in a process.
//       2) The code is not thread-safe, i.e., you must not make
//          simultaneous calls to a particular random number generator
//          (CSARandGen instance) on different threads. If more than 
//          one thread is to call a particular generator, you should 
//          provide the synchronization necessary in some wrapper class.
//       3) Generation and subsequent conversion to a random real 
//          uniformly distributed over the interval [0,1] is provided 
//          by the RandReal() member function.
//       4) If you do not explicitly seed the generator, then the sequence
//          generated will with high probability be indestinguishable from
//          sequences generated by another instance. It will be an 
//          unrelated sequence that you will not be able to re-generate.
//       5) The constructor seeds the generator automatically using 
//          system clock input. However, it does not tell you this value.
//          If you want a random seed (one you likely have not used before) and
//          you also want to be able to repeat the sequence later, then
//          the following technique will work well.
//
//          CSARandGen *pRandGen = new CSARandGen;
//          UINT32 ulSeed = pRandGen->RandInt(); // gets a random seed value
//          pRandGen->RandSeed( ulSeed );
//              // now save ulSeed so you can use it again to seed
//              // a generator. Any CSARandGen instance will produce
//              // the same sequence after calling the seed function
//              // with the same seed value.
//
//
class CSARandGen {
    public: // public functions
        _stdcall CSARandGen();

            // seeds the random number generator, can be called at 
            // any time to re-seed, seeding with the same number starts
            // the same sequence. 
        void _stdcall RandSeed( UINT32 ulSeed );

            // returns uniformly distributed random number 
            // between 0 and MAX_RANDGEN inclusive, period about 2^250
        UINT32 _stdcall RandInt(); 

            // returns uniformly distributed random floating point number
            // between 0 and 1. Two adjacent possible numbers are 
            // 1/MAX_RANDGEN apart.
        double _stdcall RandReal()
        {
            return double(RandInt())/double(MAX_RANDGEN);
        };


    private: // private data members
        UINT16 mother1[10];
        UINT16 mother2[10];
        static LONG slCInstances; // keeps count of instantiations, used to ensure
                                  // uniqueness of default seeds when two instantiations
                                  // result in the same tick and filetime.
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\rtutils.h ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    rtutils.h

Abstract:
     Public declarations for the Router process  utility functions.

--*/

#ifndef __ROUTING_RTUTILS_H__
#define __ROUTING_RTUTILS_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// TRACING FUNCTION PROTOTYPES                                              //
//                                                                          //
// See DOCUMENT for more information                                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Definitions for flags and constants                                      //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define TRACE_USE_FILE      0x00000001
#define TRACE_USE_CONSOLE   0x00000002
#define TRACE_NO_SYNCH      0x00000004

#define TRACE_NO_STDINFO    0x00000001
#define TRACE_USE_MASK      0x00000002
#define TRACE_USE_MSEC      0x00000004

#define INVALID_TRACEID     0xFFFFFFFF


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// ANSI entry-points                                                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
APIENTRY
TraceRegisterExA(
    IN  LPCSTR      lpszCallerName,
    IN  DWORD       dwFlags
    );

DWORD
APIENTRY
TraceDeregisterA(
    IN  DWORD       dwTraceID
    );

DWORD
APIENTRY
TraceDeregisterExA(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags
    );

DWORD
APIENTRY
TraceGetConsoleA(
    IN  DWORD       dwTraceID,
    OUT LPHANDLE    lphConsole
    );

DWORD
APIENTRY
TracePrintfA(
    IN  DWORD       dwTraceID,
    IN  LPCSTR      lpszFormat,
    IN  ...         OPTIONAL
    );

DWORD
APIENTRY
TracePrintfExA(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags,
    IN  LPCSTR      lpszFormat,
    IN  ...         OPTIONAL
    );

DWORD
APIENTRY
TraceVprintfExA(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags,
    IN  LPCSTR      lpszFormat,
    IN  va_list     arglist
    );

DWORD
APIENTRY
TracePutsExA(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags,
    IN  LPCSTR      lpszString
    );

DWORD
APIENTRY
TraceDumpExA(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags,
    IN  LPBYTE      lpbBytes,
    IN  DWORD       dwByteCount,
    IN  DWORD       dwGroupSize,
    IN  BOOL        bAddressPrefix,
    IN  LPCSTR      lpszPrefix
    );


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// ANSI entry-points macros                                                 //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define TraceRegisterA(a)               TraceRegisterExA(a,0)
#define TraceVprintfA(a,b,c)            TraceVprintfExA(a,0,b,c)
#define TracePutsA(a,b)                 TracePutsExA(a,0,b)
#define TraceDumpA(a,b,c,d,e,f)         TraceDumpExA(a,0,b,c,d,e,f)



//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Unicode entry-points                                                     //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
APIENTRY
TraceRegisterExW(
    IN  LPCWSTR     lpszCallerName,
    IN  DWORD       dwFlags
    );

DWORD
APIENTRY
TraceDeregisterW(
    IN  DWORD       dwTraceID
    );

DWORD
APIENTRY
TraceDeregisterExW(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags
    );

DWORD
APIENTRY
TraceGetConsoleW(
    IN  DWORD       dwTraceID,
    OUT LPHANDLE    lphConsole
    );

DWORD
APIENTRY
TracePrintfW(
    IN  DWORD       dwTraceID,
    IN  LPCWSTR     lpszFormat,
    IN  ...         OPTIONAL
    );

DWORD
APIENTRY
TracePrintfExW(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags,
    IN  LPCWSTR     lpszFormat,
    IN  ...         OPTIONAL
    );

DWORD
APIENTRY
TraceVprintfExW(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags,
    IN  LPCWSTR     lpszFormat,
    IN  va_list     arglist
    );

DWORD
APIENTRY
TracePutsExW(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags,
    IN  LPCWSTR     lpszString
    );

DWORD
APIENTRY
TraceDumpExW(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags,
    IN  LPBYTE      lpbBytes,
    IN  DWORD       dwByteCount,
    IN  DWORD       dwGroupSize,
    IN  BOOL        bAddressPrefix,
    IN  LPCWSTR     lpszPrefix
    );


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Unicode entry-points macros                                              //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define TraceRegisterW(a)               TraceRegisterExW(a,0)
#define TraceVprintfW(a,b,c)            TraceVprintfExW(a,0,b,c)
#define TracePutsW(a,b)                 TracePutsExW(a,0,b)
#define TraceDumpW(a,b,c,d,e,f)         TraceDumpExW(a,0,b,c,d,e,f)



//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Code-page dependent entry-point macros                                   //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#ifdef UNICODE
#define TraceRegister           TraceRegisterW
#define TraceDeregister         TraceDeregisterW
#define TraceDeregisterEx       TraceDeregisterExW
#define TraceGetConsole         TraceGetConsoleW
#define TracePrintf             TracePrintfW
#define TraceVprintf            TraceVprintfW
#define TracePuts               TracePutsW
#define TraceDump               TraceDumpW
#define TraceRegisterEx         TraceRegisterExW
#define TracePrintfEx           TracePrintfExW
#define TraceVprintfEx          TraceVprintfExW
#define TracePutsEx             TracePutsExW
#define TraceDumpEx             TraceDumpExW
#else
#define TraceRegister           TraceRegisterA
#define TraceDeregister         TraceDeregisterA
#define TraceDeregisterEx       TraceDeregisterExA
#define TraceGetConsole         TraceGetConsoleA
#define TracePrintf             TracePrintfA
#define TraceVprintf            TraceVprintfA
#define TracePuts               TracePutsA
#define TraceDump               TraceDumpA
#define TraceRegisterEx         TraceRegisterExA
#define TracePrintfEx           TracePrintfExA
#define TraceVprintfEx          TraceVprintfExA
#define TracePutsEx             TracePutsExA
#define TraceDumpEx             TraceDumpExA
#endif



//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// EVENT LOGGING FUNCTION PROTOTYPES                                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// ANSI prototypes                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


VOID
APIENTRY
LogErrorA(
    IN DWORD    dwMessageId,
    IN DWORD    cNumberOfSubStrings,
    IN LPSTR   *plpwsSubStrings,
    IN DWORD    dwErrorCode
);

VOID
APIENTRY
LogEventA(
    IN DWORD   wEventType,
    IN DWORD   dwMessageId,
    IN DWORD   cNumberOfSubStrings,
    IN LPSTR  *plpwsSubStrings
);


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Unicode prototypes                                                       //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

VOID
LogErrorW(
    IN DWORD    dwMessageId,
    IN DWORD    cNumberOfSubStrings,
    IN LPWSTR  *plpwsSubStrings,
    IN DWORD    dwErrorCode
);

VOID
LogEventW(
    IN DWORD   wEventType,
    IN DWORD   dwMessageId,
    IN DWORD   cNumberOfSubStrings,
    IN LPWSTR *plpwsSubStrings
);


#ifdef UNICODE
#define LogError                LogErrorW
#define LogEvent                LogEventW
#else
#define LogError                LogErrorA
#define LogEvent                LogEventA
#endif


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The following functions allow the caller to specify the event source.    //
//                                                                          //
// Call RouterLogRegister with the strings which would be passed to         //
// RegisterEventSource; this returns a handle which can be passed           //
// to the functions RouterLogEvent and RouterLogEventData.                  //
//                                                                          //
// Call RouterLogDeregister to close the handle.                            //
//                                                                          //
// Macros are provided for the different kinds of event log entrys:         //
//  RouterLogError          logs an error (EVENTLOG_ERROR_TYPE)             //
//  RouterLogWarning        logs a warning (EVENTLOG_WARNING_TYPE)          //
//  RouterLogInformation    logs information (EVENTLOG_INFORMATION_TYPE)    //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// ANSI prototypes                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

HANDLE
RouterLogRegisterA(
    LPCSTR lpszSource
    );

VOID
RouterLogDeregisterA(
    HANDLE hLogHandle
    );

VOID
RouterLogEventA(
    IN HANDLE hLogHandle,
    IN DWORD dwEventType,
    IN DWORD dwMessageId,
    IN DWORD dwSubStringCount,
    IN LPSTR *plpszSubStringArray,
    IN DWORD dwErrorCode
    );

VOID
RouterLogEventDataA(
    IN HANDLE hLogHandle,
    IN DWORD dwEventType,
    IN DWORD dwMessageId,
    IN DWORD dwSubStringCount,
    IN LPSTR *plpszSubStringArray,
    IN DWORD dwDataBytes,
    IN LPBYTE lpDataBytes
    );

VOID
RouterLogEventStringA(
    IN HANDLE hLogHandle,
    IN DWORD dwEventType,
    IN DWORD dwMessageId,
    IN DWORD dwSubStringCount,
    IN LPSTR *plpszSubStringArray,
    IN DWORD dwErrorCode,
    IN DWORD dwErrorIndex
    );

VOID
RouterLogEventExA(
    IN HANDLE   hLogHandle,
    IN DWORD    dwEventType,
    IN DWORD    dwErrorCode,
    IN DWORD    dwMessageId,
    IN LPCSTR   ptszFormat,
    ...
    );

VOID
RouterLogEventValistExA(
    IN HANDLE   hLogHandle,
    IN DWORD    dwEventType,
    IN DWORD    dwErrorCode,
    IN DWORD    dwMessageId,
    IN LPCSTR   ptszFormat,
    IN va_list  arglist
    );

DWORD
RouterGetErrorStringA(
    IN  DWORD   dwErrorCode,
    OUT LPSTR * lplpszErrorString
    );

#define RouterLogErrorA(h,msg,count,array,err) \
        RouterLogEventA(h,EVENTLOG_ERROR_TYPE,msg,count,array,err)
#define RouterLogWarningA(h,msg,count,array,err) \
        RouterLogEventA(h,EVENTLOG_WARNING_TYPE,msg,count,array,err)
#define RouterLogInformationA(h,msg,count,array,err) \
        RouterLogEventA(h,EVENTLOG_INFORMATION_TYPE,msg,count,array,err)

#define RouterLogErrorDataA(h,msg,count,array,c,buf) \
        RouterLogEventDataA(h,EVENTLOG_ERROR_TYPE,msg,count,array,c,buf)
#define RouterLogWarningDataA(h,msg,count,array,c,buf) \
        RouterLogEventDataA(h,EVENTLOG_WARNING_TYPE,msg,count,array,c,buf)
#define RouterLogInformationDataA(h,msg,count,array,c,buf) \
        RouterLogEventDataA(h,EVENTLOG_INFORMATION_TYPE,msg,count,array,c,buf)

#define RouterLogErrorStringA(h,msg,count,array,err,index) \
        RouterLogEventStringA(h,EVENTLOG_ERROR_TYPE,msg,count,array, err,index)
#define RouterLogWarningStringA(h,msg,count,array,err,index) \
        RouterLogEventStringA(h,EVENTLOG_WARNING_TYPE,msg,count,array,err,index)
#define RouterLogInformationStringA(h,msg,count,array, err,index) \
        RouterLogEventStringA(h,EVENTLOG_INFORMATION_TYPE,msg,count,array,err,\
                              index)


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Unicode prototypes                                                       //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

HANDLE
RouterLogRegisterW(
    LPCWSTR lpszSource
    );

VOID
RouterLogDeregisterW(
    HANDLE hLogHandle
    );

VOID
RouterLogEventW(
    IN HANDLE hLogHandle,
    IN DWORD dwEventType,
    IN DWORD dwMessageId,
    IN DWORD dwSubStringCount,
    IN LPWSTR *plpszSubStringArray,
    IN DWORD dwErrorCode
    );

VOID
RouterLogEventDataW(
    IN HANDLE hLogHandle,
    IN DWORD dwEventType,
    IN DWORD dwMessageId,
    IN DWORD dwSubStringCount,
    IN LPWSTR *plpszSubStringArray,
    IN DWORD dwDataBytes,
    IN LPBYTE lpDataBytes
    );

VOID
RouterLogEventStringW(
    IN HANDLE hLogHandle,
    IN DWORD dwEventType,
    IN DWORD dwMessageId,
    IN DWORD dwSubStringCount,
    IN LPWSTR *plpszSubStringArray,
    IN DWORD dwErrorCode,
    IN DWORD dwErrorIndex
    );

VOID
RouterLogEventExW(
    IN HANDLE   hLogHandle,
    IN DWORD    dwEventType,
    IN DWORD    dwErrorCode,
    IN DWORD    dwMessageId,
    IN LPCWSTR  ptszFormat,
    ...
    );

VOID
RouterLogEventValistExW(
    IN HANDLE   hLogHandle,
    IN DWORD    dwEventType,
    IN DWORD    dwErrorCode,
    IN DWORD    dwMessageId,
    IN LPCWSTR  ptszFormat,
    IN va_list  arglist
    );

DWORD
RouterGetErrorStringW(
    IN  DWORD    dwErrorCode,
    OUT LPWSTR * lplpwszErrorString
    );


#define RouterLogErrorW(h,msg,count,array,err) \
        RouterLogEventW(h,EVENTLOG_ERROR_TYPE,msg,count,array,err)
#define RouterLogWarningW(h,msg,count,array,err) \
        RouterLogEventW(h,EVENTLOG_WARNING_TYPE,msg,count,array,err)
#define RouterLogInformationW(h,msg,count,array,err) \
        RouterLogEventW(h,EVENTLOG_INFORMATION_TYPE,msg,count,array,err)

#define RouterLogErrorDataW(h,msg,count,array,c,buf) \
        RouterLogEventDataW(h,EVENTLOG_ERROR_TYPE,msg,count,array,c,buf)
#define RouterLogWarningDataW(h,msg,count,array,c,buf) \
        RouterLogEventDataW(h,EVENTLOG_WARNING_TYPE,msg,count,array,c,buf)
#define RouterLogInformationDataW(h,msg,count,array,c,buf) \
        RouterLogEventDataW(h,EVENTLOG_INFORMATION_TYPE,msg,count,array,c,buf)

#define RouterLogErrorStringW(h,msg,count,array,err,index) \
        RouterLogEventStringW(h,EVENTLOG_ERROR_TYPE,msg,count,array,err,index)
#define RouterLogWarningStringW(h,msg,count,array,err,index) \
        RouterLogEventStringW(h,EVENTLOG_WARNING_TYPE,msg,count,array,err,index)
#define RouterLogInformationStringW(h,msg,count,array,err,index) \
        RouterLogEventStringW(h,EVENTLOG_INFORMATION_TYPE,msg,count,array,err,\
                              index)


#ifdef UNICODE
#define RouterLogRegister           RouterLogRegisterW
#define RouterLogDeregister         RouterLogDeregisterW
#define RouterLogEvent              RouterLogEventW
#define RouterLogError              RouterLogErrorW
#define RouterLogWarning            RouterLogWarningW
#define RouterLogInformation        RouterLogInformationW
#define RouterLogEventData          RouterLogEventDataW
#define RouterLogErrorData          RouterLogErrorDataW
#define RouterLogWarningData        RouterLogWarningDataW
#define RouterLogInformationData    RouterLogInformationDataW
#define RouterLogEventString        RouterLogEventStringW
#define RouterLogEventEx            RouterLogEventExW
#define RouterLogEventValistEx      RouterLogEventValistExW
#define RouterLogErrorString        RouterLogErrorStringW
#define RouterLogWarningString      RouterLogWarningStringW
#define RouterLogInformationString  RouterLogInformationStringW
#define RouterGetErrorString        RouterGetErrorStringW
#
#else
#define RouterLogRegister           RouterLogRegisterA
#define RouterLogDeregister         RouterLogDeregisterA
#define RouterLogEvent              RouterLogEventA
#define RouterLogError              RouterLogErrorA
#define RouterLogWarning            RouterLogWarningA
#define RouterLogInformation        RouterLogInformationA
#define RouterLogEventData          RouterLogEventDataA
#define RouterLogErrorData          RouterLogErrorDataA
#define RouterLogWarningData        RouterLogWarningDataA
#define RouterLogInformationData    RouterLogInformationDataA
#define RouterLogEventString        RouterLogEventStringA
#define RouterLogEventEx            RouterLogEventExA
#define RouterLogEventValistEx      RouterLogEventValistExA
#define RouterLogErrorString        RouterLogErrorStringA
#define RouterLogWarningString      RouterLogWarningStringA
#define RouterLogInformationString  RouterLogInformationStringA
#define RouterGetErrorString        RouterGetErrorStringA
#endif


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// WORKER THREAD POOL FUNCTIONS                                             //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// definition of worker function passed in QueueWorkItem API                //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

typedef VOID (APIENTRY * WORKERFUNCTION)(PVOID);


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//  Function: Queues the supplied work item in the work queue.              //
//                                                                          //
//  functionptr: function to be called must be of WORKERFUNCTION type       //
//  context:     opaque ptr                                                 //
//  serviceinalertablethread: if TRUE gets scheduled in                     //
//               a alertably waiting thread that never dies                 //
//  Returns:  0 (success)                                                   //
//            Win32 error codes for cases like out of memory                //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
APIENTRY
QueueWorkItem(
    IN WORKERFUNCTION functionptr,
    IN PVOID context,
    IN BOOL serviceinalertablethread
    );


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Function:        Associates file handle with the completion port (all    //
//                  asynchronous i/o on this handle will be queued to       //
//                    the completion port)                                    //
//                                                                          //
// FileHandle:        File handle to be associated with completion port       //
//                                                                          //
// CompletionProc:  Procedure to be called when io associated with the file //
//                    handle completes. This function will be executed in     //
//                    the context of non-alertable worker thread              //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
APIENTRY
SetIoCompletionProc (
    IN HANDLE                            FileHandle,
    IN LPOVERLAPPED_COMPLETION_ROUTINE    CompletionProc
    );



//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The following defines are included here as a hint on how the worker      //
// thread pool is managed:                                                  //
//                                                                          //
// There are NUM_ALERTABLE_THREADS permanent threads that never quit and    //
// wait alertably on a alertable worker queue.  These threads should solely //
// be used for work items that intiate asyncronous operation (file io,      //
// waitable timer) that ABSOLUTELY require APCs to complete (preferable     //
// method for IO is the usage of completio port API)                        //
//                                                                          //
// There is a pool of the threads that wait on completion port              //
// that used both for processing of IO and non-IO related work items        //
//                                                                          //
// The minimum number of threads is Number of processors                    //
// The maximum number of threads is MAX_WORKER_THREADS                      //
//                                                                          //
// A new thread is created if worker queue has not been served for more     //
// that WORK_QUEUE_TIMEOUT                                                  //
// The existing thread will be shut down if it is not used for more than    //
// THREAD_IDLE_TIMEOUT                                                      //
//                                                                          //
// Note that worker threads age guaranteed to be alive for at least         //
// THREAD_IDLE_TIMEOUT after the last work item is executed.  This timeout  //
// is chosen such that bulk of IO request could be completed before it      //
// expires.  If it is not enough for your case, use alertable thread with   //
// APC, or create your own thread.                                          //
//                                                                          //
// Note: changing these flags will not change anything.                     //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Number of alertable threads                                              //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define NUM_ALERTABLE_THREADS        2

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Max number of threads at any time                                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define MAX_WORKER_THREADS          10

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Time that the worker queue is not served before starting new thread      //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define WORK_QUEUE_TIMEOUT            1 //sec

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Time that thread has to be idle before exiting                           //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define THREAD_IDLE_TIMEOUT            10 //sec


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// ROUTER ASSERT DECLARATION                                                //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

VOID
RouterAssert(
    IN PSTR pszFailedAssertion,
    IN PSTR pszFileName,
    IN DWORD dwLineNumber,
    IN PSTR pszMessage OPTIONAL
    );


#if DBG
#define RTASSERT(exp) \
        if (!(exp)) \
            RouterAssert(#exp, __FILE__, __LINE__, NULL)
#define RTASSERTMSG(msg, exp) \
        if (!(exp)) \
            RouterAssert(#exp, __FILE__, __LINE__, msg)
#else
#define RTASSERT(exp)
#define RTASSERTMSG(msg, exp)
#endif

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// REGISTRY CONFIGURATION FUNCTIONS                                         //
//                                                                          //
// The following definitions are used to read configuration information     //
// about installed protocols.                                               //
//                                                                          //
// Call 'MprSetupProtocolEnum' to enumerate the routing-protocols           //
// for transport 'dwTransportId'. This fills an array with entries          //
// of type 'MPR_PROTOCOL_0'.                                                //
//                                                                          //
// The array loaded can be destroyed by calling 'MprSetupProtocolFree'.     //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define MAX_PROTOCOL_NAME_LEN                           40
#define MAX_PROTOCOL_DLL_LEN                            48

typedef struct _MPR_PROTOCOL_0 {

    DWORD       dwProtocolId;                           // e.g. IP_RIP
    WCHAR       wszProtocol[MAX_PROTOCOL_NAME_LEN+1];   // e.g. "IPRIP"
    WCHAR       wszDLLName[MAX_PROTOCOL_DLL_LEN+1];     // e.g. "iprip2.dll"

} MPR_PROTOCOL_0;


DWORD APIENTRY
MprSetupProtocolEnum(
    IN      DWORD                   dwTransportId,
    OUT     LPBYTE*                 lplpBuffer,         // MPR_PROTOCOL_0
    OUT     LPDWORD                 lpdwEntriesRead
    );


DWORD APIENTRY
MprSetupProtocolFree(
    IN      LPVOID                  lpBuffer
    );


//////////////////////////////////////////////////////////////////////////////
// Extensions to Rtutils to improve worker thread utilization.                //
//                                                                             //
//////////////////////////////////////////////////////////////////////////////

#define ROUTING_RESERVED
#define OPT1_1
#define OPT1_2
#define OPT2_1
#define OPT2_2
#define OPT3_1
#define OPT3_2


//
// When everyone is migrated to using Winsock2
//

#if 0


//==========================================================================================================//
//==========================================================================================================//

// ASYNC_SOCKET_DATA structure is used to pass / receive back data from an        //
// asynchronous wait recv from call                                                //

typedef struct _ASYNC_SOCKET_DATA {
            OVERLAPPED        Overlapped;            // reserved. not to be used
    IN        WSABUF            WsaBuf;                // WsaBuf.buf to be initialized to point to buffer
                                                // WsaBuf.len set to the length of the buffer
    OUT        SOCKADDR_IN        SrcAddress;            // AsyncWsaRecvFrom fills this with the source address of the packet
    OUT        DWORD            NumBytesReceived;    // AsyncWsaRecvFrom fills this with the number of bytes returned in the packet
    IN OUT    DWORD            Flags;                // Used to set flags for WSARecvFrom, and returns the flags set by WSARecvFrom
    OUT        DWORD            Status;                // status returned by IO Completion Port

    IN        WORKERFUNCTION    pFunction;            // Function to be executed on receiving packet
    IN        PVOID            pContext;            // context for the above function
} ASYNC_SOCKET_DATA, *PASYNC_SOCKET_DATA;



// AsyncSocketInit() binds the socket to the IOCompletionPort. This should be called//
// after the socket is created and before AsyncWsaRecvFrom() call is made            //
DWORD
APIENTRY
AsyncSocketInit (
    SOCKET    sock
    );


// This should be called only after the appropriate fields in SockData are initialized    //
// This sets up an asynchronous WSARecvFrom(), and on its return dispatches the         //
// function to a worker thread. It should be remembered that the function will run in     //
// a worker thread which might later on be deleted. So SetWaitableTimer() and             //
// asynchronous receive calls should be avoided unless you are sure that it would not be//
// a problem. It is adviced that if you want the function to run in an alertable thread,//
// then have the callback function queue a work item to alertable thread. Queue work     //
// items to alertable worker threads for SetWaitableTimer() and async receives.         //
// One must not make many AsyncWSArecvFrom() calls, as the buffer are non-paged            //
DWORD
APIENTRY
AsyncWSARecvFrom (
    SOCKET        sock,
    PASYNC_SOCKET_DATA    pSockData
    );

#endif // all winsock2 functions

//==========================================================================================================//
//==========================================================================================================//


// forward declarations
struct _WAIT_THREAD_ENTRY;
struct _WT_EVENT_ENTRY;


typedef struct _WT_TIMER_ENTRY {
    LONGLONG            te_Timeout;

    WORKERFUNCTION        te_Function;
    PVOID                te_Context;
    DWORD                te_ContextSz;
    BOOL                te_RunInServer;
    
    DWORD                te_Status;

    #define         TIMER_INACTIVE  3
    #define         TIMER_ACTIVE    4

    DWORD                te_ServerId;
    struct _WAIT_THREAD_ENTRY *teP_wte;    
    LIST_ENTRY            te_ServerLinks;
    
    LIST_ENTRY            te_Links;

    BOOL                te_Flag;        //todo: not used
    DWORD                te_TimerId;
} WT_TIMER_ENTRY, *PWT_TIMER_ENTRY;

    
typedef struct _WT_WORK_ITEM {
    WORKERFUNCTION      wi_Function;                // function to call
    PVOID               wi_Context;                    // context passed into function call
    DWORD                wi_ContextSz;                // size of context, used for allocating
    BOOL                wi_RunInServer;                // run in wait server thread or get queued to some worker thread

    struct _WT_EVENT_ENTRY    *wiP_ee;
    LIST_ENTRY        wi_ServerLinks;
    LIST_ENTRY      wi_Links;                      //todo not req    // link to next and prev element
} WT_WORK_ITEM, *PWT_WORK_ITEM;

#define WT_EVENT_BINDING     WT_WORK_ITEM
#define PWT_EVENT_BINDING     PWT_WORK_ITEM


//
// WT_EVENT_ENTRY
//
typedef struct _WT_EVENT_ENTRY {
    HANDLE            ee_Event;
    BOOL            ee_bManualReset;                            // is the event manually reset
    BOOL            ee_bInitialState;                        // is the initial state of the event active
    BOOL            ee_bDeleteEvent;                        // was the event created as part of createWaitEvent
    
    DWORD            ee_Status;                                // current status of the event entry
    BOOL            ee_bHighPriority;
    
    LIST_ENTRY        eeL_wi;
    
    BOOL            ee_bSignalSingle;                        // signal single function or multiple functions                        // how many functions to activate when event signalled (default:1)
    BOOL            ee_bOwnerSelf;                            // the owner if the client which create this event

    INT                ee_ArrayIndex;                            // index in the events array if active
    
    DWORD            ee_ServerId;                            // Id of server: used while deleting
    struct _WAIT_THREAD_ENTRY *eeP_wte;                        // pointer to wait thread entry
    LIST_ENTRY        ee_ServerLinks;                            // used by wait server thread
    LIST_ENTRY        ee_Links;                                // used by client

    DWORD            ee_RefCount;
    BOOL            ee_bFlag;        //todo: notused                                // reserved for use during deletion
    DWORD            ee_EventId;        //todo: remove it, being used only for testing/debugging    

} WT_EVENT_ENTRY, *PWT_EVENT_ENTRY;




// PROTOTYPES OF FUNCTIONS USED IN THIS FILE ONLY
//


// used by client to create a wait event
// context size should be 0 if you are passing a dword instead of a pointer
// if pEvent field is set, then lpName and security attributes are ignored
// if pFunction is NULL, then pContext, dwContextSz, and bRunInServerContext are ignored
PWT_EVENT_ENTRY
APIENTRY
CreateWaitEvent (
    //IN    PWT_EVENT_ENTRY    pEventEntry,                    // handle to event entry if initialized by others
    IN    HANDLE            pEvent                 OPT1_1,            // handle to event if already created

    IN    LPSECURITY_ATTRIBUTES lpEventAttributes OPT1_2,     // pointer to security attributes
    IN    BOOL            bManualReset,
    IN    BOOL            bInitialState,
    IN    LPCTSTR         lpName                 OPT1_2,         // pointer to event-object name

    IN  BOOL            bHighPriority,                        // create high priority event

    IN    WORKERFUNCTION     pFunction             OPT2_1,            // if null, means will be set by other clients
    IN    PVOID             pContext              OPT2_1,            // can be null
    IN  DWORD            dwContextSz            OPT2_1,            // size of context: used for allocating context to functions
    IN     BOOL            bRunInServerContext    OPT2_1            // run in server thread or get dispatched to worker thread
    );



//dwContextSz should be 0 if a dword is being passed. >0 only if pointer to block of that size is being passed.
PWT_EVENT_BINDING
APIENTRY
CreateWaitEventBinding (
    IN    PWT_EVENT_ENTRY    pee,
    IN     WORKERFUNCTION     pFunction,
    IN     PVOID            pContext,
    IN    DWORD            dwContextSz,
    IN    BOOL            bRunInServerContext
    );

    
PWT_TIMER_ENTRY
APIENTRY
CreateWaitTimer (
    IN    WORKERFUNCTION    pFunction,
    IN    PVOID            pContext,
    IN    DWORD            dwContextSz,
    IN    BOOL            bRunInServerContext
    );

DWORD
APIENTRY
DeRegisterWaitEventBindingSelf (
    IN    PWT_EVENT_BINDING    pwiWorkItem
    );

    
DWORD
APIENTRY
DeRegisterWaitEventBinding (
    IN    PWT_EVENT_BINDING    pwiWorkItem
    );


//all the events and timers should be registered with one waitThread server
//todo: change the above requirement
DWORD
APIENTRY
DeRegisterWaitEventsTimers (
    PLIST_ENTRY    pLEvents,    // list of events linked by ee_Links field
    PLIST_ENTRY pLTimers    // list of timers linked by te_Links field:
    //these lists can be a single list entry, or a multiple entry list with a list header entry.
    );

// this should be used only when called within a server thread
DWORD
APIENTRY
DeRegisterWaitEventsTimersSelf (
    IN    PLIST_ENTRY pLEvents,
    IN    PLIST_ENTRY    pLTimers
    );

    
DWORD
APIENTRY
RegisterWaitEventBinding (
    IN    PWT_EVENT_BINDING    pwiWorkItem
    );
    
// Register the client with the wait thread
DWORD
APIENTRY
RegisterWaitEventsTimers (
    IN    PLIST_ENTRY pLEventsToAdd,
    IN    PLIST_ENTRY    pLTimersToAdd
    );

DWORD
APIENTRY
UpdateWaitTimer (
    IN    PWT_TIMER_ENTRY    pte,
    IN    LONGLONG         *time
    );

VOID
APIENTRY
WTFree (
    PVOID ptr
    );


//used to free wait-event. Should be deallocated using DeRegisterWaitEventsTimers
//This function is to be used only when the events have not been registered
VOID
APIENTRY
WTFreeEvent (
    IN    PWT_EVENT_ENTRY    peeEvent
    );


//used to free wait-timer. Should be deallocated using DeRegisterWaitEventsTimers
//This function is to be used only when the timers have not been registered
VOID
APIENTRY
WTFreeTimer (
    IN PWT_TIMER_ENTRY pteTimer
    );

    
VOID
APIENTRY
DebugPrintWaitWorkerThreads (
    DWORD    dwDebugLevel
    );

#define DEBUGPRINT_FILTER_NONCLIENT_EVENTS    0x2
#define DEBUGPRINT_FILTER_EVENTS            0x4
#define DEBUGPRINT_FILTER_TIMERS            0x8


//
//ERROR VALUES
//
#define ERROR_WAIT_THREAD_UNAVAILABLE     1

#define ERROR_WT_EVENT_ALREADY_DELETED     2




#define TIMER_HIGH(time) \
    (((LARGE_INTEGER*)&time)->HighPart)

#define TIMER_LOW(time) \
    (((LARGE_INTEGER*)&time)->LowPart)


#ifdef __cplusplus
}
#endif

#endif // ___ROUTING_RTUTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\sadisplay.h ===
//
// Copyright (R) 1999-2000 Microsoft Corporation. All rights reserved.
//
// File Name: Sadisplay.h
//
// Author: Mukesh Karki
//
// Date: April 21, 1999
//
// Contents:
//   Definitions of data structures for WriteFile() structures 
//   used by the low-level local display drivers. 
//   This driver receives bitmaps and message codes 
//   from higher level code and writes them to the local display
//   hardware. Bitmaps are intended to be written to an LCD. 
//   Bit codes are intended to be used to light LED's or change 
//   icon states on an LCD.
//
#ifndef __SADISPLAY__
#define __SADISPLAY__

//
// Header files
//
// none

///////////////////////////////////////////////
// lpBuffer
//

#define MAXDISPLINES 2
#define MAXDISPCHAR  42
#define MAXBITMAP 2048 // can handle a 128x128 pixel display

typedef struct tagSABITMAP {  /* bm */
    int     bmWidth;        // width in pixels
    int     bmHeight;        // height in pixels = scans
    int     bmWidthBytes;    // bytes per scan in bmBits
    BYTE    bmBits[MAXBITMAP];
} SABITMAP; // See the BITMAP definition in MSDN


typedef struct _SADISPLAY_LP_BUFF {
    DWORD        version;    // each bit = version 
    DWORD        msgCode;    // each bit = message code
    union {
        SABITMAP    bitmap;
        CHAR        chars[MAXDISPLINES][MAXDISPCHAR]; // future use
        WCHAR       wChars[MAXDISPLINES][MAXDISPCHAR]; // future use
    } display;
} SADISPLAY_LP_BUFF, *PSADISPLAY_LP_BUFF;


// Default message codes
#define    READY           0x1    // OS is running normally
#define    SHUTTING_DOWN   0x2    // OS is shutting down
#define    NET_ERR         0x4    // LAN error
#define    HW_ERR          0x8    // general hardware error
#define    CHECK_DISK      0x10   // autochk.exe is running
#define    BACKUP_DISK     0x20   // disk backup in progress
#define NEW_TAPE        0x40   // new tape media required
#define NEW_DISK        0x80   // new disk media required
#define STARTING        0x100  // OS is booting
#define WAN_CONNECTED   0x200  // connected to ISP
#define WAN_ERR         0x400  // WAN error, e.g. no dial tone
#define DISK_ERR        0x800  // disk error, e.g. dirty bit set
#define ADD_START_TASKS 0x1000 // additional startup tasks running, 
                               // e.g. autochk, sw update
#define CRITICAL_ERR    0x2000 // LED will display info
#endif // __SADISPLAY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\restriction.h ===
//+----------------------------------------------------------------------------
//
// File:    Restriction.h     
//
// Module:     Server Appliance
//
// Synopsis: The interface to get restrictions
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:     fengsun Created    10/12/98
//
//+----------------------------------------------------------------------------

#ifndef _RESTRICTION_
#define _RESTRICTION_

#define RESTRICTION_NumberClientPC        L"NumberClientPC"
#define RESTRICTION_MaxRam               L"MaxRam"
#define RESTRICTION_NumberUser            L"NumberUser"
#define RESTRICTION_NumberDhcpAddressLease L"NumberDhcpAddressLease"
#define RESTRICTION_TotalDiskSpace        L"TotalDiskSpace"
#define RESTRICTION_EnableBackup            L"EnableBackup"
#define RESTRICTION_NumberNicCard         L"NumberNicCard"
#define RESTRICTION_NumberModemIsdn       L"NumberModemIsdn"
#define RESTRICTION_NumberParallelPort     L"NumberParallelPort"

const WCHAR* const arszName[] = 
            {
                    RESTRICTION_NumberClientPC,       // Core OS
                    RESTRICTION_MaxRam,              // Core OS
                    RESTRICTION_NumberUser,           // Security Service
                    RESTRICTION_NumberDhcpAddressLease,  // Simple Network Service
                    RESTRICTION_TotalDiskSpace,           // File Sharing
                    RESTRICTION_EnableBackup,           // Disk manager
                    RESTRICTION_NumberNicCard,        // Internet Gateway
                    RESTRICTION_NumberModemIsdn,      // Internet Gateway
                    RESTRICTION_NumberParallelPort,    // Printer Sharing
            };
    
const int NUM_RESTRICTIONS = sizeof(arszName) / sizeof(arszName[0]);

struct RESTRICTION_DATA
{
    DWORD dwReserved;
    DWORD dwSignature;
    DWORD dwNum;
    DWORD arData[NUM_RESTRICTIONS];
};

//
// Get the restriction value by name
//
HRESULT GetRestriction(IN const WCHAR* pszName, OUT DWORD* pdwValue);


//
// Functions used by setrestr.exe
//
HRESULT LoadRestrictionData(OUT RESTRICTION_DATA* pRestrictionData);
HRESULT SaveRestrictionData(OUT RESTRICTION_DATA* pRestrictionData);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\sadisplayioctl.h ===
//
// Copyright (R) 1999-2000 Microsoft Corporation. All rights reserved.
//
// File Name: SaDisplayIoctl.h
//
// Author: Mukesh Karki
//
// Contents:
//   Definitions of IOCTL codes and data structures for the low-
//   level local display driver. These IOCTL codes allow higher 
//   levels of software to determine the type and size of the 
//   local display hardware as well as the interface version 
//   supported.
//
#ifndef __SADISPLAY_IOCTL__
#define __SADISPLAY_IOCTL__

//
// Header files
//
// (None)

//
// IOCTL control codes
//

///////////////////////////////////////////////
// GET_VERSION of interface supported by this driver
//
#define IOCTL_SADISPLAY_GET_VERSION            \
    CTL_CODE( FILE_DEVICE_UNKNOWN, 0x801,    \
        METHOD_BUFFERED, FILE_ANY_ACCESS )

//
// Structures used by the IOCTL codes
//
#ifndef VERSION_INFO
#define VERSION_INFO
#define    VERSION1  0x1
#define    VERSION2  0x2 
#define VERSION3  0x4
#define VERSION4  0x8
#define VERSION5  0x10
#define VERSION6  0x20
#define    VERSION7  0x40
#define    VERSION8  0x80

#define THIS_VERSION VERSION2
#endif    //#ifndef VERSION_INFO


///////////////////////////////////////////////
// GET_TYPE
//
#define IOCTL_SADISPLAY_GET_TYPE            \
    CTL_CODE( FILE_DEVICE_UNKNOWN, 0x802,    \
        METHOD_BUFFERED, FILE_ANY_ACCESS )

//
// Structures used by the IOCTL code
//                         
typedef enum _SADISPLAY_TYPE_OUT_BUF {
    LED, 
    CHARACTER_LCD, // future use
    BIT_MAPPED_LCD 
} SADISPLAY_TYPE_OUT_BUF;

///////////////////////////////////////////////
// GET_LCD_SIZE
//
#define IOCTL_SADISPLAY_GET_LCD_SIZE        \
    CTL_CODE( FILE_DEVICE_UNKNOWN, 0x803,    \
        METHOD_BUFFERED, FILE_ANY_ACCESS )

//
// Structures used by the IOCTL code
//                         
typedef struct _SADISPLAY_LCD_SIZE_OUT_BUFF {
    ULONG    Height;    // pixels
    ULONG    Width;    // pixels
} SADISPLAY_LCD_SIZE_OUT_BUFF, *PSADISPLAY_LCD_SIZE_OUT_BUFF;

///////////////////////////////////////////////
// GET_CHAR_SIZE
// (Future use.)

#define IOCTL_SADISPLAY_GET_CHAR_SIZE        \
    CTL_CODE( FILE_DEVICE_UNKNOWN, 0x804,    \
        METHOD_BUFFERED, FILE_ANY_ACCESS )

//
// Structures used by the IOCTL code
//                         
typedef struct _SADISPLAY_CHAR_SIZE_OUT_BUFF {
    ULONG    lines;
    ULONG    chars_per_line;
} SADISPLAY_CHAR_SIZE_OUT_BUFF, *PSADISPLAY_CHAR_SIZE_OUT_BUFF;

///////////////////////////////////////////////
// GET_CHAR_TYPE
// (Future use.)

#define IOCTL_SADISPLAY_GET_CHAR_TYPE        \
    CTL_CODE( FILE_DEVICE_UNKNOWN, 0x805,    \
        METHOD_BUFFERED, FILE_ANY_ACCESS )

//
// Structures used by the IOCTL code
//                         

typedef enum _SADISPLAY_CHAR_OUT_BUF {
    CHAR_ASCII, 
    CHAR_UNICODE
} SADISPLAY_CHAR_OUT_BUF;

#endif // __SADISPLAY_IOCTL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\sadiskmanagerdefs.h ===
/*++--------------------------------------------------------------------------            
    File:       sadiskmanagerdefs.h

    Synopsis:   Public Disk Manager declarations 

    Copyright:  (C) 1999 Microsoft Corporation All rights reserved.

    Authors:    Abdul Nizar

    History:    Created 5-7-99 abduln
----------------------------------------------------------------------------*/

#ifndef __SADISKMANGERDEFS_H_
#define __SADISKMANGERDEFS_H_

//
// WBEM class representing a physical disk
//
static const PWCHAR DISK_CLASS_NAME =               L"Microsoft_SA_Disk";

//
// Properties of Microsoft_SA_Disk
//
static const PWCHAR DISK_PROPERTY_NAME =            L"DiskName";
static const PWCHAR DISK_PROPERTY_TYPE =            L"DiskType";
static const PWCHAR DISK_PROPERTY_STATUS =          L"DiskStatus";
static const PWCHAR DISK_PROPERTY_MIRRORSTATUS =    L"DiskMirrorStatus";
static const PWCHAR DISK_PROPERTY_DRIVEMASK =       L"DriveMask";
static const PWCHAR DISK_PROPERTY_SLOTNUMBER =      L"Slot";
static const PWCHAR DISK_PROPERTY_DISKSIZE   =      L"DiskSize";
static const PWCHAR DISK_PROPERTY_BACKUPDATAMASK =  L"BackupDataMask";
//
// WBEM class representing the Disk Manager
//
static const PWCHAR DISKMANAGER_CLASS_NAME =    L"Microsoft_SA_DiskManager";

//
// Methods of Microsoft_SA_DiskManager
//

static const PWCHAR DISKMANAGER_METHOD_DISKCONFIGURE =      L"DiskConfigure";

static const PWCHAR DISKCONFIGURE_PARAMETER_FORMATSLOTS =   L"FormatSlots";
static const PWCHAR DISKCONFIGURE_PARAMETER_RECOVERSLOTS =  L"RecoverSlots";
static const PWCHAR DISKCONFIGURE_PARAMETER_DELETESLOTS =   L"DeleteShadowSlots";
static const PWCHAR DISKCONFIGURE_PARAMETER_MIRRORSLOTS =   L"MirrorSlots";

static const PWCHAR DISKMANAGER_METHOD_CANRECOVER =         L"CanRecover";

static const PWCHAR CANRECOVER_PARAMETER_RECOVERSLOT =      L"RecoverSlot";

static const PWCHAR DISKMANAGER_METHOD_CANMIRROR =          L"CanMirror";

static const PWCHAR CANMIRROR_PARAMETER_MIRRORSLOTS =       L"MirrorSlots";


//
// Special property identifying return value of methods
//
static const PWCHAR METHOD_PARAMETER_RETURNVALUE =          L"ReturnValue";
static const PWCHAR METHOD_PARAMETER_REBOOT =               L"Reboot";
static const PWCHAR METHOD_PARAMETER_REQUIREDSIZE =         L"RequiredSize";

//
// Disk Manager configuration registry key elements
//
static const PWCHAR DISK_MANAGER_KEY =              L"SOFTWARE\\Microsoft\\ServerAppliance\\ApplianceManager\\ObjectManagers\\Microsoft_SA_Service\\Disk Manager";
static const PWCHAR DISK_MANAGER_CONFIG_KEY =       L"Configuration";
static const PWCHAR DISK_MANAGER_PORT_KEY =         L"Scsi Port %d";
static const PWCHAR DISK_MANAGER_PATH_KEY =         L"Scsi Bus %d";
static const PWCHAR DISK_MANAGER_TARGET_KEY =       L"Target Id %d";
static const PWCHAR DISK_MANAGER_LUN_KEY =          L"Logical Unit Id %d";

static const PWCHAR DISK_TYPE_VALUE_NAME =          DISK_PROPERTY_TYPE; 

//
// WBEM event signalling a change in disk configuration
//
static const PWCHAR DISK_EVENT_NAME =               L"Microsoft_SA_DiskEvent";


///////////////////////////////////////////////////////////////////////////////
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11
// 
// gGUID handling ...
//
// byao        7/15/1999
//
////////////////////////////////////////////////////////////////////////////////
static const PWCHAR DISK_MANAGER_VALUE_FIRST_BOOT =    L"FirstTime";

#endif // __SADISKMANGERDEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\sakeypadioctl.h ===
//
// Copyright (R) 1999-2000 Microsoft Corporation. All rights reserved.
//
// File Name:
//        SaKeypadIoctl.h
//
// Contents:
//        Definitions of IOCTL codes and data
//        structures exported by SAKEYPADDRIVER.
//
#ifndef __SAKEYPAD_IOCTL__
#define __SAKEYPAD_IOCTL__

//
// Header files
//
// (None)

//
// IOCTL control codes
//

///////////////////////////////////////////////
// GET_VERSION
//
#define IOCTL_SAKEYPAD_GET_VERSION            \
    CTL_CODE( FILE_DEVICE_UNKNOWN, 0x801,    \
        METHOD_BUFFERED, FILE_ANY_ACCESS )

//
// Structures used by the IOCTL codes
//
#ifndef VERSION_INFO
#define VERSION_INFO
#define    VERSION1  1
#define    VERSION2  2 
#define VERSION3  4
#define VERSION4  8
#define VERSION5  16
#define VERSION6  32
#define    VESRION7  64
#define    VESRION8  128

#define THIS_VERSION VERSION2
#endif    //#ifndef VERSION_INFO 

#endif // __SAKEYPAD_IOCTL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\sakeypad.h ===
//
// Copyright 1999 Microsoft Corporation.  All Rights Reserved.
//
// File Name: sakeypad.h
//
// Author: Mukesh Karki
//
// Date: April 21, 1999
//
// Contents:
//        Definitions of data structures for ReadFileEx()
//        structures exported by SAKEYPADDRIVER.
//
#ifndef __SAKEYPAD__
#define __SAKEYPAD__

//
// Header files
//
// none

//
// data structures
//

///////////////////////////////////////////////
// lpBuffer
//


typedef struct _SAKEYPAD_LP_BUFF {
    DWORD        version;    // each bit = version 
    DWORD        KeyID;        // each bit = KeyID
} SAKEYPAD_LP_BUFF, *PSAKEYPAD_LP_BUFF;


//replacing with new ones, see below
// default key codes
//#define    UP        1
//#define    DOWN    2
//#define    RIGHT    4
//#define    LEFT    8




// default key codes
//#define    UP        1
//#define    DOWN    2
//#define    CANCEL    4
//#define    SELECT    8
//#define    RIGHT    16
//#define    LEFT    32

//
// Redefine the key codes, 2/1/2001.
//
#define    UP        1
#define    DOWN    2
#define    LEFT    4
#define    RIGHT    8
#define    CANCEL    16
#define    SELECT    32

#endif // __SAKEYPAD__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\saping.h ===
#ifndef _SA_PING_H_
#define _SA_PING_H_

#include "windows.h"

BOOL PingHost(char* szHostName);
BOOL PingHostOnIntranet(char* szHostName);
BOOL IsAutoDialEnabled(void);
BOOL EnableAutoDial( BOOL fEnable);

#endif  _SA_PING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\saeventcomm.h ===
// **************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
// File:  SAEventComm.H
//
// Description:
//       Server appliance event provider common define - header file defines 
// event provider common define
//
// History:
//         12/1/2000, initial version by lustar.Li
// **************************************************************************

#ifndef __SAEVENTCOMM_H_
#define __SAEVENTCOMM_H_

//
// Define the Event structure
//
typedef struct __SARESOURCEEVNET{
    WCHAR UniqueName[16];        //Appliance resource name being monitored
    UINT DisplayInformationID;    //ID for the string or graphic resource value
    UINT CurrentState;            //Current state - must be 0
}SARESOURCEEVNET, *PSARESOURCEEVNET;

#define SA_RESOURCEEVENT_CLASSNAME            L"Microsoft_SA_ResourceEvent"

#define SA_RESOURCEEVENT_UNIQUENAME            L"UniqueName"
#define SA_RESOURCEEVENT_DISPLAYINFORMATION    L"DisplayInformationID"
#define SA_RESOURCEEVENT_CURRENTSTATE        L"CurrentState"

#define SA_RESOURCEEVENT_DEFAULT_CURRENTSTATE    0x00000000

//
// Define the const for Net event provider
//

// Describe the event source
#define SA_NET_EVENT                    (L"NetEvent")

// Describe the message code for network
#define SA_NET_STATUS_RECIVE_DATA        0x00000001
#define SA_NET_STATUS_SEND_DATA            0x00000002
#define SA_NET_STATUS_NO_CABLE            0x00000004

// Define the display Information ID
#define SA_NET_DISPLAY_IDLE                0x00000001
#define SA_NET_DISPLAY_TRANSMITING        0x00000002
#define SA_NET_DISPLAY_NO_CABLE            0x00000003

//
// Define the const for Disk event provider
//
#define SA_DISK_EVENT                    (L"DiskEvent")

// Describe the message code for hard disk
#define SA_DISK_STATUS_RECIVE_DATA        0x00000001
#define SA_DISK_STATUS_SEND_DATA        0x00000002

// Define the display Information ID for hard disk
#define SA_DISK_DISPLAY_IDLE            0x00000001
#define SA_DISK_DISPLAY_TRANSMITING        0x00000002

#endif    //#ifndef __SAEVENTCOMM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\saverp.h ===
#include <windows.h>
#include <winver.h>
#include <ntverp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\samsnvramioctl.h ===
//
// Copyright (R) 1999-2000 Microsoft Corporation. All rights reserved.
//
// PURPOSE:
//  File contains declarations for the Non-Volatile RAM Driver
//  for the Windows-based Server Appliance.
//
//  This driver reads and writes to non-volatile RAM provided to
//  the OS by the OEM hardware. It also provides for the OEM to
//  indicate to the OS that power has cycled since the last boot
//  attempt that succeeded, from the BIOS perspective.
//
//  File Name:  SaMSNVRamIoctl.h
//  Originally: SaNVRamIoctl.h
//
#ifndef __SAMSNVRAM_IOCTL__
#define __SAMSNVRAM_IOCTL__


//
// Device Names
//
    // System Registered device name
#define PDEVICENAME_SANVRAM  (L"\\Device\\SANVRAM")

    // Device Symbolic name
#define PDEVSYMBOLICNAME_SANVRAM  (L"\\??\\SANVRAM1")

    // Device symbolic name as used in CreateFile
#define PDEVFILENAME_SANVRAM  (L"\\\\.\\SANVRAM1")

//
// IOCTL control codes
//

///////////////////////////////////////////////
// GET_VERSION
//
#define IOCTL_SANVRAM_GET_VERSION\
        CTL_CODE( FILE_DEVICE_UNKNOWN, 0xD01,\
                METHOD_BUFFERED, FILE_ANY_ACCESS )

//
// Structures used by the IOCTL codes
//
typedef struct _SANVRAM_GET_VER_OUT_BUFF {
        DWORD   Version;
} SANVRAM_GET_VER_OUT_BUFF, *PSANVRAM_GET_VER_OUT_BUFF;

//
// version bits
//
#ifndef VERSION_INFO
#define VERSION_INFO
#define VERSION1  0x1
#define VERSION2  0x2
#define VERSION3  0x4
#define VERSION4  0x8
#define VERSION5  0x10
#define VERSION6  0x20
#define VESRION7  0x40
#define VESRION8  0x80

#define THIS_VERSION VERSION2
#endif    //#ifndef VERSION_INFO


///////////////////////////////////////////////
// GET_CAPABILTIES
// Returns a DWORD with bits indicating capabilities.

#define IOCTL_SANVRAM_GET_CAPABILITIES\
        CTL_CODE( FILE_DEVICE_UNKNOWN, 0xD02,\
                METHOD_BUFFERED, FILE_ANY_ACCESS )
//
// Structures used by the IOCTL codes
//
typedef struct _SANVRAM_GET_CAPS_OUT_BUFF {
    DWORD   Version;
    DWORD   Capability;
}  SANVRAM_GET_CAPS_OUT_BUFF, *PSANVRAM_GET_CAPS_OUT_BUFF;


/////////////////////////////////////////////////////////////////////////////
// Semantics of the fields of the SANVRAM_GET_CAPS_OUT_BUFF structure.
//
// Version: Must have exactly one bit set, and must be one of the bits
//          set in the Version field on a prior return from the IOCTL
//          IOCTL_SANVRAM_GET_VERSION. The driver is required to
//          support the VERSION1 interface defined in this header.
//          At this time no other version is defined.
//
// Capability bits: Indicates that this driver supports the non-volatile RAM
//                  interface and that this driver supports the knowledge of
//                  whether the power has cycled since the last boot up. See
//                  the semantics for the relevant bits in the IOCTL_SANVRAM
//                  call below.
//
#define NON_VOLATILE_RAM    0x01 // set if driver supports non-volatile RAM
#define POWER_CYCLE_INFO    0x02 // set if driver supports power cycle info



///////////////////////////////////////////////
// IOCTL_SANVRAM
// Returns the input structure with actions taken
// as described in the discussion below. The input
// and output are identical in size and structure.
//
#define IOCTL_SANVRAM\
        CTL_CODE( FILE_DEVICE_UNKNOWN, 0xD03,\
                METHOD_BUFFERED, FILE_ANY_ACCESS )

//
// Structures used by this IOCTL code,
//
typedef struct _SANVRAM__BUFF {
    IN     DWORD  Version;      // version of interface used
    IN     DWORD  FlagsControl; // bit field indicating desired actions
    OUT    DWORD  FlagsInfo;    // bit field indicating state
    IN OUT DWORD  FirstDWORD;   // First uninterpreted DWORD: non-volatile RAM
    IN OUT DWORD  SecondDWORD;  // Second uninterpreted DWORD: non-volatile RAM
} SANVRAM__BUFF, *PSANVRAM__BUFF;


/////////////////////////////////////////////////////////////////////////////
// Semantics of the fields of the SANVRAM_BUFF structure.
//
// Version: Must have exactly one bit set, and must be one of the bits
//          set in the Version field on a prior return from the IOCTL
//          IOCTL_SANVRAM_GET_VERSION. The driver is required to
//          support the VERSION1 interface defined in this header.
//          At this time no other version is defined.

// FlagsControl: Flags indicating the desired actions. The two DWORD values
//               may be set, read, or both set and read. Setting the values
//               in a single call must precede reading them. Requested
//               reads and writes must take place directly to and from the
//               non-volatile media. (Thus if a standard C optimizer is used
//               with the compiler, and both a write and a read are requested,
//               then optimizations should be turned off for these actions,
//               perhaps by using the "volatile" key word.) The two DWORD
//               values are independently controlled. There are two bits
//               for the first DWORD and two for the second.
//
//               NOTE:: Writing to the media
//               dedicated to the two non-volatile DWORDS MUST occur WHEN
//               and ONLY when commanded by these bits. This requirement
//               must be globally honored in time and space, through
//               failures, disk changes, etc.
//
#define FirstDWORD_WRITE      (0x01) // set if first DWORD is to be written
#define SecondDWORD_WRITE     (0x02) // set if second DWORD is to be written
#define FirstDWORD_READ       (0x04) // set if first DWORD is to be read
#define SecondDWORD_READ      (0x08) // set if second DWORD is to be read
#define REQUEST_ALTERNATE_OS  (0x10) // set if alternate OS is to be requested
#define NOTIFY_SYSTEM_FAILURE (0x20) // set to notify that alternate OS failed 
#define INDICATE_LAST_CALL    (0x40) // set to notify that this is last call before shutdown or reboot
//
// FlagsInfo: Bit field for output flags: Flag indicates whether the power
//            has cycled between the current boot of an operating system on
//            this machine and the last.  It indicates that this is the
//            first boot of an operating system since power had been off.
//            This bit has no significance if the capability to give this
//            information has not been declared with the POWER_CYCLE_INFO
//            bit. If the power cycle capability is provided, then this bit is
//            set on ALL boot attempts subsequent to a power cycle until a
//            boot succeedes sufficiently that the OS sets the BIOS boot
//            counter to zero. Stated differently we have that, after a
//            power cycle, the POWER_CYCLED bit will be set on all calls
//            to this function, until a boot attempt is under way that is
//            subsequent to a boot in which the OS made a call with the bit
//            RESET_BIOS_BOOT_COUNT set.
//
//            The behavior is given in the following matrix where pre-reset is
//            prior to a call to the NVRAM driver indicating to reset the bit,
//            and post-reset is after such a call.
//            In the matrix a non-PCB is a boot that was not occasioned
//            by the power coming up ( a non Power Cycle Boot). The running state
//            of the system is characterized here by whether the immediately 
//            preceding boot was occasioned by a power up, and whether, according
//            to the matrix, the power cycle bit was set prior to the boot. Note 
//            that semantically "power cycle boot" includes all boots (CPU resets)
//            that are occasioned by direct user actions. On most server appliances
//            this is covered by power cycles. However, if the user has some other
//            means to request a reboot of the box, e.g., a reset switch, then that
//            action is included in the status of a "power cycle boot." On such a 
//            hardware platform it is perhaps more accurate to call this a 
//            "user action" boot, and add that as a set it includes all power 
//            cycles.
//
//           | Power Cycle Bit Set Before Boot | Power Cycle Bit Clear Before Boot |
//           -----------------------------------------------------------------------
//           | Power Cycle Boot | non-PCB      | Power Cycle Boot | non-PCB        |
//           -----------------------------------------------------------------------
// pre-reset |   Set            |  Set         |      Set         |    Clear       |
// ---------------------------------------------------------------------------------
// post-reset|   Clear          |  Clear       |      Clear       |    Clear       |
// ---------------------------------------------------------------------------------
//
#define POWER_CYCLED            0x01 // set if power has cycled,

//
// FirstDWORD:
// SecondDWORD:
//      These values are simply stored and retrieved, they are not interpreted
//      at this level.
//      They must be stored in
//      non-volatile storage and will be written on boots, updates of the OS,
//      and shutdowns. They will therefore be written sufficiently infrequently
//      that slow non-volatile RAM technologies, such as Flash ROM, can be
//      suitable from a performance perspective. The lifetime of a particular
//      technology in write-cycles must be considered relative to the intended
//      design life between service or perhaps the total design life of the
//      particular server appliance.
//
//////////////////////////////////////////////////////////////////////////////



#endif // __SAMSNVRAM_IOCTL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\sasvc.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    SASVC.H

Abstract:

    Header file for Server Appliance service loader

Author:

    Baogang Yao (byao)   2-3-99

Revision History:

--*/

#ifndef _SASVC_INCLUDE_
#define _SASVC_INCLUDE_

//
// Service DLLs loaded into sasvrldr.exe all export the same main
// entry point.  SASVCS_ENTRY_POINT defines that name.
//
// Note that SASVCS_ENTRY_POINT_STRING is always ANSI, because that's
// what GetProcAddress takes.
//
#define SASVCS_ENTRY_POINT         ServiceEntry
#define SASVCS_ENTRY_POINT_STRING  "ServiceEntry"

//
// Structure containing "global" data for the various DLLs.
//
typedef struct _SASVCS_GLOBAL_DATA 
{
    // global data items -- to be defined
    LPTSTR pszSvcName;

} SASVCS_GLOBAL_DATA, *PSASVCS_GLOBAL_DATA;


//
// Service DLL entry point prototype.
//
typedef
VOID
(*PSASVCS_SERVICE_DLL_ENTRY) (
    IN DWORD argc,
    IN LPTSTR argv[],
    IN PSASVCS_GLOBAL_DATA pGlobalData
    );

#endif    // _SASVC_INCLUDE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\satrace.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    satrace.h
//
// SYNOPSIS
//
//    Declares the API into the SA trace facility.
//
// MODIFICATION HISTORY
//
//    08/18/1998    Original version.
//    10/06/1998    Trace is always on.
//    01/27/1999    Stolen from IAS
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _SATRACE_H_
#define _SATRACE_H_


#ifdef __cplusplus
extern "C" {
#endif

DWORD
WINAPI
SAFormatSysErr(
    IN DWORD dwError,
    IN PSTR lpBuffer,
    IN DWORD nSize
    );

VOID
WINAPIV
SATracePrintf(
    IN PCSTR szFormat,
    ...
    );

VOID
WINAPI
SATraceString(
    IN PCSTR szString
    );

VOID
WINAPI
SATraceBinary(
    IN CONST BYTE* lpbBytes,
    IN DWORD dwByteCount
    );

VOID
WINAPI
SATraceFailure(
    IN PCSTR szFunction,
    IN DWORD dwError
    );

#ifdef __cplusplus
}
#endif


#ifdef __cplusplus

const DWORD MAX_TRACEFUNCTION_NAMELENGTH =  512;

// C++ only!
class CSATraceFunc
{
public:
    CSATraceFunc(PCSTR pszFuncName)
    {
        strncpy(m_szFuncName, pszFuncName, MAX_TRACEFUNCTION_NAMELENGTH);
        m_szFuncName[MAX_TRACEFUNCTION_NAMELENGTH] = '\0';
        SATracePrintf("Enter %s", m_szFuncName);
    }

    ~CSATraceFunc()
    {
        SATracePrintf("Leave %s", m_szFuncName);
    }
private:
    CHAR m_szFuncName[MAX_TRACEFUNCTION_NAMELENGTH +1];  // maximum function name: 512
};

//
// use SATraceFunc() in the beginning of a function to generate
// "entering Func..." and "Leaving Func..." trace message
//
#define SATraceFunction(szFuncName) \
             CSATraceFunc temp_TraceFunc(szFuncName)

#endif  // __cplusplus

#endif  // _SATRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\sawatchdogioctl.h ===
// 
// Copyright (R) 1999-2000 Microsoft Corporation. All rights reserved.
// 
// PURPOSE: 
//  File contains declarations for the Watchdog Timer Driver
//  for the Windows-based Server Appliance. 
//
//  This driver reads and writes to the underlying watchdog timer
//  hardware. It receives pings from higher level software and 
//  then resets the hardware counter to keep the machine from 
//  being re-booted when the counter rolls over.
//
// File Name: SaWatchdogIoctl.h
// Contents:
//
//  Definitions of IOCTL codes and data
//  structures exported by SAWATCHDOGDRIVER.
//
#ifndef __SAWATCHDOG_IOCTL__
#define __SAWATCHDOG_IOCTL__

//
// Header files
//
// (None)

//
// IOCTL control codes
//

///////////////////////////////////////////////
// GET_VERSION
//
#define IOCTL_SAWATCHDOG_GET_VERSION            \
    CTL_CODE( FILE_DEVICE_UNKNOWN, 0x801,    \
        METHOD_BUFFERED, FILE_ANY_ACCESS )

//
// Structures used by the IOCTL codes
//
typedef struct _SAWD_GET_VER_OUT_BUFF {
    DWORD    Version;
} SAWD_GET_VER_OUT_BUFF, *PSAWD_GET_VER_OUT_BUFF;

//
// version bits
//
#ifndef VERSION_INFO
#define VERSION_INFO
#define    VERSION1  0x1
#define    VERSION2  0x2 
#define VERSION3  0x4
#define VERSION4  0x8
#define VERSION5  0x10
#define VERSION6  0x20
#define    VESRION7  0x40
#define    VESRION8  0x80

#define THIS_VERSION VERSION2
#endif    //#ifndef VERSION_INFO

///////////////////////////////////////////////
// GET_CAPABILTY
// Returns a DWORD with bits indicating capabilities.

#define IOCTL_SAWD_GET_CAPABILITY        \
    CTL_CODE( FILE_DEVICE_UNKNOWN, 0x802,    \
        METHOD_BUFFERED, FILE_ANY_ACCESS )

//
// Structures used by this IOCTL code
//
typedef struct _SAWD_CAPABILITY_OUT_BUFF {
    DWORD   Version;    // version of interface used
    DWORD    Capability; // bit field indicating capabilities
    DWORD    min;        // minimum value in msecs
    DWORD    max;        // maximum value in msecs
} SAWD_CAPABILITY_OUT_BUFF, *PSAWD_CAPABILITY_OUT_BUFF;

//
// capability bit masks
//
#define    DISABLABLE        0x1    // Can watchdog timer be disabled/enabled?
#define SHUTDOWNABLE    0x2    // Can watchdog shutdown computer?

/////////////////////////////////////////////////////////////////////
// Write structure to the Watchdog Timer ( in particular, to "ping" it )
//
//  Pinging is a simple write to the device. All output information
//  required is obtained in the status returned. 
//
//  Low level device implementers are encouraged, where performance
//  would benefit, to keep the last value of Holdoff and results of any
//  calculations based upon it in the device extension. The value of 
//  Holdoff will typically be unchanged from one call to the next.
//
typedef struct _SAWD_PING {
    DWORD       Version;    // version of interface used
    DWORD       Flags;      // flags defined below
    DWORD       Holdoff;    // number of milliseconds to delay firing.
    } SAWD_PING , *PSAWD_PING;

    // writing to the timer with the DISABLE_WD cleared enables the timer.
    // If DISABLE_WD is set, then the timer is disabled.
#define DISABLE_WD   0x01
    //writing to the timer with SHUTDOWN_WD will shutdown computer.
    //If SHUTDOWN_WD is set, after Holdoff milliseconds, computer will be
    //shutdowned
#define SHUTDOWN_WD     0x02

    // undefined bits of Flags field are reserved and must be zero
    // STATUS_INVALID_PARAMETER is returned if reserved bits are not 0.

#endif // __SAWATCHDOG_IOCTL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\servicedirectory.h ===
class CServiceItem
{
public:
    CServiceItem();
    void GetClsid(CLSID& clsid) const;
    HRESULT Load(const WCHAR* pszClsid);
    BOOL ShallStartByFrameWork();
    BOOL SupportsSecurityInterface();

protected:
    CLSID m_clsid;
    DWORD  m_fStartByFrameWork;
    DWORD  m_fSupportsSecurityInterface;
};

class CServiceDirectory
{
public:
    CServiceDirectory();
    ~CServiceDirectory();
    void Reset();
    BOOL GetNext(CServiceItem& service);
protected:
    DWORD m_dwIndex;
    HKEY m_hKeyDirectory;

};

inline CServiceItem::CServiceItem()
{
    ZeroMemory(&m_clsid, sizeof(m_clsid));
}

inline void CServiceItem::GetClsid(CLSID& clsid) const
{
    clsid = m_clsid;
}

inline BOOL CServiceItem::ShallStartByFrameWork()
{
    return m_fStartByFrameWork;
}

inline BOOL CServiceItem::SupportsSecurityInterface()
{
    return m_fSupportsSecurityInterface;
}


inline CServiceDirectory::CServiceDirectory() : m_dwIndex(0), m_hKeyDirectory(NULL){};
inline CServiceDirectory::~CServiceDirectory()
{
    if (m_hKeyDirectory)
    {
        RegCloseKey(m_hKeyDirectory);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\shortcutresource.h ===
#define     IDS_SAK_SHORTCUT_NAME                 9001
#define     IDS_SAK_SHORTCUT_DESCRIPTION          9002
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\ssdp.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for ssdp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __ssdp_h__
#define __ssdp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "wtypes.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __ssdpsrv_INTERFACE_DEFINED__
#define __ssdpsrv_INTERFACE_DEFINED__

/* interface ssdpsrv */
/* [auto_handle][unique][version][uuid] */ 

#define SSDP_SERVICE_PERSISTENT 0x00000001
#define NUM_OF_HEADERS 19
#define NUM_OF_METHODS 4
typedef 
enum _NOTIFY_TYPE
    {    NOTIFY_ALIVE    = 0,
    NOTIFY_PROP_CHANGE    = NOTIFY_ALIVE + 1
    }     NOTIFY_TYPE;

typedef 
enum _SSDP_METHOD
    {    SSDP_NOTIFY    = 0,
    SSDP_M_SEARCH    = 1,
    GENA_SUBSCRIBE    = 2,
    GENA_UNSUBSCRIBE    = 3,
    SSDP_INVALID    = 4
    }     SSDP_METHOD;

typedef enum _SSDP_METHOD *PSSDP_METHOD;

typedef 
enum _SSDP_HEADER
    {    SSDP_HOST    = 0,
    SSDP_NT    = SSDP_HOST + 1,
    SSDP_NTS    = SSDP_NT + 1,
    SSDP_ST    = SSDP_NTS + 1,
    SSDP_MAN    = SSDP_ST + 1,
    SSDP_MX    = SSDP_MAN + 1,
    SSDP_LOCATION    = SSDP_MX + 1,
    SSDP_AL    = SSDP_LOCATION + 1,
    SSDP_USN    = SSDP_AL + 1,
    SSDP_CACHECONTROL    = SSDP_USN + 1,
    GENA_CALLBACK    = SSDP_CACHECONTROL + 1,
    GENA_TIMEOUT    = GENA_CALLBACK + 1,
    GENA_SCOPE    = GENA_TIMEOUT + 1,
    GENA_SID    = GENA_SCOPE + 1,
    GENA_SEQ    = GENA_SID + 1,
    CONTENT_LENGTH    = GENA_SEQ + 1,
    CONTENT_TYPE    = CONTENT_LENGTH + 1,
    SSDP_SERVER    = CONTENT_TYPE + 1,
    SSDP_EXT    = SSDP_SERVER + 1
    }     SSDP_HEADER;

typedef enum _SSDP_HEADER *PSSDP_HEADER;

typedef /* [string] */ LPSTR MIDL_SZ;

typedef struct _SSDP_REQUEST
    {
    SSDP_METHOD Method;
    /* [string] */ LPSTR RequestUri;
    MIDL_SZ Headers[ 19 ];
    /* [string] */ LPSTR ContentType;
    /* [string] */ LPSTR Content;
    GUID guidInterface;
    }     SSDP_REQUEST;

typedef struct _SSDP_REQUEST *PSSDP_REQUEST;

typedef struct _SSDP_MESSAGE
    {
    /* [string] */ LPSTR szType;
    /* [string] */ LPSTR szLocHeader;
    /* [string] */ LPSTR szAltHeaders;
    /* [string] */ LPSTR szUSN;
    /* [string] */ LPSTR szSid;
    DWORD iSeq;
    UINT iLifeTime;
    /* [string] */ LPSTR szContent;
    }     SSDP_MESSAGE;

typedef struct _SSDP_MESSAGE *PSSDP_MESSAGE;

typedef struct _SSDP_REGISTER_INFO
    {
    /* [string] */ LPSTR szSid;
    DWORD csecTimeout;
    }     SSDP_REGISTER_INFO;

typedef struct _MessageList
    {
    long size;
    /* [size_is] */ SSDP_REQUEST *list;
    }     MessageList;

typedef 
enum _UPNP_PROPERTY_FLAG
    {    UPF_NON_EVENTED    = 0x1
    }     UPNP_PROPERTY_FLAG;

typedef struct _UPNP_PROPERTY
    {
    /* [string] */ LPSTR szName;
    DWORD dwFlags;
    /* [string] */ LPSTR szValue;
    }     UPNP_PROPERTY;

typedef struct _SUBSCRIBER_INFO
    {
    /* [string] */ LPSTR szDestUrl;
    FILETIME ftTimeout;
    DWORD csecTimeout;
    DWORD iSeq;
    /* [string] */ LPSTR szSid;
    }     SUBSCRIBER_INFO;

typedef struct _EVTSRC_INFO
    {
    DWORD cSubs;
    /* [size_is] */ SUBSCRIBER_INFO *rgSubs;
    }     EVTSRC_INFO;

typedef /* [context_handle] */ void *PCONTEXT_HANDLE_TYPE;

typedef /* [context_handle] */ void *PSYNC_HANDLE_TYPE;

/* client prototype */
int RegisterServiceRpc( 
    /* [out] */ PCONTEXT_HANDLE_TYPE *pphContext,
    /* [in] */ SSDP_MESSAGE svc,
    /* [in] */ DWORD flags);
/* server prototype */
int _RegisterServiceRpc( 
    /* [out] */ PCONTEXT_HANDLE_TYPE *pphContext,
    /* [in] */ SSDP_MESSAGE svc,
    /* [in] */ DWORD flags);

/* client prototype */
int DeregisterServiceRpcByUSN( 
    /* [string][in] */ LPSTR szUSN,
    /* [in] */ BOOL fByebye);
/* server prototype */
int _DeregisterServiceRpcByUSN( 
    /* [string][in] */ LPSTR szUSN,
    /* [in] */ BOOL fByebye);

/* client prototype */
int DeregisterServiceRpc( 
    /* [out][in] */ PCONTEXT_HANDLE_TYPE *pphContext,
    /* [in] */ BOOL fByebye);
/* server prototype */
int _DeregisterServiceRpc( 
    /* [out][in] */ PCONTEXT_HANDLE_TYPE *pphContext,
    /* [in] */ BOOL fByebye);

/* client prototype */
void UpdateCacheRpc( 
    /* [unique][in] */ PSSDP_REQUEST SsdpRequest);
/* server prototype */
void _UpdateCacheRpc( 
    /* [unique][in] */ PSSDP_REQUEST SsdpRequest);

/* client prototype */
int LookupCacheRpc( 
    /* [string][in] */ LPSTR szType,
    /* [out] */ MessageList **svcList);
/* server prototype */
int _LookupCacheRpc( 
    /* [string][in] */ LPSTR szType,
    /* [out] */ MessageList **svcList);

/* client prototype */
void CleanupCacheRpc( void);
/* server prototype */
void _CleanupCacheRpc( void);

/* client prototype */
int InitializeSyncHandle( 
    /* [out] */ PSYNC_HANDLE_TYPE *pphContextSync);
/* server prototype */
int _InitializeSyncHandle( 
    /* [out] */ PSYNC_HANDLE_TYPE *pphContextSync);

/* client prototype */
void RemoveSyncHandle( 
    /* [out][in] */ PSYNC_HANDLE_TYPE *pphContextSync);
/* server prototype */
void _RemoveSyncHandle( 
    /* [out][in] */ PSYNC_HANDLE_TYPE *pphContextSync);

/* client prototype */
int RegisterNotificationRpc( 
    /* [out] */ PCONTEXT_HANDLE_TYPE *pphContext,
    /* [in] */ PSYNC_HANDLE_TYPE phContextSync,
    /* [in] */ NOTIFY_TYPE nt,
    /* [string][unique][in] */ LPSTR szType,
    /* [string][unique][in] */ LPSTR szEventUrl,
    /* [out] */ SSDP_REGISTER_INFO **ppinfo);
/* server prototype */
int _RegisterNotificationRpc( 
    /* [out] */ PCONTEXT_HANDLE_TYPE *pphContext,
    /* [in] */ PSYNC_HANDLE_TYPE phContextSync,
    /* [in] */ NOTIFY_TYPE nt,
    /* [string][unique][in] */ LPSTR szType,
    /* [string][unique][in] */ LPSTR szEventUrl,
    /* [out] */ SSDP_REGISTER_INFO **ppinfo);

/* client prototype */
int GetNotificationRpc( 
    /* [in] */ PSYNC_HANDLE_TYPE pphContextSync,
    /* [out] */ MessageList **svcList);
/* server prototype */
int _GetNotificationRpc( 
    /* [in] */ PSYNC_HANDLE_TYPE pphContextSync,
    /* [out] */ MessageList **svcList);

/* client prototype */
int WakeupGetNotificationRpc( 
    /* [in] */ PSYNC_HANDLE_TYPE pphContextSync);
/* server prototype */
int _WakeupGetNotificationRpc( 
    /* [in] */ PSYNC_HANDLE_TYPE pphContextSync);

/* client prototype */
int DeregisterNotificationRpc( 
    /* [out][in] */ PCONTEXT_HANDLE_TYPE *pphContext,
    /* [in] */ BOOL fLast);
/* server prototype */
int _DeregisterNotificationRpc( 
    /* [out][in] */ PCONTEXT_HANDLE_TYPE *pphContext,
    /* [in] */ BOOL fLast);

/* client prototype */
void EnableDeviceHost( void);
/* server prototype */
void _EnableDeviceHost( void);

/* client prototype */
void DisableDeviceHost( void);
/* server prototype */
void _DisableDeviceHost( void);

/* client prototype */
void SetICSInterfaces( 
    /* [in] */ long nCount,
    /* [size_is][in] */ GUID *arInterfaces);
/* server prototype */
void _SetICSInterfaces( 
    /* [in] */ long nCount,
    /* [size_is][in] */ GUID *arInterfaces);

/* client prototype */
void SetICSOff( void);
/* server prototype */
void _SetICSOff( void);

/* client prototype */
void HelloProc( 
    /* [string][in] */ LPSTR pszString);
/* server prototype */
void _HelloProc( 
    /* [string][in] */ LPSTR pszString);

/* client prototype */
void Shutdown( void);
/* server prototype */
void _Shutdown( void);



extern RPC_IF_HANDLE ssdpsrv_v1_0_c_ifspec;
extern RPC_IF_HANDLE _ssdpsrv_v1_0_s_ifspec;
#endif /* __ssdpsrv_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

void __RPC_USER PCONTEXT_HANDLE_TYPE_rundown( PCONTEXT_HANDLE_TYPE );
void __RPC_USER PSYNC_HANDLE_TYPE_rundown( PSYNC_HANDLE_TYPE );

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\throwclientalert.h ===
#ifndef _THROW_CLIENT_ALERT_H_
#define _THROW_CLIENT_ALERT_H_

#include <windows.h>
#include <comdef.h>
#include <comutil.h>
#include <wbemcli.h>
#include <wbemprov.h>


#include "appsrvcs.h"
#include "taskctx.h"

#include "debug.h"
#include "mem.h"

#define CLIENT_ALERT_TASK "ConfigChangeAlert"
HRESULT ThrowClientConfigAlert(void);
HRESULT ThrowClientConfigAlertFromWBEMProvider(IWbemServices *pIWbemServices);

#endif  _THROW_CLIENT_ALERT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\ssdperror.h ===
#define SSDP_ERROR_BASE 18000
#define ERROR_NO_MORE_SERVICES SSDP_ERROR_BASE+1
#define ERROR_TIMER_START_FAILED SSDP_ERROR_BASE+2
#define ERROR_DUPLICATE_SERVICE SSDP_ERROR_BASE+3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\wbemhlpr.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1998-1999 Microsoft Corporation all rights reserved.
//
// Module:      wbemcommon.h
//
// Project:     Chameleon
//
// Description: Common WBEM Related Helper Functions
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 12/03/98     TLP    Initial Version
//
//////////////////////////////////////////////////////////////////////////////

#ifndef __INC_WBEM_COMMON_SERVICES_H
#define __INC_WBEM_COMMON_SERVICES_H

#include <wbemcli.h>

///////////////////////////////////////////////////////////////////////////////
HRESULT 
ConnectToWM(
   /*[out]*/ IWbemServices** ppWbemSrvcs
           );

#endif // __INC_WBEM_COMMON_SERVICES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\ssdpapi.h ===
#ifndef _SSDPAPI_H
#define _SSDPAPI_H

#include <windows.h>
#include "ssdp.h"
#include "ssdperror.h"

#ifdef  __cplusplus
extern "C" {
#endif

// DO NOT REORDER THIS ENUMERATION.  ADD NEW VALUES TO THE END.
//   if you do, change the necessary code in upnpdevicefinder.cpp
typedef enum _SSDP_CALLBACK_TYPE {
    SSDP_FOUND = 0,
    SSDP_ALIVE = 1,
    SSDP_BYEBYE = 2,
    SSDP_DONE = 3,
    SSDP_EVENT = 4,
    SSDP_DEAD = 5,
} SSDP_CALLBACK_TYPE, *PSSDP_CALLBACK_TYPE;

const TCHAR c_szReplaceGuid[] = TEXT("5479f6b6-71ac-44fc-9164-7e901a557f81");
const DWORD c_cchReplaceGuid = celems(c_szReplaceGuid) - 1;

typedef void (WINAPI *SERVICE_CALLBACK_FUNC)(SSDP_CALLBACK_TYPE CallbackType,
                                      CONST SSDP_MESSAGE *pSsdpService,
                                      void *pContext);

VOID WINAPI FreeSsdpMessage(PSSDP_MESSAGE pSsdpMessage);

HANDLE WINAPI RegisterService(PSSDP_MESSAGE pSsdpMessage, DWORD flags);

BOOL WINAPI DeregisterService(HANDLE hRegister, BOOL fByebye);

BOOL WINAPI DeregisterServiceByUSN(char * szUSN, BOOL fByebye);

HANDLE WINAPI RegisterNotification (NOTIFY_TYPE nt, char * szType, char *szEventUrl, SERVICE_CALLBACK_FUNC fnCallback,void *pContext);

BOOL WINAPI DeregisterNotification(HANDLE hNotification);

BOOL WINAPI RegisterUpnpEventSource(LPCSTR szRequestUri, DWORD cProps,
                                    UPNP_PROPERTY *rgProps);
BOOL WINAPI DeregisterUpnpEventSource(LPCSTR szRequestUri);

BOOL WINAPI SubmitUpnpPropertyEvent(LPCSTR szEventSourceUri, DWORD dwFlags,
                                    DWORD cProps, UPNP_PROPERTY *rgProps);

BOOL WINAPI SubmitEvent(LPCSTR szEventSourceUri, DWORD dwFlags,
                        LPCSTR szHeaders, LPCSTR szEventBody);

BOOL WINAPI GetEventSourceInfo(LPCSTR szEventSourceUri, EVTSRC_INFO **ppinfo);

HANDLE WINAPI FindServices (char* szType, void *pReserved , BOOL fForceSearch);

HANDLE WINAPI FindServicesCallback (char * szType,
                             void * pReserved ,
                             BOOL fForceSearch,
                             SERVICE_CALLBACK_FUNC fnCallback,
                             void *Context
                             );

BOOL WINAPI GetFirstService (HANDLE hFindServices, PSSDP_MESSAGE *ppSsdpService);

BOOL WINAPI GetNextService (HANDLE hFindServices, PSSDP_MESSAGE *ppSsdpService);

BOOL WINAPI FindServicesClose(HANDLE hSearch);

BOOL WINAPI CleanupCache();

BOOL WINAPI SsdpStartup();

void WINAPI SsdpCleanup();

void WINAPI DHEnableDeviceHost();
void WINAPI DHDisableDeviceHost();
void WINAPI DHSetICSInterfaces(long nCount, GUID * arInterfaces);
void WINAPI DHSetICSOff();

#ifdef  __cplusplus
}   /* ... extern "C" */
#endif

#endif // _SSDPAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\vmsaldm.h ===
//#--------------------------------------------------------------
//
//  File:       vmsaldm.h
//
//  Synopsis:   This file holds the declaratations common to the
//              Virtual Machine Display Driver and the Server 
//              Appliance Local Display Manager Service
//
//  History:     4/14/99  MKarki Created
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------
#ifndef VMSALDM_H
#define VMSALDM_H


//
// name of the registry key for the Virtual Machine Intermediate
// Display Driver
//
const WCHAR VMDISPLAY_REGKEY_NAME [] =
            L"SYSTEM\\CurrentControlSet\\Services\\vmdisp\\Parameters";

//
// name of the registry sub-key to get the bitmap info.
//
const WCHAR VMDISPLAY_PARAMETERS [] = L"Parameters";

//
// name of the registry value  for the bitmaps
//
const WCHAR VMDISPLAY_STARTING_PARAM [] = L"Startup BitMap";

const WCHAR VMDISPLAY_CHECKDISK_PARAM [] = L"CheckDisk BitMap";

const WCHAR VMDISPLAY_READY_PARAM [] = L"Ready BitMap";

const WCHAR VMDISPLAY_SHUTDOWN_PARAM [] = L"Shutdown BitMap";

const WCHAR VMDISPLAY_UPDATE_PARAM [] = L"Update BitMap";

//
// this is the default width in pixels
//
const DWORD DEFAULT_DISPLAY_WIDTH = 128;

//
// this is the default height pixels
//
const DWORD DEFAULT_DISPLAY_HEIGHT = 64;

//
// this is the default height of the characters
// TODO - remove this
//
const DWORD DISPLAY_SCAN_LINES = 12;

//
// minimum character lines we support, this has to be the mininum lines 
// for any Local Display which supports a LCD
//
const DWORD SA_MINIMUM_ROWS = 4;

//
// this is the default width of the logo in pixels
//
const DWORD DEFAULT_LOGO_WIDTH = 128;

//
// this is the default height of the logo in pixels
//
const DWORD DEFAULT_LOGO_HEIGHT = 36;

//
//private IOCTL code used to lock the VMDISPLAY driver
//

#define IOCTL_SADISPLAY_LOCK    \
    CTL_CODE( FILE_DEVICE_UNKNOWN, 0x810,    \
        METHOD_BUFFERED, FILE_ANY_ACCESS )
//
//private IOCTL code used to unlock the VMDISPLAY driver
//

#define IOCTL_SADISPLAY_UNLOCK    \
    CTL_CODE( FILE_DEVICE_UNKNOWN, 0x811,    \
        METHOD_BUFFERED, FILE_ANY_ACCESS )

//
//private IOCTL code used to send busy message the VMDISPLAY driver
//

#define IOCTL_SADISPLAY_BUSY_MESSAGE    \
    CTL_CODE( FILE_DEVICE_UNKNOWN, 0x812,    \
        METHOD_BUFFERED, FILE_ANY_ACCESS )

//
//private IOCTL code used to send shutdown message the VMDISPLAY driver
//

#define IOCTL_SADISPLAY_SHUTDOWN_MESSAGE    \
    CTL_CODE( FILE_DEVICE_UNKNOWN, 0x813,    \
        METHOD_BUFFERED, FILE_ANY_ACCESS )

//
//private IOCTL code used to send shutdown message the VMDISPLAY driver
//

#define IOCTL_SADISPLAY_CHANGE_LANGUAGE     \
    CTL_CODE( FILE_DEVICE_UNKNOWN, 0x814,    \
        METHOD_BUFFERED, FILE_ANY_ACCESS )


#endif //   #define VMSALDM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\varvec.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    VarVec.h
//
// SYNOPSIS
//
//    This file describes the class CVariantVector
//
// MODIFICATION HISTORY
//
//    08/05/1997    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _VARVEC_H_
#define _VARVEC_H_

#include "nocopy.h"

#pragma warning( disable : 4290 )

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    CVariantVector
//
// DESCRIPTION
//
//    This class provides a wrapper around a one-dimensional SAFEARRAY stored
//    in a VARIANT.
//
// CAVEATS
//
//    This class does not assume ownership of the VARIANT struct.  In other
//    words, you are responsible for calling VariantClear() to free any
//    allocated memory.
//
///////////////////////////////////////////////////////////////////////////////
template <class T>
class CVariantVector : NonCopyable
{
public:

   // Manipulates an existing array.
   explicit CVariantVector(VARIANT* pv) throw (_com_error);

   // Creates a new array cElements in length.
   CVariantVector(
                   VARIANT* pv, 
                   unsigned int cElements
                 ) throw (_com_error);

   // Create or manipulate a safe array of any automation compatible type
   CVariantVector(
                   VARIANT*     pv, 
                   VARTYPE      vt, 
                   unsigned int cElements
                 ) throw (_com_error);

   ~CVariantVector() throw()
   {
      SafeArrayUnaccessData(m_psa);
   }

   T* data() throw()
   {
      return m_pData;
   }

   long size() const throw()
   {
      return m_lSize;
   }

   T& operator[](size_t index) throw()
   {
      return m_pData[index];
   }

protected:

   SAFEARRAY* m_psa;   // The SAFEARRAY being manipulated.
   long m_lSize;       // The number of elements in the array.
   T* m_pData;         // The raw array inside the SAFEARRAY.
};


///////////////////////////////////////////////////////////////////////////////
//
//  These inline functions convert a C++ type to a VARTYPE.
//
///////////////////////////////////////////////////////////////////////////////
inline VARTYPE GetVARTYPE(BYTE*)
{
   return VT_UI1;
}

inline VARTYPE GetVARTYPE(short*)
{
   return VT_I2;
}

inline VARTYPE GetVARTYPE(long*)
{
   return VT_I4;
}

inline VARTYPE GetVARTYPE(float*)
{
   return VT_R4;
}

inline VARTYPE GetVARTYPE(double*)
{
   return VT_R8;
}

inline VARTYPE GetVARTYPE(CY*)
{
   return VT_CY;
}

inline VARTYPE GetVARTYPE(BSTR*)
{
   return VT_BSTR;
}

inline VARTYPE GetVARTYPE(IDispatch**)
{
   return VT_DISPATCH;
}

inline VARTYPE GetVARTYPE(IUnknown**)
{
   return VT_UNKNOWN;
}

inline VARTYPE GetVARTYPE(VARIANT*)
{
   return VT_VARIANT;
}

///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CVariantVector::CVariantVector
//
// DESCRIPTION
//
//    Creates a CVariantVector that accesses an existing SAFEARRAY (which
//    is contained in the passed in VARIANT).
//
///////////////////////////////////////////////////////////////////////////////
template <class T>
CVariantVector<T>::CVariantVector(VARIANT* pv) throw (_com_error)
   : m_psa(V_ARRAY(pv))
{
   using _com_util::CheckError;

   // Make sure the variant contains a one-dimensional array of the right type.
   if (V_VT(pv) != (VT_ARRAY | GetVARTYPE((T*)NULL)) ||
       SafeArrayGetDim(m_psa) != 1)
   {
      throw _com_error(DISP_E_TYPEMISMATCH);
   }

   // Get the upper and lower bound. 
   long lLBound, lUBound;
   CheckError(SafeArrayGetLBound(m_psa, 1, &lLBound));
   CheckError(SafeArrayGetUBound(m_psa, 1, &lUBound));

   // Compute the size.
   m_lSize = lUBound - lLBound + 1;
   if (m_lSize < 0)
   {
      throw _com_error(DISP_E_BADINDEX);
   }

   // Lock the array data.
   CheckError(SafeArrayAccessData(m_psa, (void**)&m_pData));
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CVariantVector::CVariantVector
//
// DESCRIPTION
//
//    Initializes both the passed in VARIANT and the CVariantVector to
//    manipulate a new array, cElements in length.
//
///////////////////////////////////////////////////////////////////////////////
template <class T>
CVariantVector<T>::CVariantVector(
                                   VARIANT* pv, 
                                   unsigned int cElements
                                 ) throw (_com_error)
   : m_lSize(cElements)
{
   // Initalize the variant.
   VariantInit(pv);

   // Create the SAFEARRAY.
   V_ARRAY(pv) = SafeArrayCreateVector(GetVARTYPE((T*)NULL), 0, cElements);

   if ((m_psa = V_ARRAY(pv)) == NULL)
   {
      throw _com_error(E_OUTOFMEMORY);
   }

   // Set the type.
   V_VT(pv) = VT_ARRAY | GetVARTYPE((T*)NULL);

   // Lock the array data.
   HRESULT hr = SafeArrayAccessData(m_psa, (void**)&m_pData);

   if (FAILED(hr))
   {
      // Free the memory we allocated.
      VariantClear(pv);

      throw _com_error(hr);
   }
}



///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CVariantVector::CVariantVector
//
// DESCRIPTION
//
//      Create a new safe array or manipulate an existing safearray of any
//      automation compatible type
//
///////////////////////////////////////////////////////////////////////////////
template <class T>
CVariantVector<T>::CVariantVector(
                                   VARIANT* pv, 
                                   VARTYPE  vt,
                                   unsigned int cElements
                                 ) throw (_com_error)
{
    if ( 0 == cElements )
    {
        // Manipulate an existing array

        m_psa = V_ARRAY(pv);

        // Make sure the variant contains a one-dimensional array of the right type.
        if ( V_VT(pv) != (VT_ARRAY | vt) || SafeArrayGetDim(m_psa) != 1)
        {
            throw _com_error(DISP_E_TYPEMISMATCH);
        }

        // Get the upper and lower bound. 
        long lLBound, lUBound;
        HRESULT hr = SafeArrayGetLBound(m_psa, 1, &lLBound);
        if ( FAILED(hr) )
        {
            throw _com_error(hr);
        }
        hr = SafeArrayGetUBound(m_psa, 1, &lUBound);
        if ( FAILED(hr) )
        {
            throw _com_error(hr);
        }

        // Compute the size.
        m_lSize = lUBound - lLBound + 1;
        if (m_lSize < 0)
        {
            throw _com_error(DISP_E_BADINDEX);
        }

        // Lock the array data.
        hr = SafeArrayAccessData(m_psa, (void**)&m_pData);
        if ( FAILED(hr) )
        {
            throw _com_error(hr);
        }
    }
    else
    {
        // Create a new array

        m_lSize = cElements;

        // Initalize the variant.
        VariantInit(pv);

        // Create the SAFEARRAY.
        _ASSERT( vt < VT_ARRAY );
        V_ARRAY(pv) = SafeArrayCreateVector(vt, 0, cElements);

        if ( NULL == (m_psa = V_ARRAY(pv)) )
        {
            throw _com_error(E_OUTOFMEMORY);
        }

        // Set the type.
        V_VT(pv) = VT_ARRAY | vt;

        // Lock the array data.
        HRESULT hr = SafeArrayAccessData(m_psa, (void**)&m_pData);

        if (FAILED(hr))
        {
            // Free the memory we allocated.
            VariantClear(pv);
            throw _com_error(hr);
        }
    }
}


#endif  // _VARVEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\inc\workerthread.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      workerthread.h
//
// Project:     Chameleon
//
// Description: Generic Worker Thread Class 
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_WORKER_THREAD_H_
#define __INC_WORKER_THREAD_H_

#include "callback.h"

typedef struct _THREADINFO
{
    bool        bExit;
    bool        bSuspended;
    HANDLE        hWait;
    HANDLE        hExit;    
    HANDLE        hThread;
    unsigned    dwThreadId;
    DWORD        dwWaitInterval;
    Callback*    pfnCallback;

} THREADINFO, *PTHREADINFO;

///////////////////////////////////////////////////////////////////////////////
class CTheWorkerThread
{

public:

    CTheWorkerThread();

    ~CTheWorkerThread();

    //////////////////////////////////////////////////////////////////////////
    bool Start(
       /*[in]*/ DWORD       dwWaitInterval, 
       /*[in]*/ Callback*   pfnCallback
              );

    //////////////////////////////////////////////////////////////////////////
    bool End(
     /*[in]*/ DWORD dwMaxWait,
     /*[in]*/ bool  bTerminateAfterWait
            );

    //////////////////////////////////////////////////////////////////////////
    void Suspend(void);

    //////////////////////////////////////////////////////////////////////////
    void Resume(void);

    //////////////////////////////////////////////////////////////////////////
    HANDLE GetHandle(void);

private:

    //////////////////////////////////////////////////////////////////////////
    static unsigned _stdcall ThreadFunc(LPVOID pThreadInfo);

    //////////////////////////////////////////////////////////////////////////
    THREADINFO            m_ThreadInfo;
};


#endif // __INC_WORKER_THREAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\sacommon\getvalue.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1998-1999 Microsoft Corporation all rights reserved.
//
// Module:      getvalue.cpp
//
// Project:     Chameleon
//
// Description: Get/Set a property value from a specified object
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 05/06/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <getvalue.h>
#include <propertybagfactory.h>
#include <satrace.h>
 
//////////////////////////////////////////////////////////////////////////////
//
// Function: GetValue() 
//
// Synopsis: Get a value from the specified object
//
//////////////////////////////////////////////////////////////////////////////
bool
GetObjectValue(
       /*[in]*/ LPCWSTR  pszObjectPath,
       /*[in]*/ LPCWSTR  pszValueName, 
       /*[in]*/ VARIANT* pValue,
       /*[in]*/ UINT     uExpectedType
              )
{
    bool bReturn = false;
    try
    {
        do
        {
            CLocationInfo LocInfo(HKEY_LOCAL_MACHINE, pszObjectPath);
            PPROPERTYBAG pBag = ::MakePropertyBag(
                                                   PROPERTY_BAG_REGISTRY,
                                                   LocInfo
                                                 );
            if ( ! pBag.IsValid() )
            {
                SATraceString("GetValue() - Could not locate registry key");
                break;
            }
            if ( ! pBag->open() )
            {
                SATraceString("GetValue() - Could not open registry key");
                break;
            }
            if ( ! pBag->get(pszValueName, pValue) )
            {
                SATracePrintf("GetValue() - Could not get value '%ls'", pszValueName);
                break;
            }
            else
            {
                if ( uExpectedType != V_VT(pValue) )
                {
                    SATracePrintf("GetValue() - Unexpected value data type for '%ls', pszValueName");
                    break;
                }
                else
                {
                    bReturn = true;
                }
            }
         
        } while ( FALSE );
    }
    catch(...)
    {
        SATraceString("GetValue() - Caught unhandled exception");
    }

    return bReturn;
}


//////////////////////////////////////////////////////////////////////////////
//
// Function: SetObjectValue() 
//
// Synopsis: Set a value in a specified object
//
//////////////////////////////////////////////////////////////////////////////
bool
SetObjectValue(
       /*[in]*/ LPCWSTR  pszObjectPath,
       /*[in]*/ LPCWSTR  pszValueName, 
       /*[in]*/ VARIANT* pValue
              )
{
    bool bReturn = false;
    try
    {
        do
        {
            CLocationInfo LocInfo(HKEY_LOCAL_MACHINE, pszObjectPath);
            PPROPERTYBAG pBag = ::MakePropertyBag(
                                                   PROPERTY_BAG_REGISTRY,
                                                   LocInfo
                                                 );
            if ( ! pBag.IsValid() )
            {
                SATraceString("SetValue() - Could not locate registry key");
                break;
            }
            if ( ! pBag->open() )
            {
                SATraceString("SetValue() - Could not open registry key");
                break;
            }
            if ( ! pBag->put(pszValueName, pValue) )
            {
                SATracePrintf("SetValue() - Could not set value '%ls'", pszValueName);
                break;
            }

            if ( ! pBag->save ())
            {
                SATracePrintf("SetValue() - Could not save value '%ls'", pszValueName);
                break;
            }

            //      
            // success
            //
            bReturn = true;
         
        } while ( FALSE );
    }
    catch(...)
    {
        SATraceString("SetValue() - Caught unhandled exception");
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\sacommon\propertybagfactory.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1998-1999 Microsoft Corporation all rights reserved.
//
// Module:      propbagfactory.cpp
//
// Project:     Chameleon
//
// Description: Property bag factory implementation
//
// Author:      TLP 
//
// When         Who    What
// ----         ---    ----
// 12/3/98      TLP    Original version
//
///////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "propertybagfactory.h"
#include "regpropertybag.h"

DWORD MPPROPERTYBAG::m_dwInstances = 0;
DWORD MPREGPROPERTYBAG::m_dwInstances = 0;

//////////////////////////////////////////////////////////////////////////////
PPROPERTYBAG
MakePropertyBag(
        /*[in]*/ PROPERTY_BAG_TYPE    eType,
        /*[in]*/ CLocationInfo&        locationInfo
               )
{
    if ( eType == PROPERTY_BAG_REGISTRY )
    {
        // Create a new property bag and give it to the 
        // master pointer (which will then take ownership of it).
        CRegPropertyBag* pBag = new CRegPropertyBag(locationInfo);
        if ( pBag != NULL )
        {
            MPPROPERTYBAG* mp = (MPPROPERTYBAG*) new MPREGPROPERTYBAG(pBag);
            return PPROPERTYBAG(mp);
        }
    }
    // Caller should always invoke CHandle<T>.IsValid() to determine
    // if the "pointer" is valid. Analgous to checking return from new for NULL
    return PPROPERTYBAG();
}

DWORD MPPROPERTYBAGCONTAINER::m_dwInstances = 0;
DWORD MPREGPROPERTYBAGCONTAINER::m_dwInstances = 0;

//////////////////////////////////////////////////////////////////////////////
PPROPERTYBAGCONTAINER 
MakePropertyBagContainer(
                /*[in]*/ PROPERTY_BAG_TYPE    eType,
                /*[in]*/ CLocationInfo&        locationInfo
                        )
{
    if ( eType == PROPERTY_BAG_REGISTRY )
    {
        // Create a new property bag container and give it to the 
        // master pointer (which will then take ownership of it)
        CRegPropertyBagContainer* pBagContainer = new CRegPropertyBagContainer(locationInfo);
        if ( pBagContainer != NULL )
        {
            MPPROPERTYBAGCONTAINER* mp = (MPPROPERTYBAGCONTAINER*) new MPREGPROPERTYBAGCONTAINER(pBagContainer);
            return PPROPERTYBAGCONTAINER(mp);
        }
    }
    // Caller should always invoke CHandle<T>.IsValid() to determine
    // if the "pointer" is valid. Analogous to checking return from new for NULL
    return PPROPERTYBAGCONTAINER();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\sacommon\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__4A3E5C39_C2A2_11D2_BF1B_00105A1F3461__INCLUDED_)
#define AFX_STDAFX_H__4A3E5C39_C2A2_11D2_BF1B_00105A1F3461__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#undef _ATL_NO_DEBUG_CRT

#include <atlbase.h>
#include <stdio.h>
#include <windows.h>
#include <ole2.h>
//#include <atlcom.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__4A3E5C39_C2A2_11D2_BF1B_00105A1F3461__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\sacommon\regpropertybag.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1998-1999 Microsoft Corporation all rights reserved.
//
// Module:      regpropertybag.h
//
// Project:     Chameleon
//
// Description: Registry property bag class definition
//
// Author:      TLP 
//
// When         Who    What
// ----         ---    ----
// 12/3/98      TLP    Original version
//
///////////////////////////////////////////////////////////////////////////

#ifndef __INC_REG_PROPERTY_BAG_H_    
#define __INC_REG_PROPERTY_BAG_H_

#include "basedefs.h"
#include "propertybag.h"
#include "propertybagfactory.h"
#include <comdef.h>
#include <comutil.h>

#pragma warning( disable : 4786 )  // template produced long name warning
#include <map>
#include <string>
using namespace std;

///////////////////////////////////////////////////////////////////////////
class CRegError
{

public:

    CRegError() { }
    ~CRegError() { }
};


///////////////////////////////////////////////////////////////////////////
class CRegInfo
{

public:

    ///////////////////////////////////////////////////////////////////////////
    CRegInfo(bool& bOK, HKEY hKey) 
        : m_dwSubKeys(0),
          m_dwValues(0),
          m_dwMaxSubKeyName(0),
          m_pSubKeyName(NULL),
          m_dwMaxValueName(0),
          m_pValueName(NULL),
          m_dwMaxValueData(0),
          m_pValueData(NULL)
    {
        bOK = false;
        LONG lResult = RegQueryInfoKey(
                        hKey,                // handle to key to query
                        NULL,                // address of buffer for class string
                        NULL,                // address of size of class string buffer
                        NULL,                // reserved
                        &m_dwSubKeys,        // address of buffer for number of subkeys
                        &m_dwMaxSubKeyName,    // address of buffer for longest subkey name length
                        NULL,                // address of buffer for longest class string length
                        &m_dwValues,        // address of buffer for number of value entries
                        &m_dwMaxValueName,    // address of buffer for longest value name length
                        &m_dwMaxValueData,    // address of buffer for longest value data length
                        NULL,                // address of buffer for security descriptor length
                        NULL                // address of buffer for last write time
                      );
        if ( ERROR_SUCCESS == lResult )
        {
            m_dwMaxSubKeyName++;
            m_dwMaxValueName++;
            auto_ptr<TCHAR> pSubKey (new TCHAR[m_dwMaxSubKeyName]);
            auto_ptr<TCHAR> pValueName (new TCHAR[m_dwMaxValueName]);
            m_pValueData = new BYTE[m_dwMaxValueData + 2];
            m_pSubKeyName = pSubKey.release();
            m_pValueName = pValueName.release();
            bOK = true;
        }
    }

    ///////////////////////////////////////////////////////////////////////////
    ~CRegInfo()
    {
        if ( m_pSubKeyName )
            delete [] m_pSubKeyName;
        if ( m_pValueName )
            delete [] m_pValueName;
        if ( m_pValueData )
            delete [] m_pValueData;
    }

    ///////////////////////////////////////////////////////////////////////////

    DWORD    m_dwSubKeys;
    DWORD    m_dwValues;

    DWORD    m_dwMaxSubKeyName;
    TCHAR*    m_pSubKeyName;

    DWORD    m_dwMaxValueName;
    TCHAR*    m_pValueName;

    DWORD    m_dwMaxValueData;
    BYTE*    m_pValueData;

private:

    CRegInfo();
    CRegInfo(const CRegInfo& rhs);
    CRegInfo& operator = (CRegInfo& rhs);

};

typedef map<wstring, _variant_t>    PropertyMap;
typedef PropertyMap::iterator        PropertyMapIterator;

///////////////////////////////////////////////////////////////////////////
class CRegPropertyBag : public CPropertyBag
{

public:

    ~CRegPropertyBag();

    // CPropertyBag interface functions (see propertybag.h)

    bool open(void);

    void close(void);

    void getLocation(CLocationInfo& location);

    LPCWSTR    getName(void);

    bool load(void);

    bool save(void);

    bool IsContainer(void);

    PPROPERTYBAGCONTAINER getContainer(void);

    bool IsProperty(LPCWSTR pszPropertyName);

    bool get(LPCWSTR pszPropertyName, VARIANT* pValue);

    bool put(LPCWSTR pszPropertyName, VARIANT* pValue);

    bool reset(void);

    DWORD getMaxPropertyName(void);

    bool current(LPWSTR pszPropertyName, VARIANT* pValue);

    bool next(void);

private:

    // Only the property bag factory can create a reg property bag
friend PPROPERTYBAG MakePropertyBag(
                            /*[in]*/ PROPERTY_BAG_TYPE    eType,
                            /*[in]*/ CLocationInfo&        location 
                                   );

    CRegPropertyBag(CLocationInfo& location);

    // No copy or assignment
    CRegPropertyBag(const CRegPropertyBag& rhs);
    CRegPropertyBag& operator = (CRegPropertyBag& rhs);

    //////////////////////////////////////////////////////////////////////////
    PropertyMapIterator 
    MyFind(LPCWSTR pszPropertyName);

    //////////////////////////////////////////////////////////////////////////
    bool
    IsSupportedType(VARTYPE vt);

    //////////////////////////////////////////////////////////////////////////
    VARTYPE
    getTypeFromBuffer(
              /*[in]*/ DWORD dwBuffSize,
              /*[in]*/ PBYTE pBuff
                     );

    //////////////////////////////////////////////////////////////////////////
    HKEY
    getKey(void) const
    { return m_key.m_hKey; }

    //////////////////////////////////////////////////////////////////////////
    void 
    releaseProperties(void);

    //////////////////////////////////////////////////////////////////////////

    bool                    m_isContainer;
    DWORD                    m_maxPropertyName;
    CLocationInfo            m_locationInfo;
    CRegKey                    m_key;
    wstring                    m_name;
    PropertyMapIterator        m_current;
    PropertyMap                m_properties;
};

typedef CMasterPtr<CRegPropertyBag> MPREGPROPERTYBAG;


///////////////////////////////////////////////////////////////////////////
class CRegPropertyBagContainer : public CPropertyBagContainer
{

public:

    ~CRegPropertyBagContainer();

    // CPropertyBagContainer interface functions (see propertybag.h)
    //
    bool open(void);

    void close(void);

    void getLocation(CLocationInfo& locationInfo);

    LPCWSTR    getName(void);

    DWORD count(void);

    PPROPERTYBAG add(LPCWSTR pszName);

    bool remove(LPCWSTR pszName);

    PPROPERTYBAG find(LPCWSTR pszName);

    PPROPERTYBAG current(void);

    bool reset(void);

    bool next(void);

private:

    // Only the property bag factory can create a reg property bag container
friend PPROPERTYBAGCONTAINER MakePropertyBagContainer(
                                             /*[in]*/ PROPERTY_BAG_TYPE    eType,
                                             /*[in]*/ CLocationInfo&    locationInfo 
                                                     );
    CRegPropertyBagContainer(CLocationInfo& locationInfo);

    // No copy or assignment
    CRegPropertyBagContainer(const CRegPropertyBagContainer& rhs);
    CRegPropertyBagContainer& operator = (CRegPropertyBagContainer& rhs);

    //////////////////////////////////////////////////////////////////////////
    HKEY
    getKey(void) const
    { return m_key.m_hKey; }

    //////////////////////////////////////////////////////////////////////////
    PPROPERTYBAG
    addBag(LPCWSTR pszName);

    //////////////////////////////////////////////////////////////////////////
    void
    releaseBags(void);

    typedef map< wstring, PPROPERTYBAG >    BagMap;
    typedef BagMap::iterator                BagMapIterator;

    CLocationInfo        m_locationInfo;
    CRegKey                m_key;
    wstring                m_name;
    BagMapIterator        m_current;
    BagMap                m_bags;
};

typedef CMasterPtr<CRegPropertyBagContainer> MPREGPROPERTYBAGCONTAINER;


#endif // __INC_REG_PROPERTY_BAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\sacommon\wbemhlpr.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1998-1999 Microsoft Corporation all rights reserved.
//
// Module:      wbemcommon.cpp
//
// Project:     Chameleon
//
// Description: Common WBEM Related Helper Functions
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 12/03/98     TLP    Initial Version
//
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "wbemhlpr.h"
#include <comdef.h>
#include <comutil.h>

//////////////////////////////////////////////////////////////////////////////
//
// Function:    ConnectToWM()
//
// Synopsis:    Connect to Windows Management
//
//////////////////////////////////////////////////////////////////////////////
HRESULT 
ConnectToWM(
   /*[out]*/ IWbemServices** ppWbemSrvcs
           )
{
    HRESULT hr = S_OK;

    // Get the WMI Locator
    CComPtr<IWbemLocator> pLoc;
    hr = CoCreateInstance(
                          CLSID_WbemLocator, 
                          0, 
                          CLSCTX_INPROC_SERVER, 
                          IID_IWbemLocator, 
                          (void**)&pLoc
                         );
    if ( SUCCEEDED(hr) )
    {
        // Connect to the CIMV2 Namespace on the local system
        CComPtr<IWbemServices> pWbemSrvcs;
        _bstr_t bstrRootNamespace = L"\\\\.\\ROOT\\CIMV2";
        hr = pLoc->ConnectServer(
                                  bstrRootNamespace, 
                                  NULL,
                                  NULL,
                                  0,                                  
                                  NULL,
                                  0,                                  
                                  0,                                  
                                  &pWbemSrvcs
                                );
        if ( SUCCEEDED(hr) )
        {
            // Set client security... May only need to do this if a service is 
            // accessing Windows Management via the Appliance Services DLL
            CComPtr<IClientSecurity> pSecurity;
            hr = pWbemSrvcs->QueryInterface(IID_IClientSecurity , (void **) &pSecurity);
            if ( SUCCEEDED(hr) )
            {
                hr = pSecurity->SetBlanket ( 
                                            pWbemSrvcs, 
                                            RPC_C_AUTHN_WINNT, 
                                            RPC_C_AUTHZ_NONE, 
                                            NULL,
                                            RPC_C_AUTHN_LEVEL_CONNECT , 
                                            RPC_C_IMP_LEVEL_IMPERSONATE, 
                                            NULL,
                                            EOAC_DYNAMIC_CLOAKING
                                           );
                if ( SUCCEEDED(hr) )
                { 
                    (*ppWbemSrvcs = pWbemSrvcs)->AddRef();
                }
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\sacommon\workerthread.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      workerthread.cpp
//
// Project:     Chameleon
//
// Description: Generic Worker Thread Class Implementation 
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "workerthread.h"
#include <process.h>

//////////////////////////////////////////////////////////////////////////
//
// Function:    Constructor
//
// Synopsis:    Initialize the worker thread object
//
//////////////////////////////////////////////////////////////////////////
CTheWorkerThread::CTheWorkerThread()
{
    m_ThreadInfo.bExit = true;
    m_ThreadInfo.bSuspended = true;
    m_ThreadInfo.hWait = NULL;
    m_ThreadInfo.hExit = NULL;    
    m_ThreadInfo.hThread = NULL;
    m_ThreadInfo.dwThreadId = 0;
    m_ThreadInfo.dwWaitInterval = 0;
    m_ThreadInfo.pfnCallback = NULL;
}

//////////////////////////////////////////////////////////////////////////
//
// Function:    Destructor
//
// Synopsis:    Syncronize the destruction of the worker thread with
//                the worker thread object.
//
//////////////////////////////////////////////////////////////////////////
CTheWorkerThread::~CTheWorkerThread()
{
    End(INFINITE, false);
}

//////////////////////////////////////////////////////////////////////////
//
// Function:    StartThread
//
// Synopsis:    Start the worker thread on its merry way
//
//////////////////////////////////////////////////////////////////////////
bool CTheWorkerThread::Start(
                     /*[in]*/ DWORD     dwWaitInterval, 
                     /*[in]*/ Callback* pfnCallback
                            )
{
    _ASSERT( m_ThreadInfo.hThread == NULL && NULL != pfnCallback );

    bool bReturn = false;

    if ( NULL == m_ThreadInfo.hThread )
    { 
        m_ThreadInfo.pfnCallback = pfnCallback;
        if ( dwWaitInterval )
        {
            m_ThreadInfo.dwWaitInterval = dwWaitInterval;
            m_ThreadInfo.bExit = false;
        }
        m_ThreadInfo.hWait = CreateEvent(NULL, TRUE, FALSE, NULL);
        if ( NULL != m_ThreadInfo.hWait )
        { 
            m_ThreadInfo.hExit = CreateEvent(NULL, TRUE, FALSE, NULL);
            if ( NULL != m_ThreadInfo.hExit )
            { 
                m_ThreadInfo.hThread = (HANDLE) _beginthreadex(
                                                               NULL,                         
                                                               0,             
                                                               CTheWorkerThread::ThreadFunc,
                                                               &m_ThreadInfo,  
                                                               0, 
                                                               &m_ThreadInfo.dwThreadId
                                                            );
                if ( m_ThreadInfo.hThread )
                { 
                    bReturn = true; 
                }
            }
        }
    }

    return bReturn;
}

//////////////////////////////////////////////////////////////////////////
//
// Function:    EndThread
//
// Synopsis:    Attempt to end the worker thread
//
//////////////////////////////////////////////////////////////////////////
bool CTheWorkerThread::End(
                   /*[in]*/ DWORD dwTimeOut,
                   /*[in]*/ bool  bTerminateAfterWait
                          )
{
    bool bReturn = true;

    if ( m_ThreadInfo.hThread )
    {
        bReturn = false;

        // Set thread exiting flag to true (see ThreadFunc below...)
        m_ThreadInfo.bExit = true;

        // Resume our worker (if its currently suspended otherwise no-op)
        Resume();

        // Wake it up if its idle
        SetEvent(m_ThreadInfo.hWait);

        // Wait for it to exit
        if ( WAIT_OBJECT_0 != WaitForSingleObjectEx(m_ThreadInfo.hExit, dwTimeOut, FALSE) )
        {
            if ( bTerminateAfterWait )
            {
                _endthreadex((unsigned)m_ThreadInfo.hThread);

                // OK, we're without a thread now...
                CloseHandle(m_ThreadInfo.hWait);
                CloseHandle(m_ThreadInfo.hExit);
                CloseHandle(m_ThreadInfo.hThread);
                m_ThreadInfo.hThread = NULL;
                bReturn = true;
            }
        }
        else
        {
            // OK, we're without a thread now...
            CloseHandle(m_ThreadInfo.hWait);
            CloseHandle(m_ThreadInfo.hExit);
            CloseHandle(m_ThreadInfo.hThread);
            m_ThreadInfo.hThread = NULL;
            bReturn = true;
        }
    }

    return bReturn;
}

//////////////////////////////////////////////////////////////////////////
//
// Function:    SuspendThread
//
// Synopsis:    Suspend the worker thread
//
//////////////////////////////////////////////////////////////////////////
void CTheWorkerThread::Suspend(void)
{
    _ASSERT(m_ThreadInfo.hThread);
    m_ThreadInfo.bSuspended = true;
    ::SuspendThread(m_ThreadInfo.hThread);
}

//////////////////////////////////////////////////////////////////////////
//
// Function:    ResumeThread
//
// Synopsis:    Resume the worker thread
//
//////////////////////////////////////////////////////////////////////////
void CTheWorkerThread::Resume(void)
{
    _ASSERT(m_ThreadInfo.hThread);
    m_ThreadInfo.bSuspended = false;
    ::ResumeThread(m_ThreadInfo.hThread);
}

//////////////////////////////////////////////////////////////////////////
//
// Function:    GetHandle()
//
// Synopsis:    Return the thread handle
//
//////////////////////////////////////////////////////////////////////////
HANDLE CTheWorkerThread::GetHandle(void)
{
    return m_ThreadInfo.hThread;
}

//////////////////////////////////////////////////////////////////////////
//
// Function:    ThreadFunc
//
// Synopsis:    The worker thread function
//
//////////////////////////////////////////////////////////////////////////
unsigned _stdcall CTheWorkerThread::ThreadFunc(LPVOID pThreadInfo)
{
    // If One Shot Then
    //    Do some work
    // Else
    //    While not time to exit 
    //      Do some work
    //      Go idle for the wait interval
    //      End While
    //    End While
    // End If
    // Set exit event (synchronize thread termination)

    SetThreadPriority(((PTHREADINFO)pThreadInfo)->hThread, THREAD_PRIORITY_HIGHEST);

    if ( ((PTHREADINFO)pThreadInfo)->bExit )
    {
        ((PTHREADINFO)pThreadInfo)->pfnCallback->DoCallback();
    }
    else
    {
        while ( ! ((PTHREADINFO)pThreadInfo)->bExit )
        {
            ((PTHREADINFO)pThreadInfo)->pfnCallback->DoCallback();

            WaitForSingleObjectEx(
                                  ((PTHREADINFO)pThreadInfo)->hWait, 
                                  ((PTHREADINFO)pThreadInfo)->dwWaitInterval, 
                                  FALSE
                                 );

        } 
    }
    SetEvent(((PTHREADINFO)pThreadInfo)->hExit);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\sacommon\regpropertybag.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1998-1999 Microsoft Corporation all rights reserved.
//
// Module:      regpropertybag.cpp
//
// Project:     Chameleon
//
// Description: Registry property bag class implementation
//
// Author:      TLP 
//
// When         Who    What
// ----         ---    ----
// 12/3/98      TLP    Original version
// 07/26/99     TLP    Updated to support additional types
//
///////////////////////////////////////////////////////////////////////////

#include "stdafx.h"            
#include "regpropertybag.h"
#include <comdef.h>
#include <comutil.h>
#include <varvec.h>


const BYTE abSignature[] = {'#', 'm', 's', '#' };

/////////////////////////////////////////////////
inline void VariantValue(VARIANT* pVar, BYTE* pbVal)
{ *pbVal = pVar->bVal; }
inline void VariantValue(BYTE* pbVal, VARIANT* pVar)
{ pVar->bVal = *pbVal; }

/////////////////////////////////////////////////
inline void VariantValue(VARIANT* pVar, short* piVal)
{ *piVal = pVar->iVal; }
inline void VariantValue(short* piVal, VARIANT* pVar)
{ pVar->iVal = *piVal; }

/////////////////////////////////////////////////
inline void VariantValue(VARIANT* pVar, long* plVal)
{ *plVal = pVar->lVal; }
inline void VariantValue(long* plVal, VARIANT* pVar)
{ pVar->lVal = *plVal; }

/////////////////////////////////////////////////
inline void VariantValue(VARIANT* pVar, float* pfltVal)
{ *pfltVal = pVar->fltVal; }
inline void VariantValue(float* pfltVal, VARIANT* pVar)
{ pVar->fltVal = *pfltVal; }

/////////////////////////////////////////////////
inline void VariantValue(VARIANT* pVar, double* pdblVal)
{ *pdblVal = pVar->dblVal; }
inline void VariantValue(double* pdblVal, VARIANT* pVar)
{ pVar->dblVal = *pdblVal; }

/////////////////////////////////////////////////
inline void VariantValue(VARIANT* pVar, CY* pcyVal)
{ *pcyVal = pVar->cyVal; }
inline void VariantValue(CY* pcyVal, VARIANT* pVar)
{ pVar->cyVal = *pcyVal; }


//////////////////////////////////////////////////////////////////////////////
// Serialize the specified VARIANT into a buffer and persist the buffer
// in a registry key named pszName with type REG_BINARY.
//////////////////////////////////////////////////////////////////////////////
template < class T >
bool saveValue(
        /*[in]*/ HKEY      hKey,
        /*[in]*/ LPCWSTR  pszName,
        /*[in]*/ VARIANT* pValue,
        /*[in]*/ T        Size
                )
{
    bool bRet = false;
    try
    {
        // Determine the size of the buffer needed to
        // persist the specified value
        PBYTE pBuff = NULL;
        DWORD dwBuffSize = sizeof(abSignature) + sizeof(VARTYPE);
        VARTYPE vt = V_VT(pValue);
        if ( VT_ARRAY < vt )
        {
            CVariantVector<T> varvec(pValue, vt & ~VT_ARRAY, 0);
            dwBuffSize += sizeof(DWORD) + varvec.size() * sizeof(T);
            // Create the buffer
            pBuff = new BYTE[dwBuffSize];
            PBYTE pBuffCur = pBuff;
            // Add the parameter header
            memcpy(pBuffCur, abSignature, sizeof(abSignature));
            pBuffCur += sizeof(abSignature);
            *((VARTYPE*)pBuffCur) = vt;
            pBuffCur += sizeof(VARTYPE);
            // Add the parameter value
            *((LPDWORD)pBuffCur) = (DWORD)varvec.size();
            pBuffCur += sizeof(DWORD);
            memcpy(pBuffCur, varvec.data(), varvec.size() * sizeof(T));
        }
        else
        {
            dwBuffSize += sizeof(T);
            // Create the buffer
            pBuff = new BYTE[dwBuffSize];
            PBYTE pBuffCur = pBuff;
            // Add the parameter header
            memcpy(pBuffCur, abSignature, sizeof(abSignature));
            pBuffCur += sizeof(abSignature);
            *((VARTYPE*)pBuffCur) = vt;
            pBuffCur += sizeof(VARTYPE);
            // Add the parameter value
            VariantValue(pValue, (T*)pBuffCur);
        }
        // Save the parameter buffer
        if ( ERROR_SUCCESS == RegSetValueEx(
                                            hKey, 
                                            pszName, 
                                            NULL, 
                                            REG_BINARY,
                                            pBuff, 
                                            dwBuffSize
                                           ) )
        {
            bRet = true;
        }

        delete [] pBuff;
    }
    catch(...)
    {

    }
    return bRet;
}

//////////////////////////////////////////////////////////////////////////////
template< class T >
void restoreValue(
                   PBYTE    pBuff,
                   VARIANT* pValue,
                   T        Size
                 )
{
    pBuff += sizeof(abSignature);
    VARTYPE vt = *((VARTYPE*)pBuff);
    pBuff += sizeof(VARTYPE);
    if ( VT_ARRAY < vt )
    {
        DWORD dwElements = *((LPDWORD)pBuff);
        pBuff += sizeof(DWORD);
        CVariantVector<T> varvec(pValue, vt & ~VT_ARRAY, dwElements);
        memcpy(varvec.data(), pBuff, dwElements * sizeof(T));
    }
    else
    {
        VariantValue((T*)pBuff, pValue);
    }
    V_VT(pValue) = vt;
}

/////////////////////////////////////////////////////////////////////////
// CRegPropertyBag - Implementation of CPropertyBag

/////////////////////////////////////////////////////////////////////////
CRegPropertyBag::CRegPropertyBag(CLocationInfo& locationInfo)
    : m_isContainer(false),
      m_maxPropertyName(0),
      m_locationInfo(locationInfo)
{
    m_name = m_locationInfo.getShortName();
}

/////////////////////////////////////////////////////////////////////////
CRegPropertyBag::~CRegPropertyBag()
{
    close();
    releaseProperties();
}

//////////////////////////////////////////////////////////////////////////
bool
CRegPropertyBag::open()
{
    try
    {
        close();
        LONG lReturn = m_key.Open(
                                    (HKEY)m_locationInfo.getHandle(), 
                                    m_locationInfo.getName(), 
                                    KEY_ALL_ACCESS
                                 );

        if ( ERROR_SUCCESS == lReturn )
        {
            if ( load() )
                return true;
        }
        // DoTrace("");
    }
    catch(...)
    {
        // DoTrace("");
    }
    m_key.m_hKey = NULL;
    return false;
}

//////////////////////////////////////////////////////////////////////////
void
CRegPropertyBag::close()
{
    if ( getKey() )
        m_key.Close();
}


//////////////////////////////////////////////////////////////////////////
void
CRegPropertyBag::getLocation(CLocationInfo& locationInfo)
{ 
    locationInfo = m_locationInfo;
}

//////////////////////////////////////////////////////////////////////////
bool
CRegPropertyBag::load()
{
    if ( getKey() )
    {
        bool bOK;
        CRegInfo regInfo(bOK, (HKEY)m_key);
        if ( bOK )
        {
            LONG  lReturn = ERROR_SUCCESS;
            DWORD dwIndex = 0;
            DWORD dwMaxValueName;
            DWORD dwType;
            DWORD dwMaxValueData;
            DWORD dwValue;
            VARTYPE vt;
            
            releaseProperties();

            try
            {
                _variant_t vtValue;
                while ( dwIndex < regInfo.m_dwValues )
                {
                    dwMaxValueName = regInfo.m_dwMaxValueName;
                    lReturn = RegEnumValue(
                                            getKey(),
                                            dwIndex,
                                            regInfo.m_pValueName,
                                            &dwMaxValueName,
                                            NULL,
                                            &dwType,
                                            NULL,
                                            NULL
                                          );

                    if ( ERROR_SUCCESS != lReturn )
                    {
                        // DoTrace("");
                        throw CRegError();
                    }

                    switch( dwType )
                    {
                        ///////////////
                        case REG_DWORD:
                            lReturn = m_key.QueryValue(dwValue, regInfo.m_pValueName);
                            if ( ERROR_SUCCESS != lReturn )
                            {
                                // DoTrace("");
                                throw CRegError();
                            }
                            vtValue = (long)dwValue;
                            break;

                        ///////////////////
                        case REG_EXPAND_SZ:    // Note we do not expand the string here...    
                        case REG_SZ:
                            dwMaxValueData = regInfo.m_dwMaxValueData;
                            lReturn = m_key.QueryValue((LPTSTR)regInfo.m_pValueData, regInfo.m_pValueName, &dwMaxValueData);
                            if ( ERROR_SUCCESS != lReturn )
                            {
                                // DoTrace("");
                                throw CRegError();
                            }
                            vtValue = (LPCWSTR)regInfo.m_pValueData;
                            break;

                        ////////////////
                        case REG_BINARY:
                            dwMaxValueData = regInfo.m_dwMaxValueData;
                            lReturn = RegQueryValueEx(
                                                       getKey(), 
                                                       regInfo.m_pValueName, 
                                                       NULL, 
                                                       &dwType,
                                                       regInfo.m_pValueData, 
                                                       &dwMaxValueData
                                                     );
                            if ( ERROR_SUCCESS != lReturn )
                            {
                                // DoTrace("");
                                throw CRegError();
                            }
                            vt = getTypeFromBuffer(dwMaxValueData, regInfo.m_pValueData);
                            switch ( vt & ~VT_ARRAY )
                            {
                                ///////////
                                case VT_UI1:
                                    {
                                        BYTE size = sizeof(BYTE);
                                        restoreValue(regInfo.m_pValueData, &vtValue, size);
                                    }
                                    break;
                                    

                                ///////////
                                case VT_I2:
                                    {
                                        short size = sizeof(short);
                                        restoreValue(regInfo.m_pValueData, &vtValue, size);
                                    }
                                    break;

                                case VT_BOOL:
                                    {
                                        VARIANT_BOOL size = sizeof(VARIANT_BOOL);
                                        restoreValue(regInfo.m_pValueData, &vtValue, size);
                                    }
                                    break;
    
                                ///////////
                                case VT_R4:
                                    {
                                        float size = sizeof(float);
                                        restoreValue(regInfo.m_pValueData, &vtValue, size);
                                    }
                                    break;

                                ///////////
                                case VT_R8:
                                    {
                                        double size = sizeof(double);
                                        restoreValue(regInfo.m_pValueData, &vtValue, size);
                                    }
                                    break;

                                ///////////
                                case VT_CY:
                                    {
                                        CY size = { sizeof(CY), sizeof(CY) };
                                        restoreValue(regInfo.m_pValueData, &vtValue, size);
                                    }
                                    break;

                                ///////////
                                case VT_DATE:
                                    {
                                        DATE size = sizeof(DATE);
                                        restoreValue(regInfo.m_pValueData, &vtValue, size);
                                    }
                                    break;

                                ///////////
                                case VT_ERROR:
                                    {
                                        SCODE size = sizeof(SCODE);
                                        restoreValue(regInfo.m_pValueData, &vtValue, size);
                                    }
                                    break;

                                ///////////
                                case VT_I4:
                                case VT_BSTR:
                                     _ASSERT(FALSE);
                                    // DoTrace("");
                                    throw CRegError();
                                    break;

                                default:
                                    CVariantVector<unsigned char> theBuff(&vtValue, dwMaxValueData);
                                    break;
                            }
                            break;

                        //////////////////
                        case REG_MULTI_SZ:
                            {
                                dwMaxValueData = regInfo.m_dwMaxValueData;
                                lReturn = m_key.QueryValue((LPTSTR)regInfo.m_pValueData, regInfo.m_pValueName, &dwMaxValueData);
                                if ( ERROR_SUCCESS != lReturn )
                                {
                                    // DoTrace("");
                                    throw CRegError();
                                }
                                // Determine number of strings
                                DWORD dwStrs = 0;
                                LPWSTR pszStr = (LPWSTR)regInfo.m_pValueData;
                                while ( *pszStr )
                                {
                                    dwStrs++;
                                    pszStr += lstrlen(pszStr) + 1;                            
                                }
                                // Create a VARIANT of BSTRs for the strings
                                if ( dwStrs )
                                { 
                                    CVariantVector<BSTR> theStrings(&vtValue, dwStrs);
                                    pszStr = (LPWSTR)regInfo.m_pValueData;
                                    for ( int i = 0; i < dwStrs; i++ )
                                    {
                                        theStrings[i] = SysAllocString(pszStr);
                                        pszStr += lstrlen(pszStr) + 1;                            
                                    }
                                }
                                else
                                {
                                    CVariantVector<BSTR> theStrings(&vtValue, 1);
                                    theStrings[0] = SysAllocString(L"");
                                }
                            }
                            break;
                                
                        ////////
                        default:
                            // DoTrace("Unsupported Type");
                            throw CRegError();
                            break;
                    }

                    // Create new propertyinfo object then add it to the collection
                    pair<PropertyMapIterator, bool> thePair = m_properties.insert(PropertyMap::value_type(regInfo.m_pValueName, vtValue));
                    if ( false == thePair.second )
                    {
                        // DoTrace("");
                        throw CRegError();
                    }

                    dwIndex++;
                }

                if ( regInfo.m_dwSubKeys )
                {
                    m_isContainer = true;
                }
                m_maxPropertyName = regInfo.m_dwMaxValueName;
                reset();
                return true;
            }
            catch(...)
            {
                releaseProperties();
            }
        }
    }
    return false;
}    

//////////////////////////////////////////////////////////////////////////
bool
CRegPropertyBag::save()
{
    if ( getKey() )
    {
        try
        {
            LONG lReturn;
            PropertyMapIterator p = m_properties.begin();
            while ( p != m_properties.end() )
            {
                VARTYPE vt = V_VT(&((*p).second));
                switch ( vt & ~ VT_ARRAY )
                {
                    /////////////
                    case VT_BSTR:
                        if ( VT_ARRAY < vt )
                        {
                            // Format the safe array of BSTRs
                            // into a REG_MULTI_SZ
                            DWORD dwBuffSize = 0;
                            int i = 0;
                            CVariantVector<BSTR> theArray(&((*p).second));
                            for ( i = 0; i < theArray.size(); i++ )
                            {
                                dwBuffSize += (lstrlen(theArray[i]) + 1) * sizeof(WCHAR);
                            }
                            dwBuffSize += sizeof(WCHAR); // terminated by 2 NULL characters
                            PBYTE pBuff = new BYTE[dwBuffSize];
                            PBYTE pBuffCur = pBuff;
                            memset(pBuff, 0, dwBuffSize);
                            for ( i = 0; i < theArray.size(); i++ )
                            {
                                lstrcpy((LPWSTR)pBuffCur, theArray[i]);
                                pBuffCur += (lstrlen(theArray[i]) + 1) * sizeof(WCHAR);
                            }
                            if ( ERROR_SUCCESS != RegSetValueEx(
                                                                getKey(), 
                                                                (*p).first.c_str(), 
                                                                NULL, 
                                                                REG_MULTI_SZ,
                                                                pBuff, 
                                                                dwBuffSize
                                                               ) )
                            {
                                // DoTrace("");
                                throw CRegError();
                            }

                            delete[] pBuff;
                        }
                        else
                        {
                            // Single string value
                            if ( ERROR_SUCCESS != m_key.SetValue(V_BSTR(&((*p).second)), (*p).first.c_str()) )
                            { 
                                // DoTrace("");
                                throw CRegError();
                            }
                        }
                        break;

                    ///////////
                    case VT_I4:
                        if ( ERROR_SUCCESS != m_key.SetValue((DWORD)V_I4(&((*p).second)), (*p).first.c_str()) )
                        { 
                            // DoTrace("");
                            throw CRegError();
                        }
                        break;

                    ////////////
                    case VT_UI1:
                        {
                            BYTE size = sizeof(BYTE);
                            if ( ! saveValue(getKey(), (*p).first.c_str(), &((*p).second), size) )
                            {
                                 // DoTrace("");
                                throw CRegError();
                            }
                        }
                        break;

                    ///////////
                    case VT_I2:
                        {
                            short size = sizeof(short);
                            if ( ! saveValue(getKey(), (*p).first.c_str(), &((*p).second), size) )
                            {
                                 // DoTrace("");
                                throw CRegError();
                            }
                        }
                        break;

                    case VT_BOOL:
                        {
                            VARIANT_BOOL size = sizeof(VARIANT_BOOL);
                            if ( ! saveValue(getKey(), (*p).first.c_str(), &((*p).second), size) )
                            {
                                 // DoTrace("");
                                throw CRegError();
                            }
                        }
                        break;


                    ///////////
                    case VT_R4:
                        {
                            float size = sizeof(float);
                            if ( ! saveValue(getKey(), (*p).first.c_str(), &((*p).second), size) )
                            {
                                 // DoTrace("");
                                throw CRegError();
                            }
                        }
                        break;

                    ///////////
                    case VT_R8:
                        {
                            double size = sizeof(double);
                            if ( ! saveValue(getKey(), (*p).first.c_str(), &((*p).second), size) )
                            {
                                 // DoTrace("");
                                throw CRegError();
                            }
                        }
                        break;

                    ///////////
                    case VT_CY:
                        {
                            CY size = { sizeof(CY), sizeof(CY) };
                            if ( ! saveValue(getKey(), (*p).first.c_str(), &((*p).second), size) )
                            {
                                 // DoTrace("");
                                throw CRegError();
                            }
                        }
                        break;

                    ///////////
                    case VT_DATE:
                        {
                            DATE size = sizeof(DATE);
                            if ( ! saveValue(getKey(), (*p).first.c_str(), &((*p).second), size) )
                            {
                                 // DoTrace("");
                                throw CRegError();
                            }
                        }
                        break;

                    ///////////
                    case VT_ERROR:
                        {
                            SCODE size = sizeof(SCODE);
                            if ( ! saveValue(getKey(), (*p).first.c_str(), &((*p).second), size) )
                            {
                                 // DoTrace("");
                                throw CRegError();
                            }
                        }
                        break;

                    ////////
                    default:
                        _ASSERT( FALSE );
                        // DoTrace("");
                        throw CRegError();
                        break;
                }

                p++;
            }

            return true;
        }
        catch(...)
        {

        }
    }

    return false;
}

//////////////////////////////////////////////////////////////////////////
bool
CRegPropertyBag::IsContainer(void)
{ 
    return m_isContainer;
}    

//////////////////////////////////////////////////////////////////////////
PPROPERTYBAGCONTAINER
CRegPropertyBag::getContainer()
{ 
    if ( m_isContainer )
        return ::MakePropertyBagContainer(PROPERTY_BAG_REGISTRY, m_locationInfo);
    return PPROPERTYBAGCONTAINER();
}

//////////////////////////////////////////////////////////////////////////
LPCWSTR
CRegPropertyBag::getName(void)
{ 
    return m_name.c_str(); 
}

//////////////////////////////////////////////////////////////////////////
DWORD
CRegPropertyBag::getMaxPropertyName(void)
{ 
    return m_maxPropertyName; 
}

//////////////////////////////////////////////////////////////////////////
bool
CRegPropertyBag::IsProperty(LPCWSTR pszPropertyName)
{
    _ASSERT( pszPropertyName );
    PropertyMapIterator p = MyFind(pszPropertyName);
    if ( p != m_properties.end() )
    { 
        return true; 
    }
    return false;
}

//////////////////////////////////////////////////////////////////////////
bool
CRegPropertyBag::get(LPCWSTR pszPropertyName, VARIANT* pValue)
{
    _ASSERT( pszPropertyName );
    PropertyMapIterator p = MyFind(pszPropertyName);
    if ( p != m_properties.end() )
    {
        if ( SUCCEEDED(VariantCopy(pValue, &((*p).second))) )
        {
            return true;
        }
    }        
    // DoTrace("");
    return false;
}

//////////////////////////////////////////////////////////////////////////
bool
CRegPropertyBag::put(LPCWSTR pszPropertyName, VARIANT* pValue)
{
    _ASSERT( pszPropertyName );

    if ( ! IsSupportedType(V_VT(pValue)) )
    {
        return false;
    }

    // Try to locate the specified property...
    PropertyMapIterator p = MyFind(pszPropertyName);
    if ( p != m_properties.end() )
    {
        // Existing property. We're either changing its value or removing it.
        if ( VT_EMPTY == V_VT(pValue) )
        {
            // Removing it
            if ( m_current == p )
            {
                m_current = m_properties.erase(p);
            }
            else
            {
                m_properties.erase(p);
            }
        }
        else
        {
            // Changing its value (and possibly its type)
            if ( SUCCEEDED(VariantCopy(&((*p).second), pValue)) )
            {
                return true;
            }
        }
    }
    else
    {
        if ( VT_EMPTY != V_VT(pValue) )
        {
            // New property. Insert it into the property map
            pair<PropertyMapIterator, bool> thePair = m_properties.insert(PropertyMap::value_type(pszPropertyName, pValue));
            if ( false == thePair.second )
            {
                // DoTrace("");
                throw CRegError();
            }
            int length = lstrlen(pszPropertyName);
            if ( length > m_maxPropertyName )
            {
                m_maxPropertyName = length;
            }
        }
        return true;
    }
    // DoTrace("");
    return false;
}

//////////////////////////////////////////////////////////////////////////
bool
CRegPropertyBag::current(LPWSTR pszPropertyName, VARIANT* pValue)
{
    if ( ! m_properties.empty() )
    {
        lstrcpy(pszPropertyName, ((*m_current).first).c_str());
        if ( SUCCEEDED(VariantCopy(pValue, &(*m_current).second)) )
        {
            return true;
        }
    }
    // DoTrace("");
    return false;
}

//////////////////////////////////////////////////////////////////////////
bool
CRegPropertyBag::reset()
{
    m_current = m_properties.begin();
    return true;
}

//////////////////////////////////////////////////////////////////////////
bool
CRegPropertyBag::next()
{
    if ( ! m_properties.empty() )
    {
        m_current++;
        if ( m_current == m_properties.end() )
        {
            m_current--;
        }
        else
        {
            return true;
        }
    }            
    // DoTrace("");
    return false;
}


//////////////////////////////////////
// CRegPropertyBag - private functions

//////////////////////////////////////////////////////////////////////////////
VARTYPE 
CRegPropertyBag::getTypeFromBuffer(
                           /*[in]*/ DWORD dwBuffSize,
                           /*[in]*/ PBYTE pBuff
                                  )
{
    VARTYPE vt = VT_EMPTY;
    if ( dwBuffSize > sizeof(abSignature) + sizeof(VARTYPE) )
    {
        if ( ! memcmp(pBuff, abSignature, sizeof(abSignature)) )
        {
            pBuff += sizeof(abSignature);
            vt = *((VARTYPE*)pBuff);
            if ( ! IsSupportedType(vt) )
            {
                vt = VT_EMPTY;
            }
        }
    }
    return vt;
}

//////////////////////////////////////////////////////////////////////////
PropertyMapIterator 
CRegPropertyBag::MyFind(LPCWSTR pszPropertyName)
{
    PropertyMapIterator p = m_properties.begin();
    while ( p != m_properties.end() )
    {
        if ( ! lstrcmpi(pszPropertyName, (*p).first.c_str()) )
        {
            break;
        }
        p++;
    }
    return p;
}

//////////////////////////////////////////////////////////////////////////
bool 
CRegPropertyBag::IsSupportedType(VARTYPE vt)
{
    bool bRet = false;

    switch ( vt & ~ VT_ARRAY )
    {
        case VT_UI1:
        case VT_I2:
        case VT_BOOL:
        case VT_I4:
        case VT_R4:
        case VT_R8:
        case VT_CY:
        case VT_DATE:
        case VT_ERROR:
        case VT_BSTR:
        case VT_UNKNOWN:    // Allow put() and get() of COM objects
        case VT_DISPATCH:
        case VT_EMPTY:      // Used to erase an existing bag value
            bRet = true;
            break;

        default:
            break;
    };

    return bRet;
}

//////////////////////////////////////////////////////////////////////////
void 
CRegPropertyBag::releaseProperties()
{
    PropertyMapIterator p = m_properties.begin();
    while ( p != m_properties.end() )
        p = m_properties.erase(p);
}


//////////////////////////////////////////////////////////////////////////
// CRegPropertyBagContainer
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
CRegPropertyBagContainer::CRegPropertyBagContainer(CLocationInfo& locationInfo)
    : m_locationInfo(locationInfo)
{
    m_name = m_locationInfo.getShortName();    
}

//////////////////////////////////////////////////////////////////////////
CRegPropertyBagContainer::~CRegPropertyBagContainer() 
{ 
    close(); 
    releaseBags();
}

//////////////////////////////////////////////////////////////////////////
bool
CRegPropertyBagContainer::open()
{
    close();

    try
    {
        LONG lReturn = m_key.Open(
                                    (HKEY)m_locationInfo.getHandle(), 
                                    m_locationInfo.getName(), 
                                    KEY_ALL_ACCESS
                                 );
        
        if ( ERROR_SUCCESS == lReturn )
        {
            bool bOk;
            CRegInfo regInfo(bOk, getKey());
            if ( bOk )
            {
                LONG        lResult = ERROR_SUCCESS;
                DWORD        dwKeyNameSize;     
                FILETIME    sFileTime;
                DWORD        dwIndex = 0;

                releaseBags();

                while ( lResult == ERROR_SUCCESS )
                {
                    dwKeyNameSize = regInfo.m_dwMaxSubKeyName;
                    lResult = RegEnumKeyEx(
                                            getKey(),
                                            dwIndex,
                                            regInfo.m_pSubKeyName,
                                            &dwKeyNameSize,
                                            NULL,
                                            NULL,
                                            NULL,
                                            &sFileTime
                                          );
                    if ( ERROR_SUCCESS == lResult )
                    {
                        PPROPERTYBAG pBag = addBag(regInfo.m_pSubKeyName);
                        if ( ! pBag.IsValid() )
                            throw CRegError();
                    }
                    dwIndex++;
                }
                if ( ERROR_NO_MORE_ITEMS == lResult )
                    return true;
            }
        }
    }
    catch(...)
    {
        close();
        releaseBags();
    }
    // DoTrace("");
    return false;
}

//////////////////////////////////////////////////////////////////////////
void 
CRegPropertyBagContainer::close()
{
    if ( getKey() )
        m_key.Close();
}

//////////////////////////////////////////////////////////////////////////
void
CRegPropertyBagContainer::getLocation(CLocationInfo& locationInfo)
{ 
    locationInfo = m_locationInfo;
}

//////////////////////////////////////////////////////////////////////////
LPCWSTR
CRegPropertyBagContainer::getName()
{
    return m_name.c_str();
}

//////////////////////////////////////////////////////////////////////////
DWORD
CRegPropertyBagContainer::count(void)
{
    return m_bags.size();
}

//////////////////////////////////////////////////////////////////////////
PPROPERTYBAG
CRegPropertyBagContainer::add(LPCWSTR pszName)
{
    try 
    {
        if ( getKey() )
        {
            HKEY hKey;
            DWORD dwDisposition;
            LONG lRes = RegCreateKeyEx(
                                        getKey(), 
                                        pszName, 
                                        0,
                                        REG_NONE,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &hKey,
                                        &dwDisposition
                                       );
            if ( ERROR_SUCCESS == lRes)
            {
                CLocationInfo locationBag(getKey(), pszName);
                PPROPERTYBAG pBag = ::MakePropertyBag(PROPERTY_BAG_REGISTRY, locationBag);
                pair<BagMapIterator, bool> thePair = m_bags.insert(BagMap::value_type(pszName, pBag));
                if ( true == thePair.second )
                { 
                    RegCloseKey(hKey);
                    return pBag; 
                }
                else
                { m_key.DeleteSubKey(pszName); }
            }
        }
    }
    catch(...)
    {

    }
    // DoTrace("");
    return PPROPERTYBAG();
}


//////////////////////////////////////////////////////////////////////////
bool
CRegPropertyBagContainer::remove(LPCWSTR pszName)
{
    if ( getKey() )
    {
        BagMapIterator p = m_bags.find(pszName);
        if ( p != m_bags.end() )
        {
            if ( m_current == p )
                m_current = m_bags.erase(p);
            else
                m_bags.erase(p);

            if ( ERROR_SUCCESS == m_key.DeleteSubKey(pszName) )
                return true;
        }
    }
    // DoTrace("");
    return false;
}

//////////////////////////////////////////////////////////////////////////
PPROPERTYBAG
CRegPropertyBagContainer::find(LPCWSTR pszName)
{
    if ( getKey() )
    {
        BagMapIterator p = m_bags.begin();
        while ( p != m_bags.end() )
        {
            if ( ! lstrcmpi(pszName, (*p).first.c_str()) )
            {
                return (*p).second;
            }
            p++;
        }
    }
    // DoTrace("")
    return PPROPERTYBAG();        
}

//////////////////////////////////////////////////////////////////////////
PPROPERTYBAG
CRegPropertyBagContainer::current()
{
    if ( getKey() )
    {
        if ( ! m_bags.empty() )
            return (*m_current).second;
    }
    // DoTrace("");
    return PPROPERTYBAG();
}
    
//////////////////////////////////////////////////////////////////////////
bool
CRegPropertyBagContainer::reset()
{ 
    if ( getKey() )
    {
        m_current = m_bags.begin();
        return true;
    }
    // DoTrace("")
    return false;
}

//////////////////////////////////////////////////////////////////////////
bool
CRegPropertyBagContainer::next()
{
    if ( getKey() )
    {
        if ( ! m_bags.empty() )
        {
            m_current++;
            if ( m_current == m_bags.end() )
                m_current--;
            else
                return true;
        }            
    }
    // DoTrace("");
    return false;
}


//////////////////////////////////////////////////////////////////////////
PPROPERTYBAG
CRegPropertyBagContainer::addBag(LPCWSTR pszName)
{
    try 
    {
        wstring szObjName = m_locationInfo.getName();
        szObjName += L"\\";
        szObjName += pszName;
        CLocationInfo locationBag(m_locationInfo.getHandle(), szObjName.c_str());
        PPROPERTYBAG pBag = ::MakePropertyBag(PROPERTY_BAG_REGISTRY, locationBag);
        pair<BagMapIterator, bool> thePair = m_bags.insert(BagMap::value_type(pszName, pBag));
        if ( true == thePair.second )
        { return pBag; }
    }
    catch(...)
    {

    }
    // DoTrace("");
    return PPROPERTYBAG();
}
//////////////////////////////////////////////////////////////////////////
void 
CRegPropertyBagContainer::releaseBags()
{
    BagMapIterator p = m_bags.begin();
    while ( p != m_bags.end() )
        p = m_bags.erase(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\satrace\satrace.c ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iastrace.cpp
//
// SYNOPSIS
//
//    Defines the API into the SA trace facility.
//
// MODIFICATION HISTORY
//
//    08/18/1998    Original version.
//    01/27/1999    Stolen from IAS Project
//
///////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <rtutils.h>
#include <stdlib.h>
#include <stdio.h>

//
// trace libarary name
//
const TCHAR TRACE_LIBRARY [] = TEXT ("rtutils.dll");

const DWORD MAX_DEBUGSTRING_LENGTH = 512;

//
// tracing library method names
//
const char TRACE_REGISTER_FUNC[]    = "TraceRegisterExW";
const char TRACE_DEREGISTER_FUNC[]  = "TraceDeregisterW";
const char TRACE_VPRINTF_FUNC[]     = "TraceVprintfExA";
const char TRACE_PUTS_FUNC[]        = "TracePutsExA";
const char TRACE_DUMP_FUNC[]        = "TraceDumpExA";

//
// signatures of methods in rtutils.dll
//
typedef DWORD   (*PTRACE_REGISTER_FUNC) (
                                LPCWSTR lpszCallerName,
                                DWORD   dwFlags
                                );

typedef DWORD   (*PTRACE_DEREGISTER_FUNC) (
                                DWORD   dwTraceID
                                );

typedef DWORD   (*PTRACE_VPRINTF_FUNC) (
                                DWORD   dwTraceID,
                                DWORD   dwFlags,
                                LPCSTR  lpszFormat,
                                va_list arglist
                                );

typedef DWORD   (*PTRACE_PUTS_FUNC) (
                                DWORD   dwTraceID,
                                DWORD   dwFlags,
                                LPCSTR  lpszString
                                );

typedef DWORD   (*PTRACE_DUMP_FUNC) (
                                DWORD   dwTraceID,
                                DWORD   dwFlags,
                                LPBYTE  lpBytes,
                                DWORD   dwByteCount,
                                DWORD   dwGroupSize,
                                BOOL    bAddressPrefix,
                                LPCSTR  lpszPrefix
                                );

//
// pointer to the functsion in rtutils.dll
//
PTRACE_REGISTER_FUNC        pfnTraceRegisterExW = NULL;
PTRACE_DEREGISTER_FUNC      pfnTraceDeregisterW = NULL;
PTRACE_VPRINTF_FUNC         pfnTraceVprintfExA = NULL;
PTRACE_PUTS_FUNC            pfnTracePutsExA = NULL;
PTRACE_DUMP_FUNC            pfnTraceDumpExA = NULL;

//
// flags specifies that the tracing is being done for the first time
//
BOOL    fFirstTime = TRUE;

//
// this flag is used to signify whether Trace DLL is initialized
// no tracing is done if DLL is not initialized
//
BOOL fInitDLL = FALSE;

//
// new line char
//
CHAR NEWLINE[] = "\n";

//////////
// Flags passed for all trace calls.
//////////
#define SA_TRACE_FLAGS (0x00010000 | TRACE_USE_MASK | TRACE_USE_MSEC)

//////////
// Trace ID for this module.
//////////
DWORD dwTraceID = INVALID_TRACEID;

//////////
// Flag indicating whether the API has been registered.
//////////
BOOL fRegistered = FALSE;

//////////
// Non-zero if the registration code is locked.
//////////
LONG lLocked = 0;

//////////
// Macros to lock/unlock the registration code.
//////////
#define LOCK_TRACE() \
   while (InterlockedExchange(&lLocked, 1)) Sleep(5)

#define UNLOCK_TRACE() \
   InterlockedExchange(&lLocked, 0)

//
// signature of method used to initialize trace DLL
//
VOID InitializeTraceDLL(
        VOID
        );

//////////
// Formats an error message from the system message table.
//////////
DWORD
WINAPI
SAFormatSysErr(
    DWORD dwError,
    PSTR lpBuffer,
    DWORD nSize
    )
{
   DWORD nChar;

   // Attempt to format the message using the system message table.
   nChar = FormatMessageA(
               FORMAT_MESSAGE_FROM_SYSTEM,
               NULL,
               dwError,
               MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
               lpBuffer,
               nSize,
               NULL
               );

   if (nChar > 0)
   {
      // Format succeeded, so strip any trailing newline and exit.
      if (lpBuffer[nChar - 1] == '\n')
      {
         --nChar;
         lpBuffer[nChar] = '\0';

         if (lpBuffer[nChar - 1] == '\r')
         {
            --nChar;
            lpBuffer[nChar] = '\0';
         }
      }

      goto exit;
   }

   // Only error condition we can handle is when the message is not found.
   if (GetLastError() != ERROR_MR_MID_NOT_FOUND)
   {
      goto exit;
   }

   // Do we have enough space for the fallback error message ?
   if (nSize < 25)
   {
      SetLastError(ERROR_INSUFFICIENT_BUFFER);

      goto exit;
   }

   // No entry in the message table, so just format the raw error code.
   nChar = wsprintfA(lpBuffer, "Unknown error 0x%0lX", dwError);

exit:
   return nChar;
}

//////////
// Deregisters the module.
//////////
VOID
__cdecl
SATraceDeregister( VOID )
{
   if (NULL != pfnTraceDeregisterW)
   {
   	pfnTraceDeregisterW(dwTraceID);
   }

   LOCK_TRACE();
   fRegistered = FALSE;
   UNLOCK_TRACE();
}

//////////
// Registers the module.
//////////
VOID
WINAPI
SATraceRegister( VOID )
{
   LONG state;
   DWORD status;
   MEMORY_BASIC_INFORMATION mbi;
   WCHAR filename[MAX_PATH + 1], *basename, *suffix;


   if ((fRegistered) || (NULL == pfnTraceRegisterExW))
   {
       return;
   }

   LOCK_TRACE();


   //////////
   // Now that we have the lock, double check that we need to register.
   //////////

   //////////
   // Find the base address of this module.
   //////////

   status = VirtualQuery(
                SATraceRegister,
                &mbi,
                sizeof(mbi)
                );
   if (status == 0) { goto exit; }

   //////////
   // Get the module filename.
   //////////

   status = GetModuleFileNameW(
                (HINSTANCE)mbi.AllocationBase,
                filename,
                MAX_PATH
                );
   if (status == 0) { goto exit; }

   //////////
   // Strip everything before the last backslash.
   //////////

   basename = wcsrchr(filename, L'\\');
   if (basename == NULL)
   {
      basename = filename;
   }
   else
   {
      ++basename;
   }

   //////////
   // Strip everything after the last dot.
   //////////

   suffix = wcsrchr(basename, L'.');
   if (suffix)
   {
      *suffix = L'\0';
   }

   //////////
   // Convert to uppercase.
   //////////

   _wcsupr(basename);

   //////////
   // Register the module.
   //////////

   dwTraceID = pfnTraceRegisterExW(basename, 0);
   if (dwTraceID != INVALID_TRACEID)
   {
        fRegistered = TRUE;
   

        //////////
        // Deregister when we exit.
        //////////

        atexit(SATraceDeregister);
   }
exit:
   UNLOCK_TRACE();
}

VOID
WINAPIV
SATracePrintf(
    IN PCSTR szFormat,
    ...
    )
{
   va_list marker;

#if (defined (DEBUG) || defined (_DEBUG))
    //
    // in case of debug build always output the output string
    //
    CHAR szDebugString[MAX_DEBUGSTRING_LENGTH +1];
    va_start(marker, szFormat);
    _vsnprintf (szDebugString, MAX_DEBUGSTRING_LENGTH, szFormat, marker);
    szDebugString[MAX_DEBUGSTRING_LENGTH] = '\0';
    OutputDebugString (szDebugString);
    OutputDebugString (NEWLINE);
    va_end(marker);
#endif // (defined (DEBUG) || defined (_DEBUG)

    if (fFirstTime) {InitializeTraceDLL();}

    if (!fInitDLL) {return;}

    SATraceRegister();

    if ((fRegistered) && (NULL != pfnTraceVprintfExA))
    { 
        va_start(marker, szFormat);
        pfnTraceVprintfExA(
            dwTraceID,
            SA_TRACE_FLAGS,
            szFormat,
            marker
            );
        va_end(marker);
    }
}

VOID
WINAPI
SATraceString(
    IN PCSTR szString
    )
{

#if (defined (DEBUG) || defined (_DEBUG))
    //
    // in case of debug build always output the output string
    //
    OutputDebugString (szString);
    OutputDebugString (NEWLINE);
#endif // (defined (DEBUG) || defined (_DEBUG)

    if (fFirstTime) {InitializeTraceDLL();}

    if (!fInitDLL) {return;}

    SATraceRegister();

    if ((fRegistered) && (NULL  != pfnTracePutsExA))
    { 
        pfnTracePutsExA(
            dwTraceID,
            SA_TRACE_FLAGS,
            szString
            );
    }
}

VOID
WINAPI
SATraceBinary(
    IN CONST BYTE* lpbBytes,
    IN DWORD dwByteCount
    )
{
    if (fFirstTime) {InitializeTraceDLL();}

    if (!fInitDLL) {return;}

    SATraceRegister();

    if ((fRegistered) && (NULL != pfnTraceDumpExA))
    { 
        pfnTraceDumpExA(
            dwTraceID,
            SA_TRACE_FLAGS,
            (LPBYTE)lpbBytes,
            dwByteCount,
            1,
            FALSE,
            NULL
            );
    }
}

VOID
WINAPI
SATraceFailure(
    IN PCSTR szFunction,
    IN DWORD dwError
    )
{
   CHAR szMessage[256];
   DWORD nChar;

   nChar = SAFormatSysErr(
               dwError,
               szMessage,
               sizeof(szMessage)
               );

   szMessage[nChar] = '\0';

   SATracePrintf("%s failed: %s\n", szFunction, szMessage);

}

//
// this is the internal trace method used to initialize platform specific
// stuff

VOID InitializeTraceDLL(
        VOID
        )
{
    OSVERSIONINFO   OsInfo;
    HINSTANCE       hInst = NULL;
    DWORD           dwSize = sizeof (OSVERSIONINFO);

    LOCK_TRACE ();

    do
    {
        if (!fFirstTime) {break;}

        fFirstTime = FALSE;

        //
        // check the platform we are running in
        //
        ZeroMemory (&OsInfo, dwSize);
        OsInfo.dwOSVersionInfoSize =  dwSize;
        if (!GetVersionEx (&OsInfo)) {break;}

        //
        // no tracing if this is not NT
        //
        if (VER_PLATFORM_WIN32_NT != OsInfo.dwPlatformId) {break;}

        //
        // Load the trace library (rtutils.dll)
        //
        hInst = LoadLibrary (TRACE_LIBRARY);
        if (NULL == hInst) {break;}

        //
        // get the address of the methods in the DLL
        //
        pfnTraceRegisterExW = (PTRACE_REGISTER_FUNC)
                                GetProcAddress (hInst, (LPCSTR)TRACE_REGISTER_FUNC);
        if (NULL == pfnTraceRegisterExW) {break;}

        pfnTraceDeregisterW = (PTRACE_DEREGISTER_FUNC)
                                GetProcAddress (hInst, (LPCSTR)TRACE_DEREGISTER_FUNC);
        if (NULL == pfnTraceDeregisterW) {break;}

        pfnTraceVprintfExA = (PTRACE_VPRINTF_FUNC)
                                GetProcAddress (hInst, (LPCSTR)TRACE_VPRINTF_FUNC);
        if (NULL == pfnTraceVprintfExA) {break;}

        pfnTracePutsExA = (PTRACE_PUTS_FUNC)
                            GetProcAddress (hInst, (LPCSTR)TRACE_PUTS_FUNC);
        if (NULL == pfnTracePutsExA) {break;}

        pfnTraceDumpExA = (PTRACE_DUMP_FUNC)
                            GetProcAddress (hInst, (LPCSTR)TRACE_DUMP_FUNC);
        if (NULL == pfnTraceDumpExA) {break;}

        //
        //  successfully initialized tracing DLL
        //
        fInitDLL = TRUE;
    }
    while (FALSE);

    UNLOCK_TRACE();

    return;

}   //  end of InitializeTraceDLL method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\throwclientalert\throwclientalert.cpp ===
#include "ThrowClientAlert.h"

HRESULT ThrowClientConfigAlert(void)
{
    IApplianceServices* pAppSrvcs = NULL;
    ITaskContext*       pTaskContext = NULL;
    _bstr_t             bstrTaskName(CLIENT_ALERT_TASK);
    HRESULT             hr;

    hr = CoCreateInstance(CLSID_ApplianceServices,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IApplianceServices,
                          (void**)&pAppSrvcs);
    if (FAILED(hr))
    {
        TRACE1("CoCreateInstance() for AppSrvcs failed in ThrowClientConfigAlert %X", hr);
        goto End;
    }

    hr = pAppSrvcs->Initialize();
    if (FAILED(hr))
    {
        TRACE1("pAppSrvcs->Initialize() failed in ThrowClientConfigAlert %X", hr);
        goto End;
    }

    hr = CoCreateInstance(CLSID_TaskContext,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ITaskContext,
                          (void**)&pTaskContext);
    if (FAILED(hr))
    {
        TRACE1("CoCreateInstance() for TaskContext failed in ThrowClientConfigAlert %X", hr);
        goto End;
    }

    hr = pAppSrvcs->ExecuteTask(bstrTaskName, pTaskContext);
    if (FAILED(hr))
    {
        TRACE1("ExecuteTask() failed in ThrowClientConfigAlert %X", hr);
        goto End;
    }

End:
    if (pAppSrvcs)
    {
        pAppSrvcs->Release();
    }
    if (pTaskContext)
    {
        pTaskContext->Release();
    }
    return hr;
}



HRESULT ThrowClientConfigAlertFromWBEMProvider(IWbemServices *pIWbemServices)
{
    IApplianceServices* pAppSrvcs = NULL;
    ITaskContext*       pTaskContext = NULL;
    _bstr_t             bstrTaskName(CLIENT_ALERT_TASK);
    HRESULT             hr;

    ASSERT(pIWbemServices);

    hr = CoCreateInstance(CLSID_ApplianceServices,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IApplianceServices,
                          (void**)&pAppSrvcs);
    if (FAILED(hr))
    {
        TRACE1("CoCreateInstance() for AppSrvcs failed in ThrowClientConfigAlertFromWBEMProvider %X", hr);
        goto End;
    }

    hr = pAppSrvcs->InitializeFromContext(pIWbemServices);
    if (FAILED(hr))
    {
        TRACE1("pAppSrvcs->InitializeFromContext() failed in ThrowClientConfigAlertFromWBEMProvider %X", hr);
        goto End;
    }

    hr = CoCreateInstance(CLSID_TaskContext,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ITaskContext,
                          (void**)&pTaskContext);
    if (FAILED(hr))
    {
        TRACE1("CoCreateInstance() for TaskContext failed in ThrowClientConfigAlertFromWBEMProvider %X", hr);
        goto End;
    }

    hr = pAppSrvcs->ExecuteTask(bstrTaskName, pTaskContext);
    if (FAILED(hr))
    {
        TRACE1("ExecuteTask() failed in ThrowClientConfigAlertFromWBEMProvider %X", hr);
        goto End;
    }

End:
    if (pAppSrvcs)
    {
        pAppSrvcs->Release();
    }
    if (pTaskContext)
    {
        pTaskContext->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sainstall\dlldatax.c ===
// wrapper for dlldata.c
//  Copyright (c) 2001 Microsoft Corporation

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "sainstallcom_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\utils\mem.cpp ===
//+----------------------------------------------------------------------------
//
// File:     mem.cpp
//      
// Module:   common
//
// Synopsis: Basic memory manipulation routines
//
// Copyright (C) 1997-1998 Microsoft Corporation.  All rights reserved.
//
// Author:     fengsun
//
// Created   9/24/98
//
//+----------------------------------------------------------------------------
//
// Always use ANSI code
//
#ifdef UNICODE
#undef UNICODE
#endif

//
// for mem.h
// somehow, new and delete functions are not inlined and cause link problem, not sure why
//
#define NO_INLINE_NEW

#include <windows.h>
#include "mem.h"
#include "debug.h"

#if !defined(DEBUG_MEM) 

//////////////////////////////////////////////////////////////////////////////////
//
// If DEBUG_MEM if NOT defined, only track a count of memory leaks for debug version
//
///////////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
static LONG    g_lMallocCnt = 0;  // a counter to detect memory leak
#endif

void *SaRealloc(void *pvPtr, size_t nBytes) 
{
    void* pMem = HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY|HEAP_GENERATE_EXCEPTIONS, pvPtr, nBytes);

    ASSERT(pMem != NULL);   

    return pMem;
}


void *SaAlloc(size_t nBytes) 
{
#ifdef _DEBUG
    InterlockedIncrement(&g_lMallocCnt);
#endif

    ASSERT(nBytes < 1024*1024); // It should be less than 1 MB
    
    void* pMem = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY|HEAP_GENERATE_EXCEPTIONS, nBytes);
    
    ASSERT(pMem != NULL);   

    return pMem;
}


void SaFree(void *pvPtr) 
{
    if (pvPtr) 
    {    
        VERIFY(HeapFree(GetProcessHeap(), 0, pvPtr));

#ifdef _DEBUG
        InterlockedDecrement(&g_lMallocCnt);
#endif
    
    }
}

#ifdef _DEBUG
void EndDebugMemory()
{
    if (g_lMallocCnt)
    {
        TCHAR buf[256];
        wsprintf(buf, TEXT("Detect Memory Leak of %d blocks"),g_lMallocCnt);
        AssertMessage(TEXT(__FILE__),__LINE__,buf);
    }
}
#endif

#else // DEBUG_MEM

//////////////////////////////////////////////////////////////////////////////////
//
// If DEBUG_MEM if defined, track all the memory alloction in debug version.
// Keep all the allocated memory blocks in the double link list.
// Record the file name and line #, where memory is allocated.
// Add extra tag at the beginning and end of the memory to watch for overwriten
// The whole list is checked against corruption for every alloc/free operation
//
// The folowing three function is exported:
// BOOL   CheckDebugMem(void); // return TRUE for succeed
// void* AllocDebugMem(long size,const char* lpFileName,int nLine);
// BOOL   FreeDebugMem(void* pMem); // return TRUE for succeed
//
///////////////////////////////////////////////////////////////////////////////////

//#undef new

#define MEMTAG 0xBEEDB77D     // the tag before/after the block to watch for overwriten
#define FREETAG 0xBD          // the flag to fill freed memory
#define TAGSIZE (sizeof(long))// Size of the tags appended to the end of the block


//
// memory block, a double link list
//
struct TMemoryBlock
{
     TMemoryBlock* pPrev;
     TMemoryBlock* pNext;
     long size;
     const char*   lpFileName;   // The filename
     int      nLine;             // The line number
     long     topTag;            // The watch tag at the beginning
     // followed by:
     //  BYTE            data[nDataSize];
     //  long     bottomTag;
     BYTE* pbData() const        // Return the pointer to the actual data
        { return (BYTE*) (this + 1); }
};

//
// The following internal function can be overwritten to change the behaivor
//
   
static void* MemAlloc(long size);    
static BOOL  MemFree(void* pMem);    
static void  LockDebugMem();   
static void  UnlockDebugMem();   
   
//
// Internal function
//
static BOOL RealCheckMemory();  // without call Enter/Leave critical Section
static BOOL CheckBlock(const TMemoryBlock* pBlock) ;

//
// Internal data, protected by the lock to be multi-thread safe
//
static long nTotalMem;    // Total bytes of memory allocated
static long nTotalBlock;  // Total # of blocks allocated
static TMemoryBlock head; // The head of the double link list


//
// critical section to lock \ unlock DebugMemory
// The constructor lock the memory, the destructor unlock the memory
//
class MemCriticalSection
{
public:
   MemCriticalSection()
   {
      LockDebugMem();
   }                                  
   
   ~MemCriticalSection()
   {
      UnlockDebugMem();
   }
};

static BOOL fDebugMemInited = FALSE; // whether the debug memory is initialized

//+----------------------------------------------------------------------------
//
// Function:  StartDebugMemory
//
// Synopsis:  Initialize the data for debug memory
//
// Arguments: None
//
// Returns:   
//
// History:   fengsun Created Header    4/2/98
//
//+----------------------------------------------------------------------------
static void StartDebugMemory()
{
   fDebugMemInited = TRUE;

   head.pNext = head.pPrev = NULL;
   head.topTag = MEMTAG;
   head.size = 0;
   nTotalMem = 0;
   nTotalBlock = 0;
}                




//+----------------------------------------------------------------------------
//
// Function:  MemAlloc
//
// Synopsis:  Allocate a block of memory.  This function should be overwriten
//            if different allocation method is used
//
// Arguments: long size - size of the memory
//
// Returns:   void* - the memory allocated or NULL
//
// History:   fengsun Created Header    4/2/98
//
//+----------------------------------------------------------------------------
static void* MemAlloc(long size) 
{ 
    return (HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY|HEAP_GENERATE_EXCEPTIONS, size));
}



//+----------------------------------------------------------------------------
//
// Function:    MemFree
//
// Synopsis:  Free a block of memory.  This function should be overwriten
//            if different allocation method is used
//
// Arguments: void* pMem - The memory to be freed
//
// Returns:   static BOOL - TRUE if succeeded
//
// History:   Created Header    4/2/98
//
//+----------------------------------------------------------------------------
static BOOL MemFree(void* pMem)
{ 
    return HeapFree(GetProcessHeap(), 0, pMem);
}

//
// Data / functions to provide mutual exclusion.
// Can be overwritten, if other methed is to be used.
//
static BOOL fLockInited = FALSE;   // whether the critical section is inialized
static CRITICAL_SECTION cSection;  // The critical section to protect the link list

static void InitLock()
{
   fLockInited = TRUE;
   InitializeCriticalSection(&cSection);
}

static void LockDebugMem()
{
   static int i = 0;
   if(!fLockInited)
      InitLock();
   EnterCriticalSection(&cSection);
}

static void UnlockDebugMem()
{
   LeaveCriticalSection(&cSection);
}




//+----------------------------------------------------------------------------
//
// Function:  AllocDebugMem
//
// Synopsis:  Process memory allocation request.
//            Check the link list.  Allocate a larger block.  
//            Record filename/linenumber, add tags and insert to the list
//
// Arguments: long size - Size of the memory to be allocated
//            const char* lpFileName - File name to be recorded
//            int nLine - Line number to be recorted
//
// Returns:   void* - The memory allocated. Ready to use by the caller
//
// History:   fengsun Created Header    4/2/98
//
//+----------------------------------------------------------------------------
void* AllocDebugMem(long size,const char* lpFileName,int nLine)
{
    if(!fDebugMemInited)
    {
        StartDebugMemory();
    }

    if(size<0)
    {
        ASSERTMSG(FALSE,TEXT("Negtive size for alloc"));
        return NULL;
    }

    if(size>1024*1024)
    {
        ASSERTMSG(FALSE, TEXT("Size for alloc is great than 1Mb"));
        return NULL;
    }

    if(size == 0)
    {
        TRACE(TEXT("Allocate memory of size 0"));
        return NULL;
    }


    //
    // Protect the access to the list
    //
    MemCriticalSection criticalSection;

    //
    // Check the link list first
    //
    if(!RealCheckMemory())
    {
        return NULL;
    }
              
    //
    // Allocate a large block to hold additional information
    //
    TMemoryBlock* pBlock = (TMemoryBlock*)MemAlloc(sizeof(TMemoryBlock)+size + TAGSIZE);
    if(!pBlock)                  
    {
        TRACE(TEXT("Outof Memory"));
        return NULL;
    }               

    //
    // record filename/line/size, add tag to the beginning and end
    //
    pBlock->size = size;
    pBlock->topTag = MEMTAG;   

    if (lpFileName)
    {
        pBlock->lpFileName = lpFileName;
    }
    else
    {
        pBlock->lpFileName = TEXT("");
    }

    pBlock->nLine = nLine;
    *(long*)(pBlock->pbData() + size) = MEMTAG;

    //
    // insert at head
    //
    pBlock->pNext = head.pNext;
    pBlock->pPrev = &head;  
    if(head.pNext)
      head.pNext->pPrev = pBlock; 
    head.pNext = pBlock;

    nTotalMem += size;
    nTotalBlock ++;

    return  pBlock->pbData();
}



//+----------------------------------------------------------------------------
//
// Function:  FreeDebugMem
//
// Synopsis: Free the memory allocated by AllocDebugMem
//           Check the link list, and the block to be freed.
//           Fill the block data with FREETAG before freed 
//
// Arguments: void* pMem - Memory to be freed
//
// Returns:   BOOL - TRUE for succeeded
//
// History:   fengsun Created Header    4/2/98
//
//+----------------------------------------------------------------------------
BOOL FreeDebugMem(void* pMem)
{
    if(!fDebugMemInited)
    {
        StartDebugMemory();
    }

    if(!pMem)
    {
        return FALSE;
    }            
  
    //
    // Get the lock
    //
    MemCriticalSection criticalSection;

    //
    // Get pointer to our structure
    //
    TMemoryBlock* pBlock =(TMemoryBlock*)( (char*)pMem - sizeof(TMemoryBlock));

    //
    // Check the block to be freed
    //
    if(!CheckBlock(pBlock))
    {
        ASSERTMSG(FALSE, TEXT("The memory to be freed is either corrupted or not allocated by us"));
        return FALSE;
    }

    //
    // Check the link list
    //
    if(!RealCheckMemory())
    {
        return FALSE;
    }

    //
    // remove the block from the list
    //
    pBlock->pPrev->pNext = pBlock->pNext;
    if(pBlock->pNext)
    {
      pBlock->pNext->pPrev = pBlock->pPrev;
    }
                 
    nTotalMem -= pBlock->size;
    nTotalBlock --;

    //
    // Fill the freed memory with 0xBD, leave the size/filename/lineNumber unchanged
    //
    memset(&pBlock->topTag,FREETAG,(size_t)pBlock->size + sizeof(pBlock->topTag)+ TAGSIZE);
    return MemFree(pBlock);
}



//+----------------------------------------------------------------------------
//
// Function:  void* ReAllocDebugMem
//
// Synopsis:  Reallocate a memory with a diffirent size
//
// Arguments: void* pMem - memory to be reallocated
//            long nSize - size of the request
//            const char* lpFileName - FileName to be recorded
//            int nLine - Line umber to be recorded
//
// Returns:   void* - new memory returned
//
// History:   fengsun Created Header    4/2/98
//
//+----------------------------------------------------------------------------
void* ReAllocDebugMem(void* pMem, long nSize, const char* lpFileName,int nLine)
{
   if(!fDebugMemInited)
      StartDebugMemory();

   if(!pMem)
   {
      return NULL;
   }            
      
   //
   // Allocate a new block, copy the information over and free the old block.
   //
   TMemoryBlock* pBlock =(TMemoryBlock*)( (char*)pMem - sizeof(TMemoryBlock));

   DWORD dwOrginalSize = pBlock->size;

   void* pNew = AllocDebugMem(nSize, lpFileName, nLine);
   if(pNew)
   {
       CopyMemory(pNew, pMem, ((DWORD)nSize < dwOrginalSize ? nSize : dwOrginalSize));
       FreeDebugMem(pMem);
   }
    
   return pNew;
}



//+----------------------------------------------------------------------------
//
// Function:  CheckDebugMem
//
// Synopsis:  Exported to external module.
//            Call this function, whenever, you want to check against 
//            memory curruption
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the memory is fine.
//
// History:   fengsun Created Header    4/2/98
//
//+----------------------------------------------------------------------------
BOOL CheckDebugMem()
{
   if(!fDebugMemInited)
      StartDebugMemory();

   MemCriticalSection criticalSection;

   return RealCheckMemory();                           
}



//+----------------------------------------------------------------------------
//
// Function:  RealCheckMemory
//
// Synopsis:  Go through the link list to check for memory corruption
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the memory is fine.
//
// History:   fengsun Created Header    4/2/98
//
//+----------------------------------------------------------------------------
static BOOL RealCheckMemory() 
{
   TMemoryBlock* pBlock = head.pNext;
   
   int nBlock =0;
   while(pBlock!=NULL)
   {
      if(!CheckBlock(pBlock))
      {
         return FALSE;
      }            
      
      pBlock = pBlock->pNext;
      nBlock++;
   }
                              
   if(nBlock != nTotalBlock)
   {
         ASSERTMSG(FALSE,TEXT("Memery corrupted"));
         return FALSE;
   }            

   return TRUE;                           
}
   


//+----------------------------------------------------------------------------
//
// Function:  CheckBlock
//
// Synopsis:  Check a block for memory corruption
//
// Arguments: const TMemoryBlock* pBlock - 
//
// Returns:   BOOL - TRUE, if the block is fine
//
// History:   fengsun Created Header    4/2/98
//
//+----------------------------------------------------------------------------
static BOOL CheckBlock(const TMemoryBlock* pBlock) 
{
   if(pBlock->topTag != MEMTAG)     // overwriten at top
   {
       if(pBlock->topTag == (FREETAG | (FREETAG <<8) | (FREETAG <<16) | (FREETAG <<24)))
       {
             TCHAR buf[1024];
             wsprintf(buf,TEXT("Memory in used after freed.  Allocated %d bytes:\n%s"),pBlock->size,pBlock->pbData());
             AssertMessage(pBlock->lpFileName,pBlock->nLine, buf);    // do not print the file name
       }
       else
       {
           ASSERTMSG(FALSE, TEXT("Memery overwriten from top"));
       }

       return FALSE;
   }            

   if(pBlock->size<0)
   {
         ASSERTMSG(FALSE, TEXT("Memery corrupted"));
         return FALSE;
   }            

   if(*(long*)(pBlock->pbData() +pBlock->size) != MEMTAG) // overwriten at bottom
   {
         TCHAR buf[1024];
         wsprintf(buf,TEXT("Memory overwriten.  Allocated %d bytes:\n%s"),pBlock->size,pBlock->pbData());
         AssertMessage(pBlock->lpFileName,pBlock->nLine, buf);    // do not print the file name
//         ASSERTMSG(FALSE, TEXT("Memery corrupted"));

         return FALSE;
   }            

   if(pBlock->pPrev && pBlock->pPrev->pNext != pBlock)
   {
         ASSERTMSG(FALSE, TEXT("Memery corrupted"));
         return FALSE;
   }            

   if(pBlock->pNext && pBlock->pNext->pPrev != pBlock)
   {
         ASSERTMSG(FALSE, TEXT("Memery corrupted"));
         return FALSE;
   }            
      
   return TRUE;
}  


//+----------------------------------------------------------------------------
//
// Function:  EndDebugMemory
//
// Synopsis:  Called before the program exits.  Report any unreleased memory leak
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    4/2/98
//
//+----------------------------------------------------------------------------
void EndDebugMemory()
{
   if(head.pNext != NULL || nTotalMem!=0 || nTotalBlock !=0)
   {
      TRACE1(TEXT("Detected memory leaks of %d blocks"), nTotalBlock);
      TMemoryBlock * pBlock;

      for(pBlock = head.pNext; pBlock != NULL; pBlock = pBlock->pNext)
      {
         TCHAR buf[256];
         wsprintf(buf,TEXT("Memory Leak of %d bytes:\n"),pBlock->size);
         TRACE(buf);
         AssertMessage(pBlock->lpFileName,pBlock->nLine, buf);    // do not print the file name
      }
      DeleteCriticalSection(&cSection);
   }
}                

#endif //#else defined(DEBUG_MEM)

#ifdef _DEBUG
//
// Call ExitDebugMem upon exit
//
class ExitDebugMem
{
public:
   ~ExitDebugMem()
      {EndDebugMemory();}
};

// force initialization early
#pragma warning(disable:4073)
#pragma init_seg(lib)

static ExitDebugMem exitDebugMem;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sainstall\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__E58CAB7F_B614_4282_94C0_A3FDBDF28200__INCLUDED_)
#define AFX_DLLDATAX_H__E58CAB7F_B614_4282_94C0_A3FDBDF28200__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__E58CAB7F_B614_4282_94C0_A3FDBDF28200__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\common\utils\eventlog.cpp ===
//+----------------------------------------------------------------------------
//
// File:eventlog.cpp     
//
// Module:     
//
// Synopsis: Implement eventlog helper class CEventLog
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:     Created    9/16/98
//
//+----------------------------------------------------------------------------

#include <windows.h>
#include "debug.h"
#include "eventlog.h"

//+----------------------------------------------------------------------------
//
// Function:  CEventLog::Open
//
// Synopsis:  
//      Register the specified event source.
//      Note that the registry entries must already exist.
//      HKLM\System\CurrentControlSet\Services\EventLog\Application\<pszEventSource>
//          Requires values "EventMessageFile" and "TypesSupported".
//
// Arguments: LPCTSTR lpSourceName - The source name must be a subkey of 
//                  a logfile entry under the EventLog key in the registry
//
// Returns:   BOOL - TRUE if succeed
//
// History:   Created Header    9/16/98
//
//+----------------------------------------------------------------------------
BOOL CEventLog::Open(LPCWSTR lpSourceName)
{
    ASSERT(lpSourceName != NULL);
    if (lpSourceName == NULL)
    {
        return FALSE;
    }

    ASSERT(m_hEventLog == NULL);  

    m_hEventLog = ::RegisterEventSource(NULL,  // local machine
                                        lpSourceName); // source name

    if (m_hEventLog == NULL)
    {
        TRACE2(("CEventLog::Open %ws failed, LastError = %d"), lpSourceName, GetLastError());
    }

    return m_hEventLog != NULL;
}




//+----------------------------------------------------------------------------
//
// Function:  CEventLog::ReportEvent
//
// Synopsis:  Writes an entry at the end of the event log.  Support upto 3 
//            parameters
//
// Arguments: WORD wType - see wType of ::ReportEvent
//            DWORD dwEventID - see dwEventID of ::ReportEvent
//            const TCHAR* pszS1 - The 1st string, default is NULL
//            const TCHAR* pszS2 - The 2st string, default is NULL
//            const TCHAR* pszS3 - The 3st string, default is NULL
//
// Returns:   BOOL - TRUE is succeed
//
// History:   Created Header    9/16/98
//
//+----------------------------------------------------------------------------
BOOL CEventLog::ReportEvent(WORD wType, DWORD dwEventID,
                          const TCHAR* pszS1,
                          const TCHAR* pszS2,
                          const TCHAR* pszS3)
{
    //
    // Set up an array of strings
    //
    const TCHAR* arString[3] = {pszS1, pszS2, pszS3};

    int iNumString = 0;   // number of parameters
    for (iNumString = 0; iNumString < 3; iNumString++) 
    {
        if (arString[iNumString] == NULL) 
        {
            break;
        }
    }

    
    ASSERT(m_hEventLog);

    if (m_hEventLog == NULL)
    {
        return FALSE;
    }

    BOOL fSucceed = ::ReportEvent(m_hEventLog,
                      wType,
                      0,        // event category  
                      dwEventID,
                      NULL,     // user security identifier
                      (WORD) iNumString,// number of strings to merge with message
                      0,        // size of binary data
                      arString, // array of strings to merge with message
                      NULL);    // address of binary data

    if (!fSucceed)
    {
        TRACE2(("CEventLog::ReportEvent failed for event id %d, LastError = %d"), 
            dwEventID, GetLastError());
    }

    return fSucceed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sainstall\helper.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      helper.h
//
//  Description:
//
//  [Implementation Files:]
//      helper.cpp
//
//  History:
//      Travis Nielsen   travisn   13-AUG-2001 Created
//      Travis Nielsen   travisn   20-AUG-2001 Added tracing functions
//
//
/////////////////////////////////////////////////////////////////////////

#pragma once

#include <string>
#include "stdafx.h"
#include "sainstallcom.h"
#include <msi.h>
#include <setupapi.h> // SetupPromptForDiskW
#include "SaInstall.h"


//Use the std namespace from <string> for using wstring
using namespace std;


//
// Product ID Code defined in the MSI used to detect if components are 
// installed
//
const LPCWSTR SAK_PRODUCT_CODE = L"{A4F8313B-0E21-478B-B289-BFB7736CA7AA}";




/////////////////////////////////////////////////////////////////////////
// Function definitions
/////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////
BOOL GetRegString(
    const HKEY hKey,        //[in] Key to look up in the registry
    const LPCWSTR wsSubKey, //[in] Subkey to look up
    const LPCWSTR wsValName,//[in] Value name
    wstring& wsVal);   //[out] Return data for this registry entry

/////////////////////////////////////////////////////////////////////////
void AppendPath(wstring &wsPath,//[in, out] Path on which to append the other path
                LPCWSTR wsAppendedPath);//[in] Path to be appended

/////////////////////////////////////////////////////////////////////////
BOOL bSAIsInstalled(const SA_TYPE installType);

/////////////////////////////////////////////////////////////////////////
HRESULT GetInstallLocation(
    wstring &wsLocationOfSaSetup);// [out] expected path to SaSetup.msi

/////////////////////////////////////////////////////////////////////////
HRESULT CreateHiddenConsoleProcess(
          const wchar_t *wsCommandLine);//[in] Command line to execute

/////////////////////////////////////////////////////////////////////////
void ReportError(BSTR *pbstrErrorString, //[out] error string
        const VARIANT_BOOL bDispError, //[in] display error dialogs
        const unsigned int errorID);   //[in] ID from resource strings

/////////////////////////////////////////////////////////////////////////
void TestWebSites(const VARIANT_BOOL bDispError, //[in] Display error dialogs?
                  BSTR* pbstrErrorString);//[in, out] Error string 

/////////////////////////////////////////////////////////////////////////
BOOL InstallingOnNTFS();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sainstall\helper.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      helper.cpp
//
//  Description:
//
//  Header File:
//      helper.h
//
//  History:
//      travisn   13-AUG-2001    Created
//      travisn   22-AUG-2001    Added file tracing
//      travisn   24-SEP-2001    Added application log error reporting
//////////////////////////////////////////////////////////////////////////////

#include "helper.h"
#include "satrace.h"

//
// Filename for SaSetup.msi
//
const LPCWSTR SETUP_FILENAME = L"SaSetup.msi";

//
// Key feature name for WEB
//
const LPCWSTR WEB_ID = L"WebBlade";

const LPCWSTR BACKSLASH = L"\\";

const LPCWSTR NTFS = L"NTFS";


//
// Constants for Keys, Values, and Data in the registry
//
const LPCWSTR SETUP_VERSION_KEY = L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup";
const LPCWSTR SAINSTALL_EVENT_KEY = L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\SAInstall";
const LPCWSTR SOURCEPATH_VALUE = L"SourcePath";
const LPCWSTR SERVER_APPLIANCE_KEY = L"SOFTWARE\\Microsoft\\ServerAppliance\\";
const LPCWSTR START_SITE_VALUE = L"StartSiteError";
const LPCWSTR INSTALL_TYPE_VALUE = L"InstallType";
const LPCWSTR EVENT_MESSAGE_VALUE = L"EventMessageFile";
const LPCWSTR TYPES_SUPPORTED_VALUE = L"TypesSupported";
const LPCWSTR SAINSTALL_DLL = L"sainstall.dll";
const LPCWSTR SA_APP_NAME = L"SAInstall";

HANDLE g_hEventLogHandle = NULL;
HMODULE g_resourceModule = NULL;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  GetRegString
//
//  Description:
//    Copied from %msi%\src\ca\mainca\ows.cpp
//    Get a string from the registry
//
//  Return:
//    Returns TRUE if the registry entry was found without error and
//    stored in the [out] value, and FALSE if the entry was not found
//    correctly.
//
//  history
//      travisn   2-AUG-2001  Some comments added
//--
//////////////////////////////////////////////////////////////////////////////
BOOL GetRegString(
    const HKEY hKey,        //[in] Key to look up in the registry
    const LPCWSTR wsSubKey, //[in] Subkey to look up
    const LPCWSTR wsValName,//[in] Value name
    wstring& wsVal)   //[out] Return data for this registry entry
{
    SATraceString ("Entering GetRegString");
    //
    // Initialize the variables as if we're not opening a sub key and
    // looking at the currentkey
    //
    HKEY hOpenKey = hKey;
    LRESULT lRes = ERROR_SUCCESS;
    BOOL bSubkeyOpened = FALSE;

    //
    // Check to see if we need to open the sub key
    //
    if(wsSubKey != NULL)  
    {
        //
        // Open the subkey
        //
        lRes = RegOpenKeyExW(hKey, wsSubKey, 0, KEY_READ, &hOpenKey);
        if (ERROR_SUCCESS != lRes)
        {
            //Couldn't find the registry entry, so return FALSE
            return FALSE;
        }
        //Found the subkey
        bSubkeyOpened = TRUE;
    }

    //
    // Check the type and size of the key
    //
    LPDWORD lpdw = NULL;
    DWORD dwType;
    DWORD dwStringSize = 0;
    lRes = RegQueryValueExW(hOpenKey, // handle to key
        wsValName,  // value name
        lpdw,       // reserved
        &dwType,    // Type of registry entry (ie. DWORD or SZ)
        NULL,       // data buffer
        &dwStringSize);//size of data buffer

    //
    // Check to make sure that the registry entry is type REG_SZ,
    // then read it into the return value
    //

    BOOL bReturn = FALSE;
    if ((ERROR_SUCCESS == lRes) &&
        (REG_SZ == dwType || 
         REG_EXPAND_SZ == dwType))
    {   //
        // Make sure the return string buffer is big enough to hold the entry
        // Add 2 for the null character
        //
        WCHAR* regData = new WCHAR[dwStringSize + 2];

        //Look up the value and insert it into the return string
        lRes = RegQueryValueExW(hOpenKey, 
            wsValName, 
            lpdw, 
            &dwType,
            (LPBYTE)regData, //Return string
            &dwStringSize);

        wsVal = regData;
        delete[] regData;
        //Check for success reading the registry entry
        bReturn = (ERROR_SUCCESS == lRes);
    }

    //Close the subkey if it was opened
    if (bSubkeyOpened)
    {
        RegCloseKey(hOpenKey);
    }

    SATraceString ("Exiting GetRegString");
    return bReturn;
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  AppendPath
//
//  Description:
//    Make sure the path has a terminating backslash, then append
//    the additional path on the end
//
//  history
//      Travis Nielsen   travisn   2-AUG-2001
//--
//////////////////////////////////////////////////////////////////////////////
void AppendPath(wstring &wsPath,//[in, out] Path on which to append the other path
                LPCWSTR wsAppendedPath)//[in] Path to be appended
{
    SATraceString ("Entering AppendPath");
    //Check for the terminating backslash on the path
    int nLen = wsPath.length();
    if (L'\\' != wsPath.at(nLen - 1))
    {
      wsPath += BACKSLASH;
    }

    //Append the paths together
    wsPath += wsAppendedPath;
    SATraceString ("Exiting AppendPath");
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  bSAIsInstalled
//
//  Description:
//    Detects if a server appliance is installed. The key feature(s) for a
//    Server Appliance type is (are) queried in MSI to see if it is installed.
//    
//    For WEB, the key is WebBlade
//
//  Returns:
//    If the key feature is installed, returns true
//    Otherwise, returns false
//
//  history
//      Travis Nielsen   travisn   8-AUG-2001
//--
//////////////////////////////////////////////////////////////////////////////
BOOL bSAIsInstalled(const SA_TYPE installType)
{
    SATraceString ("Entering bSAIsInstalled");
    //
    // Assume either the product is not installed, or 
    // an unsupported installType was requested until proven otherwise
    //
    BOOL bReturn = FALSE;

    switch (installType)
    {
    case WEB:
    
        SATraceString ("  Query the installation state of WebBlade");
        //Key feature state for WEB
        INSTALLSTATE webState;

        //Get the state of the WebBlade feature
        webState = MsiQueryFeatureState(SAK_PRODUCT_CODE,
                                     WEB_ID);

        //Return TRUE if WebBlade is installed locally
        if (webState == INSTALLSTATE_LOCAL)
        {
            bReturn = TRUE;
            SATraceString ("  WebBlade is installed");
        }
        break;
    }

    if (!bReturn)
        SATraceString ("  Feature is not installed");

    SATraceString ("Exiting bSAIsInstalled");
    return bReturn;
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  getInstallLocation
//
//  Description:
//    Get the path to SaSetup.msi in %system32%.  
//
//  history
//      Travis Nielsen   travisn   23-JUL-2001
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT GetInstallLocation(
    wstring &wsLocationOfSaSetup)// [out] expected path to SaSetup.msi
{
    SATraceString (" Entering GetInstallLocation");
    //initialize the HRESULT
    HRESULT hr = S_OK;

    //
    //Check to see if sasetup.msi is in the path (ie. In %system32%)
    //

    WCHAR wsBuffer[MAX_PATH+1];
    UINT nBufferLength = GetWindowsDirectory(wsBuffer, MAX_PATH+1);
    if (nBufferLength == 0)
    {   //Check in the default location for a chance at finding sasetup.msi
        wsLocationOfSaSetup = L"C:\\Windows";
    }
    else
    {   //Copy the Windows directory from the buffer
        wsLocationOfSaSetup = wsBuffer;
    }
    
    AppendPath(wsLocationOfSaSetup, L"system32\\");
    wsLocationOfSaSetup += SETUP_FILENAME;

    //Now wsLocationOfSaSetup is something like C:\Windows\system32\sasetup.msi

    if (-1 == ::GetFileAttributesW(wsLocationOfSaSetup.data()))
    {
        //Could not find setup at the expected path
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        SATraceString ("  Did NOT find sasetup.msi in system32");
    }

    SATraceString (" Exiting GetInstallLocation");
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CreateHiddenConsoleProcess
//
//  Description:
//    Copied and adapted from %fp%\server\source\ocmsetup\ocmsetup.cpp
//    Take the command line passed and create a hidden console
//    process to execute it.
//
//  history
//      Travis Nielsen   travisn   23-JUL-2001
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT CreateHiddenConsoleProcess(
          const wchar_t *wsCommandLine)//[in] Command line to execute
{
    SATraceString ("  Entering CreateHiddenConsoleProcess");
    
    //
    // Create a hidden console process
	//
	DWORD error = 0;
    PROCESS_INFORMATION pi;
    STARTUPINFOW si;
    memset( &si, 0, sizeof(si) );
    si.cb          = sizeof(si);
    si.dwFlags     = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_HIDE;
    DWORD dwCreationFlags = NORMAL_PRIORITY_CLASS |
                  DETACHED_PROCESS;    // no console

    DWORD dwErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );
            
    SATraceString ("   Calling CreateProcess");
    BOOL bStatus = ::CreateProcess (
                       0,              // name of executable module
                       (LPWSTR)wsCommandLine, // command line string
                       0,              // SD
                       0,              // SD
                       FALSE,          // handle inheritance option
                       dwCreationFlags,//creation flags
                       0,              // new environment block
                       0,              // current directory name
                       &si, // startup information
                       &pi);// process information

    SetErrorMode( dwErrorMode );

    if (bStatus)
    {
        SATraceString ("   CreateProcess was successful");

        //
        // wait for the  process to exit now, or a quit event
        //
        DWORD dwRetVal = WaitForSingleObject (pi.hProcess, INFINITE);

        if (WAIT_OBJECT_0 == dwRetVal)
        {
            SATraceString  ("    Finished waiting for sasetup.msi");
            error = S_OK;
        }
        else if (WAIT_FAILED == dwRetVal)
        {
            SATraceString ("    Error waiting for sasetup.msi: WAIT_FAILED");
            error = E_FAIL;
        }
        else
        {
            SATraceString ("    Error waiting for sasetup.msi");
            error = E_FAIL;
        }

        CloseHandle(pi.hProcess);
    }
    else
    {   //An error occurred in CreateProcess
        SATraceString ("   CreateProcess reported an error");
        error = HRESULT_FROM_WIN32(GetLastError());
    }
    
    SATraceString ("  Exiting CreateHiddenConsoleProcess");
	return error;
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  InstallingOnNTFS
//
//  Description:
//      Check to see if the system partition is NTFS.
//
//  history
//      Travis Nielsen   travisn   22-JAN-2002
//--
//////////////////////////////////////////////////////////////////////////////
BOOL InstallingOnNTFS()
{
    BOOL bIsNTFS = FALSE;
    WCHAR wsFileSystem[MAX_PATH+1];

    if (GetVolumeInformation(
            NULL,//Get information for the root of the current directory
            NULL,//Don't need the volume name
            0,
            NULL,//Don't need the volume serial number
            NULL,//Don't need the max file length
            NULL,//Don't need the file system flags
            wsFileSystem,
            MAX_PATH
        ))
    {
        if (_wcsicmp(wsFileSystem, NTFS) == 0)
        {
            bIsNTFS = TRUE;
            SATraceString ("File system is NTFS");
        }
        else
            SATraceString ("File system is NOT NTFS");
    }

    return bIsNTFS;
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  AddEventSource
//
//  Description:
//      Registry entries are created to enable writing messages
//      to the event log.  A key is created with the necessary entries at:
//      HKLM\SYSTEM\CurrentControlSet\Services\EventLog\Application\SAInstall
//
//  history
//      Travis Nielsen   travisn   18-SEP-2001
//--
//////////////////////////////////////////////////////////////////////////////
void AddEventSource()
{
    SATraceString ("Entering AddEventSource");

    HKEY hkey = NULL; 
    DWORD dwData; 
    WCHAR wsBuf[80]; 
    do
    {   //
        // Add source name as a subkey under the Application 
        // key in the EventLog registry key. 
        //
        if (RegCreateKey(HKEY_LOCAL_MACHINE, 
                SAINSTALL_EVENT_KEY, 
                &hkey)) 
        {
            SATraceString ("  Could not create the registry key to register SAInstall."); 
            break;
        }
     
        // Set the name of the message file. 
        wcscpy(wsBuf, SAINSTALL_DLL); 
     
        // Add the name to the EventMessageFile subkey. 
        if (RegSetValueEx(hkey,             // subkey handle 
                EVENT_MESSAGE_VALUE,       // value name 
                0,                        // must be zero 
                REG_EXPAND_SZ,            // value type 
                (LPBYTE) wsBuf,           // pointer to value data 
                (wcslen(wsBuf)+1)*sizeof(WCHAR)))// length of value data 
        {
            SATraceString (" Could not set the event message file."); 
            break;
        }
     
        // Set the supported event types in the TypesSupported subkey. 
        dwData = EVENTLOG_ERROR_TYPE | 
                 EVENTLOG_WARNING_TYPE | 
                 EVENTLOG_INFORMATION_TYPE; 
     
        if (RegSetValueEx(hkey,      // subkey handle 
                TYPES_SUPPORTED_VALUE,// value name 
                0,                 // must be zero 
                REG_DWORD,         // value type 
                (LPBYTE) &dwData,  // pointer to value data 
                sizeof(DWORD)))    // length of value data 
        {
            SATraceString ("  Could not set the supported types."); 
            break;
        }

    } while (false);

    RegCloseKey(hkey); 
    SATraceString ("Exiting AddEventSource");
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  WriteErrorToEventLog
//
//  Description:
//    An error has occurred during the setup and will be reported to the
//    system application log.
//
//  history
//      Travis Nielsen   travisn   10-SEP-2001
//--
//////////////////////////////////////////////////////////////////////////////
void WriteErrorToEventLog(const DWORD nErrorID)//[in] 
{
    SATraceString ("Entering WriteErrorToEventLog");

    //Register with the event log if it hasn't been done already
    if (g_hEventLogHandle == NULL)
    {
        SATraceString ("  Registering with the event log");
        AddEventSource();
        g_hEventLogHandle = RegisterEventSource(NULL, // uses local computer 
                                              SA_APP_NAME);// source name 
    }

    if (g_hEventLogHandle == NULL) 
    {   //Could not register the event source.
        SATraceString ("  Could not register with the event log");
    }
    //Report the event to the log
    else if (ReportEventW(
                g_hEventLogHandle,   // event log handle 
                EVENTLOG_ERROR_TYPE, // event type 
                0,                   // category zero 
                nErrorID,            // event identifier 
                NULL,                // no user security identifier 
                0,                   // one substitution string 
                0,                   // no data 
                NULL,                // pointer to string array 
                NULL))               // pointer to data 
    {
        SATraceString ("  Reported the error to the event log");
    }
    else
    {   
        SATraceString("  Could not report the error to the event log");
    }

    SATraceString ("Exiting WriteErrorToEventLog");
} 

//////////////////////////////////////////////////////////////////////////////
//++
//
//  reportError
//
//  Description:
//    An error has occurred during the setup and must be reported, either
//    simply by appending it to the error string, or displaying a
//    dialog box. Also, add the error to the log file:
//    %winnt%\tracing\SAINSTALL.LOG
//
//  history
//      Travis Nielsen   travisn   23-JUL-2001
//--
//////////////////////////////////////////////////////////////////////////////
void ReportError(BSTR *pbstrErrorString, //[out] error string
        const VARIANT_BOOL bDispError, //[in] display error dialogs
        const unsigned int nErrorID)   //[in] ID from resource strings
{
    SATraceString ("Entering ReportError");

    //Write the error to the event log
    WriteErrorToEventLog(nErrorID);

    //
    // Load the message library module if it has not already been loaded.
    //
    if (g_resourceModule == NULL)
    {   
        g_resourceModule = LoadLibraryEx(
                SAINSTALL_DLL,
                NULL,
                LOAD_LIBRARY_AS_DATAFILE | DONT_RESOLVE_DLL_REFERENCES);

        if (g_resourceModule == NULL)
        {
            SATraceString ("  Could not open resource module");
            return;
        }
    }

    //
    // Load the message from the resource library
    //
    TCHAR* pwsMessage = NULL;
    DWORD dwLen;
    DWORD flags = FORMAT_MESSAGE_ALLOCATE_BUFFER |
                  FORMAT_MESSAGE_IGNORE_INSERTS |
                  FORMAT_MESSAGE_FROM_HMODULE;

    dwLen = FormatMessage(flags,
                            g_resourceModule,
                            static_cast<DWORD>(nErrorID),
                            0,
                            reinterpret_cast<LPTSTR>(&pwsMessage),
                            0,
                            NULL );
    if (dwLen == 0)
    {
        SATraceString ("  Could not read message in ReportError");
        return;
    }
   
    //
    // Append the new error to the error string
    //
    if (*pbstrErrorString == NULL)
    {
        //Initialize the string since this is the first error
        *pbstrErrorString = SysAllocString(pwsMessage);
        SATraceString ("  Assigned first error to pbstrErrorString");
    }
    else
    {
        //Append the error to the end of any errors that may already be present
        USES_CONVERSION;
        CComBSTR bstrDelim("\r\n");
        CComBSTR bstrOldError(*pbstrErrorString);

        bstrOldError.AppendBSTR(bstrDelim);
        bstrOldError.Append(pwsMessage);
        SysFreeString(*pbstrErrorString);
        *pbstrErrorString = SysAllocString(bstrOldError.m_str);
        SATraceString ("  Appended multiple error to pbstrErrorString");
    }
    

    //
    // If we need to display error dialog boxes,
    // display the new error
    //
    if (bDispError)
    {
       SATraceString ("  Attended mode - Display the error");

       //Load the error dialog title string
       CComBSTR bstrTitle;
       bstrTitle.LoadString(IDS_ERROR_TITLE);

       //Display new error
       MessageBoxW(NULL, 
            pwsMessage, //Error text
            bstrTitle.m_str, //Error title
            0);//Only show the OK button
    }

    LocalFree(pwsMessage);
    SATraceString ("Exiting ReportError");
}

///////////////////////////////////////////////////////////////////////////////
//++
//
//  TestWebSites
//
//  Description:
//    This function should be called at the very end of installation after
//    SASetup.msi has completed execution.  It checks entries in the 
//    registry to see if the Administration site started
//    successfully.  Each bit in the registry entry indicates whether
//    a website started successfully.  For example, if 
//    StartSiteError = 3, two corresponding website for bits 0 and 1
//    failed to start.
//
//  history
//    Travis Nielsen   travisn   23-JUL-2001
//--
///////////////////////////////////////////////////////////////////////////////
void TestWebSites(const VARIANT_BOOL bDispError, //[in] Display error dialogs?
                  BSTR* pbstrErrorString)//[in, out] Error string 
{
    SATraceString ("Entering TestWebSites");
    wstring wsErrors;
    unsigned long errors = 0;

	//
    // Check the registry entry at 
    // HKLM\SOFTWARE\Microsoft\ServerAppliance\StartSiteError
    // to see if SaSetup.msi reported any errors starting the websites.
    // This entry is created by a script called by SaSetup.msi
    //
    if (GetRegString(HKEY_LOCAL_MACHINE,
        SERVER_APPLIANCE_KEY,
        START_SITE_VALUE, 
        wsErrors))
    {
        //
        // Errors were reported during installation.
        // Convert the string to a numerical form.
        //
        errors = wcstoul(wsErrors.data(), NULL, 10);
    }

    //The mask for the Administration site failing to start (bit 0)
    const unsigned long ADMIN_SITE_MASK = 1;

    if (errors & ADMIN_SITE_MASK)
    {
        ReportError(pbstrErrorString, bDispError, IDS_ADMIN_SITE_STOPPED);
    }

    SATraceString ("Exiting TestWebSites");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sainstall\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sainstall\resource.h ===
//{{NO_DEPENDENCIES}}
// Used by SaInstallCom.rc
//
#include "sainstmc.h"

#define IDS_PROJNAME                    100
#define IDS_SAINSTALL_DESC              101
#define IDS_ERROR_TITLE                 102
#define IDR_SaInstall                   103
#define IDS_PRODUCT_NAME                104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sainstall\metabaseobject.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//     MetabaseObject.cpp
//
//  Description:
//     Copied from %fp%\server\source\msiis\metabase.cpp
//     Opens the Metabse for accessing information about
//     IIS.  For example, to make sure it is installed correctly
//     and make sure ASP is turned on.
//
//  Header File:
//      MetabaseObject.h
//
//  History:
//      travisn    2-AUG-2001    Copied and comments added
//
//////////////////////////////////////////////////////////////////////////////


#include "MetabaseObject.h"

/////////////////////////////////////////////////////////////////////////
// CMetabaseObject::~CMetabaseObject
//
// Description:
//    Destructor for the Metabase object
//
/////////////////////////////////////////////////////////////////////////
CMetabaseObject::~CMetabaseObject()
{
    if (m_pIAdmCom)
    {
        if (m_isOpen)
            m_pIAdmCom->CloseKey(m_handle);

        m_pIAdmCom->Release();
        m_pIAdmCom = 0;
    }
}

/////////////////////////////////////////////////////////////////////////
// CMetabaseObject::init
//
// Description:
//    Initalize the metabase for access
//
/////////////////////////////////////////////////////////////////////////
HRESULT CMetabaseObject::init()
{
    if (m_pIAdmCom)
        return S_OK;
    return CoCreateInstance(
        CLSID_MSAdminBase,
        NULL,
        CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
        IID_IMSAdminBase,
        (void **) &m_pIAdmCom );
}

/////////////////////////////////////////////////////////////////////////
// CMetabaseObject::openObject
//
// Description:
//    Open this metabase object with the path given
//
/////////////////////////////////////////////////////////////////////////
HRESULT CMetabaseObject::openObject(const WCHAR *path)
{
    HRESULT hr = S_OK;
    if (FAILED(hr = init()))
        return hr;

    if (m_isOpen)
    {
        if (FAILED(hr = closeObject()))
            return hr;
    }

    hr = m_pIAdmCom->OpenKey(
        METADATA_MASTER_ROOT_HANDLE,
        path,
        METADATA_PERMISSION_READ,
        60000,
        &m_handle);
    
    if (FAILED(hr))
        return hr;
    m_isOpen = TRUE;
    return hr;
}

/////////////////////////////////////////////////////////////////////////
// CMetabaseObject::closeObject
//
// Description:
//    Close this metabase object
//
/////////////////////////////////////////////////////////////////////////
HRESULT CMetabaseObject::closeObject()
{
    if (!m_isOpen)
        return S_FALSE;
    HRESULT hr = m_pIAdmCom->CloseKey(m_handle);
    if (FAILED(hr))
        return hr;
    m_isOpen = FALSE;
    return hr;
}

/////////////////////////////////////////////////////////////////////////
// CMetabaseObject::getData
//
// Description:
//    This method does not appear necessary for SaInstall
//
//HRESULT CMetabaseObject::getData(
//    DWORD property,
//    Wstring& value,
//    DWORD userType,
//    LPCWSTR path,
//    BOOL inherited,
//    DWORD dataType)
//{
//    METADATA_RECORD metaDataRecord;
//    metaDataRecord.dwMDIdentifier = property;
//    metaDataRecord.dwMDDataType   = dataType;
//    metaDataRecord.dwMDUserType   = userType;
//    metaDataRecord.dwMDAttributes = inherited ? 
//        METADATA_INHERIT | METADATA_PARTIAL_PATH : 0;
//    metaDataRecord.dwMDDataLen    = value.numBytes();
//    metaDataRecord.pbMDData       = (unsigned char *)value.data();
//    DWORD metaDataLength = 0;
//    HRESULT hr = m_pIAdmCom->GetData(m_handle,
//        path, &metaDataRecord, &metaDataLength);
//    
//    // See if we need a bigger buffer
//    if (!FAILED(hr))
//        return hr;
//    if (ERROR_INSUFFICIENT_BUFFER != hr &&
//        ERROR_INSUFFICIENT_BUFFER != (hr & 0xFFFF))
//        return hr;
//    value.makeBigger(metaDataLength);
//    metaDataRecord.dwMDDataLen    = value.numBytes();
//    metaDataRecord.pbMDData       = (unsigned char *)value.data();
//    return m_pIAdmCom->GetData(m_handle,
//        path, &metaDataRecord, &metaDataLength);
//}

/////////////////////////////////////////////////////////////////////////
// CMetabaseObject::enumerateObjects
//
// Description:
//    This method does not appear necessary for SaInstall
//
//HRESULT CMetabaseObject::enumerateObjects(
//    LPCWSTR pszMDPath,
//    LPWSTR pszMDName,   // at least METADATA_MAX_NAME_LEN long
//    DWORD dwMDEnumKeyIndex)
//{
//    return m_pIAdmCom->EnumKeys(m_handle,
//        pszMDPath,
//        pszMDName,
//        dwMDEnumKeyIndex);
//}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sainstall\metabaseobject.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//     MetabaseObject.h 
//
//  Description:
//     Copied from %fp%\server\source\msiis\metabase.cpp
//     Opens the Metabse for accessing information about
//     IIS.  For example, to make sure it is installed correctly
//     and make sure ASP is turned on.
//
//  Implementation Files:
//      MetabaseObject.cpp
//
//  History:
//      travisn    2-AUG-2001    Created
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include <iiscnfg.h>       // for MD_* constants 
#include <iadmw.h>         // METADATA_HANDLE et al
#include <string>

//////////////////////////////////////////////////////////////////////////////
// CMetabaseObject definition
//////////////////////////////////////////////////////////////////////////////

class CMetabaseObject
{
public:
    /////////////////////////////////////////////////////////////////////////
    //Default Constructor
    CMetabaseObject()
        : m_pIAdmCom(0)
        , m_isOpen(FALSE)
        , m_handle(0)
    {
    }

    /////////////////////////////////////////////////////////////////////////
    //Destructor
    ~CMetabaseObject();

    /////////////////////////////////////////////////////////////////////////
    HRESULT init();

    /////////////////////////////////////////////////////////////////////////
    HRESULT openObject(const WCHAR *path);

    /////////////////////////////////////////////////////////////////////////
    HRESULT closeObject();

    /////////////////////////////////////////////////////////////////////////
    //HRESULT getData(
    //    DWORD property,
    //    Wstring& value,
    //    DWORD userType = IIS_MD_UT_SERVER,
    //    LPCWSTR path = 0,
    //    BOOL inherited = TRUE,
    //    DWORD dataType = STRING_METADATA);
    
    /////////////////////////////////////////////////////////////////////////
    //HRESULT enumerateObjects(
    //    LPCWSTR pszMDPath,
    //    LPWSTR pszMDName,   // at least METADATA_MAX_NAME_LEN long
    //    DWORD dwMDEnumKeyIndex);
    
private:
    /////////////////////////////////////////////////////////////////////////
    IMSAdminBase    *m_pIAdmCom;
    METADATA_HANDLE  m_handle;
    BOOL             m_isOpen;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sainstall\sainstall.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      SaInstall.h: Definition of the SaInstall class
//
//  Description:
//      Defines the 3 methods in ISaInstall to provide 
//      installation and uninstallation which prompt for the
//      Windows CD if necessary and perform some other error
//      checking
//
//  [Documentation:]
//      name-of-documentation-file
//
//  [Implementation Files:]
//      SaInstall.cpp
//
//  History:
//      Travis Nielsen   travisn   23-JUL-2001
//
//
/////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// SaInstall

class SaInstall : 
	public IDispatchImpl<ISaInstall, &IID_ISaInstall, &LIBID_SAINSTALLCOMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<SaInstall,&CLSID_SaInstall>
{
public:
	SaInstall() {}
BEGIN_COM_MAP(SaInstall)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISaInstall)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(SaInstall) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_SaInstall)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
// ISaInstall

    //Installs a Server Appliance solution
	STDMETHOD(SAInstall)(
			SA_TYPE installType,     //[in] Determines which type of solution to install
			BSTR bstrDiskName,       //[in] The name of the CD that needs to be inserted
			VARIANT_BOOL bDispError, //[in] Whether the component displays error dialogs.
			VARIANT_BOOL bUnattended,//[in] Whether the component displays any UI.
			BSTR* bstrErrorString);//[out, retval] Error string returned if install is not successful

	//UnInstalls a specific Server Appliance solution
	STDMETHOD(SAUninstall)(
        SA_TYPE installType,  //[in] Determines which type of solution to uninstall
        BSTR* bstrErrorString);//[out, retval] Error string returned if install is not successful

    //Detects if a type of SAK solution is currently installed
    STDMETHOD(SAAlreadyInstalled)(
		SA_TYPE installedType,//[in] The type to query if it is installed
        VARIANT_BOOL *pbInstalled);//[out, retval] Error string
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sainstall\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__BAB94C5C_59E9_4A7B_A78D_AC8163AFF809__INCLUDED_)
#define AFX_STDAFX_H__BAB94C5C_59E9_4A7B_A78D_AC8163AFF809__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <crtdbg.h>
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__BAB94C5C_59E9_4A7B_A78D_AC8163AFF809__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\drivers\cominterfaces\internal.h ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

    #### ##   # ###### ##### #####  ##   #   ###   ##       ##   ##
     ##  ###  #   ##   ##    ##  ## ###  #   ###   ##       ##   ##
     ##  #### #   ##   ##    ##  ## #### #  ## ##  ##       ##   ##
     ##  # ####   ##   ##### #####  # ####  ## ##  ##       #######
     ##  #  ###   ##   ##    ####   #  ### ####### ##       ##   ##
     ##  #   ##   ##   ##    ## ##  #   ## ##   ## ##    ## ##   ##
    #### #    #   ##   ##### ##  ## #    # ##   ## ##### ## ##   ##

Abstract:

    This header contains all definitions that are internal
    to the COM interfaces DLL.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    User mode only.

Notes:

--*/

#define ATLASSERT(x)
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include "resource.h"
#include <winioctl.h>
#include "saio.h"
#include "sacom.h"
#include "sadisplay.h"
#include "sakeypad.h"
#include "sanvram.h"


HANDLE
OpenSaDevice(
    ULONG DeviceType
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\drivers\cominterfaces\resource.h ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

    #####  #####  ###   #####  ##  ## #####   ####  #####    ##   ##
    ##  ## ##    ##  # ##   ## ##  ## ##  ## ##   # ##       ##   ##
    ##  ## ##    ###   ##   ## ##  ## ##  ## ##     ##       ##   ##
    #####  #####  ###  ##   ## ##  ## #####  ##     #####    #######
    ####   ##      ### ##   ## ##  ## ####   ##     ##       ##   ##
    ## ##  ##    #  ## ##   ## ##  ## ## ##  ##   # ##    ## ##   ##
    ##  ## #####  ###   #####   ####  ##  ##  ####  ##### ## ##   ##

Abstract:

    This header contains all resource definitions for the COM interface DLL.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    Kernel mode only.

Notes:


--*/

#define IDR_SERVERAPPLIANCE             100
#define IDR_SANVRAM                     101
#define IDR_SADISPLAY                   103
#define IDR_SAKEYPAD                    104
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sainstall\sainstallcom.cpp ===
//
// sainstallcom.cpp : Implementation of DLL Exports.
//

// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for sainstallcom.idl by adding the following 
//      files to the Outputs.
//          sainstallcom_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f sainstallcomps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "sainstallcom.h"
#include "dlldatax.h"

#include "sainstallcom_i.c"
#include "SaInstall.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SaInstall, SaInstall)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_SAINSTALLCOMLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry
STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    HRESULT hr = _Module.RegisterServer(TRUE);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\drivers\cominterfaces\sacom.cpp ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

     ###    ###    ####   #####  ##    ##     ####  #####  #####
    ##  #   ###   ##   # ##   ## ###  ###    ##   # ##  ## ##  ##
    ###    ## ##  ##     ##   ## ########    ##     ##  ## ##  ##
     ###   ## ##  ##     ##   ## # ### ##    ##     ##  ## ##  ##
      ### ####### ##     ##   ## #  #  ##    ##     #####  #####
    #  ## ##   ## ##   # ##   ## #     ## ## ##   # ##     ##
     ###  ##   ##  ####   #####  #     ## ##  ####  ##     ##

Abstract:

    This module contains the basic DLL exports for the
    COM interfaces DLL.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    User mode only.

Notes:

--*/

#include "internal.h"
#include <initguid.h>
#include "sacom_i.c"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SaNvram, CSaNvram)
OBJECT_ENTRY(CLSID_SaDisplay, CSaDisplay)
OBJECT_ENTRY(CLSID_SaKeypad, CSaKeypad)
END_OBJECT_MAP()


extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        _Module.Init(ObjectMap, hInstance, &LIBID_SACOMLib);
        DisableThreadLibraryCalls(hInstance);
    } else if (dwReason == DLL_PROCESS_DETACH) {
        _Module.Term();
    }
    return TRUE;
}


STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}


STDAPI DllRegisterServer(void)
{
    return _Module.RegisterServer(TRUE);
}


STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\drivers\cominterfaces\sadisplay.h ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

     ###    ###   #####   ####  ###  #####  ##      ###   ##  ##    ##   ##
    ##  #   ###   ##  ##   ##  ##  # ##  ## ##      ###   ##  ##    ##   ##
    ###    