MEWAVEFILTER)pwf;
        LoadString(pdi->hinst, IDS_ACM_DRIVER_FORMAT_VOLUME, ach, SIZEOF(ach));
        u = wsprintf( szFilter, ach,
                 (WORD)(((pwfVol->dwVolume * 100) / 0x10000)) );
        return( u );
    }
    else if (echoIsValidFilter(pwf))
    {
        pwfEcho = (LPECHOWAVEFILTER)pwf;
        LoadString(pdi->hinst, IDS_ACM_DRIVER_FORMAT_ECHO, ach, SIZEOF(ach));
        u = wsprintf( szFilter, ach,
                 (WORD)(((pwfEcho->dwVolume * 100) / 0x10000)),
                     (WORD)pwfEcho->dwDelay );
        return( u );
    }
    return ( 0 );
} // acmdFilterDetailsToString()

#endif



//--------------------------------------------------------------------------;
//
//  LRESULT acmdFilterDetails
//
//  Description:
//
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMFILTERDETAILS padf:
//
//      DWORD fdwDetails:
//
//  Return (LRESULT):
//
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFilterDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMFILTERDETAILS      padf,
    DWORD                   fdwDetails
)
{
    UINT                uFilterIndex;
    LPWAVEFILTER        pwf;
    LPVOLUMEWAVEFILTER  pwfVolume;
    LPECHOWAVEFILTER    pwfEcho;
    UINT                u;

    pwf = padf->pwfltr;

    //
    //
    //
    //
    //
    switch (ACM_FILTERDETAILSF_QUERYMASK & fdwDetails)
    {
        case ACM_FILTERDETAILSF_INDEX:
            //
            //  enumerate by index
            //
            //  for this converter, this is more code than necessary... just
            //  verify that the filter tag is something we know about
            //
            switch (padf->dwFilterTag)
            {
                case WAVE_FILTER_VOLUME:
                    if (ACM_DRIVER_MAX_VOLUME_FILTERS <= padf->dwFilterIndex)
                        return (ACMERR_NOTPOSSIBLE);

                    pwfVolume        = (LPVOLUMEWAVEFILTER)padf->pwfltr;
                    pwf->cbStruct    = sizeof(VOLUMEWAVEFILTER);
                    pwf->dwFilterTag = WAVE_FILTER_VOLUME;
                    pwf->fdwFilter   = 0;
                    pwfVolume->dwVolume = gdwFilterIndexToVolume[(UINT)padf->dwFilterIndex];
                    break;

                case WAVE_FILTER_ECHO:
                    if (ACM_DRIVER_MAX_ECHO_FILTERS <= padf->dwFilterIndex)
                        return (ACMERR_NOTPOSSIBLE);

                    pwfEcho             = (LPECHOWAVEFILTER)padf->pwfltr;
                    pwf->cbStruct       = sizeof(ECHOWAVEFILTER);
                    pwf->dwFilterTag    = WAVE_FILTER_ECHO;
                    pwf->fdwFilter      = 0;

                    uFilterIndex = (UINT)padf->dwFilterIndex;

                    u = uFilterIndex / ACM_DRIVER_NUM_DELAY;
                    pwfEcho->dwVolume = gdwFilterIndexToEchoVol[u];

                    u = uFilterIndex % ACM_DRIVER_NUM_DELAY;
                    pwfEcho->dwDelay = gdwFilterIndexToDelay[u];
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }

        case ACM_FILTERDETAILSF_FILTER:
            //
            //  must want to verify that the filter passed in is supported
            //  and return a string description...
            //
            switch (pwf->dwFilterTag)
            {
                case WAVE_FILTER_VOLUME:
                    if (!volumeIsValidFilter(pwf))
                        return (ACMERR_NOTPOSSIBLE);

                    break;

                case WAVE_FILTER_ECHO:
                    if (!echoIsValidFilter(pwf))
                        return (ACMERR_NOTPOSSIBLE);

                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        default:
            //
            //  don't know how to do the query type passed--return 'not
            //  supported'.
            //
            return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //  return only the requested info
    //
    //  the ACM will guarantee that the ACMFILTERDETAILS structure
    //  passed is at least large enough to hold everything in the base
    //  filter details structure...
    //
    //  get a nice friendly string for the filter we made
    //
    acmdFilterDetailsToString(pdi, pwf, padf->szFilter);


    //
    //  if they asked for more info than we know how to return, then
    //  set size of valid structure bytes to correct value.
    //
    padf->fdwSupport = ACMDRIVERDETAILS_SUPPORTF_FILTER;
    padf->cbStruct   = min(padf->cbStruct, sizeof(*padf));

    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFilterDetails()



//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamOpen
//
//  Description:
//      This function handles the ACMDM_STREAM_OPEN message. This message
//      is sent to initiate a new conversion stream. This is usually caused
//      by an application calling acmStreamOpen. If this function is
//      successful, then one or more ACMDM_STREAM_CONVERT messages will be
//      sent to convert individual buffers (user calls acmStreamConvert).
//
//      Note that an ACM driver will not receive open requests for ASYNC
//      or FILTER operations unless the ACMDRIVERDETAILS_SUPPORTF_ASYNC
//      or ACMDRIVERDETAILS_SUPPORTF_FILTER flags are set in the
//      ACMDRIVERDETAILS structure. There is no need for the driver to
//      check for these requests unless it sets those support bits.
//
//      If the ACM_STREAMOPENF_QUERY flag is set in the padsi->fdwOpen
//      member, then no resources should be allocated. Just verify that
//      the conversion request is possible by this driver and return the
//      appropriate error (either ACMERR_NOTPOSSIBLE or MMSYSERR_NOERROR).
//      The driver will NOT receive an ACMDM_STREAM_CLOSE for queries.
//
//      If the ACM_STREAMOPENF_NONREALTIME bit is NOT set, then conversion
//      must be done in 'real-time'. This is a tough one to describe
//      exactly. If the driver may have trouble doing the conversion without
//      breaking up the audio, then a configuration dialog might be used
//      to allow the user to specify whether the real-time conversion
//      request should be succeeded. DO NOT SUCCEED THE CALL UNLESS YOU
//      ACTUALLY CAN DO REAL-TIME CONVERSIONS! There may be another driver
//      installed that can--so if you succeed the call you are hindering
//      the performance of the user's system!
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      This structure will be passed back to all future stream messages
//      if the open succeeds. The information in this structure will never
//      change during the lifetime of the stream--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      A driver should return ACMERR_NOTPOSSIBLE if the conversion cannot
//      be performed due to incompatible source and destination formats.
//
//      A driver should return MMSYSERR_NOTSUPPORTED if the conversion
//      cannot be performed in real-time and the request does not specify
//      the ACM_STREAMOPENF_NONREALTIME flag.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamOpen
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    PSTREAMINSTANCE     psi;
    LPWAVEFORMATEX      pwfxSrc;
    LPWAVEFORMATEX      pwfxDst;
    LPWAVEFILTER        pwfltr;
    BOOL                fRealTime;


    //
    //
    //
    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;
    pwfltr  = padsi->pwfltr;

    fRealTime = (0 == (padsi->fdwOpen & ACM_STREAMOPENF_NONREALTIME));

    if( fRealTime )
    {
    	//
        //  We only do non-realtime conversions.
    	//  Return failure if we are asked for realtime.
        //
        return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  the most important condition to check before doing anything else
    //  is that this ACM driver can actually perform the conversion we are
    //  being opened for. this check should fail as quickly as possible
    //  if the conversion is not possible by this driver.
    //
    //  it is VERY important to fail quickly so the ACM can attempt to
    //  find a driver that is suitable for the conversion. also note that
    //  the ACM may call this driver several times with slightly different
    //  format specifications before giving up.
    //
    //  this driver first verifies that the source and destination formats
    //  are acceptable...
    //
    //  NOTE! for a 'filter only' driver, you only need to check one
    //  of the formats. the ACM will have already verified that the source
    //  and destination formats are equal. so if one is acceptable to this
    //  driver, they both are.
    //
    if (!pcmIsValidFormat(pwfxSrc))
    {
        //
        //  either the source or destination format is illegal for this
        //  driver--or the conversion between the formats can not be
        //  performed by this driver.
        //
        return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  now verify the filter..
    //
    if (!volumeIsValidFilter(pwfltr) && !echoIsValidFilter(pwfltr))
    {
        return (ACMERR_NOTPOSSIBLE);
    }



    //
    //  we have determined that the conversion requested is possible by
    //  this driver. now check if we are just being queried for support.
    //  if this is just a query, then do NOT allocate any instance data
    //  or create tables, etc. just succeed the call.
    //
    if (0 != (ACM_STREAMOPENF_QUERY & padsi->fdwOpen))
    {
        return (MMSYSERR_NOERROR);
    }


    //
    //  we have decided that this driver can handle the conversion stream.
    //  so we want to do _AS MUCH WORK AS POSSIBLE_ right now to prepare
    //  for converting data. any resource allocation, table building, etc
    //  that can be dealt with at this time should be done.
    //
    //  THIS IS VERY IMPORTANT! all ACMDM_STREAM_CONVERT messages need to
    //  be handled as quickly as possible.
    //
    //

    //
    //  we have decided that this driver can handle the conversion stream.
    //  so we want to do _AS MUCH WORK AS POSSIBLE_ right now to prepare
    //  for converting data. any resource allocation, table building, etc
    //  that can be dealt with at this time should be done.
    //
    //  THIS IS VERY IMPORTANT! all ACMDM_STREAM_CONVERT messages need to
    //  be handled as quickly as possible.
    //
    //  this driver allocates a small instance structure for each stream
    //
    //
    psi = (PSTREAMINSTANCE)LocalAlloc(LPTR, sizeof(*psi));
    if (NULL == psi)
    {
        return (MMSYSERR_NOMEM);
    }


    //
    //  fill out our instance structure
    //
    //  this driver stores a pointer to the conversion function that will
    //  be used for each conversion on this stream. we also store a
    //  copy of the _current_ configuration of the driver instance we
    //  are opened on. this must not change during the life of the stream
    //  instance.
    //
    //  this is also very important! if the user is able to configure how
    //  the driver performs conversions, the changes should only affect
    //  future open streams. all current open streams should behave as
    //  they were configured during the open.
    //

    //
    //
    //
    //
    if (WAVE_FILTER_VOLUME == pwfltr->dwFilterTag)
    {
        psi->fnConvert      = msfilterVolume;
        psi->fdwConfig      = pdi->fdwConfig;
        psi->hpbHistory     = NULL;
        psi->dwPlace        = 0L;
        psi->dwHistoryDone  = 0L;
    }
    else
    {
        LPECHOWAVEFILTER    pwfEcho;
        DWORD               cb;
        LPBYTE              pb;

        psi->fnConvert      = msfilterEcho;
        psi->fdwConfig      = pdi->fdwConfig;
        psi->hpbHistory     = NULL;
        psi->dwPlace        = 0L;
        psi->dwHistoryDone  = 0L;

        pwfEcho = (LPECHOWAVEFILTER)pwfltr;

        //
        //  compute size of delay buffer--add 4 to allow for rounding
	//  errors when we access the delay buffer.   (could do this
	//  more precisely.)
        //
        cb  = (pwfxSrc->nSamplesPerSec * pwfEcho->dwDelay / 1000) *
	      pwfxSrc->nBlockAlign;
        cb += 4;

        pb = (LPBYTE)GlobalAllocPtr(GMEM_MOVEABLE|GMEM_SHARE|GMEM_ZEROINIT, cb);
        if (NULL == pb)
        {
            //
            //  free the stream instance structure and fail with no memory
            //
            LocalFree((HLOCAL)psi);
            return (MMSYSERR_NOMEM);
        }

        psi->hpbHistory = (HPBYTE)pb;
    }


    //
    //  fill in our instance data--this will be passed back to all stream
    //  messages in the ACMDRVSTREAMINSTANCE structure. it is entirely
    //  up to the driver what gets stored (and maintained) in the
    //  fdwDriver and dwDriver members.
    //
    padsi->fdwDriver = 0L;
    padsi->dwDriver  = (DWORD_PTR)psi;

    return (MMSYSERR_NOERROR);
} // acmdStreamOpen()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamClose
//
//  Description:
//      This function is called to handle the ACMDM_STREAM_CLOSE message.
//      This message is sent when a conversion stream is no longer being
//      used (the stream is being closed; usually by an application
//      calling acmStreamClose). The ACM driver should clean up any resources
//      that were allocated for the stream.
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      NOTE! It is _strongly_ recommended that a driver not fail to close
//      a conversion stream.
//
//      An asyncronous conversion stream may fail with ACMERR_BUSY if there
//      are pending buffers. An application may call acmStreamReset to
//      force all pending buffers to be posted.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamClose
(
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    PSTREAMINSTANCE     psi;

    //
    //  the driver should clean up all privately allocated resources that
    //  were created for maintaining the stream instance. if no resources
    //  were allocated, then simply succeed.
    //
    //  in the case of this driver, we need to free the stream instance
    //  structure that we allocated during acmdStreamOpen.
    //
    psi = (PSTREAMINSTANCE)padsi->dwDriver;
    if (NULL != psi)
    {
        //
        //  free up  the delay buffer if one was allocated (will be for
        //  the echo filter
        //
        if (NULL != psi->hpbHistory)
        {
            GlobalFreePtr((LPVOID)psi->hpbHistory);
        }

        //
        //  free the stream instance structure
        //
        LocalFree((HLOCAL)psi);
    }

    return (MMSYSERR_NOERROR);
} // acmdStreamClose()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamSize
//
//  Description:
//      This function handles the ACMDM_STREAM_SIZE message. The purpose
//      of this function is to provide the _largest size in bytes_ that
//      the source or destination buffer needs to be given the input and
//      output formats and the size in bytes of the source or destination
//      data buffer.
//
//      In other words: how big does my destination buffer need to be to
//      hold the converted data? (ACM_STREAMSIZEF_SOURCE)
//
//      Or: how big can my source buffer be given the destination buffer?
//      (ACM_STREAMSIZEF_DESTINATION)
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//      LPACMDRVSTREAMSIZE padss: Specifies a pointer to the ACMDRVSTREAMSIZE
//      structure that defines the conversion stream size query attributes.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      An ACM driver should return MMSYSERR_NOTSUPPORTED if a query type
//      is requested that the driver does not understand. Note that a driver
//      must support both the ACM_STREAMSIZEF_DESTINATION and
//      ACM_STREAMSIZEF_SOURCE queries.
//
//      If the conversion would be 'out of range' given the input arguments,
//      then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamSize
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMSIZE      padss
)
{
    LPWAVEFORMATEX      pwfxSrc;
    LPWAVEFORMATEX      pwfxDst;
    LPWAVEFILTER        pwfltr;
    DWORD               dw;


    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;
    pwfltr  = padsi->pwfltr;


    //
    //
    //
    switch (ACM_STREAMSIZEF_QUERYMASK & padss->fdwSize)
    {
        case ACM_STREAMSIZEF_SOURCE:
            dw = padss->cbSrcLength;

            if( pwfltr->dwFilterTag == WAVE_FILTER_VOLUME )
            {
                //
                //  Source and dest sizes are the same for volume.
                //
                //  block align the destination
                //
                dw = PCM_BYTESTOSAMPLES(pwfxSrc, padss->cbSrcLength);
                dw = PCM_SAMPLESTOBYTES(pwfxSrc, dw);
            }
            else if( pwfltr->dwFilterTag == WAVE_FILTER_ECHO )
            {
                dw = PCM_BYTESTOSAMPLES(pwfxSrc, padss->cbSrcLength);
                dw = PCM_SAMPLESTOBYTES(pwfxSrc, dw);
            }

            if (0 == dw)
            {
                return (ACMERR_NOTPOSSIBLE);
            }

            padss->cbDstLength = dw;
            return (MMSYSERR_NOERROR);


        case ACM_STREAMSIZEF_DESTINATION:
            dw = padss->cbDstLength;

            if( pwfltr->dwFilterTag == WAVE_FILTER_VOLUME )
            {
                //
                //  Source and dest sizes are the same for volume.
                //
                //  block align the destination
                //
                dw = PCM_BYTESTOSAMPLES(pwfxDst, padss->cbDstLength);
                dw = PCM_SAMPLESTOBYTES(pwfxDst, dw);
            }
            else if( pwfltr->dwFilterTag == WAVE_FILTER_ECHO )
            {
                dw = PCM_BYTESTOSAMPLES(pwfxDst, padss->cbDstLength);
                dw = PCM_SAMPLESTOBYTES(pwfxDst, dw);
            }

            if (0 == dw)
            {
                return (ACMERR_NOTPOSSIBLE);
            }

            padss->cbSrcLength = dw;
            return (MMSYSERR_NOERROR);
    }

    //
    //
    //
    return (MMSYSERR_NOTSUPPORTED);
} // acmdStreamSize()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT DriverProc
//
//  Description:
//
//
//  Arguments:
//      DWORD dwId: For most messages, dwId is the DWORD value that
//      the driver returns in response to a DRV_OPEN message. Each time
//      the driver is opened, through the OpenDriver API, the driver
//      receives a DRV_OPEN message and can return an arbitrary, non-zero
//      value. The installable driver interface saves this value and returns
//      a unique driver handle to the application. Whenever the application
//      sends a message to the driver using the driver handle, the interface
//      routes the message to this entry point and passes the corresponding
//      dwId. This mechanism allows the driver to use the same or different
//      identifiers for multiple opens but ensures that driver handles are
//      unique at the application interface layer.
//
//      The following messages are not related to a particular open instance
//      of the driver. For these messages, the dwId will always be zero.
//
//          DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
//
//      HDRVR hdrvr: This is the handle returned to the application
//      by the driver interface.
//
//      UINT uMsg: The requested action to be performed. Message
//      values below DRV_RESERVED are used for globally defined messages.
//      Message values from DRV_RESERVED to DRV_USER are used for defined
//      driver protocols. Messages above DRV_USER are used for driver
//      specific messages.
//
//      LPARAM lParam1: Data for this message. Defined separately for
//      each message.
//
//      LPARAM lParam2: Data for this message. Defined separately for
//      each message.
//
//  Return (LRESULT):
//      Defined separately for each message.
//
//--------------------------------------------------------------------------;

EXTERN_C LRESULT FNEXPORT DriverProc
(
    DWORD_PTR               dwId,
    HDRVR                   hdrvr,
    UINT                    uMsg,
    LPARAM                  lParam1,
    LPARAM                  lParam2
)
{
    LRESULT             lr;
    PDRIVERINSTANCE     pdi;

    //
    //  make pdi either NULL or a valid instance pointer. note that dwId
    //  is 0 for several of the DRV_* messages (ie DRV_LOAD, DRV_OPEN...)
    //  see acmdDriverOpen for information on what dwId is for other
    //  messages (instance data).
    //
    pdi = (PDRIVERINSTANCE)dwId;

    switch (uMsg)
    {
        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_LOAD:
#ifdef WIN32
            DbgInitialize(TRUE);
#endif
            return(1L);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_FREE:
            return (1L);


        //
        //  lParam1: Not used. Ignore this argument.
        //
        //  lParam2: Pointer to ACMDRVOPENDESC (or NULL).
        //
        case DRV_OPEN:
            lr = acmdDriverOpen(hdrvr, (LPACMDRVOPENDESC)lParam2);
            return (lr);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_CLOSE:
            lr = acmdDriverClose(pdi);
            return (lr);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_INSTALL:
            return ((LRESULT)DRVCNF_RESTART);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_REMOVE:
            return ((LRESULT)DRVCNF_RESTART);



        //
        //  lParam1: Not used.
        //
        //  lParam2: Not used.
        //
        case DRV_QUERYCONFIGURE:
            //
            //  set up lParam1 and lParam2 to values that can be used by
            //  acmdDriverConfigure to know that it is being 'queried'
            //  for configuration support.
            //
            lParam1 = -1L;
            lParam2 = 0L;

            //--fall through--//

        //
        //  lParam1: Handle to parent window for the configuration dialog
        //           box.
        //
        //  lParam2: Optional pointer to DRVCONFIGINFO structure.
        //
        case DRV_CONFIGURE:
            lr = acmdDriverConfigure(pdi, (HWND)lParam1, (LPDRVCONFIGINFO)lParam2);
            return (lr);


        //
        //  lParam1: Pointer to ACMDRIVERDETAILS structure.
        //
        //  lParam2: Size in bytes of ACMDRIVERDETAILS stucture passed.
        //
        case ACMDM_DRIVER_DETAILS:
            lr = acmdDriverDetails(pdi, (LPACMDRIVERDETAILS)lParam1);
            return (lr);

        //
        //  lParam1: Handle to parent window to use if displaying your own
        //           about box.
        //
        //  lParam2: Not used.
        //
        case ACMDM_DRIVER_ABOUT:
            lr = acmdDriverAbout(pdi, (HWND)lParam1);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: Pointer to FORMATTAGDETAILS structure.
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FORMATTAG_DETAILS:
            lr = acmdFormatTagDetails(pdi, (LPACMFORMATTAGDETAILS)lParam1, (DWORD)lParam2);
            return (lr);


        //
        //  lParam1: Pointer to FORMATDETAILS structure.
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FORMAT_DETAILS:
            lr = acmdFormatDetails(pdi, (LPACMFORMATDETAILS)lParam1, (DWORD)lParam2);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: FILTERTAGDETAILS
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FILTERTAG_DETAILS:
            lr = acmdFilterTagDetails(pdi, (LPACMFILTERTAGDETAILS)lParam1, (DWORD)lParam2);
            return (lr);

        //
        //  lParam1: Pointer to the details structure.
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FILTER_DETAILS:
            lr = acmdFilterDetails(pdi, (LPACMFILTERDETAILS)lParam1, (DWORD)lParam2);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Not used.
        //
        case ACMDM_STREAM_OPEN:
            lr = acmdStreamOpen(pdi, (LPACMDRVSTREAMINSTANCE)lParam1);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Not Used.
        //
        case ACMDM_STREAM_CLOSE:
            lr = acmdStreamClose((LPACMDRVSTREAMINSTANCE)lParam1);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Pointer to ACMDRVSTREAMSIZE structure.
        //
        case ACMDM_STREAM_SIZE:
            lr = acmdStreamSize((LPACMDRVSTREAMINSTANCE)lParam1, (LPACMDRVSTREAMSIZE)lParam2);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Pointer to ACMDRVSTREAMHEADER structure.
        //
        case ACMDM_STREAM_CONVERT:
        {
            PSTREAMINSTANCE         psi;
            LPACMDRVSTREAMINSTANCE  padsi;
            LPACMDRVSTREAMHEADER    padsh;

            //
            //  our stream instance data is a pointer to the conversion
            //  procedure needed to convert the pwfxSrc data to pwfxDst.
            //  the correct procedure to use was decided in acmdStreamOpen
            //
            padsi = (LPACMDRVSTREAMINSTANCE)lParam1;
            padsh = (LPACMDRVSTREAMHEADER)lParam2;

            psi   = (PSTREAMINSTANCE)padsi->dwDriver;

            lr = psi->fnConvert(padsi, padsh);
            return (lr);
        }
    }

    //
    //  if we are executing the following code, then this ACM driver does not
    //  handle the message that was sent. there are two ranges of messages
    //  we need to deal with:
    //
    //  o   ACM specific driver messages: if an ACM driver does not answer a
    //      message sent in the ACM driver message range, then it must
    //      return MMSYSERR_NOTSUPPORTED. this applies to the 'user'
    //      range as well (for consistency).
    //
    //  o   other installable driver messages: if an ACM driver does not
    //      answer a message that is NOT in the ACM driver message range,
    //      then it must call DefDriverProc and return that result.
    //      the exception to this is ACM driver procedures installed as
    //      ACM_DRIVERADDF_FUNCTION through acmDriverAdd. in this case,
    //      the driver procedure should conform to the ACMDRIVERPROC
    //      prototype and also return zero instead of calling DefDriverProc.
    //
    if (uMsg >= ACMDM_USER)
        return (MMSYSERR_NOTSUPPORTED);
    else
        return (DefDriverProc(dwId, hdrvr, uMsg, lParam1, lParam2));
} // DriverProc()

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msfilter\msfilter.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  msfilter.c
//
//  Description:
//      This file contains filter routines for doing simple
//      volume and echo.
//
//
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include "codec.h"
#include "msfilter.h"

#include "debug.h"


//--------------------------------------------------------------------------;
//
//  LRESULT msfilterVolume
//
//  Description:
//      This function handles the ACMDM_STREAM_CONVERT message. This is the
//      whole purpose of writing an ACM driver--to convert data. This message
//      is sent after a stream has been opened (the driver receives and
//      succeeds the ACMDM_STREAM_OPEN message).
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//      LPACMDRVSTREAMHEADER padsh: Pointer to stream header structure
//      that defines the source data and destination buffer to convert.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL msfilterVolume
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh

)
{
    LPVOLUMEWAVEFILTER      pwfVol;
    HPSHORT                 hpiSrc;
    HPSHORT                 hpiDst;
    HPBYTE                  hpbSrc;
    HPBYTE                  hpbDst;
    LONG                    lSrc, lDst;
    LONG                    lAmp;
    LONG                    lDone, lSize;
    DWORD                   dw;

    pwfVol = (LPVOLUMEWAVEFILTER)padsi->pwfltr;
    DPF(2, "msfilterVolume Vol %lX ", pwfVol->dwVolume);


    //
    //  Source and dest sizes are the same for volume.
    //  block align source
    //
    dw = PCM_BYTESTOSAMPLES(padsi->pwfxSrc, padsh->cbSrcLength);
    dw = PCM_SAMPLESTOBYTES(padsi->pwfxSrc, dw);

    padsh->cbSrcLengthUsed = dw;

    lSize = (LONG)dw;

    lAmp = pwfVol->dwVolume;

    if( padsi->pwfxSrc->wBitsPerSample == 8 ) {
        hpbSrc = (HPBYTE)padsh->pbSrc;
        hpbDst = (HPBYTE)padsh->pbDst;
        for( lDone = 0; lDone < lSize; lDone++ ) {
            lSrc = ((short)(WORD)(*hpbSrc)) - 128;
            lDst = ((lSrc * lAmp) / 65536L) + 128;
            if( lDst < 0 ) {
                lDst = 0;
            } else if( lDst > 255 ) {
                lDst = 255;
            }
            *hpbDst = (BYTE)lDst;
            if( lDone < (lSize - 1) ) {
                // Will advance to invalid ptr on last sample
                // So do not advance on last sample.
                hpbSrc++;
                hpbDst++;
            }
        }
    } else {
        hpiSrc = (HPSHORT)(padsh->pbSrc);
        hpiDst = (HPSHORT)(padsh->pbDst);
        for( lDone = 0; lDone < lSize; lDone += sizeof(short) ) {
            lDst = ((((LONG)(int)(*hpiSrc)) * (lAmp/2)) / 32768L);
            if( lDst < -32768 ) {
                lDst = -32768;
            } else if( lDst > 32767 ) {
                lDst = 32767;
            }
            *hpiDst = (short)lDst;
            if( lDone < (lSize - 1) ) {
                // Will advance to invalid ptr on last sample
                // So do not advance on last sample.
                hpiSrc++;
                hpiDst++;
            }
        }

    }


    padsh->cbDstLengthUsed = lDone;

    return (MMSYSERR_NOERROR);
}


//--------------------------------------------------------------------------;
//
//  LRESULT msfilterEcho
//
//  Description:
//      This function handles the ACMDM_STREAM_CONVERT message. This is the
//      whole purpose of writing an ACM driver--to convert data. This message
//      is sent after a stream has been opened (the driver receives and
//      succeeds the ACMDM_STREAM_OPEN message).
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//      LPACMDRVSTREAMHEADER padsh: Pointer to stream header structure
//      that defines the source data and destination buffer to convert.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL msfilterEcho
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
)
{
    PSTREAMINSTANCE         psi;
    LPECHOWAVEFILTER        pwfEcho;
    DWORD                   dw;
    HPSHORT                 hpiHistory;
    HPSHORT                 hpiSrc;
    HPSHORT                 hpiDst;
    HPBYTE                  hpbHistory;
    HPBYTE                  hpbSrc;
    HPBYTE                  hpbDst;
    LONG                    lSrc, lHist, lDst;
    LONG                    lAmp, lDelay;
    LONG                    lDone1, lDone2, lSize, lDelaySize;
    BOOL                    fStart;
    BOOL                    fEnd;
    DWORD                   cbDstLength;

    fStart = (0 != (ACM_STREAMCONVERTF_START & padsh->fdwConvert));
    fEnd   = (0 != (ACM_STREAMCONVERTF_END   & padsh->fdwConvert));


    pwfEcho = (LPECHOWAVEFILTER)padsi->pwfltr;
    DPF(2, "msfilterEcho Vol %lX Delay %ld",
          pwfEcho->dwVolume,
          pwfEcho->dwDelay);


    lAmp = pwfEcho->dwVolume;

    psi = (PSTREAMINSTANCE)padsi->dwDriver;



    lDone1 = 0;
    lDone2 = 0;
    lDelay = psi->dwPlace;

    lDelaySize = padsi->pwfxSrc->nBlockAlign
            * (padsi->pwfxSrc->nSamplesPerSec
            * pwfEcho->dwDelay
            / 1000);


    // If this is a start buffer, then zero out the history
    if(fStart) {
        hpbHistory = psi->hpbHistory;
        for( lDone1 = 0; lDone1 < lDelaySize; lDone1++ ) {
            hpbHistory[lDone1] = 0;
        }

        psi->dwPlace        = 0L;
        psi->dwHistoryDone  = 0L;
    }


    //
    //  Source and dest sizes are the same for volume.
    //  block align source
    //
    dw = PCM_BYTESTOSAMPLES(padsi->pwfxSrc, padsh->cbSrcLength);
    dw = PCM_SAMPLESTOBYTES(padsi->pwfxSrc, dw);

    padsh->cbSrcLengthUsed = dw;

    lSize = (LONG)dw;

    cbDstLength = PCM_BYTESTOSAMPLES(padsi->pwfxDst, padsh->cbDstLength);
    cbDstLength = PCM_SAMPLESTOBYTES(padsi->pwfxDst, cbDstLength);


    if( padsi->pwfxSrc->wBitsPerSample == 8 ) {
        hpbHistory = psi->hpbHistory;
        hpbSrc = (HPBYTE)padsh->pbSrc;
        hpbDst = (HPBYTE)padsh->pbDst;
        for( lDone1 = 0; lDone1 < lSize; lDone1++ ) {
            lSrc  = ((short)(WORD)(*hpbSrc)) - 128;
            lHist = ((short)(char)(hpbHistory[lDelay]));
            lDst = lSrc + lHist + 128;
            if( lDst < 0 ) {
                lDst = 0;
            } else if( lDst > 255 ) {
                lDst = 255;
            }
            *hpbDst = (BYTE)lDst;
            lHist = (((lDst-128) * lAmp) / 65536L);
            if( lHist < -128 ) {
                lHist = -128;
            } else if( lHist > 127 ) {
                lHist = 127;
            }
            hpbHistory[lDelay] = (BYTE)lHist;
            lDelay++;
            if( lDelay >= lDelaySize ) {
                lDelay = 0;
            }
            if( lDone1 < (lSize - 1) ) {
                // Will advance to invalid ptr on last sample
                // So do not advance on last sample.
                hpbSrc++;
                hpbDst++;
            }
        }

	// If this is the end block and there is room,
	// then output the last echo
	if(fEnd && ((DWORD)lDone1 < cbDstLength) ) {
	    lSize = cbDstLength - lDone1;
	    if( lSize > (lDelaySize - (LONG)(psi->dwHistoryDone)) ) {
		lSize = lDelaySize - psi->dwHistoryDone;
	    }
	    if( lSize < 0 ) {
		/* ERROR */
		DPF(2, "!msfilterEcho Size Error!" );
		lSize = 0;
	    }
	    for( lDone2 = 0; lDone2 < lSize; lDone2++ ) {
		*hpbDst = (BYTE)((short)(char)(hpbHistory[lDelay]) + 128);
		lDelay++;
		if( lDelay >= lDelaySize ) {
		    lDelay = 0;
		}
		if( lDone2 < (lSize - 1) ) {
		    // Will advance to invalid ptr on last sample
		    // So do not advance on last sample.
		    hpbSrc++;
		    hpbDst++;
		}
		(psi->dwHistoryDone)++;
	    }
	}
    } else {
        hpiHistory = (HPSHORT)(psi->hpbHistory);
        hpiSrc = (HPSHORT)(padsh->pbSrc);
        hpiDst = (HPSHORT)(padsh->pbDst);
        for( lDone1 = 0; lDone1 < lSize; lDone1 += sizeof(short) ) {
            lDst = (LONG)(*hpiSrc) + (LONG)(hpiHistory[lDelay]);
            if( lDst < -32768 ) {
                lDst = -32768;
            } else if( lDst > 32767 ) {
                lDst = 32767;
            }
            *hpiDst = (short)lDst;
            lHist = ( ( lDst  * (lAmp/2)) / 32768L);
            if( lHist < -32768 ) {
                lHist = -32768;
            } else if( lHist > 32767 ) {
                lHist = 32767;
            }
            hpiHistory[lDelay] = (short)lHist;
            lDelay++;
            if( (LONG)(lDelay * sizeof(short)) >= lDelaySize ) {
                lDelay = 0;
            }
            if( lDone1 < (lSize - 1) ) {
                // Will advance to invalid ptr on last sample
                // So do not advance on last sample.
                hpiSrc++;
                hpiDst++;
            }
        }


	// If this is the end block and there is room,
	// then output the last echo
	if(fEnd && ((DWORD)lDone1 < cbDstLength) ) {
	    lSize = cbDstLength - lDone1;
	    if( lSize > (lDelaySize - (LONG)(psi->dwHistoryDone)) ) {
		lSize = lDelaySize - psi->dwHistoryDone;
	    }
	    if( lSize < 0 ) {
		/* ERROR */
		DPF(2, "!msfilterEcho Size Error!" );
		lSize = 0;
	    }
	    for( lDone2 = 0; lDone2 < lSize; lDone2 += sizeof(short) ) {
		*hpiDst = hpiHistory[lDelay];
		
		lDelay++;
		if( (LONG)(lDelay * sizeof(short)) >= lDelaySize ) {
		    lDelay = 0;
		}
		if( lDone2 < (lSize - 1) ) {
		    // Will advance to invalid ptr on last sample
		    // So do not advance on last sample.
		    hpiSrc++;
		    hpiDst++;
		}
		psi->dwHistoryDone += sizeof(short);
	    }
	}
    }


    // Reset the new point/place in the history
    psi->dwPlace = lDelay;

    padsh->cbDstLengthUsed = lDone1 + lDone2;

    return (MMSYSERR_NOERROR);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\verinfo\usa\verinfo.h ===
/*
 *      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 *      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 *	!!!!!!!IF YOU CHANGE TABS TO SPACES, YOU WILL BE KILLED!!!!!!!
 *      !!!!!!!!!!!!!!DOING SO MESSES UP THE BUILD PROCESS!!!!!!!!!!!!
 *      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 *      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 */


/*
 *  verinfo.h - internal header file to define the build version
 *
 */

//
//  WARNING! the following defines are used by some of the components in
//  the multimedia core. do *NOT* put LEADING ZERO's on these numbers or
//  they will end up as OCTAL numbers in the C code!
//

#ifdef MTN

#define OFFICIAL	1
#define FINAL		0

#ifdef ALTACM

#define /*ALTACM*/ MMVERSION		2
#define /*ALTACM*/ MMREVISION		0
#define /*ALTACM*/ MMRELEASE		83

#ifdef RC_INVOKED
#define VERSIONPRODUCTNAME	"Microsoft Audio Compression Manager\0"
#define VERSIONCOPYRIGHT	"Copyright (c) 1992-1994 Microsoft Corporation\0"
#endif

#if defined(DEBUG_RETAIL)
#define /*ALTACM*/ VERSIONSTR	"Motown Retail Debug Version 2.00.083\0"
#elif defined(DEBUG)
#define /*ALTACM*/ VERSIONSTR	"Motown Internal Debug Version 2.00.083\0"
#else
#define /*ALTACM*/ VERSIONSTR	"2.00\0"
#endif

#elif defined(ALTVFW)

#define /*ALTVFW*/ MMVERSION		4
#define /*ALTVFW*/ MMREVISION		0
#define /*ALTVFW*/ MMRELEASE		83

#ifdef RC_INVOKED
#define VERSIONPRODUCTNAME	"Microsoft Video for Windows\0"
#define VERSIONCOPYRIGHT	"Copyright \251 Microsoft Corp. 1992-1993\0"
#endif

#if defined(DEBUG_RETAIL)
#define /*ALTVFW*/ VERSIONSTR	"Motown Retail Debug Version 4.00.083\0"
#elif defined(DEBUG)
#define /*ALTVFW*/ VERSIONSTR	"Motown Internal Debug Version 4.00.083\0"
#else
#define /*ALTVFW*/ VERSIONSTR	"4.00\0"
#endif

#else

#define /*MTN*/ MMVERSION		4
#define /*MTN*/ MMREVISION		0
#define /*MTN*/ MMRELEASE		83

#ifdef RC_INVOKED
#define VERSIONPRODUCTNAME	"Microsoft Windows\0"
#define VERSIONCOPYRIGHT	"Copyright \251 Microsoft Corp. 1991-1994\0"
#endif

#if defined(DEBUG_RETAIL)
#define /*MTN*/ VERSIONSTR	"Motown Retail Debug Version 4.00.083\0"
#elif defined(DEBUG)
#define /*MTN*/ VERSIONSTR	"Motown Internal Debug Version 4.00.083\0"
#else
#define /*MTN*/ VERSIONSTR	"4.00\0"
#endif

#endif

#elif defined(ACM)

#define OFFICIAL	1
#define FINAL		0

#define /*ACM*/ MMVERSION		2
#define /*ACM*/ MMREVISION		02
#define /*ACM*/ MMRELEASE		005

#ifdef RC_INVOKED
#define VERSIONPRODUCTNAME	"Microsoft Audio Compression Manager\0"
#define VERSIONCOPYRIGHT	"Copyright \251 Microsoft Corp. 1992-1993\0"
#endif

#if defined(DEBUG_RETAIL)
#define /*ACM*/ VERSIONSTR	"ACM Retail Debug Version 2.02.005\0"
#elif defined(DEBUG)
#define /*ACM*/ VERSIONSTR	"ACM Internal Debug Version 2.02.005\0"
#else
#define /*ACM*/ VERSIONSTR	"2.02\0"
#endif

#elif defined(VFW)

#define OFFICIAL	1
#define FINAL		0

#define /*VFW*/ MMVERSION		1
#define /*VFW*/ MMREVISION		10
#define /*VFW*/ MMRELEASE		176

#ifdef RC_INVOKED
#define VERSIONPRODUCTNAME	"Microsoft Video for Windows\0"
#define VERSIONCOPYRIGHT	"Copyright \251 Microsoft Corp. 1992-1993\0"
#endif

#if defined(DEBUG_RETAIL)
#define /*VFW*/ VERSIONSTR	"VfW Retail Debug Version 1.10.176\0"
#elif defined(DEBUG)
#define /*VFW*/ VERSIONSTR	"VfW Internal Debug Version 1.10.176\0"
#else
#define /*VFW*/ VERSIONSTR	"1.1\0"
#endif

#endif

/***************************************************************************
 *  DO NOT TOUCH BELOW THIS LINE                                           *
 ***************************************************************************/

#ifdef RC_INVOKED
#define VERSIONCOMPANYNAME	"Microsoft Corporation\0"

/*
 *  Version flags 
 */

#ifndef OFFICIAL
#define VER_PRIVATEBUILD	VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD	0
#endif

#ifndef FINAL
#define VER_PRERELEASE		VS_FF_PRERELEASE
#else
#define VER_PRERELEASE		0
#endif

#if defined(DEBUG_RETAIL)
#define VER_DEBUG		VS_FF_DEBUG    
#elif defined(DEBUG)
#define VER_DEBUG		VS_FF_DEBUG    
#else
#define VER_DEBUG		0
#endif

#define VERSIONFLAGS		(VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)
#define VERSIONFILEFLAGSMASK	0x0030003FL

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msfilter\init.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  init.c
//
//  Description:
//      This file contains module initialization routines.  Note that there
//      is no module initialization for Win32.
//
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>

#include "codec.h"
#include "debug.h"


//==========================================================================;
//
//  WIN 16 SPECIFIC SUPPORT
//
//==========================================================================;

#ifndef WIN32

//--------------------------------------------------------------------------;
//
//  int LibMain
//
//  Description:
//      Library initialization code.
//
//  Arguments:
//      HINSTANCE hinst: Our module handle.
//
//      WORD wDataSeg: Specifies the DS value for this DLL.
//
//      WORD cbHeapSize: The heap size from the .def file.
//
//      LPSTR pszCmdLine: The command line.
//
//  Return (int):
//      Returns non-zero if the initialization was successful and 0 otherwise.
//
//  History:
//      11/15/92    Created. 
//
//--------------------------------------------------------------------------;

int FNGLOBAL LibMain
(
    HINSTANCE               hinst, 
    WORD                    wDataSeg, 
    WORD                    cbHeapSize,
    LPSTR                   pszCmdLine
)
{
    DbgInitialize(TRUE);

    //
    //  if debug level is 5 or greater, then do a DebugBreak() to debug
    //  loading of this driver
    //
    DPF(1, "LibMain(hinst=%.4Xh, wDataSeg=%.4Xh, cbHeapSize=%u, pszCmdLine=%.8lXh)",
        hinst, wDataSeg, cbHeapSize, pszCmdLine);
    DPF(5, "!*** break for debugging ***");

    return (TRUE);
} // LibMain()


//--------------------------------------------------------------------------;
//  
//  int WEP
//  
//  Description:
//  
//  
//  Arguments:
//      WORD wUselessParam:
//  
//  Return (int):
//  
//  History:
//      03/28/93    Created.
//  
//--------------------------------------------------------------------------;

EXTERN_C int FNEXPORT WEP
(
    WORD                    wUselessParam
)
{
    DPF(1, "WEP(wUselessParam=%u)", wUselessParam);

    //
    //  always return 1.
    //
    return (1);
} // WEP()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\setup\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF


!IF "$(TARGET_DIRECTORY)"=="i386"  || "$(TARGET_DIRECTORY)"=="I386"
PLATFORM_SWITCH=i
!ELSEIF "$(TARGET_DIRECTORY)"=="amd64"  || "$(TARGET_DIRECTORY)"=="AMD64"
PLATFORM_SWITCH=a
!ELSEIF "$(TARGET_DIRECTORY)"=="ia64"  || "$(TARGET_DIRECTORY)"=="IA64"
PLATFORM_SWITCH=m
!ELSE
! ERROR Invalid Platform Switch for infs
!ENDIF


_LNG=$(LANGUAGE)
_INX=.
_INF=obj\$(TARGET_DIRECTORY)
STAMP=stampinf -f $@

make_infs:$(_INF)\wave.inf      \
          $(_INF)\wdmaudio.inf  \
          $(_INF)\wdma10k1.inf  \
          $(_INF)\wdma_ali.inf  \
          $(_INF)\wdma_csf.inf  \
          $(_INF)\wdma_cwr.inf  \
          $(_INF)\wdma_es3.inf  \
          $(_INF)\wdma_int.inf  \
          $(_INF)\wdma_m2e.inf  \
          $(_INF)\wdma_ms.inf   \
          $(_INF)\wdma_rip.inf  \
          $(_INF)\wdma_sis.inf  \
          $(_INF)\wdma_usb.inf  \
          $(_INF)\wdma_via.inf  \
          $(_INF)\wdma_avc.inf  \
          $(_INF)\mssb16.inf


#
# Explicit dependencies. We do it this way instead of trying to use rules
# because !#@&^$#% nmake doesn't allow multiple 'source' extensions
# when defining a rule, and we need to express a dependency between
# .txt OR .inx to the final .inf.
#


$(_INF)\wave.inf: $(_INX)\wave.inx $(_LNG)\wave.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdmaudio.inf: $(_INX)\wdmaudio.inx $(_LNG)\wdmaudio.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PLATFORM_SWITCH)
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp2 >$@
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma10k1.inf: $(_INX)\wdma10k1.inx $(_LNG)\wdma10k1.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)


$(_INF)\wdma_ali.inf: $(_INX)\wdma_ali.inx $(_LNG)\wdma_ali.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma_csf.inf: $(_INX)\wdma_csf.inx $(_LNG)\wdma_csf.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma_cwr.inf: $(_INX)\wdma_cwr.inx $(_LNG)\wdma_cwr.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PLATFORM_SWITCH)
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp2 >$@
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma_es3.inf: $(_INX)\wdma_es3.inx $(_LNG)\wdma_es3.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma_int.inf: $(_INX)\wdma_int.inx $(_LNG)\wdma_int.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)


$(_INF)\wdma_m2e.inf: $(_INX)\wdma_m2e.inx $(_LNG)\wdma_m2e.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma_ms.inf: $(_INX)\wdma_ms.inx $(_LNG)\wdma_ms.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma_rip.inf: $(_INX)\wdma_rip.inx $(_LNG)\wdma_rip.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma_sis.inf: $(_INX)\wdma_sis.inx $(_LNG)\wdma_sis.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma_usb.inf: $(_INX)\wdma_usb.inx $(_LNG)\wdma_usb.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma_via.inf: $(_INX)\wdma_via.inx $(_LNG)\wdma_via.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma_avc.inf: $(_INX)\wdma_avc.inx $(_LNG)\wdma_avc.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)


$(_INF)\mssb16.inf: $(_INX)\mssb16.inx $(_LNG)\mssb16.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\o2base\border.cxx ===
//+---------------------------------------------------------------------
//
//   File:       border.cxx
//
//   Contents:   Border Object Class
//
//   Classes:    OLEBorder
//
//------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


    BOOL OLEBorder::fInit = FALSE;
    HCURSOR OLEBorder::ahc[5] = { NULL, NULL, NULL, NULL, NULL };
    int OLEBorder::iPartMap[14] = {
        ICURS_STD,  // 0 NOWHERE
        ICURS_STD,  // 1 TOP
        ICURS_STD,  // 2 RIGHT
        ICURS_STD,  // 3 BOTTOM
        ICURS_STD,  // 4 LEFT
        ICURS_NESW, // 5 TOPRIGHT
        ICURS_NWSE, // 6 BOTTOMRIGHT
        ICURS_NESW, // 7 BOTTOMLEFT
        ICURS_NWSE, // 8 TOPLEFT
        ICURS_NS,   // 9 TOPHAND
        ICURS_WE,   //10 RIGHTHAND
        ICURS_NS,   //11 BOTTOMHAND
        ICURS_WE,   //12 LEFTHAND
        ICURS_STD   //13 INSIDE
    };

HCURSOR
OLEBorder::MapPartToCursor(USHORT usPart)
{
    if (usPart > MAX_OBPART)
        usPart = 0;
    return ahc[iPartMap[usPart]];
}

//+---------------------------------------------------------------
//
//  Member: OLEBorder::InitClass
//
//---------------------------------------------------------------
void
OLEBorder::InitClass( void )
{
    _fErased = TRUE;
    _state = 0;
    _sThickness = FBORDER_THICKNESS;
    _sMinHeight = FBORDER_MINHEIGHT;
    _sMinWidth = FBORDER_MINWIDTH;
    if(fInit)
        return;

    ahc[ICURS_NWSE] = LoadCursor( NULL, IDC_SIZENWSE );
    ahc[ICURS_NESW] = LoadCursor( NULL, IDC_SIZENESW );
    ahc[ICURS_NS] = LoadCursor( NULL, IDC_SIZENS );
    ahc[ICURS_WE] = LoadCursor( NULL, IDC_SIZEWE );
    ahc[ICURS_STD] = LoadCursor( NULL, IDC_SIZEALL );
    fInit = TRUE;
}

//+---------------------------------------------------------------
//
//  Member: OLEBorder::OLEBorder
//
//---------------------------------------------------------------
OLEBorder::OLEBorder( void )
{
    rect.top = 0;
    rect.left = 0;
    rect.bottom = 0;
    rect.right = 0;
    InitClass();
}

//+---------------------------------------------------------------
//
//  Member: OLEBorder::OLEBorder
//
//---------------------------------------------------------------
OLEBorder::OLEBorder( RECT& r )
{
    rect = r;
    InitClass();
}

//+---------------------------------------------------------------
//
//  Member: OLEBorder::~OLEBorder
//
//---------------------------------------------------------------
OLEBorder::~OLEBorder( void )
{
}


//+---------------------------------------------------------------
//
//  Member: OLEBorder::SetState
//
//---------------------------------------------------------------
USHORT
OLEBorder::SetState( HDC hdc, HWND hwnd, USHORT usBorderState )
{
    if (_state ^ usBorderState)
    {
        if (hdc != NULL)
        {
            _state |= OBSTYLE_RESERVED;
            Draw(hdc,hwnd);
        }
    }
    _state = usBorderState & (~OBSTYLE_RESERVED);
    if (hdc != NULL)
        Draw(hdc,hwnd);

    return _state;
}

//+---------------------------------------------------------------
//
//  Member: OLEBorder::Erase
//
//---------------------------------------------------------------
void
OLEBorder::Erase(HWND hwnd)
{
    RECT r;
    if (hwnd != NULL && !_fErased)
    {
        _fErased = TRUE;
        if(_state & OBSTYLE_DIAGONAL_FILL)
        {
            GetBorderRect(r,BP_INSIDE);
            InvalidateRect(hwnd,&r,TRUE);
        }
        else
        {
            for(int i = BP_TOP; i <= BP_LEFT; i++)
            {
                GetBorderRect(r,i);
                InvalidateRect(hwnd,&r,TRUE);
            }
        }
    }
    _state = _state & OBSTYLE_INSIDE;
}

void
OLEBorder::GetInsideBorder( RECT& rDest, int iEdge )
{
    int sHalf = _sThickness >> 1;
    int sMid;

    switch(iEdge)
    {
    case BP_TOP:
    case BP_BOTTOM:
        rDest.left = rect.left;
        rDest.right = rect.right;
        if (iEdge == BP_TOP)
        {
            rDest.top = rect.top;
            rDest.bottom = rect.top + _sThickness;
        }
        else
        {
            rDest.top = rect.bottom - _sThickness;
            rDest.bottom = rect.bottom;
        }
        break;

    case BP_RIGHT:
    case BP_LEFT:
        rDest.top = rect.top;
        rDest.bottom = rect.bottom;
        if (iEdge == BP_RIGHT)
        {
            rDest.left = rect.right - _sThickness;
            rDest.right = rect.right;
        }
        else
        {
            rDest.left = rect.left;
            rDest.right = rect.left + _sThickness;
        }
        break;

    case BP_TOPRIGHT:
    case BP_BOTTOMRIGHT:
        rDest.left = rect.right - _sThickness;
        rDest.right = rect.right;
        if (iEdge == BP_TOPRIGHT)
        {
            rDest.top = rect.top;
            rDest.bottom = rect.top + _sThickness;
        }
        else
        {
            rDest.top = rect.bottom - _sThickness;
            rDest.bottom = rect.bottom;
        }
        break;

    case BP_BOTTOMLEFT:
    case BP_TOPLEFT:
        rDest.left = rect.left;
        rDest.right = rect.left + _sThickness;
        if (iEdge == BP_BOTTOMLEFT)
        {
            rDest.top = rect.bottom - _sThickness;
            rDest.bottom = rect.bottom;
        }
        else
        {
            rDest.top = rect.top;
            rDest.bottom = rect.top + _sThickness;
        }
        break;

    case BP_TOPHAND:
    case BP_BOTTOMHAND:
        sMid = rect.left + ((rect.right - rect.left) >> 1);
        rDest.left = sMid - sHalf;
        rDest.right = sMid + sHalf;
        if (iEdge == BP_TOPHAND)
        {
            rDest.top = rect.top;
            rDest.bottom = rect.top + _sThickness;
        }
        else
        {
            rDest.top = rect.bottom - _sThickness;
            rDest.bottom = rect.bottom;
        }
        break;

    case BP_RIGHTHAND:
    case BP_LEFTHAND:
        sMid = rect.top + ((rect.bottom - rect.top) >> 1);
        rDest.top = sMid - sHalf;
        rDest.bottom = sMid + sHalf;
        if (iEdge == BP_LEFTHAND)
        {
            rDest.left = rect.left;
            rDest.right = rect.left + _sThickness;
        }
        else
        {
            rDest.left = rect.right - _sThickness;
            rDest.right = rect.right;
        }
        break;

    case BP_INSIDE:
    default:
        rDest = rect;
        break;
    }
}

void
OLEBorder::GetOutsideBorder( RECT& rDest, int iEdge )
{
    int sHalf = _sThickness >> 1;
    int sMid;

    switch(iEdge)
    {
    case BP_TOP:
    case BP_BOTTOM:
        rDest.left = rect.left - _sThickness;
        rDest.right = rect.right + _sThickness;
        if (iEdge == BP_TOP)
        {
            rDest.top = rect.top - _sThickness;
            rDest.bottom = rect.top + 1;
        }
        else
        {
            rDest.top = rect.bottom;
            rDest.bottom = rect.bottom + _sThickness;
        }
        break;

    case BP_RIGHT:
    case BP_LEFT:
        rDest.top = rect.top - _sThickness;
        rDest.bottom = rect.bottom + _sThickness;
        if (iEdge == BP_RIGHT)
        {
            rDest.left = rect.right;
            rDest.right = rect.right + _sThickness;
        }
        else
        {
            rDest.left = rect.left - _sThickness;
            rDest.right = rect.left + 1;
        }
        break;

    case BP_TOPRIGHT:
    case BP_BOTTOMRIGHT:
        rDest.left = rect.right;
        rDest.right = rect.right + _sThickness;
        if (iEdge == BP_TOPRIGHT)
        {
            rDest.top = rect.top - _sThickness;
            rDest.bottom = rect.top + 1;
        }
        else
        {
            rDest.top = rect.bottom;
            rDest.bottom = rect.bottom + _sThickness;
        }
        break;

    case BP_BOTTOMLEFT:
    case BP_TOPLEFT:
        rDest.left = rect.left - _sThickness;
        rDest.right = rect.left + 1;
        if (iEdge == BP_BOTTOMLEFT)
        {
            rDest.top = rect.bottom;
            rDest.bottom = rect.bottom + _sThickness;
        }
        else
        {
            rDest.top = rect.top - _sThickness;
            rDest.bottom = rect.top + 1;
        }
        break;

    case BP_TOPHAND:
    case BP_BOTTOMHAND:
        sMid = rect.left + ((rect.right - rect.left) >> 1);
        rDest.left = sMid - sHalf;
        rDest.right = sMid + sHalf;
        if (iEdge == BP_TOPHAND)
        {
            rDest.top = rect.top - _sThickness;
            rDest.bottom = rect.top + 1;
        }
        else
        {
            rDest.top = rect.bottom;
            rDest.bottom = rect.bottom + _sThickness;
        }
        break;

    case BP_RIGHTHAND:
    case BP_LEFTHAND:
        sMid = rect.top + ((rect.bottom - rect.top) >> 1);
        rDest.top = sMid - sHalf;
        rDest.bottom = sMid + sHalf;
        if (iEdge == BP_LEFTHAND)
        {
            rDest.left = rect.left - _sThickness;
            rDest.right = rect.left + 1;
        }
        else
        {
            rDest.left = rect.right;
            rDest.right = rect.right + _sThickness;
        }
        break;

    case BP_INSIDE:
    default: //inactive border
        rDest.left = rect.left - 1;
        rDest.right = rect.right + 1;
        rDest.top = rect.top - 1;
        rDest.bottom = rect.bottom + 1;
        break;
    }
}

//+---------------------------------------------------------------
//
//  Member: OLEBorder::GetBorderRect
//
//---------------------------------------------------------------
void
OLEBorder::GetBorderRect( RECT& rDest, int iEdge )
{
    if(_state & OBSTYLE_INSIDE)
        GetInsideBorder(rDest,iEdge);
    else
        GetOutsideBorder(rDest,iEdge);
}

//+---------------------------------------------------------------
//
//  Member: OLEBorder::SwitchCoords
//
//---------------------------------------------------------------
void
OLEBorder::SwitchCoords( HWND hwndFrom, HWND hwndTo )
{
    MapWindowPoints(hwndFrom, hwndTo, (LPPOINT)&rect, 2);
    MapWindowPoints(hwndFrom, hwndTo, &_pt, 1);
}

//+---------------------------------------------------------------
//
//  Member: OLEBorder::Draw
//
//---------------------------------------------------------------
void
OLEBorder::Draw( HDC hdc, HWND hwnd )
{
    if(hdc == NULL || (_state & ~OBSTYLE_INSIDE) == 0)
    {
        return;     //nothing to do!
    }

    RECT r;
    //
    //       the following should be rewritten so any border style
    //       can be drawn in XOR mode...
    //
    if (_state & OBSTYLE_XOR)
    {
        if (_state & OBSTYLE_THICK)
        {
            PatBlt(hdc, rect.left - 1, rect.top - 1,
                rect.right - rect.left + 2, 3, PATINVERT);

            PatBlt(hdc, rect.left - 1, rect.bottom - 2,
                rect.right - rect.left + 2, 3, PATINVERT);

            PatBlt(hdc, rect.left - 1, rect.top + 2,
                3, rect.bottom - rect.top - 4, PATINVERT);

            PatBlt(hdc, rect.right - 2, rect.top + 2,
                3, rect.bottom - rect.top - 4, PATINVERT);
        }
        else
            DrawFocusRect(hdc,&rect);
        return;
    }

    HBRUSH hbrBlack = (HBRUSH)GetStockObject(BLACK_BRUSH);
    HBRUSH hbr;
    COLORREF clrref;
    int i;

    if (_state & OBSTYLE_RESERVED)
    {
        Erase(hwnd);
        return;
    }

    if (_state & OBSTYLE_ACTIVE)
    {
        clrref = GetSysColor(COLOR_ACTIVECAPTION);
    }
    else
    {
        clrref = GetSysColor(COLOR_WINDOWFRAME);
    }

    if ((_state & OBSTYLE_TYPEMASK) == OBSTYLE_DIAGONAL_FILL)
    {
        hbr = CreateHatchBrush(HS_DIAGCROSS,clrref);
        GetBorderRect(r,BP_INSIDE);
        FillRect(hdc,&r,hbr);
        DeleteObject(hbr);
    }
    else if ((_state & OBSTYLE_TYPEMASK) == OBSTYLE_SOLID_PEN)
    {
        GetBorderRect(r,BP_INSIDE);
        FrameRect(hdc,&r,hbrBlack);
    }

    if (_state & OBSTYLE_THICK)
    {
        if (_state & OBSTYLE_INSIDE)
            InflateRect(&r,-1,-1);
        else
            InflateRect(&r,1,1);
        FrameRect(hdc,&rect,hbrBlack);
    }

    if (_state & OBSTYLE_HANDLED)
    {
        for (i = BP_TOPRIGHT; i <= BP_TOPLEFT; i++)
        {
            GetBorderRect(r,i);
            FillRect(hdc,&r,hbrBlack);
        }
        for (i = BP_TOPHAND; i <= BP_LEFTHAND; i++)
        {
            GetBorderRect(r,i);
            FillRect(hdc,&r,hbrBlack);
        }
    }
    _fErased = FALSE;
}

//+---------------------------------------------------------------
//
//  Member: OLEBorder::QueryHit
//
//---------------------------------------------------------------
USHORT
OLEBorder::QueryHit( POINT point )
{
    RECT r = rect;
    USHORT usWhere = BP_NOWHERE;

    if ((_state & OBSTYLE_INSIDE) == 0)
        InflateRect(&r,_sThickness,_sThickness);
    if (PtInRect(&r,point))
    {
        usWhere = BP_INSIDE;
        //
        //test against the real inside to optimize this case...
        //
        InflateRect(&r,-_sThickness,-_sThickness);

        //
        // PtInRect counts the top and left borders as being inside, so
        // we must account for this.
        //
        r.left++;
        r.top++;
        if (!PtInRect(&r,point))
        {
            //
            //Search for the "handle" that was hit...
            //
            USHORT i;
            for (i = BP_LEFTHAND; i >= BP_TOP; i--)
            {
                GetBorderRect(r,i);
                if (PtInRect(&r,point))
                {
                    usWhere = i;
                    break;
                }
            }
        }
    }
    return(usWhere);
}

//+---------------------------------------------------------------
//
//  Member: OLEBorder::QueryMoveCursor
//
//---------------------------------------------------------------
HCURSOR
OLEBorder::QueryMoveCursor( POINT ptCurrent, BOOL fMustMove )
{
    //
    //Stash part-hit info so we can do the right thing durring
    //upcomming move/size operation
    //
    if (fMustMove)
    {
        _usPart = BP_INSIDE;
    }
    else
    {
        _usPart = QueryHit(ptCurrent);
    }
    return MapPartToCursor(_usPart);
}

//+---------------------------------------------------------------
//
//  Member: OLEBorder::BeginMove
//
//---------------------------------------------------------------
HCURSOR
OLEBorder::BeginMove( HDC hdc, HWND hwnd, POINT ptStart,
        BOOL fMustMove )
{
    if(_state == 0 )
        _state = OBSTYLE_SOLID_PEN;
    SetState( hdc, hwnd, _state | OBSTYLE_XOR | OBSTYLE_THICK);
    _pt = ptStart;
    return QueryMoveCursor(ptStart,fMustMove);
}

//+---------------------------------------------------------------
//
//  Member: OLEBorder::UpdateMove
//
//---------------------------------------------------------------
RECT&
OLEBorder::UpdateMove( HDC hdc, HWND hwnd, POINT ptCurrent, BOOL fNewRegion )
{
    if ((ptCurrent.x == _pt.x) && (ptCurrent.y == _pt.y))
        return rect;

    RECT rTemp = rect;
    Draw(hdc,hwnd);
    if (fNewRegion)
    {
        rTemp.left = min(_pt.x,ptCurrent.x);
        rTemp.top = min(_pt.y,ptCurrent.y);
        rTemp.right = max(_pt.x,ptCurrent.x);
        rTemp.bottom = max(_pt.y,ptCurrent.y);
    }
    else
    {
        int xDelta = ptCurrent.x - _pt.x;
        int yDelta = ptCurrent.y - _pt.y;
        switch (_usPart)
        {
        case BP_INSIDE:
        case BP_TOP:
        case BP_BOTTOM:
        case BP_RIGHT:
        case BP_LEFT:
        default:
            OffsetRect(&rTemp,xDelta,yDelta);
            break;

        case BP_TOPRIGHT:
            rTemp.right += xDelta;
            rTemp.top += yDelta;
            break;

        case BP_BOTTOMRIGHT:
            rTemp.right += xDelta;
            rTemp.bottom += yDelta;
            break;

        case BP_BOTTOMLEFT:
            rTemp.bottom += yDelta;
            rTemp.left += xDelta;
            break;

        case BP_TOPLEFT:
            rTemp.top += yDelta;
            rTemp.left += xDelta;
            break;

        case BP_TOPHAND:
            rTemp.top += yDelta;
            break;

        case BP_BOTTOMHAND:
            rTemp.bottom += yDelta;
            break;

        case BP_RIGHTHAND:
            rTemp.right += xDelta;
            break;

        case BP_LEFTHAND:
            rTemp.left += xDelta;
            break;
        }
    }
    //
    //clip resize to repect minimum height & width specification
    //
    if((rTemp.right - rTemp.left >= _sMinWidth) &&
        (rTemp.bottom - rTemp.top >= _sMinHeight))
    {
        rect = rTemp;
        if (!fNewRegion)
        {
            _pt = ptCurrent;
        }
    }

    Draw(hdc,hwnd);

    return rect;
}

//+---------------------------------------------------------------
//
//  Member: OLEBorder::EndMove
//
//---------------------------------------------------------------
RECT&
OLEBorder::EndMove( HDC hdc, HWND hwnd, POINT ptCurrent, USHORT usBorderState )
{
    SetState( hdc, hwnd, usBorderState );
    return rect;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\o2base\clsdesc.cxx ===
//+---------------------------------------------------------------------
//
//   File:       clsdesc.cxx
//
//   Contents:   ClassDescriptor implementation
//
//------------------------------------------------------------------------

//[ classdescriptor_overview
/*
                        ClassDescriptor Overview

A ClassDescriptor is a structure the contains global, static information
about an OLE Compound Document class.  Having a ClassDescriptor allows
the base classes to do a lot of work on behalf of the derived class because
it can get information it needs from the ClassDescriptor instead of resorting
to virtual method calls.  A single ClassDescriptor is shared by all object
instances of that Compound Document class.

A ClassDescriptor has three conceptual parts.  The first part is a collection
of information loaded from resources.  This includes strings, menus, accelerators,
and an icon.  The second part is a pair of verb tables that are used to implement
IOleObject::DoVerb.  The third part is two pairs of format tables that are
used to implement many of the Get/Set/Query methods on IDataObject.
Each of these parts has its own initialization method to prepare that part of
the class descriptor.

The ClassDescriptor is usually associated with the ClassFactory.

*/
//]

#include "headers.hxx"
#pragma hdrstop

#define MAX_USERTYPE_LEN 64

//+---------------------------------------------------------------
//
//  Member:     ClassDescriptor::ClassDescriptor
//
//  Synopsis:   Constructor for ClassDescriptor structure
//
//  Notes:      A DLL (in-process) server should allocate the class
//              descriptor at library initialization time and allocate
//              it in shared memory (GMEM_SHARE flag with GlobalAlloc, or
//              the OLE shared allocator, MEMCTX_SHARED).
//
//              The constructor ensures all members of the structure
//              are initialized to NULL
//
//----------------------------------------------------------------

ClassDescriptor::ClassDescriptor(void)
{
    // initialize everything to NULL
    // ZeroMemory(this, sizeof(ClassDescriptor));
    memset(this, 0, sizeof(ClassDescriptor));
}

//+---------------------------------------------------------------
//
//  Member:     ClassDescriptor::Init
//
//  Synopsis:   Initializes a class descriptor structure from resources
//
//  Arguments:  [hinst] -- instance handle of module with resources used
//                      to initialize the class descriptor
//
//  Returns:    TRUE iff the class descriptor was successfully initialized
//
//  Notes:      This method only fills in the part of the class descriptor
//              that can be initialized from resources.  The other part
//              that requires initialization are the verb and format tables.
//
//              Objects that are concerned about resource load times could
//              not use this initialization method and fill in fields of the
//              class descriptor directly.
//
//----------------------------------------------------------------

BOOL ClassDescriptor::Init(HINSTANCE hinst, WORD wBaseID)
{
    //REVIEW:  Currently, information loaded from resources is duplicated
    //REVIEW:  in the registration database.  We could
    //REVIEW:   (1) load this stuff from the reg db instead (except CLSID), or
    //REVIEW:   (2) do an autoregistration feature where the reg db is filled
    //REVIEW:       in from the class descriptor information loaded from resources

    //REVIEW:  We could also support loading the verb and format tables
    //REVIEW:  from resources/regdb as well.

    _hinst = hinst;
    _wBaseResID = wBaseID;

    // load our class id string and convert it into our real class id
    TCHAR szClsId[40];
    ZeroMemory (szClsId, sizeof (szClsId));

    LoadString(hinst, wBaseID+IDOFF_CLASSID, szClsId, ARRAY_SIZE(szClsId));
    
#if !defined(UNICODE) && !defined(OLE2ANSI)
    LPOLESTR lpostr = ConvertMBToOLESTR(szClsId,-1);
    BOOL fRet = OK(CLSIDFromString(lpostr, &_clsid));
    TaskFreeMem(lpostr);
#else
    BOOL fRet = OK(CLSIDFromString(szClsId, &_clsid));
#endif
    
    // load our in-place menus and accelerators
    _hicon = LoadIcon(hinst, MAKEINTRESOURCE(wBaseID+IDOFF_ICON));

    _haccel = (HACCEL)LoadAccelerators(hinst,
            MAKEINTRESOURCE(wBaseID+IDOFF_ACCELS));

    LoadResourceData(hinst,
                           MAKEINTRESOURCE(wBaseID+IDOFF_MGW),
                           &_mgw,
                           sizeof(_mgw));
    
    LoadResourceData(hinst,
                     MAKEINTRESOURCE(wBaseID+IDOFF_MISCSTATUS),
                     &_dwMiscStatus,
                     sizeof(_dwMiscStatus));

#if !defined(UNICODE) && !defined(OLE2ANSI)
    
    CHAR szUserClassType[MAX_USERTYPE_LEN];
    
#define SetWideClassType(y,x) \
    MultiByteToWideChar(CP_ACP                      \
                        , 0                         \
                        , (y)                       \
                        , -1                        \
                        , _szUserClassType[(x)]     \
                        , ARRAY_SIZE(_szUserClassType[(x)]))
    LoadString(hinst
               , wBaseID+IDOFF_USERTYPEFULL
               , szUserClassType
               , MAX_USERTYPE_LEN);
    
    SetWideClassType(szUserClassType,USERCLASSTYPE_FULL);

    LoadString(hinst
               , wBaseID+IDOFF_USERTYPESHORT
               , szUserClassType
               , MAX_USERTYPE_LEN);
    
    SetWideClassType(szUserClassType,USERCLASSTYPE_SHORT);
    
    LoadString(hinst
               , wBaseID+IDOFF_USERTYPEAPP
               , szUserClassType
               , MAX_USERTYPE_LEN);
    
    SetWideClassType(szUserClassType,USERCLASSTYPE_APPNAME);
    
    LoadString(hinst
               , wBaseID+IDOFF_DOCFEXT
               , szUserClassType
               , MAX_USERTYPE_LEN);

    MultiByteToWideChar(CP_ACP
                        , 0
                        , szUserClassType
                        , -1
                        , _szDocfileExt
                        , ARRAY_SIZE(_szDocfileExt));
#else    
    LoadString(hinst
               , wBaseID+IDOFF_USERTYPEFULL
               , _szUserClassType[USERCLASSTYPE_FULL]
               , ARRAY_SIZE(_szUserClassType[USERCLASSTYPE_FULL]));
    LoadString(hinst
               , wBaseID+IDOFF_USERTYPESHORT
               , _szUserClassType[USERCLASSTYPE_SHORT]
               , ARRAY_SIZE(_szUserClassType[USERCLASSTYPE_SHORT]));
    LoadString(hinst
               , wBaseID+IDOFF_USERTYPEAPP
               , _szUserClassType[USERCLASSTYPE_APPNAME]
               , ARRAY_SIZE(_szUserClassType[USERCLASSTYPE_APPNAME]));
    LoadString(hinst
               , wBaseID+IDOFF_DOCFEXT
               , _szDocfileExt
               , ARRAY_SIZE(_szDocfileExt));

#endif
    
    return fRet;
}

//+---------------------------------------------------------------
//
//  Member:     ClassDescriptor::LoadMenu, public
//
//  Synopsis:   Loads a copy of the menus for the server
//
//  Notes:      A single copy of the menu cannot be shared by all
//              instances of the class, like an accelerator table can.
//              This is because the menu is not a read-only resource
//              (e.g. you can "check" a menu item and merge in verb
//              menu items).  Therefore each class instance must load
//              its own copy of the menu.  This LoadMenu call is used
//              for that purpose.
//
//---------------------------------------------------------------

HMENU
ClassDescriptor::LoadMenu(void)
{
    return ::LoadMenu(_hinst, MAKEINTRESOURCE(_wBaseResID+IDOFF_MENU));
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\o2base\himetric.cxx ===
//+---------------------------------------------------------------------
//
//  File:       himetric.cxx
//
//  Contents:   Routines to convert Pixels to Himetric and vice versa
//
//----------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#define HIMETRIC_PER_INCH 2540L

//+---------------------------------------------------------------
//
//  Function:   HimetricFromHPix
//
//  Synopsis:   Converts horizontal pixel units to himetric units.
//
//----------------------------------------------------------------

long
HimetricFromHPix(int iPix)
{
   HDC hdc = GetDC(NULL);
   if (!hdc) 
       return 0;
   int iPPLI = GetDeviceCaps(hdc, LOGPIXELSX);
   ReleaseDC(NULL, hdc);

   return (HIMETRIC_PER_INCH * (long)iPix)/(long)iPPLI;
}

//+---------------------------------------------------------------
//
//  Function:   HimetricFromVPix
//
//  Synopsis:   Converts vertical pixel units to himetric units.
//
//----------------------------------------------------------------

long
HimetricFromVPix(int iPix)
{
   HDC hdc = GetDC(NULL);
   if (!hdc) 
       return 0;
   int iPPLI = GetDeviceCaps(hdc, LOGPIXELSY);
   ReleaseDC(NULL, hdc);
   return (HIMETRIC_PER_INCH * (long)iPix)/(long)iPPLI;
}

//+---------------------------------------------------------------
//
//  Function:   HPixFromHimetric
//
//  Synopsis:   Converts himetric units to horizontal pixel units.
//
//----------------------------------------------------------------

int
HPixFromHimetric(long lHi)
{
   HDC hdc = GetDC(NULL);
   if (!hdc) 
       return 0;
   int iPPLI = GetDeviceCaps(hdc, LOGPIXELSX);
   ReleaseDC(NULL, hdc);
   return (int)(( (iPPLI * lHi) + (HIMETRIC_PER_INCH / 2) )/HIMETRIC_PER_INCH);
}

//+---------------------------------------------------------------
//
//  Function:   VPixFromHimetric
//
//  Synopsis:   Converts himetric units to vertical pixel units.
//
//----------------------------------------------------------------

int
VPixFromHimetric(long lHi)
{
   HDC hdc = GetDC(NULL);
   if (!hdc) 
       return 0;
   int iPPLI = GetDeviceCaps(hdc, LOGPIXELSY);
   ReleaseDC(NULL, hdc);
   return (int)(( (iPPLI * lHi) + (HIMETRIC_PER_INCH / 2) )/HIMETRIC_PER_INCH);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\o2base\dvutils.cxx ===
//+---------------------------------------------------------------------
//
//  File:       dvutils.cxx
//
//  Contents:   Helper functions for implementing IDataObject and IViewObject
//
//----------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//
//  Globals
//

UINT OleClipFormat[OCF_LAST+1];         // array of OLE standard clipboard formats

// these are the names of the standard OLE clipboard formats that need to
// be registered.
LPTSTR OleClipNames[OCF_LAST+1] =
{
    TEXT("ObjectLink"),
    TEXT("OwnerLink"),
    TEXT("Native"),
    TEXT("FileName"),
    TEXT("NetworkName"),
    TEXT("DataObject"),
    TEXT("Embedded Object"),
    TEXT("Embed Source"),
    TEXT("Link Source"),
    TEXT("Link Source Descriptor"),
    TEXT("Object Descriptor"),
    TEXT("OleDraw")
};


//+---------------------------------------------------------------
//
//  Function:   RegisterOleClipFormats
//
//  Synopsis:   Initializes the OleClipFormat table of standard
//              OLE clipboard formats.
//
//  Notes:      The OleClipFormat table is a table of registered,
//              standard, OLE-related clipboard formats.  The table
//              is indexed by the OLECLIPFORMAT enumeration.
//              Before this table can be used it must be initialized
//              via this function.
//              This function is usually called in the WinMain or
//              LibMain of the module using the OleClipFormat table.
//
//----------------------------------------------------------------

void
RegisterOleClipFormats(void)
{
    for (int i = 0; i<= OCF_LAST; i++)
        OleClipFormat[i] = RegisterClipboardFormat(OleClipNames[i]);
}

//+---------------------------------------------------------------
//
//  Function:   IsCompatibleDevice, public
//
//  Synopsis:   Compares two DEVICETARGET structures and returns
//              TRUE if they are compatible.
//
//  Arguments:  [ptdLeft] -- A pointer to a device target
//              [ptdRight] -- Another pointer to a device target
//
//  Notes:      The target devices are compatible if they are both
//              NULL or if they are identical.  Otherwise they are
//              incompatible.
//
//----------------------------------------------------------------

BOOL
IsCompatibleDevice(DVTARGETDEVICE FAR* ptdLeft, DVTARGETDEVICE FAR* ptdRight)
{
    // same address of td; must be same (handles NULL case)
    if (ptdLeft == ptdRight)
        return TRUE;

#if 1
    
//fix for NTbug 20692 - reason: see bad assumption below
    if ((ptdRight == DVTARGETIGNORE) || (ptdLeft == DVTARGETIGNORE))
        return TRUE;
    
#endif    

//        The following is a wrong assumption for device independant formats
//        like CF_DIB and CF_METAFILE
    
    // if ones NULL, and the others not then they are incompatible
    if ((ptdRight == NULL) || (ptdLeft == NULL))
        return FALSE;

    // different sizes, not equal
    if (ptdLeft->tdSize != ptdRight->tdSize)
        return FALSE;

    return _fmemcmp(ptdLeft, ptdRight, (size_t)ptdLeft->tdSize) == 0;
}

//+---------------------------------------------------------------
//
//  Function:   IsCompatibleFormat, public
//
//  Synopsis:   Compares two FORMATETC structures and returns
//              TRUE if they are compatible.
//
//  Arguments:  [f1] -- A FORMATETC structure
//              [f2] -- Another FORMATETC structure
//
//  Notes:      This function ignores the lindex member of the
//              FORMATETCs.
//
//----------------------------------------------------------------

BOOL
IsCompatibleFormat(FORMATETC& f1, FORMATETC& f2)
{
    return f1.cfFormat == f2.cfFormat
            && IsCompatibleDevice(f1.ptd, f2.ptd)
            && (f1.dwAspect & f2.dwAspect) != 0L
            && (f1.tymed & f2.tymed) != 0;
}

//+---------------------------------------------------------------
//
//  Function:   FindCompatibleFormat
//
//  Synopsis:   Searches a table of FORMATETC structures and
//              returns the index of the first entry that is
//              compatible with a specified FORMATETC.
//
//  Arguments:  [FmtTable] -- the table of FORMATETCs
//              [iSize] -- the number of entries in the format table
//              [formatetc] -- the FORMATETC we are comparing for compatibility
//
//  Returns:    The index into the table of the compatible format, or
//              -1 if no compatible format was found.
//
//  Notes:      This function is typically used in conjunction with
//              IDataObject methods that need to check if a requested format
//              is available.
//
//----------------------------------------------------------------

int
FindCompatibleFormat(FORMATETC FmtTable[], int iSize, FORMATETC& formatetc)
{
    // look through the table for a compatible format
    for (int i = 0; i < iSize; i++)
    {
        if (IsCompatibleFormat(formatetc, FmtTable[i]))
            return i;
    }
    return -1;
}


//+---------------------------------------------------------------
//
//  Function:   GetObjectDescriptor
//
//  Synopsis:   Extracts an OBJECTDESCRIPTOR from an IDataObject,
//              if available.
//
//  Arguments:  [pDataObj] -- data object from which to extract an object descriptor
//              [pDescOut] -- object descriptor structure to fill in
//
//  Returns:    Success iff the object descriptor could be extracted.
//              This does not copy out the dwFullUserTypeName or
//              dwSrcOfCopy strings.
//
//----------------------------------------------------------------

HRESULT
GetObjectDescriptor(LPDATAOBJECT pDataObj, LPOBJECTDESCRIPTOR pDescOut)
{
    HRESULT r;
    HGLOBAL hglobal = GlobalAlloc(GMEM_SHARE, sizeof(OBJECTDESCRIPTOR)+256);
    LPOBJECTDESCRIPTOR pObjDesc = (LPOBJECTDESCRIPTOR)GlobalLock(hglobal);
    if (pObjDesc == NULL)
    {
        DOUT(TEXT("o2base/dvutils/GetObjectDescriptor failed\r\n"));
        r = E_OUTOFMEMORY;
    }
    else
    {
        FORMATETC formatetc =
            { (WORD)OleClipFormat[OCF_OBJECTDESCRIPTOR],
                NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

        STGMEDIUM stgmedium;
        stgmedium.tymed = TYMED_HGLOBAL;
        stgmedium.hGlobal = hglobal;
        stgmedium.pUnkForRelease = NULL;

        if (OK(r = pDataObj->GetDataHere(&formatetc, &stgmedium)))
        {
            if (pDescOut != NULL)
            {
                // note: in the future we may wish to copy out the strings
                // into two out parameters.  This would be used in
                // implementing the Paste Special dialog box.
                *pDescOut = *pObjDesc;
                pDescOut->dwFullUserTypeName = 0;
                pDescOut->dwSrcOfCopy = 0;
            }
        }
        GlobalUnlock(hglobal);
        GlobalFree(hglobal);
    }
    return r;
}

//+---------------------------------------------------------------
//
//  Function:   UpdateObjectDescriptor
//
//  Synopsis:   Updates the pointl and dwDrawAspects of an OBJECTDESCRIPTOR
//              on a data object
//
//  Arguments:  [pDataObj] -- the data object to update
//              [ptl] -- the pointl to update in the object descriptor
//              [dwAspect] -- the draw aspect to update in the object descriptor
//
//  Returns:    Success iff the object descriptor could be updated
//
//  Notes:      This method is for IDataObjects used in drag-drop.
//              The object being dragged supplies the object descriptor but only
//              the container knows where the point that the mouse button went
//              down relative to the corner of the object, and what aspect
//              of the object the container is displaying.
//              The container uses this method to fill in that missing information.
//              This performs a GetDataHere on the object to get a filled-in
//              object descriptor.  It then updates the pointl and dwDrawAspect
//              fields and uses SetData to update the object.
//
//----------------------------------------------------------------

HRESULT
UpdateObjectDescriptor(LPDATAOBJECT pDataObj, POINTL& ptl, DWORD dwAspect)
{
    HRESULT r;
    HGLOBAL hglobal = GlobalAlloc(GMEM_SHARE, sizeof(OBJECTDESCRIPTOR)+256);
    LPOBJECTDESCRIPTOR pObjDesc = (LPOBJECTDESCRIPTOR)GlobalLock(hglobal);
    if (pObjDesc == NULL)
    {
        DOUT(TEXT("o2base/dvutils/UpdateObjectDescriptor failed\r\n"));
        r = E_OUTOFMEMORY;
    }
    else
    {
        FORMATETC formatetc =
            { (WORD)OleClipFormat[OCF_OBJECTDESCRIPTOR],
                NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

        STGMEDIUM stgmedium;
        stgmedium.tymed = TYMED_HGLOBAL;
        stgmedium.hGlobal = hglobal;
        stgmedium.pUnkForRelease = NULL;

        if (OK(r = pDataObj->GetDataHere(&formatetc, &stgmedium)))
        {
            pObjDesc->pointl = ptl;
            pObjDesc->dwDrawAspect = dwAspect;
            r = pDataObj->SetData(&formatetc, &stgmedium, FALSE);
        }
        GlobalUnlock(hglobal);
        GlobalFree(hglobal);
    }
    return r;
}

//+---------------------------------------------------------------
//
//  Function:   DrawMetafile
//
//  Synopsis:   Creates a metafile from an IViewObject using the Draw method
//
//  Arguments:  [pVwObj] -- the view object
//              [rc] -- rectangle on the view object to draw
//              [dwAspect] -- aspect of the view object to draw, typically
//                           content or icon
//              [pHMF] -- place where handle to the metafile is drawn
//
//  Returns:    Success iff the metafile was drawn successfully.
//
//----------------------------------------------------------------

HRESULT
DrawMetafile(LPVIEWOBJECT pVwObj,
        RECT& rc,
        DWORD dwAspect,
        HMETAFILE FAR* pHMF)
{
    HRESULT hr;
    HMETAFILE hmf = NULL;
    HDC hdc;

    if ((hdc = CreateMetaFile(NULL)) == NULL)
    {
        DOUT(TEXT("o2base/dvutils/DrawMetafile failed to create metafile\r\n"));
        hr = E_OUTOFMEMORY;
    }
    else
    {
        SetMapMode(hdc, MM_ANISOTROPIC);
        SetWindowOrgEx(hdc, 0, 0, NULL);
        SetWindowExtEx(hdc, rc.right, rc.bottom, NULL);

        hr = OleDraw(pVwObj, dwAspect, hdc, &rc);

        hmf = CloseMetaFile(hdc);

        if (!OK(hr))
        {
            DeleteMetaFile(hmf);
            hmf = NULL;
        }

        if (hmf == NULL)
        {
            DOUT(TEXT("o2base/dvutils/DrawMetafile failed\r\n"));
            hr = E_OUTOFMEMORY;
        }
    }
    *pHMF = hmf;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\o2base\rotutils.cxx ===
//+---------------------------------------------------------------------
//
//  File:       rotutils.cxx
//
//  Contents:   Running Object Table helper functions
//
//----------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//+---------------------------------------------------------------
//
//  Function:   RegisterAsRunning
//
//  Synopsis:   Registers the object in the Running Object Table
//
//  Arguments:  [lpUnk] -- the object being registered
//              [lpmkFull] -- the full moniker to the object
//              [lpdwRegister] -- where the registration value will be
//                                  returned.
//
//  Notes:      c.f. RevokeAsRunning
//
//----------------------------------------------------------------

void
RegisterAsRunning(LPUNKNOWN lpUnk,
        LPMONIKER lpmkFull,
        DWORD FAR* lpdwRegister)
{
    LPRUNNINGOBJECTTABLE pROT;
    HRESULT r;

    if (OK(r = GetRunningObjectTable(0,(LPRUNNINGOBJECTTABLE FAR*)&pROT)))
    {
        // if already registered, revoke
        if (*lpdwRegister != NULL)
        {
            pROT->Revoke(*lpdwRegister);
            *lpdwRegister = NULL;
        }

        // register as running if a valid moniker is passed
        if (lpmkFull)
        {
            pROT->Register(NULL, lpUnk, lpmkFull, lpdwRegister);
        }

        pROT->Release();
    }
}


//+---------------------------------------------------------------
//
//  Function:   RevokeAsRunning
//
//  Synopsis:   Revokes an objects registration in the Running Object Table
//
//  Arguments:  [lpdwRegister] -- points to where the registration value is
//                                  for the object.  Will be set to NULL.
//
//  Notes:      c.f. RegisterAsRunning
//
//----------------------------------------------------------------

void
RevokeAsRunning(DWORD FAR* lpdwRegister)
{
    LPRUNNINGOBJECTTABLE pROT;
    HRESULT r;

    // if still registered, then revoke
    if (*lpdwRegister != NULL)
    {
        if (OK(r = GetRunningObjectTable(0,(LPRUNNINGOBJECTTABLE FAR*)&pROT)))
        {
            pROT->Revoke(*lpdwRegister);
            *lpdwRegister = NULL;
            pROT->Release();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\o2base\memutils.cxx ===
//+---------------------------------------------------------------------
//
//  File:       memutils.cxx
//
//  Contents:   IMalloc-related helpers
//
//----------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

HRESULT
OleAllocMem(MEMCTX ctx, ULONG cb, LPVOID FAR* ppv)
{
    HRESULT r;
    LPMALLOC pMalloc;
    if (OK(r = CoGetMalloc(ctx, &pMalloc)))
    {
        *ppv = pMalloc->Alloc(cb);
        if (*ppv == NULL)
        {
            DOUT(TEXT("o2base/memutils/OleAllocMem failed\r\n"));
            r = E_OUTOFMEMORY;
        }

        pMalloc->Release();
    }
    return r;
}

void
OleFreeMem(MEMCTX ctx, LPVOID pv)
{
    LPMALLOC pMalloc;
    if (OK(CoGetMalloc(ctx, &pMalloc)))
    {
        pMalloc->Free(pv);
        pMalloc->Release();
    }
}

HRESULT
OleAllocString(MEMCTX ctx, LPCOLESTR lpstrSrc, LPOLESTR FAR* ppstr)
{
    HRESULT r;
    if (lpstrSrc == NULL)
    {
        *ppstr = NULL;
        r = NOERROR;
    }
    else
    {
        r = OleAllocMem(ctx,
                (ostrlen(lpstrSrc)+1) * sizeof(OLECHAR),
                (LPVOID FAR*)ppstr);
        if (*ppstr != NULL)
        {
            ostrcpy((LPOLESTR)*ppstr, lpstrSrc);
        }
    }
    return r;
}

void
OleFreeString(MEMCTX ctx, LPOLESTR lpstr)
{
    OleFreeMem(ctx, lpstr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\o2base\ipborder.cxx ===
//+---------------------------------------------------------------------
//
//   File:       ipborder.cxx
//
//   Classes:    InPlaceBorder
//
//   Notes:      Use of this class limits windows to the use
//               of the non-client region for UIAtive borders
//               only: Standard (non-control window) scroll bars
//               are specifically NOT supported.
//
//   History:    14-May-93   CliffG        Created.
//
//------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#define IPB_GRABFACTOR  3

#define SetWF(hwnd,wf)  SetWindowLongPtr(hwnd, GWL_STYLE, \
            GetWindowLongPtr(hwnd,GWL_STYLE) | (wf))
#define ClrWF(hwnd,wf)  SetWindowLongPtr(hwnd, GWL_STYLE, \
            GetWindowLongPtr(hwnd,GWL_STYLE) &~(wf))
#define TestWF(hwnd,wf) (GetWindowLongPtr(hwnd,GWL_STYLE) & (wf))


    WORD InPlaceBorder::_cUsage = 0;
    HBRUSH InPlaceBorder::_hbrActiveCaption;
    HBRUSH InPlaceBorder::_hbrInActiveCaption;


//+---------------------------------------------------------------
//
//  Member: InPlaceBorder::DrawFrame
//
//---------------------------------------------------------------
void
InPlaceBorder::DrawFrame(HWND hwnd)
{
    if(!_fUIActive)
        return;

    HDC hdc = GetWindowDC(hwnd);
    if (!hdc)
        return;

    HBRUSH hbr;
    if(_fParentActive)
        hbr = _hbrActiveCaption;
    else
        hbr = _hbrInActiveCaption;

    if (hbr)
    {
        RECT rcWhole;
        GetWindowRect(hwnd, &rcWhole);
        OffsetRect(&rcWhole, -rcWhole.left, -rcWhole.top);
        RECT rc;
        //Top
        rc = rcWhole;
        rc.bottom = rc.top + _cyFrame;
        FillRect(hdc, &rc, hbr);
        //Left
        rc = rcWhole;
        rc.right = rc.left + _cxFrame;
        FillRect(hdc, &rc, hbr);
        //Bottom
        rc = rcWhole;
        rc.top = rc.bottom - _cyFrame;
        FillRect(hdc, &rc, hbr);
        //Right
        rc = rcWhole;
        rc.left = rc.right - _cxFrame;
        FillRect(hdc, &rc, hbr);

        if(TestWF(hwnd, WS_THICKFRAME)) //Resizable window?
        {
            //
            //Draw grab handles at 4 corners of the border...
            //
            hbr = (HBRUSH)GetStockObject( BLACK_BRUSH );
            //TopLeft
            rc = rcWhole;
            rc.right = rc.left + _cxFrame;
            rc.bottom = rc.top + _cyFrame * IPB_GRABFACTOR;
            FillRect(hdc, &rc, hbr);
            rc.bottom = rc.top + _cyFrame;
            rc.right = rc.left + _cxFrame * IPB_GRABFACTOR;
            FillRect(hdc, &rc, hbr);
            //TopRight
            rc.right = rcWhole.right;
            rc.left = rc.right - _cxFrame * IPB_GRABFACTOR;
            FillRect(hdc, &rc, hbr);
            rc.left = rc.right - _cxFrame;
            rc.bottom = rc.top + _cyFrame * IPB_GRABFACTOR;
            FillRect(hdc, &rc, hbr);
            //BottomLeft
            rc = rcWhole;
            rc.top = rc.bottom - _cyFrame * IPB_GRABFACTOR;
            rc.right = rc.left + _cxFrame;
            FillRect(hdc, &rc, hbr);
            rc.top = rc.bottom - _cyFrame;
            rc.right = rc.left + _cxFrame * IPB_GRABFACTOR;
            FillRect(hdc, &rc, hbr);
            //BottomRight
            rc.right = rcWhole.right;
            rc.left = rc.right - _cxFrame * IPB_GRABFACTOR;
            FillRect(hdc, &rc, hbr);
            rc.right = rcWhole.right;
            rc.left = rc.right - _cxFrame;
            rc.top = rc.bottom - _cyFrame * IPB_GRABFACTOR;
            FillRect(hdc, &rc, hbr);
        }
    }

    ReleaseDC(hwnd, hdc);
}

//+---------------------------------------------------------------
//
//  Member: InPlaceBorder::HitTest
//
//---------------------------------------------------------------
LONG
InPlaceBorder::HitTest(HWND hwnd, int x, int y)
{
    POINT pt = { x, y };
    RECT rcClient;

    GetWindowRect(hwnd, &rcClient);
    CalcClientRect(hwnd, &rcClient);
    if (PtInRect(&rcClient, pt))
        return HTCLIENT;

    // We're somewhere on the window frame.
    if (y >= rcClient.bottom)
    {
        if (x <= rcClient.left + _cxFrame * IPB_GRABFACTOR)
            return HTBOTTOMLEFT;
        if (x >= rcClient.right - _cxFrame * IPB_GRABFACTOR)
            return HTBOTTOMRIGHT;
        return HTBOTTOM;
    }
    else if (y <= rcClient.top)
    {
        if (x <= rcClient.left + _cxFrame * IPB_GRABFACTOR)
            return(HTTOPLEFT);
        if (x >= rcClient.right - _cxFrame * IPB_GRABFACTOR)
            return(HTTOPRIGHT);
        return HTTOP;
    }
    else if (x <= rcClient.left)
    {
        if (y <= rcClient.top + _cyFrame * IPB_GRABFACTOR)
            return HTTOPLEFT;
        if (y >= rcClient.bottom - _cyFrame * IPB_GRABFACTOR)
            return HTBOTTOMLEFT;
        return HTLEFT;
    }
    else
    {
        if (y <= rcClient.top + _cyFrame * IPB_GRABFACTOR)
            return HTTOPRIGHT;
        if (y >= rcClient.bottom - _cyFrame * IPB_GRABFACTOR)
            return HTBOTTOMRIGHT;
        return HTRIGHT;
    }

    return HTNOWHERE;
}

//+---------------------------------------------------------------
//
//  Member: InPlaceBorder::DefWindowProc
//
//---------------------------------------------------------------
LRESULT
InPlaceBorder::DefWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet = 0L;
    //REVIEW code assumes an SDI app...
    if(_hwnd == NULL)
        return ::DefWindowProc(hwnd,msg,wParam,lParam);

    switch (msg)
    {
    case WM_WINDOWPOSCHANGED:
        if(_pSite != NULL && _cResizing == 0 && _fUIActive)
        {
            ++_cResizing;
            RECT rc;
            GetChildWindowRect(hwnd, &rc);
            InflateRect(&rc,-_cxFrame,-_cyFrame);
            _pSite->OnPosRectChange(&rc);
            _cResizing--;
        }
        break;
    case WM_NCCALCSIZE:     // lParam == LPRECT of window rect
        //
        //Turn off the WS_THICKFRAME style bit during
        //default processing so we keep ownership of visualization...
        //
        if (TestWF(hwnd, WS_THICKFRAME))
        {
            ClrWF(hwnd, WS_THICKFRAME);
            lRet = ::DefWindowProc(hwnd, msg, wParam,lParam);
            SetWF(hwnd, WS_THICKFRAME);
        }
        CalcClientRect(hwnd, (LPRECT)lParam);
        return lRet;

    case WM_NCHITTEST:      // lParam is POINT in screen cords
        return HitTest(hwnd, LOWORD(lParam), HIWORD(lParam));

    case WM_NCPAINT:
        DrawFrame(hwnd);
        return 0L;

    case WM_NCLBUTTONDOWN:
    case WM_NCMOUSEMOVE:
    case WM_NCLBUTTONUP:
    case WM_NCLBUTTONDBLCLK:
    case WM_NCRBUTTONDOWN:
    case WM_NCRBUTTONUP:
    case WM_NCRBUTTONDBLCLK:
    case WM_NCMBUTTONDOWN:
    case WM_NCMBUTTONUP:
    case WM_NCMBUTTONDBLCLK:
    case WM_NCACTIVATE:     // wParam == active state
    case WM_NCCREATE:       // Sent before WM_CREATE
    case WM_NCDESTROY:      // Sent before WM_DESTROY
        break;
    }

    return ::DefWindowProc(hwnd, msg, wParam, lParam);
}

//+---------------------------------------------------------------
//
//  Member: InPlaceBorder::InPlaceBorder
//
//---------------------------------------------------------------
InPlaceBorder::InPlaceBorder(void)
{
    _fParentActive = TRUE;
    _fUIActive = FALSE;
    _hwnd = NULL;
    _pSite = NULL;
    _cResizing = 0;
    _cxFrame = _cyFrame = IPBORDER_THICKNESS;
    if(_cUsage++ == 0)
    {
        // the following could fail and we would be hosed...
        _hbrActiveCaption = CreateHatchBrush(HS_BDIAGONAL,
            GetSysColor(COLOR_ACTIVECAPTION));
        _hbrInActiveCaption = CreateHatchBrush(HS_BDIAGONAL,
            GetSysColor(COLOR_WINDOWFRAME));
    }
}

//+---------------------------------------------------------------
//
//  Member: InPlaceBorder::~InPlaceBorder
//
//---------------------------------------------------------------
InPlaceBorder::~InPlaceBorder(void)
{
    if(--_cUsage == 0)
    {
        DeleteObject(_hbrActiveCaption);
        _hbrActiveCaption = NULL;
        DeleteObject(_hbrInActiveCaption);
        _hbrInActiveCaption = NULL;
    }
}

//+---------------------------------------------------------------
//
//  Member: InPlaceBorder::SetState
//
//Change the border state: reflected in the nonclient window border
//---------------------------------------------------------------
void
InPlaceBorder::SetUIActive(BOOL fUIActive)
{
    if(_hwnd == NULL)
        return;

    if(_fUIActive != fUIActive)
    {
        RECT rcClient;
        GetChildWindowRect(_hwnd, &rcClient);
        int cx = rcClient.right - rcClient.left;
        int cy = rcClient.bottom - rcClient.top;
        int x = rcClient.left;
        int y = rcClient.top;
        BOOL fResize = FALSE;
        if (fUIActive)
        {
            fResize = TRUE;
            cx += _cxFrame * 2;
            cy += _cyFrame * 2;
            x -= _cxFrame;
            y -= _cyFrame;
        }
        else if (_fUIActive)
        {
            fResize = TRUE;
            cx -= _cxFrame * 2;
            cy -= _cyFrame * 2;
            x += _cxFrame;
            y += _cyFrame;
        }
        if (fResize)
        {
            //
            //Set our state member up so CalcClientRect generates correct values,
            //then move the window (keeping client area same size and position)
            //
            _fUIActive = fUIActive;
            ++_cResizing;
            SetWindowPos( _hwnd, NULL, x, y, cx, cy, SWP_FRAMECHANGED |
                SWP_NOACTIVATE | SWP_NOZORDER);
            RedrawFrame();
            _cResizing--;
        }
        else
        {
            InvalidateFrame();
        }
    }
    _fUIActive = fUIActive;
}

//+---------------------------------------------------------------
//
//  Member: InPlaceBorder::SetSize
//
//---------------------------------------------------------------
void
InPlaceBorder::SetSize(HWND hwnd, RECT& rc)
{
    int cx = rc.right - rc.left;
    int cy = rc.bottom - rc.top;
    int x = rc.left;
    int y = rc.top;
    if(_fUIActive)
    {
        cx += _cxFrame * 2;
        cy += _cyFrame * 2;
        x -= _cxFrame;
        y -= _cyFrame;
    }
    ++_cResizing;
    MoveWindow(hwnd, x, y, cx, cy, TRUE);
    _cResizing--;
}

//+---------------------------------------------------------------
//
//  Member: InPlaceBorder::Erase
//
// Force border state to non-UIActive, managing the coresponding
// change in border appearance
//
//---------------------------------------------------------------
void
InPlaceBorder::Erase(void)
{
    if(_hwnd == NULL)
        return;
    SetUIActive(FALSE);
    _fParentActive = TRUE;
    InvalidateFrame();
    RedrawFrame();
}


//+---------------------------------------------------------------
//
//  Member: InPlaceBorder::SetBorderSize
//
//---------------------------------------------------------------
void
InPlaceBorder::SetBorderSize( int cx, int cy )
{
    if(cx < 0)
        cx = 0;
    if(cy < 0)
        cy = 0;
    _cxFrame = cx;
    _cyFrame = cy;
    InvalidateFrame();
    RedrawFrame();
}

//+---------------------------------------------------------------
//
//  Member: InPlaceBorder::GetBorderSize
//
//---------------------------------------------------------------
void
InPlaceBorder::GetBorderSize( LPINT pcx, LPINT pcy )
{
    *pcx = _cxFrame;
    *pcy = _cyFrame;
}

//+---------------------------------------------------------------
//
//  Member: InPlaceBorder::Attach
//
//---------------------------------------------------------------
void
InPlaceBorder::Attach(HWND hwnd, BOOL fUIActive)
{
    if((_hwnd = hwnd) != NULL)
    {
        SetUIActive(fUIActive);
        InvalidateFrame();  //force first-time NCCALC
    }
}

void
InPlaceBorder::Bind(LPOLEINPLACESITE pSite, HWND hwnd, BOOL fUIActive)
{
    _pSite = NULL;
    if((_hwnd = hwnd) != NULL && (_pSite = pSite) != NULL)
    {
        SetUIActive(fUIActive);
        InvalidateFrame();  //force first-time NCCALC
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\o2base\sdv.cxx ===
//+---------------------------------------------------------------------
//
//   File:       sdv.cxx
//
//------------------------------------------------------------------------

//[ srvrdv_overview
/*
                        SrvrDV Overview

The SrvrDV base class implements the persistent data and view aspects common
to most OLE Compound Document objects.  It implements the IDataObject,
IViewObject, and IPersist family of interfaces.

The set of formats supported in IDataObject::GetData and SetData methods is
very object dependent.  SrvrDV uses a table approach to allow each derived
class to specify precisely exactly the set of formats supported.  For each
of GetData and SetData there is a pair of tables.  One is a table of FORMATETC
structures that specify information about the format supported.  A parallel
table contains a pointer to a function that implements each format supported.
SrvrDV has a set of static methods that implement the standard OLE clipboard
formats.  The derived class can include these methods in its Get/Set tables.

*/
//]

#include "headers.hxx"
#pragma hdrstop

OLECHAR szContents[] = OLETEXT("contents");

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::SrvrDV, protected
//
//  Synopsis:   Constructor for SrvrCtrl object
//
//  Notes:      To create a properly initialized object you must
//              call the Init method immediately after construction.
//
//---------------------------------------------------------------

SrvrDV::SrvrDV(void)
{
    DOUT(TEXT("SrvrDV: Constructing\r\n"));

    _pmk = NULL;
    _lpstrDisplayName = NULL;
    _sizel.cx = 0; _sizel.cy = 0;
    _pDataAdviseHolder = NULL;

    _fFrozen = FALSE;
    _pViewAdviseHolder = NULL;

    _fDirty = FALSE;
    _fNoScribble = FALSE;
    _pStg = NULL;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::Init, protected
//
//  Synopsis:   Fully initializes a SrvrCtrl object as part of a compound
//              document server aggregate
//
//  Arguments:  [pClass] -- The initialized class descriptor for the server
//              [pCtrl] -- The control subobject of the server we are a part of.
//
//  Returns:    NOERROR if successful
//
//  Notes:      The Init method of the control subobject creates the data/view and
//              inplace subobjects of the object and calls the respective Init methods
//              on each, including this one.
//              The class descriptor pointer is saved in the protected _pClass
//              member variable where it is accessible during the lifetime
//              of the object.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::Init(LPCLASSDESCRIPTOR pClass, LPSRVRCTRL pCtrl)
{
    _pClass = pClass;
    _pCtrl = pCtrl;

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::Init, protected
//
//  Synopsis:   Fully initializes a SrvrCtrl object from an existing object
//              to be used as a data transfer object
//
//  Arguments:  [pClass] -- The initialized class descriptor for the server
//              [pDV] -- The data/view subobject of the object that is the source
//                       of this transfer data object
//
//  Returns:    NOERROR if successful
//
//  Notes:      This method is used in the process of the GetClipboardCopy method
//              for obtaining a transfer data object from an existing object.
//              The class descriptor pointer is saved in the protected _pClass
//              member variable where it is accessible during the lifetime
//              of the object.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::Init(LPCLASSDESCRIPTOR pClass, LPSRVRDV pDV)
{
    _pClass = pClass;           // stash the class descriptor pointer
    _pCtrl = NULL;              // we are a free-floating transfer data object

    // copy over member variables as appropriate
    _pmk = pDV->_pmk;
    if (_pmk != NULL)
       _pmk->AddRef();

    TaskAllocString(pDV->_lpstrDisplayName, &_lpstrDisplayName);
    _sizel = pDV->_sizel;

    // we create a temporary IStorage and take a snapshot of the storage.
    // The temporary IStorage will be automatically deleted when this
    // data object is released
    // What happens when we run out of memory?
    // Should re-try with disk-based docfile?
    //
    HRESULT hr;
    LPSTORAGE pStg;
    if (OK(hr = CreateStorageOnHGlobal(NULL, &pStg)))
    {
        // do a "Save Copy As" into our storage instance.
        if (OK(hr = OleSave((LPPERSISTSTORAGE)pDV, pStg, FALSE)))
        {
            if (OK(hr = pStg->Commit(STGC_DEFAULT)))
            {
                if (OK(hr = ((LPPERSISTSTORAGE)pDV)->SaveCompleted(NULL)))
                    (_pStg = pStg)->AddRef();
            }
        }
        pStg->Release();
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::~SrvrDV, protected
//
//  Synopsis:   Destructor for the SrvrDV object
//
//  Notes:      The destructor is called as a result of the servers
//              reference count going to 0.  It releases any held resources
//              including advise holders and storages.
//
//---------------------------------------------------------------

SrvrDV::~SrvrDV(void)
{
    if (_pmk != NULL)
        _pmk->Release();

    if (_lpstrDisplayName != NULL)
        TaskFreeString(_lpstrDisplayName);

    if (_pDataAdviseHolder != NULL)
        _pDataAdviseHolder->Release();

    if (_pViewAdviseHolder != NULL)
        _pViewAdviseHolder->Release();

    if (_pStg != NULL)
        _pStg->Release();

    DOUT(TEXT("SrvrDV: Destructed\r\n"));
}

#ifdef DOCGEN  // documentation for pure virtual function
//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetClipboardCopy, public
//
//  Synopsis:   Produces a data-transfer object representing a snapshot
//              of this data/view object
//
//  Arguments:  [ppDV] -- The place where the data-transfer object is returned
//
//  Returns:    Success if the data-transfer object was created.
//
//  Notes:      This method is called
//              as a result of an IOleObject::GetClipboardData call on the
//              control subobject.  The overridden method should create a new
//              instance of itself and call the appropriate Init method on
//              the new instance passing the `this' pointer.  This way the
//              new instance can initialize itself as a snapshot of this object.
//              All servers must override this pure virtual method.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::GetClipboardCopy(LPSRVRDV FAR* ppDV)
{}
#endif  // DOCGEN

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::SetExtent, public
//
//  Synopsis:   Informs the object that it has a new expected size
//
//  Notes:      IOleObject::SetExtent and GetExtent methods are passed
//              directly from the control subobject to the data/view subobject
//              via these methods.   See OLE documentation for the
//              arguments and return values.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::SetExtent(DWORD dwAspect, SIZEL& sizel)
{
    HRESULT hr = NOERROR;
    switch(dwAspect)
    {
    case DVASPECT_CONTENT:
    case DVASPECT_DOCPRINT:
#if 1
        // NTBug #20692: Fail Metafile setextent, because
        //    Powerpoint tries to resize things in weird ways.
        hr = E_FAIL;            // icon aspect is fixed size        
#else
        _sizel = sizel;
#endif        
        break;
    case DVASPECT_THUMBNAIL:    //REVIEW: what size is a thumbnail?
    case DVASPECT_ICON:
        DOUT(TEXT("SrvrDV::SetExtent E_FAIL\r\n"));
        hr = E_FAIL; // icon aspect is fixed size
        break;
    default:
        DOUT(TEXT("SrvrDV::SetExtent E_INVALIDARG\r\n"));
        hr = E_INVALIDARG;
        break;
    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetExtent, public
//
//  Synopsis:   Requests the current size for some draw aspect of the object
//
//  Notes:      IOleObject::SetExtent and GetExtent methods are passed
//              directly from the control subobject to the data/view subobject
//              via these methods.   See OLE documentation for the
//              arguments and return values.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::GetExtent(DWORD dwAspect, LPSIZEL lpsizel)
{
#if DBG
    TCHAR achTemp[256];
    wsprintf(achTemp,TEXT("SrvrDV::GetExtent (dwApsect = %ld, cx = %ld, cy = %ld)\r\n"),
            dwAspect, _sizel.cx, _sizel.cy);
    DOUT(achTemp);
#endif
    
    HRESULT hr = NOERROR;
    switch(dwAspect) {
    default:
        DOUT(TEXT("SrvrDV::GetExtent INVALIDARG\r\n"));
    case DVASPECT_CONTENT:
    case DVASPECT_DOCPRINT:
        *lpsizel = _sizel;
        break;

    case DVASPECT_THUMBNAIL:
    case DVASPECT_ICON:
        // The iconic view is actually a metafile of the
        // icon with a text-string underneath.
        // This isn't the right calculation...
        lpsizel->cx = HimetricFromHPix(32);
        lpsizel->cy = HimetricFromVPix(32);
        break;

    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::OnDataChange, public
//
//  Synopsis:   Sets the dirty flag and raises data and view changed
//              to all registered advises
//
//  Arguments:  [dwAdvf] -- from the ADVF Data Advise flags.
//                          Usually this is 0.  ADVF_DATAONSTOP is used
//                          when the object is closing down.
//  Notes:      This function should be called whenever the native
//              data of the object is modified.
//
//---------------------------------------------------------------

void
SrvrDV::OnDataChange(DWORD dwAdvf)
{
    _fDirty = TRUE;
    if (_pViewAdviseHolder != NULL)
        _pViewAdviseHolder->SendOnViewChange(DVASPECT_CONTENT);
    if (_pDataAdviseHolder != NULL)
        _pDataAdviseHolder->SendOnDataChange((LPDATAOBJECT)this, 0, dwAdvf);
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::SetMoniker, public
//
//  Synopsis:   Informs the object of its new, full moniker
//
//  Arguments:  [pmk] -- full moniker to the object
//
//  Notes:      The data/view subobject records the full moniker to the
//              object so it can properly dispense the standard OLE
//              Object Descriptor and Link Source clipboard formats.
//              This method is called whenever the IOleObject::SetMoniker
//              method is called on the control subobject.
//
//---------------------------------------------------------------

void
SrvrDV::SetMoniker(LPMONIKER pmk)
{
    if (_pmk != NULL)
    {
        _pmk->Release();

        if (_lpstrDisplayName != NULL)        // flush our cached display name
        {
            TaskFreeString(_lpstrDisplayName);
            _lpstrDisplayName = NULL;
        }
    }

    _pmk = pmk;

    if (_pmk != NULL)
    {
        _pmk->AddRef();
    }
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetMoniker, public
//
//  Synopsis:   Returns the full moniker to the object
//
//  Arguments:  [dwAssign] -- See IOleObject::GetMoniker
//              [ppmk] -- The place where the moniker is returned
//
//  Returns:    Success if the moniker is available.
//
//  Notes:      This returns the moniker that this data/view subobject has
//              previously recorded.  If no moniker is yet assigned
//              then the moniker is requested from the client site
//              via the IOleObject::GetMoniker method on the control subobject.
//              This method is used by the GetOBJECTDESCRIPTOR and GetLINKSOURCE
//              methods.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::GetMoniker(DWORD dwAssign, LPMONIKER FAR* ppmk)
{
    *ppmk = NULL;   // set out params to NULL

    HRESULT hr = NOERROR;
    if (_pmk == NULL)
    {
        if (_pCtrl == NULL)
        {
            DOUT(TEXT("SrvrDV::GetMoniker E_INVALIDARG\r\n"));
            hr = MK_E_UNAVAILABLE;
        }
        else
        {
            hr = _pCtrl->GetMoniker(dwAssign, OLEWHICHMK_OBJFULL, &_pmk);
        }
    }

    if (OK(hr))
        (*ppmk = _pmk)->AddRef();

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetMonikerDisplayName, public
//
//  Synopsis:   Returns the display name from the object's moniker
//
//  Notes:      The display name of the object is used in for
//              dispensing the Object Descriptor clipboard format.
//              The caller must not free the string returned.
//
//---------------------------------------------------------------

LPOLESTR
SrvrDV::GetMonikerDisplayName(DWORD dwAssign)
{
    //
    // NOTE: default dwAssign is OLEGETMONIKER_ONLYIFTHERE
    //
    // we maintain a moniker display name cache in the form of member
    // variable _lpstrDisplayName.
    //
    // If we don't have a display name cached then take our moniker and
    // squeeze a display name out of it
    //
    if (!_lpstrDisplayName)
    {
        LPMONIKER pmk;
        if (OK(GetMoniker(dwAssign, &pmk)))
        {
            ::GetMonikerDisplayName(pmk, &_lpstrDisplayName);
            pmk->Release();
        }
    }
    return _lpstrDisplayName;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetEMBEDDEDOBJECT, public
//
//  Synopsis:   Implementation of IDataObject::GetData and GetDataHere
//              for the standard Embedded Object clipboard format
//
//  Arguments:  [pv] -- pointer to a SrvrDV object
//              [pformatetc] -- as in IDataObject::GetData, GetDataHere
//              [pmedium] -- as in IDataObject::GetData, GetDataHere
//              [fHere] -- TRUE for GetDataHere, FALSE for GetData
//
//  Returns:    Success if the clipboard format could be dispensed
//
//  Notes:      This and the other static GetXXX methods are for use
//              in the server's Get format tables.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::GetEMBEDDEDOBJECT( LPSRVRDV pDV,
                        LPFORMATETC pformatetc,
                        LPSTGMEDIUM pmedium,
                        BOOL fHere)
{
    LPPERSISTSTORAGE pPStg = (LPPERSISTSTORAGE)(LPSRVRDV)pDV;
    HRESULT hr = NOERROR;
    if (!fHere && pmedium)
    {
        // fill in the pmedium structure
        pmedium->tymed = TYMED_ISTORAGE;
        hr = StgCreateDocfile(NULL,
                            STGM_DFRALL | STGM_CREATE | STGM_DELETEONRELEASE,
                            0L,
                            &pmedium->pstg);
        pmedium->pUnkForRelease = NULL;
    }

    if (OK(hr) && pmedium && pPStg)
    {
        if (OK(hr = OleSave(pPStg, pmedium->pstg, FALSE)))
            hr = pPStg->SaveCompleted(NULL);

        // if we failed somehow and yet created a docfile, then we will
        // release the docfile to delete it
        //
        if (!OK(hr) && !fHere)
            pmedium->pstg->Release();
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetMETAFILEPICT, public
//
//  Synopsis:   Implementation of IDataObject::GetData and GetDataHere
//              for the standard Metafilepict clipboard format
//
//  Arguments:  [pv] -- pointer to a SrvrDV object
//              [pformatetc] -- as in IDataObject::GetData, GetDataHere
//              [pmedium] -- as in IDataObject::GetData, GetDataHere
//              [fHere] -- TRUE for GetDataHere, FALSE for GetData
//
//  Returns:    Success if the clipboard format could be dispensed
//
//  Notes:      This member function uses IViewObject::Draw to construct
//              the metafile pict.
//              This and the other static GetXXX methods are for use
//              in the server's Get format tables.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::GetMETAFILEPICT( LPSRVRDV pDV,
                        LPFORMATETC pformatetc,
                        LPSTGMEDIUM pmedium,
                        BOOL fHere)
{
    DOUT(TEXT("o2base/SrvrDV::GetMETAFILEPICT\r\n"));

    LPVIEWOBJECT pView = (LPVIEWOBJECT)pDV;
    SIZEL sizel;
    pDV->GetExtent(pformatetc->dwAspect, &sizel);

    RECT rc = { 0, 0, sizel.cx, sizel.cy };
    HRESULT hr = NOERROR;
    if (!fHere)
    {
        // fill in the pmedium structure
        pmedium->tymed = TYMED_MFPICT;
        pmedium->hGlobal = GlobalAlloc(GMEM_SHARE, sizeof(METAFILEPICT));
        if (pmedium->hGlobal == NULL)
        {
            DOUT(TEXT("o2base/SrvrDV::GetMETAFILEPICT failed\r\n"));
            hr = E_OUTOFMEMORY;
        }
        pmedium->pUnkForRelease = NULL;
    }

    if (OK(hr))
    {
        HMETAFILE hmf;
        if (OK(hr = DrawMetafile(pView, rc, pformatetc->dwAspect, &hmf)))
        {
            LPMETAFILEPICT pPict = (LPMETAFILEPICT)GlobalLock(pmedium->hGlobal);
            if (pPict == NULL)
            {
                DOUT(TEXT("SrvrDV::GetMETAFILEPICT E_INVALIDARG\r\n"));

                DeleteMetaFile(hmf);
                hr = E_INVALIDARG;
            }
            else
            {
                // fill in the object descriptor
                pPict->mm   =  MM_ANISOTROPIC;
                pPict->hMF  =  hmf;
                pPict->xExt =  rc.right;
                pPict->yExt =  rc.bottom;

                GlobalUnlock(pmedium->hGlobal);
            }
        }

        // if we failed somehow and yet allocated memory,
        // then we will release it here...
        //
        if (!OK(hr) && !fHere)
        {
            GlobalFree(pmedium->hGlobal);
            pmedium->hGlobal = NULL;
        }
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetOBJECTDESCRIPTOR, public
//
//  Synopsis:   Implementation of IDataObject::GetData and GetDataHere
//              for the standard Object Descriptor clipboard format
//
//  Arguments:  [pv] -- pointer to a SrvrDV object
//              [pformatetc] -- as in IDataObject::GetData, GetDataHere
//              [pmedium] -- as in IDataObject::GetData, GetDataHere
//              [fHere] -- TRUE for GetDataHere, FALSE for GetData
//
//  Returns:    Success if the clipboard format could be dispensed
//
//  Notes:      This and the other static GetXXX methods are for use
//              in the server's Get format tables.
//
//---------------------------------------------------------------
         
HRESULT
SrvrDV::GetOBJECTDESCRIPTOR( LPSRVRDV pDV,
                            LPFORMATETC pformatetc,
                            LPSTGMEDIUM pmedium,
                            BOOL fHere)
{
    HRESULT hr = NOERROR;
    LPCLASSDESCRIPTOR pClass = pDV->_pClass;

    //
    //REVIEW: what's the best display name for the OBJECTDESCRIPTOR?
    //

    OLECHAR achDisplay[256];
    
    ostrcpy(achDisplay, OLETEXT("Microsoft "));
    ostrcat(achDisplay, pClass->_szUserClassType[USERCLASSTYPE_FULL]);
    
    LPOLESTR    lpstrDisplay = achDisplay;
    DWORD       dwDisplay = lpstrDisplay ?
                            (ostrlen(lpstrDisplay) + 1) * sizeof(OLECHAR) : 0;
    LPOLESTR    lpstrUserTypeFull = pClass->_szUserClassType[USERCLASSTYPE_FULL];
    DWORD       dwUserTypeFull = lpstrUserTypeFull ?
                            (ostrlen(lpstrUserTypeFull) + 1) * sizeof(OLECHAR) : 0;

    DWORD dwSize = sizeof(OBJECTDESCRIPTOR) + dwUserTypeFull + dwDisplay;

    if (!fHere)
    {
        // compute the amount of memory required

        // fill in the pmedium structure
        pmedium->tymed = TYMED_HGLOBAL;
        pmedium->hGlobal = GlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE, dwSize);
        if (pmedium->hGlobal == NULL)
        {
            DOUT(TEXT("o2base/SrvrDV::GetOBJECTDESCRIPTOR failed (pmedium)\r\n"));
            hr = E_OUTOFMEMORY;
        }

        pmedium->pUnkForRelease = NULL;
    }

    if (OK(hr) && (GlobalSize(pmedium->hGlobal) >= dwSize))
    {
        LPOBJECTDESCRIPTOR pObjDesc =
                (LPOBJECTDESCRIPTOR)GlobalLock(pmedium->hGlobal);
        if (pObjDesc == NULL)
        {
            DOUT(TEXT("o2base/SrvrDV::GetOBJECTDESCRIPTOR failed\r\n"));
            hr = E_OUTOFMEMORY;
        }
        else
        {
            //
            // fill in the object descriptor
            //
            pObjDesc->cbSize        = dwSize;
            pObjDesc->clsid         = pClass->_clsid;
            pObjDesc->dwDrawAspect  = DVASPECT_CONTENT;
            pObjDesc->sizel         = pDV->_sizel;
            pObjDesc->pointl.y      = pObjDesc->pointl.x = 0;
            pObjDesc->dwStatus      = pClass->_dwMiscStatus;

            LPOLESTR lpstrDest = (LPOLESTR)(pObjDesc + 1);
            if(lpstrUserTypeFull)
            {
                ostrcpy(lpstrDest, lpstrUserTypeFull);
#if DBG
#if !defined(UNICODE) && !defined(OLE2ANSI)
                LPSTR lp = ConvertOLESTRToMB(lpstrDest, -1);
                OutputDebugStringA(lp);
                OutputDebugStringA("\r\n");
                TaskFreeMem(lp);
#endif                
#endif                
                pObjDesc->dwFullUserTypeName = sizeof(OBJECTDESCRIPTOR);
                lpstrDest += ostrlen(lpstrUserTypeFull) + 1;
                
            }
            else
                pObjDesc->dwFullUserTypeName = 0;

            if (lpstrDisplay)
            {
                pObjDesc->dwSrcOfCopy = pObjDesc->dwFullUserTypeName + dwUserTypeFull;
                ostrcpy(lpstrDest, lpstrDisplay);
#if DBG
#if !defined(UNICODE) && !defined(OLE2ANSI)
                LPSTR lp = ConvertOLESTRToMB(lpstrDest, -1);
                OutputDebugStringA(lp);
                OutputDebugStringA("\r\n");
                TaskFreeMem(lp);
#endif                
#endif                
            }
            else
                pObjDesc->dwSrcOfCopy = 0;

            GlobalUnlock(pmedium->hGlobal);
            hr = NOERROR;
        }

        // if we failed somehow and yet allocated memory,
        // then we will release it here...
        if (!OK(hr) && !fHere)
        {
            GlobalFree(pmedium->hGlobal);
            pmedium->hGlobal = NULL;
        }
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetLINKSOURCE, public
//
//  Synopsis:   Implementation of IDataObject::GetData and GetDataHere
//              for the standard Link Source clipboard format
//
//  Arguments:  [pv] -- pointer to a SrvrDV object
//              [pformatetc] -- as in IDataObject::GetData, GetDataHere
//              [pmedium] -- as in IDataObject::GetData, GetDataHere
//              [fHere] -- TRUE for GetDataHere, FALSE for GetData
//
//  Returns:    Success if the clipboard format could be dispensed
//
//  Notes:      This method uses the moniker cached by the data/view
//              object.
//              This and the other static GetXXX methods are for use
//              in the server's Get format tables.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::GetLINKSOURCE( LPSRVRDV pDV,
                    LPFORMATETC pformatetc,
                    LPSTGMEDIUM pmedium,
                    BOOL fHere)
{
    LPMONIKER pmk;
    HRESULT hr;

    if (OK(hr = pDV->GetMoniker(OLEGETMONIKER_FORCEASSIGN, &pmk)))
    {
        if (!fHere)
        {
            pmedium->tymed = TYMED_ISTREAM;
            HRESULT hr = CreateStreamOnHGlobal(NULL, TRUE, &pmedium->pstm);
            pmedium->pUnkForRelease = NULL;
        }

        if (OK(hr))
        {
            CLSID clsid;
            if (OK(hr = pmk->GetClassID(&clsid)))
            {
                if (OK(hr = WriteClassStm(pmedium->pstm, clsid)))
                    hr = pmk->Save(pmedium->pstm, FALSE);
                
                pDV->GetClassID(&clsid);
                WriteClassStm(pmedium->pstm, clsid);
            }
        }

        pmk->Release();
    }

    return hr;
}


//+--------------------------------------------------------------
//
//  Member:     SrvrDV::GetData, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method searches the server's Get format table
//              for a compatible format.  If one is found it calls
//              the corresponding Get function.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::GetData(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium)
{
    DOUT(TEXT("SrvrDV:GetData\r\n"));

    if (pformatetc == NULL || pmedium == NULL)
    {
        DOUT(TEXT("SrvrDV::GetData E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    HRESULT hr;
    
    int i = FindCompatibleFormat(_pClass->_pGetFmtTable,
            _pClass->_cGetFmtTable,
            *pformatetc);
    
    if (i < 0)
    {
        DOUT(TEXT("SrvrDV::GetData DV_E_FORMATETC\r\n"));
        hr = DV_E_FORMATETC;
    }
    else
    {
        hr = (*_pGetFuncs[i]) (this, pformatetc, pmedium, FALSE);
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetDataHere, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method searches the server's Get format table
//              for a compatible format.  If one is found it calls
//              the corresponding Get function.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::GetDataHere(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium)
{
    DOUT(TEXT("SrvrDV:GetDataHere\r\n"));

    HRESULT hr;
    int i = FindCompatibleFormat(_pClass->_pGetFmtTable,
            _pClass->_cGetFmtTable,
            *pformatetc);
    if (i < 0)
    {
        DOUT(TEXT("SrvrDV::GetDataHere DV_E_FORMATETC\r\n"));
        hr = DV_E_FORMATETC;
    }
    else
    {
        hr = (*_pGetFuncs[i]) (this, pformatetc, pmedium, TRUE);
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::QueryGetData, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method searches the server's Get format table
//              for a compatible format.  The return value indicates
//              whether or not a compatible format was found.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::QueryGetData(LPFORMATETC pformatetc)
{
    return FindCompatibleFormat(_pClass->_pGetFmtTable,
            _pClass->_cGetFmtTable,
            *pformatetc) >=0 ? NOERROR : DV_E_FORMATETC;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetCanonicalFormatEtc, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method returns DATA_S_SAMEFORMATETC assuming
//              that each format the server dispenses is its own
//              canonical format.  If this is not the case then this
//              method should be overridden.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::GetCanonicalFormatEtc(LPFORMATETC pformatetc,
    LPFORMATETC pformatetcOut)
{
    return DATA_S_SAMEFORMATETC;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::SetData, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method searches the server's Set format table
//              for a compatible format.  If one is found it calls
//              the corresponding Set function.
//
//---------------------------------------------------------------
STDMETHODIMP
SrvrDV::SetData(LPFORMATETC pformatetc, STGMEDIUM FAR *pmedium, BOOL fRelease)
{
    DOUT(TEXT("SrvrDV:SetData\r\n"));

    HRESULT hr;
    int i = FindCompatibleFormat(_pClass->_pSetFmtTable,
            _pClass->_cSetFmtTable,
            *pformatetc);
    if (i < 0)
    {
        DOUT(TEXT("SrvrDV::SetData DV_E_FORMATETC\r\n"));
        hr = DV_E_FORMATETC;
    }
    else
    {
        hr = (*_pSetFuncs[i]) (this, pformatetc, pmedium);
    }

    if (fRelease)
    {
        ReleaseStgMedium(pmedium);
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::EnumFormatEtc, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method creates an enumerator over the Get or
//              Set format tables depending on the value of the
//              dwDirection argument.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC FAR* ppenumFormatEtc)
{
    if (ppenumFormatEtc == NULL)
    {
        DOUT(TEXT("SrvrDV::EnumFormatEtc E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }
    *ppenumFormatEtc = NULL;            // set out params to NULL

    // create an enumerator over our static format table.
    HRESULT hr = E_INVALIDARG;
    switch (dwDirection)
    {
    case DATADIR_GET:
        hr = CreateFORMATETCEnum(_pClass->_pGetFmtTable,
                _pClass->_cGetFmtTable,
                ppenumFormatEtc);
        break;
    case DATADIR_SET:
        hr = CreateFORMATETCEnum(_pClass->_pSetFmtTable,
                _pClass->_cSetFmtTable,
                ppenumFormatEtc);
        break;
    default:
        DOUT(TEXT("SrvrDV::EnumFormatEtc E_INVALIDARG (2)\r\n"));
        break;
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::DAdvise, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method uses the standard OLE data advise holder.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::DAdvise(FORMATETC FAR* pFormatetc,
                DWORD advf,
                LPADVISESINK pAdvSink,
                DWORD FAR* pdwConnection)
{
    if (pdwConnection == NULL)
    {
        DOUT(TEXT("SrvrDV::DAdvise E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    *pdwConnection = NULL;              // set out params to NULL

    HRESULT hr = NOERROR;
    if (_pDataAdviseHolder == NULL)
        hr = CreateDataAdviseHolder(&_pDataAdviseHolder);

    if (OK(hr))
    {
        hr = _pDataAdviseHolder->Advise((LPDATAOBJECT)this,
                pFormatetc,
                advf,
                pAdvSink,
                pdwConnection);
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::DUnadvise, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method uses the standard OLE data advise holder.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::DUnadvise(DWORD dwConnection)
{
    if (_pDataAdviseHolder == NULL)
        return NOERROR;

    return _pDataAdviseHolder->Unadvise(dwConnection);
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::EnumDAdvise, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method uses the standard OLE data advise holder.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::EnumDAdvise(LPENUMSTATDATA FAR* ppenumAdvise)
{
    if (ppenumAdvise == NULL)
    {
        DOUT(TEXT("SrvrDV::EnumDAdvise E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    *ppenumAdvise = NULL;               // set out params to NULL

    HRESULT hr;
    if (_pDataAdviseHolder == NULL)
        hr = NOERROR;
    else
        hr = _pDataAdviseHolder->EnumAdvise(ppenumAdvise);

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::RenderContent, public
//
//  Synopsis:   Used to draw the content aspect of the object
//
//  Notes:      This method is used by the implementation of IViewObject::Draw
//              when the content aspect is requested.  The parameters are
//              identical to those of IViewObject::Draw.
//              All objects should override this method.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::RenderContent(DWORD dwDrawAspect,
        LONG lindex,
        void FAR* pvAspect,
        DVTARGETDEVICE FAR * ptd,
        HDC hicTargetDev,
        HDC hdcDraw,
        LPCRECTL lprectl,
        LPCRECTL lprcWBounds,
        BOOL (CALLBACK * pfnContinue) (ULONG_PTR),
        ULONG_PTR dwContinue)
{
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::RenderPrint, public
//
//  Synopsis:   Used to draw the print aspect of the object
//
//  Notes:      This method is used by the implementation of IViewObject::Draw
//              when the docprint aspect is requested.  The parameters are
//              identical to those of IViewObject::Draw.
//              By default this method calls RenderContent.  If the
//              server has special processing for the print case then
//              this method should be overridden.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::RenderPrint(DWORD dwDrawAspect,
        LONG lindex,
        void FAR* pvAspect,
        DVTARGETDEVICE FAR * ptd,
        HDC hicTargetDev,
        HDC hdcDraw,
        LPCRECTL lprectl,
        LPCRECTL lprcWBounds,
        BOOL (CALLBACK * pfnContinue) (ULONG_PTR),
        ULONG_PTR dwContinue)
{
    return RenderContent(dwDrawAspect,
            lindex,
            pvAspect,
            ptd,
            hicTargetDev,
            hdcDraw,
            lprectl,
            lprcWBounds,
            pfnContinue,
            dwContinue);
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::RenderThumbnail, public
//
//  Synopsis:   Used to draw the thumbnail aspect of the object
//
//  Notes:      This method is used by the implementation of IViewObject::Draw
//              when the thumbnail aspect is requested.  The parameters are
//              identical to those of IViewObject::Draw.
//              All objects should override this method.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::RenderThumbnail(DWORD dwDrawAspect,
        LONG lindex,
        void FAR* pvAspect,
        DVTARGETDEVICE FAR * ptd,
        HDC hicTargetDev,
        HDC hdcDraw,
        LPCRECTL lprectl,
        LPCRECTL lprcWBounds,
        BOOL (CALLBACK * pfnContinue) (ULONG_PTR),
        ULONG_PTR dwContinue)
{
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::Draw, public
//
//  Synopsis:   Method of IViewObject interface
//
//  Notes:      This method calls RenderContent/Print/Thumbnail for
//              those respective aspects.  It handles the icon aspect
//              automatically using the icon found in the class descriptor
//              indicated by the _pClass member.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::Draw(DWORD dwDrawAspect,
        LONG lindex,
        void FAR* pvAspect,
        DVTARGETDEVICE FAR * ptd,
        HDC hicTargetDev,
        HDC hdcDraw,
        LPCRECTL lprectl,
        LPCRECTL lprcWBounds,
        BOOL (CALLBACK * pfnContinue) (ULONG_PTR),
        ULONG_PTR dwContinue)
{
    HRESULT hr;
    switch(dwDrawAspect) {
    case DVASPECT_CONTENT:
        hr = RenderContent(dwDrawAspect,
                lindex,
                pvAspect,
                ptd,
                hicTargetDev,
                hdcDraw,
                lprectl,
                lprcWBounds,
                pfnContinue,
                dwContinue);
        break;

    case DVASPECT_DOCPRINT:
        hr = RenderPrint(dwDrawAspect,
                lindex,
                pvAspect,
                ptd,
                hicTargetDev,
                hdcDraw,
                lprectl,
                lprcWBounds,
                pfnContinue,
                dwContinue);
        break;

    case DVASPECT_THUMBNAIL:
        hr = RenderThumbnail(dwDrawAspect,
                lindex,
                pvAspect,
                ptd,
                hicTargetDev,
                hdcDraw,
                lprectl,
                lprcWBounds,
                pfnContinue,
                dwContinue);
        break;

    case DVASPECT_ICON:
        {
            // This is not the right way to do iconic aspect rendering!
            RECT rc;
            RECTL rcTemp = *lprectl;
            RECTLtoRECT(rcTemp, &rc);
            DrawIcon(hdcDraw, rc.left, rc.top, _pClass->_hicon);
            hr = NOERROR;
        }
        break;

    default:
        DOUT(TEXT("SrvrDV::Draw E_INVALIDARG\r\n"));
        hr = E_INVALIDARG;
        break;
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetColorSet, public
//
//  Synopsis:   Method of IViewObject interface
//
//  Notes:      This method returns S_FALSE indicating the server
//              does not support this functionality.  Server's that
//              wish to support it should override this method.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::GetColorSet(DWORD dwDrawAspect,
        LONG lindex,
        void FAR* pvAspect,
        DVTARGETDEVICE FAR * ptd,
        HDC hicTargetDev,
        LPLOGPALETTE FAR* ppColorSet)
{
    if (ppColorSet == NULL)
    {
        DOUT(TEXT("SrvrDV::GetColorSet E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    *ppColorSet = NULL; //set out params to NULL

    return S_FALSE;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::Freeze, public
//
//  Synopsis:   Method of IViewObject interface
//
//  Notes:      This method sets the frozen flag, _fFrozen.
//              The derived class must pay attention to this flag
//              and not allow any modifications that would change
//              the current rendering.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::Freeze(DWORD dwDrawAspect,
        LONG lindex,
        void FAR* pvAspect,
        DWORD FAR* pdwFreeze)
{
    if (pdwFreeze == NULL)
    {
        DOUT(TEXT("SrvrDV::Freeze E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    *pdwFreeze = 0; //set out params to NULL

    _fFrozen = TRUE;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::Unfreeze, public
//
//  Synopsis:   Method of IViewObject interface
//
//  Notes:      This method clears the frozen flag, _fFrozen.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::Unfreeze(DWORD dwFreeze)
{
    _fFrozen = FALSE;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::SetAdvise, public
//
//  Synopsis:   Method of IViewObject interface
//
//  Notes:      This method implements an advise holder for the view
//              advise.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::SetAdvise(DWORD aspects, DWORD advf, LPADVISESINK pAdvSink)
{
    HRESULT hr = NOERROR;
    if (_pViewAdviseHolder == NULL)
        hr = CreateViewAdviseHolder(&_pViewAdviseHolder);

    if (OK(hr))
        hr = _pViewAdviseHolder->SetAdvise(aspects, advf, pAdvSink);

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetAdvise, public
//
//  Synopsis:   Method of IViewObject interface
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::GetAdvise(DWORD FAR* pAspects,
        DWORD FAR* pAdvf,
        LPADVISESINK FAR* ppAdvSink)
{
    if (ppAdvSink == NULL)
    {
        DOUT(TEXT("SrvrDV::GetAdvise E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    *ppAdvSink = NULL;                  // set out params to NULL

    HRESULT hr;
    if (_pViewAdviseHolder==NULL)
        hr = NOERROR;
    else
        hr = _pViewAdviseHolder->GetAdvise(pAspects, pAdvf, ppAdvSink);

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::LoadFromStream, protected
//
//  Synopsis:   Loads the object's persistent state from a stream
//
//  Arguments:  [pStrm] -- stream to load from
//
//  Returns:    Success iff persistent state was read
//
//  Notes:      This function is used in the implementation of
//              IPersistStream::Load and IPersistFile::Load when
//              the file is not a docfile.
//              All objects should override this method.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::LoadFromStream(LPSTREAM pStrm)
{
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::SaveToStream, protected
//
//  Synopsis:   Saves the object's persistent state to a stream
//
//  Arguments:  [pStrm] -- stream to save to
//
//  Returns:    Success iff persistent state was written
//
//  Notes:      This function is used in the implementation of
//              IPersistStream::Save and IPersistFile::Save when
//              the file is not a docfile.
//              All objects should override this method.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::SaveToStream(LPSTREAM pStrm)
{
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetStreamSizeMax, protected
//
//  Synopsis:   Returns the number of bytes required to serialize object
//
//  Notes:      This function is used in the implementation of
//              IPersistStream::GetSizeMax.
//              All objects should override this method.
//
//---------------------------------------------------------------
DWORD
SrvrDV::GetStreamSizeMax(void)
{
    return 0;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetClassID, public
//
//  Synopsis:   Method of IPersist interface
//
//  Notes:      This method uses the class id in the class descriptor.
//
//---------------------------------------------------------------
STDMETHODIMP
SrvrDV::GetClassID(LPCLSID lpClassID)
{
    if (lpClassID == NULL)
    {
        DOUT(TEXT("SrvrDV::GetClassID E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    *lpClassID = _pClass->_clsid;
    return NOERROR;
}


//+---------------------------------------------------------------
//
//  Member:     SrvrDV::IsDirty, public
//
//  Synopsis:   Method of IPersistStream/Storage/File interface
//
//  Notes:      This method uses the dirty flag, _fDirty.
//              Objects should not set the _fDirty flag directly
//              but instead call the OnDataChange method to set the
//              flag.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::IsDirty(void)
{
    return (_fDirty ? NOERROR : S_FALSE);
}


//+---------------------------------------------------------------
//
//  Member:     SrvrDV::Load, public
//
//  Synopsis:   Method of IPersistStream interface
//
//  Notes:      This function uses the LoadFromStream method and
//              transitions the object to the loaded state if the
//              load was successful.
//
//---------------------------------------------------------------
STDMETHODIMP
SrvrDV::Load(LPSTREAM pStrm)
{
    // object can be loaded only once!
    if (_pCtrl->State() != OS_PASSIVE)
    {
        DOUT(TEXT("SrvrDV::Load E_FAIL\r\n"));
        return E_FAIL;
    }

    HRESULT hr;
    if (OK(hr = LoadFromStream(pStrm)))
        hr = _pCtrl->TransitionTo(OS_LOADED);

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::Save, public
//
//  Synopsis:   Method of IPersistStream interface
//
//  Notes:      This method uses the SaveToStream method and
//              clears the _fDirty flag as appropriate.
//              Containers that have nonserializeable embeddings can
//              override this method and return STG_E_CANTSAVE
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::Save(LPSTREAM pStrm, BOOL fClearDirty)
{
    HRESULT hr;
    if (OK(hr = SaveToStream(pStrm)))
    {
        if (fClearDirty)
        {
            _fDirty = FALSE;
        }
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetSizeMax
//
//  Synopsis:   Method of IPersistStream interface
//
//  Notes:
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::GetSizeMax(ULARGE_INTEGER FAR * pcbSize)
{
    if (pcbSize == NULL)
    {
        DOUT(TEXT("SrvrDV::GetSizeMax E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    ULISet32(*pcbSize, GetStreamSizeMax());

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::LoadFromStorage, protected
//
//  Synopsis:   Loads the object's persistent state from a storage
//
//  Arguments:  [pSg] -- storage to load from
//
//  Returns:    Success iff persistent state was read
//
//  Notes:      This function is used in the implementation of
//              IPersistStorage::Load and IPersistFile::Load when
//              the file is a docfile.
//              This method opens a stream, "CONTENTS", and uses
//              method LoadFromStream to complete the load.
//              Servers that do more sophisticated loading will want
//              to override this method.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::LoadFromStorage(LPSTORAGE pStg)
{
    LPSTREAM pStrm;
    HRESULT hr;
    if (OK(hr = pStg->OpenStream(szContents, NULL, STGM_SRO, 0, &pStrm)))
    {
        hr = LoadFromStream(pStrm);
        pStrm->Release();
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member: SrvrDV::SaveToStorage
//
//  Synopsis:   Saves the object's persistent state to a storage
//
//  Arguments:  [pSg] -- storage to save to
//
//  Returns:    Success iff persistent state was written
//
//  Notes:      This function is used in the implementation of
//              IPersistStorage::Save and IPersistFile::Save when
//              the file is a docfile.
//              This method opens a stream, "CONTENTS", and uses
//              method SaveToStream to complete the save.
//              Servers that do more sophisticated saving will want
//              to override this method.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::SaveToStorage(LPSTORAGE pStg, BOOL fSameAsLoad)
{
    // write our native data stream
    HRESULT hr;
    LPSTREAM pStrm;
    hr = pStg->CreateStream(szContents, STGM_SALL|STGM_CREATE, 0L, 0L, &pStrm);
    if (OK(hr))
    {
        hr = SaveToStream(pStrm);
        pStrm->Release();
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::InitNew
//
//  Synopsis:   IPersistStorage Method
//
//  Notes:      This method transitions the object to loaded.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::InitNew(LPSTORAGE pStg)
{
    //
    //REVIEW: what happens if we attempt to load the same ctrl more than once?
    //
    if (pStg == NULL)
    {
        DOUT(TEXT("SrvrDV::InitNew E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    HRESULT hr;
    if (OK(hr = _pCtrl->TransitionTo(OS_LOADED)))
        (_pStg = pStg)->AddRef();   // hold on to the storage

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::Load
//
//  Synopsis:   IPersistStorage Method
//
//  Notes:      This method loads the object using LoadFromStorage and
//              then transitions the object to loaded.
//              A pointer to our storage is maintained in member variable
//              _pStg.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::Load(LPSTORAGE pStg)
{
    // object can be loaded only once!
    if (_pCtrl->State() != OS_PASSIVE)
    {
        DOUT(TEXT("SrvrDV::Load E_FAIL\r\n"));
        return E_FAIL;
    }

    if (pStg == NULL)
    {
        DOUT(TEXT("SrvrDV::Load E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    // do the load and move to the loaded state
    HRESULT hr;
    if (OK(hr = LoadFromStorage(pStg)))
    {
        if (OK(hr = _pCtrl->TransitionTo(OS_LOADED)))
        {
            (_pStg = pStg)->AddRef();
        }
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::Save
//
//  Synopsis:   Method of IPersistStorage interface
//
//  Notes:      This method uses SaveToStorage to write the persistent
//              state.  It also writes the full user type string to the
//              storage as is required.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::Save(LPSTORAGE pStg, BOOL fSameAsLoad)
{
    if (pStg == NULL)
    {
        DOUT(TEXT("SrvrDV::Save E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    // write our native data stream
    HRESULT hr;
    if (OK(hr = SaveToStorage(pStg, fSameAsLoad)))
    {
        // Write the UserType string. We don't let this fail the operation.
        WriteFmtUserTypeStg(pStg,
                0,
                _pClass->_szUserClassType[USERCLASSTYPE_FULL]);

        _fNoScribble = TRUE;
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::SaveCompleted
//
//  Synopsis:   Method of IPersistStorage interface
//
//  Notes:      This method clears the dirty flag and updates our
//              storage pointer, _pStg, if required.
//              Servers that are also containers will want to override
//              this method to pass the call recursively to all loaded
//              embeddings.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::SaveCompleted(LPSTORAGE pStg)
{
    // if pStg is non-null then we are coming out of HANDS-OFF mode,
    // otherwise we are coming out of NO-SCRIBBLE mode.
    if (pStg != NULL)
    {
        // We should be in HANDS-OFF mode and hence able to Assert that
        // _pStg is NULL here by virtue of the HandsOffStorage call.
        // However, the official OLE sample container app "Outline"
        // fail to make the HandsOffStorage call.
        // In order to be robust we release our _pStg handle if it is
        // "illegally" NON-NULL
        //
        if (_pStg != NULL)
        {
            DOUT(TEXT("SrvrDV: WARNING! SaveCompleted: "));
            DOUT(TEXT("SrvrDV: Container failed to make required HandsOffStorage call.\n"));
            _pStg->Release();
        }

        (_pStg = pStg)->AddRef();   // hold on to the new storage
    }

    _fDirty = FALSE;                // clear our dirty flag
    _fNoScribble = FALSE;           // we are out of NO-SCRIBBLE mode

    //REVIEW: should we advise in the case we are not fRemembering?
    if (_pCtrl != NULL)
        _pCtrl->OnSave();           // and notify any advises that we have saved

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::HandsOffStorage
//
//  Synopsis:   Method of IPersistStorage interface
//
//  Notes:      This method releases the storage we are holding on to.
//              Servers that are also containers will want to override
//              this method to pass the call recursively to all loaded
//              embeddings.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::HandsOffStorage(void)
{
    if (_pStg != NULL)
        _pStg->Release();
    _pStg = NULL;

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::Load, public
//
//  Synopsis:   Method of IPersistFile interface
//
//  Notes:      This opens the file as a docfile and uses IPersistStorage::Load
//              to complete the operation.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::Load(LPCOLESTR lpstrFile, DWORD grfMode)
{

    // use the default storage modes if no flags were specified
    if (grfMode == 0)
        grfMode = STGM_DFRALL;

    // if they didn't specify a share mode then use deny-write
    if ( (grfMode & STGM_SHARE) == 0)
        grfMode |= STGM_SHARE_DENY_WRITE;

    // of course, we use transacted mode
    grfMode |= STGM_TRANSACTED;

    HRESULT hr;
    if (lpstrFile == NULL)
    {
        // lpstrFile NULL is a special-case indicating that we should
        // create a temporary docfile for the new file case
        //
        grfMode |= STGM_CREATE | STGM_DELETEONRELEASE;

        LPSTORAGE pStg;
        if (OK(hr = StgCreateDocfile(NULL, grfMode, 0L, &pStg)))
        {
            hr = InitNew(pStg);

            // IPersistStorage::InitNew will hold on to the pStg
            pStg->Release();
        }
        return hr;
    }

    LPSTORAGE pStg;
    if (OK(hr = StgOpenStorage(lpstrFile, NULL, grfMode, NULL, 0L, &pStg)))
    {
        hr = Load(pStg);

        // IPersistStorage::Load will hold on to the pStg
        pStg->Release();
    }
    //REVIEW:  Is the first SetMoniker happening correctly?
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::Save, public
//
//  Synopsis:   Method of IPersistFile interface
//
//  Notes:      If a file is specified then this creates a docfile and
//              uses IPersistStorage::Save to complete the operation.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::Save(LPCOLESTR lpstrFile, BOOL fRemember)
{
    // if lpstrFile is NULL that means that we should save from where we
    // loaded.  Otherwise create a docfile with the specified name
    HRESULT hr = NOERROR;
    LPSTORAGE pStg;

    if (lpstrFile == NULL)
        (pStg = _pStg)->AddRef();
    else
        hr = StgCreateDocfile(lpstrFile, STGM_DFRALL|STGM_CREATE, 0L, &pStg);

    if (OK(hr))
    {
        hr = OleSave((LPPERSISTSTORAGE)this, pStg, pStg == _pStg);

        if (OK(hr))
        {
            // if we are to remember this storage then release our old
            // storage and hold on to the new.
            // Otherwise, wrap up a storage save by the usual SaveCompleted.
            if (lpstrFile != NULL && fRemember)
            {
                // release our previous storage or stream
                // and hold on to our new
                HandsOffStorage();
                ((LPPERSISTSTORAGE)this)->SaveCompleted(pStg);
            }
            else
            {
                // If we did a storage save and we are not switching to a new
                // storage then we complete the transaction with a SaveCompleted.
                ((LPPERSISTSTORAGE)this)->SaveCompleted(NULL);
            }
        }

        // Release the storage.  If we are supposed to hold on
        // to it then we have already add-ref'd it.
        pStg->Release();
    }

    // if we have renamed then
    if (lpstrFile != NULL)
    {
        // TBD: Send On_Renamed advise?
        //
        // inform our object of its new moniker
        //
        LPMONIKER pmk;
        if (OK(CreateFileMoniker(lpstrFile, &pmk)))
        {
            _pCtrl->SetMoniker(OLEWHICHMK_OBJFULL, pmk);
            pmk->Release();
        }
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::SaveCompleted, public
//
//  Synopsis:   Method of IPersistFile interface
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::SaveCompleted(LPCOLESTR lpstrFile)
{
    //REVIEW: should we launch advise in the case we are not fRemembering?
    if (_pCtrl != NULL)
        _pCtrl->OnSave();   // and notify any advises that we have saved

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetCurFile, public
//
//  Synopsis:   Method of IPersistFile interface
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::GetCurFile(LPOLESTR FAR * ppstrFile)
{
    if (ppstrFile == NULL)
    {
        DOUT(TEXT("SrvrDV::GetCurFile E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    *ppstrFile = 0; //set out params to NULL

    HRESULT hr;

    // if we don't currently have a file then return the default filename
    if (_pStg == NULL)
    {
        // the default filename is *.ext where ext is our docfile extension
        OLECHAR szDefault[6];
#if defined(OLE2ANSI)        
        wsprintf(szDefault, TEXT("*%s"), _pClass->_szDocfileExt);
#else
        wsprintfW(szDefault, OLETEXT("*%ws"), _pClass->_szDocfileExt);        
#endif                
        hr = TaskAllocString(szDefault, ppstrFile);
    }
    else
    {
        // the caller will free the task-allocated file name
        STATSTG statstg;
        if (OK(hr = _pStg->Stat(&statstg, STATFLAG_DEFAULT)))
            *ppstrFile = statstg.pwcsName;
    }

    return hr;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\o2base\sctrl.cxx ===
//+---------------------------------------------------------------------
//
//   File:       sctrl.cxx
//
//------------------------------------------------------------------------

//[ srvr_overview
/*
                        Srvr Library Overview

The Srvr library is a set of C++ base classes intended to greatly simplify
the process of implementing an OLE Compound Document object DLL in C++.
This library requires the O2UTIL library and and understanding of elements
in that library is prerequisite to a complete understanding of these base
classes.  Consult documentation for the O2UTIL library.

The library consists of three C++ base classes: SrvrCtrl, SrvrDV, and
SrvrInPlace.  An OLE Compound Document object implemented using the Srvr
library is an aggregate of three subobjects -- the control, data/view
and in-place subobjects.  The implementations of these subobjects are C++
classes that inherit from SrvrCtrl, SrvrDV, and SrvrInPlace respectively.
Behaviour specific to the C.D. object type is implemented
by overriding virtual methods on the base classes.  The base classes are
designed so that a simple but functional server can be implemented by overriding
only a small number of virtual methods.  Progressively more advanced servers
can be implemented by deriving more virtual methods and adding support for
new interfaces in the derived classes.

In the following discussion, the unqualified term "object" refers to an OLE
Compound Document (C.D.) object.  The term "subobject" refers to a C++ object
whose class inherits from one of the Srvr base classes.

The data/view subobject encapsulates the persistent data of an object and the
rendering of that data.  This subobject supports the IDataObject, IViewObject,
and the IPersist family of interfaces.  These subobjects can also function
independently as a data transfer object for clipboard and drag-drop operations.

The control subobject manages the dynamic control of the object.  This subobject
supports the IOleObject interface and directs all state transitions of the object.

The in-place subobject is responsible for the child window and user interface
of an object while it is in-place active.  The subobject supports the
IOleInPlaceObject and IOleInPlaceActiveObject interfaces.  This subobject is
not required for objects that don't support in-place editing.

The control subobject controls the aggregate and holds pointers to the data/view
and inplace subobjects.  It maintains the reference count for the object as a
whole and delegates QueryInterfaces to the other subobjects for interfaces
that it does not handle.  The data/view and in-place subobjects each hold a
pointer to the control subobject.  They each forward their IUnknown methods
to the control.  When a data/view subobject is being used independently as
a data-transfer object then its control pointer is NULL.

For more information consult the overview sections for each of the base
classes and the documentation for the base class methods.

*/
//]

//[ srvrctrl_overview
/*
                        SrvrCtrl Overview

The SrvrCtrl base class implements the control aspects common to most
OLE Compound Document objects.  It records the state of the object and
directs the state transitions.  It implements the IOleObject interface.

An object is in one of five possible states: passive, loaded, in-place,
U.I. active, or opened.  An object is passive when it is holding no
resources.  This is true for objects that are newly created or have
been released.  An object becomes loaded when it gets
an IPersistXXX::Load or IPersistStorage::InitNew call and has loaded
or initialized the necessary part of its persistent state.  An object in
the in-place state has a child window in its containers window and
can receive window messages.  The object (nor any of its embeddings)
does not have its U.I. visible (e.g. shared menu or toolbars).
A U.I. active object does have its (or one of its embeddings) U.I. visible.
An open object is one that is being open-edited in a separate, top-level
window.

Part of implementing the control subobject of an OLE Compound Document object
is implementing verbs.  There are a number of standard, OLE-defined verbs
and an object can add its own.  Since the set of verbs is very object
dependent SrvrCtrl requires a derived class to supply tables indicating
the verbs that are supported.  One is table of OLEVERB structures giving
standard information about the verb including the verb number and name.
A parallel table contains a pointer for each verb pointing to a function
that implements that verb.  SrvrCtrl has a set of static methods that
implement the standard OLE verbs.  The derived class can include these methods
in its verb table.  SrvrCtrl implements all the IOleObject verb-related
methods using these two verb tables.  The verb tables must be in order
of verb number and must be contiguous (i.e. no missing verb numbers).

*/
//]

#include "headers.hxx"
#pragma hdrstop


//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::SrvrCtrl, protected
//
//  Synopsis:   Constructor for SrvrCtrl object
//
//  Notes:      To create a properly initialized object you must
//              call the Init method immediately after construction.
//
//---------------------------------------------------------------

SrvrCtrl::SrvrCtrl(void)
{
    DOUT(TEXT("SrvrCtrl: Constructing\r\n"));

    _pDV        = NULL;
    _pInPlace   = NULL;
    _pPrivUnkDV = NULL;
    _pPrivUnkIP = NULL;

     // site-related information
    _pClientSite = NULL;
    _pOleAdviseHolder = NULL;
    _pClass = NULL;

    _dwRegROT = 0;

    _lpstrCntrApp = NULL;
    _lpstrCntrObj = NULL;
    
#if !defined(UNICODE) && !defined(OLE2ANSI)
    _lpstrCntrAppA = NULL;
    _lpstrCntrObjA = NULL;
#endif
    
    _state = OS_PASSIVE;

    EnableIPB(TRUE);
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::Init, protected
//
//  Synopsis:   Fully initializes a SrvrCtrl object
//
//  Arguments:  [pClass] -- The initialized class descriptor for the server
//              [pUnkOuter] -- The controlling unknown if this server is being
//                          created as part of an aggregate; NULL otherwise
//
//  Returns:    NOERROR if successful
//
//  Notes:      The class descriptor pointer is saved in the protected _pClass
//              member variable where it is accessible during the lifetime
//              of the object.
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::Init(LPCLASSDESCRIPTOR pClass)
{
    _pClass = pClass;
    return NOERROR;
}


//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::~SrvrCtrl, protected
//
//  Synopsis:   Destructor for the SrvrCtrl object
//
//  Notes:      The destructor is called as a result of the servers
//              reference count going to 0.  It ensure the object
//              is in a passive state and releases the data/view and inplace
//              subobjects objects.
//
//---------------------------------------------------------------

SrvrCtrl::~SrvrCtrl(void)
{
    DOUT(TEXT("~~~~~SrvrCtrl::~OPCtrl\r\n"));
    // note: we don't have to release _pDV and _pInPlace because
    // we should have released them right away (standard aggregation policy)
    // We must release the private unknowns of those two subobjects, though.

    if (_pPrivUnkIP)
        _pPrivUnkIP->Release();
    if (_pPrivUnkDV)
        _pPrivUnkDV->Release();

    // free our advise holder
    if(_pOleAdviseHolder != NULL)
        _pOleAdviseHolder->Release();

    // release our client site
    TaskFreeString(_lpstrCntrApp);
    TaskFreeString(_lpstrCntrObj);
    
#if !defined(UNICODE) && !defined(OLE2ANSI)
    TaskFreeMem(_lpstrCntrAppA);
    TaskFreeMem(_lpstrCntrObjA);
#endif
    
    if (_pClientSite != NULL)
        _pClientSite->Release();
    DOUT(TEXT("SrvrCtrl: Destructed\r\n"));
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::TransitionTo, public
//
//  Synopsis:   Drives the transition of the object from one state to another
//
//  Arguments:  [state] -- the desired resulting state of the object
//
//  Returns:    Success iff the transition completed successfully.  On failure
//              the object will be in the original or some intermediate,
//              but consistent, state.
//
//  Notes:      There are eight direct state transitions.  These are:
//              between the passive and loaded states, between the
//              loaded and inplace states, between the inplace and U.I. active
//              states, and between the loaded and opened states.
//              Each of these direct transitions has an overridable method
//              that effects it.  The TransitionTo function implements
//              transitions between any two arbitrary states by calling
//              these direct transition methods in the proper order.
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::TransitionTo(OLE_SERVER_STATE state)
{
#if DBG
    TCHAR achTemp[256];
    wsprintf(achTemp,TEXT("[%d] --> [%d] SrvrCtrl::TransitionTo\n\r"),(int)_state,(int)state);
    DOUT(achTemp);
#endif //DBG

    Assert(state >= OS_PASSIVE && state <= OS_OPEN);
    Assert(_state >= OS_PASSIVE && _state <= OS_OPEN);

    //
    // at each iteration we transition one state closer to
    // our destination state...
    //
    HRESULT hr = NOERROR;
    while (state != _state && OK(hr))
    {
        switch(_state)
        {
        case OS_PASSIVE:
            // from passive we can only go to loaded!
            if (OK(hr = PassiveToLoaded()))
                _state = OS_LOADED;

            break;

        case OS_LOADED:
            switch(state)
            {
            default:
                if (OK(hr = LoadedToRunning()))
                    _state = OS_RUNNING;
                break;

            case OS_PASSIVE:
                if (OK(hr = LoadedToPassive()))
                    _state = OS_PASSIVE;
                break;
            }
            break;

        case OS_RUNNING:
            switch(state)
            {
            default:
            case OS_LOADED:
                if (OK(hr = RunningToLoaded()))
                    _state = OS_LOADED;
                break;
            case OS_INPLACE:
            case OS_UIACTIVE:
                if (OK(hr = RunningToInPlace()))
                    _state = OS_INPLACE;
                break;
            case OS_OPEN:
                if (OK(hr = RunningToOpened()))
                    _state = OS_OPEN;
                break;
            }
            break;

        case OS_INPLACE:
            switch(state)
            {
            default:
                if (OK(hr = InPlaceToRunning()))
                {
                    //
                    // The following handles re-entrancy cases in which
                    // processing of this state transition caused us to
                    // reach a state below our current target state...
                    if(_state < OS_RUNNING)
                        goto LExit;

                    _state = OS_RUNNING;
                }
                
                break;
            case OS_UIACTIVE:
                if (OK(hr = InPlaceToUIActive()))
                    _state = OS_UIACTIVE;
                break;
            }
            break;

        case OS_UIACTIVE:
            // from UIActive we can only go to inplace
            if (OK(hr = UIActiveToInPlace()))
            {
                //
                // In the course of notifying the container that we
                // are no longer UIActive, it is possible that we
                // got InPlace deactivated (or worse, Closed).
                // If this happened we abort our currently targeted
                // transition...
                if(_state < OS_INPLACE)
                    goto LExit;

                _state = OS_INPLACE;
            }
            break;

        case OS_OPEN:
            // from Open we can only go to running
            if (OK(hr = OpenedToRunning()))
                _state = OS_RUNNING;
            break;
        }
    }

LExit:
#if DBG
    wsprintf(achTemp,TEXT("SrvrCtrl::TransitionTo [%d] hr = %lx\n\r"),(int)_state, hr);
    DOUT(achTemp);
#endif //DBG
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::PassiveToLoaded, protected
//
//  Synopsis:   Effects the direct passive to loaded state transition
//
//  Returns:    Success iff the object is in the loaded state.  On failure
//              the object will be in a consistent passive state.
//
//  Notes:      The base class does not do any processing on this transition.
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::PassiveToLoaded(void)
{
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::LoadedToRunning, protected
//
//  Synopsis:   Effects the direct loaded to running state transition
//
//  Returns:    Success if the object is running.
//
//  Notes:      This transition occurs as a result of an
//              IRunnableObject::Run call (TBD) and is implicit in any
//              DoVerb call.
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::LoadedToRunning(void)
{
    DOUT(TEXT("SrvrCtrl::LoadedToRunning\r\n"));
    //
    // enter ourself in the Running Object Table
    //
    LPMONIKER pmk;
    if (OK(_pDV->GetMoniker(OLEGETMONIKER_ONLYIFTHERE, &pmk)))
    {
        RegisterAsRunning((LPUNKNOWN)this, pmk, &_dwRegROT);
        pmk->Release();
    }
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::LoadedToPassive, protected
//
//  Synopsis:   Effects the direct loaded to passive state transition
//
//  Returns:    Success if the object is loaded.
//
//  Notes:      This transition occurs as a result of an IOleObject::Close()
//              call.
//              This method sends an OnClose notification to all of our
//              advises.
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::LoadedToPassive(void)
{
    DOUT(TEXT("SrvrCtrl::LoadedToPassive\r\n"));

    // notify our data advise holders of 'stop'
    _pDV->OnDataChange(ADVF_DATAONSTOP);
    
    // notify our advise holders that we have closed
    if (_pOleAdviseHolder != NULL)
    {
        DOUT(TEXT("SrvrCtrl::LoadedToPassive calling _pOleAdviseHolder->SendOnClose()\r\n"));
        _pOleAdviseHolder->SendOnClose();
    }

    // forcibly cut off remoting clients???
    //CoDisconnectObject((LPUNKNOWN)this, 0);

    //
    // revoke our entry in the running object table
    //
    if (_dwRegROT != 0)
    {
        DOUT(TEXT(".-.-.SrvrCtrl::RunningToLoaded calling RevokeAsRunning\r\n"));
        RevokeAsRunning(&_dwRegROT);
        _dwRegROT = 0;
    }

    DOUT(TEXT("SrvrCtrl::LoadedToPassive (returning)\r\n"));
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::RunningToLoaded, protected
//
//  Synopsis:   Effects the direct running to loaded state transition
//
//  Returns:    Success if the object is loaded.
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::RunningToLoaded(void)
{
    DOUT(TEXT("SrvrCtrl::RunningToLoaded\r\n"));
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::RunningToOpened, protected
//
//  Synopsis:   Effects the direct running to opened state transition
//
//  Returns:    Success if the object is open-edited.
//
//  Notes:      Open-editing is not yet supported.  This returns E_FAIL.
//
//              The derived class MUST completely override this
//              transition to implement an open-ediing server!
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::RunningToOpened(void)
{
    DOUT(TEXT("SrvrCtrl::RunningToOpened E_FAIL\r\n"));
    return E_FAIL;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::OpenedToRunning, protected
//
//  Synopsis:   Effects the direct opened to running state transition
//
//  Returns:    Success if the open-editing session was shut down
//
//  Notes:      This occurs as the result of a DoVerb(HIDE...)
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::OpenedToRunning(void)
{
    // notify our container so it can un-hatch
    if (_pClientSite != NULL)
        _pClientSite->OnShowWindow(FALSE);

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::RunningToInPlace, protected
//
//  Synopsis:   Effects the direct Running to inplace state transition
//
//  Returns:    Success iff the object is in the inplace state.  On failure
//              the object will be in a consistent Running state.
//
//  Notes:      This transition invokes the ActivateInPlace method on the
//              inplace subobject of the server, if there is one.  Containers
//              will typically override this method in order to additionally
//              inplace activate any inside-out embeddings that are visible.
//              If the server does not support in-place
//              activation then this method will return E_UNEXPECTED.
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::RunningToInPlace(void)
{
    if (_pInPlace == NULL)
    {
        DOUT(TEXT("SrvrCtrl::RunningToInPlace E_FAIL\r\n"));
        return E_FAIL;
    }

    return _pInPlace->ActivateInPlace(_pClientSite);
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::InPlaceToRunning, protected
//
//  Synopsis:   Effects the direct inplace to Running state transition
//
//  Returns:    Success under all but catastrophic circumstances.
//
//  Notes:      This transition invokes the DeactivateInPlace method on the
//              inplace subobject of the server, if there is one.  Containers
//              will typically override this method in order to additionally
//              inplace deactivate any inplace-active embeddings.
//              If the server does not support in-place activation then
//              this method will never be called.
//              This method is called as the result of a DoVerb(HIDE...)
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::InPlaceToRunning(void)
{
    Assert(_pInPlace != NULL);
    return _pInPlace->DeactivateInPlace();
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::InPlaceToUIActive, protected
//
//  Synopsis:   Effects the direct inplace to U.I. active state transition
//
//  Returns:    Success iff the object is in the U.I. active state.  On failure
//              the object will be in a consistent inplace state.
//
//  Notes:      This transition invokes the ActivateUI methods on the inplace
//              subobject of the server.
//              If the server does not support in-place activation then
//              this method will never be called.
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::InPlaceToUIActive(void)
{
    Assert(_pInPlace != NULL);
    return _pInPlace->ActivateUI();
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::UIActiveToInPlace, protected
//
//  Synopsis:   Effects the direct U.I. Active to inplace state transition
//
//  Returns:    Success under all but catastrophic circumstances.
//
//  Notes:      This transition invokes the DeactivateUI methods
//              on the inplace subobject of the server.  Containers
//              will typically override this method in order to possibly
//              U.I. deactivate a U.I. active embedding.
//              If the server does not support in-place activation then
//              this method will never be called.
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::UIActiveToInPlace(void)
{
    Assert(_pInPlace != NULL);
    return _pInPlace->DeactivateUI();
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::OnSave, public
//
//  Synopsis:   Raises the OnSave advise to any registered advises
//
//  Notes:      This method is called by the data/view subobject upon
//              successful completion of a save operation.
//
//---------------------------------------------------------------

void
SrvrCtrl::OnSave(void)
{
    if (_pOleAdviseHolder != NULL)
        _pOleAdviseHolder->SendOnSave();
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::DoShow, public
//
//  Synopsis:   Implementation of the standard verb OLEIVERB_SHOW
//
//  Arguments:  [pv] -- pointer to a SrvrCntrl object.
//              All other parameters are the same as the IOleObject::DoVerb
//              method.
//
//  Returns:    Success if the verb was successfully executed
//
//  Notes:      This and the other static Do functions are provided for
//              use in the server's verb table.  This verb results in
//              a ShowObject call on our container and a transition
//              to the U.I. active state
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::DoShow(LPVOID pv,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    LPSRVRCTRL pCtrl = (LPSRVRCTRL)pv;
    HRESULT hr = NOERROR;

#if DBG    
    TCHAR achTemp[256];
    wsprintf(achTemp,TEXT("SrvrCtrl::DoShow [%d]\n\r"),(int)pCtrl->State());
    DOUT(achTemp);
#endif    

    if (pCtrl->_pClientSite != NULL)
    {
        pCtrl->_pClientSite->ShowObject();
        if(pCtrl->State() == OS_OPEN)
        {
            HWND hwnd = NULL;
            if(pCtrl->_pInPlace)
                pCtrl->_pInPlace->GetWindow(&hwnd);
            if(hwnd != NULL)
                SetForegroundWindow(hwnd);
        }
        else
        {
            hr = pCtrl->TransitionTo(OS_UIACTIVE);
        }
    }
    
    if (!OK(hr))
    {
        // the default action is OPEN...
        hr = pCtrl->TransitionTo(OS_OPEN);
    }

    // if the verb was unknown then return Unknown Verb error.
    if (OK(hr) && iVerb != OLEIVERB_PRIMARY && iVerb != OLEIVERB_SHOW)
    {
        DOUT(TEXT("SrvrCtrl::DoShow returning OLEOBJ_S_INVALIDVERB\r\n"));
        hr = OLEOBJ_S_INVALIDVERB;
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::DoOpen, public
//
//  Synopsis:   Implementation of the standard verb OLEIVERB_OPEN.
//              This verb results in a transition to the open state.
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::DoOpen(LPVOID pv,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    DOUT(TEXT("SrvrCtrl::DoOpen\r\n"));

    LPSRVRCTRL pCtrl = (LPSRVRCTRL)pv;
    if(pCtrl->State() == OS_OPEN)
    {
        HWND hwnd = NULL;
        if(pCtrl->_pInPlace)
            pCtrl->_pInPlace->GetWindow(&hwnd);
        if(hwnd != NULL)
            SetForegroundWindow(hwnd);
    }
    return pCtrl->TransitionTo(OS_OPEN);
}

//+---------------------------------------------------------------
//
//  Member: SrvrCtrl::DoHide, public
//
//  Synopsis:   Implementation of the standard verb OLEIVERB_HIDE
//              This verb results in a transition to the Running state.
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::DoHide(LPVOID pv,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    DOUT(TEXT("SrvrCtrl::DoHide\r\n"));

    LPSRVRCTRL pCtrl = (LPSRVRCTRL)pv;
    if(pCtrl != NULL)
    {
//jyg: ntbug 17327        
//        if(pCtrl->_state == OS_LOADED || pCtrl->_state == OS_PASSIVE)
//            return pCtrl->TransitionTo(OS_PASSIVE);
//        else
            return pCtrl->TransitionTo(OS_RUNNING);
    }
    else
    {
        DOUT(TEXT("SrvrCtrl::DoHide E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::DoUIActivate, public
//
//  Synopsis:   Implementation of the standard verb OLEIVERB_UIACTIVATE
//              This verb results in a transition to the U.I. active state.
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::DoUIActivate(LPVOID pv,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    LPSRVRCTRL pCtrl = (LPSRVRCTRL)pv;
    HRESULT hr = pCtrl->TransitionTo(OS_UIACTIVE);
    if(OK(hr) && (lpmsg != NULL))
    {
        PostMessage(pCtrl->_pInPlace->WindowHandle(),
                lpmsg->message,
                lpmsg->wParam,
                lpmsg->lParam);
    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::DoInPlaceActivate, public
//
//  Synopsis:   Implementation of the standard verb OLEIVERB_INPLACEACTIVATE
//              This verb results in a transition to the inplace state.
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::DoInPlaceActivate(LPVOID pv,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    LPSRVRCTRL pCtrl = (LPSRVRCTRL)pv;
    HRESULT hr = pCtrl->TransitionTo(OS_INPLACE);
    if(OK(hr) && (lpmsg != NULL))
    {
        PostMessage(pCtrl->_pInPlace->WindowHandle(),
                lpmsg->message,
                lpmsg->wParam,
                lpmsg->lParam);
    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::SetClientSite, public
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method saves the client site pointer in the
//              _pClientSite member variable.
//
//              We never fail!
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::SetClientSite(LPOLECLIENTSITE pClientSite)
{
    //
    // if we already have a client site then release it
    //
    if (_pClientSite != NULL)
        _pClientSite->Release();

    //
    // if there is a new client site then hold on to it
    //
    _pClientSite = pClientSite;
    if (_pClientSite != NULL)
        _pClientSite->AddRef();

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::GetClientSite
//
//  Synopsis:   Method of IOleObject interface
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::GetClientSite(LPOLECLIENTSITE FAR* ppClientSite)
{
    if (ppClientSite == NULL)
    {
        DOUT(TEXT("SrvrCtrl::GetClientSite E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }
    *ppClientSite = NULL;   // set out params to NULL

    //
    // if we have a client site then return it, but addref it first.
    //
    if (_pClientSite != NULL)
        (*ppClientSite = _pClientSite)->AddRef();

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::SetHostNames
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method saves copies of the container-related strings
//              in the _lpstrCntrApp and _lpstrCntrObj member variables.
//
//              We never fail!
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::SetHostNames(LPCOLESTR lpstrCntrApp, LPCOLESTR lpstrCntrObj)
{
    // free any strings we are holding on to
    if (_lpstrCntrApp != NULL)
    {
        TaskFreeString(_lpstrCntrApp);
        _lpstrCntrApp = NULL;
        
#if !defined(UNICODE) && !defined(OLE2ANSI)        
        TaskFreeMem(_lpstrCntrAppA);
        _lpstrCntrAppA = NULL;
#endif
        
    }
    if (_lpstrCntrObj != NULL)
    {
        TaskFreeString(_lpstrCntrObj);
        _lpstrCntrObj = NULL;
        
#if !defined(UNICODE) && !defined(OLE2ANSI)                
        TaskFreeMem(_lpstrCntrObjA);
        _lpstrCntrObjA = NULL;
#endif
                
    }

    // make copies of the new strings and hold on
    TaskAllocString(lpstrCntrApp, &_lpstrCntrApp);
    TaskAllocString(lpstrCntrObj, &_lpstrCntrObj);

#if !defined(UNICODE) && !defined(OLE2ANSI)
    _lpstrCntrAppA = ConvertOLESTRToMB(_lpstrCntrApp, -1);
    _lpstrCntrObjA = ConvertOLESTRToMB(_lpstrCntrObj, -1);    
#endif

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::Close
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method ensures the object is in the loaded
//              (not passive!) state.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::Close(DWORD dwSaveOption)
{
    HRESULT hr = NOERROR;

    // if our object is dirty then we should save it, depending on the
    // save options
    if (_pClientSite != NULL && NOERROR == _pDV->IsDirty())
    {
        BOOL fSave;
        switch(dwSaveOption)
        {
        case OLECLOSE_SAVEIFDIRTY:
            fSave = TRUE;
            break;

        case OLECLOSE_NOSAVE:
            fSave = FALSE;
            break;

        case OLECLOSE_PROMPTSAVE:
            {
                // put up a message box asking the user if they want to update
                // the container
                LPOLESTR lpstrObj =
                    _pDV->GetMonikerDisplayName(OLEGETMONIKER_ONLYIFTHERE);
                if (lpstrObj == NULL)
                {
                    lpstrObj = _pClass->_szUserClassType[USERCLASSTYPE_FULL];
                }
                int i = IDYES;
#if 0                
#pragma message("Localizable string here!")
                int i = MessageBox(NULL,
                            TEXT("Object has changed.  Update?"),
                            lpstrObj,
                            MB_YESNOCANCEL | MB_ICONQUESTION);
#endif                

                if (IDCANCEL == i)
                {
                    return OLE_E_PROMPTSAVECANCELLED;
                }

                fSave = (IDYES == i);
            }
            break;

        default:
            DOUT(TEXT("SrvrCtrl::Close E_INVALIDARG\r\n"));
            return E_INVALIDARG;
        }

        if (fSave)
            hr = _pClientSite->SaveObject();
    }

    // Ensure that we do not loose any SaveObject() failure. 
    if (SUCCEEDED (hr))
        hr = TransitionTo(OS_PASSIVE);
    else
        (void) TransitionTo(OS_PASSIVE);

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::SetMoniker
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method notifies our data/view subobject of our new
//              moniker.  It also registers us in the running object
//              table and sends an OnRename notification to all registered
//              advises.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::SetMoniker(DWORD dwWhichMoniker, LPMONIKER pmk)
{
    // our moniker has changed so revoke our entry in the running object table
    if (_dwRegROT != 0)
    {
        RevokeAsRunning(&_dwRegROT);
    }

    //
    // insure that we have a full moniker to register in the ROT
    // if we have a full moniker, then go with it
    // otherwise ask our client site for a full moniker
    //
    HRESULT hr = NOERROR;
    LPMONIKER pmkFull = NULL;
    if (dwWhichMoniker == OLEWHICHMK_OBJFULL)
    {
        if((pmkFull = pmk) != NULL)
            pmkFull->AddRef();
    }
    else
    {
        if (_pClientSite == NULL)
        {
            DOUT(TEXT("SrvrCtrl::SetMoniker E_FAIL\r\n"));
            hr = E_FAIL;
        }
        else
        {
            hr = _pClientSite->GetMoniker(OLEGETMONIKER_ONLYIFTHERE,
                    OLEWHICHMK_OBJFULL,
                    &pmkFull);
        }
    }

    if (OK(hr))
    {
        // stow the moniker away in our data object
        _pDV->SetMoniker(pmkFull);

        if(pmkFull != NULL)
        {
            // register ourself in the running object table
            // NOTE: if we had native data items that weren't embeddings
            // but could be pseudo-objects then we would also register a
            // wildcard moniker
            //
            RegisterAsRunning((LPUNKNOWN)this, pmkFull, &_dwRegROT);

            // notify our advise holders that we have been renamed!
            if (_pOleAdviseHolder != NULL)
            {
                _pOleAdviseHolder->SendOnRename(pmkFull);
            }

            pmkFull->Release();
        }
        else
        {
            RevokeAsRunning(&_dwRegROT);
        }
    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::GetMoniker
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method forwards the request to our client site
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk)
{
    if (ppmk == NULL)
    {
        DOUT(TEXT("SrvrCtrl::GetMoniker E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }
    *ppmk = NULL;   // set out parameters to NULL

    // get the requested moniker from our client site
    HRESULT hr;
    if (_pClientSite == NULL)
    {
        DOUT(TEXT("SrvrCtrl::GetMoniker MK_E_UNAVAILABLE\r\n"));
        hr = MK_E_UNAVAILABLE;
    }
    else
        hr = _pClientSite->GetMoniker(dwAssign, dwWhichMoniker, ppmk);

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::InitFromData
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method returns S_FALSE indicating InitFromData
//              is not supported.  Servers that wish to support initialization
//              from a selection should override this function.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::InitFromData(LPDATAOBJECT pDataObject,
        BOOL fCreation,
        DWORD dwReserved)
{
    return S_FALSE;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::GetClipboardData
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method uses the GetClipboardCopy method on our
//              data/view subobject to obtain a data transfer object
//              representing a snapshot of our compound document object.
//
//              This is considered an exotic, and OPTIONAL method to
//              implement. It was intended for programatic access
//              (bypassing the clipboard), and will probably never
//              be used...
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::GetClipboardData(DWORD dwReserved, LPDATAOBJECT FAR* ppDataObject)
{
    if (ppDataObject == NULL)
    {
        DOUT(TEXT("SrvrCtrl::GetClipboardData E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }
    *ppDataObject = NULL;               // set out params to NULL

    // create a new data object initialized from our own data object
    LPSRVRDV pDV = NULL;
    HRESULT hr;
    if (OK(hr = _pDV->GetClipboardCopy(&pDV)))
    {
        *ppDataObject = (LPDATAOBJECT)pDV;
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::DoVerb
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method locates the requested verb in the servers
//              verb table and calls the associated verb function.
//              If the verb is not found then the first (at index 0) verb in
//              the verb table is called.  This should be the primary verb
//              with verb number 0.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::DoVerb(LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    //
    // All DoVerbs make an implicit transition to the running state if
    // the object is not already running...
    //
    HRESULT hr = NOERROR;
    if (_state < OS_RUNNING)
        hr = TransitionTo(OS_RUNNING);

    if (OK(hr))
    {
        //
        // find the verb in the verb table.  if it is not there then default
        // to the 0th entry in the table (should be primary verb)
        //
        for (int i = 0; i < _pClass->_cVerbTable; i++)
        {
            if (iVerb == _pClass->_pVerbTable[i].lVerb)
            {
                break;
            }
        }
        if (i >= _pClass->_cVerbTable)
        {
            i = 0;
        }

        // dispatch the verb
        hr = (*_pVerbFuncs[i])(this,
                iVerb,
                lpmsg,
                pActiveSite,
                lindex,
                hwndParent,
                lprcPosRect);
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::EnumVerbs
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method produces an enumerator over the server's
//              verb table.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::EnumVerbs(LPENUMOLEVERB FAR* ppenum)
{
    if (ppenum == NULL)
    {
        DOUT(TEXT("SrvrCtrl::EnumVerbs E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    *ppenum = NULL;
    
    //return OLE_S_USEREG;
    return CreateOLEVERBEnum(_pClass->_pVerbTable, _pClass->_cVerbTable, ppenum);
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::Update
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method returns NOERROR indicating that the update was
//              successful.  Containers will wish to override this function
//              in order to recursively pass the function on to all embeddings.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::Update(void)
{
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::IsUpToDate
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method returns NOERROR indicating that the object is
//              up to date.  Containers will wish to override this function
//              in order to recursively pass the function on to all embeddings.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::IsUpToDate(void)
{
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::GetUserClassID
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method supplies the class id from the server's
//              CLASSDESCRIPTOR structure
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::GetUserClassID(CLSID FAR* pClsid)
{
    if (pClsid == NULL)
    {
        DOUT(TEXT("SrvrCtrl::GetUserClassID E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }
    *pClsid = _pClass->_clsid;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::GetUserType
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method supplies the user type string from the server's
//              CLASSDESCRIPTOR structure
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::GetUserType(DWORD dwFormOfType, LPOLESTR FAR* plpstr)
{
    if (plpstr == NULL || dwFormOfType < 1 || dwFormOfType > 3)
    {
        DOUT(TEXT("SrvrCtrl::GetUserType E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    return TaskAllocString(_pClass->_szUserClassType[dwFormOfType], plpstr);
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::SetExtent
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method is forwarded to the SetExtent method on
//              the data/view subobject.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::SetExtent(DWORD dwDrawAspect, LPSIZEL lpsizel)
{
    if (lpsizel == NULL)
    {
        DOUT(TEXT("SrvrCtrl::SetExtent E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }
    return _pDV->SetExtent(dwDrawAspect, *lpsizel);
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::GetExtent
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method is forwarded to the SetExtent method on
//              the data/view subobject.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::GetExtent(DWORD dwDrawAspect, LPSIZEL lpsizel)
{
    if (lpsizel == NULL)
    {
        DOUT(TEXT("SrvrCtrl::GetExtent E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }
    return _pDV->GetExtent(dwDrawAspect, lpsizel);
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::Advise
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method is implemented using the standard
//              OLE advise holder.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::Advise(IAdviseSink FAR* pAdvSink, DWORD FAR* pdwConnection)
{
    if (pdwConnection == NULL)
    {
        DOUT(TEXT("SrvrCtrl::Advise E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }
    *pdwConnection = NULL;              // set out params to NULL

    HRESULT hr = NOERROR;
    if (_pOleAdviseHolder == NULL)
        hr = CreateOleAdviseHolder(&_pOleAdviseHolder);

    if (OK(hr))
        hr = _pOleAdviseHolder->Advise(pAdvSink, pdwConnection);

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::Unadvise
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method is implemented using the standard
//              OLE advise holder.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::Unadvise(DWORD dwConnection)
{
    if (_pOleAdviseHolder == NULL)
        return NOERROR;

    return _pOleAdviseHolder->Unadvise(dwConnection);
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::EnumAdvise
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method is implemented using the standard
//              OLE advise holder.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::EnumAdvise(LPENUMSTATDATA FAR* ppenumAdvise)
{
    if (ppenumAdvise == NULL)
    {
        DOUT(TEXT("SrvrCtrl::EnumAdvise E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    HRESULT hr;
    if (_pOleAdviseHolder == NULL)
    {
        *ppenumAdvise = NULL;
        hr = NOERROR;
    }
    else
    {
        hr = _pOleAdviseHolder->EnumAdvise(ppenumAdvise);
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::GetMiscStatus
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method supplies the misc status flags from the server's
//              CLASSDESCRIPTOR structure
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::GetMiscStatus(DWORD dwAspect, DWORD FAR* pdwStatus)
{
    if (pdwStatus == NULL)
    {
        DOUT(TEXT("SrvrCtrl::GetMiscStatus E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }
    *pdwStatus = _pClass->_dwMiscStatus;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::SetColorScheme
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      Servers should override this method if they are
//              interested in the palette.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::SetColorScheme(LPLOGPALETTE lpLogpal)
{
    DOUT(TEXT("SrvrCtrl::SetColorScheme E_NOTIMPL\r\n"));
    return E_NOTIMPL;   //will we ever?
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\o2base\sinpl.cxx ===
//+---------------------------------------------------------------------
//
//   File:      sinpl.cxx
//
//   Contents:  Implementation of the SrvrInPlace class
//
//------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::SrvrInPlace, public
//
//  Synopsis:   Constructor for SrvrInPlace object
//
//  Notes:      To create a properly initialized object you must
//              call the Init method immediately after construction.
//
//---------------------------------------------------------------

SrvrInPlace::SrvrInPlace(void)
{
    DOUT(TEXT("SrvrInPlace: Constructing\r\n"));

    _hwnd = NULL;

    _pInPlaceSite = NULL;
    _frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
    _pFrame = NULL;
    _pDoc = NULL;

    _hmenu = NULL;
    _hOleMenu = NULL;
    _hmenuShared = NULL;

    _fCSHelpMode = FALSE;
    _fChildActivating = FALSE;
    _fDeactivating = FALSE;
    _rcFrame.top = 0; _rcFrame.left = 0;
    _rcFrame.bottom = 0; _rcFrame.right = 0;

    _fClientResize = FALSE;
    _fUIDown = TRUE;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::Init, public
//
//  Synopsis:   Fully initializes a SrvrInPlace object
//
//  Arguments:  [pClass] -- The initialized class descriptor for the server
//              [pCtrl] -- The control subobject of the server we are a part of.
//
//  Returns:    NOERROR if successful
//
//  Notes:      The class descriptor pointer is saved in the protected _pClass
//              member variable where it is accessible during the lifetime
//              of the object.
//
//---------------------------------------------------------------

HRESULT
SrvrInPlace::Init(LPCLASSDESCRIPTOR pClass, LPSRVRCTRL pCtrl)
{
    _pClass = pClass;
    _pCtrl = pCtrl;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::~SrvrInPlace, protected
//
//  Synopsis:   Destructor for the SrvrCtrl object
//
//  Notes:      The destructor is called as a result of the servers
//              reference count going to 0.  It releases all held
//              resources.
//
//---------------------------------------------------------------

SrvrInPlace::~SrvrInPlace(void)
{
    DOUT(TEXT("SrvrInPlace: Destructed\r\n"));
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::ActivateInPlace, public
//
//  Synopsis:   In-place activates the object
//
//  Arguments:  [pClientSite] -- The site on our container
//
//  Returns:    Success if we in-place activated properly
//
//  Notes:      This method implements the standard in-place activation
//              protocol and creates the in-place window.  It creates
//              all U.I. elements using CreateUI but does not
//              activate the U.I., for that is reserved for
//              the ActivateUI and InstallUI methods.
//
//---------------------------------------------------------------

HRESULT
SrvrInPlace::ActivateInPlace(LPOLECLIENTSITE pClientSite)
{
    DOUT(TEXT("SrvrInPlace::ActivateInPlace\r\n"));

    if (pClientSite == NULL)
    {
        DOUT(TEXT("SrvrInPlace::ActivateInPlace E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    HWND hwndSite;
    RECT rect, rectVis;
    HRESULT hr;

    //
    // see if the client site supports in-place, and is willing to do so...
    //
    if (OK(hr = pClientSite->QueryInterface(IID_IOleInPlaceSite,
                (LPVOID FAR *)&_pInPlaceSite)))
    {
        if (OK(hr = _pInPlaceSite->CanInPlaceActivate()))
        {
            if (OK(hr = _pInPlaceSite->GetWindow(&hwndSite))
                    &&  OK(hr = _pInPlaceSite->GetWindowContext(&_pFrame,
                                &_pDoc,
                                &rect,
                                &rectVis,
                                &_frameInfo)))
            {
                if ((_hwnd = AttachWin(hwndSite)) == NULL)
                {
                    DOUT(TEXT("SrvrInPlace::ActivateInPlace failed at AttachWin\r\n"));
                    hr = E_UNEXPECTED;
                }
                else
                {
                    if (OK(hr = _pInPlaceSite->OnInPlaceActivate()))
                    {
                        if(_pCtrl->IsIPBEnabled())
                        {
                            _IPB.Bind(_pInPlaceSite, _hwnd, FALSE);
                        }

                        // create any U.I. elements
                        CreateUI();

                        // position and show the window
                        SetObjectRects(&rect, &rectVis);
                        ShowWindow(_hwnd, SW_SHOW);

                        return NOERROR;

                        //
                        //The rest of this code cleans up after errors...
                        //
                    }
                    DetachWin();
                }
                if (_pFrame != NULL)
                    _pFrame->Release();
                if (_pDoc != NULL)
                    _pDoc->Release();
            }
        }
        _pInPlaceSite->Release();
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::DeactivateInPlace, public
//
//  Synopsis:   In-place deactivates the object
//
//  Returns:    Success except for catastophic circumstances
//
//  Notes:      This method "undoes" everything done in ActivateInPlace
//              including destroying U.I. elements via DestroyUI, and
//              destroying the inplace active window.
//
//---------------------------------------------------------------

HRESULT
SrvrInPlace::DeactivateInPlace(void)
{
    DOUT(TEXT("SrvrInPlace::DeactivateInPlace\r\n"));

    //
    // The following prevents some nasty recursion cases, in which the call
    // bellow to OnInPlaceDeactivate get's us back in to the same transition we
    // are in now...
    //
    _pCtrl->SetState(OS_RUNNING);
        
    // undo everything we did in InPlaceActivate
    if(_pCtrl->IsIPBEnabled())
    {
        _IPB.Detach();
    }

    DestroyUI();
    DetachWin();

    _pInPlaceSite->OnInPlaceDeactivate();

    if (_pFrame != NULL)
        _pFrame->Release();
    if (_pDoc != NULL)
        _pDoc->Release();

    // release the in-place site we were holding on to.
    _pInPlaceSite->Release();
    _pInPlaceSite = NULL;

    return NOERROR; // we never fail this function
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::ActivateUI, public
//
//  Synopsis:   Notifies container of U.I. activation and installs our
//              U.I. elements.
//
//  Returns:    Success if our container granted permission to U.I. activate.
//
//  Notes:      Installing our U.I. (border toolbars, floating palettes,
//              adornments) is accomplished via a virtual call to InstallUI.
//
//---------------------------------------------------------------

HRESULT
SrvrInPlace::ActivateUI(void)
{
    DOUT(TEXT("SrvrInPlace::ActivateUI\r\n"));

    HRESULT hr;
    if (OK(hr = _pInPlaceSite->OnUIActivate()))
    {
        InstallUI();

        if(!GetChildActivating() && !IsDeactivating())
            ReflectState(TRUE);
    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::DeactivateUI, public
//
//  Synopsis:   Removes any U.I. we have installed and notifies our container
//              that we are no longer U.I. active
//
//  Returns:    Success except for catastrophic circumstances
//
//  Notes:      This method "undoes" everything done in ActivateUI.
//              U.I. elements are removed via a virtual call to RemoveUI
//
//---------------------------------------------------------------

HRESULT
SrvrInPlace::DeactivateUI(void)
{
    DOUT(TEXT("SrvrInPlace::DeactivateUI\r\n"));

    //
    // The following prevents some nasty recursion cases, in which the call
    // bellow to OnUIDeactivate get's us back in to the same transition we
    // are in now...
    //
    _pCtrl->SetState(OS_INPLACE);
        
    // remove any UI that is up and notify our container that we have deactivated
    RemoveUI();
    _pInPlaceSite->OnUIDeactivate(FALSE);
    ReflectState(FALSE);

    //REVIEW: we should return TRUE if we add Undo capability.
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::InstallUI, public
//
//  Synopsis:   Installs previously created U.I. so it is displayed to
//              the user.
//
//  Notes:      This method will call the InstallFrameUI and InstallDocUI
//              methods to install those U.I. elements, respectively.
//
//---------------------------------------------------------------

void
SrvrInPlace::InstallUI(void)
{
    DOUT(TEXT("SrvrInPlace::InstallUI\r\n"));
    
    if(!_fChildActivating && !_fDeactivating)
    {
        _pFrame->SetActiveObject((LPOLEINPLACEACTIVEOBJECT)this,
                            _pClass->_szUserClassType[USERCLASSTYPE_SHORT]);
        InstallFrameUI();
        InstallDocUI();
        _fUIDown = FALSE;
    }
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::RemoveUI, public
//
//  Synopsis:   Removes previously installed U.I. so it is hidden from the
//              the user.
//
//  Notes:      This method "undoes" everything done in InstallUI.  It calls
//              the RemoveFrameUI and RemoveDocUI methods.
//
//---------------------------------------------------------------

void
SrvrInPlace::RemoveUI(void)
{
    DOUT(TEXT("SrvrInPlace::RemoveUI\r\n"));

    if(!_fUIDown)
    {
        _fUIDown = TRUE;

        ClearSelection();
        RemoveDocUI();
        RemoveFrameUI();
        _pFrame->SetActiveObject(NULL, NULL);
    }
}


#ifdef DOCGEN  // documentation for pure virtual function
//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::AttachWin, public
//
//  Synopsis:   Attaches the child in-place window
//              to the given parent.
//
//  Arguments:  [hwndParent] -- parent window for child
//
//  Returns:    HWND of attached window
//
//  Notes:      All servers must override this method.
//
//---------------------------------------------------------------

HWND SrvrInPlace::AttachWin(HWND hwndParent) {}
#endif //DOCGEN

//+--------------------------------------------------------------
//
//  Member:     SrvrInPlace::DetachWin, public
//
//  Synopsis:   Detaches the child's in-place
//              window from the current parent.
//
//  Arguments:  [hwndParent] -- parent window for child
//
//  Notes:      This destroys the _hwnd of the server.
//              If the derived class does anything
//              other than create a Window on AttachWin,
//              it must over-ride this function.
//              If the derived class destroys the window
//              on detach, it must set _hwnd = NULL
//
//---------------------------------------------------------------
void
SrvrInPlace::DetachWin()
{
    DOUT(TEXT("SrvrInPlace::DetachWin\r\n"));

    Assert(_hwnd != NULL && IsWindow(_hwnd));
    DestroyWindow(_hwnd);
    _hwnd = NULL;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::CreateUI, protected
//
//  Synopsis:   Creates all U.I. elements
//
//  Notes:      This method uses information in the class descriptor
//              to create a merged menu and OLE menu descriptor.
//              Servers that have additional U.I. should override
//              this method, but can call the base class to do the
//              standard menu processing.
//
// IMPORTANT:   The derived class is responsible for having
//              settup the _hmenu member prior to calling
//              this code.
//
//---------------------------------------------------------------

void
SrvrInPlace::CreateUI(void)
{
    DOUT(TEXT("SrvrInPlace::CreateUI\r\n"));

    Assert(_hmenuShared == NULL);

    _fUIDown = TRUE;

    if (_hmenu != NULL)
    {
        // create an empty menu and ask application to insert its menus
        if ((_hmenuShared = CreateMenu()) != NULL)
        {
            // get a copy of our menu-group widths and perform the merge
            _mgw = _pClass->_mgw;
            if (OK(_pFrame->InsertMenus(_hmenuShared, &_mgw)))
            {
                // insert our own menus and create a descriptor for
                // the whole mess
                if (OK(InsertServerMenus(_hmenuShared, _hmenu, &_mgw)))
                    _hOleMenu = OleCreateMenuDescriptor(_hmenuShared, &_mgw);
            }
        }
    }
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::DestroyUI, protected
//
//  Synopsis:   Destroys U.I. elements
//
//  Notes:      This method "undoes" everything that was done in
//              CreateUI -- destroys the shared menu and OLE menu
//              descriptor.  If a server overrides CreateUI then it
//              should also override this method.
//
//---------------------------------------------------------------

void
SrvrInPlace::DestroyUI(void)
{
    DOUT(TEXT("SrvrInPlace::DestroyUI\r\n"));

    if (_hmenuShared != NULL)
    {
        OleDestroyMenuDescriptor(_hOleMenu);
        RemoveServerMenus(_hmenuShared, &_mgw);
        _pFrame->RemoveMenus(_hmenuShared);
        DestroyMenu(_hmenuShared);
        _hmenuShared = NULL;
    }
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::InstallFrameUI, protected
//
//  Synopsis:   Installs the U.I. elements on the frame window
//
//  Notes:      This method uses IOleInPlaceFrame::SetMenu to install
//              the shared menu constructed in CreateUI.  It also notifies
//              the frame that we are the active object.
//              Servers that have additional frame adornments should
//              override this method.
//              This method is called by the InstallUI method and
//              on document window activation for when we are in a MDI
//              an application.
//
//---------------------------------------------------------------

void
SrvrInPlace::InstallFrameUI(void)
{
    DOUT(TEXT("SrvrInPlace::InstallFrameUI\r\n"));

    _pFrame->SetMenu(_hmenuShared, _hOleMenu, _hwnd);
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::RemoveFrameUI, protected
//
//  Synopsis:   Removes the U.I. elements on the frame window
//
//  Notes:      This method "undoes" everything that was done in
//              InstallFrameUI -- it removes the shared menu from
//              the frame.
//              Servers that override the InstallFrameUI method will
//              also want to override this method.
//              This method is call by the RemoveUI method and on
//              document window deactivation for MDI-application purposes.
//
//---------------------------------------------------------------

void
SrvrInPlace::RemoveFrameUI(void)
{
    DOUT(TEXT("SrvrInPlace::RemoveFrameUI\r\n"));

    _pFrame->SetMenu(NULL, NULL, _hwnd);
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::InstallDocUI, protected
//
//  Synopsis:   Installs the U.I. elements on the document window
//
//  Notes:      This method notifies the document window that we are
//              the active object.  Otherwise, there are no standard U.I. elements
//              installed on the document window.
//              Servers that have document window tools should override this
//              method.
//
//---------------------------------------------------------------

void
SrvrInPlace::InstallDocUI(void)
{
    DOUT(TEXT("SrvrInPlace::InstallDocUI\r\n"));

    if (_pDoc != NULL)
    {
        DOUT(TEXT("SrvrInPlace::InstallDocUI (_pDoc != NULL)\r\n"));
        _pDoc->SetActiveObject((LPOLEINPLACEACTIVEOBJECT)this,
                                _pClass->_szUserClassType[USERCLASSTYPE_SHORT]);
    }
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::RemoveDocUI, protected
//
//  Synopsis:   Removes the U.I. elements from the document window.
//
//  Notes:      This method "undoes" everything done in the InstallDocUI
//              method.
//              Servers that override the InstallDocUI method should
//              also override this method.
//
//---------------------------------------------------------------

void
SrvrInPlace::RemoveDocUI(void)
{
    DOUT(TEXT("SrvrInPlace::RemoveDocUI\r\n"));

    if (_pDoc != NULL)
    {
        _pDoc->SetActiveObject(NULL, NULL);
    }
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::ClearSelection
//
//  Synopsis:   Removes any selection because we have lost ownership of the U.I.
//
//  Notes:      When our container or an embedding steals the right to put
//              up the U.I. then we should remove any selection to avoid
//              confusing the user.
//
//---------------------------------------------------------------

void
SrvrInPlace::ClearSelection(void)
{
    DOUT(TEXT("SrvrInPlace::ClearSelection\r\n"));
}


//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::SetFocus, public
//
//  Synopsis:   Overide in derived if focus-window != _hwnd
//
//---------------------------------------------------------------

void
SrvrInPlace::SetFocus(HWND hwnd)
{
    ::SetFocus(hwnd);
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::GetWindow, public
//
//  Synopsis:   Method of IOleWindow interface
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrInPlace::GetWindow(HWND FAR* lphwnd)
{
    if (lphwnd == NULL)
    {
        DOUT(TEXT("SrvrInPlace::GetWindow E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    *lphwnd = _hwnd;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::ContextSensitiveHelp, public
//
//  Synopsis:   Method of IOleWindow interface
//
//  Notes:      This method sets or clears the _fCSHelpMode
//              member flag.  The window procedure needs to pay
//              attention to the value of this flag in implementing
//              context-sensitive help.
//
//              We never fail!
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrInPlace::ContextSensitiveHelp(BOOL fEnterMode)
{
    DOUT(TEXT("SrvrInPlace::ContextSensitiveHelp\r\n"));

    _fCSHelpMode = fEnterMode;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::InPlaceDeactivate, public
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      This method transitions the object to the loaded state
//              if the object is in the InPlace or U.I. active state.
//
//              We never fail!
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrInPlace::InPlaceDeactivate(void)
{
    DOUT(TEXT("SrvrInPlace::InPlaceDeactivate\r\n"));

    if (_pCtrl->State() == OS_INPLACE || _pCtrl->State() == OS_UIACTIVE)
    {
        _pCtrl->TransitionTo(OS_LOADED);
    }
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::UIDeactivate, public
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      The method transitions the object to the in-place state
//              if the object is in U.I. active state.
//
//              We never fail!
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrInPlace::UIDeactivate(void)
{
    DOUT(TEXT("SrvrInPlace::UIDeactivate\r\n"));

    if (_pCtrl->State() == OS_UIACTIVE)
    {
        _fDeactivating = TRUE;
        _pCtrl->TransitionTo(OS_INPLACE);
        _fDeactivating = FALSE;
    }
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::SetObjectRects, public
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      This method does a Move window on the child
//              window to put it in its new position.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrInPlace::SetObjectRects(LPCRECT lprcPos, LPCRECT lprcVisRect)
{
    DOUT(TEXT("SrvrInPlace::SetObjectRects\r\n"));

    if (lprcPos == NULL || lprcVisRect == NULL)
    {
        DOUT(TEXT("SrvrInPlace::SetObjectRects E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    _fClientResize = TRUE;  //indicate that we are being resized by client

    //
    // calculate and do the new child window positioning
    //
    RECT rc = *lprcPos;
    if(_pCtrl->IsIPBEnabled())
    {
        _IPB.SetSize(_hwnd, rc);
    }
    else
    {
        SetWindowPos( _hwnd, NULL, rc.left, rc.top,
            rc.right - rc.left, rc.bottom - rc.top,
            SWP_NOZORDER);
    }

    //
    // update our border rect (child window coordinates)
    //
    _rcFrame.right = rc.right - rc.left;
    _rcFrame.bottom = rc.bottom - rc.top;

    //
    // update our "native" extent
    //
    SIZEL sizel = { HimetricFromHPix(_rcFrame.right - _rcFrame.left),
            HimetricFromVPix(_rcFrame.bottom - _rcFrame.top) };

    _pCtrl->SetExtent(DVASPECT_CONTENT, &sizel);

    _fClientResize = FALSE; // indicate that client resize is over

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::ReactivateAndUndo, public
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      This method returns E_FAIL.  If the server wishes
//              to support undo it should override this method.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrInPlace::ReactivateAndUndo(void)
{
    DOUT(TEXT("SrvrInPlace::ReactivateAndUndo E_NOTIMPL\r\n"));
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::TranslateAccelerator, public
//
//  Synopsis:   Method of IOleInPlaceActiveObject interface
//
//  Notes:      This method translates the message according
//              to the accelerator table in the class descriptor
//              structure.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrInPlace::TranslateAccelerator(LPMSG lpmsg)
{
    //
    // translate the message via the SrvrInPlace accelerator table
    //
    if (_pClass->_haccel  &&
            ::TranslateAccelerator(_hwnd, _pClass->_haccel, lpmsg))
    {
        return NOERROR;
    }

    return S_FALSE;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::OnFrameWindowActivate, public
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      This method changes the color of our border shading
//              depending on whether our frame window is activating
//              or deactivating.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrInPlace::OnFrameWindowActivate(BOOL fActivate)
{
    DOUT(TEXT("SrvrInPlace::OnFrameWindowActivate\r\n"));

    if(_pCtrl->IsIPBEnabled())
        _IPB.SetParentActive(fActivate);

    if(fActivate && _hwnd && (_pCtrl->State() != OS_OPEN))
        SetFocus(_hwnd);

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::OnDocWindowActivate, public
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      This method will install or remove the frame
//              U.I. elements using the InstallFrameUI or RemoveFrameUI
//              methods.  This is to properly handle the MDI application
//              case.  It also updates our shading color.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrInPlace::OnDocWindowActivate(BOOL fActivate)
{
    DOUT(TEXT("SrvrInPlace::OnDocWindowActivate\r\n"));

    if (fActivate)
    {
        InstallFrameUI();
        SetFocus(_hwnd);
    }
    else if (!fActivate)
        RemoveFrameUI();

    if(_pCtrl->IsIPBEnabled())
        _IPB.SetParentActive(fActivate);

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::ResizeBorder, public
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      There are no standard border adornments so we do
//              nothing in this method.  Servers that have additional
//              U.I. elements that are installed on the frame or
//              document windows should override this method.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrInPlace::ResizeBorder(LPCRECT lprc,
                        LPOLEINPLACEUIWINDOW pUIWindow,
                        BOOL fFrameWindow)
{
    DOUT(TEXT("SrvrInPlace::ResizeBorder\r\n"));

    // we do not install any tools on our frame or document windows.
    //REVIEW:  This must be implemented if we do implement a frame or document
    //REVIEW:  toolbar.

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::EnableModeless, public
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      If we are a DLL and hence don't have a separate
//              message pump we can ignore this call and simply
//              return NOERROR.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrInPlace::EnableModeless(BOOL fEnable)
{
    DOUT(TEXT("SrvrInPlace::EnableModeless\r\n"));

    return NOERROR;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\o2base\iputils.cxx ===
//+---------------------------------------------------------------------
//
//  File:       iputils.hxx
//
//  Contents:   Helper functions for in-place activation
//
//----------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#define MAXLABELLEN 32

//+---------------------------------------------------------------
//
//  Function:   InsertServerMenus
//
//  Synopsis:   Inserts the objects menus into a shared menu after
//              the top-level application has inserted its menus
//
//  Arguments:  [hmenuShared] -- the shared menu to recieve the objects menus
//              [hmenuObject] -- all of the objects menus
//              [lpmgw] -- menu group widths indicating where the menus
//                          should be inserted
//
//  Returns:    Success if the menus were merged successfully
//
//  Notes:      The function does most of the shared menu work
//              by the object between the IOleInPlaceFrame::InsertMenus and
//              IOleInPlaceFrame::SetMenu method calls.
//              c.f. RemoveServerMenus
//
//----------------------------------------------------------------

HRESULT
InsertServerMenus(HMENU hmenuShared,
        HMENU hmenuObject,
        LPOLEMENUGROUPWIDTHS lpmgw)
{
    int i, j;
    HMENU hmenuXfer;
    TCHAR szLabel[MAXLABELLEN];
    UINT iServer = 0;
    UINT iShared = 0;

    // for each of the Edit, Object, and Help menu groups
    for (j = 1; j <= 5; j += 2)
    {
        // advance over container menus
        iShared += (UINT)lpmgw->width[j-1];

        // pull out the popup menus from servers menu
        for (i = 0; i < lpmgw->width[j]; i++)
        {
            GetMenuString(hmenuObject,
                        iServer,
                        szLabel,
                        MAXLABELLEN,
                        MF_BYPOSITION);
            hmenuXfer = GetSubMenu(hmenuObject, iServer++);
            if (!InsertMenu(hmenuShared,
                        iShared++,
                        MF_BYPOSITION|MF_POPUP,
                        (UINT_PTR)hmenuXfer,
                        szLabel))
            {
                return HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Function:   RemoveServerMenus
//
//  Synopsis:   Removes the objects menus from a shared menu
//
//  Arguments:  [hmenuShared] -- the menu contain both the application's
//                              and the object's menus
//              [lpmgw] -- menu group widths indicating which menus should
//                          be removed
//
//  Notes:      c.f. InsertServerMenus
//
//----------------------------------------------------------------

void
RemoveServerMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpmgw)
{
    int i, j;
    UINT iShared = 0;

    // for each of the Edit, Object, and Help menu groups
    for (j = 1; j <= 5; j += 2)
    {
        // advance over container menus
        iShared += (UINT)lpmgw->width[j-1];

        // pull out the popup menus from shared menu
        for (i = 0; i < lpmgw->width[j]; i++)
        {
            RemoveMenu(hmenuShared, iShared, MF_BYPOSITION);
        }
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\o2base\misc.cxx ===
//+---------------------------------------------------------------------
//
//  File:       misc.cxx
//
//  Contents:   Useful OLE helper and debugging functions
//
//----------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//#include <rpcferr.h>


#if !defined(UNICODE) && !defined(OLE2ANSI)
LPOLESTR ConvertMBToOLESTR(LPCSTR lpStr, int cchStr)
{
        OLECHAR *lpwConverted;
        int cchW;
        
        //
        // UNICODE note: assuming we get an LPSTR here, find out how
        // many *bytes* are required and multiply by sizeof(TCHAR)
        //
        cchW = MultiByteToWideChar(CP_ACP, 0, lpStr, cchStr, NULL, 0);

        TaskAllocMem(sizeof(OLECHAR)*cchW, (LPVOID FAR *)&lpwConverted);

        if (lpwConverted == NULL)
                return NULL;
        
        MultiByteToWideChar(CP_ACP
                            , 0
                            , lpStr
                            , cchStr
                            , lpwConverted
                            , cchW);
        
        return lpwConverted;
}

LPTSTR ConvertOLESTRToMB(LPCOLESTR lpStr, int cchStr)
{
        LPTSTR lpConverted;
        int    cch;
        
        //
        // UNICODE note: assuming we get an LPSTR here, find out how
        // many *bytes* are required and multiply by sizeof(TCHAR)
        //
        cch = WideCharToMultiByte(CP_ACP, 0, lpStr, cchStr, NULL, 0, NULL, NULL);

        TaskAllocMem(sizeof(TCHAR)*cch, (LPVOID FAR *)&lpConverted);

        if (lpConverted == NULL)
                return NULL;
        
        WideCharToMultiByte(CP_ACP
                            , 0
                            , lpStr
                            , cchStr
                            , lpConverted
                            , cch
                            , NULL
                            , NULL);
        
        return lpConverted;
}
#endif

//+---------------------------------------------------------------
//
//  Function:   IsCompatibleOleVersion
//
//  Synopsis:   Checks if the installed version of OLE is compatible with
//              the version of OLE for which the software was written.
//
//  Arguments:  [wMaj] -- the major version number
//              [wMin] -- the minor version number
//
//  Returns:    TRUE if the installed version of OLE is compatible
//
//  Notes:      This function combines a call to OleBuildVersion
//              with the proper checking of version numbers.
//              The major and minor values passed in should be
//              the major and minor values returned from
//              OleBuildVersion for the version of OLE current
//              when the software was written.
//
//----------------------------------------------------------------

BOOL
IsCompatibleOleVersion(WORD wMaj, WORD wMin)
{
    // Check our compatibility with the OLE runtime.
    // We are compatible with any later major version,
    // or the same major version with equal or greater minor version.
    DWORD ov = OleBuildVersion();
    return HIWORD(ov) > wMaj || (HIWORD(ov) == wMaj && LOWORD(ov) >= wMin);
}

#if DBG

//+---------------------------------------------------------------
//
//  Function:   AssertSFL
//
//  Synopsis:   Displays "Assertion Failed" message and puts up
//              a message box allowing the user to (1) exit the program,
//              (2) break into the debugger, or (3) ignore
//
//  Arguments:
//              [lpszClause]   -- The assertion clause
//              [lpszFileName] -- File where assertion failed
//              [nLine}        -- Line in file where assertion failed
//
//----------------------------------------------------------------

extern "C" void FAR PASCAL AssertSFL(LPSTR lpszClause,
        LPSTR lpszFileName, int nLine)
{
    static TCHAR achMessage[] = TEXT("File %hs\n Line %d");
    TCHAR achTitle[256];
    TCHAR achFormatBuffer[256];

    wsprintf(achTitle,TEXT("%hs"), lpszClause);
    wsprintf(achFormatBuffer, achMessage, lpszFileName, nLine);
    
    OutputDebugString(achFormatBuffer);
    OutputDebugString(TEXT(", "));
    OutputDebugString(achTitle);
    OutputDebugString(TEXT("\n\r"));
        
retry:
    int nCode = ::MessageBox(NULL, achFormatBuffer, achTitle,
                        MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE);
    if (nCode == IDIGNORE)
        return;     // ignore
    else if (nCode == IDRETRY)
    {
        // break into the debugger (or Dr Watson log)
        DebugBreak();   
        goto retry;
    }                            
    
    // else fall through and exit
    FatalExit(2);
}

#endif // DBG

#if DBG == 1

//+---------------------------------------------------------------
//
//  Function:   TraceIID
//
//  Synopsis:   Outputs the name of the interface to the debugging device
//
//  Arguments:  [riid] -- the interface
//
//  Notes:      This function disappears in retail builds.
//
//----------------------------------------------------------------

void
TraceIID(REFIID riid)
{
    LPTSTR lpstr = TEXT("UNKNOWN INTERFACE");

#define CASE_IID(iid)  \
        if (IsEqualIID(IID_##iid, riid)) lpstr = (LPTSTR)TEXT(#iid);

    CASE_IID(IUnknown)
    CASE_IID(IOleLink)
    CASE_IID(IOleCache)
    CASE_IID(IOleManager)
    CASE_IID(IOlePresObj)
    CASE_IID(IDebug)
    CASE_IID(IDebugStream)
    CASE_IID(IAdviseSink2)
    CASE_IID(IDataObject)
    CASE_IID(IViewObject)
    CASE_IID(IOleObject)
    CASE_IID(IOleInPlaceObject)
    CASE_IID(IParseDisplayName)
    CASE_IID(IOleContainer)
    CASE_IID(IOleItemContainer)
    CASE_IID(IOleClientSite)
    CASE_IID(IOleInPlaceSite)
    CASE_IID(IPersist)
    CASE_IID(IPersistStorage)
    CASE_IID(IPersistFile)
    CASE_IID(IPersistStream)
    CASE_IID(IOleClientSite)
    CASE_IID(IOleInPlaceSite)
    CASE_IID(IAdviseSink)
    CASE_IID(IDataAdviseHolder)
    CASE_IID(IOleAdviseHolder)
    CASE_IID(IClassFactory)
    CASE_IID(IOleWindow)
    CASE_IID(IOleInPlaceActiveObject)
    CASE_IID(IOleInPlaceUIWindow)
    CASE_IID(IOleInPlaceFrame)
    CASE_IID(IDropSource)
    CASE_IID(IDropTarget)
    CASE_IID(IBindCtx)
    CASE_IID(IEnumUnknown)
    CASE_IID(IEnumString)
    CASE_IID(IEnumFORMATETC)
    CASE_IID(IEnumSTATDATA)
    CASE_IID(IEnumOLEVERB)
    CASE_IID(IEnumMoniker)
    CASE_IID(IEnumGeneric)
    CASE_IID(IEnumHolder)
    CASE_IID(IEnumCallback)
    CASE_IID(ILockBytes)
    CASE_IID(IStorage)
    CASE_IID(IStream)
    //CASE_IID(IDispatch)
    //CASE_IID(IEnumVARIANT)
    //CASE_IID(ITypeInfo)
    //CASE_IID(ITypeLib)
    //CASE_IID(ITypeComp)
    //CASE_IID(ICreateTypeInfo)
    //CASE_IID(ICreateTypeLib)

#undef CASE_IID

    TCHAR achTemp[256];
#ifdef UNICODE    
    wsprintf(achTemp, TEXT("%ws"), lpstr);
#else
    wsprintf(achTemp, TEXT("%s"), lpstr);    
#endif        
    OutputDebugString( achTemp );
}


//+---------------------------------------------------------------
//
//  Function:   TraceHRESULT
//
//  Synopsis:   Outputs the name of the SCODE to the debugging device
//
//  Arguments:  [scode] -- the status code to report
//
//  Notes:      This function disappears in retail builds.
//
//----------------------------------------------------------------

HRESULT
TraceHRESULT(HRESULT r)
{
    LPTSTR lpstr;
#ifdef UNICODE
#define CASE_SCODE(sc)  \
        case sc: lpstr = (LPWSTR)L#sc; break;
#else
#define CASE_SCODE(sc)  \
        case sc: lpstr = (LPSTR)#sc; break;
#endif    
    switch (r) {
        /* SCODE's defined in SCODE.H */
        CASE_SCODE(S_OK)
 // same value as S_OK      CASE_SCODE(S_TRUE)
        CASE_SCODE(S_FALSE)
        CASE_SCODE(E_UNEXPECTED)
        CASE_SCODE(E_NOTIMPL)
        CASE_SCODE(E_OUTOFMEMORY)
        CASE_SCODE(E_INVALIDARG)
        CASE_SCODE(E_NOINTERFACE)
        CASE_SCODE(E_POINTER)
        CASE_SCODE(E_HANDLE)
        CASE_SCODE(E_ABORT)
        CASE_SCODE(E_FAIL)
        CASE_SCODE(E_ACCESSDENIED)

        /* SCODE's defined in DVOBJ.H */
        CASE_SCODE(DATA_E_FORMATETC)
// same as DATA_E_FORMATETC     CASE_SCODE(DV_E_FORMATETC)
        CASE_SCODE(DATA_S_SAMEFORMATETC)
        CASE_SCODE(VIEW_E_DRAW)
//  same as VIEW_E_DRAW         CASE_SCODE(E_DRAW)
        CASE_SCODE(VIEW_S_ALREADY_FROZEN)
        CASE_SCODE(CACHE_E_NOCACHE_UPDATED)
        CASE_SCODE(CACHE_S_FORMATETC_NOTSUPPORTED)
        CASE_SCODE(CACHE_S_SAMECACHE)
        CASE_SCODE(CACHE_S_SOMECACHES_NOTUPDATED)

        /* SCODE's defined in OLE2.H */
        CASE_SCODE(OLE_E_OLEVERB)
        CASE_SCODE(OLE_E_ADVF)
        CASE_SCODE(OLE_E_ENUM_NOMORE)
        CASE_SCODE(OLE_E_ADVISENOTSUPPORTED)
        CASE_SCODE(OLE_E_NOCONNECTION)
        CASE_SCODE(OLE_E_NOTRUNNING)
        CASE_SCODE(OLE_E_NOCACHE)
        CASE_SCODE(OLE_E_BLANK)
        CASE_SCODE(OLE_E_CLASSDIFF)
        CASE_SCODE(OLE_E_CANT_GETMONIKER)
        CASE_SCODE(OLE_E_CANT_BINDTOSOURCE)
        CASE_SCODE(OLE_E_STATIC)
        CASE_SCODE(OLE_E_PROMPTSAVECANCELLED)
        CASE_SCODE(OLE_E_INVALIDRECT)
        CASE_SCODE(OLE_E_WRONGCOMPOBJ)
        CASE_SCODE(OLE_E_INVALIDHWND)
        CASE_SCODE(DV_E_DVTARGETDEVICE)
        CASE_SCODE(DV_E_STGMEDIUM)
        CASE_SCODE(DV_E_STATDATA)
        CASE_SCODE(DV_E_LINDEX)
        CASE_SCODE(DV_E_TYMED)
        CASE_SCODE(DV_E_CLIPFORMAT)
        CASE_SCODE(DV_E_DVASPECT)
        CASE_SCODE(DV_E_DVTARGETDEVICE_SIZE)
        CASE_SCODE(DV_E_NOIVIEWOBJECT)
        CASE_SCODE(OLE_S_USEREG)
        CASE_SCODE(OLE_S_STATIC)
        CASE_SCODE(OLE_S_MAC_CLIPFORMAT)
        CASE_SCODE(CONVERT10_E_OLESTREAM_GET)
        CASE_SCODE(CONVERT10_E_OLESTREAM_PUT)
        CASE_SCODE(CONVERT10_E_OLESTREAM_FMT)
        CASE_SCODE(CONVERT10_E_OLESTREAM_BITMAP_TO_DIB)
        CASE_SCODE(CONVERT10_E_STG_FMT)
        CASE_SCODE(CONVERT10_E_STG_NO_STD_STREAM)
        CASE_SCODE(CONVERT10_E_STG_DIB_TO_BITMAP)
        CASE_SCODE(CONVERT10_S_NO_PRESENTATION)
        CASE_SCODE(CLIPBRD_E_CANT_OPEN)
        CASE_SCODE(CLIPBRD_E_CANT_EMPTY)
        CASE_SCODE(CLIPBRD_E_CANT_SET)
        CASE_SCODE(CLIPBRD_E_BAD_DATA)
        CASE_SCODE(CLIPBRD_E_CANT_CLOSE)
        CASE_SCODE(DRAGDROP_E_NOTREGISTERED)
        CASE_SCODE(DRAGDROP_E_ALREADYREGISTERED)
        CASE_SCODE(DRAGDROP_E_INVALIDHWND)
        CASE_SCODE(DRAGDROP_S_DROP)
        CASE_SCODE(DRAGDROP_S_CANCEL)
        CASE_SCODE(DRAGDROP_S_USEDEFAULTCURSORS)
        CASE_SCODE(OLEOBJ_E_NOVERBS)
        CASE_SCODE(OLEOBJ_S_INVALIDVERB)
        CASE_SCODE(OLEOBJ_S_CANNOT_DOVERB_NOW)
        CASE_SCODE(OLEOBJ_S_INVALIDHWND)
        CASE_SCODE(INPLACE_E_NOTUNDOABLE)
        CASE_SCODE(INPLACE_E_NOTOOLSPACE)
        CASE_SCODE(INPLACE_S_TRUNCATED)

        /* SCODE's defined in STORAGE.H */
        CASE_SCODE(STG_E_INVALIDFUNCTION)
        CASE_SCODE(STG_E_FILENOTFOUND)
        CASE_SCODE(STG_E_PATHNOTFOUND)
        CASE_SCODE(STG_E_TOOMANYOPENFILES)
        CASE_SCODE(STG_E_ACCESSDENIED)
        CASE_SCODE(STG_E_INVALIDHANDLE)
        CASE_SCODE(STG_E_INSUFFICIENTMEMORY)
        CASE_SCODE(STG_E_INVALIDPOINTER)
        CASE_SCODE(STG_E_NOMOREFILES)
        CASE_SCODE(STG_E_DISKISWRITEPROTECTED)
        CASE_SCODE(STG_E_SEEKERROR)
        CASE_SCODE(STG_E_WRITEFAULT)
        CASE_SCODE(STG_E_READFAULT)
        CASE_SCODE(STG_E_LOCKVIOLATION)
        CASE_SCODE(STG_E_FILEALREADYEXISTS)
        CASE_SCODE(STG_E_INVALIDPARAMETER)
        CASE_SCODE(STG_E_MEDIUMFULL)
        CASE_SCODE(STG_E_ABNORMALAPIEXIT)
        CASE_SCODE(STG_E_INVALIDHEADER)
        CASE_SCODE(STG_E_INVALIDNAME)
        CASE_SCODE(STG_E_UNKNOWN)
        CASE_SCODE(STG_E_UNIMPLEMENTEDFUNCTION)
        CASE_SCODE(STG_E_INVALIDFLAG)
        CASE_SCODE(STG_E_INUSE)
        CASE_SCODE(STG_E_NOTCURRENT)
        CASE_SCODE(STG_E_REVERTED)
        CASE_SCODE(STG_E_CANTSAVE)
        CASE_SCODE(STG_E_OLDFORMAT)
        CASE_SCODE(STG_E_OLDDLL)
        CASE_SCODE(STG_E_SHAREREQUIRED)
        CASE_SCODE(STG_S_CONVERTED)
        //CASE_SCODE(STG_S_BUFFEROVERFLOW)
        //CASE_SCODE(STG_S_TRYOVERWRITE)

        /* SCODE's defined in COMPOBJ.H */
        CASE_SCODE(CO_E_NOTINITIALIZED)
        CASE_SCODE(CO_E_ALREADYINITIALIZED)
        CASE_SCODE(CO_E_CANTDETERMINECLASS)
        CASE_SCODE(CO_E_CLASSSTRING)
        CASE_SCODE(CO_E_IIDSTRING)
        CASE_SCODE(CO_E_APPNOTFOUND)
        CASE_SCODE(CO_E_APPSINGLEUSE)
        CASE_SCODE(CO_E_ERRORINAPP)
        CASE_SCODE(CO_E_DLLNOTFOUND)
        CASE_SCODE(CO_E_ERRORINDLL)
        CASE_SCODE(CO_E_WRONGOSFORAPP)
        CASE_SCODE(CO_E_OBJNOTREG)
        CASE_SCODE(CO_E_OBJISREG)
        CASE_SCODE(CO_E_OBJNOTCONNECTED)
        CASE_SCODE(CO_E_APPDIDNTREG)
        CASE_SCODE(CLASS_E_NOAGGREGATION)
        CASE_SCODE(REGDB_E_READREGDB)
        CASE_SCODE(REGDB_E_WRITEREGDB)
        CASE_SCODE(REGDB_E_KEYMISSING)
        CASE_SCODE(REGDB_E_INVALIDVALUE)
        CASE_SCODE(REGDB_E_CLASSNOTREG)
        CASE_SCODE(REGDB_E_IIDNOTREG)
#if defined(NO_NTOLEBUGS)
        CASE_SCODE(RPC_E_SERVER_DIED)
        CASE_SCODE(RPC_E_CALL_REJECTED)
        CASE_SCODE(RPC_E_CALL_CANCELED)
        CASE_SCODE(RPC_E_CANTPOST_INSENDCALL)
        CASE_SCODE(RPC_E_CANTCALLOUT_INASYNCCALL)
        CASE_SCODE(RPC_E_CANTCALLOUT_INEXTERNALCALL)
        CASE_SCODE(RPC_E_CONNECTION_TERMINATED)
        CASE_SCODE(RPC_E_CLIENT_DIED)
        CASE_SCODE(RPC_E_INVALID_DATAPACKET)
        CASE_SCODE(RPC_E_CANTTRANSMIT_CALL)
        CASE_SCODE(RPC_E_CLIENT_CANTMARSHAL_DATA)
        CASE_SCODE(RPC_E_CLIENT_CANTUNMARSHAL_DATA)
        CASE_SCODE(RPC_E_SERVER_CANTMARSHAL_DATA)
        CASE_SCODE(RPC_E_SERVER_CANTUNMARSHAL_DATA)
        CASE_SCODE(RPC_E_INVALID_DATA)
        CASE_SCODE(RPC_E_INVALID_PARAMETER)
        CASE_SCODE(RPC_E_UNEXPECTED)
#endif // NO_NTOLEBUGS

        /* SCODE's defined in MONIKER.H */
        CASE_SCODE(MK_E_CONNECTMANUALLY)
        CASE_SCODE(MK_E_EXCEEDEDDEADLINE)
        CASE_SCODE(MK_E_NEEDGENERIC)
        CASE_SCODE(MK_E_UNAVAILABLE)
        CASE_SCODE(MK_E_SYNTAX)
        CASE_SCODE(MK_E_NOOBJECT)
        CASE_SCODE(MK_E_INVALIDEXTENSION)
        CASE_SCODE(MK_E_INTERMEDIATEINTERFACENOTSUPPORTED)
        CASE_SCODE(MK_E_NOTBINDABLE)
        CASE_SCODE(MK_E_NOTBOUND)
        CASE_SCODE(MK_E_CANTOPENFILE)
        CASE_SCODE(MK_E_MUSTBOTHERUSER)
        CASE_SCODE(MK_E_NOINVERSE)
        CASE_SCODE(MK_E_NOSTORAGE)
        CASE_SCODE(MK_S_REDUCED_TO_SELF)
        CASE_SCODE(MK_S_ME)
        CASE_SCODE(MK_S_HIM)
        CASE_SCODE(MK_S_US)
#if defined(NO_NTOLEBUGS)
        CASE_SCODE(MK_S_MONIKERALREADYREGISTERED)
#endif //NO_NTOLEBUGS

    default:
        lpstr = TEXT(" <UNKNOWN SCODE  0x%lx>\n");
        break;
    }

#undef CASE_SCODE

    TCHAR achTemp[256];
#ifdef UNICODE    
    wsprintf(achTemp, TEXT("%ws"), lpstr);
#else
    wsprintf(achTemp, TEXT("%s"), lpstr);
#endif        
    OutputDebugString( achTemp );
    return r;
}

#endif  // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\o2base\stgutils.cxx ===
//+---------------------------------------------------------------------
//
//  File:       stgutils.hxx
//
//  Contents:   IStorage and IStream Helper functions
//
//----------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//+---------------------------------------------------------------
//
//  Function:   GetMonikerDisplayName
//
//  Synopsis:   Retrieves the display name of a moniker
//
//  Arguments:  [pmk] -- the moniker for which the display name is requested
//              [ppstr] -- the place where the display name is returned
//
//  Returns:    Success iff the display name could be retrieved
//
//  Notes:      The display name string is allocated using the task allocator
//              and should be freed by the same.
//
//----------------------------------------------------------------

HRESULT
GetMonikerDisplayName(LPMONIKER pmk, LPOLESTR FAR* ppstr)
{
    HRESULT r;
    LPBC pbc;
    if (OK(r = CreateBindCtx(0, &pbc)))
    {
        r = pmk->GetDisplayName(pbc, NULL, ppstr);
        pbc->Release();
    }
    return r;
}

//+---------------------------------------------------------------
//
//  Function:   CreateStorageOnHGlobal
//
//  Synopsis:   Creates an IStorage on a global memory handle
//
//  Arguments:  [hgbl] -- memory handle to create storage on
//              [ppStg] -- where the storage is returned
//
//  Returns:    Success iff the storage could be successfully created
//              on the memory handle.
//
//  Notes:      This helper function combines CreateILockBytesOnHGlobal
//              and StgCreateDocfileOnILockBytes.  hgbl may be NULL in
//              which case a global memory handle will be automatically
//              allocated.
//
//----------------------------------------------------------------

HRESULT
CreateStorageOnHGlobal(HGLOBAL hgbl, LPSTORAGE FAR* ppStg)
{
    HRESULT r;
    LPLOCKBYTES pLockBytes;
    if (OK(r = CreateILockBytesOnHGlobal(hgbl, TRUE, &pLockBytes)))
    {
        //REVIEW:  should be use STGM_DELETEONRELEASE when hgbl == NULL?
        r = StgCreateDocfileOnILockBytes(pLockBytes,
                STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE, 0, ppStg);
        pLockBytes->Release();
    }
    return r;
}

//+---------------------------------------------------------------
//
//  Function:   ConvertToMemoryStream
//
//  Synopsis:   Takes a stream and produces an equivalent stream
//              stored in memory for faster individual reads
//
//  Arguments:  [pStrmFrom] -- the stream to convert
//
//  Returns:    An equivalent stream
//
//  Notes:      Any failure in creating the memory stream will result in
//              the original stream, pStrmFrom, being returned.
//              Hence the caller should assume the stream passed in has
//              been released and should release the stream returned
//              after it has finished using it.
//
//----------------------------------------------------------------

LPSTREAM
ConvertToMemoryStream(LPSTREAM pStrmFrom)
{
    //REVIEW:  perhaps we should use the IStream::CopyTo function
    // instead of doing the read manually!
    HRESULT r;
    LPSTREAM pStrm = NULL;
    STATSTG statstg;

    if (OK(r = pStrmFrom->Stat(&statstg, STATFLAG_NONAME)))
    {
        if (statstg.cbSize.HighPart != 0)
        {
            DOUT(TEXT("o2base/stdils/ConvertToMemoryStream E_FAIL\r\n"));
            r = E_FAIL;
        }
        else
        {
            HGLOBAL hgbl = GlobalAlloc(GMEM_SHARE, statstg.cbSize.LowPart);
            if (hgbl == NULL)
            {
               DOUT(TEXT("o2base/stgutils/ConvertToMemoryStream failed\r\n"));
               r = E_OUTOFMEMORY;
            }
            else
            {
                LPVOID pv = GlobalLock(hgbl);
                if (pv == NULL)
                {
                    DOUT(TEXT("o2base/stdils/ConvertToMemoryStream E_FAIL(2)\r\n"));
                    r = E_FAIL;
                }
                else
                {
                    r = pStrmFrom->Read(pv, statstg.cbSize.LowPart, NULL);
                    GlobalUnlock(hgbl);
                    if (OK(r))
                    {
                        if (OK(r = CreateStreamOnHGlobal(hgbl, TRUE, &pStrm)))
                        {
                            pStrm->SetSize(statstg.cbSize);
                            pStrmFrom->Release();
                        }
                        else
                        {
                            DOUT(TEXT("o2base/stdils/ConvertToMemoryStream CreateStreamOnHGlobal Failed!\r\n"));
                        }
                    }
                }
                if (!OK(r))
                {
                    GlobalFree(hgbl);
                }
            }
        }
    }

    if (!OK(r))
    {
        pStrm = pStrmFrom;
    }

    return pStrm;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\o2base\stdfact.cxx ===
//+---------------------------------------------------------------------
//
//  File:       stdfact.cxx
//
//  Contents:   Standard IClassFactory implementation
//
//  Classes:    StdClassFactory
//
//----------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::StdClassFactory, public
//
//  Synopsis:   Constructor for StdUnknown class
//
//----------------------------------------------------------------

StdClassFactory::StdClassFactory(void)
{
    _ulRefs = 0;
    _ulLocks = 0;
}

//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::AddRef, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP_(ULONG)
StdClassFactory::AddRef(void)
{
    return ++_ulRefs;
}


//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::Release, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP_(ULONG)
StdClassFactory::Release(void)
{
    Assert(_ulRefs > 0);
    --_ulRefs;

#if DBG
    if(_ulRefs == 0)
        DOUT(TEXT("StdClassFactory::Release _ulRefs == 0\r\n"));
#endif

    return _ulRefs;
}

//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::QueryInterface, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdClassFactory::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
#if DBG
    TCHAR achBuffer[256];
    wsprintf(achBuffer,
            TEXT("StdClassFactory::QueryInterface (%lx)\r\n"),
            riid.Data1);
    DOUT(achBuffer);
#endif

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        AddRef();
        *ppv = (LPCLASSFACTORY)this;
        return NOERROR;
    }
    *ppv = NULL;
    DOUT(TEXT("StdClassFactory::QueryInterface returning E_NOINTERFACE\r\n"));
    return E_NOINTERFACE;
}


//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::LockServer, public
//
//  Synopsis:   Method of IClassFactory interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdClassFactory::LockServer (BOOL fLock)
{
    if (fLock)
    {
        _ulLocks++;
    }
    else
    {
        Assert(_ulLocks > 0);
        _ulLocks--;
    }
    return NOERROR;
}

#ifdef DOCGEN
//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::CreateInstance, public
//
//  Synopsis:   Manufactures an instance of the class
//
//  Notes:      This pure virtual function must be overridden by the inheriting
//              class because the base class does not know what class to
//              instantiate.
//
//----------------------------------------------------------------

STDMETHODIMP
StdClassFactory::CreateInstance(LPUNKNOWN pUnkOuter,
        REFIID iid,
        LPVOID FAR* ppv) {};

//REVIEW: how to enforce ref counting of Class factory in object
// constructor/destructor?  Can we do this in a conjunction of StdUnknown
// with StdClassFactory.
#endif  // DOCGEN

//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::CanUnload, public
//
//  Synopsis:   Returns TRUE iff there are no extant instances of
//              this class, outstanding references on the class factory,
//              or locks on the class factory.
//
//  Notes:      This function is for use in the standard DllCanUnloadNow
//              function.
//
//----------------------------------------------------------------

BOOL
StdClassFactory::CanUnload(void)
{
    return _ulRefs == 0 && _ulLocks == 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\o2base\stdenum.cxx ===
//+---------------------------------------------------------------------
//
//  File:       stdenum.cxx
//
//  Contents:   Standard implementations of common enumerators
//
//----------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop
#include <limits.h>         // for UINT_MAX below

//
//  forward declarations
//

class StdEnumOLEVERB;
typedef StdEnumOLEVERB FAR* LPSTDENUMOLEVERB;

class StdEnumFORMATETC;
typedef StdEnumFORMATETC FAR* LPSTDENUMFORMATETC;

#if 1
class StdStaticEnum;
typedef StdStaticEnum FAR* LPSTDSTATICENUM;
#endif  // 0


//+---------------------------------------------------------------
//
//  Class:      StdEnumOLEVERB
//
//  Purpose:    Standard enumerator of OLEVERB tables
//
//---------------------------------------------------------------

class StdEnumOLEVERB: public IEnumOLEVERB
{
    friend HRESULT CreateOLEVERBEnum(LPOLEVERB, ULONG, LPENUMOLEVERB FAR*);

public:
    DECLARE_STANDARD_IUNKNOWN(StdEnumOLEVERB);

    // *** IEnumOLEVERB methods ***
    STDMETHOD(Next) (ULONG celt, LPOLEVERB rgelt, ULONG FAR* pceltFetched);
    STDMETHOD(Skip) (ULONG celt);
    STDMETHOD(Reset) (void);
    STDMETHOD(Clone) (IEnumOLEVERB FAR* FAR* ppenm);

private:
    StdEnumOLEVERB(LPOLEVERB pStart, ULONG cCount);
    ~StdEnumOLEVERB(void);

    LPOLEVERB _pStart;
    ULONG _cCount;
    ULONG _cCurrent;
};

//+---------------------------------------------------------------
//
//  Member:     StdEnumOLEVERB::StdEnumOLEVERB, private
//
//  Synopsis:   Constructor for StdEnumOLEVERB objects
//
//  Arguments:  [pStart] -- pointer to the beginning of the OLEVERB array
//              [cCount] -- the number of elements in the array
//
//  Notes:      OLEVERB enumerators should be constructed using the
//              CreateOLEVERBEnum function.
//
//----------------------------------------------------------------

StdEnumOLEVERB::StdEnumOLEVERB(LPOLEVERB pStart, ULONG cCount)
{
    _ulRefs = 1;
    _pStart = pStart;
    _cCount = cCount;
    _cCurrent = 0;
    DOUT(TEXT("StdEnumOLEVERB constructed.\r\n"));
}

//+---------------------------------------------------------------
//
//  Member:     StdEnumOLEVERB::~StdEnumOLEVERB, private
//
//  Synopsis:   Destructor for StdEnumOLEVERB objects
//
//  Notes:      Static enumerators should never be `deleted' but
//              instead IUnknown::Release'd.
//
//----------------------------------------------------------------

StdEnumOLEVERB::~StdEnumOLEVERB(void)
{
    DOUT(TEXT("StdEnumOLEVERB destructed.\r\n"));
}

IMPLEMENT_STANDARD_IUNKNOWN(StdEnumOLEVERB)

//+---------------------------------------------------------------
//
//  Member:     StdEnumOLEVERB::QueryInterface, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdEnumOLEVERB::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if (IsEqualIID(riid,IID_IUnknown) || IsEqualIID(riid,IID_IEnumOLEVERB))
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }
    DOUT(TEXT("StdEnumOLEVERB::QueryInterface E_NOINTERFACE\r\n"));
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Member:     StdEnumOLEVERB::Next
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdEnumOLEVERB::Next(ULONG celt,
        LPOLEVERB pArrayObjs,
        ULONG FAR* pceltFetched)
{
    /* skip ahead to primary verb */
    for (;_cCurrent <= _cCount; _cCurrent++)
    {
        LPOLEVERB pVerb = &_pStart[_cCurrent];
        if (pVerb->lVerb >= OLEIVERB_PRIMARY)
            break;
    }

    ULONG celtFetched = min(celt, _cCount-_cCurrent);
    for (ULONG i = 0; i < celtFetched; i++, _cCurrent++)
    {
        LPOLEVERB pVerb = &_pStart[_cCurrent];

        pArrayObjs[i] = *pVerb;
        if (pVerb->lpszVerbName!=NULL)
        {
            HRESULT r;
            r = TaskAllocString(pVerb->lpszVerbName,
                    &pArrayObjs[i].lpszVerbName);
            if (!OK(r))
                return r;
        }
    }

    if (pceltFetched != NULL)
    {
        *pceltFetched = celtFetched;
    }

    return ((celtFetched == celt) ? NOERROR : S_FALSE);
}

//+---------------------------------------------------------------
//
//  Member:     StdEnumOLEVERB::Skip
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdEnumOLEVERB::Skip(ULONG celt)
{
    _cCurrent += celt;
    if (_cCurrent >= _cCount)
    {
        _cCurrent = _cCount;
        return S_FALSE;
    }
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     StdEnumOLEVERB::Reset
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdEnumOLEVERB::Reset(void)
{
    _cCurrent = 0;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     StdEnumOLEVERB::Clone
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdEnumOLEVERB::Clone(LPENUMOLEVERB FAR* ppenm)
{
    HRESULT r = E_OUTOFMEMORY;
    //LPSTDENUMOLEVERB penum = new (NullOnFail) StdEnumOLEVERB(_pStart, _cCount);
    LPSTDENUMOLEVERB penum = new StdEnumOLEVERB(_pStart, _cCount);
    if (penum != NULL)
    {
        r = NOERROR;
        penum->_cCurrent = _cCurrent;
        *ppenm = penum;
    }
    else
    {
        DOUT(TEXT("o2base/StdEnumOLEVERB::Clone failed\r\n"));
    }
    return r;
}

//+---------------------------------------------------------------
//
//  Function:   CreateOLEVERBEnum, public
//
//  Synopsis:   Creates a standard enumerator over OLEVERB arrays
//
//  Arguments:  [pVerbs] -- pointer to the beginning of the OLEVERB array
//              [cVerbs] -- the number of elements in the array
//              [ppenum] -- where the enumerator is returned
//
//  Returns:    Success if the enumerator could be successfully created
//
//  Notes:      This function is typically used in the IOleObject::EnumVerbs
//              method implementation.
//
//----------------------------------------------------------------

HRESULT
CreateOLEVERBEnum(LPOLEVERB pVerbs, ULONG cVerbs, LPENUMOLEVERB FAR* ppenum)
{
    HRESULT r = E_OUTOFMEMORY;
    //LPSTDENUMOLEVERB penum = new (NullOnFail) StdEnumOLEVERB(pVerbs, cVerbs);
    LPSTDENUMOLEVERB penum = new StdEnumOLEVERB(pVerbs, cVerbs);
    if (penum != NULL)
    {
        r = NOERROR;
        *ppenum = penum;
    }
    else
    {
        DOUT(TEXT("o2base/stdenum/CreateOLEVERBEnum failed\r\n"));
    }
    return r;
}

//+---------------------------------------------------------------
//
//  Class:      StdEnumFORMATETC
//
//  Purpose:    Standard enumerator of FORMATETC tables
//
//---------------------------------------------------------------

class StdEnumFORMATETC: public IEnumFORMATETC
{
    friend HRESULT CreateFORMATETCEnum(LPFORMATETC, ULONG, LPENUMFORMATETC FAR*);
public:
    DECLARE_STANDARD_IUNKNOWN(StdEnumFORMATETC);

    // *** IEnumFORMATETC methods ***
    STDMETHOD(Next) (ULONG celt, LPFORMATETC rgelt, ULONG FAR* pceltFetched);
    STDMETHOD(Skip) (ULONG celt);
    STDMETHOD(Reset) (void);
    STDMETHOD(Clone) (IEnumFORMATETC FAR* FAR* ppenm);

private:
    StdEnumFORMATETC(LPFORMATETC pStart, ULONG cCount);
    ~StdEnumFORMATETC(void);

    LPFORMATETC _pStart;
    ULONG _cCount;
    ULONG _cCurrent;
};

//+---------------------------------------------------------------
//
//  Member:     StdEnumFORMATETC::StdEnumFORMATETC, private
//
//  Synopsis:   Constructor for StdEnumFORMATETC objects
//
//  Arguments:  [pStart] -- pointer to the beginning of the FORMATETC array
//              [cCount] -- the number of elements in the array
//
//  Notes:      Static enumerators should be constructed using the
//              CreateFORMATETCEnum function.
//
//----------------------------------------------------------------

StdEnumFORMATETC::StdEnumFORMATETC(LPFORMATETC pStart, ULONG cCount)
{
    _ulRefs = 1;
    _pStart = pStart;
    _cCount = cCount;
    _cCurrent = 0;
    DOUT(TEXT("StdEnumFORMATETC constructed.\r\n"));
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::~StdStaticEnum, private
//
//  Synopsis:   Destructor for StdStaticEnum objects
//
//  Notes:      Static enumerators should never be `deleted' but
//              instead IUnknown::Release'd.
//
//----------------------------------------------------------------

StdEnumFORMATETC::~StdEnumFORMATETC(void)
{
    DOUT(TEXT("StdEnumFORMATETC destructed.\r\n"));
}

IMPLEMENT_STANDARD_IUNKNOWN(StdEnumFORMATETC)

//+---------------------------------------------------------------
//
//  Member:     StdEnumFORMATETC::QueryInterface, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdEnumFORMATETC::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
#ifdef VERBOSE_DBG
    TCHAR achBuffer[256];
    wsprintf(achBuffer,
            TEXT("StdEnumFORMATETC::QueryInterface (%lx)\r\n"),
            riid.Data1);
    DOUT(achBuffer);
#endif //VERBOSE_DBG

    if (IsEqualIID(riid,IID_IUnknown) || IsEqualIID(riid,IID_IEnumFORMATETC))
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }

#if VERBOSE_DBG
    wsprintf(achBuffer,
            TEXT("StdEnumFORMATETC::QueryInterface returning E_NOINTERFACE for %lx\r\n"),
            riid.Data1);
    DOUT(achBuffer);
#endif //VERBOSE_DBG
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Member:     StdEnumFORMATETC::Next
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdEnumFORMATETC::Next(ULONG celt,
                        LPFORMATETC pArrayObjs,
                        ULONG FAR* pceltFetched)
{
    ULONG celtFetched = 0;

    if (_pStart == NULL)
        return S_FALSE;

    if (pceltFetched != NULL)
        *pceltFetched = 0L;

    if (pArrayObjs == NULL || _cCurrent >= _cCount)
        return S_FALSE;
    
    while ( _cCurrent < _cCount && celt > 0 )
    {
        LPFORMATETC pFormat = &_pStart[_cCurrent];

        // deep copy the FORMATETC structure
        
        *pArrayObjs = *pFormat;
        if (pFormat->ptd == DVTARGETIGNORE )
            pArrayObjs->ptd = NULL;
        
        if (pArrayObjs->ptd != NULL)
        {
            HRESULT r = TaskAllocMem(sizeof(DVTARGETDEVICE),
                (LPVOID FAR*)&pArrayObjs->ptd);
            if (OK(r))
            {
                *(pArrayObjs->ptd) = *(pFormat->ptd);
            }
        }
        pArrayObjs++;
        _cCurrent++;
        celtFetched++;
        celt--;
    }

    if (pceltFetched != NULL)
    {
        *pceltFetched = celtFetched - celt;
    }
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     StdEnumFORMATETC::Skip
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdEnumFORMATETC::Skip(ULONG celt)
{
    _cCurrent += celt;
    if (_cCurrent >= _cCount)
    {
        _cCurrent = _cCount;
        return S_FALSE;
    }
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     StdEnumFORMATETC::Reset
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdEnumFORMATETC::Reset(void)
{
    _cCurrent = 0;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     StdEnumFORMATETC::Clone
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdEnumFORMATETC::Clone(LPENUMFORMATETC FAR* ppenm)
{
    HRESULT r = E_OUTOFMEMORY;;
    LPSTDENUMFORMATETC penum = new StdEnumFORMATETC(_pStart, _cCount);
    if (penum != NULL)
    {
        r = NOERROR;
        penum->_cCurrent = _cCurrent;
        *ppenm = penum;
    }
    else
    {
        DOUT(TEXT("o2base/StdEnumFORMATETC::Clone failed\r\n"));
    }
    return r;
}

//+---------------------------------------------------------------
//
//  Function:   CreateFORMATETCEnum, public
//
//  Synopsis:   Creates a standard enumerator over FORMATETC arrays
//
//  Arguments:  [pFormats] -- pointer to the beginning of the FORMATETC array
//              [cFormats] -- the number of elements in the array
//              [ppenum] -- where the enumerator is returned
//
//  Returns:    Success if the enumerator could be successfully created
//
//  Notes:      This function is typically used in the IDataObject::EnumFormatetc
//              method implementation.
//
//----------------------------------------------------------------

HRESULT
CreateFORMATETCEnum(LPFORMATETC pFormats,
                    ULONG cFormats,
                    LPENUMFORMATETC FAR* ppenum)
{
    HRESULT r;
    LPSTDENUMFORMATETC penum = new StdEnumFORMATETC(pFormats, cFormats);
    if (penum == NULL)
    {
        DOUT(TEXT("o2base/stdenum/CreateFORMATETCEnum E_OUTOFMEMORY\r\n"));
        r = E_OUTOFMEMORY;
    }
    else
    {
        *ppenum = penum;
        r = NOERROR;
    }
    return r;
}

#if 1   // this maybe useful later but is not currently used.

//+---------------------------------------------------------------
//
//  Class:      StdStaticEnum
//
//  Purpose:    Enumerates over a static array
//
//  Notes:      This may not be used to enumerate over structures
//              that are "deep".  For instance, it cannot be used
//              to enumerate over an array of FORMATETCs because such
//              an enumerator needs to deep copy the ptd field
//              and the enumerator client frees these allocated ptd.
//              Similarly for the OLEVERB structure where the verb
//              name string must be deep copied.
//
//---------------------------------------------------------------

class StdStaticEnum: public IUnknown
{
    friend HRESULT CreateStaticEnum(REFIID, LPVOID, ULONG, ULONG, LPVOID FAR*);

public:
    DECLARE_STANDARD_IUNKNOWN(StdStaticEnum);

    //*** IEnumerator methods ***
    STDMETHOD(Next) (ULONG celt, LPVOID pArrayObjs, ULONG FAR* pceltFetched);
    STDMETHOD(Skip) (ULONG celt);
    STDMETHOD(Reset) (void);
    STDMETHOD(Clone) (LPSTDSTATICENUM FAR* ppenm);

private:
    // constructor/destructor
    StdStaticEnum(REFIID riid, LPVOID pStart, ULONG cSize, ULONG cCount);
    ~StdStaticEnum(void);

    IID _iid;
    LPVOID _pStart;
    ULONG _cSize;
    ULONG _cCount;
    ULONG _cCurrent;
};

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::StdStaticEnum, private
//
//  Synopsis:   Constructor for StdStaticEnum objects
//
//  Arguments:  [riid] -- the enumerator interface that this class is
//                          "pretending" to be.
//              [pStart] -- pointer to the beginning of the static array
//              [cSize] -- the size of the elements of the array
//              [cCount] -- the number of elements in the array
//
//  Notes:      Static enumerators should be constructed using the
//              CreateStaticEnum function.
//
//----------------------------------------------------------------

StdStaticEnum::StdStaticEnum(REFIID riid,
        LPVOID pStart,
        ULONG cSize,
        ULONG cCount)
{
    _ulRefs = 1;
    _iid = riid;
    _pStart = pStart;
    _cSize = cSize;
    _cCount = cCount;
    _cCurrent = 0;
    DOUT(TEXT("StdStaticEnum constructed.\r\n"));
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::~StdStaticEnum, private
//
//  Synopsis:   Destructor for StdStaticEnum objects
//
//  Notes:      Static enumerators should never be `deleted' but
//              instead IUnknown::Release'd.
//
//----------------------------------------------------------------

StdStaticEnum::~StdStaticEnum(void)
{
    DOUT(TEXT("StdStaticEnum destructed.\r\n"));
}

IMPLEMENT_STANDARD_IUNKNOWN(StdStaticEnum);

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::QueryInterface, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if (IsEqualIID(riid,IID_IUnknown) || IsEqualIID(riid,_iid))
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }
    DOUT(TEXT("StdStaticEnum::QueryInterface E_NOINTERFACE\r\n"));
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::Next
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::Next(ULONG celt,
        LPVOID pArrayObjs,
        ULONG FAR* pceltFetched)
{
    ULONG celtFetched = min(celt, _cCount-_cCurrent);

    // calculate the number of bytes to copy
    if (celtFetched != 0 && _cSize > (UINT_MAX/celtFetched))
    {
        DOUT(TEXT("StdStaticEnum::Next E_FAIL\r\n"));
        return E_FAIL;         // overflow!
    }

    UINT count = (UINT) (celtFetched*_cSize);
    _fmemcpy(pArrayObjs, (LPBYTE)_pStart+_cCurrent*_cSize, count);
    _cCurrent += celtFetched;
    if (pceltFetched != NULL)
    {
        *pceltFetched = celtFetched;
    }
    return ((celtFetched == celt) ? NOERROR : S_FALSE);
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::Skip
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::Skip(ULONG celt)
{
    _cCurrent += celt;
    if (_cCurrent >= _cCount)
    {
        _cCurrent = _cCount;
        return S_FALSE;
    }
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::Reset
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::Reset(void)
{
    _cCurrent = 0;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::Clone
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::Clone(LPSTDSTATICENUM FAR* ppenm)
{
    HRESULT r;
    //LPSTDSTATICENUM penum = new (NullOnFail) StdStaticEnum(
    LPSTDSTATICENUM penum = new StdStaticEnum(
                                                    _iid,
                                                    _pStart,
                                                    _cSize,
                                                    _cCount);
    if (penum == NULL)
    {
        DOUT(TEXT("o2base/StdStaticEnum::Clone failed\r\n"));
        r = E_OUTOFMEMORY;
    }
    else
    {
        penum->_cCurrent = _cCurrent;
        *ppenm = penum;
        r = NOERROR;
    }
    return r;
}

//+---------------------------------------------------------------
//
//  Function:   CreateStaticEnum, public
//
//  Synopsis:   Creates a standard enumerator over static arrays
//
//  Arguments:  [riid] -- the enumerator interface that this class is
//                          "pretending" to be.
//              [pStart] -- pointer to the beginning of the static array
//              [cSize] -- the size of the elements of the array
//              [cCount] -- the number of elements in the array
//              [ppenum] -- where the enumerator is returned
//
//  Returns:    Success if the enumerator could be successfully created
//
//----------------------------------------------------------------

HRESULT
CreateStaticEnum(REFIID riid,
        LPVOID pStart,
        ULONG cSize,
        ULONG cCount,
        LPVOID FAR* ppenum)
{
    HRESULT r;
    //LPSTDSTATICENUM penum = new (NullOnFail) StdStaticEnum(
    LPSTDSTATICENUM penum = new StdStaticEnum(
                                                    riid,
                                                    pStart,
                                                    cSize,
                                                    cCount);
    if (penum == NULL)
    {
        DOUT(TEXT("o2base/stdenum/CreateStaticEnum failed\r\n"));
        r = E_OUTOFMEMORY;
    }
    else
    {
        *ppenum = penum;
        r = NOERROR;
    }
    return r;
}

#endif // 0

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\o2base\vwadvhld.cxx ===
//+---------------------------------------------------------------------
//
//   File:       vwadvhld.cxx
//
//   Contents:   Miscellaneous OLE helper routines
//
//------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//+---------------------------------------------------------------
//
//  Member:     ViewAdviseHolder::ViewAdviseHolder, protected
//
//  Synopsis:   Constructor for ViewAdviseHolder class
//
//----------------------------------------------------------------

ViewAdviseHolder::ViewAdviseHolder()
{
    _refs = 1;
    _pAdvSink = NULL;
    _dwAdviseAspects = 0;
    _dwAdviseFlags = 0;

}

//+---------------------------------------------------------------
//
//  Member:     ViewAdviseHolder::~ViewAdviseHolder, protected
//
//  Synopsis:   Destructor for ViewAdviseHolder class
//
//----------------------------------------------------------------

ViewAdviseHolder::~ViewAdviseHolder()
{
    if (_pAdvSink != NULL)
        _pAdvSink->Release();
}

//+---------------------------------------------------------------
//
//  Member:     ViewAdviseHolder::QueryInterface, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
ViewAdviseHolder::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if (IsEqualIID(riid,IID_IUnknown))
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }
    DOUT(TEXT("ViewAdviseHolder::QueryInterface E_NOINTERFACE\r\n"));
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Member:     ViewAdviseHolder:AddRef, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP_(ULONG)
ViewAdviseHolder::AddRef(void)
{
    return _refs++;
}

//+---------------------------------------------------------------
//
//  Member:     ViewAdviseHolder::Release, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP_(ULONG)
ViewAdviseHolder::Release(void)
{
    if (--_refs == 0)
        delete this;
    return (_refs);
}

//+---------------------------------------------------------------
//
//  Member:     ViewAdviseHolder::SetAdvise, public
//
//  Synopsis:   Places an advise in the advise holder
//
//  Arguments:  The arguments are the same as to IViewObject::SetAdvise
//
//  Notes:      IViewObject objects using this advise holder delegate
//              their IViewObject::SetAdvise methods to this method.
//
//----------------------------------------------------------------

STDMETHODIMP
ViewAdviseHolder::SetAdvise(DWORD aspects, DWORD advf, LPADVISESINK pAdvSink)
{
    if (_pAdvSink != NULL)
        _pAdvSink->Release();

    _pAdvSink = pAdvSink;

    if (_pAdvSink != NULL)
        _pAdvSink->AddRef();

    _dwAdviseAspects = aspects;
    _dwAdviseFlags = advf;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     ViewAdviseHolder::GetAdvise, public
//
//  Synopsis:   Reports on an advise in the advise holder
//
//  Arguments:  The arguments are the same as to IViewObject::GetAdvise
//
//  Notes:      IViewObject objects using this advise holder delegate
//              their IViewObject::GetAdvise methods to this method.
//
//----------------------------------------------------------------

STDMETHODIMP
ViewAdviseHolder::GetAdvise(DWORD FAR* pAspects,
        DWORD FAR* pAdvf,
        LPADVISESINK FAR* ppAdvSink)
{
    *ppAdvSink = _pAdvSink;
    *pAspects = _dwAdviseAspects;
    *pAdvf = _dwAdviseFlags;
    return NOERROR;
    // review: is this the right return code if no advise has been set?
}

//+---------------------------------------------------------------
//
//  Member:     ViewAdviseHolder::SendOnViewChange, public
//
//  Synopsis:   Sends an OnViewChange notification to the registered advise.
//
//  Arguments:  [dwAspect] -- the display aspect that has changed
//
//  Notes:      The client IViewObject should call this method whenever
//              its view has changed.
//
//----------------------------------------------------------------

void ViewAdviseHolder::SendOnViewChange(DWORD dwAspect)
{
    if (_pAdvSink != NULL && (dwAspect&_dwAdviseAspects) != 0)
        _pAdvSink->OnViewChange(dwAspect, -1);
}

//+---------------------------------------------------------------
//
//  Function:   CreateViewAdviseHolder
//
//  Synopsis:   Creates a ViewAdviseHolder object
//
//  Arguments:  [ppViewHolder] -- place where the view holder is returned
//
//  Returns:    Success if the advise holder was created
//
//  Notes:      This function is directly analogous to the OLE provided
//              CreateDataAdviseHolder
//
//----------------------------------------------------------------

HRESULT
CreateViewAdviseHolder(LPVIEWADVISEHOLDER FAR* ppViewHolder)
{
    //LPVIEWADVISEHOLDER pViewAdvHolder = new (NullOnFail) ViewAdviseHolder;
    LPVIEWADVISEHOLDER pViewAdvHolder = new ViewAdviseHolder;
    *ppViewHolder = pViewAdvHolder;

    if (pViewAdvHolder == NULL)
    {
        DOUT(TEXT("o2base/vwadvhld/CreateViewAdviseHolder failed\r\n"));
        return E_OUTOFMEMORY;
    }
    else
        return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\o2base\wutils.cxx ===
//+---------------------------------------------------------------------
//
//  File:       wutils.cxx
//
//  Contents:   Windows helper functions
//
//----------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//+---------------------------------------------------------------
//
//  Function:   LoadResourceData
//
//  Synopsis:   Loads a resource RCDATA block into a buffer
//
//  Arguments:  [hinst] -- instance of the module with the resource
//              [lpstrId] -- the identifier of the RCDATA resource
//              [lpvBuf] -- the buffer where the resource is to be loaded
//              [cbBuf] -- the number of bytes of resource data to load
//
//  Returns:    lpvBuf if the resource was successfully loaded, NULL otherwise
//
//  Notes:      This function combines Windows' FindResource, LoadResource,
//              LockResource, and a memory copy.
//
//----------------------------------------------------------------

LPVOID
LoadResourceData(HINSTANCE hinst,
        LPCTSTR lpstrId,
        LPVOID lpvBuf,
        int cbBuf)
{
    LPVOID lpvRet = NULL;
    HRSRC hrsrc = FindResource(hinst, lpstrId, RT_RCDATA);
    if (hrsrc != NULL)
    {
        HGLOBAL hgbl = LoadResource(hinst, hrsrc);
        if (hgbl != NULL)
        {
            LPVOID lpvSrc = LockResource(hgbl);
            if (lpvSrc != NULL)
            {
                lpvRet = _fmemcpy(lpvBuf, lpvSrc, cbBuf);
                UnlockResource(hgbl);
            }
            FreeResource(hgbl);
        }
    }
    return lpvRet;
}

//+---------------------------------------------------------------
//
//  Function:   GetChildWindowRect
//
//  Synopsis:   Gets the rectangle of the child window in
//              its parent window coordinates
//
//  Arguments:  [hwndChild] -- the child window
//              [lprect]  -- the rectangle to fill with childs coordinates
//
//  Notes:      This function gets the screen coordinates of the child
//              then maps them into the client coordinates of its parent.
//
//----------------------------------------------------------------

void
GetChildWindowRect(HWND hwndChild, LPRECT lprect)
{
    HWND hwndParent;
    POINT ptUpperLeft;
    POINT ptLowerRight;

    // get the screen coordinates of the child window
    GetWindowRect(hwndChild, lprect);

    // get the parent window of the child
    if ((hwndParent = GetParent(hwndChild)) != NULL)
    {
        // map the screen coordinates to client coordinates
        ptUpperLeft.x   = lprect->left;
        ptUpperLeft.y   = lprect->top;
        ptLowerRight.x  = lprect->right;
        ptLowerRight.y  = lprect->bottom;

        ScreenToClient(hwndParent, &ptUpperLeft);
        ScreenToClient(hwndParent, &ptLowerRight);

        SetRect(lprect,
                ptUpperLeft.x,
                ptUpperLeft.y,
                ptLowerRight.x,
                ptLowerRight.y);
    }
}

//+---------------------------------------------------------------
//
//  Function:   SizeClientRect
//
//  Synopsis:   Resizes the window so its client size is a specified
//              area.  Can also move the window so its client region
//              covers a specified rectangle.
//
//  Arguments:  [hwnd] -- the window to resize/move
//              [rc] -- rectangle indicating size and possibly position of
//                      client area
//              [fMove] -- flag indicating resize-only or move
//
//  Notes:      This function uses SetWindowPos which does not handle
//              accurately the case where the menu wraps to more than one line
//              as a result of the resize.
//
//----------------------------------------------------------------

void
SizeClientRect(HWND hwnd, RECT& rc, BOOL fMove)
{
    AdjustWindowRect(&rc,
            GetWindowLong(hwnd, GWL_STYLE),
            GetMenu(hwnd) != NULL);
    SetWindowPos(hwnd,
            NULL,
            rc.left,
            rc.top,
            rc.right-rc.left,
            rc.bottom-rc.top,
            SWP_NOZORDER|SWP_NOACTIVATE | (fMove ? 0 : SWP_NOMOVE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\soundrec\convert.c ===
/* (C) Copyright Microsoft Corporation 1991-1994.  All Rights Reserved */
/* convert.c
 *
 * conversion utilites.
 */
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <commctrl.h>
#include <msacm.h>
#include <commdlg.h>
#include <dlgs.h>
#include <convert.h>
#include <msacmdlg.h>

#include "soundrec.h"
#ifdef CHICAGO
#include "helpids.h"
#endif

#define STRSAFE_LIB
#include <strsafe.h>

BOOL gfBreakOfDeath;
/*
 **/
LPTSTR SoundRec_GetFormatName(
    LPWAVEFORMATEX pwfx)
{
    ACMFORMATTAGDETAILS aftd;
    ACMFORMATDETAILS    afd;
    const TCHAR         szFormat[] = TEXT("%s %s");
    LPTSTR              lpstr;
    UINT                cbstr;
	HRESULT				hr;

    ZeroMemory(&aftd, sizeof(ACMFORMATTAGDETAILS));    
    aftd.cbStruct = sizeof(ACMFORMATTAGDETAILS);
    aftd.dwFormatTag = pwfx->wFormatTag;

    if (MMSYSERR_NOERROR != acmFormatTagDetails( NULL
                                                 , &aftd
                                                 , ACM_FORMATTAGDETAILSF_FORMATTAG))
    {
        aftd.szFormatTag[0] = 0;
    }

    ZeroMemory(&afd, sizeof(ACMFORMATDETAILS));
    afd.cbStruct = sizeof(ACMFORMATDETAILS);
    afd.pwfx = pwfx;
    afd.dwFormatTag = pwfx->wFormatTag;

    afd.cbwfx = sizeof(WAVEFORMATEX);
    if (pwfx->wFormatTag != WAVE_FORMAT_PCM)
        afd.cbwfx += pwfx->cbSize;

    if (MMSYSERR_NOERROR != acmFormatDetails( NULL
                                              , &afd
                                              , ACM_FORMATDETAILSF_FORMAT))
    {
        afd.szFormat[0] = 0;
    }

    cbstr = sizeof(LPTSTR) * ( lstrlen(aftd.szFormatTag) + lstrlen(afd.szFormat) + lstrlen(szFormat));
    lpstr = (LPTSTR) GlobalAllocPtr(GHND, cbstr);
    if (lpstr)
	{
        hr = StringCbPrintf(lpstr, cbstr, szFormat, aftd.szFormatTag, afd.szFormat);
		Assert( hr == S_OK );
	}
    return lpstr;
}

/* 
 * SaveAsHookProc
 *
 * This is a hook proc for the Save As common dialog to support conversion
 * upon save.
 **/
UINT_PTR CALLBACK SaveAsHookProc(
    HWND    hdlg,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam)
{
#ifdef CHICAGO
    int DlgItem;
    static const DWORD aHelpIds[] = {
        IDC_TXT_FORMAT,         IDH_SOUNDREC_CHANGE,
        IDC_CONVERTTO,          IDH_SOUNDREC_CHANGE,
        IDC_CONVERT_TO,         IDH_SOUNDREC_CHANGE,
        0,                      0
    };
    extern DWORD aChooserHelpIds[];
    extern UINT  guChooserContextMenu;
    extern UINT  guChooserContextHelp;
    
    //
    //  Handle context-sensitive help messages from acm dialog
    //
    if( msg == guChooserContextMenu )
    {
        WinHelp( (HWND)wParam, NULL, HELP_CONTEXTMENU, 
            (UINT_PTR)(LPSTR)aChooserHelpIds );
        return TRUE;
    }
    else if( msg == guChooserContextHelp )
    {
        WinHelp( ((LPHELPINFO)lParam)->hItemHandle, NULL,
            HELP_WM_HELP, (UINT_PTR)(LPSTR)aChooserHelpIds );
        return TRUE;
    }
    
#endif    
    
    switch (msg)
    {
#ifdef CHICAGO
        case WM_CONTEXTMENU:
            DlgItem = GetDlgCtrlID((HWND)wParam);
            
            //
            // Only process the id's we are responsible for
            //
            if (DlgItem != IDC_CONVERTTO && DlgItem != IDC_CONVERT_TO && DlgItem != IDC_TXT_FORMAT)
                break;

            WinHelp((HWND)wParam, gachHelpFile, HELP_CONTEXTMENU, 
                (UINT_PTR)(LPSTR)aHelpIds);

            return TRUE;

        case WM_HELP:
        {
            LPHELPINFO lphi = (LPVOID) lParam;

            //
            // Only process the id's we are responsible for
            //
            DlgItem = GetDlgCtrlID(lphi->hItemHandle);
            if (DlgItem != IDC_CONVERTTO && DlgItem != IDC_CONVERT_TO && DlgItem != IDC_TXT_FORMAT)
                break;
            WinHelp (lphi->hItemHandle, gachHelpFile, HELP_WM_HELP,
                    (UINT_PTR) (LPSTR) aHelpIds);
            return TRUE;
        }
#endif

        case WM_INITDIALOG:
        {
            LPTSTR          lpszFormat;
            PWAVEFORMATEX * ppwfx;
                        
            // passed in through lCustData
            ppwfx = (PWAVEFORMATEX *)((OPENFILENAME *)(LPVOID)lParam)->lCustData;

            SetProp(hdlg,  TEXT("DATA"), (HANDLE)ppwfx);

            lpszFormat = SoundRec_GetFormatName(gpWaveFormat);
            if (lpszFormat)
            {
                SetDlgItemText(hdlg, IDC_CONVERT_TO, lpszFormat);
                SetDlgItemText(hdlg, IDC_CONVERT_FROM, lpszFormat);
                GlobalFreePtr(lpszFormat);
            }
            return FALSE;
        }
            
        case WM_COMMAND:
        {
            PWAVEFORMATEX *ppwfx = (PWAVEFORMATEX *)GetProp(hdlg, TEXT("DATA"));
            int id = GET_WM_COMMAND_ID(wParam, lParam);
            switch (id)
            {
                case IDC_CONVERTTO:
                {
                    PWAVEFORMATEX pwfxNew = NULL;
                    if (ChooseDestinationFormat(ghInst
                                                ,hdlg
                                                ,NULL
                                                ,&pwfxNew
                                                ,0L) == MMSYSERR_NOERROR)
                    {
                        LPTSTR lpszFormat;
                        if (*ppwfx)
                            GlobalFreePtr(*ppwfx);

                        //
                        // set string name
                        //
                        lpszFormat = SoundRec_GetFormatName(pwfxNew);
                        if (lpszFormat)
                        {
                            SetDlgItemText(hdlg, IDC_CONVERT_TO, lpszFormat);
                            GlobalFreePtr(lpszFormat);
                        }
                        //
                        // do something
                        // 
                        *ppwfx = pwfxNew;
                    }
                    return TRUE;
                }
                default:
                    break;
            }
            break;
        }

        case WM_DESTROY:
            RemoveProp(hdlg, TEXT("DATA"));
            break;

        default:
            break;
    }
    return FALSE;
}

/*
 * Launches the chooser dialog for changing the destination format.
 */
MMRESULT FAR PASCAL
ChooseDestinationFormat(
    HINSTANCE       hInst,
    HWND            hwndParent,
    PWAVEFORMATEX   pwfxIn,
    PWAVEFORMATEX   *ppwfxOut,
    DWORD           fdwEnum)
{
    ACMFORMATCHOOSE     cwf;
    MMRESULT            mmr;
    LPWAVEFORMATEX      pwfx;
    DWORD               dwMaxFormatSize;
    
    mmr = acmMetrics(NULL
                     , ACM_METRIC_MAX_SIZE_FORMAT
                     , (LPVOID)&dwMaxFormatSize);

    if (mmr != MMSYSERR_NOERROR)
        return mmr;
    
    pwfx = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, (UINT)dwMaxFormatSize);
    if (pwfx == NULL)
        return MMSYSERR_NOMEM;
    
    memset(&cwf, 0, sizeof(cwf));
    
    cwf.cbStruct    = sizeof(cwf);
    cwf.hwndOwner   = hwndParent;
    cwf.fdwStyle    = 0L;

    cwf.fdwEnum     = 0L;           // all formats!
    cwf.pwfxEnum    = NULL;         // all formats!
    
    if (fdwEnum)
    {
        cwf.fdwEnum     = fdwEnum;
        cwf.pwfxEnum    = pwfxIn;
    }
    
    cwf.pwfx        = (LPWAVEFORMATEX)pwfx;
    cwf.cbwfx       = dwMaxFormatSize;

#ifdef CHICAGO
    cwf.fdwStyle    |= ACMFORMATCHOOSE_STYLEF_CONTEXTHELP;
#endif

    mmr = acmFormatChoose(&cwf);
    
    if (mmr == MMSYSERR_NOERROR)
        *ppwfxOut = pwfx;
    else
    {
        *ppwfxOut = NULL;
        GlobalFreePtr(pwfx);
    }
    return mmr;
    
}
#ifndef WM_APP
#define WM_APP                          0x8000
#endif

#define MYWM_CANCEL      (WM_APP+0)
#define MYWM_PROGRESS    (WM_APP+1)

/* Update a progress dialog
 */
BOOL
ProgressUpdate (
    PPROGRESS       pPrg,
    DWORD           dwCompleted)
{
    DWORD dwDone;
    BOOL  fCancel;

    if (pPrg == NULL)
        return TRUE;

    dwDone = (dwCompleted * pPrg->dwTotal) / 100L + pPrg->dwComplete;

    if (!IsWindow(pPrg->hPrg))
        return FALSE;
        
    SendMessage( pPrg->hPrg, MYWM_CANCEL, (WPARAM)&fCancel, 0L);
    if (fCancel)
    {
        return FALSE;
    }

    PostMessage( pPrg->hPrg, MYWM_PROGRESS, (WPARAM)dwDone, 0L);
    return TRUE;
}


//
// should support a file handle as well.
//

typedef struct tConvertParam {
    PWAVEFORMATEX   pwfxSrc;        // pwfx specifying source format
    DWORD           cbSrc;          // size of the source buffer
    LPBYTE          pbSrc;          // source buffer
    PWAVEFORMATEX   pwfxDst;        // pwfx specifying dest format
    DWORD *         pcbDst;         // return size of the dest buffer
    LPBYTE *        ppbDst;         // dest buffer
    DWORD           cBlks;          // number of blocks
    PROGRESS        Prg;            // progress update
    MMRESULT        mmr;            // MMSYSERR result
    HANDLE          hThread;        // private
} ConvertParam, *PConvertParam;

/*
 * */
DWORD ConvertThreadProc(LPVOID lpv)
{
    PConvertParam pcp = (PConvertParam)lpv;
    MMRESULT mmr;

    mmr = ConvertMultipleFormats(pcp->pwfxSrc
                                 , pcp->cbSrc
                                 , pcp->pbSrc
                                 , pcp->pwfxDst
                                 , pcp->pcbDst
                                 , pcp->ppbDst
                                 , pcp->cBlks
                                 , &pcp->Prg);

    pcp->mmr = mmr;
    PostMessage(pcp->Prg.hPrg, WM_CLOSE, 0, 0);
    
    return 0;   // end of thread! 
}

static BOOL gfCancel = FALSE;

/*
 * Progress_OnCommand
 * */
void Progress_OnCommand(
    HWND    hdlg,
    int     id,
    HWND    hctl,
    UINT    unotify)
{
    switch (id)
    {
        case IDCANCEL:
            gfCancel = TRUE;
            EndDialog(hdlg, FALSE);
            break;
            
        default:
            break;
    }
}

/*
 * Progress_Proc
 * */
INT_PTR CALLBACK
Progress_Proc(
    HWND        hdlg,
    UINT        umsg,
    WPARAM      wparam,
    LPARAM      lparam)
{
    switch (umsg)
    {
        case WM_INITDIALOG:
        {
            HANDLE          hThread;
            PConvertParam   pcp = (PConvertParam)(LPVOID)lparam;
            HWND            hprg;
            DWORD           thid;
            LPTSTR          lpsz;
            
            hprg = GetDlgItem(hdlg, IDC_PROGRESSBAR);
            
            SendMessage(hprg, PBM_SETRANGE, 0, MAKELONG(0, 100));
            SendMessage(hprg, PBM_SETPOS, 0, 0);

            SetProp(hdlg,  TEXT("DATA"), (HANDLE)pcp);
            pcp->Prg.hPrg    = hdlg;
            pcp->Prg.dwTotal = 100;
            gfCancel         = FALSE;
            
            lpsz = SoundRec_GetFormatName(pcp->pwfxSrc);
            if (lpsz)
            {
                SetDlgItemText(hdlg, IDC_CONVERT_FROM, lpsz);
                GlobalFreePtr(lpsz);
            }
            
            lpsz = SoundRec_GetFormatName(pcp->pwfxDst);
            if (lpsz)
            {
                SetDlgItemText(hdlg, IDC_CONVERT_TO, lpsz);
                GlobalFreePtr(lpsz);
            }
            
            hThread = CreateThread( NULL        // no special security 
                                    , 0           // default stack size 
                                    , (LPTHREAD_START_ROUTINE)ConvertThreadProc
                                    , (LPVOID)pcp
                                    , 0           // start running at once 
                                    , &thid );
    
            pcp->hThread = hThread;
            break;
        }
        
        case WM_COMMAND:
            HANDLE_WM_COMMAND(hdlg, wparam, lparam, Progress_OnCommand);
            break;
            
        case MYWM_CANCEL:
        {
            BOOL *pf = (BOOL *)wparam;
            if (pf)
                *pf = gfCancel;
            break;
        }

        case MYWM_PROGRESS:
        {
            HWND hprg = GetDlgItem(hdlg, IDC_PROGRESSBAR);
            SendMessage(hprg, PBM_SETPOS, wparam, 0);
            break;
        }

        case WM_DESTROY:
        {
            PConvertParam pcp = (ConvertParam *)GetProp(hdlg, TEXT("DATA"));
            if (pcp)
            {
                //
                // Make sure the thread exits
                //
                if (pcp->hThread)
                {
                    WaitForSingleObject(pcp->hThread, 1000);
                    CloseHandle(pcp->hThread);
                    pcp->hThread = NULL;
                }
                RemoveProp(hdlg, TEXT("DATA"));
            }
            break;
        }
            
        default:
            break;
    }
    return FALSE;
}

/* Generic single step conversion.
 */
MMRESULT
ConvertFormatDialog(
    HWND            hParent,
    PWAVEFORMATEX   pwfxSrc,        // pwfx specifying source format
    DWORD           cbSrc,          // size of the source buffer
    LPBYTE          pbSrc,          // source buffer
    PWAVEFORMATEX   pwfxDst,        // pwfx specifying dest format
    DWORD *         pcbDst,         // return size of the dest buffer
    LPBYTE *        ppbDst,         // dest buffer
    DWORD           cBlks,          // number of blocks
    PPROGRESS       pPrg)           // progress update
{
    ConvertParam    cp;

    *pcbDst     = 0;
    *ppbDst     = NULL;
    
    if (cbSrc == 0)
        return MMSYSERR_NOERROR;
        
    cp.pwfxSrc  = pwfxSrc;
    cp.cbSrc    = cbSrc;
    cp.pbSrc    = pbSrc;
    cp.pwfxDst  = pwfxDst;
    cp.pcbDst   = pcbDst;
    cp.ppbDst   = ppbDst;
    cp.cBlks    = cBlks;
    cp.mmr      = MMSYSERR_ERROR;    // fail on abnormal thread termination!
    cp.hThread  = NULL;

    DialogBoxParam(ghInst
                 , MAKEINTRESOURCE(IDD_CONVERTING)
                 , hParent
                 , Progress_Proc
                 , (LPARAM)(LPVOID)&cp);
    return cp.mmr;
}

#if DBG
void DumpASH(
             MMRESULT mmr,
             ACMSTREAMHEADER *pash)
{
    TCHAR sz[256];
	HRESULT hr;

    hr = StringCchPrintf(sz,SIZEOF(sz),TEXT("mmr = %lx\r\n"), mmr);
	Assert( hr == S_OK );
    OutputDebugString(sz);

    hr = StringCchPrintf(sz,SIZEOF(sz),TEXT("pash is %s\r\n"),IsBadWritePtr(pash, pash->cbStruct)?TEXT("bad"):TEXT("good"));
	Assert( hr == S_OK );
    OutputDebugString(sz);

    OutputDebugString(TEXT("ACMSTREAMHEADER {\r\n"));
    hr = StringCchPrintf(sz,SIZEOF(sz),TEXT("ash.cbStruct       = %lx\r\n"),pash->cbStruct);
	Assert( hr == S_OK );
    OutputDebugString(sz);

    hr = StringCchPrintf(sz,SIZEOF(sz),TEXT("ash.fdwStatus      = %lx\r\n"),pash->fdwStatus);
	Assert( hr == S_OK );
    OutputDebugString(sz);

    hr = StringCchPrintf(sz,SIZEOF(sz),TEXT("ash.pbSrc          = %lx\r\n"),pash->pbSrc);
	Assert( hr == S_OK );
    OutputDebugString(sz);

    hr = StringCchPrintf(sz,SIZEOF(sz),TEXT("ash.cbSrcLength    = %lx\r\n"),pash->cbSrcLength);
	Assert( hr == S_OK );
    OutputDebugString(sz);
    
    hr = StringCchPrintf(sz,SIZEOF(sz),TEXT("pbSrc is %s\r\n"),IsBadWritePtr(pash->pbSrc, pash->cbSrcLength)?TEXT("bad"):TEXT("good"));
	Assert( hr == S_OK );
    OutputDebugString(sz);
    
    hr = StringCchPrintf(sz,SIZEOF(sz),TEXT("ash.cbSrcLengthUsed= %lx\r\n"),pash->cbSrcLengthUsed);
	Assert( hr == S_OK );
    OutputDebugString(sz);

    hr = StringCchPrintf(sz,SIZEOF(sz),TEXT("ash.pbDst          = %lx\r\n"),pash->pbDst);
	Assert( hr == S_OK );
    OutputDebugString(sz);
    
    hr = StringCchPrintf(sz,SIZEOF(sz),TEXT("ash.cbDstLength    = %lx\r\n"),pash->cbDstLength);
	Assert( hr == S_OK );
    OutputDebugString(sz);
    
    hr = StringCchPrintf(sz,SIZEOF(sz),TEXT("pbDst is %s\r\n"),IsBadWritePtr(pash->pbDst, pash->cbDstLength)?TEXT("bad"):TEXT("good"));
	Assert( hr == S_OK );
    OutputDebugString(sz);
    
    hr = StringCchPrintf(sz,SIZEOF(sz),TEXT("ash.cbDstLengthUsed= %lx\r\n"),pash->cbDstLengthUsed);
	Assert( hr == S_OK );
    OutputDebugString(sz);
    
    OutputDebugString(TEXT("} ACMSTREAMHEADER\r\n"));
    
    if (mmr != MMSYSERR_NOERROR)
        DebugBreak();
}

void DumpWFX(
             LPTSTR         psz,
             LPWAVEFORMATEX pwfx,
             LPBYTE         pbSamples,
             DWORD          cbSamples)
{
    TCHAR sz[256];
	HRESULT hr;
    
    if (psz)
    {
        OutputDebugString(psz);
        OutputDebugString(TEXT("\r\n"));
    }
    OutputDebugString(TEXT("WAVEFORMATEX {\r\n"));
    
    hr = StringCchPrintf(sz , SIZEOF(sz) , TEXT("wfx.wFormatTag        = %x\r\n")
                , pwfx->wFormatTag);
	Assert( hr == S_OK );
    OutputDebugString(sz);

    hr = StringCchPrintf(sz , SIZEOF(sz) , TEXT("wfx.nChannels         = %x\r\n")
                , pwfx->nChannels);
	Assert( hr == S_OK );
    OutputDebugString(sz);

    hr = StringCchPrintf(sz , SIZEOF(sz) , TEXT("wfx.nSamplesPerSec    = %lx\r\n")
                , pwfx->nSamplesPerSec);
	Assert( hr == S_OK );
    OutputDebugString(sz);
    
    hr = StringCchPrintf(sz , SIZEOF(sz) , TEXT("wfx.nAvgBytesPerSec   = %lx\r\n")
                , pwfx->nAvgBytesPerSec);
	Assert( hr == S_OK );
    OutputDebugString(sz);
    
    hr = StringCchPrintf(sz , SIZEOF(sz) , TEXT("wfx.nBlockAlign       = %x\r\n")
                , pwfx->nBlockAlign);
	Assert( hr == S_OK );
    OutputDebugString(sz);

    hr = StringCchPrintf(sz , SIZEOF(sz) , TEXT("wfx.wBitsPerSample    = %x\r\n")
                , pwfx->wBitsPerSample);
	Assert( hr == S_OK );
    OutputDebugString(sz);

    hr = StringCchPrintf(sz , SIZEOF(sz) , TEXT("wfx.cbSize            = %x\r\n")
                , pwfx->cbSize);
	Assert( hr == S_OK );
    OutputDebugString(sz);
    OutputDebugString(TEXT("} WAVEFORMATEX\r\n"));

    hr = StringCchPrintf(sz , SIZEOF(sz) , TEXT("cbSamples = %d, that's %d ms\r\n")
                , cbSamples
                , wfSamplesToTime(pwfx, wfBytesToSamples(pwfx, cbSamples)));
	Assert( hr == S_OK );
    OutputDebugString(sz);    
    if (IsBadReadPtr(pbSamples, cbSamples))
    {
        OutputDebugString(TEXT("Bad Data (READ)!!!!!\r\n"));
        DebugBreak();
    }
    if (IsBadWritePtr(pbSamples, cbSamples))
    {
        OutputDebugString(TEXT("Bad Data (WRITE)!!!!!\r\n"));
        DebugBreak();
    }

}
#else
#define DumpASH(x,y)
#define DumpWFX(x,y,z,a)
#endif

MMRESULT
ConvertMultipleFormats(
    PWAVEFORMATEX   pwfxSrc,        // pwfx specifying source format
    DWORD           cbSrc,          // size of the source buffer
    LPBYTE          pbSrc,          // source buffer
    PWAVEFORMATEX   pwfxDst,        // pwfx specifying dest format
    DWORD *         pcbDst,         // return size of the dest buffer
    LPBYTE *        ppbDst,         // dest buffer
    DWORD           cBlks,          // number of blocks
    PPROGRESS       pPrg)           // progress update
{

    MMRESULT        mmr;
    WAVEFORMATEX    wfxPCM1, wfxPCM2;
    LPBYTE          pbPCM1, pbPCM2;
    DWORD           cbPCM1, cbPCM2;

    if (cbSrc == 0 || pbSrc == NULL)
    {
        pPrg->dwTotal       = 100;
        pPrg->dwComplete    = 100;
        
        ProgressUpdate(pPrg, 100);
        
        *pcbDst = 0;
        *ppbDst = NULL;
        
        return MMSYSERR_NOERROR;
    }
    
    //
    // Ask ACM to suggest a PCM format to convert to.
    //
    wfxPCM1.wFormatTag      = WAVE_FORMAT_PCM;
    mmr = acmFormatSuggest(NULL, pwfxSrc, &wfxPCM1, sizeof(WAVEFORMATEX),
                           ACM_FORMATSUGGESTF_WFORMATTAG);

    if (mmr != MMSYSERR_NOERROR)
        return mmr;

    //
    // Ask ACM to suggest a PCM format to convert from.
    // 
    wfxPCM2.wFormatTag      = WAVE_FORMAT_PCM;

    mmr = acmFormatSuggest(NULL, pwfxDst, &wfxPCM2, sizeof(WAVEFORMATEX),
                           ACM_FORMATSUGGESTF_WFORMATTAG);

    if (mmr != MMSYSERR_NOERROR)
        return mmr;

    //
    // if either of the above suggestions failed, we cannot complete the
    // conversion.
    //
    // now, we have the following steps to execute:
    //
    // *pwfxSrc -> wfxPCM1
    // wfxPCM1  -> wfxPCM2
    // wfxPCM2  -> *pwfxDst
    //
    // if either *pwfxSrc or *pwfxDst are PCM, we only need a two or one step
    // conversion.
    //
    
    if (pwfxSrc->wFormatTag == WAVE_FORMAT_PCM
        || pwfxDst->wFormatTag == WAVE_FORMAT_PCM)
    {

        LPWAVEFORMATEX pwfx;
        DWORD *        pcb;
        LPBYTE *       ppb;
        //
        // single step conversion
        //
        if ((pwfxSrc->wFormatTag == WAVE_FORMAT_PCM
             && pwfxDst->wFormatTag == WAVE_FORMAT_PCM)
            || (pwfxSrc->wFormatTag == WAVE_FORMAT_PCM
                && memcmp(pwfxSrc, &wfxPCM2, sizeof(PCMWAVEFORMAT)) == 0)
            || (pwfxDst->wFormatTag == WAVE_FORMAT_PCM
                && memcmp(pwfxDst, &wfxPCM1, sizeof(PCMWAVEFORMAT)) == 0))
        {
            pPrg->dwTotal       = 100;
            pPrg->dwComplete    = 0;
            mmr = ConvertFormat(pwfxSrc
                                , cbSrc
                                , pbSrc
                                , pwfxDst
                                , pcbDst
                                , ppbDst
                                , cBlks
                                , pPrg);
            return mmr;
        }
        
        //
        // two step conversion required
        //
        if (pwfxSrc->wFormatTag == WAVE_FORMAT_PCM)
        {
            pwfx = &wfxPCM2;
            pcb  = &cbPCM2;
            ppb  = &pbPCM2;
        }
        else
        {
            pwfx = &wfxPCM1;
            pcb  = &cbPCM1;
            ppb  = &pbPCM1;
        }
        pPrg->dwTotal       = 50;
        pPrg->dwComplete    = 0;

        mmr = ConvertFormat(pwfxSrc
                            , cbSrc
                            , pbSrc
                            , pwfx
                            , pcb
                            , ppb
                            , cBlks
                            , pPrg);

        if (mmr != MMSYSERR_NOERROR)
            return mmr;

        pPrg->dwTotal       = 50;
        pPrg->dwComplete    = 50;

        mmr = ConvertFormat(pwfx
                            , *pcb
                            , *ppb
                            , pwfxDst
                            , pcbDst
                            , ppbDst
                            , cBlks
                            , pPrg);

        GlobalFreePtr(*ppb);
        return mmr;
    }
    else
    {
        //
        // three step conversion required
        //
        pPrg->dwTotal       = 33;
        pPrg->dwComplete    = 1;

        //
        // Convert from Src to PCM1
        //
        mmr = ConvertFormat(pwfxSrc
                            , cbSrc
                            , pbSrc
                            , &wfxPCM1
                            , &cbPCM1
                            , &pbPCM1
                            , cBlks
                            , pPrg);
        if (mmr != MMSYSERR_NOERROR)
            return mmr;

        pPrg->dwTotal       = 33;
        pPrg->dwComplete    = 34;

        //
        // Convert from PCM1 to PCM2
        //
        mmr = ConvertFormat (&wfxPCM1
                             , cbPCM1
                             , pbPCM1
                             , &wfxPCM2
                             , &cbPCM2
                             , &pbPCM2
                             , cBlks
                             , pPrg);

        GlobalFreePtr(pbPCM1);

        if (mmr != MMSYSERR_NOERROR)
            return mmr;

        pPrg->dwTotal       = 33;
        pPrg->dwComplete    = 67;

        //
        // Convert from PCM2 to DST
        //
        mmr = ConvertFormat (&wfxPCM2
                             , cbPCM2
                             , pbPCM2
                             , pwfxDst
                             , pcbDst
                             , ppbDst
                             , cBlks
                             , pPrg);

        GlobalFreePtr(pbPCM2);
    }
    return mmr;
}

//
// add spilage to/from file i/o
//

/* Generic single step conversion.
 */
MMRESULT
ConvertFormat(
    PWAVEFORMATEX   pwfxSrc,        // pwfx specifying source format
    DWORD           cbSrc,          // size of the source buffer
    LPBYTE          pbSrc,          // source buffer
    PWAVEFORMATEX   pwfxDst,        // pwfx specifying dest format
    DWORD *         pcbDst,         // return size of the dest buffer
    LPBYTE *        ppbDst,         // dest buffer
    DWORD           cBlks,          // number of blocks
    PPROGRESS       pPrg)           // progress update
{
    HACMSTREAM      hasStream   = NULL;
    MMRESULT        mmr         = MMSYSERR_NOERROR;

    //
    // temporary copy buffers
    //
    DWORD           cbSrcBuf    = 0L;
    LPBYTE          pbSrcBuf    = NULL;

    DWORD           cbDstBuf    = 0L;
    LPBYTE          pbDstBuf    = NULL;

    //
    // full destination buffers
    //
    DWORD           cbDst       = 0L;
    LPBYTE          pbDst       = NULL;

    DWORD           cbSrcUsed   = 0L;
    DWORD           cbDstUsed   = 0L;

    DWORD           cbCopySrc   = 0L;
    DWORD           cbCopyDst   = 0L;    

    DWORD           cbRem;
    
    ACMSTREAMHEADER ash;
    WORD            nBlockAlign;
    
    gfBreakOfDeath = FALSE;
    
    DumpWFX(TEXT("ConvertFormat Input"), pwfxSrc, pbSrc, cbSrc);

    if (cbSrc == 0 || pbSrc == NULL)
    {
        pPrg->dwTotal       = 100;
        pPrg->dwComplete    = 100;
        
        ProgressUpdate(pPrg, 100);
        
        *pcbDst = 0;
        *ppbDst = NULL;
        
        return MMSYSERR_NOERROR;
    }
    
    //
    // synchronous conversion 
    //
    mmr = acmStreamOpen(&hasStream
                        , NULL
                        , pwfxSrc
                        , pwfxDst
                        , NULL        // no filter. maybe later
                        , 0L
                        , 0L
                        , ACM_STREAMOPENF_NONREALTIME );

    if (MMSYSERR_NOERROR != mmr)
    {
        return mmr;
    }

    //
    // How big of a destination buffer do we need?
    //
    // WARNING: acmStreamSize only gives us an estimation. if, in the event
    // it *underestimates* the destination buffer size we currently ignore
    // it, causing a clipping of the end buffer
    //
    mmr = acmStreamSize(hasStream
                        , cbSrc
                        , &cbDst
                        , ACM_STREAMSIZEF_SOURCE);
    
    if (MMSYSERR_NOERROR != mmr)
    {
        goto ExitCloseStream;
    }
    
    //
    // allocate the destination buffer 
    //
    pbDst = (LPBYTE)GlobalAllocPtr(GHND | GMEM_SHARE,cbDst);
    
    if (pbDst == NULL)
    {
        mmr = MMSYSERR_NOMEM;
        goto ExitCloseStream;
    }
    
    *ppbDst = pbDst;
    *pcbDst = cbDst;

    //
    // chop up the data into 10 bitesize pieces
    //
    nBlockAlign = pwfxSrc->nBlockAlign;
                 
    cbSrcBuf = cbSrc / 10;
    cbSrcBuf = cbSrcBuf - (cbSrcBuf % nBlockAlign);
    cbSrcBuf = ( 0L == cbSrcBuf ) ? nBlockAlign : cbSrcBuf;

    mmr = acmStreamSize(hasStream
                        , cbSrcBuf
                        , &cbDstBuf
                        , ACM_STREAMSIZEF_SOURCE);
    
    if (MMSYSERR_NOERROR != mmr)
        goto ExitFreeDestData;
    
    //
    // allocate source copy buffer 
    //
    pbSrcBuf = (LPBYTE)GlobalAllocPtr(GHND | GMEM_SHARE,cbSrcBuf);
    if (pbSrcBuf == NULL)
    {
        mmr = MMSYSERR_NOMEM;        
        goto ExitFreeDestData;
    }

    //
    // allocate destination copy buffer
    //
    pbDstBuf = (LPBYTE)GlobalAllocPtr(GHND | GMEM_SHARE,cbDstBuf);
    if (pbDstBuf == NULL)
    {
        mmr = MMSYSERR_NOMEM;
        GlobalFreePtr(pbSrcBuf);
        pbSrcBuf = NULL;
        goto ExitFreeDestData;
    }

    //
    // initialize the ash 
    //    
    ash.cbStruct        = sizeof(ash);
    ash.fdwStatus       = 0L;
    ash.pbSrc           = pbSrcBuf;
    ash.cbSrcLength     = cbSrcBuf;
    ash.cbSrcLengthUsed = 0L;
    ash.pbDst           = pbDstBuf;
    ash.cbDstLength     = cbDstBuf;
    ash.cbDstLengthUsed = 0L;

    //
    // we will only need to prepare once, since the buffers are
    // never moved.
    //
    mmr = acmStreamPrepareHeader(hasStream, &ash, 0L);
    if (MMSYSERR_NOERROR != mmr)
        goto ExitFreeTempBuffers;

    //
    // main blockalign conversion loop
    //
    while (cbSrcUsed < cbSrc)
    {
        cbCopySrc = min(cbSrcBuf, cbSrc - cbSrcUsed);
        if (cbCopySrc > 0L)
            memmove(pbSrcBuf, pbSrc, cbCopySrc);
        
#ifdef ACMBUG
//
// ACM has a bug wherein the destination buffer is validated for too
// much.  If we exactly calculate the cbCopyDst here, ACM is sure to
// puke on the conversion before the last.
//
        cbCopyDst = min(cbDstBuf, cbDst - cbDstUsed);
#else        
        cbCopyDst = cbDstBuf;
#endif
        if (cbCopyDst == 0L || cbCopyDst == 0L)
            break;
        
        ash.cbSrcLength     = cbCopySrc;
        ash.cbSrcLengthUsed = 0L;        
        ash.cbDstLength     = cbCopyDst;
        ash.cbDstLengthUsed = 0L;

        mmr = acmStreamConvert(hasStream
                               , &ash
                               , ACM_STREAMCONVERTF_BLOCKALIGN );
        
        if (MMSYSERR_NOERROR != mmr)
        {
            DumpASH(mmr, &ash);
            goto ExitUnprepareHeader;
        }

        //
        // Update the user and test for cancel
        //
        if (!ProgressUpdate(pPrg, (cbSrcUsed * 100)/cbSrc))
        {
            mmr = MMSYSERR_ERROR;
            goto ExitUnprepareHeader;
        }
        
        while (0 == (ACMSTREAMHEADER_STATUSF_DONE & ash.fdwStatus))
        {
            //
            // I don't trust an infinite loop.
            //
            if (gfBreakOfDeath)
            {
                mmr = MMSYSERR_HANDLEBUSY;  // Bad bad bad condition
                goto ExitUnprepareHeader;
            }
        }

        //
        // always increment.  we will have to carry over whatever the
        // last conversion gives us back since this determined by.
        //
        cbSrcUsed   += ash.cbSrcLengthUsed;
        pbSrc       += ash.cbSrcLengthUsed;

        //
        // loop terminating condition.  if the conversion yields no
        // destination data without error, we can only flush end data.
        //
        if (0L == ash.cbDstLengthUsed || cbDstUsed >= cbDst)
            break;

#ifdef ACMBUG            
        memmove(pbDst, pbDstBuf, ash.cbDstLengthUsed );
        cbDstUsed   += ash.cbDstLengthUsed;
        pbDst       += ash.cbDstLengthUsed;
#else
        cbRem = min(ash.cbDstLengthUsed, cbDst - cbDstUsed);
        memmove(pbDst, pbDstBuf, cbRem);
            
        cbDstUsed   += cbRem;
        pbDst       += cbRem;
#endif        
    }

    //
    // Flush remaining block-aligned end data to the destination stream.
    // Example: A few bytes of source data were left unconverted because
    // for some reason, the last 
    //
 
    for (;cbDst - cbDstUsed > 0; )
    {
        cbCopySrc = min(cbSrcBuf, cbSrc - cbSrcUsed);
        if (cbCopySrc > 0L)
            memmove(pbSrcBuf, pbSrc, cbCopySrc);

#ifdef ACMBUG
        cbCopyDst = min(cbDstBuf, cbDst - cbDstUsed);
#else        
        cbCopyDst = cbDstBuf;
#endif        
        
        ash.cbSrcLength     = cbCopySrc;
        ash.cbSrcLengthUsed = 0L;
        ash.cbDstLength     = cbCopyDst;
        ash.cbDstLengthUsed = 0L;
        
        mmr = acmStreamConvert(hasStream
                               , &ash
                               , ACM_STREAMCONVERTF_BLOCKALIGN |
                                 ACM_STREAMCONVERTF_END );
        
        if (MMSYSERR_NOERROR != mmr)
        {
            DumpASH(mmr, &ash);
            goto ExitUnprepareHeader;
        }

        //
        // Update the user and test for cancel
        //
        if (!ProgressUpdate(pPrg, (cbSrcUsed * 100)/cbSrc))
        {
            mmr = MMSYSERR_ERROR;
            goto ExitUnprepareHeader;
        }
        
        while (0 == (ACMSTREAMHEADER_STATUSF_DONE & ash.fdwStatus))
        {
            //
            // I don't trust an infinite loop.
            //
            if (gfBreakOfDeath)
            {
                mmr = MMSYSERR_HANDLEBUSY;  // Bad bad bad condition
                goto ExitUnprepareHeader;
            }
        }
        cbSrcUsed   += ash.cbSrcLengthUsed;
        pbSrc       += ash.cbSrcLengthUsed;

        if (0L != ash.cbDstLengthUsed && cbDstUsed < cbDst)
        {
#ifdef ACMBUG            
            memmove(pbDst, pbDstBuf, ash.cbDstLengthUsed);
        
            cbDstUsed   += ash.cbDstLengthUsed;
            pbDst       += ash.cbDstLengthUsed;
#else            
            cbRem = min(ash.cbDstLengthUsed, cbDst - cbDstUsed);
            memmove(pbDst, pbDstBuf, cbRem);
            cbDstUsed   += cbRem;
            pbDst       += cbRem;
#endif            
        }

        //
        // Last pass non-blockaligned end data 
        //
        cbCopySrc = min(cbSrcBuf, cbSrc - cbSrcUsed);
        if (cbCopySrc > 0L)
            memmove(pbSrcBuf, pbSrc, cbCopySrc);

#ifdef ACMBUG
        cbCopyDst = min(cbDstBuf, cbDst - cbDstUsed);
        if (0L == cbCopyDst)
            break;
#else        
        cbCopyDst = cbDstBuf;
#endif        

        ash.cbSrcLength     = cbCopySrc;
        ash.cbSrcLengthUsed = 0L;
        ash.cbDstLength     = cbCopyDst;        
        ash.cbDstLengthUsed = 0L;
        
        mmr = acmStreamConvert(hasStream
                               , &ash
                               , ACM_STREAMCONVERTF_END );

        if (MMSYSERR_NOERROR != mmr)
        {
            DumpASH(mmr, &ash);
            goto ExitUnprepareHeader;
        }

        //
        // Update the user and test for cancel 
        //
        if (!ProgressUpdate(pPrg, (cbSrcUsed * 100)/cbSrc))
        {
            mmr = MMSYSERR_ERROR;
            goto ExitUnprepareHeader;
        }
        
        while (0 == (ACMSTREAMHEADER_STATUSF_DONE & ash.fdwStatus))
        {
            //
            // I don't trust an infinite loop.
            //
            if (gfBreakOfDeath)
            {
                mmr = MMSYSERR_HANDLEBUSY;  // Bad bad bad condition
                goto ExitUnprepareHeader;
            }
        }

        cbSrcUsed   += ash.cbSrcLengthUsed;
        pbSrc       += ash.cbSrcLengthUsed;

        if (0L != ash.cbDstLengthUsed && cbDstUsed < cbDst)
        {
#ifdef ACMBUG
            memmove(pbDst, pbDstBuf, ash.cbDstLengthUsed);
        
            cbDstUsed   += ash.cbDstLengthUsed;
            pbDst       += ash.cbDstLengthUsed;
#else            
            cbRem = min(ash.cbDstLengthUsed, cbDst - cbDstUsed);
            memmove(pbDst, pbDstBuf, cbRem);
            cbDstUsed   += cbRem;
            pbDst       += cbRem;
#endif            
        }
        else // nothing's going to work 
            break;
    }
    
    *pcbDst = cbDstUsed;
    DumpWFX(TEXT("ConvertFormat Output"), pwfxDst, *ppbDst, cbDstUsed);
            
ExitUnprepareHeader:    
    acmStreamUnprepareHeader(hasStream, &ash, 0L);

ExitFreeTempBuffers:
    GlobalFreePtr(pbDstBuf);
    GlobalFreePtr(pbSrcBuf);    
    
    if (MMSYSERR_NOERROR == mmr)
        goto ExitCloseStream;

ExitFreeDestData:
    GlobalFreePtr(*ppbDst);
    *ppbDst = NULL;
    *pcbDst = 0L;

ExitCloseStream:
    acmStreamClose(hasStream,0L);
    
    return mmr;
}

/*      -       -       -       -       -       -       -       -       -   */
void Properties_InitDocVars(
    HWND        hwnd,
    PWAVEDOC    pwd)
{
    if (pwd->pwfx)
    {
        LPTSTR  lpstr;
        TCHAR   sz[128];
        TCHAR   szFmt[128];        
        LONG    lTime;
        HINSTANCE hinst;
		HRESULT hr;
        
        lpstr = SoundRec_GetFormatName(pwd->pwfx);
        if (lpstr)
        {
            SetDlgItemText(hwnd, IDC_AUDIOFORMAT, lpstr);
            GlobalFreePtr(lpstr);
        }
        lTime = wfSamplesToTime(pwd->pwfx,wfBytesToSamples(pwd->pwfx,pwd->cbdata));
        if (gfLZero || ((int)(lTime/1000) != 0))
            hr = StringCchPrintf(sz, SIZEOF(sz), aszPositionFormat, (int)(lTime/1000), chDecimal,
                     (int)((lTime/10)%100));
        else
            hr = StringCchPrintf(sz, SIZEOF(sz), aszNoZeroPositionFormat, chDecimal,
                     (int)((lTime/10)%100));
		Assert( hr == S_OK );
        SetDlgItemText(hwnd, IDC_FILELEN, sz);

        hinst = GetWindowInstance(hwnd);
        if (hinst && LoadString(hinst, IDS_DATASIZE, szFmt, SIZEOF(szFmt)))
        {
            hr = StringCchPrintf(sz, SIZEOF(sz), szFmt, pwd->cbdata);
			Assert( hr == S_OK );
            SetDlgItemText(hwnd, IDC_DATASIZE, sz);
        }
    }
}
/*
 * */
BOOL Properties_OnInitDialog(
    HWND        hwnd,
    HWND        hwndFocus,
    LPARAM      lParam)
{
    HINSTANCE   hinst;
    HWND        hChoice;
    TCHAR       sz[256];
    int         i;
    
    //
    // commence initialization
    //
    PWAVEDOC pwd = (PWAVEDOC)((LPPROPSHEETPAGE)lParam)->lParam;
    if (pwd == NULL)
    {
        EndDialog(hwnd, FALSE);
        return FALSE;
    }
    
    SetProp(hwnd,  TEXT("DATA"), (HANDLE)pwd);
    hinst = GetWindowInstance(hwnd);
    
    //
    // Set "static" property information
    //
    if (pwd->pszFileName)
        SetDlgItemText(hwnd, IDC_FILENAME, pwd->pszFileName);
    if (pwd->pszCopyright)
        SetDlgItemText(hwnd, IDC_COPYRIGHT, pwd->pszCopyright);
    else if (LoadString(hinst, IDS_NOCOPYRIGHT, sz, SIZEOF(sz)))
    {
        SetDlgItemText(hwnd, IDC_COPYRIGHT, sz);
    }
    if (pwd->hIcon)
        Static_SetIcon(GetDlgItem(hwnd, IDC_DISPICON), pwd->hIcon);

    //
    // Set "volatile" property information
    //
    Properties_InitDocVars(hwnd, pwd);

    //
    // Initialize the enumeration choice combobox
    //
    hChoice = GetDlgItem(hwnd, IDC_CONVERTCHOOSEFROM);
    if (waveOutGetNumDevs())
    {
        if (LoadString(hinst, IDS_SHOWPLAYABLE, sz, SIZEOF(sz)))
        {
            i = ComboBox_AddString(hChoice, sz);
            ComboBox_SetItemData(hChoice, i, ACM_FORMATENUMF_OUTPUT);
        }
    }
    if (waveInGetNumDevs())
    {
        if (LoadString(hinst, IDS_SHOWRECORDABLE, sz, SIZEOF(sz)))
        {
            i = ComboBox_AddString(hChoice, sz);
            ComboBox_SetItemData(hChoice, i, ACM_FORMATENUMF_INPUT);
        }
    }
    if (LoadString(hinst, IDS_SHOWALL, sz, SIZEOF(sz)))
    {
        i = ComboBox_AddString(hChoice, sz);
        ComboBox_SetItemData(hChoice, i, 0L);
    }
    ComboBox_SetCurSel(hChoice, i);
    
    return FALSE;
}

/*
 * */
void Properties_OnDestroy(
    HWND        hwnd)
{
    //
    // commence cleanup
    //
    PWAVEDOC pwd = (PWAVEDOC)GetProp(hwnd, TEXT("DATA"));
    if (pwd)
    {
        RemoveProp(hwnd, TEXT("DATA"));
    }
}


/*
 * */
BOOL PASCAL Properties_OnCommand(
    HWND        hwnd,
    int         id,
    HWND        hwndCtl,
    UINT        codeNotify)
{
    switch (id)
    {
        case ID_APPLY:
            return TRUE;
            
        case IDOK:
            break;

        case IDCANCEL:
            break;

        case ID_INIT:		
            break;

        case IDC_CONVERTTO:
        {
            PWAVEDOC pwd = (PWAVEDOC)GetProp(hwnd, TEXT("DATA"));
            PWAVEFORMATEX pwfxNew = NULL;
            DWORD fdwEnum = 0L;
            int i;
            HWND hChoice;

            hChoice = GetDlgItem(hwnd, IDC_CONVERTCHOOSEFROM);
            i = ComboBox_GetCurSel(hChoice);
            fdwEnum = (DWORD)ComboBox_GetItemData(hChoice, i);
            
            if (ChooseDestinationFormat(ghInst
                                        ,hwnd
                                        ,NULL
                                        ,&pwfxNew
                                        ,fdwEnum) == MMSYSERR_NOERROR)
            {
                DWORD   cbNew;
                LPBYTE  pbNew;
                DWORD   cbSize = (pwfxNew->wFormatTag == WAVE_FORMAT_PCM)?
                                 sizeof(PCMWAVEFORMAT):
                                 sizeof(WAVEFORMATEX)+pwfxNew->cbSize;
                
                if (memcmp(pwfxNew, pwd->pwfx, cbSize) == 0)
                    break;
                StopWave();
                BeginWaveEdit();
                if (ConvertFormatDialog(hwnd
                                        , pwd->pwfx
                                        , pwd->cbdata
                                        , pwd->pbdata
                                        , pwfxNew
                                        , &cbNew
                                        , &pbNew
                                        , 0
                                        , NULL) == MMSYSERR_NOERROR)
                {
                    GlobalFreePtr(pwd->pwfx);
                    if (pwd->pbdata)
                        GlobalFreePtr(pwd->pbdata);
                    
                    pwd->pwfx   = pwfxNew;
                    pwd->cbdata = cbNew;
                    pwd->pbdata = pbNew;
                    pwd->fChanged = TRUE;

                    if (pwd->lpv)
                    {
                        PSGLOBALS psg = (PSGLOBALS)pwd->lpv;
                        *psg->ppwfx     = pwfxNew;
                        *psg->pcbwfx    = sizeof(WAVEFORMATEX);
                        if (pwfxNew->wFormatTag != WAVE_FORMAT_PCM)
                            *psg->pcbwfx += pwfxNew->cbSize;

                        *psg->pcbdata   = cbNew;
                        *psg->ppbdata    = pwd->pbdata;
                        *psg->plSamples = wfBytesToSamples(pwfxNew, cbNew);
                        *psg->plSamplesValid    = *psg->plSamples;
                        *psg->plWavePosition = 0;
                        UpdateDisplay(TRUE);
                        Properties_InitDocVars(hwnd, pwd);
                    }
                    EndWaveEdit(TRUE);
                }
                else
                    EndWaveEdit(FALSE);
                
            }
            return TRUE;
        }
    }
    return FALSE;
}


/*
 * Properties_Proc
 */
INT_PTR CALLBACK
Properties_Proc(
    HWND        hdlg,
    UINT        umsg,
    WPARAM      wparam,
    LPARAM      lparam)
{
#ifdef CHICAGO
    static const DWORD aHelpIds[] = {
        IDC_DISPICON,           IDH_SOUNDREC_ICON,
        IDC_FILENAME,           IDH_SOUNDREC_SNDTITLE,
        IDC_TXT_COPYRIGHT,      IDH_SOUNDREC_COPYRIGHT,    
        IDC_COPYRIGHT,          IDH_SOUNDREC_COPYRIGHT,
        IDC_TXT_FILELEN,        IDH_SOUNDREC_LENGTH,
        IDC_FILELEN,            IDH_SOUNDREC_LENGTH,
        IDC_TXT_DATASIZE,       IDH_SOUNDREC_SIZE,
        IDC_DATASIZE,           IDH_SOUNDREC_SIZE,
        IDC_TXT_AUDIOFORMAT,    IDH_SOUNDREC_AUDIO,
        IDC_AUDIOFORMAT,        IDH_SOUNDREC_AUDIO,
        IDC_CONVGROUP,          IDH_SOUNDREC_COMM_GROUPBOX,
        IDC_CONVERTCHOOSEFROM,  IDH_SOUNDREC_CONVERT,
        IDC_CONVERTTO,          IDH_SOUNDREC_FORMAT,
        0,                      0
    };
#endif

    switch (umsg)
    {
        
#ifdef CHICAGO
        case WM_CONTEXTMENU:        
            WinHelp((HWND)wparam, gachHelpFile, HELP_CONTEXTMENU, 
                (UINT_PTR)(LPSTR)aHelpIds);
            return TRUE;
        
        case WM_HELP:
        {
            LPHELPINFO lphi = (LPVOID) lparam;
            WinHelp (lphi->hItemHandle, gachHelpFile, HELP_WM_HELP,
                    (UINT_PTR) (LPSTR) aHelpIds);
            return TRUE;
        }
#endif            
        case WM_INITDIALOG:
            return HANDLE_WM_INITDIALOG(hdlg, wparam, lparam, Properties_OnInitDialog);
            
        case WM_DESTROY:
            HANDLE_WM_DESTROY(hdlg, wparam, lparam, Properties_OnDestroy);
            break;
            
        case WM_NOTIFY:
        {
            NMHDR *lpnm = (NMHDR FAR *)lparam;
            switch(lpnm->code)
            {
                case PSN_KILLACTIVE:
                    FORWARD_WM_COMMAND(hdlg, IDOK, 0, 0, SendMessage);
                    break;
                    
                case PSN_APPLY:
                    FORWARD_WM_COMMAND(hdlg, ID_APPLY, 0, 0, SendMessage);	
                    break;              					

                case PSN_SETACTIVE:
                    FORWARD_WM_COMMAND(hdlg, ID_INIT, 0, 0, SendMessage);
                    break;

                case PSN_RESET:
                    FORWARD_WM_COMMAND(hdlg, IDCANCEL, 0, 0, SendMessage);
                    break;
            }
            break;
        }
        case WM_COMMAND:
            return HANDLE_WM_COMMAND(hdlg, wparam, lparam, Properties_OnCommand);
        default:
        {
#ifdef CHICAGO            
            extern DWORD aChooserHelpIds[];
            extern UINT  guChooserContextMenu;
            extern UINT  guChooserContextHelp;            
            //
            //  Handle context-sensitive help messages from acm dialog
            //
            if( umsg == guChooserContextMenu )
            {
                WinHelp( (HWND)wparam, NULL, HELP_CONTEXTMENU, 
                           (UINT_PTR)(LPSTR)aChooserHelpIds );
            }
            else if( umsg == guChooserContextHelp )
            {
                WinHelp( ((LPHELPINFO)lparam)->hItemHandle, NULL,
                        HELP_WM_HELP, (UINT_PTR)(LPSTR)aChooserHelpIds );
            }
#endif            
            break;            
        }

    }
    return FALSE;
}



/*
 * Wave document property sheet.
 * */
BOOL
SoundRec_Properties(
    HWND            hwnd,
    HINSTANCE       hinst,
    PWAVEDOC        pwd)
{
    PROPSHEETPAGE   psp;
    PROPSHEETHEADER psh;
    TCHAR szCaption[256], szCapFmt[64];
	HRESULT			hr;
    
    psp.dwSize      = sizeof(PROPSHEETPAGE);
    psp.dwFlags     = PSP_DEFAULT;// | PSP_USETITLE;
    psp.hInstance   = hinst;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROPERTIES);
    psp.pszIcon     = NULL;
    psp.pszTitle    = NULL; 
    psp.pfnDlgProc  = Properties_Proc;
    psp.lParam      = (LPARAM)(LPVOID)pwd;
    psp.pfnCallback = NULL;
    psp.pcRefParent = NULL;

    psh.dwSize      = sizeof(PROPSHEETHEADER);
    psh.dwFlags     = PSH_NOAPPLYNOW|PSH_PROPSHEETPAGE ;
    psh.hwndParent  = hwnd;
    psh.hInstance   = hinst;
    psh.pszIcon     = NULL;

    if (LoadString(hinst, IDS_PROPERTIES, szCapFmt, SIZEOF(szCapFmt)))
    {
        hr = StringCchPrintf(szCaption, SIZEOF(szCaption), szCapFmt, pwd->pszFileName);
        psh.pszCaption = szCaption;
    }
    else
        psh.pszCaption = NULL;
    
    psh.nPages      = 1;
    psh.nStartPage  = 0;
    psh.ppsp        = &psp;
    psh.pfnCallback = NULL;

    PropertySheet(&psh);
    
    return FALSE;   // nothing changed?
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\soundrec\buttons.c ===
/* (C) Copyright Microsoft Corporation 1991-1994.  All Rights Reserved */
/******************************Module*Header*******************************\
* Module Name: buttons.c
*
* Bitmap button support.  On Daytona bitmap buttons are provided by
* mmcntrls.  On Chicago there is no mmcntrls, so we use the functions
* in this file.
*
*
* Created: 19-04-94
* Author:  Stephen Estrop [StephenE]
*
\**************************************************************************/
//#pragma warning( once : 4201 4214 )

#define NOOLE
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>

#include "buttons.h"


/* -------------------------------------------------------------------------
** Color globals
** -------------------------------------------------------------------------
*/
int         nSysColorChanges = 0;
DWORD       rgbFace;
DWORD       rgbShadow;
DWORD       rgbHilight;
DWORD       rgbFrame;


extern void
PatB(
    HDC hdc,
    int x,
    int y,
    int dx,
    int dy,
    DWORD rgb
    );

#if 0
// also defined in sframe.c!

/*****************************Private*Routine******************************\
* PatB
*
* Fast way to fill an rectangle with a solid colour.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
PatB(
    HDC hdc,
    int x,
    int y,
    int dx,
    int dy,
    DWORD rgb
    )
{
    RECT    rc;

    SetBkColor(hdc,rgb);
    rc.left   = x;
    rc.top    = y;
    rc.right  = x + dx;
    rc.bottom = y + dy;

    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
}

#endif



/*****************************Private*Routine******************************\
* CheckSysColors
*
* Checks the system colors and updates the cached global variables if
* they have changed.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CheckSysColors(
    void
    )
{
   static COLORREF rgbSaveFace    = 0xffffffffL,
                   rgbSaveShadow  = 0xffffffffL,
                   rgbSaveHilight = 0xffffffffL,
                   rgbSaveFrame   = 0xffffffffL;

   rgbFace    = GetSysColor(COLOR_BTNFACE);
   rgbShadow  = GetSysColor(COLOR_BTNSHADOW);
   rgbHilight = GetSysColor(COLOR_BTNHIGHLIGHT);
   rgbFrame   = GetSysColor(COLOR_WINDOWFRAME);

   if (rgbSaveFace!=rgbFace || rgbSaveShadow!=rgbShadow
      || rgbSaveHilight!=rgbHilight || rgbSaveFrame!=rgbFrame)
   {
      ++nSysColorChanges;

      rgbSaveFace    = rgbFace;
      rgbSaveShadow  = rgbShadow;
      rgbSaveHilight = rgbHilight;
      rgbSaveFrame   = rgbFrame;

   }
}


#if WINVER >= 0x0400
/* -------------------------------------------------------------------------
** Button globals  -- some of these should be constants
** -------------------------------------------------------------------------
*/
const TCHAR   szBbmProp[]     = TEXT("ButtonBitmapProp");
const TCHAR   szButtonProp[]  = TEXT("ButtonProp");

typedef struct tagBTNSTATE {      /* instance data for toolbar window */
    WNDPROC     lpfnDefProc;
    HWND        hwndToolTips;
    HINSTANCE   hInst;
    UINT        wID;
    UINT        uStyle;
    HBITMAP     hbm;
    HDC         hdcGlyphs;
    HDC         hdcMono;
    HBITMAP     hbmMono;
    HBITMAP     hbmDefault;
    int         dxBitmap;
    int         dyBitmap;
    int         nButtons;
    int         nSysColorChanges;
    BITMAPBTN   Buttons[1];
} BTNSTATE, NEAR *PBTNSTATE, FAR *LPBTNSTATE;

typedef struct {
    WNDPROC     lpfnDefProc;
    HWND        hwndParent;
    HWND        hwndToolTips;
} BTN_INFO, *LPBTN_INFO;


LRESULT CALLBACK
ButtonSubclassProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT CALLBACK
ParentSubclassProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

void FAR PASCAL
RelayToToolTips(
    HWND hwndToolTips,
    HWND hWnd,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
InitObjects(
    LPBTNSTATE pTBState
    );

BOOL
FreeObjects(
    LPBTNSTATE pTBState
    );

void
CreateButtonMask(
    LPBTNSTATE pTBState,
    PBITMAPBTN pTBButton
    );


/*****************************Private*Routine******************************\
* InitObjects
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
InitObjects(
    LPBTNSTATE pTBState
    )
{
    pTBState->hdcGlyphs = CreateCompatibleDC(NULL);
    if (pTBState->hdcGlyphs == NULL ) {
        return FALSE;
    }

    pTBState->hdcMono = CreateCompatibleDC(NULL);
    if (pTBState->hdcMono == NULL ) {
        DeleteObject( pTBState->hdcGlyphs );
        return FALSE;
    }

    pTBState->hbmMono = CreateBitmap( pTBState->dxBitmap,
                                      pTBState->dyBitmap, 1, 1, NULL);
    if ( pTBState->hbmMono == NULL ) {
        DeleteObject( pTBState->hdcGlyphs );
        DeleteObject( pTBState->hdcMono );
        return FALSE;
    }

    pTBState->hbmDefault = SelectObject(pTBState->hdcMono, pTBState->hbmMono);

    return TRUE;
}


/*****************************Private*Routine******************************\
* FreeObjects
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
FreeObjects(
    LPBTNSTATE pTBState
    )
{
    if (pTBState->hdcMono) {
        SelectObject(pTBState->hdcMono, pTBState->hbmDefault);
        DeleteDC(pTBState->hdcMono);              /* toast the DCs */
    }

    if (pTBState->hdcGlyphs) {
        DeleteDC(pTBState->hdcGlyphs);
    }

    if (pTBState->hbmMono) {
        DeleteObject(pTBState->hbmMono);
    }

    return TRUE;
}



/*****************************Private*Routine******************************\
* CreateButtonMask
*
* create a mono bitmap mask:
*   1's where color == COLOR_BTNFACE || COLOR_HILIGHT
*   0's everywhere else
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CreateButtonMask(
    LPBTNSTATE pTBState,
    PBITMAPBTN pTBButton
    )
{
    /* initalize whole area with 0's */
    PatBlt( pTBState->hdcMono, 0, 0, pTBState->dxBitmap,
            pTBState->dyBitmap, WHITENESS);

    /* create mask based on color bitmap
    ** convert this to 1's
    */
    SetBkColor(pTBState->hdcGlyphs, rgbFace);
    BitBlt( pTBState->hdcMono, 0, 0, pTBState->dxBitmap, pTBState->dyBitmap,
            pTBState->hdcGlyphs, pTBButton->iBitmap * pTBState->dxBitmap, 0,
            SRCCOPY );

    /* convert this to 1's */
    SetBkColor(pTBState->hdcGlyphs, rgbHilight);

    /* OR in the new 1's */
    BitBlt( pTBState->hdcMono, 0, 0, pTBState->dxBitmap, pTBState->dyBitmap,
            pTBState->hdcGlyphs, pTBButton->iBitmap * pTBState->dxBitmap, 0,
            SRCPAINT );
}



#define PSDPxax     0x00B8074A


/*****************************Private*Routine******************************\
* BtnDrawButton
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void WINAPI
BtnDrawButton(
    HWND hwnd,
    HDC hdc,
    int dx,
    int dy,
    LPBITMAPBTN ptButton
    )
{
    int         glyph_offset;
    HBRUSH      hbrOld, hbr;
    BOOL        bMaskCreated = FALSE;
    RECT        rcFocus;
    PBTNSTATE   pTBState;
    int         x = 0, y = 0;


    pTBState = (PBTNSTATE)GetProp(hwnd, szBbmProp);

    CheckSysColors();
    if (pTBState->nSysColorChanges != nSysColorChanges) {

        DeleteObject( pTBState->hbm );
        pTBState->hbm = CreateMappedBitmap( pTBState->hInst,
                                            pTBState->wID, TRUE, NULL, 0);
        pTBState->nSysColorChanges = nSysColorChanges;
    }

    /*
    ** erase with face color
    */

    PatB(hdc, x, y, dx, dy, rgbFace);

    SetRect( &rcFocus, x, y, x + dx, y + dy );

    if (ptButton->fsState & BTNSTATE_PRESSED) {
        DrawEdge( hdc, &rcFocus, EDGE_SUNKEN, BF_RECT );
        glyph_offset = 1;
    }
    else {
        DrawEdge( hdc, &rcFocus, EDGE_RAISED, BF_RECT );
        glyph_offset = 0;
    }


    /*
    ** make the coordinates the interior of the button
    */
    x++;
    y++;
    dx -= 2;
    dy -= 2;

    SelectObject( pTBState->hdcGlyphs, pTBState->hbm );

    /* now put on the face */

    /*
    ** We need to centre the Bitmap here within the button
    */
    x += ((dx - pTBState->dxBitmap ) / 2) - 1;
    y +=  (dy - pTBState->dyBitmap ) / 2;

    if (!(ptButton->fsState & BTNSTATE_DISABLED)) {

        /* regular version */
        BitBlt( hdc, x + glyph_offset, y + glyph_offset,
                pTBState->dxBitmap, pTBState->dyBitmap,
                pTBState->hdcGlyphs,
                ptButton->iBitmap * pTBState->dxBitmap, 0, SRCCOPY);
    }
    else {

        /* disabled version */
        bMaskCreated = TRUE;
        CreateButtonMask(pTBState, ptButton );

        SetTextColor(hdc, 0L);          /* 0's in mono -> 0 (for ROP) */
        SetBkColor(hdc, 0x00FFFFFF);    /* 1's in mono -> 1 */

        hbr = CreateSolidBrush(rgbHilight);
        if (hbr) {
            hbrOld = SelectObject(hdc, hbr);
            if (hbrOld) {
                /* draw hilight color where we have 0's in the mask */
                BitBlt( hdc, x + 1, y + 1,
                        pTBState->dxBitmap, pTBState->dyBitmap,
                        pTBState->hdcMono, 0, 0, PSDPxax);
                SelectObject(hdc, hbrOld);
            }
            DeleteObject(hbr);
        }

        hbr = CreateSolidBrush(rgbShadow);
        if (hbr) {
            hbrOld = SelectObject(hdc, hbr);
            if (hbrOld) {
                /* draw the shadow color where we have 0's in the mask */
                BitBlt(hdc, x, y, pTBState->dxBitmap, pTBState->dyBitmap,
                       pTBState->hdcMono, 0, 0, PSDPxax);
                SelectObject(hdc, hbrOld);
            }
            DeleteObject(hbr);
        }
    }

    if (ptButton->fsState & ODS_FOCUS) {

        BtnDrawFocusRect(hdc, &rcFocus, ptButton->fsState);
    }
}



/*****************************Private*Routine******************************\
* BtnCreateBitmapButtons
*
* Returns TRUE if successful, otherwise FALSE;
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL WINAPI
BtnCreateBitmapButtons(
    HWND hWnd,
    HINSTANCE hInst,
    UINT wID,
    UINT uStyle,
    LPBITMAPBTN lpButtons,
    int nButtons,
    int dxBitmap,
    int dyBitmap
    )
{
    PBTNSTATE pTBState;


    /*
    ** If we have already created Bitmap Buttons for this
    ** window just return.
    */
    if (GetProp(hWnd, szBbmProp)) {
        return TRUE;
    }

    // InitGlobalMetrics();
    // InitToolTipsClass( hInst );

    CheckSysColors();

    /*
    ** Allocate the required storage and save the pointer in the window
    ** property list.
    */
    pTBState = (PBTNSTATE)GlobalAllocPtr( GHND,
                                      (sizeof(BTNSTATE) - sizeof(BITMAPBTN)) +
                                      (nButtons * sizeof(BITMAPBTN)) );
    if (pTBState == NULL ) {
        return FALSE;
    }
    SetProp(hWnd, szBbmProp, (HANDLE)pTBState);


    pTBState->hInst       = hInst;
    pTBState->wID         = wID;
    pTBState->uStyle      = uStyle;
    pTBState->nButtons    = nButtons;
    pTBState->hbm         = CreateMappedBitmap( hInst, wID, TRUE, NULL, 0);
    pTBState->dxBitmap    = dxBitmap;
    pTBState->dyBitmap    = dyBitmap;

    InitObjects( pTBState );

    CopyMemory( pTBState->Buttons, lpButtons, nButtons * sizeof(BITMAPBTN) );

    /*
    ** Does the caller want tool tips ?
    */
    if (pTBState->uStyle & BBS_TOOLTIPS) {
        extern BOOL gfIsRTL;   
        pTBState->hwndToolTips = CreateWindowEx(
                                              gfIsRTL ? WS_EX_LEFTSCROLLBAR | WS_EX_RIGHT | WS_EX_RTLREADING : 0,
                                              TOOLTIPS_CLASS, TEXT(""),
                                              WS_POPUP,
                                              CW_USEDEFAULT, CW_USEDEFAULT,
                                              CW_USEDEFAULT, CW_USEDEFAULT,
                                              hWnd, NULL, hInst, NULL);


        if (pTBState->hwndToolTips != (HWND)NULL ) {

            int         i;
            TOOLINFO    ti;

            pTBState->lpfnDefProc = SubclassWindow( hWnd, ParentSubclassProc );

            ti.uFlags = 0;
            ti.cbSize = sizeof(ti);
            ti.lpszText = LPSTR_TEXTCALLBACK;

            for ( i = 0; i < nButtons; i++ ) {

                LPBTN_INFO  lpBtnInfo;
                HWND        hwndBtn;

                hwndBtn = GetDlgItem(hWnd, pTBState->Buttons[i].uId);
                if ( hwndBtn == (HWND)NULL ) {
                    break;
                }

                lpBtnInfo = (LPBTN_INFO)GlobalAllocPtr(GHND, sizeof(BTN_INFO));
                if (lpBtnInfo == NULL ) {
                    break;
                }

                SetProp(hwndBtn, szButtonProp, (HANDLE)lpBtnInfo);
                lpBtnInfo->hwndToolTips = pTBState->hwndToolTips;
                lpBtnInfo->hwndParent   = hWnd;
                lpBtnInfo->lpfnDefProc = SubclassWindow( hwndBtn,
                                                         ButtonSubclassProc );

                ti.hwnd = hwndBtn;
                ti.uId = pTBState->Buttons[i].uId;

                GetClientRect( hwndBtn, &ti.rect );
                SendMessage( lpBtnInfo->hwndToolTips, TTM_ADDTOOL,
                             (WPARAM)0, (LPARAM)&ti );


                /*
                ** Add the same rectange in parent co-ordinates so that
                ** the tooltip still gets displayed even though the button
                ** is disbaled.
                */
                MapWindowRect( hwndBtn, hWnd, &ti.rect );
                ti.hwnd = hWnd;
                SendMessage( lpBtnInfo->hwndToolTips, TTM_ADDTOOL,
                             (WPARAM)0, (LPARAM)&ti );
            }

        }
        else {

            /*
            ** No tips available, just remove the BBS_TOOLTIPS style
            */
            pTBState->uStyle &= ~BBS_TOOLTIPS;
        }
    }

    return TRUE;
}

/******************************Public*Routine******************************\
* BtnDestroyBitmapButtons
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void WINAPI
BtnDestroyBitmapButtons(
    HWND hwnd
    )
{
    PBTNSTATE pTBState;

    pTBState = (PBTNSTATE)GetProp(hwnd, szBbmProp);
    if ( pTBState != NULL ) {
        if (pTBState->hbm)
            DeleteObject( pTBState->hbm );
        FreeObjects( pTBState );
        GlobalFreePtr( pTBState );
    }
    RemoveProp(hwnd, szBbmProp);
}


/******************************Public*Routine******************************\
* BtnDrawFocusRect
*
* Use this function to draw focus rectangle around a bitmap button.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void WINAPI
BtnDrawFocusRect(
    HDC hdc,
    const RECT *lpRect,
    UINT fsState
    )
{
    int     iFaceOffset;
    RECT    rc;

    CopyRect( &rc, lpRect );

    rc.top = rc.left = 3;

    if (fsState & ODS_SELECTED) {
        iFaceOffset = 2;
    }
    else {
        iFaceOffset = 4;
    }

    rc.right  -= iFaceOffset;
    rc.bottom -= iFaceOffset;

    SetBkColor( hdc, rgbFace );
    DrawFocusRect( hdc, &rc );
}


/******************************Public*Routine******************************\
* BtnUpdateColors
*
* After a WM_SYSCOLORCHANGE message is received this function should be
* called to update the colors of the button bitmaps.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void WINAPI
BtnUpdateColors(
    HWND hwnd
    )
{
    PBTNSTATE   pTBState;

    pTBState = (PBTNSTATE)GetProp(hwnd, szBbmProp);
    if (pTBState->nSysColorChanges != nSysColorChanges)
    {
        DeleteObject( pTBState->hbm );
        pTBState->hbm = CreateMappedBitmap( pTBState->hInst,
                                            pTBState->wID, TRUE, NULL, 0);

        pTBState->nSysColorChanges = nSysColorChanges;
    }
}


/******************************Public*Routine******************************\
* ButtonSubclassProc
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
LRESULT CALLBACK
ButtonSubclassProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    LPBTN_INFO  lpBtnInfo;
    WNDPROC     lpfnDefProc;


    lpBtnInfo = (LPBTN_INFO)GetProp( hwnd, szButtonProp );

    /*
    ** Save this in case anything happens to lpBtnInfo before we return.
    */
    lpfnDefProc = lpBtnInfo->lpfnDefProc;

    switch ( uMsg ) {

    case WM_DESTROY:
        SubclassWindow( hwnd, lpfnDefProc );
        if (lpBtnInfo) {
            GlobalFreePtr(lpBtnInfo);
            RemoveProp(hwnd, szButtonProp);
        }
        break;

    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_RBUTTONDOWN:
    case WM_RBUTTONUP:
    case WM_MBUTTONDOWN:
    case WM_MBUTTONUP:
    case WM_MOUSEMOVE:
        RelayToToolTips( lpBtnInfo->hwndToolTips, hwnd, uMsg, wParam, lParam );
        break;

#if WINVER < 0x0400
    case WM_WININICHANGE:
        InitGlobalMetrics();
        break;
#endif

    case WM_MOVE:
        {
            TOOLINFO    ti;

            ti.cbSize = sizeof(ti);
            ti.uFlags = 0;
            ti.hwnd = hwnd;
            ti.lpszText = LPSTR_TEXTCALLBACK;
            ti.uId = GetDlgCtrlID( hwnd );

            GetClientRect( hwnd, &ti.rect );

            SendMessage( lpBtnInfo->hwndToolTips, TTM_NEWTOOLRECT, 0,
                         (LPARAM)&ti );

            /*
            ** Add the same rectange in parent co-ordinates so that
            ** the tooltip still gets displayed even though the button
            ** is disbaled.
            */
            MapWindowRect( hwnd, lpBtnInfo->hwndParent, &ti.rect );
            ti.hwnd = lpBtnInfo->hwndParent;
            SendMessage( lpBtnInfo->hwndToolTips, TTM_NEWTOOLRECT,
                         (WPARAM)0, (LPARAM)&ti );
        }
        break;

    case WM_NOTIFY:
        SendMessage(lpBtnInfo->hwndParent, WM_NOTIFY, wParam, lParam);
        break;

    }

    return CallWindowProc(lpfnDefProc, hwnd, uMsg, wParam, lParam);
}


/******************************Public*Routine******************************\
* ParentSubclassProc
*
* Why do I need to subclass the buttons parent window ?  Well,
* if a button is disable it will not receive mouse messages, the
* messages go to the window underneath the button (ie. the parent).
* Therefore we detect this and relay the mouse message to the tool tips
* window as above.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
LRESULT CALLBACK
ParentSubclassProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    WNDPROC     lpfnDefProc;
    PBTNSTATE   pTBState;


    pTBState = (PBTNSTATE)GetProp(hwnd, szBbmProp);

    /*
    ** Save this in case anything happens to lpBtnInfo before we return.
    */
    lpfnDefProc = pTBState->lpfnDefProc;

    switch ( uMsg ) {

#if WINVER < 0x0400
    case TB_ACTIVATE_TOOLTIPS:
        SendMessage( pTBState->hwndToolTips, TTM_ACTIVATE, wParam, 0L );
        break;
#endif

    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_RBUTTONDOWN:
    case WM_RBUTTONUP:
    case WM_MBUTTONDOWN:
    case WM_MBUTTONUP:
    case WM_MOUSEMOVE:
        RelayToToolTips( pTBState->hwndToolTips, hwnd, uMsg, wParam, lParam );
        break;

    case WM_DESTROY :
    {
        SubclassWindow( hwnd, lpfnDefProc );
        BtnDestroyBitmapButtons(hwnd);
    }
    break;

    }

    return CallWindowProc(lpfnDefProc, hwnd, uMsg, wParam, lParam);
}

/******************************Public*Routine******************************\
* RelayToToolTips
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void FAR PASCAL
RelayToToolTips(
    HWND hwndToolTips,
    HWND hWnd,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    if(hwndToolTips) {
        MSG msg;
        msg.lParam = lParam;
        msg.wParam = wParam;
        msg.message = wMsg;
        msg.hwnd = hWnd;
        SendMessage(hwndToolTips, TTM_RELAYEVENT, 0, (LPARAM)(LPMSG)&msg);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\soundrec\buttons.h ===
/******************************Module*Header*******************************\
* Module Name: chicago.h
*
* CD Playing application - support for Chicago
*
*
* Created: 19-04-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

/* -------------------------------------------------------------------------
** Button helper functions
** -------------------------------------------------------------------------
*/
void
PatB(
    HDC hdc,
    int x,
    int y,
    int dx,
    int dy,
    DWORD rgb
    );

void
CheckSysColors(
    void
    );


extern DWORD        rgbFace;
extern DWORD        rgbShadow;
extern DWORD        rgbHilight;
extern DWORD        rgbFrame;
extern int          nSysColorChanges;


#if WINVER >= 0x0400
#ifndef NOBITMAPBTN

/* -------------------------------------------------------------------------
** Bitmap button styles
** -------------------------------------------------------------------------
*/

/*
** If you want little tool tips to popup next to your toolbar buttons
** use the style below.
*/
#define BBS_TOOLTIPS    0x00000100L   /* make/use a tooltips control */



/* -------------------------------------------------------------------------
** Bitmap button states
** -------------------------------------------------------------------------
*/
#define BTNSTATE_PRESSED     ODS_SELECTED
#define BTNSTATE_DISABLED    ODS_DISABLED
#define BTNSTATE_HAS_FOCUS   ODS_FOCUS




/* -------------------------------------------------------------------------
** Bitmap button structures
** -------------------------------------------------------------------------
*/
typedef struct {
    int     iBitmap;    /* Index into mondo bitmap of this button's picture */
    UINT    uId;        /* Button ID */
    UINT    fsState;    /* Button's state, see BTNSTATE_XXXX above */
} BITMAPBTN, NEAR *PBITMAPBTN, FAR *LPBITMAPBTN;




/* -------------------------------------------------------------------------
** Bitmap buttons public interfaces
** -------------------------------------------------------------------------
*/

BOOL WINAPI
BtnCreateBitmapButtons(
    HWND hwndOwner,
    HINSTANCE hBMInst,
    UINT wBMID,
    UINT uStyle,
    LPBITMAPBTN lpButtons,
    int nButtons,
    int dxBitmap,
    int dyBitmap
    );

void WINAPI
BtnDestroyBitmapButtons(
    HWND hwndOwner
    );

void WINAPI
BtnDrawButton(
    HWND hwndOwner,
    HDC hdc,
    int dxButton,
    int dyButton,
    LPBITMAPBTN lpButton
    );

void WINAPI
BtnDrawFocusRect(
    HDC hdc,
    const RECT *lpRect,
    UINT fsState
    );

void WINAPI
BtnUpdateColors(
    HWND hwndOwner
    );
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\soundrec\convert.h ===
LPTSTR SoundRec_GetFormatName(LPWAVEFORMATEX pwfx);

MMRESULT FAR PASCAL
ChooseDestinationFormat(
    HINSTANCE       hInst,
    HWND            hwndParent,
    PWAVEFORMATEX   pwfxIn,
    PWAVEFORMATEX   *ppwfxOut,
    DWORD           fdwEnum);

typedef struct tPROGRESS {
    HWND            hPrg;           // window to post progress messages
    DWORD           dwTotal;        // percent of full process this requires
    DWORD           dwComplete;     // fixed percent completed
} PROGRESS, *PPROGRESS, FAR * LPPROGRESS;

UINT_PTR CALLBACK SaveAsHookProc(
    HWND    hdlg,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam);

MMRESULT
ConvertFormat(
    PWAVEFORMATEX   pwfxSrc,        // pwfx specifying source format
    DWORD           cbSrc,          // size of the source buffer
    LPBYTE          pbSrc,          // source buffer
    PWAVEFORMATEX   pwfxDst,        // pwfx specifying dest format
    DWORD *         pcbDst,         // return size of the dest buffer
    LPBYTE *        ppbDst,         // dest buffer
    DWORD           cBlks,          // number of blocks
    PPROGRESS       pPrg);          // progress update

MMRESULT
ConvertMultipleFormats(
    PWAVEFORMATEX   pwfxSrc,        // pwfx specifying source format
    DWORD           cbSrc,          // size of the source buffer
    LPBYTE          pbSrc,          // source buffer
    PWAVEFORMATEX   pwfxDst,        // pwfx specifying dest format
    DWORD *         pcbDst,         // return size of the dest buffer
    LPBYTE *        ppbDst,         // dest buffer
    DWORD           cBlks,          // number of blocks
    PPROGRESS       pPrg);          // progress update

MMRESULT
ConvertFormatDialog(
    HWND            hParent,
    PWAVEFORMATEX   pwfxSrc,        // pwfx specifying source format
    DWORD           cbSrc,          // size of the source buffer
    LPBYTE          pbSrc,          // source buffer
    PWAVEFORMATEX   pwfxDst,        // pwfx specifying dest format
    DWORD *         pcbDst,         // return size of the dest buffer
    LPBYTE *        ppbDst,         // dest buffer
    DWORD           cBlks,          // number of blocks
    PPROGRESS       pPrg);          // progress update


typedef struct t_SGLOBALS {
    PWAVEFORMATEX   *ppwfx;
    DWORD           *pcbwfx;
    DWORD           *pcbdata;
    LPBYTE          *ppbdata;
    LONG            *plSamples;     // number of samples 
    LONG            *plSamplesValid;// number of valid samples
    LONG            *plWavePosition;// current sample position
} SGLOBALS, *PSGLOBALS, FAR * LPSGLOBALS;

/* extend use of this throughout soundrec */
typedef struct t_WAVEDOC
{
    PWAVEFORMATEX   pwfx;       // format
    LPBYTE          pbdata;     // sample data
    DWORD           cbdata;     // sizeof data buffer
    LPTSTR          pszFileName;    // document file name
    LPTSTR          pszCopyright; // copyright info
    HICON           hIcon;      // document icon
    BOOL            fChanged;   // changed in viewing
    LPVOID          lpv;        // extra
} WAVEDOC, *PWAVEDOC, FAR *LPWAVEDOC;

BOOL SoundRec_Properties(HWND hwnd, HINSTANCE hinst, PWAVEDOC pwd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\soundrec\errorbox.c ===
/* (C) Copyright Microsoft Corporation 1991-1994.  All Rights Reserved */
/*******************************************************************
 *
 *  ERRORBOX.C
 *
 *  Routines for dealing with Resource-string based message
 *  boxes.
 *
 *******************************************************************/
/* Revision History.
 *   4/2/91 LaurieGr (AKA LKG) Ported to WIN32 / WIN16 common code
 *  22/Feb/94 LaurieGr Merged Motown and Daytona versions
 */

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include "soundrec.h"
#include <stdarg.h>
#include <stdio.h>


/*
 * @doc INTERNAL
 *
 * @func short | ErrorResBox | This function displays a message box using
 * program resource error strings.
 *
 * @parm    HWND | hwnd | Specifies the message box parent window.
 *
 * @parm    HANDLE | hInst | Specifies the instance handle of the module
 * that contains the resource strings specified by <p idAppName> and
 * <p idErrorStr>.  If this value is NULL, the instance handle is
 * obtained from <p hwnd> (in which case <p hwnd> may not be NULL).
 *
 * @parm    UINT | flags | Specifies message box types controlling the
 * message box appearance.  All message box types valid for <f MessageBox> are
 * valid.
 *
 * @parm    UINT | idAppName | Specifies the resource ID of a string that
 * is to be used as the message box caption.
 *
 * @parm    UINT | idErrorStr | Specifies the resource ID of a error
 * message format string.  This string is of the style passed to
 * <f wsprintf>, containing the standard C argument formatting
 * characters.  Any procedure parameters following <p idErrorStr> will
 * be taken as arguments for this format string.
 *
 * @parm    arguments | [ arguments, ... ] | Specifies additional
 * arguments corresponding to the format specification given by
 * <p idErrorStr>.  All string arguments must be FAR pointers.
 *
 * @rdesc   Returns the result of the call to <f MessageBox>.  If an
 * error occurs, returns zero.
 *
 * @comm    This is a variable arguments function, the parameters after
 * <p idErrorStr> being taken for arguments to the <f printf> format
 * string specified by <p idErrorStr>.  The string resources specified
 * by <p idAppName> and <p idErrorStr> must be loadable using the
 * instance handle <p hInst>.  If the strings cannot be
 * loaded, or <p hwnd> is not valid, the function will fail and return
 * zero.
 *
 */
#define STRING_SIZE 1024

short FAR _cdecl
ErrorResBox (
    HWND        hwnd,
    HANDLE      hInst,
    UINT        flags,
    UINT        idAppName,
    UINT        idErrorStr,
    ... )
{
    PTSTR    sz = NULL;
    PTSTR    szFmt = NULL;
    UINT    w;
    va_list va;         // got to do this for DEC Alpha platform
                        // where parameter lists are different.

    if (hInst == NULL) {
        if (hwnd == NULL) {
            MessageBeep(0);
            return FALSE;
        }
        hInst = (HANDLE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE);
    }

    w = 0;

    sz = (PTSTR) GlobalAllocPtr(GHND, STRING_SIZE*sizeof(TCHAR));
    szFmt = (PTSTR) GlobalAllocPtr(GHND, STRING_SIZE*sizeof(TCHAR));
    if (!sz || !szFmt)
        goto ExitError; // no mem, get out

    if (!LoadString(hInst, idErrorStr, szFmt, STRING_SIZE))
        goto ExitError;

    va_start(va, idErrorStr);
    wvsprintf(sz, szFmt, va);
    va_end(va);

    if (!LoadString(hInst, idAppName, szFmt, STRING_SIZE))
        goto ExitError;

    if (gfErrorBox) {
#if DBG
        TCHAR szTxt[256];
        wsprintf(szTxt, TEXT("!ERROR '%s'\r\n"), sz);
        OutputDebugString(szTxt);
#endif
        return 0;
    }
    else {
        gfErrorBox++;
        w = MessageBox(hwnd, sz, szFmt, flags);
        gfErrorBox--;
    }

ExitError:
    if (sz) GlobalFreePtr(sz);
    if (szFmt) GlobalFreePtr(szFmt);
    return (short)w;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\soundrec\file.c ===
/* (C) Copyright Microsoft Corporation 1991-1994.  All Rights Reserved */
/* file.c
 *
 * File I/O and related functions.
 *
 * Revision history:
 *  4/2/91      LaurieGr (AKA LKG) Ported to WIN32 / WIN16 common code
 *  5/27/92     -jyg- Added more RIFF support to BOMBAY version
 *  22/Feb/94   LaurieGr merged Motown and Daytona version
 */

#include "nocrap.h"
#include <windows.h>
#include <commdlg.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <windowsx.h>

#define INCLUDE_OLESTUBS
#include "SoundRec.h"
#include "srecids.h"

#ifdef CHICAGO
# if WINVER >= 0x0400
#  include <shellapi.h>
# else
#  include <shell2.h>
# endif
#endif

#include "file.h"
#include "convert.h"
#include "reg.h"

#define STRSAFE_LIB
#include <strsafe.h>

/* globals */
PCKNODE gpcknHead = NULL;   // ??? eugh. more globals!
PCKNODE gpcknTail = NULL;

static PFACT spFact = NULL;
static long scbFact = 0;

static void FreeAllChunks(PCKNODE *ppcknHead, PCKNODE *ppcknTail);
static BOOL AddChunk(LPMMCKINFO lpCk, HPBYTE hb, PCKNODE * ppcknHead,
    PCKNODE * ppcknTail);
static PCKNODE FreeHeadChunk(PCKNODE *ppcknHead);


/*
 * Is the current document untitled?
 */
BOOL IsDocUntitled()
{
    return (lstrcmp(gachFileName, aszUntitled) == 0);
}

/*
 * Rename the current document.
 */
void RenameDoc(LPTSTR aszNewFile)
{
	HRESULT hr;
    
	hr = StringCchCopy(gachFileName, SIZEOF(gachFileName), aszNewFile);
	Assert( hr == S_OK );
	hr = StringCchCopy(gachLinkFilename, SIZEOF(gachLinkFilename), gachFileName);
	Assert( hr == S_OK );
    if (gfLinked)
        AdviseRename(gachLinkFilename);
}
    
/* MarkWaveDirty: Mark the wave as dirty. */
void FAR PASCAL
EndWaveEdit(BOOL fDirty)
{
    if (fDirty)
    {
        gfDirty = TRUE;
        AdviseDataChange();
        
        DoOleSave();
        AdviseSaved();
    }
}

void FAR PASCAL
BeginWaveEdit(void)
{
    FlushOleClipboard();
}

/* fOK = PromptToSave()
 *
 * If the file is dirty (modified), ask the user "Save before closing?".
 * Return TRUE if it's okay to continue, FALSE if the caller should cancel
 * whatever it's doing.
 */
PROMPTRESULT FAR PASCAL
PromptToSave(
    BOOL        fMustClose,
    BOOL        fSetForground)
{
    WORD        wID;
    DWORD       dwMB = MB_ICONEXCLAMATION | MB_YESNOCANCEL;

    if (fSetForground)
        dwMB |= MB_SETFOREGROUND;

    /* stop playing/recording */
    StopWave();


    if (gfDirty && gfStandalone && gfDirty != -1) {   // changed and possible to save
        wID = ErrorResBox( ghwndApp
                         , ghInst
                         , dwMB
                         , IDS_APPTITLE
                         , IDS_SAVECHANGES
                         , (LPTSTR) gachFileName
                         );
        if (wID == IDCANCEL)
        {
            return enumCancel;
        }
        else if (wID == IDYES)
        {
            if (!FileSave(FALSE))
                return enumCancel;
        }
        else
            return enumRevert;
        
    }

#if 0
// is this necessary?
    
// This is bad.  It notifies the container before we actually
// DoOleClose.  This will cause some containers (Excel 5.0c) to
// get confused and nuke client sites on non-dirty objects.
                
    else if (fMustClose)
    {
        DebugBreak();
        AdviseClosed();
    }
#endif
    return enumSaved;
} /* PromptToSave */


/* fOK = CheckIfFileExists(szFileName)
 *
 * The user specified <szFileName> as a file to write over -- check if
 * this file exists.  Return TRUE if it's okay to continue (i.e. the
 * file doesn't exist, or the user OK'd overwriting it),
 * FALSE if the caller should cancel whatever it's doing.
 */
static BOOL NEAR PASCAL
CheckIfFileExists( LPTSTR       szFileName)     // file name to check
{
    HANDLE hFile;
    hFile = CreateFile(szFileName,
                    GENERIC_READ|GENERIC_WRITE,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);
    if (hFile == INVALID_HANDLE_VALUE)
            return TRUE;        // doesn't exist
    CloseHandle(hFile);
            
    /* prompt user for permission to overwrite the file */
    return ErrorResBox(ghwndApp, ghInst, MB_ICONQUESTION | MB_OKCANCEL,
             IDS_APPTITLE, IDS_FILEEXISTS, szFileName) == IDOK;
}

#define SLASH(c)     ((c) == TEXT('/') || (c) == TEXT('\\'))


/* return a pointer to the filename part of the path
   i.e. scan back from end to \: or start
   e.g. "C:\FOO\BAR.XYZ"  -> return pointer to "BAR.XYZ"
*/
LPCTSTR FAR PASCAL
FileName(LPCTSTR szPath)
{
    LPCTSTR   sz;
    if (!szPath)
        return NULL;
    for (sz=szPath; *sz; sz = CharNext(sz))
        ;
    for (; !SLASH(*sz) && *sz!=TEXT(':'); sz = CharPrev(szPath,sz))
        if (sz == szPath)
            return sz;
    
    return CharNext(sz);
}



/* UpdateCaption()
 *
 * Set the caption of the app window.
 */
void FAR PASCAL
UpdateCaption(void)
{
	HRESULT  hr;
    TCHAR    ach[_MAX_PATH + _MAX_FNAME + _MAX_EXT - 2];
    static SZCODE aszTitleFormat[] = TEXT("%s - %s");
#ifdef CHICAGO
    SHFILEINFO shfi;
        
    if (!IsDocUntitled() && SHGetFileInfo(gachFileName, 0, &shfi, sizeof(shfi), SHGFI_ICON|SHGFI_DISPLAYNAME ))
    {
        hr = StringCchPrintf(ach, SIZEOF(ach), aszTitleFormat, shfi.szDisplayName, (LPTSTR)gachAppTitle);
        SetWindowText(ghwndApp, ach);
        SetClassLongPtr(ghwndApp, GCLP_HICON, (DWORD_PTR)shfi.hIcon);
        return;
    }
    else
    {
        //
        // reset icon to app icon
        //
        extern HICON ghiconApp;
        SetClassLongPtr(ghwndApp, GCLP_HICON, (LONG_PTR)ghiconApp);
    }
#endif
    hr = StringCchPrintf(ach, SIZEOF(ach), aszTitleFormat, FileName(gachFileName), (LPTSTR)gachAppTitle);
    SetWindowText(ghwndApp, ach);

} /* UpdateCaption */

//REVIEW:  The functionality in FileOpen and FileNew should be more
//         safe for OLE.  This means, we want to open a file, but
//         have no reason to revoke the server.


/* FileNew(fmt, fUpdateDisplay, fNewDlg)
 *
 * Make a blank document.
 *
 * If <fUpdateDisplay> is TRUE, then update the display after creating a new file.
 */
BOOL FAR PASCAL FileNew(
    WORD    fmt,
    BOOL    fUpdateDisplay,
    BOOL    fNewDlg)
{
	HRESULT hr;
    //
    // avoid reentrancy when called through OLE
    //

    // ??? Need to double check on this.  Is this thread safe?
    // ??? Does it need to be thread safe?  Or are we actually
    // ??? just trying to avoid recursion rather than reentrancy?

    if (gfInFileNew)
        return FALSE;

    //
    // stop playing/recording
    //
    StopWave();

    //
    // Commit all pending objects.
    //
    FlushOleClipboard();

    //
    //  some client's (ie Excel 3.00 and PowerPoint 1.0) don't
    //  handle saved notifications, they expect to get a
    //  OLE_CLOSED message.
    //
    //  if the user has chosen to update the object, but the client did
    //  not then send a OLE_CLOSED message.
    //
    if (gfEmbeddedObject && gfDirty == -1)
        AdviseClosed();

    //  
    // FileNew can be called either from FileOpen or from a menu
    // or from the server, etc...  We should behave as FileOpen from the
    // server (i.e. the dialog can be canceled without toasting the buffer)
    //
    if (!NewWave(fmt,fNewDlg))
        return FALSE;

    //        
    // update state variables
    //
    hr = StringCchCopy(gachFileName, SIZEOF(gachFileName), aszUntitled);
	Assert( hr == S_OK );
    BuildUniqueLinkName();
    
    gfDirty = FALSE;                        // file was modified and not saved?

    if (fUpdateDisplay) {
        UpdateCaption();
        UpdateDisplay(TRUE);
    }

    FreeAllChunks(&gpcknHead, &gpcknTail);    // free all old info

    return TRUE;
} /* FileNew */


/* REVIEW:  The functionality in FileOpen and FileNew should be more
 *          safe for OLE.  This means, we want to open a file, but
 *          have no reason to revoke the server.
 * */

BOOL FileLoad(
    LPCTSTR     szFileName)
{
    TCHAR       aszFile[_MAX_PATH];	// SIZEOF(aszFile) must be <= SIZEOF(gachFileName)
    HCURSOR     hcurPrev = NULL;    // cursor before hourglass
    HMMIO       hmmio;
    BOOL        fOk = TRUE;

    StopWave();

    // qualify 
    GetFullPathName(szFileName,SIZEOF(aszFile),aszFile,NULL);
    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));
    
    // read the WAVE file
    hmmio = mmioOpen(aszFile, NULL, MMIO_READ | MMIO_ALLOCBUF);
    
    if (hmmio != NULL)
    {
        MMRESULT        mmr;
        LPWAVEFORMATEX  pwfx;
        DWORD           cbwfx;
        DWORD           cbdata;
        LPBYTE          pdata;

        PCKNODE         pcknHead = gpcknHead;
        PCKNODE         pcknTail = gpcknTail;
        PFACT           pfct = spFact;
        LONG            cbfact = scbFact;
                
        gpcknHead       = NULL;
        gpcknTail       = NULL;
        spFact          = NULL;
        scbFact         = 0L;
                
        mmr = ReadWaveFile(hmmio
                           , &pwfx
                           , &cbwfx
                           , &pdata
                           , &cbdata
                           , aszFile
                           , TRUE);
        
        mmioClose(hmmio, 0);

        if (mmr != MMSYSERR_NOERROR || pwfx == NULL)
        {
            //
            // restore the cache globals
            //
            gpcknHead = pcknHead;
            gpcknTail = pcknTail;
            spFact = pfct;
            scbFact = cbfact;
            
            if (pwfx == NULL)
            {
                if (pdata)
                    GlobalFreePtr(pdata);
            }
            goto RETURN_ERROR;
        }
        
        DestroyWave();
        
        gpWaveFormat = pwfx;  
        gcbWaveFormat = cbwfx;
        gpWaveSamples = pdata;
        glWaveSamples = cbdata;

        //
        // destroy the cache temps
        //
        FreeAllChunks(&pcknHead, &pcknTail);
        if (pfct)
            GlobalFreePtr((LPVOID)pfct);
        
    }
    else
    {
        ErrorResBox(ghwndApp
                    , ghInst
                    , MB_ICONEXCLAMATION | MB_OK
                    , IDS_APPTITLE
                    , IDS_ERROROPEN
                    , (LPTSTR) aszFile);
        
        goto RETURN_ERROR;
    }

    //
    // update state variables
    //
    RenameDoc(aszFile);
    
    glWaveSamplesValid = glWaveSamples;
    glWavePosition = 0L;
    
    goto RETURN_SUCCESS;
    
RETURN_ERROR:
    fOk = FALSE;
#if 0    
    FreeAllChunks(&gpcknHead, &gpcknTail);     /* free all old info */
#endif
    
RETURN_SUCCESS:

    if (hcurPrev != NULL)
        SetCursor(hcurPrev);

    /* Only mark clean on success */
    if (fOk)
        gfDirty = FALSE;

    /* update the display */
    UpdateCaption();
    UpdateDisplay(TRUE);

    return fOk;
}

/* FileOpen(szFileName)
 *
 * If <szFileName> is NULL, do a File/Open command.  Otherwise, open
 * <szFileName>.  Return TRUE on success, FALSE otherwise.
 */
BOOL FAR PASCAL
FileOpen(
    LPCTSTR     szFileName) // file to open (or NULL)
{
    TCHAR       ach[80];    // buffer for string loading
    TCHAR       aszFile[_MAX_PATH];	// SIZEOF(aszFile) must be <= SIZEOF(gachFileName)
    HCURSOR     hcurPrev = NULL;    // cursor before hourglass
    HMMIO       hmmio;
    BOOL        fOk = TRUE;

    //
    // stop playing/recording
    //
    StopWave();

    //
    // Commit all pending objects.
    //
    FlushOleClipboard();

    if (!PromptToSave(FALSE, FALSE))
        goto RETURN_ERRORNONEW;

    //
    // get the new file name into <ofs.szPathName>
    //
    if (szFileName == NULL)
    {
        OPENFILENAME    ofn;
        BOOL f;

        //
        // prompt user for file to open
        //
        LoadString(ghInst, IDS_OPEN, ach, SIZEOF(ach));
        aszFile[0] = 0;
        ofn.lStructSize     = sizeof(OPENFILENAME);
        ofn.hwndOwner       = ghwndApp;
        ofn.hInstance       = NULL;
        ofn.lpstrFilter     = aszFilter;
        ofn.lpstrCustomFilter = NULL;
        ofn.nMaxCustFilter  = 0;
        ofn.nFilterIndex    = 1;
        ofn.lpstrFile       = aszFile;
        ofn.nMaxFile        = SIZEOF(aszFile);
        ofn.lpstrFileTitle  = NULL;
        ofn.nMaxFileTitle   = 0;
        ofn.lpstrInitialDir = NULL;
        ofn.lpstrTitle      = ach;
        ofn.Flags           =   OFN_FILEMUSTEXIST
                              | OFN_PATHMUSTEXIST
#ifdef CHICAGO
                              | OFN_EXPLORER
#endif                                
                              | OFN_HIDEREADONLY;
        ofn.lpfnHook        = NULL;
        ofn.nFileOffset     = 0;
        ofn.nFileExtension  = 0;
        ofn.lpstrDefExt     = gachDefFileExt;
        ofn.lCustData       = 0;
        ofn.lpTemplateName  = NULL;
        f = GetOpenFileName(&ofn);

        if (!f)
            goto RETURN_ERRORNONEW;
    }
    else
    {

        GetFullPathName(szFileName,SIZEOF(aszFile),aszFile,NULL);
    }

    UpdateWindow(ghwndApp);

    //
    // show hourglass cursor
    //
    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    // read the WAVE file
    //
    hmmio = mmioOpen(aszFile, NULL, MMIO_READ | MMIO_ALLOCBUF);
    if (hmmio != NULL)
    {
        MMRESULT        mmr;
        LPWAVEFORMATEX  pwfx;
        DWORD           cbwfx;
        DWORD           cbdata;
        LPBYTE          pdata;

        PCKNODE         pcknHead = gpcknHead;
        PCKNODE         pcknTail = gpcknTail;
        PFACT           pfct = spFact;
        LONG            cbfact = scbFact;
                
        gpcknHead       = NULL;
        gpcknTail       = NULL;
        spFact          = NULL;
        scbFact         = 0L;
        
        mmr = ReadWaveFile(hmmio
                           , &pwfx
                           , &cbwfx
                           , &pdata
                           , &cbdata
                           , aszFile
                           , TRUE);
        
        mmioClose(hmmio, 0);

        if (mmr != MMSYSERR_NOERROR || pwfx == NULL)
        {
            //
            // restore the cache globals
            //
            gpcknHead = pcknHead;
            gpcknTail = pcknTail;
            spFact = pfct;
            scbFact = cbfact;
            
            if (pwfx == NULL)
            {
                if (pdata)
                    GlobalFreePtr(pdata);
            }
            goto RETURN_ERRORNONEW;
        }

        DestroyWave();
        
        gpWaveFormat = pwfx;  
        gcbWaveFormat = cbwfx;
        gpWaveSamples = pdata;
        glWaveSamples = cbdata;

        //
        // destroy the cache temps
        //
        FreeAllChunks(&pcknHead, &pcknTail);
        if (pfct)
            GlobalFreePtr((LPVOID)pfct);
    }
    else
    {
        ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
            IDS_APPTITLE, IDS_ERROROPEN, (LPTSTR) aszFile);
        goto RETURN_ERRORNONEW;
    }

    //
    // update state variables
    //
    RenameDoc(aszFile);
    glWaveSamplesValid = glWaveSamples;
    glWavePosition = 0L;

    goto RETURN_SUCCESS;

#if 0    
RETURN_ERROR:               // do error exit without error message

    FileNew(FMT_DEFAULT, FALSE, FALSE);// revert to "(Untitled)" state

    /* fall through */
#endif
RETURN_ERRORNONEW:          // same as above, but don't do "new"

    fOk = FALSE;
    /* fall through */

RETURN_SUCCESS:             // normal exit

    if (hcurPrev != NULL)
        SetCursor(hcurPrev);

    /* Only mark clean on success */
    if (fOk)
        gfDirty = FALSE;

    /* update the display */
    UpdateCaption();
    UpdateDisplay(TRUE);

    return fOk;
} /* FileOpen */



/* fOK = FileSave(fSaveAs)
 *
 * Do a File/Save operation (if <fSaveAs> is FALSE) or a File/SaveAs
 * operation (if <fSaveAs> is TRUE).  Return TRUE unless the user cancelled
 * or an error occurred.
 */
BOOL FAR PASCAL FileSave(
    BOOL  fSaveAs)        // do a "Save As" instead of "Save"?
{
    BOOL        fOK = TRUE; // function succeeded?
    TCHAR       ach[80];    // buffer for string loading
    TCHAR       aszFile[_MAX_PATH];	// SIZEOF(aszFile) must be <= SIZEOF(gachFileName)
    BOOL        fUntitled;  // file is untitled?
    HCURSOR     hcurPrev = NULL; // cursor before hourglass
    HMMIO       hmmio;
	HRESULT		hr;
   
    // temp arguments to WriteWaveFile if a conversion is requested
    PWAVEFORMATEX pwfxSaveAsFormat = NULL;
    
    /* stop playing/recording */
    StopWave();

    fUntitled = IsDocUntitled();

    if (fSaveAs || fUntitled)
    {
        OPENFILENAME  ofn;
        BOOL          f;

        // prompt user for file to save 
        LoadString(ghInst, IDS_SAVE, ach, SIZEOF(ach));
        
        if (!gfEmbeddedObject && !fUntitled)
		{
            hr = StringCchCopy(aszFile, SIZEOF(aszFile), gachFileName);
			Assert( hr == S_OK );
			if( hr != S_OK )
			{
	            aszFile[0] = 0;
			}
		}
        else
            aszFile[0] = 0;

        ofn.lStructSize     = sizeof(OPENFILENAME);
        ofn.hwndOwner       = ghwndApp;
        ofn.hInstance       = ghInst;
        ofn.lpstrFilter     = aszFilter;
        ofn.lpstrCustomFilter = NULL;
        ofn.nMaxCustFilter  = 0;
        ofn.nFilterIndex    = 1;
        ofn.lpstrFile       = aszFile;
        ofn.nMaxFile        = SIZEOF(aszFile);
        ofn.lpstrFileTitle  = NULL;
        ofn.nMaxFileTitle   = 0;
        ofn.lpstrInitialDir = NULL;
        ofn.lpstrTitle      = ach;
        ofn.Flags           =   OFN_PATHMUSTEXIST
                              | OFN_HIDEREADONLY
#ifdef CHICAGO
                              | OFN_EXPLORER
#endif                              
                              | OFN_NOREADONLYRETURN;
        ofn.nFileOffset     = 0;
        ofn.nFileExtension  = 0;
        ofn.lpstrDefExt     = gachDefFileExt;
        
        //
        // We need to present a new Save As dialog template to add a convert
        // button.  Adding a convert button requires us to also hook and
        // handle the button message ourselves.
        //
        if (fSaveAs)
        {
            // pwfxSaveAsFormat will point to a new format if the user
            // requested it
            ofn.lCustData       = (LPARAM)(LPVOID)&pwfxSaveAsFormat;
            ofn.Flags           |= OFN_ENABLETEMPLATE | OFN_ENABLEHOOK;
            ofn.lpTemplateName  = MAKEINTRESOURCE(IDD_SAVEAS);
            ofn.lpfnHook        = SaveAsHookProc;
        }
        else
        {
            ofn.lpfnHook        = NULL;
            ofn.lpTemplateName  = NULL;
        }
        f = GetSaveFileName(&ofn);

        if (!f)
            goto RETURN_CANCEL;
        
        {
            //
            // Add extension if none given
            //
            LPTSTR lp;
            for (lp = (LPTSTR)&aszFile[lstrlen(aszFile)] ; *lp != TEXT('.')  ;)
            {
                if (SLASH(*lp) || *lp == TEXT(':') || lp == (LPTSTR)aszFile)
                {
                    extern TCHAR FAR aszClassKey[];
					hr = StringCchCat(aszFile, SIZEOF(aszFile), aszClassKey);
					if( hr != S_OK )
					{
						ErrorResBox(ghwndApp
									, ghInst
									, MB_ICONEXCLAMATION | MB_OK
									, IDS_APPTITLE
									, IDS_ERRORFILENAME
									, (LPTSTR) aszFile);
						goto RETURN_CANCEL;
					}
                    break;
                }
                lp = CharPrev(aszFile, lp);                
            }
        }

        // prompt for permission to overwrite the file 
        if (!CheckIfFileExists(aszFile))
            return FALSE;           // user cancelled

        if (gfEmbeddedObject && gfDirty)
        {
            int id;
            
            // see if user wants to update first 
            id = ErrorResBox( ghwndApp
                              , ghInst
                              , MB_ICONQUESTION | MB_YESNOCANCEL
                              , IDS_APPTITLE
                              , IDS_UPDATEBEFORESAVE);
            
            if (id == IDCANCEL)
                return FALSE;
            
            else if (id == IDYES)
            {
                DoOleSave();
                AdviseSaved();
                gfDirty = FALSE;
            }
        }
    }
    else
    {
        // Copy the current name to our temporary variable
        // We really should save to a different temporary file
        hr = StringCchCopy(aszFile, SIZEOF(aszFile), gachFileName);
		Assert( hr == S_OK );
		if( hr != S_OK )
		{
			ErrorResBox(ghwndApp
						, ghInst
						, MB_ICONEXCLAMATION | MB_OK
						, IDS_APPTITLE
						, IDS_ERRORFILENAME
						, (LPTSTR) aszFile);
			goto RETURN_CANCEL;
		}
    }

    // show hourglass cursor
    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // write the WAVE file 
    // open the file -- if it already exists, truncate it to zero bytes
    
    hmmio = mmioOpen(aszFile
                     , NULL
                     , MMIO_CREATE | MMIO_WRITE | MMIO_ALLOCBUF);
    
    if (hmmio == NULL) {
        ErrorResBox(ghwndApp
                    , ghInst
                    , MB_ICONEXCLAMATION | MB_OK
                    , IDS_APPTITLE
                    , IDS_ERROROPEN
                    , (LPTSTR) aszFile);

        goto RETURN_ERROR;
    }

    if (pwfxSaveAsFormat)
    {
        DWORD cbNew;
        DWORD cbOld;
        LPBYTE pbNew;

        cbOld = wfSamplesToBytes(gpWaveFormat, glWaveSamplesValid);
        if (ConvertFormatDialog(ghwndApp
                                , gpWaveFormat
                                , cbOld
                                , gpWaveSamples
                                , pwfxSaveAsFormat
                                , &cbNew
                                , &pbNew
                                , 0
                                , NULL) == MMSYSERR_NOERROR )
        {
            GlobalFreePtr(gpWaveFormat);
            GlobalFreePtr(gpWaveSamples);
            
            gpWaveFormat = pwfxSaveAsFormat;
            
            gcbWaveFormat = sizeof(WAVEFORMATEX);            
            if (pwfxSaveAsFormat->wFormatTag != WAVE_FORMAT_PCM)
                gcbWaveFormat += pwfxSaveAsFormat->cbSize;
            
            gpWaveSamples = pbNew;
            glWaveSamples = wfBytesToSamples(gpWaveFormat, cbNew);
            glWaveSamplesValid = wfBytesToSamples(gpWaveFormat, cbNew);
        }
        else
        {
            ErrorResBox(ghwndApp
                        , ghInst
                        , MB_ICONEXCLAMATION | MB_OK
                        , IDS_APPTITLE, IDS_ERR_CANTCONVERT);
            
            goto RETURN_ERROR;
        }
    }
    
    if (!WriteWaveFile(hmmio
                       , gpWaveFormat
                       , gcbWaveFormat
                       , gpWaveSamples
                       , glWaveSamplesValid))
    {
        mmioClose(hmmio,0);
        ErrorResBox(ghwndApp
                    , ghInst
                    , MB_ICONEXCLAMATION | MB_OK
                    , IDS_APPTITLE, IDS_ERRORWRITE
                    , (LPTSTR) aszFile );
        goto RETURN_ERROR;
    }

    mmioClose(hmmio,0);

    //
    // Only change file name if we succeed
    //
    RenameDoc(aszFile);

    UpdateCaption();
    
    if (fSaveAs || fUntitled)
    {
        AdviseRename(gachFileName);
    }
    else 
    {
        DoOleSave();
        gfDirty = FALSE;
    }
    
    goto RETURN_SUCCESS;

RETURN_ERROR:               // do error exit without error message
    DeleteFile(aszFile);

RETURN_CANCEL:

    fOK = FALSE;

    //
    // Clean up conversion selection
    //
    if (pwfxSaveAsFormat)
        GlobalFreePtr(pwfxSaveAsFormat);

RETURN_SUCCESS:             // normal exit

    if (hcurPrev != NULL)
        SetCursor(hcurPrev);

    if (fOK)
        gfDirty = FALSE;

    //
    // update the display
    //
    UpdateDisplay(TRUE);

    return fOK;
} /* FileSave*/




/* fOK = FileRevert()
 *
 * Do a File/Revert operation, i.e. let user revert to last-saved version.
 */
BOOL FAR PASCAL
     FileRevert(void)
{
    int     id;
    TCHAR       achFileName[_MAX_PATH];
    BOOL        fOk;
    BOOL        fDirtyOrig;
	HRESULT		hr;

    /* "Revert..." menu is grayed unless file is dirty and file name
     * is not "(Untitled)" and this is not an embedded object
     */

    /* prompt user for permission to discard changes */
    id = ErrorResBox(ghwndApp, ghInst, MB_ICONQUESTION | MB_YESNO,
        IDS_APPTITLE, IDS_CONFIRMREVERT);
    if (id == IDNO)
        return FALSE;

    /* discard changes and re-open file */
    hr = StringCchCopy(achFileName, SIZEOF(achFileName), gachFileName); // FileNew nukes <gachFileName>
	Assert( hr == S_OK );
	if( hr == S_OK )
	{
		/* Make file clean temporarily, so FileOpen() won't warn user */
		fDirtyOrig = gfDirty;
		gfDirty = FALSE;

		fOk = FileOpen(achFileName);
		if (!fOk)
			gfDirty = fDirtyOrig;
	}
	else
	{
		ErrorResBox(ghwndApp
					, ghInst
					, MB_ICONEXCLAMATION | MB_OK
					, IDS_APPTITLE
					, IDS_ERRORFILENAME
					, (LPTSTR) achFileName);
		fOk = FALSE;
	}

    return fOk;
} /* FileRevert */




/* ReadWaveFile
 *
 * Read a WAVE file from <hmmio>.  Fill in <*pWaveFormat> with
 * the WAVE file format and <*plWaveSamples> with the number of samples in
 * the file.  Return a pointer to the samples (stored in a GlobalAlloc'd
 * memory block) or NULL on error.
 *
 * <szFileName> is the name of the file that <hmmio> refers to.
 * <szFileName> is used only for displaying error messages.
 *
 * On failure, an error message is displayed.
 */
MMRESULT ReadWaveFile(
    HMMIO           hmmio,          // handle to open file
    LPWAVEFORMATEX* ppWaveFormat,   // fill in with the WAVE format
    DWORD *         pcbWaveFormat,  // fill in with WAVE format size
    LPBYTE *        ppWaveSamples,
    DWORD *         plWaveSamples,  // number of samples
    LPTSTR          szFileName,     // file name (or NULL) for error msg.
    BOOL            fCacheRIFF)     // cache RIFF?
{
    MMCKINFO      ckRIFF;              // chunk info. for RIFF chunk
    MMCKINFO      ck;                  // info. for a chunk file
    HPBYTE        pWaveSamples = NULL; // waveform samples
    UINT          cbWaveFormat;
    WAVEFORMATEX* pWaveFormat = NULL;
    BOOL          fHandled;
    DWORD         dwBlkAlignSize = 0; // initialisation only to eliminate spurious warning
    MMRESULT      mmr = MMSYSERR_NOERROR;
    
    //
    // added for robust RIFF checking
    //
    BOOL          fFMT=FALSE, fDATA=FALSE, fFACT=FALSE;
    DWORD         dwCkEnd,dwRiffEnd;
    
    if (ppWaveFormat == NULL
        || pcbWaveFormat == NULL
        || ppWaveSamples == NULL
        || plWaveSamples == NULL )
       return MMSYSERR_ERROR;

    *ppWaveFormat   = NULL;
    *pcbWaveFormat  = 0L;
    *ppWaveSamples  = NULL;
    *plWaveSamples  = 0L;

    //
    // descend the file into the RIFF chunk
    //
    if (mmioDescend(hmmio, &ckRIFF, NULL, 0) != 0)
    {
        //
        // Zero length files are OK.
        //
        if (mmioSeek(hmmio, 0L, SEEK_END) == 0L)
        {
            DWORD           cbwfx;
            LPWAVEFORMATEX  pwfx;

            //
            // Synthesize a wave header
            //
            if (!SoundRec_GetDefaultFormat(&pwfx, &cbwfx))
            {
                cbwfx = sizeof(WAVEFORMATEX);
                pwfx  = (WAVEFORMATEX *)GlobalAllocPtr(GHND, sizeof(WAVEFORMATEX));

                if (pwfx == NULL)
                    return MMSYSERR_NOMEM;

                CreateWaveFormat(pwfx,FMT_DEFAULT,(UINT)WAVE_MAPPER);
            }
            *ppWaveFormat   = pwfx;
            *pcbWaveFormat  = cbwfx;
            *plWaveSamples  = 0L;
            *ppWaveSamples  = NULL;

            return MMSYSERR_NOERROR;
        }
        else
            goto ERROR_NOTAWAVEFILE;
    }

    /* make sure the file is a WAVE file */
    if ((ckRIFF.ckid != FOURCC_RIFF) ||
        (ckRIFF.fccType != mmioFOURCC('W', 'A', 'V', 'E')))
        goto ERROR_NOTAWAVEFILE;

    /* We can preserve the order of chunks in memory
     * by parsing the entire file as we read it in.
     */

    /* Use AddChunk(&ck,NULL) to add a placeholder node
     * for a chunk being edited.
     * Else AddChunk(&ck,hpstrData)
     */
    dwRiffEnd = ckRIFF.cksize;
    dwRiffEnd += (dwRiffEnd % 2);   /* must be even */

    while ( mmioDescend( hmmio, &ck, &ckRIFF, 0) == 0)
    {
        fHandled = FALSE;

        dwCkEnd = ck.cksize + (ck.dwDataOffset - ckRIFF.dwDataOffset);
        dwCkEnd += (dwCkEnd % 2);   /* must be even */

        if (dwCkEnd > dwRiffEnd)
        {
            DPF(TEXT("Chunk End %lu> Riff End %lu\n"),dwCkEnd,dwRiffEnd);

            /* CORRUPTED RIFF, when we ascend we'll be past the
             * end of the RIFF
             */

            if (fFMT && fDATA)
            {
                /* We might have enough information to deal
                 * with clipboard mixing/inserts, etc...
                 * This is for the bug with BOOKSHELF '92
                 * where they give us RIFF with a
                 * RIFF.dwSize > sum(childchunks).
                 * They *PROMISE* not to do this again.
                 */
                mmioAscend( hmmio, &ck, 0 );
                goto RETURN_FINISH;

            }
            goto ERROR_READING;
        }

        switch ( ck.ckid )
        {
            case mmioFOURCC('f','m','t',' '):
                if (fFMT)
                    break; /* we've been here before */

                /* expect the 'fmt' chunk to be at least as
                 * large as <sizeof(WAVEFORMAT)>;
                 * if there are extra parameters at the end,
                 * we'll ignore them
                 */
                // 'fmt' chunk too small?
                if (ck.cksize < sizeof(WAVEFORMAT))
                    goto ERROR_NOTAWAVEFILE;

                /*
                 *  always force allocation to be AT LEAST
                 *  the size of WFX. this is required so all
                 *  code does not have to special case the
                 *  cbSize field. note that we alloc with zero
                 *  init so cbSize will be zero for plain
                 *  jane PCM
                 */
                cbWaveFormat = max((WORD)ck.cksize,
                                    sizeof(WAVEFORMATEX));
                pWaveFormat = (WAVEFORMATEX*)GlobalAllocPtr(GHND, cbWaveFormat);

                if (pWaveFormat == NULL)
                    goto ERROR_FILETOOLARGE;
                /*
                 *  set the size back to the actual size
                 */
                cbWaveFormat = (WORD)ck.cksize;

                *ppWaveFormat  = pWaveFormat;
                *pcbWaveFormat = cbWaveFormat;

                /* read the file format into <*pWaveFormat> */
                if (mmioRead(hmmio, (HPSTR)pWaveFormat, ck.cksize) != (long)ck.cksize)
                    goto ERROR_READING; // truncated file, probably

                if (fCacheRIFF && !AddChunk(&ck,NULL,&gpcknHead,&gpcknTail))
                {
                    goto ERROR_FILETOOLARGE;
                }

//Sanity check for PCM Formats:
                if (pWaveFormat->wFormatTag == WAVE_FORMAT_PCM)
                {
                    pWaveFormat->nBlockAlign = pWaveFormat->nChannels *
                                                ((pWaveFormat->wBitsPerSample + 7)/8);
                    pWaveFormat->nAvgBytesPerSec = pWaveFormat->nBlockAlign *
                                                    pWaveFormat->nSamplesPerSec;
                }

                fFMT = TRUE;
                fHandled = TRUE;
                break;

            case mmioFOURCC('d','a','t','a'):
                /* deal with the 'data' chunk */

                if (fDATA)
                    break; /* we've been here before */

                if (!pWaveFormat)
                    goto ERROR_READING;

//***           is dwBlkAlignSize?  Don't you want to use nBlkAlign
//***           to determine this value?
#if 0
                dwBlkAlignSize = ck.cksize;
                dwBlkAlignSize += (ck.cksize%pWaveFormat.nBlkAlign);
                *pcbWaveSamples = ck.cksize;

#else
                dwBlkAlignSize = wfBytesToBytes(pWaveFormat, ck.cksize);
#endif

                if ((pWaveSamples = GlobalAllocPtr(GHND | GMEM_SHARE
                                                   , dwBlkAlignSize+4)) == NULL)

                    goto ERROR_FILETOOLARGE;

                /* read the samples into the memory buffer */
                if (mmioRead(hmmio, (HPSTR)pWaveSamples, dwBlkAlignSize) !=
                           (LONG)dwBlkAlignSize)
                    goto ERROR_READING;     // truncated file, probably

                if (fCacheRIFF && !AddChunk(&ck,NULL,&gpcknHead,&gpcknTail))
                {
                    goto ERROR_FILETOOLARGE;
                }

                fDATA = TRUE;
                fHandled = TRUE;
                break;

            case mmioFOURCC('f','a','c','t'):

                /* deal with the 'fact' chunk */
                if (fFACT)
                    break; /* we've been here before */
                
#if 0
//
//         There are some wave editors that are writing 'fact' chunks
//         after the data chunk, so we no longer make this assumption
//                                
                if (fDATA)
                    break; /* we describe some another 'data' chunk */
#endif

                if (mmioRead(hmmio,(HPSTR)plWaveSamples, sizeof(DWORD))
                        != sizeof(DWORD))
                    goto ERROR_READING;

                if (fCacheRIFF && ck.cksize > sizeof(DWORD) &&
                        ck.cksize < 0xffff)
                {
                    spFact = (PFACT)GlobalAllocPtr(GHND,(UINT)(ck.cksize - sizeof(DWORD)));
                    if (spFact == NULL)
                        goto ERROR_FILETOOLARGE;
                    scbFact = ck.cksize - sizeof(DWORD);
                    if (mmioRead(hmmio,(HPSTR)spFact,scbFact) != scbFact)
                        goto ERROR_READING;
                }

                /* we don't AddChunk() the 'fact' because we
                 * write it out before we write our edit 'data'
                 */
                fFACT = TRUE;
                fHandled = TRUE;
                break;

#ifdef DISP
            case mmioFOURCC('d','i','s','p'):
                /* deal with the 'disp' chunk for clipboard transfer */
                
                // TODO:
                //  DISP's are CF_DIB or CF_TEXT.  Put 'em somewhere
                //  global and pass them through as text or a BMP when
                //  we copy to clipboard.
                //
                break;
                
#endif /* DISP */
                
            case mmioFOURCC('L','I','S','T'):
                if (fCacheRIFF)
                {
                    /* seek back over the type field */
                    if (mmioSeek(hmmio,-4,SEEK_CUR) == -1)
                        goto ERROR_READING;
                }
                break;

            default:
                break;
        }

        /* the "default" case. */
        if (fCacheRIFF && !fHandled)
        {
            HPBYTE hpData;

            hpData = GlobalAllocPtr(GMEM_MOVEABLE, ck.cksize+4);
            if (hpData == NULL)
            {
                goto ERROR_FILETOOLARGE;
            }
            /* read the data into the cache buffer */
            if (mmioRead(hmmio, (HPSTR)hpData, ck.cksize) != (LONG) ck.cksize)
            {
                GlobalFreePtr(hpData);
                goto ERROR_READING;// truncated file, probably
            }
            //
            // Special case the copyright info.  I'd rather do this than
            // rewrite this whole app.
            //
            if (ck.ckid == mmioFOURCC('I','C','O','P'))
            {
                LPTSTR lpstr = GlobalAllocPtr(GHND, ck.cksize+4);
                if (lpstr)
                {
                    memcpy(lpstr, hpData, ck.cksize+4);
                    gpszInfo = lpstr;
                }
            }
            
            if (!AddChunk(&ck,hpData,&gpcknHead, &gpcknTail))
            {
                goto ERROR_FILETOOLARGE;
            }
        }
        mmioAscend( hmmio, &ck, 0 );
    }

RETURN_FINISH:

    if (fFMT && fDATA)
    {
        *plWaveSamples = wfBytesToSamples(pWaveFormat, dwBlkAlignSize);
        *ppWaveSamples = pWaveSamples;
        goto RETURN_SUCCESS;
    }

    /* goto ERROR_NOTAWAVEFILE; */

ERROR_NOTAWAVEFILE:             // file is not a WAVE file

    ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
                IDS_APPTITLE, IDS_NOTAWAVEFILE, (LPTSTR) szFileName);
    goto RETURN_ERROR;

ERROR_READING:                  // error reading from file

    ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
                IDS_APPTITLE, IDS_ERRORREAD, (LPTSTR) szFileName);
    goto RETURN_ERROR;

ERROR_FILETOOLARGE:             // out of memory

    ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
                IDS_APPTITLE, IDS_FILETOOLARGE, (LPTSTR) szFileName);
    goto RETURN_ERROR;

RETURN_ERROR:

    if (pWaveSamples != NULL)
        GlobalFreePtr(pWaveSamples), pWaveSamples = NULL;

    if (fCacheRIFF)
        FreeAllChunks(&gpcknHead, &gpcknTail);
    
    mmr = MMSYSERR_ERROR;
    
RETURN_SUCCESS:
    return mmr;
    
} /* ReadWaveFile */


/* fSuccess = AddChunk(lpCk, hpData)
 *
 * Adds to our linked list of chunk information.
 *
 * LPMMCKINFO lpCk | far pointer to the MMCKINFO describing the chunk.
 * HPBYTE hpData | huge pointer to the data portion of the chunk, NULL if
 *      handled elsewhere.
 *
 * RETURNS: TRUE if added, FALSE if out of local heap.
 */

static BOOL AddChunk(
    LPMMCKINFO      lpCk,
    HPBYTE          hpData,
    PCKNODE *       ppcknHead,
    PCKNODE *       ppcknTail)
{
    PCKNODE         pckn;

    //
    // create a node
    //
    pckn = (PCKNODE)GlobalAllocPtr(GHND,sizeof(CKNODE));
    if (pckn == NULL)
    {
        DPF(TEXT("No Local Heap for Cache"));
        return FALSE;
    }

    if (*ppcknHead == NULL)
    {
        *ppcknHead = pckn;
    }

    if (*ppcknTail != NULL)
    {
        (*ppcknTail)->psNext = pckn;
    }
    *ppcknTail = pckn;

    pckn->ck.ckid           = lpCk->ckid;
    pckn->ck.fccType        = lpCk->fccType;
    pckn->ck.cksize         = lpCk->cksize;
    pckn->ck.dwDataOffset   = lpCk->dwDataOffset;

    pckn->hpData = hpData;

    return TRUE;

} /* AddChunk() */


/* pckn = PCKNODE FreeHeadChunk(void)
 *
 * Frees up the Head chunk and return a pointer to the new Head.
 * Uses global gpcknHead
 *
 * RETURNS: PCKNODE pointer to the Head chunk.  NULL if no chunks in the list.
 */

static PCKNODE FreeHeadChunk(
    PCKNODE *       ppcknHead)
{
    PCKNODE         pckn, pcknNext;

    if (*ppcknHead == NULL)
    {
        goto SUCCESS;
    }

    pckn = *ppcknHead;
    pcknNext = (*ppcknHead)->psNext;

    if (pckn->hpData != NULL)
    {
        GlobalFreePtr(pckn->hpData);
    }

    GlobalFreePtr(pckn);
    *ppcknHead = pcknNext;

SUCCESS:;
    return *ppcknHead;

} /* FreeHeadChunk() */


/* void FreeAllChunks(void)
 *
 * Frees up the link list of chunk data.
 *
 * RETURNS: Nothing
 */
static void FreeAllChunks(
    PCKNODE *       ppcknHead,
    PCKNODE *       ppcknTail)
{
    PCKNODE         pckn = *ppcknHead;
    PCKNODE         pcknNext = (*ppcknHead ? (*ppcknHead)->psNext : NULL);

    DPF1(TEXT("Freeing All Chunks\n"));

    while (FreeHeadChunk(ppcknHead));
            
    if (scbFact > 0)
    {
        GlobalFreePtr(spFact);
        scbFact = 0;
    }
    *ppcknHead = NULL;
    *ppcknTail = NULL;

} /* FreeAllChunks() */


/* fSuccess = WriteWaveFile(hmmio, pWaveFormat, lWaveSamples)
 *
 * Write a WAVE file into <hmmio>.  <*pWaveFormat> should be
 * the WAVE file format and <lWaveSamples> should be the number of samples in
 * the file.  Return TRUE on success, FALSE on failure.
 *
 */
BOOL FAR PASCAL
     WriteWaveFile(
                    HMMIO       hmmio,          // handle to open file
                    WAVEFORMATEX* pWaveFormat,  // WAVE format
                    UINT        cbWaveFormat,   // size of WAVEFORMAT
                    HPBYTE      pWaveSamples,   // waveform samples
                    LONG        lWaveSamples)   // number of samples
{
    MMCKINFO    ckRIFF;     // chunk info. for RIFF chunk
    MMCKINFO    ck;     // info. for a chunk file
    PCKNODE     pckn = gpcknHead;
    LONG        cbWaveSamples;
    MMRESULT    mmr;
    
    /* create the RIFF chunk of form type 'WAVE' */
    ckRIFF.fccType = mmioFOURCC('W', 'A', 'V', 'E');
    ckRIFF.cksize = 0L;         // let MMIO figure out ck. size
    
    mmr = mmioCreateChunk(hmmio, &ckRIFF, MMIO_CREATERIFF);
    if (mmr != MMSYSERR_NOERROR)
        goto wwferror;

    if (pckn != NULL)
    {
        /* ForEach node in the linked list of chunks,
         * Write out the corresponding data chunk OR
         * the global edit data.
         */

        do {
            ck.cksize   = 0L;
            ck.ckid     = pckn->ck.ckid;
            ck.fccType  = pckn->ck.fccType;

            if (pckn->hpData == NULL)
            {
                /* This must be a data-type we have in edit
                 * buffers. We should preserve the original
                 * order.
                 */

                switch (pckn->ck.ckid)
                {
                    case mmioFOURCC('f','m','t',' '):

                        mmr = mmioCreateChunk(hmmio, &ck, 0);
                        if (mmr != MMSYSERR_NOERROR)
                            goto wwferror;

                        if (mmioWrite(hmmio, (LPSTR) pWaveFormat, cbWaveFormat)
                            != (long)cbWaveFormat)
                            goto wwfwriteerror;

                        mmr = mmioAscend(hmmio, &ck, 0);
                        if (mmr != MMSYSERR_NOERROR)
                            goto wwferror;
                        
                        break;

                    case mmioFOURCC('d','a','t','a'):
                        /* Insert a 'fact' chunk here */
                        /* 'fact' should always preceed the 'data' it
                         * describes.
                         */

                        ck.ckid = mmioFOURCC('f', 'a', 'c', 't');

                        mmr = mmioCreateChunk(hmmio, &ck, 0);
                        if (mmr != MMSYSERR_NOERROR)
                            goto wwferror;

                        if (mmioWrite(hmmio, (LPSTR) &lWaveSamples,
                            sizeof(lWaveSamples)) != sizeof(lWaveSamples))
                            goto wwfwriteerror;

                        if (scbFact > 4)
                        {
                            if ( mmioWrite(hmmio, (LPSTR)spFact, scbFact)
                                    != scbFact )
                                goto wwfwriteerror;
                        }

                        mmr = mmioAscend(hmmio, &ck, 0);
                        if (mmr != MMSYSERR_NOERROR)
                            goto wwferror;

                        ck.cksize = 0L;

                        ck.ckid = mmioFOURCC('d', 'a', 't', 'a');

                        mmr = mmioCreateChunk(hmmio, &ck, 0);
                        if (mmr != MMSYSERR_NOERROR)
                            goto wwferror;

                        cbWaveSamples = wfSamplesToBytes(pWaveFormat,
                                                         lWaveSamples);
                        if (cbWaveSamples)
                        {
                            /* write the waveform samples */
                            if (mmioWrite(hmmio, (LPSTR)pWaveSamples
                                          , cbWaveSamples)
                                != cbWaveSamples)
                                return FALSE;
                        }
                        
                        mmr = mmioAscend(hmmio, &ck, 0);
                        if (mmr != MMSYSERR_NOERROR)
                            goto wwferror;
                            
                        break;

#ifdef DISP
                    case mmioFOURCC('d','i','s','p'):
                        /* deal with writing the 'disp' chunk */
                        break;
#endif /* DISP */

                    case mmioFOURCC('f','a','c','t'):
                        /* deal with the 'fact' chunk */
                        /* skip it.  We always write it before the 'data' */
                        break;

                    default:
                        /* This should never happen.*/
                        return FALSE;
                }
            }
            else
            {
                /* generic case */

                mmr = mmioCreateChunk(hmmio,&ck,0);
                if (mmr != MMSYSERR_NOERROR)
                    goto wwferror;


                if (mmioWrite(hmmio,(LPSTR)pckn->hpData,pckn->ck.cksize)
                    != (long) pckn->ck.cksize)
                    goto wwfwriteerror;

                mmr = mmioAscend(hmmio, &ck, 0);
                if (mmr != MMSYSERR_NOERROR)
                    goto wwferror;

            }

        } while (pckn = pckn->psNext);

    }
    else
    {
        /* <hmmio> is now descended into the 'RIFF' chunk -- create the
         * 'fmt' chunk and write <*pWaveFormat> into it
         */ 
        ck.ckid = mmioFOURCC('f', 'm', 't', ' ');
        ck.cksize = cbWaveFormat;
        
        mmr = mmioCreateChunk(hmmio, &ck, 0);
        if (mmr != MMSYSERR_NOERROR)
            goto wwferror;

        if (mmioWrite(hmmio, (LPSTR) pWaveFormat, cbWaveFormat) !=
                (long)cbWaveFormat)
            goto wwfwriteerror;

        /* ascend out of the 'fmt' chunk, back into 'RIFF' chunk */
        mmr = mmioAscend(hmmio, &ck, 0);
        if (mmr != MMSYSERR_NOERROR)
            goto wwferror;
        
        /* write out the number of samples in the 'FACT' chunk */
        ck.ckid = mmioFOURCC('f', 'a', 'c', 't');

        mmr = mmioCreateChunk(hmmio, &ck, 0);
        if (mmr != MMSYSERR_NOERROR)
            goto wwferror;                        
        
        if (mmioWrite(hmmio, (LPSTR)&lWaveSamples,  sizeof(lWaveSamples))
                != sizeof(lWaveSamples))
            return FALSE;

        /* ascend out of the 'fact' chunk, back into 'RIFF' chunk */
        mmr = mmioAscend(hmmio, &ck, 0);
        if (mmr != MMSYSERR_NOERROR)
            goto wwferror;
        
        /* create the 'data' chunk that holds the waveform samples */
        ck.ckid = mmioFOURCC('d', 'a', 't', 'a');
        ck.cksize = 0L;             // let MMIO figure out ck. size

        mmr = mmioCreateChunk(hmmio, &ck, 0);
        if (mmr != MMSYSERR_NOERROR)
            goto wwferror;            

        cbWaveSamples = wfSamplesToBytes(pWaveFormat,lWaveSamples);

        /* write the waveform samples */
        if (cbWaveSamples)
        {
            if (mmioWrite(hmmio, (LPSTR)pWaveSamples, cbWaveSamples)
                != cbWaveSamples)
                goto wwfwriteerror;
        }

        /* ascend the file out of the 'data' chunk, back into
         * the 'RIFF' chunk -- this will cause the chunk size of the 'data'
         * chunk to be written
         */
        mmr = mmioAscend(hmmio, &ck, 0);
        if (mmr != MMSYSERR_NOERROR)
            goto wwferror;
    }

    /* ascend the file out of the 'RIFF' chunk */
    mmr = mmioAscend(hmmio, &ckRIFF, 0);
    if (mmr != MMSYSERR_NOERROR)
        goto wwferror;

    /* done */
    return TRUE;

wwferror:
#if DBG    
    {
        TCHAR sz[256];
        HRESULT hr = StringCchPrintf(sz, SIZEOF(sz), TEXT("WriteWaveFile: Error %lx\r\n"), mmr);
		Assert( hr == S_OK );
        OutputDebugString(sz);
        DebugBreak();
    }
#endif            
    return FALSE;

wwfwriteerror:
#if DBG    
    {
        TCHAR sz[256];
        HRESULT hr = StringCchPrintf(sz, SIZEOF(sz), TEXT("Write Error! ckid = %04x\r\n"), (DWORD)ck.ckid);
		Assert( hr == S_OK );
        OutputDebugString(sz);
        DebugBreak();
    }
#endif    
    return FALSE;
} /* WriteWaveFile */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\soundrec\edit.c ===
/* (C) Copyright Microsoft Corporation 1991-1994.  All Rights Reserved */
/* edit.c
 *
 * Editing operations and special effects.
 */

/* Revision History.
 *   4/ Feb/91 LaurieGr (AKA LKG) Ported to WIN32 / WIN16 common code
 *  14/Feb/94 LaurieGr merged Motown and Daytona versions
 */

#include "nocrap.h"
#include <windows.h>
#include <windowsx.h>
#include <commdlg.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <string.h>

#define INCLUDE_OLESTUBS
#include "SoundRec.h"
#include "srecids.h"

/* constants */
#define CHVOL_INCDELTAVOLUME    25  // ChangeVolume: % to inc volume by
#define CHVOL_DECDELTAVOLUME    20  // ChangeVolume: % to dec volume by

#define ECHO_VOLUME             25      // AddEcho: % to multiply echo samples
#define ECHO_DELAY              150     // AddEcho: millisec delay for echo
#define WAVEBUFSIZE             400     // IncreasePitch, DecreasePitch
#define FINDWAVE_PICKYNESS      5       // how picky is FindWave?

extern char aszInitFile[];          // soundrec.c

static  SZCODE aszSamplesFormat[] = TEXT("%d%c%02d");
static  SZCODE aszSamplesNoZeroFormat[] = TEXT("%c%02d");

/* InsertFile(void)
 *
 * Prompt for the name of a WAVE file to insert at the current position.
 */
void FAR PASCAL
InsertFile(BOOL fPaste)
{
    TCHAR           achFileName[_MAX_PATH]; // name of file to insert
    WAVEFORMATEX*   pwfInsert=NULL; // WAVE file format of given file
    DWORD           cb;             // size of WAVEFORMATEX
    HPBYTE          pInsertSamples = NULL;  // samples from file to insert
    long            lInsertSamples; // number of samples in given file
    long            lSamplesToInsert;// no. samp. at samp. rate of cur. file
    TCHAR           ach[80];        // buffer for string loading
    HCURSOR         hcurPrev = NULL; // cursor before hourglass
    HPBYTE          pchSrc;         // pointer into source wave buffer
    short  *    piSrc;          // 16-bit pointer
    HPBYTE          pchDst;         // pointer into destination wave buffer
    short  *    piDst;          // 16-bit pointer
    long            lSamplesDst;    // bytes to copy into destination buffer
    long            lDDA;           // used to implement DDA algorithm
    HMMIO           hmmio;          // Handle to open file to read from

    BOOL            fDirty = TRUE;  // Is the buffer Dirty?

    BOOL            fStereoIn;
    BOOL            fStereoOut;
    BOOL            fEightIn;
    BOOL            fEightOut;
    BOOL            fEditWave = FALSE;
    int             iTemp;
    int             iTemp2;
    OPENFILENAME    ofn;

#ifdef DOWECARE    
    /* HACK from "server.c" to read objects without CF_WAVE */
    extern WORD cfNative;
#endif
    
    if (glWaveSamplesValid > 0 && !IsWaveFormatPCM(gpWaveFormat))
        return;

    if (fPaste) {
        MMIOINFO        mmioinfo;
        HANDLE          h;
        
        BeginWaveEdit();
        
        if (!OpenClipboard(ghwndApp))
            return;

        LoadString(ghInst, IDS_CLIPBOARD, achFileName, SIZEOF(achFileName));

        h = GetClipboardData(CF_WAVE);
#ifdef DOWECARE        
        if (!h) h = GetClipboardData(cfNative);
#endif
        if (h)
        {
            mmioinfo.fccIOProc = FOURCC_MEM;
            mmioinfo.pIOProc = NULL;
            mmioinfo.pchBuffer = GlobalLock(h);
            mmioinfo.cchBuffer = (long)GlobalSize(h); // initial size
            mmioinfo.adwInfo[0] = 0;            // grow by this much
            hmmio = mmioOpen(NULL, &mmioinfo, MMIO_READ);
        }
        else
        {
            hmmio = NULL;
        }
    }
    else
    {
        BOOL f;

        achFileName[0] = 0;

        /* prompt user for file to open */
        LoadString(ghInst, IDS_INSERTFILE, ach, SIZEOF(ach));
        ofn.lStructSize = sizeof(OPENFILENAME);
        ofn.hwndOwner = ghwndApp;
        ofn.hInstance = NULL;
        ofn.lpstrFilter = aszFilter;
        ofn.lpstrCustomFilter = NULL;
        ofn.nMaxCustFilter = 0;
        ofn.nFilterIndex = 1;
        ofn.lpstrFile = achFileName;
        ofn.nMaxFile = SIZEOF(achFileName);
        ofn.lpstrFileTitle = NULL;
        ofn.nMaxFileTitle = 0;
        ofn.lpstrInitialDir = NULL;
        ofn.lpstrTitle = ach;
        ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
        ofn.nFileOffset = 0;
        ofn.nFileExtension = 0;
        ofn.lpstrDefExt = NULL;
        ofn.lCustData = 0;
        ofn.lpfnHook = NULL;
        ofn.lpTemplateName = NULL;
        f = GetOpenFileName(&ofn);  // get the filename

        // did we succeed or not?
        if (!f)
            goto RETURN_ERROR;

        /* read the WAVE file */
        hmmio = mmioOpen(achFileName, NULL, MMIO_READ | MMIO_ALLOCBUF);
    }

    if (hmmio != NULL)
    {
        MMRESULT    mmr;
        
        //
        // show hourglass cursor
        //
        hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

        //
        // read the WAVE file
        //
        mmr = ReadWaveFile( hmmio
                            , &pwfInsert
                            , &cb
                            , &pInsertSamples
                            , &lInsertSamples
                            , achFileName
                            , FALSE );
        
        mmioClose(hmmio, 0);

        if (mmr != MMSYSERR_NOERROR)
            goto RETURN_ERROR;
        
        if (lInsertSamples == 0)
            goto RETURN_SUCCESS;

        if (pInsertSamples == NULL)
            goto RETURN_ERROR;

        if (glWaveSamplesValid > 0 && !IsWaveFormatPCM(pwfInsert))
        {

            ErrorResBox( ghwndApp
                       , ghInst
                       , MB_ICONEXCLAMATION | MB_OK
                       , IDS_APPTITLE
                       , fPaste ? IDS_CANTPASTE : IDS_NOTASUPPORTEDFILE
                       , (LPTSTR) achFileName
                       );
            goto RETURN_ERROR;
        }
    } else {
        ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
                            IDS_APPTITLE, IDS_ERROROPEN, (LPTSTR) achFileName);
        goto RETURN_ERROR;
    }
    
//jyg:moved
//        BeginWaveEdit();
    fEditWave = TRUE;

    //
    // if the current file is empty, treat the insert like a open
    //
    if (glWaveSamplesValid == 0)
    {
        DestroyWave();

        gpWaveSamples = pInsertSamples;
        glWaveSamples = lInsertSamples;
        glWaveSamplesValid = lInsertSamples;
        gpWaveFormat  = pwfInsert;
        gcbWaveFormat = cb;

        pInsertSamples = NULL;
        pwfInsert      = NULL;

        goto RETURN_SUCCESS;
    }

    fStereoIn  = pwfInsert->nChannels != 1;
    fStereoOut = gpWaveFormat->nChannels != 1;

    fEightIn  = ((LPWAVEFORMATEX)pwfInsert)->wBitsPerSample == 8;
    fEightOut = ((LPWAVEFORMATEX)gpWaveFormat)->wBitsPerSample == 8;

    /* figure out how many bytes need to be inserted */
    lSamplesToInsert = MulDiv(lInsertSamples, gpWaveFormat->nSamplesPerSec,
                                      pwfInsert->nSamplesPerSec);
#ifdef DEBUG
    DPF(TEXT("insert %ld samples, converting from %ld Hz to %ld Hz\n"),
            lInsertSamples, pwfInsert->nSamplesPerSec,
            gpWaveFormat->nSamplesPerSec);
    DPF(TEXT("so %ld samples need to be inserted at position %ld\n"),
            lSamplesToInsert, glWavePosition);
#endif

    /* reallocate the WAVE buffer to be big enough */
    if (!AllocWaveBuffer(glWaveSamplesValid + lSamplesToInsert, TRUE, TRUE))
        goto RETURN_ERROR;
    glWaveSamplesValid += lSamplesToInsert;

    /* create a "gap" in the WAVE buffer to go from this:
     *     |---glWavePosition---|-rest-of-buffer-|
     * to this:
     *     |---glWavePosition---|----lSamplesToInsert----|-rest-of-buffer-|
     * where <glWaveSamplesValid> is the size of the buffer
     * *after* reallocation
     */
    memmove( gpWaveSamples + wfSamplesToBytes(gpWaveFormat, glWavePosition + lSamplesToInsert)
           , gpWaveSamples + wfSamplesToBytes(gpWaveFormat, glWavePosition)
           , wfSamplesToBytes(gpWaveFormat, glWaveSamplesValid - (glWavePosition + lSamplesToInsert))
           );

    /* copy the read-in WAVE file into the "gap" */
    pchDst = gpWaveSamples + wfSamplesToBytes(gpWaveFormat,glWavePosition);
    piDst = (short  *) pchDst;

    lSamplesDst = lSamplesToInsert;
    pchSrc = pInsertSamples;
    piSrc = (short  *) pchSrc;

    lDDA = -((LONG)gpWaveFormat->nSamplesPerSec);
    while (lSamplesDst > 0)
    {
        /* get a sample, convert to right format */
        if (fEightIn) {
            iTemp = *((BYTE  *) pchSrc);
            if (fStereoIn) {
                iTemp2 = (unsigned char) *(pchSrc+1);
                if (!fStereoOut) {
                    iTemp = (iTemp + iTemp2) / 2;
                }
            }
            else
                iTemp2 = iTemp;

            if (!fEightOut) {
                iTemp = (iTemp - 128) << 8;
                iTemp2 = (iTemp2 - 128) << 8;
            }
        } else {
            iTemp = *piSrc;
            if (fStereoIn) {
                iTemp2 = *(piSrc+1);
                if (!fStereoOut) {
                    iTemp = (int) (  ( ((long)iTemp) + ((long) iTemp2)
                                     ) / 2);
                }
            }
            else
                iTemp2 = iTemp;

            if (fEightOut) {
                iTemp = (iTemp >> 8) + 128;
                iTemp2 = (iTemp2 >> 8) + 128;
            }
        }

        /* Output a sample */
        if (fEightOut)
        {   // Cast on lvalue eliminated -- LKG
            *(BYTE  *) pchDst = (BYTE) iTemp;
            pchDst = (BYTE  *)pchDst + 1;
        }
        else
            *piDst++ = (short)iTemp;
        if (fStereoOut) {
            if (fEightOut)
            {   // Cast on lvalue eliminated -- LKG
                *(BYTE  *) pchDst = (BYTE) iTemp2;
                pchDst = (BYTE  *)pchDst + 1;
            }
            else
                *piDst++ = (short)iTemp2;
        }
        lSamplesDst--;

        /* increment <pchSrc> at the correct rate so that the
         * sampling rate of the input file is converted to match
         * the sampling rate of the current file
         */
        lDDA += pwfInsert->nSamplesPerSec;
        while (lDDA >= 0) {
            lDDA -= gpWaveFormat->nSamplesPerSec;
            if (fEightIn)
                pchSrc++;
            else
                piSrc++;
            if (fStereoIn) {
                if (fEightIn)
                    pchSrc++;
                else
                    piSrc++;
            }
        }
    }
#ifdef DEBUG
    if (!fEightIn)
        pchSrc = (HPBYTE) piSrc;
    DPF(TEXT("copied %ld bytes from insertion buffer\n"), (long) (pchSrc - pInsertSamples));
#endif

    goto RETURN_SUCCESS;

RETURN_ERROR:                           // do error exit without error message
    fDirty = FALSE;

RETURN_SUCCESS:                         // normal exit

    if (fPaste)
        CloseClipboard();

    if (pInsertSamples != NULL)
        GlobalFreePtr(pInsertSamples);

    if (pwfInsert != NULL)
        GlobalFreePtr(pwfInsert);

    if (hcurPrev != NULL)
        SetCursor(hcurPrev);

    if (fEditWave == TRUE)
        EndWaveEdit(fDirty);

    /* update the display */
    UpdateDisplay(TRUE);
}


/* MixWithFile(void)
 *
 * Prompt for the name of a WAVE file to mix with the audio starting at
 * the current location.
 */
void FAR PASCAL
MixWithFile(BOOL fPaste)
{
    TCHAR           achFileName[_MAX_PATH]; // name of file to mix with
    WAVEFORMATEX*     pwfMix=NULL;    // WAVE file format of given file
    UINT            cb;
    HPBYTE          pMixSamples = NULL;     // samples from file to mix with
    long            lMixSamples;    // number of samples in given file
    long            lSamplesToMix;  // no. Samples at samp. rate. of cur. file
    long            lSamplesToAdd;  // no. Samples to add in
    TCHAR           ach[80];        // buffer for string loading
    HCURSOR         hcurPrev = NULL; // cursor before hourglass
    HPBYTE          pchSrc;         // pointer into source wave buffer
    HPBYTE          pchDst;         // pointer into destination wave buffer
    short  *    piSrc;          // pointer into source wave buffer
    short  *    piDst;          // pointer into destination wave buffer
    long            lSamplesDst;    // Samples to copy into destination buffer
    long            lDDA;           // used to implement DDA algorithm
    int             iSample;        // value of a waveform sample
    long            lSample;        // value of a waveform sample
    HMMIO           hmmio;

    BOOL            fDirty = TRUE;

    BOOL            fStereoIn;
    BOOL            fStereoOut;
    BOOL            fEightIn;
    BOOL            fEightOut;
    BOOL            fEditWave = FALSE;
    int             iTemp;
    int             iTemp2;
    OPENFILENAME    ofn;

#ifdef DOWECARE    
    /* HACK from "server.c" to read objects without CF_WAVE */
    extern WORD cfNative;
#endif
    
    if (glWaveSamplesValid > 0 && !IsWaveFormatPCM(gpWaveFormat))
        return;

    if (fPaste) {
        MMIOINFO        mmioinfo;
        HANDLE          h;

        BeginWaveEdit();        
        if (!OpenClipboard(ghwndApp))
            return;

        LoadString(ghInst, IDS_CLIPBOARD, achFileName, SIZEOF(achFileName));

        h = GetClipboardData(CF_WAVE);
#ifdef DOWECARE        
        if (!h) h = GetClipboardData(cfNative);
#endif        
        if (h) {
            mmioinfo.fccIOProc = FOURCC_MEM;
            mmioinfo.pIOProc = NULL;
            mmioinfo.pchBuffer = GlobalLock(h);
            mmioinfo.cchBuffer = (long)GlobalSize(h); // initial size
            mmioinfo.adwInfo[0] = 0;            // grow by this much
            hmmio = mmioOpen(NULL, &mmioinfo, MMIO_READ);
        }
        else {
            hmmio = NULL;
        }
    }
    else {
        BOOL f;

        achFileName[0] = 0;

        /* prompt user for file to open */
        LoadString(ghInst, IDS_MIXWITHFILE, ach, SIZEOF(ach));
        ofn.lStructSize = sizeof(OPENFILENAME);
        ofn.hwndOwner = ghwndApp;
        ofn.hInstance = NULL;
        ofn.lpstrFilter = aszFilter;
        ofn.lpstrCustomFilter = NULL;
        ofn.nMaxCustFilter = 0;
        ofn.nFilterIndex = 1;
        ofn.lpstrFile = achFileName;
        ofn.nMaxFile = SIZEOF(achFileName);
        ofn.lpstrFileTitle = NULL;
        ofn.nMaxFileTitle = 0;
        ofn.lpstrInitialDir = NULL;
        ofn.lpstrTitle = ach;
        ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
        ofn.nFileOffset = 0;
        ofn.nFileExtension = 0;
        ofn.lpstrDefExt = NULL;
        ofn.lCustData = 0;
        ofn.lpfnHook = NULL;
        ofn.lpTemplateName = NULL;
        f = GetOpenFileName(&ofn);  // get the filename for mixing

        // see if we continue
        if (!f)
            goto RETURN_ERROR;

        /* read the WAVE file */
        hmmio = mmioOpen(achFileName, NULL, MMIO_READ | MMIO_ALLOCBUF);
    }

    if (hmmio != NULL)
    {
        MMRESULT mmr;
        
        //
        // show hourglass cursor
        //
        hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

        //
        // read the WAVE file
        //
        mmr = ReadWaveFile( hmmio
                            , &pwfMix       // wave format
                            , &cb           // wave format size
                            , &pMixSamples  // samples
                            , &lMixSamples  // number of samples
                            , achFileName   // file name for error
                            , FALSE );      // cache riff?
                                 
        mmioClose(hmmio, 0);


        if (mmr != MMSYSERR_NOERROR)
            goto RETURN_ERROR;
        
        if (lMixSamples == 0)
            goto RETURN_SUCCESS;
        
        if (pMixSamples == NULL)
            goto RETURN_ERROR;

        if (glWaveSamplesValid > 0 && !IsWaveFormatPCM(pwfMix)) {
            ErrorResBox( ghwndApp
                       , ghInst
                       , MB_ICONEXCLAMATION | MB_OK
                       , IDS_APPTITLE
                       , fPaste ? IDS_CANTPASTE : IDS_NOTASUPPORTEDFILE
                       , (LPTSTR) achFileName
                       );
            goto RETURN_ERROR;
        }
    }
    else
    {
        ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
                    IDS_APPTITLE, IDS_ERROROPEN, (LPTSTR) achFileName);
        goto RETURN_ERROR;
    }

//jyg: moved
//        BeginWaveEdit();
    fEditWave = TRUE;

    //
    // if the current file is empty, treat the insert like a open
    //
    if (glWaveSamplesValid == 0)
    {
        DestroyWave();

        gpWaveSamples = pMixSamples;
        glWaveSamples = lMixSamples;
        glWaveSamplesValid = lMixSamples;
        gpWaveFormat  = pwfMix;
        gcbWaveFormat = cb;

        pMixSamples = NULL;
        pwfMix      = NULL;

        goto RETURN_SUCCESS;
    }

    fStereoIn  = pwfMix->nChannels != 1;
    fStereoOut = gpWaveFormat->nChannels != 1;

    fEightIn  = ((LPWAVEFORMATEX)pwfMix)->wBitsPerSample == 8;
    fEightOut = ((LPWAVEFORMATEX)gpWaveFormat)->wBitsPerSample == 8;

    /* figure out how many Samples need to be mixed in */
    lSamplesToMix = MulDiv(lMixSamples, gpWaveFormat->nSamplesPerSec,
                                  pwfMix->nSamplesPerSec);
    lSamplesToAdd = lSamplesToMix - (glWaveSamplesValid - glWavePosition);
    if (lSamplesToAdd < 0)
        lSamplesToAdd = 0;
#ifdef DEBUG
    DPF(TEXT("mix in %ld samples, converting from %ld Hz to %ld Hz\n"),
                lMixSamples, pwfMix->nSamplesPerSec,
                gpWaveFormat->nSamplesPerSec);
    DPF(TEXT("so %ld Samples need to be mixed in at position %ld (add %ld)\n"),
                lSamplesToMix, glWavePosition, lSamplesToAdd);
#endif

    if (lSamplesToAdd > 0) {

        /* mixing the specified file at the current location will
         * require the current file's wave buffer to be expanded
         * by <lSamplesToAdd>
         */

        /* reallocate the WAVE buffer to be big enough */
        if (!AllocWaveBuffer(glWaveSamplesValid + lSamplesToAdd,TRUE, TRUE))
            goto RETURN_ERROR;

        /* fill in the new part of the buffer with silence
         */
        lSamplesDst = lSamplesToAdd;

        /* If stereo, just twice as many samples
         */
        if (fStereoOut)
            lSamplesDst *= 2;

        pchDst = gpWaveSamples + wfSamplesToBytes(gpWaveFormat,glWaveSamplesValid);

        if (fEightOut) {
            while (lSamplesDst-- > 0) {
                // cast on lvalue eliminated
                *((BYTE  *) pchDst) = 128;
                pchDst = (BYTE  *)pchDst + 1;
            }
        }
        else {
            piDst = (short  *) pchDst;
            while (lSamplesDst-- > 0) {
                *((short  *) piDst) = 0;
                piDst = (short  *)piDst + 1;
            }
        }
        glWaveSamplesValid += lSamplesToAdd;
    }

    /* mix the read-in WAVE file with the current file starting at the
     * current position
     */
    pchDst = gpWaveSamples + wfSamplesToBytes(gpWaveFormat, glWavePosition);
    piDst = (short  *) pchDst;

    lSamplesDst = lSamplesToMix;
    pchSrc = pMixSamples;
    piSrc = (short  *) pchSrc;

    lDDA = -((LONG)gpWaveFormat->nSamplesPerSec);
    while (lSamplesDst > 0)
    {
        /* get a sample, convert to right format */
        if (fEightIn) {
            iTemp = (int) (unsigned char) *pchSrc;
            if (fStereoIn) {
                iTemp2 = (int) (unsigned char) *(pchSrc+1);
                if (!fStereoOut) {
                    iTemp = (iTemp + iTemp2) / 2;
                }
            } else
                iTemp2 = iTemp;

            if (!fEightOut) {
                iTemp = (iTemp - 128) << 8;
                iTemp2 = (iTemp2 - 128) << 8;
            }
        } else {
            iTemp = *piSrc;
            if (fStereoIn) {
                iTemp2 = *(piSrc+1);
                if (!fStereoOut) {
                    iTemp = (int) ((((long) iTemp)
                              + ((long) iTemp2)) / 2);
                }
            } else
                iTemp2 = iTemp;

            if (fEightOut) {
                iTemp = (iTemp >> 8) + 128;
                iTemp2 = (iTemp2 >> 8) + 128;
            }
        }

        /* Output a sample */
        if (fEightOut)
        {
            iSample = (int) *((BYTE  *) pchDst)
                                            + iTemp - 128;
            *((BYTE  *) pchDst++) = (BYTE)
                         (iSample < 0 ? 0 :
                                 (iSample > 255 ? 255 : iSample));
        }
        else
        {
            lSample = (long) *((short  *) piDst)
                                            + (long) iTemp;
            *((short  *) piDst++) = (int)
                            (lSample < -32768L
                                    ? -32768 : (lSample > 32767L
                                            ? 32767 : (short) lSample));
        }
        if (fStereoOut) {
            if (fEightOut)
            {
                iSample = (int) *((BYTE  *) pchDst)
                                                    + iTemp2 - 128;
                *((BYTE  *) pchDst++) = (BYTE)
                                    (iSample < 0
                                            ? 0 : (iSample > 255
                                                    ? 255 : iSample));
            }
            else
            {
                lSample = (long) *((short  *) piDst)
                                                    + (long) iTemp2;
                *((short  *) piDst++) = (short)
                                    (lSample < -32768L
                                        ? -32768 : (lSample > 32767L
                                            ? 32767 : (short) lSample));
            }
        }
        lSamplesDst--;

        /* increment <pchSrc> at the correct rate so that the
         * sampling rate of the input file is converted to match
         * the sampling rate of the current file
         */
        lDDA += pwfMix->nSamplesPerSec;
        while (lDDA >= 0)
        {
            lDDA -= gpWaveFormat->nSamplesPerSec;
            if (fEightIn)
                pchSrc++;
            else
                piSrc++;
            if (fStereoIn) {
                if (fEightIn)
                    pchSrc++;
                else
                    piSrc++;
            }
        }
    }
#ifdef DEBUG
    if (!fEightIn)
        pchSrc = (HPBYTE) piSrc;
    DPF(TEXT("copied %ld bytes from mix buffer\n"),
        (long) (pchSrc - pMixSamples));
#endif

    goto RETURN_SUCCESS;

RETURN_ERROR:                           // do error exit without error message
    fDirty = FALSE;

RETURN_SUCCESS:                         // normal exit

    if (fPaste)
        CloseClipboard();

    if (pMixSamples != NULL)
        GlobalFreePtr(pMixSamples);

    if (pwfMix != NULL)
        GlobalFreePtr(pwfMix);

    if (hcurPrev != NULL)
        SetCursor(hcurPrev);

    if (fEditWave == TRUE)
        EndWaveEdit(fDirty);

    /* update the display */
    UpdateDisplay(TRUE);
}


/* DeleteBefore()
 *
 * Delete samples before <glWavePosition>.
 */
void FAR PASCAL
     DeleteBefore(void)
{
    TCHAR           ach[40];
    long            lTime;
    int             id;

    if (glWavePosition == 0)                // nothing to do?
            return;                         // don't set dirty flag

    BeginWaveEdit();

    /* jyg - made this conditional because of rounding errors at
     * the end of buffer case
     */
    if (glWavePosition != glWaveSamplesValid)
        glWavePosition = wfSamplesToSamples(gpWaveFormat, glWavePosition);

    /* get the current wave position */
    lTime = wfSamplesToTime(gpWaveFormat, glWavePosition);
    if (gfLZero || ((int)(lTime/1000) != 0))               // ??? what are these casts ???
        wsprintf(ach, aszSamplesFormat, (int)(lTime/1000), chDecimal, (int)((lTime/10)%100));
    else
    wsprintf(ach, aszSamplesNoZeroFormat, chDecimal, (int)((lTime/10)%100));


    /* prompt user for permission */

    id = ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OKCANCEL,
        IDS_APPTITLE, IDS_DELBEFOREWARN, (LPTSTR) ach);

    if (id != IDOK)
        return;

    /* copy the samples after <glWavePosition> to the beginning of
     * the buffer
     */
    memmove(gpWaveSamples,
            gpWaveSamples + wfSamplesToBytes(gpWaveFormat, glWavePosition),
            wfSamplesToBytes(gpWaveFormat, glWaveSamplesValid - glWavePosition));

    /* reallocate the buffer to be <glWavePosition> samples smaller */
    AllocWaveBuffer(glWaveSamplesValid - glWavePosition, TRUE, TRUE);
    glWavePosition = 0L;

    EndWaveEdit(TRUE);

    /* update the display */
    UpdateDisplay(TRUE);
} /* DeleteBefore */


/* DeleteAfter()
 *
 * Delete samples after <glWavePosition>.
 */
void FAR PASCAL
     DeleteAfter(void)
{
    TCHAR           ach[40];
    long            lTime;
    int             id;

    if (glWavePosition == glWaveSamplesValid)       // nothing to do?
            return;                         // don't set dirty flag

    glWavePosition = wfSamplesToSamples(gpWaveFormat, glWavePosition);

    BeginWaveEdit();

    /* get the current wave position */
    lTime = wfSamplesToTime(gpWaveFormat, glWavePosition);
    if (gfLZero || ((int)(lTime/1000) != 0))             // ??? casts ???
        wsprintf(ach, aszSamplesFormat, (int)(lTime/1000), chDecimal, (int)((lTime/10)%100));
    else
        wsprintf(ach, aszSamplesNoZeroFormat, chDecimal, (int)((lTime/10)%100));

    /* prompt user for permission */

    id = ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OKCANCEL,
            IDS_APPTITLE, IDS_DELAFTERWARN, (LPTSTR) ach);

    if (id != IDOK)
        return;

    /* reallocate the buffer to be <glWavePosition> samples in size */
    AllocWaveBuffer(glWavePosition, TRUE, TRUE);

    EndWaveEdit(TRUE);

    /* update the display */
    UpdateDisplay(TRUE);
} /* DeleteAfter */


/* ChangeVolume(fIncrease)
 *
 * Increase the volume (if <fIncrease> is TRUE) or decrease the volume
 * (if <fIncrease> is FALSE) of samples in the wave buffer by CHVOL_DELTAVOLUME
 * percent.
 */
void FAR PASCAL
ChangeVolume(BOOL fIncrease)
{
    HPBYTE          pch = gpWaveSamples; // ptr. into waveform buffer
    long            lSamples;       // samples to modify
    HCURSOR         hcurPrev = NULL; // cursor before hourglass
    int             iFactor;        // amount to multiply amplitude by
    short  *    pi = (short  *) gpWaveSamples;

    if (glWaveSamplesValid == 0L)           // nothing to do?
        return;                             // don't set dirty flag

    if (!IsWaveFormatPCM(gpWaveFormat))
        return;

    /* show hourglass cursor */
    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    BeginWaveEdit();

    /* for stereo, just twice as many samples */
    lSamples = glWaveSamplesValid * gpWaveFormat->nChannels;

    iFactor = 100 + (fIncrease ? CHVOL_INCDELTAVOLUME : -CHVOL_DECDELTAVOLUME);
    if (((LPWAVEFORMATEX)gpWaveFormat)->wBitsPerSample == 8) {
        /* 8-bit: samples 0-255 */
        int     iTemp;
        while (lSamples-- > 0)
        {
            iTemp = ( ((short) *((BYTE  *) pch) - 128)
                    * iFactor
                    )
                    / 100 + 128;
            *((BYTE  *) pch++) = (BYTE)
                            (iTemp < 0 ? 0 : (iTemp > 255 ? 255 : iTemp));
        }
    } else {
        /* 16-bit: samples -32768 - 32767 */
        long            lTemp;
        while (lSamples-- > 0)
        {
            lTemp =  (((long) *pi) * iFactor) / 100;
            *(pi++) = (short) (lTemp < -32768L ? -32768 :
                                    (lTemp > 32767L ?
                                            32767 : (short) lTemp));
        }
    }

    EndWaveEdit(TRUE);

    if (hcurPrev != NULL)
        SetCursor(hcurPrev);

    /* update the display */
    UpdateDisplay(TRUE);
}


/* MakeFaster()
 *
 * Make the sound play twice as fast.
 */
void FAR PASCAL
MakeFaster(void)
{
    HPBYTE          pchSrc;         // pointer into source part of buffer
    HPBYTE          pchDst;         // pointer into destination part
    short  *    piSrc;
    short  *    piDst;
    long            lSamplesDst;    // samples to copy into destination buffer
    HCURSOR         hcurPrev = NULL; // cursor before hourglass

    if (glWaveSamplesValid == 0L)           // nothing to do?
        return;                             // don't set dirty flag

    if (!IsWaveFormatPCM(gpWaveFormat))
        return;

    /* show hourglass cursor */
    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    BeginWaveEdit();

    /* move the current position so it will correspond to the same point
     * in the audio before and after the change-pitch operation
     */
    glWavePosition /= 2L;

    /* delete every other sample */
    lSamplesDst = glWaveSamplesValid / 2L;
    if (((LPWAVEFORMATEX)gpWaveFormat)->wBitsPerSample == 8) {
        pchSrc = pchDst = gpWaveSamples;
        if (gpWaveFormat->nChannels == 1) {
            while (lSamplesDst-- > 0)
            {
                *pchDst++ = *pchSrc++;
                pchSrc++;
            }
        } else {
            while (lSamplesDst-- > 0)
            {
                *pchDst++ = *pchSrc++;
                *pchDst++ = *pchSrc++;
                pchSrc++;
                pchSrc++;
            }
        }
    } else {
        piSrc = piDst = (short  *) gpWaveSamples;
        if (gpWaveFormat->nChannels == 1) {
            while (lSamplesDst-- > 0)
            {
                *piDst++ = *piSrc++;
                piSrc++;
            }
        } else {
            while (lSamplesDst-- > 0)
            {
                *piDst++ = *piSrc++;
                *piDst++ = *piSrc++;
                piSrc++;
                piSrc++;
            }
        }
    }

    /* reallocate the WAVE buffer to be half as big enough */
//!!WinEval(AllocWaveBuffer(glWaveSamplesValid / 2L));
    AllocWaveBuffer(glWaveSamplesValid / 2L, TRUE, TRUE);

    EndWaveEdit(TRUE);

    if (hcurPrev != NULL)
            SetCursor(hcurPrev);

    /* update the display */
    UpdateDisplay(TRUE);
}


/* MakeSlower()
 *
 * Make the sound play twice as slow.
 */
void FAR PASCAL
MakeSlower(void)
{
    HPBYTE          pchSrc;         // pointer into source part of buffer
    HPBYTE          pchDst;         // pointer into destination part
    short  *    piSrc;
    short  *    piDst;

    long            lSamplesSrc;    // samples to copy from source buffer
    HCURSOR         hcurPrev = NULL; // cursor before hourglass
    long            lPrevPosition;  // previous "current position"

    int             iSample;        // current source sample
    int             iPrevSample;    // previous sample (for interpolation)
    int             iSample2;
    int             iPrevSample2;

    long            lSample;
    long            lPrevSample;
    long            lSample2;
    long            lPrevSample2;

    if (glWaveSamplesValid == 0L)           // nothing to do?
        return;                             // don't set dirty flag

    if (!IsWaveFormatPCM(gpWaveFormat))
        return;

    /* show hourglass cursor */
    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    BeginWaveEdit();

    /* reallocate the WAVE buffer to be twice as big */
    lPrevPosition = glWavePosition;
    if (!AllocWaveBuffer(glWaveSamplesValid * 2L, TRUE, TRUE))
        goto RETURN;

    /* each source sample generates two destination samples;
     * use interpolation to generate new samples; must go backwards
     * through the buffer to avoid destroying data
     */
    pchSrc = gpWaveSamples + wfSamplesToBytes(gpWaveFormat, glWaveSamplesValid);
    pchDst = gpWaveSamples + wfSamplesToBytes(gpWaveFormat, glWaveSamplesValid * 2L);
    lSamplesSrc = glWaveSamplesValid;

    if (((LPWAVEFORMATEX)gpWaveFormat)->wBitsPerSample == 8)
    {
        if (gpWaveFormat->nChannels == 1)
        {
            iPrevSample = *((BYTE  *) (pchSrc - 1));
            while (lSamplesSrc-- > 0)
            {
                pchSrc =  ((BYTE  *) pchSrc) - 1;
                iSample = *((BYTE  *) pchSrc);

                *--pchDst = (BYTE)((iSample + iPrevSample)/2);
                *--pchDst = (BYTE) iSample;
                iPrevSample = iSample;
            }
        }
        else
        {
            iPrevSample = *((BYTE  *) (pchSrc - 2));
            iPrevSample2 = *((BYTE  *) (pchSrc - 1));
            while (lSamplesSrc-- > 0)
            {
                pchSrc = ((BYTE  *) pchSrc)-1;
                iSample2 = *((BYTE  *) pchSrc);

                pchSrc = ((BYTE  *) pchSrc)-1;
                iSample = *((BYTE  *) pchSrc);

                *--pchDst = (BYTE)((iSample2 + iPrevSample2)
                                                        / 2);
                *--pchDst = (BYTE)((iSample + iPrevSample)
                                                        / 2);
                *--pchDst = (BYTE) iSample2;
                *--pchDst = (BYTE) iSample;
                iPrevSample = iSample;
                iPrevSample2 = iSample2;
            }
        }
    }
    else
    {
        piDst = (short  *) pchDst;
        piSrc = (short  *) pchSrc;

        if (gpWaveFormat->nChannels == 1)
        {
            lPrevSample = *(piSrc - 1);
            while (lSamplesSrc-- > 0)
            {
                lSample = *--piSrc;
                *--piDst = (short)((lSample + lPrevSample)/2);
                *--piDst = (short) lSample;
                lPrevSample = lSample;
            }
        }
        else
        {
            lPrevSample = *(piSrc - 2);
            lPrevSample2 = *(piSrc - 1);
            while (lSamplesSrc-- > 0)
            {
                lSample2 = *--piSrc;
                lSample = *--piSrc;
                *--piDst = (short)((lSample2 + lPrevSample2)/2);
                *--piDst = (short)((lSample + lPrevSample) / 2);
                *--piDst = (short) lSample2;
                *--piDst = (short) lSample;
                lPrevSample = lSample;
                lPrevSample2 = lSample2;
            }
        }
    }

    /* the entire buffer now contains valid samples */
    glWaveSamplesValid *= 2L;

    /* move the current position so it will correspond to the same point
     * in the audio before and after the change-pitch operation
     */
    glWavePosition = lPrevPosition * 2L;
//!!WinAssert(glWavePosition <= glWaveSamplesValid);

RETURN:
    EndWaveEdit(TRUE);

    if (hcurPrev != NULL)
        SetCursor(hcurPrev);

    /* update the display */
    UpdateDisplay(TRUE);
}


#if 0

/* pchNew = FindWave(pch, pchEnd, ppchWaveBuf)
 *
 * Assuming <pch> points within the wave buffer and <pchEnd> points past the
 * end of the buffer, find the beginning of the next "wave", i.e. the point
 * where the waveform starts rising (after it has fallen).
 *
 * <ppchWaveBuf> points to a pointer that points to a buffer that is filled
 * in with a copy of the wave.  The pointer <*ppchWaveBuf> is modified and
 * upon return will point past the end of the wave.
 */
HPBYTE NEAR PASCAL
FindWave(HPBYTE pch, HPBYTE pchEnd, NPBYTE *ppchWaveBuf)
{
    BYTE    bLowest = 255;
    BYTE    bHighest = 0;
    BYTE    bLowPoint;
    BYTE    bHighPoint;
    BYTE    bDelta;
    HPBYTE  pchWalk;
    BYTE    b;
#ifdef VERBOSEDEBUG
    NPBYTE  pchWaveBufInit = *ppchWaveBuf;
#endif

    if (pch == pchEnd)
            return pch;

    for (pchWalk = pch; pchWalk != pchEnd; pchWalk++)
    {
            b = *pchWalk;
            b = *((BYTE  *) pchWalk);
            if (bLowest > b)
                    bLowest = b;
            if (bHighest < b)
                    bHighest = b;
    }

    bDelta = (bHighest - bLowest) / FINDWAVE_PICKYNESS;
    bLowPoint = bLowest + bDelta;
    bHighPoint = bHighest - bDelta;
//!!WinAssert(bLowPoint >= bLowest);
//!!WinAssert(bHighPoint <= bHighest);
#ifdef VERBOSEDEBUG
    DPF(TEXT("0x%08lX: %3d to %3d"), (DWORD) pch,
            (int) bLowPoint, (int) bHighPoint);
#endif

    if (bLowPoint == bHighPoint)
    {
        /* avoid infinite loop */
        *(*ppchWaveBuf)++ = *((BYTE  *) pch++);
#ifdef VERBOSEDEBUG
        DPF(TEXT(" (equal)\n"));
#endif
        return pch;
    }

    /* find a "peak" */
    while ((pch != pchEnd) && (*((BYTE  *) pch) < bHighPoint))
        *(*ppchWaveBuf)++ = *((BYTE  *) pch++);

    /* find a "valley" */
    while ((pch != pchEnd) && (*((BYTE  *) pch) > bLowPoint))
        *(*ppchWaveBuf)++ = *((BYTE  *) pch++);

#ifdef VERBOSEDEBUG
    DPF(TEXT(" (copied %d)\n"), *ppchWaveBuf - pchWaveBufInit);
#endif

    return pch;
}

#endif


#if 0

/* IncreasePitch()
 *
 * Increase the pitch of samples in the wave buffer by one octave.
 */
void FAR PASCAL
IncreasePitch(void)
{
    HCURSOR         hcurPrev = NULL; // cursor before hourglass
    HPBYTE          pchEndFile;     // end of file's buffer
    HPBYTE          pchStartWave;   // start of one wave
    HPBYTE          pchMaxWave;     // last place where wave may end
    HPBYTE          pchEndWave;     // end an actual wave
    char            achWaveBuf[WAVEBUFSIZE];
    NPBYTE          pchWaveBuf;
    NPBYTE          pchSrc;
    HPBYTE          pchDst;

    if (glWaveSamplesValid == 0L)           // nothing to do?
        return;                             // don't set dirty flag

    if (!IsWaveFormatPCM(gpWaveFormat))
        return;

    /* show hourglass cursor */
    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    BeginWaveEdit();

    /* find each wave in the wave buffer and double it */
    pchEndFile = gpWaveSamples + glWaveSamplesValid;
    pchStartWave = gpWaveSamples;
    while (TRUE)
    {
        pchMaxWave = pchStartWave + WAVEBUFSIZE;
        if (pchMaxWave > pchEndFile)
            pchMaxWave = pchEndFile;
        pchWaveBuf = achWaveBuf;
        pchEndWave = FindWave(pchStartWave, pchMaxWave, &pchWaveBuf);
        pchSrc = achWaveBuf;
        pchDst = pchStartWave;
        if (pchSrc == pchWaveBuf)
            break;                  // no samples copied

        while (pchDst != pchEndWave)
        {
            *pchDst++ = *pchSrc++;
            pchSrc++;
            if (pchSrc >= pchWaveBuf)
            {
                if (pchSrc == pchWaveBuf)
                    pchSrc = achWaveBuf;
                else
                    pchSrc = achWaveBuf + 1;
            }
        }

        pchStartWave = pchEndWave;
    }

    EndWaveEdit(TRUE);

    if (hcurPrev != NULL)
        SetCursor(hcurPrev);

    /* update the display */
    UpdateDisplay(TRUE);
}

#endif


#if 0

/* DecreasePitch()
 *
 * Decrease the pitch of samples in the wave buffer by one octave.
 */
void FAR PASCAL
DecreasePitch(void)
{
    HCURSOR         hcurPrev = NULL; // cursor before hourglass
    HPBYTE          pchEndFile;     // end of file's buffer
    HPBYTE          pchStartWave;   // start of one wave
    HPBYTE          pchMaxWave;     // last place where wave may end
    HPBYTE          pchEndWave;     // end an actual wave
    char            achWaveBuf[WAVEBUFSIZE];
    NPBYTE          pchWaveBuf;     // end of first wave in <achWaveBuf>
    NPBYTE          pchSrc;         // place to read samples from
    NPBYTE          pchSrcEnd;      // end of place to read samples from
    int             iSample;        // current source sample
    int             iPrevSample;    // previous sample (for interpolation)
    HPBYTE          pchDst;         // where result gets put in buffer
    long            lNewFileSize;   // file size after pitch change

    if (glWaveSamplesValid == 0L)           // nothing to do?
        return;                             // don't set dirty flag

    if (!IsWaveFormatPCM(gpWaveFormat))
        return;

    /* show hourglass cursor */
    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    BeginWaveEdit();

    /* find each pair of waves in the wave buffer, discard the longer
     * of the two waves, and expand the shorter of the two waves to
     * twice its size
     */
    pchEndFile = gpWaveSamples + glWaveSamplesValid;
    pchStartWave = gpWaveSamples;           // read waves from here
    pchDst = gpWaveSamples;                 // write waves to here
    while (TRUE)
    {
        pchMaxWave = pchStartWave + WAVEBUFSIZE;
        if (pchMaxWave > pchEndFile)
            pchMaxWave = pchEndFile;

        /* read one wave -- make <pchWaveBuf> point to the end
         * of the wave that's copied into <achWaveBuf>
         */
        pchWaveBuf = achWaveBuf;
        pchEndWave = FindWave(pchStartWave, pchMaxWave, &pchWaveBuf);
        if (pchWaveBuf == achWaveBuf)
            break;

        /* read another wave -- make <pchWaveBuf> now point to the end
         * of that wave that's copied into <achWaveBuf>
         */
        pchEndWave = FindWave(pchEndWave, pchMaxWave, &pchWaveBuf);

        pchSrc = achWaveBuf;
        pchSrcEnd = achWaveBuf + ((pchWaveBuf - achWaveBuf) / 2);
        iPrevSample = *((BYTE *) pchSrc);
        while (pchSrc != pchSrcEnd)
        {
            iSample = *((BYTE *) pchSrc)++;
            *pchDst++ = (BYTE) ((iSample + iPrevSample) / 2);
            *pchDst++ = iSample;
            iPrevSample = iSample;
        }

        pchStartWave = pchEndWave;
    }

    /* file may have shrunk */
    lNewFileSize = pchDst - gpWaveSamples;
//!!WinAssert(lNewFileSize <= glWaveSamplesValid);
#ifdef DEBUG
    DPF(TEXT("old file size is %ld, new size is %ld\n"),
                    glWaveSamplesValid, lNewFileSize);
#endif
    AllocWaveBuffer(lNewFileSize, TRUE, TRUE);

    EndWaveEdit(TRUE);

    if (hcurPrev != NULL)
        SetCursor(hcurPrev);

    /* update the display */
    UpdateDisplay(TRUE);
}

#endif


/* AddEcho()
 *
 * Add echo to samples in the wave buffer.
 */
void FAR PASCAL
AddEcho(void)
{
    HCURSOR         hcurPrev = NULL; // cursor before hourglass
    long            lDeltaSamples;  // no. samples for echo delay
    long            lSamples;       // no. samples to modify
    int             iAmpSrc;        // current source sample amplitude
    int             iAmpDst;        // current destination sample amplitude

    if (!IsWaveFormatPCM(gpWaveFormat))
        return;

    BeginWaveEdit();

    /* figure out how many samples need to be modified */
    lDeltaSamples = MulDiv((long) ECHO_DELAY,
                             gpWaveFormat->nSamplesPerSec, 1000L);

    /* Set lSamples to be number of samples * number of channels */
    lSamples = (glWaveSamplesValid - lDeltaSamples)
                            * gpWaveFormat->nChannels;

    if (lSamples <= 0L)             // nothing to do?
        return;                     // don't set dirty flag

    /* show hourglass cursor */
    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    /* copy ECHO_VOLUME percent of each source sample (starting at
     * ECHO_DELAY milliseconds from the end of the the buffer)
     * to the each destination sample (starting at the end of the
     * buffer)
     */
    if (((LPWAVEFORMATEX)gpWaveFormat)->wBitsPerSample == 8)
    {
        HPBYTE  pchSrc;         // pointer into source part of buffer
        HPBYTE  pchDst;         // pointer into destination part
        int     iSample;        // destination sample

        pchSrc = gpWaveSamples + wfSamplesToBytes(gpWaveFormat, glWaveSamplesValid - lDeltaSamples);
        pchDst = gpWaveSamples + wfSamplesToBytes(gpWaveFormat, glWaveSamplesValid);

        while (lSamples-- > 0)
        {
            pchSrc = ((BYTE  *) pchSrc) - 1;
            iAmpSrc = (int) *((BYTE  *) pchSrc) - 128;

            pchDst = ((BYTE  *) pchDst) - 1;
            iAmpDst = (int) *((BYTE  *) pchDst) - 128;

            iSample = iAmpDst + (iAmpSrc * ECHO_VOLUME) / 100
                                                            + 128;
            *((BYTE  *) pchDst) = (BYTE)
                    (iSample < 0 ? 0 : (iSample > 255
                                            ? 255 : iSample));
        }
    }
    else
    {
        short  *  piSrc;  // pointer into source part of buffer
        short  *  piDst;  // pointer into destination part
        long            lSample;// destination sample

        piSrc = (short  *) (gpWaveSamples + wfSamplesToBytes(gpWaveFormat, glWaveSamplesValid - lDeltaSamples));
        piDst = (short  *) (gpWaveSamples + wfSamplesToBytes(gpWaveFormat, glWaveSamplesValid));

        while (lSamples-- > 0)
        {
            iAmpSrc = *--piSrc;
            iAmpDst = *--piDst;
            lSample = ((long) iAmpSrc * ECHO_VOLUME) / 100 + (long) iAmpDst;

            *piDst = (short) (lSample < -32768L
                            ? -32768 : (lSample > 32767L
                                    ? 32767 : (short) lSample));
        }
    }

    EndWaveEdit(TRUE);

    if (hcurPrev != NULL)
        SetCursor(hcurPrev);

    /* update the display */
    UpdateDisplay(TRUE);
}


/* Reverse()
 *
 * Reverse samples in the wave buffer.
 */
void FAR PASCAL
Reverse(void)
{
    HCURSOR         hcurPrev = NULL; // cursor before hourglass
    HPBYTE          pchA, pchB;     // pointers into buffer
    short  *      piA;
    short  *      piB;
    long            lSamples;       // no. Samples to modify
    char            chTmp;          // for swapping
    int             iTmp;

    if (glWaveSamplesValid == 0L)   // nothing to do?
        return;                     // don't set dirty flag

    if (!IsWaveFormatPCM(gpWaveFormat))
        return;

    BeginWaveEdit();

    /* show hourglass cursor */
    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    lSamples = glWaveSamplesValid / 2;

    if (((LPWAVEFORMATEX)gpWaveFormat)->wBitsPerSample == 8)
    {
        pchA = gpWaveSamples;
        if (gpWaveFormat->nChannels == 1)
        {
            pchB = gpWaveSamples + wfSamplesToBytes(gpWaveFormat, glWaveSamplesValid);

            while (lSamples-- > 0)
            {
                chTmp = *pchA;
                *pchA++ = *--pchB;
                *pchB = chTmp;
            }
        }
        else
        {
            pchB = gpWaveSamples + wfSamplesToBytes(gpWaveFormat, glWaveSamplesValid - 1);

            while (lSamples-- > 0)
            {
                chTmp = *pchA;
                *pchA = *pchB;
                *pchB = chTmp;
                chTmp = pchA[1];
                pchA[1] = pchB[1];
                pchB[1] = chTmp;
                pchA += 2;
                pchB -= 2;
            }
        }
    }
    else
    {
        piA = (short  *) gpWaveSamples;
        if (gpWaveFormat->nChannels == 1)
        {
            piB = (short  *) (gpWaveSamples + wfSamplesToBytes(gpWaveFormat, glWaveSamplesValid));

            while (lSamples-- > 0)
            {
                iTmp = *piA;
                *piA++ = *--piB;
                *piB = (short)iTmp;
            }
        }
        else
        {
            piB = (short  *) (gpWaveSamples + wfSamplesToBytes(gpWaveFormat, glWaveSamplesValid - 1));

            while (lSamples-- > 0)
            {
                iTmp = *piA;
                *piA = *piB;
                *piB = (short)iTmp;
                iTmp = piA[1];
                piA[1] = piB[1];
                piB[1] = (short)iTmp;
                piA += 2;
                piB -= 2;
            }
        }
    }

    /* move the current position so it corresponds to the same point
     * in the audio as it did before the reverse operation
     */
    glWavePosition = glWaveSamplesValid - glWavePosition;

    EndWaveEdit(TRUE);

    if (hcurPrev != NULL)
        SetCursor(hcurPrev);

    /* update the display */
    UpdateDisplay(TRUE);
}

#if defined(REVERB)

/* AddReverb()
 *
 * Add reverberation to samples in the wave buffer.
 * Very similar to add echo, but instead of adding a single
 * shot we
 * 1. have multiple echoes
 * 2. Have feedback so that each echo also generates an echo
 *    Danger: Because some of the echo times are short, there
 *            is likely to be high correlation between the wave
 *            at the source and destination points.  In this case
 *            we don't get an echo at all, we get a resonance.
 *            The effect of a large hall DOES give resonances,
 *            but we should scatter them about to avoid making
 *            any sharp resonance.
 *            The first echo is also chosen to be long enough that
 *            its primary resonance will be below any normal speaking
 *            voice.  20mSec is 50Hz and an octave below bass range.
 *            Low levels of sound suffer badly from quantisation noise
 *            which can get quite bad.  For this reason it's probably
 *            better to have the multipliers as powers of 2.
 *
 *    Cheat:  The reverb does NOT extend the total time (no realloc (yet).
 *
 *    This takes a lot of compute - and is not really very much different
 *    in sound to AddEcho.  Conclusion -- NOT IN PRODUCT.
 *
 */
void FAR PASCAL
AddReverb(void)
{
    HCURSOR         hcurPrev = NULL; // cursor before hourglass
    long            lSamples;       // no. samples to modify
    int             iAmpSrc;        // current source sample amplitude
    int             iAmpDst;        // current destination sample amplitude
    int i;

    typedef struct
    {  long Offset;   // delay in samples
       long Delay;    // delay in mSec
       int  Vol;      // volume multiplier in units of 1/256
    }  ECHO;

#define CREVERB  3

    ECHO Reverb[CREVERB] = { 0,  18, 64
                           , 0,  64, 64
                           };

    if (!IsWaveFormatPCM(gpWaveFormat))
        return;

    BeginWaveEdit();

    /* Convert millisec figures into samples */
    for (i=0; i<CREVERB; ++i)
    {  Reverb[i].Offset = MulDiv( Reverb[i].Delay
                                  , gpWaveFormat->nSamplesPerSec
                                  , 1000L
                                  );

       // I think this could have the effect of putting the reverb
       // from one stereo channel onto the other one sometimes.
       // It's a feature!  (Fix is to make Offset always even)
    }

    if (lSamples <= 0L)             // nothing to do?
        return;                     // don't set dirty flag

    /* show hourglass cursor */
    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    lSamples = glWaveSamplesValid * gpWaveFormat->nChannels;

    /* Work through the buffer left to right adding in the reverbs */
    if (((LPPCMWAVEFORMAT)gpWaveFormat)->wBitsPerSample == 8)
    {
        BYTE *  pbSrc;         // pointer into source part of buffer
        BYTE *  pbDst;         // pointer into destination part
        int     iSample;       // destination sample


        for (i=0; i<CREVERB; ++i)
        {   long cSamp; // loop counter
            int  Vol = Reverb[i].Vol;
            pbSrc = gpWaveSamples;
            pbDst = gpWaveSamples+Reverb[i].Offset; // but elsewhere if realloc
            cSamp = lSamples-Reverb[i].Offset;
            while (cSamp-- > 0)
            {
                iAmpSrc = (*pbSrc) - 128;
                iSample = *pbDst + MulDiv(iAmpSrc, Vol, 256);
                *pbDst = (iSample < 0 ? 0 : (iSample > 255 ? 255 : iSample));

                ++pbSrc;
                ++pbDst;
            }
        }
    }
    else
    {
        int short *     piSrc;  // pointer into source part of buffer
        int short *     piDst;  // pointer into destination part
        long            lSample;// destination sample

        piSrc = gpWaveSamples;
        piDst = gpWaveSamples;

        while (lSamples-- > 0)
        {
            iAmpSrc = *piSrc;
            for (i=0; i<CREVERB; ++i)
            {   int short * piD = piDst + Reverb[i].Offset;   // !!not win16
                lSample = *piD + MulDiv(iAmpSrc, Reverb[i].Vol, 256);
                *piDst = (short) ( lSample < -32768L
                                 ? -32768
                                 : (lSample > 32767L ? 32767 : (short) lSample)
                                 );
            }

            ++piSrc;
            ++piDst;
        }
    }

    EndWaveEdit(TRUE);

    if (hcurPrev != NULL)
        SetCursor(hcurPrev);

    /* update the display */
    UpdateDisplay(TRUE);
} /* AddReverb */
#endif //REVERB

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\soundrec\file.h ===
/* (C) Copyright Microsoft Corporation 1991.  All Rights Reserved */
/* file.h
 *
 * File I/O and related functions.
 */

#include <mmsystem.h>

/* make this a global def.*/

typedef struct tCKNODE {
   MMCKINFO ck;
   HPBYTE hpData;
   struct tCKNODE * psNext;
} CKNODE, *PCKNODE, FAR * LPCKNODE;

/* Fact Chunk, should be defined elsewhere. */
typedef struct tFACT {
   long lSamples;
} FACT, *PFACT, FAR * LPFACT;

/* export these.*/

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\soundrec\helpids.h ===
/* context sensitive help */
#define IDH_SOUNDREC_ICON       4303
#define IDH_SOUNDREC_SNDTITLE   4304
#define IDH_SOUNDREC_COPYRIGHT  4305
#define IDH_SOUNDREC_LENGTH     4306
#define IDH_SOUNDREC_SIZE       4307
#define IDH_SOUNDREC_AUDIO      4308
#define IDH_SOUNDREC_COMM_GROUPBOX  4309
#define IDH_SOUNDREC_FORMAT     4310
#define IDH_SOUNDREC_CONVERT    4311
#define IDH_SOUNDREC_SAVEFMT    4312
#define IDH_SOUNDREC_CHANGE     4313
                                      
/* menu help */
#define IDH_SOUNDREC_SNDRC_CS_FILE_NEW					4314
#define IDH_SOUNDREC_SNDRC_CS_FILE_OPEN					4315
#define IDH_SOUNDREC_SNDRC_CS_FILE_SAVE					4316
#define IDH_SOUNDREC_SNDRC_CS_FILE_SAVE_AS				4317
#define IDH_SOUNDREC_SNDRC_CS_FILE_REVERT				4318
#define IDH_SOUNDREC_SNDRC_CS_FILE_PROPERTIES				4319
#define IDH_SOUNDREC_SNDRC_CS_FILE_EXIT					4320
#define IDH_SOUNDREC_SNDRC_CS_EDIT_COPY					4321
#define IDH_SOUNDREC_SNDRC_CS_EDIT_PASTE_INSERT				4322
#define IDH_SOUNDREC_SNDRC_CS_EDIT_PASTE_MIX				4323
#define IDH_SOUNDREC_SNDRC_CS_EDIT_INSERT_FILE				4324
#define IDH_SOUNDREC_SNDRC_CS_EDIT_MIX_WITH_FILE			4325
#define IDH_SOUNDREC_SNDRC_CS_EDIT_DELETE_BEFORE_CURRENT_POSITION	4326
#define IDH_SOUNDREC_SNDRC_CS_EDIT_DELETE_AFTER_CURRENT_POSITION	4327
#define IDH_SOUNDREC_SNDRC_CS_EDIT_AUDIO_PROPERTIES			4328
#define IDH_SOUNDREC_SNDRC_CS_EFFECTS_INCREASE_VOLUME			4329
#define IDH_SOUNDREC_SNDRC_CS_EFFECTS_DECREASE_VOLUME			4330
#define IDH_SOUNDREC_SNDRC_CS_EFFECTS_INCREASE_SPEED			4331
#define IDH_SOUNDREC_SNDRC_CS_EFFECTS_DECREASE_SPEED			4332
#define IDH_SOUNDREC_SNDRC_CS_EFFECTS_ADD_ECHO				4333
#define IDH_SOUNDREC_SNDRC_CS_EFFECTS_REVERSE				4334
#define IDH_SOUNDREC_SNDRC_CS_HELP_HELP_TOPICS				4335
#define IDH_SOUNDREC_SNDRC_CS_HELP_ABOUT				4336
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\soundrec\fixreg.h ===
/*-----------------------------------------------------------------------------+
| FIXREG.H                                                                     |
|                                                                              |
| (C) Copyright Microsoft Corporation 1994.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    10-Aug-1994 Lauriegr Created.                                             |
|                                                                              |
+-----------------------------------------------------------------------------*/

/* Call this with the hwnd that you want a WM_BADREG message posted to
   It will check the registry.  No news is good news.
   It does the work on a separate thread, so this should return quickly.
*/
void BackgroundRegCheck(HWND hwnd);

/* Insert the good values into the registry
   Call this if you get a WM_BADREG back from BackgroundRegCheck.
*/
BOOL SetRegValues(void);

/*
 * Test if the app should ignore registry changes.
 */
BOOL IgnoreRegCheck(void);

/*
 * Fixup registry values to our known defaults.
 */
void FixReg(HWND hwnd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\soundrec\fixreg.c ===
/* (C) Copyright Microsoft Corporation 1991-1994.  All Rights Reserved */
/*-----------------------------------------------------------------------------+
| FIXREG.C                                                                     |
|                                                                              |
| Publisher and Video For Windows make evil changes to the registry            |
| when they are installed.  Look for these changes.  If they are spotted       |
| then put up a message box to warn the user and offer the user the chance to  |
| correct them (i.e. stuff our version back in)                                |
|                                                                              |
| (C) Copyright Microsoft Corporation 1994.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    10-Aug-1994 Lauriegr Created.                                             |
|                                                                              |
+-----------------------------------------------------------------------------*/

#include <windows.h>
#include <mmsystem.h>
#include <soundrec.h>
#include <reg.h>
#include <fixreg.h>
#include <string.h>
#include <tchar.h>

#define RC_INVOKED
#include <o2base.hxx>
#include <srs.hxx>
#undef RC_INVOKED


/* The idea is to call CheckRegValues(hinst) on a separate thread
   (sort of backgroundy thing) and have it just die
   quietly if there's no problem.  If on the other hand there is a problem
   then we need to get the message box up - and it's a VERY BAD IDEA to
   try to put a message box up on anything other than the thread that's doing
   all the UI (otherwise ScottLu will get you with a weasle word - guaranteed).

   So the background thread should PostMessage (Post, don't Send - more weasles)
   to the main thread a message to say "WM_BADREG".  The main thread should then
   wack up the dialog box by calling FixRegValues.

   Suggested coding in main thread:

       BackgroundRegCheck(hwndmain);

   in window proc for hwndmain:
       case WM_HEYUP:
           FixReg(hwndmain, title);
*/


/* These are the things we check up.

   First define them as static strings, since the compiler's not smart enough
   to spot common strings.

   NOTE - these values are NOT LOCALISED
*/
/* These are for Sound Recorder - Let's try to fix it all while we're here. */
TCHAR szSoundRec[]               = TEXT("SoundRec");
TCHAR szSoundRec_CLSID[]         = TEXT("SoundRec\\CLSID");
TCHAR szSROLE2GUID[]             = TEXT("{00020C01-0000-0000-C000-000000000046}");
TCHAR szSROLE1GUID[]             = TEXT("{0003000D-0000-0000-C000-000000000046}");
TCHAR szSRCLSID_OLE2GUID[]       = TEXT("CLSID\\{00020C01-0000-0000-C000-000000000046}");
TCHAR szSRStdExecute_Server[]    = TEXT("SoundRec\\protocol\\StdExecute\\server");
TCHAR szSR32[]                   = TEXT("sndrec32.exe");
TCHAR szSRStdFileEdit_Server[]   = TEXT("SoundRec\\protocol\\StdFileEditing\\server");
TCHAR szSRShell_Open_Command[]   = TEXT("SoundRec\\shell\\open\\command");
TCHAR szSR32Cmd[]                = TEXT("sndrec32.exe %1");
TCHAR szSRStdFileEdit_verb_0[]   = TEXT("SoundRec\\protocol\\StdFileEditing\\verb\\0");
TCHAR szSRStdFileEdit_verb_1[]   = TEXT("SoundRec\\protocol\\StdFileEditing\\verb\\1");
TCHAR szSRStdFileEdit_verb_2[]   = TEXT("SoundRec\\protocol\\StdFileEditing\\verb\\2");
TCHAR sz_Open[]                  = TEXT("&Open");

/* Array of registry value-data pairs to check:
 */
#define RES_STR_LEN 40  /* Should be enough as a maximum resource string. */
TCHAR szSound[RES_STR_LEN];      // IDS_CLASSROOT in resources
TCHAR sz_Play[RES_STR_LEN];      // IDS_PLAYVERB in resources
TCHAR sz_Edit[RES_STR_LEN];      // IDS_EDITVERB in resources

/*
 * Check for explicit equivalence.
 * These are absolutely necessary.
 */
LPTSTR RegValuesExplicit[] =
{
    szSoundRec,               szSound,          // Primary name for object
    szSoundRec_CLSID,         szSROLE2GUID,     // CLSID, very important
    szSRStdFileEdit_verb_0,   sz_Play,          // verb, very important
    szSRStdFileEdit_verb_1,   sz_Edit           // verb, very important
//    szSRCLSID_OLE2GUID,       szSound,        // not too important 
};

/*
 * Check for valid substring
 * These are OK if the substring exists, i.e:
 *
 * "ntsd.exe sndrec32.exe"
 *  or "sndrec32.exe /play" are OK.
 *
 * "qrecord.exe" is NOT ok.
 */
LPTSTR RegValuesSubstring[] =
{
    szSRStdExecute_Server,    szSR32,   szSR32,     
    szSRStdFileEdit_Server,   szSR32,   szSR32
//    szSRShell_Open_Command,   szSR32Cmd,szSR32    // user can change this
};

/*
 * Check that a REG_SZ value in the registry has the value that it should do
 * Return TRUE if it does, FALSE if it doesn't.
 */
BOOL CheckRegValue(HKEY RootKey, LPTSTR KeyName, LPTSTR ShouldBe, LPTSTR CouldBe)
{
    DWORD Type;
    TCHAR Data[100];
    DWORD cData = sizeof(Data);
    LONG lRet;
    HKEY hkey;


    if (ERROR_SUCCESS!=RegOpenKeyEx( RootKey
                                   , KeyName
                                   , 0  /* reserved */
                                   , KEY_QUERY_VALUE
                                   , &hkey
                                   )
       )
        return FALSE;  /* couldn't even open the key */


    lRet=RegQueryValueEx( hkey
                        , NULL /* ValueName */
                        , NULL  /* reserved */
                        , &Type
                        , (LPBYTE)Data
                        , &cData
                        );

    RegCloseKey(hkey);  /* no idea what to do if this fails */

    if (ERROR_SUCCESS!=lRet) return FALSE;  /* couldn't query it */

    /*  Data, cData and Type give the data, length and type */
    if (Type!=REG_SZ) return FALSE;
    //
    // if Data == ShouldBe, then lRet = 0
    //
    lRet = lstrcmp(Data, ShouldBe); /* capture lRet to make debug easier */
    if (lRet && CouldBe != NULL)
    {
        //
        // if Couldbe in Data, lRet = 0
        //
        lRet = (_tcsstr(Data, CouldBe) == NULL);
    }
    
    return 0==lRet;

} /* CheckRegValue */

#define ARRAY_SIZE(x)   (sizeof((x))/sizeof((x)[0]))

/* check the registry for anything evil.  Return TRUE if it's OK else FALSE */
BOOL CheckRegValues(void)
{
    HKEY HCL = HKEY_CLASSES_ROOT;  /* save typing! */
    DWORD i;
    
    if( !( LoadString( ghInst, IDS_USERTYPESHORT, szSound, SIZEOF(szSound) )
        && LoadString( ghInst, IDS_PLAYVERB, sz_Play, SIZEOF(sz_Play))
        && LoadString( ghInst, IDS_EDITVERB, sz_Edit, SIZEOF(sz_Edit) ) ) )
        /* If any of the strings fails to load, forget it:
         */
        return TRUE;

    for( i = 0; i < ARRAY_SIZE(RegValuesExplicit); i+=2 )
    {
        if( !CheckRegValue( HCL
                            , RegValuesExplicit[i]
                            , RegValuesExplicit[i+1]
                            , NULL ) )
            return FALSE;
    }
    for(i = 0; i < ARRAY_SIZE(RegValuesSubstring); i+=3)
    {
        if( !CheckRegValue( HCL
                            , RegValuesSubstring[i]
                            , RegValuesSubstring[i+1]
                            , RegValuesSubstring[i+2] ) )
            return FALSE;
    }

    return TRUE;

} /* CheckRegValues */


/* start this thread to get the registry checked out.
 * hwnd is typed as a LPVOID because that's what CreateThread wants.
 */
DWORD RegCheckThread(LPVOID hwnd)
{
   if (!CheckRegValues())
       PostMessage((HWND)hwnd, WM_BADREG, 0, 0);

   return 0;   /* end of thread! */
}


/* Call this with the hwnd that you want a WM_BADREG message posted to
 * It will check the registry.  No news is good news.
 * It does the work on a separate thread, so this should return quickly.
 */
void BackgroundRegCheck(HWND hwnd)
{
    HANDLE hThread;
    DWORD thid;
    hThread = CreateThread( NULL /* no special security */
                          , 0    /* default stack size */
                          , (LPTHREAD_START_ROUTINE)RegCheckThread
                          , (LPVOID)hwnd
                          , 0 /* start running at once */
                          , &thid
                          );
    if (hThread!=NULL) CloseHandle(hThread);  /* we don't need this any more */

    /* Else we're in some sort of trouble - dunno what to do.
       Can't think of an intelligible message to give to the user.
       Too bad.  Creep home quietly.
    */

} /* BackgroundRegCheck */


/* returns TRUE if it worked.  Dunno what to do if it didn't

*/
BOOL SetRegValue(HKEY RootKey, LPTSTR KeyName, LPTSTR ValueName, LPTSTR ShouldBe)
{
    HKEY hkey;

    if (ERROR_SUCCESS!=RegOpenKeyEx( RootKey
                                   , KeyName
                                   , 0  /* reserved */
                                   , KEY_SET_VALUE
                                   , &hkey
                                   )
       ) {
        /* Maybe the key has been DELETED - we've seen that */
        DWORD dwDisp;
        if (ERROR_SUCCESS!=RegCreateKeyEx( RootKey
                                         , KeyName
                                         , 0  /* reserved */
                                         , TEXT("") /* class */
                                         , REG_OPTION_NON_VOLATILE
                                         , KEY_SET_VALUE
                                         , NULL   /* SecurityAttributes */
                                         , &hkey
                                         , &dwDisp
                                       )
           ) /* well we're really in trouble */
           return FALSE;
        else /* So now it exists, but we now have to open it */
            if (ERROR_SUCCESS!=RegOpenKeyEx( RootKey
                                           , KeyName
                                           , 0  /* reserved */
                                           , KEY_SET_VALUE
                                           , &hkey
                                           )
               ) /* Give up */
                   return FALSE;

    }


    if (ERROR_SUCCESS!=RegSetValueEx( hkey
                                    , ValueName
                                    , 0  // reserved 
                                    , REG_SZ
                                    , (LPBYTE)ShouldBe
                                    , (lstrlen(ShouldBe)+1)*sizeof(TCHAR)  //BYTES
                                    )
       )
        return FALSE;    /* couldn't set it */

    if ( ERROR_SUCCESS!=RegCloseKey(hkey) )
        /* no idea what to do!*/   ;    // couldn't set it

    // I'm NOT calling RegFlushKey.  They'll get there eventually 

    return TRUE;

} /* SetRegValue */


/*
 * SetRegValues
 *  Update the registry with the correct values.  Return TRUE if everything
 *  succeeds
 * */
BOOL SetRegValues(void)
{
    HKEY HCL = HKEY_CLASSES_ROOT;  /* save typing! */
    DWORD i;

    for( i = 0; i < ARRAY_SIZE(RegValuesExplicit); i+=2 )
    {
        // Do another check to see whether this one needs changing,
        // to avoid gratuitous changes, and to avoid the slim chance
        // that an unnecessary SetRegValue might fail:
        //
        if( !CheckRegValue( HCL
                            , RegValuesExplicit[i]
                            , RegValuesExplicit[i+1]
                            , NULL ) )
        {
            if( !SetRegValue( HCL
                              , RegValuesExplicit[i]
                              , NULL
                              , RegValuesExplicit[i+1] ) )
                return FALSE;
        }
    }
    for( i = 0; i < ARRAY_SIZE(RegValuesSubstring); i+=3 )
    {
        // Do another check to see whether this one needs changing,
        // to avoid gratuitous changes, and to avoid the slim chance
        // that an unnecessary SetRegValue might fail:
        //
        if( !CheckRegValue( HCL
                            , RegValuesSubstring[i]
                            , RegValuesSubstring[i+1]
                            , RegValuesSubstring[i+2] ) )
        {
            if( !SetRegValue( HCL
                              , RegValuesSubstring[i]
                              , NULL
                              , RegValuesSubstring[i+1] ) )
                return FALSE;
        }
    }
    return TRUE;
} /* SetRegValues */

/*
 * FixReg
 * */
void FixReg(HWND hwnd)
{
    int r;

    // Error is confusing and can be caused simply by incomplete localization
    // (see bug # 34330). I removed the error so that we fix the registry
    // automatically and fixed this bug.
    r = IDYES;
//    r = ErrorResBox(hwnd
//                    , NULL
//                    , MB_ICONEXCLAMATION | MB_YESNO
//                    , IDS_APPTITLE
//                    , IDS_BADREG) ;
    switch (r)
    {
        case IDYES:
            if (!SetRegValues())
                ErrorResBox(ghwndApp
                            , ghInst
                            , MB_ICONEXCLAMATION | MB_OK
                            , IDS_APPTITLE
                            , IDS_FIXREGERROR
                            , FALSE );
            break;
        case IDNO:
        case IDCANCEL:
            /* else sneak away quietly */            
        default:
            break;
    }


}  /* FixReg */

const TCHAR aszOptionsSection[]  = TEXT("Options");
const TCHAR aszIgnoreRegistryCheck[]   = TEXT("Ignore Registry Check");
        
BOOL IgnoreRegCheck()
{
    DWORD fIgnore = 0L;
    
    ReadRegistryData((LPTSTR)aszOptionsSection
                     , (LPTSTR)aszIgnoreRegistryCheck
                     , NULL
                     , (LPBYTE)&fIgnore
                     , sizeof fIgnore);
    
    return (fIgnore != 0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\soundrec\nocrap.h ===
/* (C) Copyright Microsoft Corporation 1991.  All Rights Reserved */
// #define NOVIRTUALKEYCODES    // VK_*
#define NOICONS         // IDI_*
#define NOKEYSTATES     // MK_*
// #define NOSYSCOMMANDS    // SC_*
#define OEMRESOURCE     // OEM Resource values
// #define NOATOM       // Atom Manager routines
// #define NOCLIPBOARD      // Clipboard routines
// #define NOCTLMGR     // Control and Dialog routines
#define NODRAWTEXT      // DrawText() and DT_*
#define NOMETAFILE      // typedef METAFILEPICT
// #define NOMSG        // typedef MSG and associated routines
#define NOSOUND         // Sound driver routines
#define NOWH            // SetWindowsHook and WH_*
#define NOCOMM          // COMM driver routines
#define NOKANJI         // Kanji support stuff.
// #define NOHELP       // Help engine interface.
#define NOPROFILER      // Profiler interface.
#define NODEFERWINDOWPOS    // DeferWindowPos routines
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\soundrec\nftext.c ===
/* (C) Copyright Microsoft Corporation 1991-1994.  All Rights Reserved */
/* Revision History.
   4/2/91 LaurieGr (AKA LKG) Ported to WIN32 / WIN16 common code
*/
/* nftext.c
 *
 * Implements the no-flicker static text control ("td_nftext").
 *
 * This is NOT a general-purpose control (see the globals below).
 *
 * Note: most NoFlickerText controls use ANSI_VAR_FONT, but the status
 * control (ID_STATUSTXT) uses the font defined in the dialog box
 * template (e.g. Helv8).  Also, the foreground color of most NoFlickerText
 * controls is RGB_FGNFTEXT, but the foreground color of the status control
 * is whatever the current value of <grgbStatusColor> is.
 *
 * Borrowed from ToddLa (with many, many modifications).
 */

#include "nocrap.h"
#include <windows.h>
#include <mmsystem.h>
#include <mmreg.h>
#include "soundrec.h"



/* statics */
HFONT       ghfontDialog = NULL;        // font of dialog box

void NEAR PASCAL
NFTextPaint(HWND hwnd, HDC hdc)
{
    RECT        rc;
    TCHAR      ach[128];
    int     iLen;
    long        lStyle;
    int     xOrigin;

    GetClientRect(hwnd, &rc);
    iLen = GetWindowText(hwnd, ach, SIZEOF(ach));

    SetTextColor(hdc, grgbStatusColor);
    SelectObject(hdc, ghfontDialog);

    SetBkColor(hdc, RGB_BGNFTEXT);

    lStyle = GetWindowLong(hwnd, GWL_STYLE);
    {
        SIZE size;
        if (lStyle & SS_RIGHT)
        {   GetTextExtentPoint(hdc, ach, iLen, &size);
            xOrigin = rc.right - size.cx;
        }
        else
        if (lStyle & SS_CENTER)
        {   GetTextExtentPoint(hdc, ach, iLen, &size);
            xOrigin = (rc.right - size.cx) / 2;
        }
        else
            xOrigin = 0;
    }


    ExtTextOut(hdc, xOrigin, 0, ETO_OPAQUE,
           &rc, ach, iLen, NULL);
}

INT_PTR CALLBACK
NFTextWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT ps;
    HDC     hdc;

    switch (wMsg)
    {

    case WM_SETTEXT:

        DefWindowProc(hwnd, wMsg, wParam, lParam);
        hdc = GetDC(hwnd);
        if (hdc)
        {
            NFTextPaint(hwnd, hdc);
            ReleaseDC(hwnd, hdc);
        }
        return 0L;

    case WM_SETFONT:

        ghfontDialog = (HFONT)wParam;
        return 0L;

    case WM_ERASEBKGND:

        return 0L;

    case WM_PAINT:

        BeginPaint(hwnd, &ps);
        NFTextPaint(hwnd, ps.hdc);
        EndPaint(hwnd, &ps);
        return 0L;
    }

    return DefWindowProc(hwnd, wMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\soundrec\oleglue.h ===
//
// FILE:    oleglue.h
//
// NOTES:   All OLE-related outbound references from SoundRecorder
//
#include <ole2.h>


#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#if DBG
#define DOUT(t)    OutputDebugString(t)
#define DOUTR(t)   OutputDebugString(t TEXT("\n"))
#else // !DBG
#define DOUT(t)
#define DOUTR(t)
#endif
    
extern DWORD dwOleBuildVersion;
extern BOOL gfOleInitialized;

extern BOOL gfStandalone;
extern BOOL gfEmbedded;
extern BOOL gfLinked;

extern BOOL gfTerminating;

extern BOOL gfUserClose;
extern HWND ghwndApp;
extern HICON ghiconApp;

extern BOOL gfClosing;

extern BOOL gfHideAfterPlaying;
extern BOOL gfShowWhilePlaying;
extern BOOL gfDirty;

extern int giExtWidth;
extern int giExtHeight;

#define CTC_RENDER_EVERYTHING       0   // render all data
#define CTC_RENDER_ONDEMAND         1   // render cfNative and CF_WAVE as NULL
#define CTC_RENDER_LINK             2   // render all data, except cfNative

extern TCHAR gachLinkFilename[_MAX_PATH];

/*
 * from srfact.cxx
 */
extern HRESULT ReleaseSRClassFactory(void);
extern BOOL CreateSRClassFactory(HINSTANCE hinst,BOOL fEmbedded);

extern BOOL InitializeSRS(HINSTANCE hInst);
extern void FlagEmbeddedObject(BOOL flag);

extern void DoOleClose(BOOL fSave);
extern void DoOleSave(void);
extern void TerminateServer(void);
extern void FlushOleClipboard(void);
extern void AdviseDataChange(void);
extern void AdviseRename(LPTSTR lpname);
extern void AdviseSaved(void);
extern void AdviseClosed(void);

extern HANDLE GetNativeData(void);
extern LPBYTE PutNativeData(LPBYTE lpbData, DWORD dwSize);

extern BOOL FileLoad(LPCTSTR lpFileName);
extern void BuildUniqueLinkName(void);

/* in srfact.cxx */
extern BOOL CreateStandaloneObject(void);

/* new clipboard stuff */
extern BOOL gfXBagOnClipboard;
extern void TransferToClipboard(void);

/* access to current server state data */
extern HANDLE GetPicture(void);
extern HBITMAP GetBitmap(void);
extern HANDLE GetDIB(HANDLE);

/* link helpers */
extern BOOL IsDocUntitled(void);

/* menu fixup */
extern void FixMenus(void);

/* Play sound */
extern void AppPlay(BOOL fClose);

/* Get Host names */
extern void OleObjGetHostNames(LPTSTR *ppCntr, LPTSTR *ppObj);

/* Ole initialization */
extern BOOL InitializeOle(HINSTANCE hInst);

extern void WriteObjectIfEmpty(void);

#ifdef __cplusplus
}
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\soundrec\reg.h ===
DWORD ReadRegistryData( LPTSTR pEntryNode,
                        LPTSTR pEntryName,
                        PDWORD pType,
                        LPBYTE pData,
                        DWORD  DataSize );

DWORD WriteRegistryData( LPTSTR pEntryNode,
                         LPTSTR pEntryName,
                         DWORD  Type,
                         LPBYTE pData,
                         DWORD  Size );
DWORD QueryRegistryDataSize( LPTSTR  pEntryNode,
                            LPTSTR  pEntryName,
                            DWORD   *pDataSize );

enum { SGSRR_GET, SGSRR_SET };

BOOL SoundRec_GetSetRegistryRect(
    HWND	hwnd,
    int         Get);

BOOL SoundRec_GetDefaultFormat(
    LPWAVEFORMATEX  *ppwfx,
    DWORD           *pcbwfx);

BOOL SoundRec_SetDefaultFormat(
    LPTSTR lpFormat);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\soundrec\oleglue.c ===
/* (C) Copyright Microsoft Corporation 1991-1994.  All Rights Reserved */
//
// FILE:    oleglue.c
//
// NOTES:   OLE-related outbound references from SoundRecorder
//

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <shellapi.h>
#include <objbase.h>

#define INCLUDE_OLESTUBS
#include "soundrec.h"
#include "srecids.h"

//
// GLOBALS
//

// should unify state variables and put globals into a single location

DWORD dwOleBuildVersion = 0;    // OLE library version number
BOOL gfOleInitialized = FALSE;  // did OleInitialize succeed?

BOOL gfStandalone = FALSE;      // status, are we a non-embedded object
BOOL gfEmbedded = FALSE;        // were we invoked with an -Embedding flag?
BOOL gfLinked = FALSE;          // are we a linked object?

BOOL gfTerminating = FALSE;     // has TerminateServer been called?

BOOL gfHideAfterPlaying = FALSE;
BOOL gfShowWhilePlaying = TRUE;
BOOL gfCloseAtEndOfPlay = FALSE;

TCHAR gachLinkFilename[_MAX_PATH];

BOOL gfClosing = FALSE;

int giExtWidth;                 // Metafile extent width
int giExtHeight;                // Metafile extent height

//
// Utility functions ported from old OLE1 code
//

/*
 *  DibFromBitmap()
 *
 *  Will create a global memory block in DIB format that represents the DDB
 *  passed in
 *
 */

#define WIDTHBYTES(i)     ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */

HANDLE FAR PASCAL DibFromBitmap(HBITMAP hbm, HPALETTE hpal, HANDLE hMem)
{
    BITMAP               bm;
    BITMAPINFOHEADER     bi;
    BITMAPINFOHEADER FAR *lpbi;
    DWORD                dw;
    HANDLE               hdib = NULL;
    HDC                  hdc;
    HPALETTE             hpalT;

    if (!hbm)
        return NULL;

    GetObject(hbm,sizeof(bm),&bm);

    bi.biSize               = sizeof(BITMAPINFOHEADER);
    bi.biWidth              = bm.bmWidth;
    bi.biHeight             = bm.bmHeight;
    bi.biPlanes             = 1;
    bi.biBitCount           = (bm.bmPlanes * bm.bmBitsPixel) > 8 ? 24 : 8;
    bi.biCompression        = BI_RGB;
    bi.biSizeImage          = (DWORD)WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;
    bi.biXPelsPerMeter      = 0;
    bi.biYPelsPerMeter      = 0;
    bi.biClrUsed            = bi.biBitCount == 8 ? 256 : 0;
    bi.biClrImportant       = 0;

    dw  = bi.biSize + bi.biClrUsed * sizeof(RGBQUAD) + bi.biSizeImage;

    if (hMem && GlobalSize(hMem) != 0)
    {
        if (GlobalSize(hMem) < dw)
            return NULL;

        lpbi = GlobalLock(hMem);
    }
    else
        lpbi = GlobalAllocPtr(GHND | GMEM_DDESHARE, dw);

    if (!lpbi)
        return NULL;
        
    *lpbi = bi;

    hdc = CreateCompatibleDC(NULL);

    if (hdc)
    {
        if (hpal)
        {
            hpalT = SelectPalette(hdc,hpal,FALSE);
            RealizePalette(hdc);
        }

        GetDIBits(hdc, hbm, 0, (UINT)bi.biHeight,
            (LPBYTE)lpbi + (int)lpbi->biSize + (int)lpbi->biClrUsed * sizeof(RGBQUAD),
            (LPBITMAPINFO)lpbi, DIB_RGB_COLORS);

        if (hpal)
            SelectPalette(hdc,hpalT,FALSE);

        DeleteDC(hdc);
    }

    hdib = GlobalHandle(lpbi);
    GlobalUnlock(hdib);
    
    return hdib;
}

HANDLE GetDIB(HANDLE hMem)
{
    HPALETTE hpal = GetStockObject(DEFAULT_PALETTE);
    HBITMAP hbm = GetBitmap();
    HANDLE hDib = NULL;

    if (hbm && hpal)
    {
        hDib = DibFromBitmap(hbm,hpal,hMem);
        if (!hDib)
            DOUT(TEXT("DibFromBitmap failed!\r\n"));
    }
    
    if (hpal)
        DeleteObject(hpal);
    
    if (hbm)
        DeleteObject(hbm);
    
    return hDib;
}

HBITMAP
GetBitmap(void)
{
    HDC hdcmem = NULL;
    HDC hdc = NULL;
    HBITMAP hbitmap = NULL;
    HBITMAP holdbitmap = NULL;
    RECT rc;
    hdc = GetDC(ghwndApp);
    if (hdc)
    {
        SetRect(&rc, 0, 0,
                GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON));

        hdcmem = CreateCompatibleDC(hdc);
        if (hdcmem)
        {
            hbitmap = CreateCompatibleBitmap(hdc, rc.right, rc.bottom);
            holdbitmap = (HBITMAP)SelectObject(hdcmem, hbitmap);

            // paint directly into the bitmap
            PatBlt(hdcmem, 0, 0, rc.right, rc.bottom, WHITENESS);
            DrawIcon(hdcmem, 0, 0, ghiconApp);

            hbitmap = (HBITMAP)SelectObject(hdcmem, holdbitmap);
            DeleteDC(hdcmem);
        }
        ReleaseDC(ghwndApp, hdc);
    }
    return hbitmap;
}

#pragma message("this code should extract the picture from the file")

HANDLE
GetPicture(void)
{
    HANDLE hpict = NULL;
    HMETAFILE hMF = NULL;

    LPMETAFILEPICT lppict = NULL;
    HBITMAP hbmT = NULL;
    HDC hdcmem = NULL;
    HDC hdc = NULL;

    BITMAP bm;
    HBITMAP hbm;
    
    hbm = GetBitmap();
    
    if (hbm == NULL)
        return NULL;

    GetObject(hbm, sizeof(bm), (LPVOID)&bm);
    hdc = GetDC(ghwndApp);
    if (hdc)
    {
        hdcmem = CreateCompatibleDC(hdc);
        ReleaseDC(ghwndApp, hdc);
    }
    if (!hdcmem)
    {
        DeleteObject(hbm);
        return NULL;
    }
    hdc = CreateMetaFile(NULL);
    hbmT = (HBITMAP)SelectObject(hdcmem, hbm);

    SetWindowOrgEx(hdc, 0, 0, NULL);
    SetWindowExtEx(hdc, bm.bmWidth, bm.bmHeight, NULL);

    StretchBlt(hdc,    0, 0, bm.bmWidth, bm.bmHeight,
               hdcmem, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY);

    hMF = CloseMetaFile(hdc);

    SelectObject(hdcmem, hbmT);
    DeleteObject(hbm);
    DeleteDC(hdcmem);

    lppict = (LPMETAFILEPICT)GlobalAllocPtr(GHND|GMEM_DDESHARE
                                            , sizeof(METAFILEPICT));
    if (!lppict)
    {
        if (hMF)
            DeleteMetaFile(hMF);
        return NULL;
    }
    
    hdc = GetDC(ghwndApp);
    lppict->mm   = MM_ANISOTROPIC;
    lppict->hMF  = hMF;
    lppict->xExt = MulDiv(bm.bmWidth,  2540, GetDeviceCaps(hdc, LOGPIXELSX));
    lppict->yExt = MulDiv(bm.bmHeight, 2540, GetDeviceCaps(hdc, LOGPIXELSX));
    
    giExtWidth = lppict->xExt;    
    giExtHeight = lppict->yExt;
    
    ReleaseDC(ghwndApp, hdc);

    hpict = GlobalHandle(lppict);
    GlobalUnlock(hpict);
    
    return hpict;
}

//
// Code ported from server.c (OLE1) for serialization...
//

HANDLE GetNativeData(void)
{
    LPBYTE      lplink = NULL;
    MMIOINFO    mmioinfo;
    HMMIO       hmmio;
    BOOL        fOk;

    lplink = (LPBYTE)GlobalAllocPtr(GHND | GMEM_SHARE, 4096L);

    if (lplink == NULL)
    {
#if DBG
        OutputDebugString(TEXT("GetNativeData: malloc failed\r\n"));
#endif        
        return NULL;
    }
    mmioinfo.fccIOProc  = FOURCC_MEM;
    mmioinfo.pIOProc    = NULL;
    mmioinfo.pchBuffer  = lplink;
    mmioinfo.cchBuffer  = 4096L;        // initial size
    mmioinfo.adwInfo[0] = 4096L;        // grow by this much
    hmmio = mmioOpen(NULL, &mmioinfo, MMIO_READWRITE);

    if (hmmio == NULL)
    {
        GlobalFreePtr(lplink);
        return NULL;
    }

    fOk = WriteWaveFile(hmmio
                         , gpWaveFormat
                         , gcbWaveFormat
                         , gpWaveSamples
                         , glWaveSamplesValid);

    mmioGetInfo(hmmio, &mmioinfo, 0);
    mmioClose(hmmio,0);

    if (fOk)
    {
        //
        // Warning, the buffer we allocated may have been realloc'd
        //
        HANDLE hlink = GlobalHandle(mmioinfo.pchBuffer);
        GlobalUnlock(hlink);
        return hlink;
    }
    else
    {
        gfErrorBox++;
        ErrorResBox( ghwndApp
                   , ghInst
                   , MB_ICONEXCLAMATION | MB_OK
                   , IDS_APPTITLE
                   , IDS_ERROREMBED
                   );
#if DBG
        OutputDebugString(TEXT("Failed to WriteWaveFile\r\n"));
#endif
        gfErrorBox--;
        
        //
        // Warning, the buffer we allocated may have been realloc'd
        //
        if (mmioinfo.pchBuffer)
            GlobalFreePtr(mmioinfo.pchBuffer);
        
        return NULL;
    }
}

/*
 * Called from OLE storage code
 */
LPBYTE PutNativeData(LPBYTE lpbData, DWORD dwSize)
{
    MMIOINFO        mmioinfo;
    HMMIO           hmmio;

    MMRESULT        mmr;
    LPWAVEFORMATEX  pwfx;
    DWORD           cbwfx;
    DWORD           cbdata;
    LPBYTE          pdata;

    mmioinfo.fccIOProc = FOURCC_MEM;
    mmioinfo.pIOProc = NULL;
    mmioinfo.pchBuffer = lpbData;
    mmioinfo.cchBuffer = dwSize;    // initial size
    mmioinfo.adwInfo[0] = 0L;       // grow by this much

    hmmio = mmioOpen(NULL, &mmioinfo, MMIO_READ);
    if (hmmio)
    {
        mmr = ReadWaveFile(hmmio
                           , &pwfx
                           , &cbwfx
                           , &pdata
                           , &cbdata
                           , TEXT("NativeData")
                           , TRUE);
        
        mmioClose(hmmio,0);

        if (mmr != MMSYSERR_NOERROR)
            return NULL;
        
        if (pwfx == NULL)
            return NULL;
        
        DestroyWave();
        
        gpWaveFormat = pwfx;  
        gcbWaveFormat = cbwfx;
        gpWaveSamples = pdata;
        glWaveSamples = cbdata;
    }

    //
    // update state variables
    //
    glWaveSamplesValid = glWaveSamples;
    glWavePosition = 0L;
    gfDirty = FALSE;
    
    //
    // update the display
    //
    UpdateDisplay(TRUE);

    return (LPBYTE)gpWaveSamples;
}

/*
 * PERMANENT ENTRY POINTS
 */
BOOL ParseCommandLine(LPTSTR lpCommandLine);

/*
 * modifies gfEmbedded, initializes gStartParams
 */

BOOL InitializeSRS(HINSTANCE hInst)
{
    TCHAR * lptCmdLine = GetCommandLine();
    BOOL fOLE = FALSE, fServer;
    gfUserClose = FALSE;
    
    gachLinkFilename[0] = 0;

    fServer = ParseCommandLine(lptCmdLine);
    gfEmbedded = fServer;       // We are embedded or linked
    
    if (!fServer)
    {
        if (gStartParams.achOpenFilename[0] != 0)
        {
            lstrcpy(gachLinkFilename, gStartParams.achOpenFilename);
        }
    }

    //
    // Only if we are invoked as an embedded object do we initialize OLE.
    // Defer initialization for the standalone object until later.
    //
    if (gfEmbedded)
        fOLE = InitializeOle(hInst);
    
    return fOLE;
}

/* OLE initialization
 */
BOOL InitializeOle(HINSTANCE hInst)
{
    BOOL fOLE;

    DOUT(TEXT("SOUNDREC: Initializing OLE\r\n"));
    
    dwOleBuildVersion = OleBuildVersion();

    // Fix bug #33271
    // As stated in the docs:
    // Typically, the COM library is initialized on an apartment only once. 
    // Subsequent calls will succeed, as long as they do not attempt to change 
    // the concurrency model of the apartment, but will return S_FALSE. To close 
    // the COM library gracefully, each successful call to OleInitialize, 
    // including those that return S_FALSE, must be balanced by a corresponding 
    // call to OleUninitialize.
    // gfOleInitialized = (OleInitialize(NULL) == NOERROR) ? TRUE : FALSE;
    gfOleInitialized = SUCCEEDED(OleInitialize(NULL));

    if (gfOleInitialized)
        fOLE = CreateSRClassFactory(hInst, gfEmbedded);
    else
        fOLE = FALSE;   // signal a serious problem!
    
    return fOLE;
}

/*
 * Initialize the state of the application or
 * change state from Embedded to Standalone.
 */
void FlagEmbeddedObject(BOOL flag)
{
    // Set global state variables.  Note, gfEmbedding is untouched.    
    gfEmbeddedObject = flag;
    gfStandalone = !flag;

}


void SetOleCaption(
    LPTSTR      lpszObj)
{
    TCHAR       aszFormatString[256];
    LPTSTR      lpszTitle;
    
    //
    // Change title to "Sound Object in XXX"
    //
    LoadString(ghInst, IDS_OBJECTTITLE, aszFormatString,
        SIZEOF(aszFormatString));

    lpszTitle = (LPTSTR)GlobalAllocPtr(GHND, (lstrlen(lpszObj) + SIZEOF(aszFormatString))*sizeof(TCHAR));
    if (lpszTitle)
    {
        wsprintf(lpszTitle, aszFormatString, lpszObj);
        SetWindowText(ghwndApp, lpszTitle);
        GlobalFreePtr(lpszTitle);
    }
}

void SetOleMenu(
    HMENU       hMenu,
    LPTSTR      lpszObj)
{
    TCHAR       aszFormatString[256];
    LPTSTR      lpszMenu;
    
    //
    // Change menu to "Exit & Return to XXX"
    //
    LoadString(ghInst, IDS_EXITANDRETURN, aszFormatString,
        SIZEOF(aszFormatString));

    lpszMenu = (LPTSTR)GlobalAllocPtr(GHND, (lstrlen(lpszObj) + SIZEOF(aszFormatString))*sizeof(TCHAR));
    if (lpszMenu)
    {
        wsprintf(lpszMenu, aszFormatString, lpszObj);
        ModifyMenu(hMenu, IDM_EXIT, MF_BYCOMMAND, IDM_EXIT, lpszMenu);
        GlobalFreePtr(lpszMenu);
    }
}

/* Adjust menus according to system state.
 * */
void FixMenus(void)
{
    HMENU       hMenu;
     
    hMenu = GetMenu(ghwndApp);
    
    if (!gfLinked && gfEmbeddedObject)
    {
        // Remove these menu items as they are irrelevant.
        
        DeleteMenu(hMenu, IDM_NEW, MF_BYCOMMAND);
        DeleteMenu(hMenu, IDM_SAVE, MF_BYCOMMAND);
        DeleteMenu(hMenu, IDM_SAVEAS, MF_BYCOMMAND);
        DeleteMenu(hMenu, IDM_REVERT, MF_BYCOMMAND);
        DeleteMenu(hMenu, IDM_OPEN, MF_BYCOMMAND);
    }
    else
    {
        TCHAR       ach[40];
// Is this necessary?
        LoadString(ghInst, IDS_NONEMBEDDEDSAVE, ach, SIZEOF(ach));
        ModifyMenu(hMenu, IDM_SAVE, MF_BYCOMMAND, IDM_SAVE, ach);
    }

    //
    // Update the titlebar and exit menu too.
    //
    if (!gfLinked && gfEmbeddedObject)
    {
        LPTSTR lpszObj = NULL;
        LPTSTR lpszApp = NULL;
        
        OleObjGetHostNames(&lpszApp,&lpszObj);
        if (lpszObj)
            lpszObj = (LPTSTR)FileName((LPCTSTR)lpszObj);
        if (lpszObj)
        {
            SetOleCaption(lpszObj);
            SetOleMenu(hMenu, lpszObj);
        }
    }

    DrawMenuBar(ghwndApp);  /* Can't hurt... */
}

#define WM_USER_DESTROY         (WM_USER+10)

//
// Called from WM_CLOSE (from user) or SCtrl::~SCtrl (from container)
//
void TerminateServer(void)
{
    DOUT(TEXT("SoundRec: TerminateServer\r\n"));
    
    gfTerminating = TRUE;

    if (gfOleInitialized)
    {
        WriteObjectIfEmpty();
        
        ReleaseSRClassFactory();
        FlushOleClipboard();
        
        //
        // If, at this time, we haven't closed, we really should.
        //
        if (!gfClosing)
        {
            DoOleClose(TRUE);
            AdviseClosed();
        }
    }
    //
    // only if the user is terminating OR we're embedded
    //
    if (gfUserClose || !gfStandalone)
        PostMessage(ghwndApp, WM_USER_DESTROY, 0, 0);
}

/* start params!
 * the app will use these params to determine behaviour once started.
 */
StartParams gStartParams = { FALSE,FALSE,FALSE,FALSE,TEXT("") };

BOOL ParseCommandLine(LPTSTR lpCommandLine)
{
    
#define TEST_STRING_MAX 11      // sizeof szEmbedding
#define NUMOPTIONS      6

    static TCHAR szEmbedding[] = TEXT("embedding");
    static TCHAR szPlay[]      = TEXT("play");
    static TCHAR szOpen[]      = TEXT("open");
    static TCHAR szNew[]       = TEXT("new");
    static TCHAR szClose[]     = TEXT("close");
    
    static struct tagOption {
        LPTSTR name;
        LPTSTR filename;
        int    cchfilename;
        LPBOOL state;
    } options [] = {
        { NULL, gStartParams.achOpenFilename, _MAX_PATH, &gStartParams.fOpen },
        { szEmbedding, gStartParams.achOpenFilename, _MAX_PATH, &gfEmbedded },
        { szPlay, gStartParams.achOpenFilename, _MAX_PATH, &gStartParams.fPlay },
        { szOpen, gStartParams.achOpenFilename, _MAX_PATH, &gStartParams.fOpen },
        { szNew, gStartParams.achOpenFilename, _MAX_PATH, &gStartParams.fNew },
        { szClose, NULL, 0, &gStartParams.fClose }
    };

    LPTSTR pchNext;
    int iOption = 0,i,cNumOptions = sizeof(options)/sizeof(struct tagOption);
    TCHAR szSwitch[TEST_STRING_MAX];
    TCHAR ch;
    
    if (lpCommandLine == NULL)
        return FALSE;
    
    
    /* skip argv[0] */
    if (*lpCommandLine == TEXT('"'))
    {
        //
        // eat up everything to the next quote
        //
        lpCommandLine++;
        do {
            ch = *lpCommandLine++;
        }
        while (ch != TEXT('"'));
    }
    else
    {
        //
        // eat up everything to the next whitespace
        //
        ch = *lpCommandLine;
        while (ch != TEXT(' ') && ch != TEXT('\t') && ch != TEXT('\0'))
            ch = *++lpCommandLine;
    }
    
    pchNext = lpCommandLine;
    while ( *pchNext )
    {
        LPTSTR pchName = options[iOption].filename;
        int cchName = options[iOption].cchfilename;
        
        /* whitespace */
        switch (*pchNext)
        {
            case TEXT(' '):
            case TEXT('\t'):
                pchNext++;
                continue;

            case TEXT('-'):
            case TEXT('/'):
            {
                lstrcpyn(szSwitch,pchNext+1,TEST_STRING_MAX);
                szSwitch[TEST_STRING_MAX-1] = 0;

                /* scan to the NULL or ' ' and terminate string */
                
                for (i = 0; i < TEST_STRING_MAX && szSwitch[i] != 0; i++)
                    if (szSwitch[i] == TEXT(' '))
                    {
                        szSwitch[i] = 0;
                        break;
                    }
                
                /* now test each option switch for a hit */

                for (i = 0; i < cNumOptions; i++)
                {
                    if (options[i].name == NULL)
                        continue;
                    
                    if (!lstrcmpi(szSwitch,options[i].name))
                    {
                        *(options[i].state) = TRUE;
                        if (options[i].filename)
                        /* next non switch string applies to this option */
                            iOption = i;
                        break;
                    }
                }
                
                /* seek ahead */
                while (*pchNext && *pchNext != TEXT(' '))
                    pchNext++;
                
                continue;
            }
            case TEXT('\"'):
                /* filename */
                /* copy up to next quote */
                pchNext++;
                while (*pchNext && *pchNext != TEXT('\"'))
                {
                    if (cchName)
                    {
                        *pchName++ = *pchNext++;
                        cchName--;
                    }
                    else
                        break;
                }
                pchNext++;
                
                continue;
                    
            default:
                /* filename */
                /* copy up to the end */
                while (*pchNext && cchName)
                {
                        *pchName++ = *pchNext++;
                        cchName--;
                }
                break;
        }
    }
    /* special case.
     * we are linked if given a LinkFilename and an embedding flag.
     * Does this ever happen or only through IPersistFile?
     */
    if (gfEmbedded && gStartParams.achOpenFilename[0] != 0)
    {
        gfLinked = TRUE;
    }
    return gfEmbedded;
}

void
BuildUniqueLinkName(void)
{
    //
    //Ensure a unique filename in gachLinkFilename so we can create valid
    //FileMonikers...
    //
    if(gachLinkFilename[0] == 0)
    {
        TCHAR aszFile[_MAX_PATH];
        GetTempFileName(TEXT("."), TEXT("Tmp"), 0, gachLinkFilename);
        
        /* GetTempFileName creates an empty file, delete it.
         */
               
        GetFullPathName(gachLinkFilename,SIZEOF(aszFile),aszFile,NULL);
        DeleteFile(aszFile);
    }
    
}


void AppPlay(BOOL fClose)
{
    if (fClose)
    {
        //ugh.  don't show while playing.
        gfShowWhilePlaying = FALSE;
    }
    
    if (IsWindow(ghwndApp))
    {
        gfCloseAtEndOfPlay = fClose;
            
        PostMessage(ghwndApp,WM_COMMAND,ID_PLAYBTN, 0L);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\soundrec\init.c ===
/* (C) Copyright Microsoft Corporation 1991-1994.  All Rights Reserved */
/* init.c
 *
 * init (discardable) utility functions.
 */
/* Revision History.
 *  4/2/91    LaurieGr (AKA LKG) Ported to WIN32 / WIN16 common code
 * 22/Feb/94  LaurieGr merged Motown and Daytona versions
 */

#include <windows.h>
#include <mmsystem.h>
#include <shellapi.h>
#include <mmreg.h>
#include <winnls.h>
#include <tchar.h>

#define INCLUDE_OLESTUBS
#include "soundrec.h"
#include "srecids.h"
#include "reg.h"

#define NOMENUHELP
#define NODRAGLIST
#ifdef USE_MMCNTRLS
#include "mmcntrls.h"
#else
#include <commctrl.h>
#include "buttons.h"
#endif

/* globals */
TCHAR    gachAppName[12];    // 8-character name
TCHAR    gachAppTitle[30];   // full name
TCHAR    gachHelpFile[20];   // name of help file
TCHAR    gachHtmlHelpFile[20];   // name of help file
TCHAR    gachDefFileExt[10]; // default file extension

HBRUSH   ghbrPanel = NULL;   // color of main window
HANDLE   ghAccel;
TCHAR    aszNull[2];
TCHAR    aszUntitled[32];    // Untitled string resource
							 // SIZEOF(szUntitled) must be <= SIZEOF(gachFileName)
TCHAR    aszFilter[64];      // Common Dialog file list filter
#ifdef FAKEITEMNAMEFORLINK
TCHAR    aszFakeItemName[16];    // Wave
#endif
TCHAR    aszPositionFormat[32];
TCHAR    aszNoZeroPositionFormat[32];

extern UINT     guWaveHdrs ;            // 1/2 second of buffering?
extern DWORD    gdwBufferDeltaMSecs ;   // # msecs added to end on record
extern UINT     gwMSecsPerBuffer;       // 1/8 second. initialised in this file

extern BITMAPBTN tbPlaybar[];

static  SZCODE aszDecimal[] = TEXT("sDecimal");
static  SZCODE aszLZero[] = TEXT("iLzero");
static  SZCODE aszWaveClass[] = TEXT("wavedisplay");
static  SZCODE aszNoFlickerClass[] = TEXT("noflickertext");
static  SZCODE aszShadowClass[] = TEXT("shadowframe");

static  SZCODE aszBufferDeltaSeconds[]  = TEXT("BufferDeltaSeconds");
static  SZCODE aszNumAsyncWaveHeaders[] = TEXT("NumAsyncWaveHeaders");
static  SZCODE aszMSecsPerAsyncBuffer[] = TEXT("MSecsPerAsyncBuffer");


/* FixupNulls(chNull, p)
 *
 * To facilitate localization, we take a localized string with non-NULL
 * NULL substitutes and replacement with a real NULL.
 */
 
void NEAR PASCAL FixupNulls(
    TCHAR chNull,
    LPTSTR p)
{
    while (*p) {
        if (*p == chNull)
            *p++ = 0;
        else
            p = CharNext(p);
    }
} /* FixupNulls */

/* AppInit(hInst, hPrev)
 *
 * This is called when the application is first loaded into memory.
 * It performs all initialization that doesn't need to be done once
 * per instance.
 */
BOOL PASCAL AppInit(
    HINSTANCE      hInst,      // instance handle of current instance
    HINSTANCE      hPrev)      // instance handle of previous instance
{
#ifdef OLE1_REGRESS        
    TCHAR       aszClipFormat[32];
#endif    
    WNDCLASS    cls;
    UINT            i;

    /* load strings */
    LoadString(hInst, IDS_APPNAME, gachAppName, SIZEOF(gachAppName));
    LoadString(hInst, IDS_APPTITLE, gachAppTitle, SIZEOF(gachAppTitle));
    LoadString(hInst, IDS_HELPFILE, gachHelpFile, SIZEOF(gachHelpFile));
    LoadString(hInst, IDS_HTMLHELPFILE, gachHtmlHelpFile, SIZEOF(gachHtmlHelpFile));
    LoadString(hInst, IDS_UNTITLED, aszUntitled, SIZEOF(aszUntitled));
    LoadString(hInst, IDS_FILTER, aszFilter, SIZEOF(aszFilter));
    LoadString(hInst, IDS_FILTERNULL, aszNull, SIZEOF(aszNull));
    LoadString(hInst, IDS_DEFFILEEXT, gachDefFileExt, SIZEOF(gachDefFileExt));
    FixupNulls(*aszNull, aszFilter);

#ifdef FAKEITEMNAMEFORLINK
    LoadString(hInst, IDS_FAKEITEMNAME, aszFakeItemName, SIZEOF(aszFakeItemName));
#endif
    LoadString(hInst, IDS_POSITIONFORMAT, aszPositionFormat, SIZEOF(aszPositionFormat));
    LoadString(hInst, IDS_NOZEROPOSITIONFORMAT, aszNoZeroPositionFormat, SIZEOF(aszNoZeroPositionFormat));

    ghiconApp = LoadIcon(hInst, MAKEINTRESOURCE(IDI_APP));


#ifdef OLE1_REGRESS
    /* Initialize OLE server stuff */
    InitVTbls();
    
//    IDS_OBJECTLINK          "ObjectLink"
//    IDS_OWNERLINK           "OwnerLink"
//    IDS_NATIVE              "Native"
    LoadString(hInst, IDS_OBJECTLINK, aszClipFormat, SIZEOF(aszClipFormat));
    cfLink      = (OLECLIPFORMAT)RegisterClipboardFormat(aszClipFormat);
    LoadString(hInst, IDS_OWNERLINK, aszClipFormat, SIZEOF(aszClipFormat));
    cfOwnerLink = (OLECLIPFORMAT)RegisterClipboardFormat(aszClipFormat);
    LoadString(hInst, IDS_NATIVE, aszClipFormat, SIZEOF(aszClipFormat));
    cfNative    = (OLECLIPFORMAT)RegisterClipboardFormat(aszClipFormat);
#if 0
    cfLink      = (OLECLIPFORMAT)RegisterClipboardFormatA("ObjectLink");
    cfOwnerLink = (OLECLIPFORMAT)RegisterClipboardFormatA("OwnerLink");
    cfNative    = (OLECLIPFORMAT)RegisterClipboardFormatA("Native");
#endif
            
#endif
    
#ifdef DEBUG
    
    ReadRegistryData(NULL
                     , TEXT("Debug")
                     , NULL
                     , (LPBYTE)&__iDebugLevel
                     , (DWORD)sizeof(__iDebugLevel));
    
    DPF(TEXT("Debug level = %d\n"),__iDebugLevel);
    
#endif

    ghbrPanel = CreateSolidBrush(RGB_PANEL);

    if (hPrev == NULL)
    {
        /* register the "wavedisplay" window class */
        cls.lpszClassName  = aszWaveClass;
        cls.hCursor        = LoadCursor(NULL, IDC_ARROW);
        cls.hIcon          = NULL;
        cls.lpszMenuName   = NULL;
        cls.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
        cls.hInstance      = hInst;
        cls.style          = CS_HREDRAW | CS_VREDRAW;
        cls.lpfnWndProc    = WaveDisplayWndProc;
        cls.cbClsExtra     = 0;
        cls.cbWndExtra     = 0;
        if (!RegisterClass(&cls))
            return FALSE;

        /* register the "noflickertext" window class */
        cls.lpszClassName  = aszNoFlickerClass;
        cls.hCursor        = LoadCursor(NULL, IDC_ARROW);
        cls.hIcon          = NULL;
        cls.lpszMenuName   = NULL;
        cls.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
        cls.hInstance      = hInst;
        cls.style          = CS_HREDRAW | CS_VREDRAW;
        cls.lpfnWndProc    = NFTextWndProc;
        cls.cbClsExtra     = 0;
        cls.cbWndExtra     = 0;
        if (!RegisterClass(&cls))
            return FALSE;

        /* register the "shadowframe" window class */
        cls.lpszClassName  = aszShadowClass;
        cls.hCursor        = LoadCursor(NULL, IDC_ARROW);
        cls.hIcon          = NULL;
        cls.lpszMenuName   = NULL;
        cls.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
        cls.hInstance      = hInst;
        cls.style          = CS_HREDRAW | CS_VREDRAW;
        cls.lpfnWndProc    = SFrameWndProc;
        cls.cbClsExtra     = 0;
        cls.cbWndExtra     = 0;
        if (!RegisterClass(&cls))
            return FALSE;

        /* register the dialog's window class */
        cls.lpszClassName  = gachAppName;
        cls.hCursor        = LoadCursor(NULL, IDC_ARROW);
        cls.hIcon          = ghiconApp;
        cls.lpszMenuName   = NULL;
        cls.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
        cls.hInstance      = hInst;
        cls.style          = CS_HREDRAW | CS_VREDRAW;
        cls.lpfnWndProc    = DefDlgProc;
        cls.cbClsExtra     = 0;
        cls.cbWndExtra     = DLGWINDOWEXTRA;
        if (!RegisterClass(&cls))
            return FALSE;

    }

#ifdef USE_MMCNTRLS
    if (!InitTrackBar(hPrev))
        return FALSE;
#else
    InitCommonControls();
#endif    

    if (!(ghAccel = LoadAccelerators(hInst, gachAppName)))
        return FALSE;


    i = DEF_BUFFERDELTASECONDS;
    ReadRegistryData(NULL
                     , (LPTSTR)aszBufferDeltaSeconds
                     , NULL
                     , (LPBYTE)&i
                     , (DWORD)sizeof(i));
    
    if (i > MAX_DELTASECONDS)
        i = MAX_DELTASECONDS;
    else if (i < MIN_DELTASECONDS)
        i = MIN_DELTASECONDS;
    gdwBufferDeltaMSecs = i * 1000L;
    DPF(TEXT("gdwBufferDeltaMSecs=%lu\n"), gdwBufferDeltaMSecs);

    //
    //  because it really doesn't help in standard mode to stream with
    //  multiple wave headers (we sorta assume we having a paging device
    //  to make things work...), we just revert to one big buffer in
    //  standard mode...  might want to check if paging is enabled??
    //
    //  in any case, this helps a LOT when running KRNL286-->the thing
    //  is buggy and GP faults when lots of discarding, etc
    //  is going on... like when dealing with large sound objects, eh?
    //
    i = DEF_NUMASYNCWAVEHEADERS;
    ReadRegistryData(NULL
                     , (LPTSTR)aszNumAsyncWaveHeaders
                     , NULL
                     , (LPBYTE)&i
                     , (DWORD)sizeof(i));
    
    if (i > MAX_WAVEHDRS)
        i = MAX_WAVEHDRS;
    else if (i < MIN_WAVEHDRS)
        i = 1;
    guWaveHdrs = i;
                 
    DPF(TEXT("         guWaveHdrs=%u\n"), guWaveHdrs);
    
    i = DEF_MSECSPERASYNCBUFFER;
    ReadRegistryData(NULL
                     , (LPTSTR)aszMSecsPerAsyncBuffer
                     , NULL
                     , (LPBYTE)&i
                     , (DWORD)sizeof(i));
    
    if (i > MAX_MSECSPERBUFFER)
        i = MAX_MSECSPERBUFFER;
    else if (i < MIN_MSECSPERBUFFER)
        i = MIN_MSECSPERBUFFER;
    gwMSecsPerBuffer = i;
    
    DPF(TEXT("   gwMSecsPerBuffer=%u\n"), gwMSecsPerBuffer);

    return TRUE;
} /* AppInit */



/*
 * */
void DoOpenFile(void)
{

    LPTSTR lpCmdLine = GetCommandLine();
    
    /* increment pointer past the argv[0] */
    while ( *lpCmdLine && *lpCmdLine != TEXT(' '))
            lpCmdLine = CharNext(lpCmdLine);
    
    if( gfLinked )
    {
         FileOpen(gachLinkFilename);
    }
    else if (!gfEmbedded)
    {
         // skip blanks
         while (*lpCmdLine == TEXT(' '))
         {
             lpCmdLine++;
             continue;
         }
         if(*lpCmdLine)
         {
             ResolveIfLink(lpCmdLine);
             FileOpen(lpCmdLine);             
         }
    }
}


/*
 * Dialog box initialization
 * */
BOOL PASCAL SoundDialogInit(
    HWND        hwnd,
    int         iCmdShow)
{
    /* make the window handle global */
    ghwndApp = hwnd;

    DragAcceptFiles(ghwndApp, TRUE); /* Process dragged and dropped file */

    GetIntlSpecs();

    /* Hide the window unless we want to display it later */
    ShowWindow(ghwndApp,SW_HIDE);

    /* remember the window handles of the important controls */
    ghwndWaveDisplay = GetDlgItem(hwnd, ID_WAVEDISPLAY);
    ghwndScroll = GetDlgItem(hwnd, ID_CURPOSSCRL);
    ghwndPlay = GetDlgItem(hwnd, ID_PLAYBTN);
    ghwndStop = GetDlgItem(hwnd, ID_STOPBTN);
    ghwndRecord = GetDlgItem(hwnd, ID_RECORDBTN);
    ghwndForward = GetDlgItem(hwnd, ID_FORWARDBTN);
    ghwndRewind = GetDlgItem(hwnd, ID_REWINDBTN);

#ifdef THRESHOLD
    ghwndSkipStart = GetDlgItem(hwnd, ID_SKIPSTARTBTN);
    ghwndSkipEnd = GetDlgItem(hwnd, ID_SKIPENDBTN);
#endif //THRESHOLD

    /* set up scroll bar */
    // SetScrollRange(ghwndScroll, SB_CTL, 0, SCROLL_RANGE, TRUE);
    SendMessage(ghwndScroll,TBM_SETRANGEMIN, 0, 0);
    SendMessage(ghwndScroll,TBM_SETRANGEMAX, 0, SCROLL_RANGE);
    SendMessage(ghwndScroll,TBM_SETPOS, TRUE, 0);

    /* Set up the bitmap buttons */
    BtnCreateBitmapButtons( hwnd,
                            (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE),
                            IDR_PLAYBAR,
                            BBS_TOOLTIPS,
                            tbPlaybar,
                            NUM_OF_BUTTONS,
                            25,
                            17);
    //
    // OLE2 and command line initialization...
    //
    InitializeSRS(ghInst);
    gfRunWithEmbeddingFlag = gfEmbedded;

    //
    // Try and init ACM
    //
    LoadACM();      
    
    //
    // build the File.New menu 
    //

    //
    // create a blank document
    //
    if (!FileNew(FMT_DEFAULT, TRUE, FALSE))
    {
        PostMessage(hwnd, WM_CLOSE, 0, 0);
        return TRUE;        
    }

    //
    // Note, FileNew/FileOpen has the side effect of releasing the
    // server when called by the user.  For now, do it here.  In the future
    // Wrapping these calls would suffice.
    //
    FlagEmbeddedObject(gfEmbedded);

    //
    // open a file if requested on command line
    //

    //
    // Execute command line verbs here.
    //
    
// Would be nicer just to execute methods that are likewise exportable
// through an OLE interface.
    
    if (gStartParams.fNew)
    {
        //
        // Behavior: If there is a filename specified, create it and
        // commit it so we have a named, empty document.  Otherwise, we
        // start in a normal new state.
        //
        
//TODO: Implement checkbox to set-as default format and not bring up
//TODO: the format selection dialog box.
                
        FileNew(FMT_DEFAULT,TRUE,TRUE);
        if (gStartParams.achOpenFilename[0] != 0)
        {
            lstrcpy(gachFileName, gStartParams.achOpenFilename);
            FileSave(FALSE);
        }
        //
        // Behaviour: If -close was specified, all we do is exit.
        //
        if (gStartParams.fClose)
            PostMessage(hwnd,WM_CLOSE,0,0);
    }
    else if (gStartParams.fPlay)
    {
        /* Behavior: If there is a file, just open it.  If not, ask for the
         * filename.  Then queue up a play request.
         * If -close was specified, then when the play is done the application
         * will exit. (see wave.c:YieldStop())
         */
        if (gStartParams.achOpenFilename[0] != 0)
            FileOpen(gStartParams.achOpenFilename);
        else
            FileOpen(NULL);
        AppPlay(gStartParams.fPlay && gStartParams.fClose);
    }
    else 
    {
        /* case: Both linked and standalone "open" cases are handled
         * here.  The only unusual case is if -open was specified without
         * a filename, meaning the user should be asked for a filename
         * first upon app start.
         *
         * Behaviour: -open and -close has no meaning, unless as a
         * verification (i.e. is this a valid wave file).  So this
         * isn't implemented.
         */
        if (gStartParams.achOpenFilename[0] != 0)
            FileOpen(gStartParams.achOpenFilename);
        else if (gStartParams.fOpen)
            FileOpen(NULL);
    }
    
    if (!gfRunWithEmbeddingFlag) {
        ShowWindow(ghwndApp,iCmdShow);

        /* set focus to "Record" if the file is empty, "Play" if not */
        if (glWaveSamplesValid == 0 && IsWindowEnabled(ghwndRecord))
            SetDlgFocus(ghwndRecord);
        else if (glWaveSamplesValid > 0 && IsWindowEnabled(ghwndPlay))
            SetDlgFocus(ghwndPlay);
        else
            SetDlgFocus(ghwndScroll);

        if (!waveInGetNumDevs() && !waveOutGetNumDevs()) {
            /* No recording or playback devices */
            ErrorResBox(hwnd, ghInst, MB_ICONHAND | MB_OK,
                            IDS_APPTITLE, IDS_NOWAVEFORMS);
        }

        return FALSE;   // FALSE because we set the focus above
    }
    //
    //  return FALSE, so the dialog manager will not activate us, it is
    //  ok because we are hidden anyway
    //
    return FALSE;
    
} /* SoundDialogInit */


/*
 * localisation stuff - decimal point delimiter etc
 * */
BOOL FAR PASCAL
GetIntlSpecs()
{
    TCHAR szTmp[5];

    // find decimal seperator
    szTmp[0] = chDecimal;
    szTmp[1] = 0;
    GetLocaleInfo(LOCALE_USER_DEFAULT
                  , LOCALE_SDECIMAL
                  , szTmp
                  , SIZEOF(szTmp));
    chDecimal = szTmp[0];

    // leading zeros
    szTmp[0] = TEXT('1');
    szTmp[1] = 0;
    GetLocaleInfo(LOCALE_USER_DEFAULT
                  , LOCALE_ILZERO
                  , szTmp
                  , SIZEOF(szTmp));
    gfLZero = _ttoi(szTmp);

    szTmp[0] = TEXT('0');
    LoadString(ghInst, IDS_RTLENABLED, szTmp, SIZEOF(szTmp));
    gfIsRTL = (szTmp[0] != TEXT('0'));

    return TRUE;
} /* GetIntlSpecs */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\soundrec\reg.c ===
/* (C) Copyright Microsoft Corporation 1991-1994.  All Rights Reserved */
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <regstr.h>
#include "reg.h"

const TCHAR szRegPath[] = REGSTR_PATH_WINDOWSAPPLETS TEXT("\\Sound Recorder");

/* ReadRegistryData
 *
 * Reads information from the registry
 *
 * Parameters:
 *
 *     pEntryNode - The node under Media Player which should be opened
 *         for this data.  If this is NULL, the value is
 *         written directly under szRegPath.
 *
 *     pEntryName - The name of the value under pEntryNode to be retrieved.
 *
 *     pType - Pointer to a buffer to receive type of data read.  May be NULL.
 *
 *     pData - Pointer to a buffer to receive the value data.
 *
 *     Size - Size, in bytes, of the buffer pointed to by pData.
 *
 * Return:
 *
 *     Registry status return (NO_ERROR is good)
 *
 *
 * Andrew Bell (andrewbe) wrote it, 10 September 1992
 *
 */
DWORD ReadRegistryData( LPTSTR pEntryNode,
                        LPTSTR pEntryName,
                        PDWORD pType,
                        LPBYTE pData,
                        DWORD  DataSize )
{
    DWORD  Status;
    HKEY   hkeyRegPath;
    HKEY   hkeyEntryNode;
    DWORD  Size;

    Status = RegOpenKeyEx( HKEY_CURRENT_USER, szRegPath, 0,
                           KEY_READ, &hkeyRegPath );

    if( Status == NO_ERROR )
    {
        /* Open the sub-node:
         */
        if( pEntryNode )
            Status = RegOpenKeyEx( hkeyRegPath, pEntryNode, 0,
                                   KEY_READ, &hkeyEntryNode );
        else
            hkeyEntryNode = hkeyRegPath;

        if( Status == NO_ERROR )
        {
            Size = DataSize;

            /* Read the entry from the registry:
             */
            Status = RegQueryValueEx( hkeyEntryNode,
                                      pEntryName,
                                      0,
                                      pType,
                                      pData,
                                      &Size );

            if( pEntryNode )
                RegCloseKey( hkeyEntryNode );
        }

        RegCloseKey( hkeyRegPath );
    }
    return Status;
}


DWORD QueryRegistryDataSize(
    LPTSTR  pEntryNode,
    LPTSTR  pEntryName,
    DWORD   *pDataSize )
{
    DWORD  Status;
    HKEY   hkeyRegPath;
    HKEY   hkeyEntryNode;
    DWORD  Size;

    /* Open the top-level node.  For Media Player this is:
     * "Software\\Microsoft\\Windows NT\\CurrentVersion\\Sound Recorder"
     */
    Status = RegOpenKeyEx( HKEY_CURRENT_USER, szRegPath, 0,
                           KEY_READ, &hkeyRegPath );

    if( Status == NO_ERROR )
    {
        /* Open the sub-node:
         */
        if( pEntryNode )
            Status = RegOpenKeyEx( hkeyRegPath, pEntryNode, 0,
                                   KEY_READ, &hkeyEntryNode );
        else
            hkeyEntryNode = hkeyRegPath;

        if( Status == NO_ERROR )
        {
            /* Read the entry from the registry:
             */
            Status = RegQueryValueEx( hkeyEntryNode,
                                      pEntryName,
                                      0,
                                      NULL,
                                      NULL,
                                      &Size );
            if (Status == NO_ERROR)
                *pDataSize = Size;

            if( pEntryNode )
                RegCloseKey( hkeyEntryNode );
        }

        RegCloseKey( hkeyRegPath );
    }
    return Status;
}



/* WriteRegistryData
 *
 * Writes a bunch of information to the registry
 *
 * Parameters:
 *
 *     pEntryNode - The node under szRegPath which should be created
 *         or opened for this data.  If this is NULL, the value is
 *         written directly under szRegPath.
 *
 *     pEntryName - The name of the value under pEntryNode to be set.
 *
 *     Type - Type of data to read (e.g. REG_SZ).
 *
 *     pData - Pointer to the value data to be written.  If this is NULL,
 *         the value under pEntryNode is deleted.
 *
 *     Size - Size, in bytes, of the buffer pointed to by pData.
 *
 *
 * This routine is fairly generic, apart from the name of the top-level node.
 *
 * The data are stored in the following registry tree:
 *
 * HKEY_CURRENT_USER
 *  
 *   Software
 *      
 *       Microsoft
 *          
 *           Windows NT
 *              
 *               CurrentVersion
 *                  
 *                   Media Player
 *                      
 *                       AVIVideo
 *                      
 *                       DisplayPosition
 *                      
 *                       SysIni
 *
 *
 * Return:
 *
 *     Registry status return (NO_ERROR is good)
 *
 *
 * Andrew Bell (andrewbe) wrote it, 10 September 1992
 *
 */
DWORD WriteRegistryData( LPTSTR pEntryNode,
                         LPTSTR pEntryName,
                         DWORD  Type,
                         LPBYTE pData,
                         DWORD  Size )
{
    DWORD  Status;
    HKEY   hkeyRegPath;
    HKEY   hkeyEntryNode;

    /* Open or create the top-level node.  For Media Player this is:
     * "Software\\Microsoft\\Windows NT\\CurrentVersion\\Media Player"
     */
    Status = RegCreateKeyEx( HKEY_CURRENT_USER, szRegPath, 0,
                             NULL, 0, KEY_WRITE, NULL, &hkeyRegPath, NULL );

    if( Status == NO_ERROR )
    {
        /* Open or create the sub-node.
         */
        if( pEntryNode )
            Status = RegCreateKeyEx( hkeyRegPath, pEntryNode, 0,
                                     NULL, 0, KEY_WRITE, NULL, &hkeyEntryNode, NULL );
        else
            hkeyEntryNode = hkeyRegPath;

        if( Status == NO_ERROR )
        {
            if( pData )
            {
                Status = RegSetValueEx( hkeyEntryNode,
                                        pEntryName,
                                        0,
                                        Type,
                                        pData,
                                        Size );

            }
            else
            {
                Status = RegDeleteValue( hkeyEntryNode, pEntryName );
            }

            if( pEntryNode )
                RegCloseKey( hkeyEntryNode );
        }

        RegCloseKey( hkeyRegPath );
    }


    return Status;
}


/*
 * Save/Restore window position
 */
BOOL SoundRec_GetSetRegistryRect(
    HWND	hwnd,
    int         Get)
{
    const TCHAR aszXPos[]    = TEXT("X");
    const TCHAR aszYPos[]    = TEXT("Y");
    
    RECT  rcWnd,rc;
    
    if (!GetWindowRect(hwnd, &rcWnd))
        return FALSE;

    switch (Get)
    {
        case SGSRR_GET:
            if (ReadRegistryData((LPTSTR)NULL
                , (LPTSTR)aszXPos
                , NULL
                , (LPBYTE)&rc.left
                , sizeof(rc.left)) != NO_ERROR)
            {
                break;
            }
            if (ReadRegistryData((LPTSTR)NULL
                , (LPTSTR)aszYPos
                , NULL
                , (LPBYTE)&rc.top
                , sizeof(rc.top)) != NO_ERROR)
            {
                break;
            }
            
            //
            // Restore window position
            //
            MoveWindow(hwnd
                        , rc.left
                        , rc.top
                        , rcWnd.right - rcWnd.left
                        , rcWnd.bottom - rcWnd.top
                        , FALSE );
            
            return TRUE;
            
        case SGSRR_SET:
            //
            // don't save iconic or hidden window states
            //
            if (IsIconic(hwnd) || !IsWindowVisible(hwnd))
                break;

            if (WriteRegistryData((LPTSTR)NULL
                , (LPTSTR)aszXPos
                , REG_DWORD
                , (LPBYTE)&rcWnd.left
                , sizeof(rcWnd.left)) != NO_ERROR)
            {
                break;
            }
            if (WriteRegistryData((LPTSTR)NULL
                , (LPTSTR)aszYPos
                , REG_DWORD
                , (LPBYTE)&rcWnd.top
                , sizeof(rcWnd.top)) != NO_ERROR)
            {
                break;
            }
            
            return TRUE;
            
        default:
            break;
    }
    return FALSE;
}    

/*
 *
 * */
const TCHAR szAudioRegPath[]    = REGSTR_PATH_MULTIMEDIA_AUDIO;
const TCHAR szWaveFormats[]     = REGSTR_PATH_MULTIMEDIA_AUDIO TEXT("\\WaveFormats");
const TCHAR szDefaultFormat[]   = TEXT("DefaultFormat");

/*
 * BOOL SoundRec_SetDefaultFormat
 * 
 * Write the DefaultFormat friendly name into the registry.  Under DAYTONA
 * we don't have a UI to set DefaultFormat, so this is a way of setting
 * it from an application.
 * 
 * Under Chicago, the Audio page in MMCPL manages this information.
 * */
BOOL SoundRec_SetDefaultFormat(
    LPTSTR lpFormat)
{
    DWORD  cbFormat;
    DWORD  Status;
    HKEY   hkeyRegPath;

    cbFormat = (lstrlen(lpFormat) + 1) * sizeof(TCHAR);

    //
    // Don't store NULL.
    //
    if (cbFormat <= sizeof(TCHAR) )
        return FALSE;
    
    Status = RegOpenKeyEx( HKEY_CURRENT_USER, szAudioRegPath, 0,
                           KEY_WRITE, &hkeyRegPath );
    
    if (Status != NO_ERROR)
        return FALSE;

    //
    // Get the format tag string
    //
    Status = RegSetValueEx( hkeyRegPath,
                              szDefaultFormat,
                              0,
                              REG_SZ,
                              (CONST BYTE*)lpFormat,
                              cbFormat );
    
    return (Status == NO_ERROR);
}

/* IsValidWFX
 *
 * Validate the wfx in case it was corrupted.
 *
 * */
BOOL IsValidWFX(
    LPWAVEFORMATEX  lpwfx,
    DWORD           cbwfx)
{

    if (cbwfx < sizeof(WAVEFORMAT))
        return FALSE;
    
    if (lpwfx->nChannels == 0)
        return FALSE;

    if (lpwfx->nSamplesPerSec == 0)
        return FALSE;

    if (lpwfx->nAvgBytesPerSec == 0)
        return FALSE;
    
    if (lpwfx->nBlockAlign == 0)
        return FALSE;
        
    if (lpwfx->wFormatTag == WAVE_FORMAT_PCM)
        return TRUE;

    if (cbwfx < (sizeof(WAVEFORMATEX) + lpwfx->cbSize))
        return FALSE;

    return TRUE;
}

/*
 * BOOL SoundRec_GetDefaultFormat
 *
 * Default format is stored in a public area of the registry.
 *
 * */
BOOL SoundRec_GetDefaultFormat(
    LPWAVEFORMATEX  *ppwfx,
    DWORD           *pcbwfx)
{
    DWORD           Status;
    HKEY            hkeyRegPath;
    HKEY            hkeyFmtPath;
    
    LPTSTR          lpsz;
    DWORD           cbsz;
    
    DWORD           cbwfx = 0;
    LPWAVEFORMATEX  lpwfx = NULL;


    //
    // Null out params
    //
    *ppwfx          = NULL;
    *pcbwfx         = 0;
    
    Status = RegOpenKeyEx( HKEY_CURRENT_USER, szAudioRegPath, 0,
                           KEY_READ, &hkeyRegPath );
    if (Status != NO_ERROR)
        return FALSE;

    //
    // Get the format tag string
    //
    Status = RegQueryValueEx( hkeyRegPath, szDefaultFormat, 0, NULL, NULL,
                              &cbsz );

    if (Status != NO_ERROR)
        return FALSE;
    
    lpsz = (LPTSTR)GlobalAllocPtr(GHND, cbsz);
    if (!lpsz)
        return FALSE;
    
    Status = RegQueryValueEx( hkeyRegPath, szDefaultFormat, 0, NULL,
                              (LPBYTE)lpsz, &cbsz );
    
    if (Status == NO_ERROR)
    {
        //
        // Get the format
        //
        Status = RegOpenKeyEx( HKEY_CURRENT_USER, szWaveFormats, 0,
                               KEY_READ, &hkeyFmtPath );

        if (Status == NO_ERROR)
        {
            Status = RegQueryValueEx( hkeyFmtPath, lpsz, 0, NULL, NULL,
                                      &cbwfx );
            //
            // Make sure the structure is at minimum a WAVEFORMAT in size
            //
            if ((Status == NO_ERROR) && (cbwfx >= sizeof(WAVEFORMAT)))
            {
                lpwfx = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, cbwfx);
                if (lpwfx)
                {
                    Status = RegQueryValueEx( hkeyFmtPath, lpsz, 0, NULL,
                                              (LPBYTE)lpwfx, &cbwfx );
                }
            }
            
            RegCloseKey(hkeyFmtPath);
        }
    }

    RegCloseKey(hkeyRegPath);
    
    GlobalFreePtr(lpsz);

    //
    // Sanity Check.
    //
    if (lpwfx)
    {
        if (Status == NO_ERROR && IsValidWFX(lpwfx, cbwfx))
        {
            cbwfx = sizeof(WAVEFORMATEX)
                    + ((lpwfx->wFormatTag == WAVE_FORMAT_PCM)?0:lpwfx->cbSize);
            *pcbwfx = cbwfx;
            *ppwfx = lpwfx;
            return TRUE;
        }
        else
        {
            GlobalFreePtr(lpwfx);
            return FALSE;
        }
    }
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\soundrec\sframe.c ===
/* (C) Copyright Microsoft Corporation 1991-1994.  All Rights Reserved */
/* sframe.c
 *
 * Implements the shadow-frame static text control ("sb_sframe").
 *
 * This is NOT a general-purpose control (see the globals below).
 *
 * Borrowed from KeithH (with many, many modifications).
 */
/* Revision History.
   4/2/91 LaurieGr (AKA LKG) Ported to WIN32 / WIN16 common code
*/

#include "nocrap.h"
#include <windows.h>
#include <mmsystem.h>
#include "SoundRec.h"


/* PatB(hdc, x, y, dx, dy, rgb)
 *
 * Fast solid color PatBlt() using ExtTextOut().
 */
void
PatB(HDC hdc, int x, int y, int dx, int dy, DWORD rgb)
{
    RECT    rc;

    SetBkColor(hdc, rgb);
    rc.left   = x;
    rc.top    = y;
    rc.right  = x + dx;
    rc.bottom = y + dy;

    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
}


/* DrawShadowFrame(hdc, prc)
 *
 * Draw a shadow frame inside <prc> in <hdc>.
 */
void FAR PASCAL
DrawShadowFrame(HDC hdc, LPRECT prc)
{
    int     dx, dy;

    dx = prc->right  - prc->left;
    dy = prc->bottom - prc->top;
    PatB(hdc, prc->left, prc->top, 1, dy, RGB_DARKSHADOW);
    PatB(hdc, prc->left, prc->top, dx, 1, RGB_DARKSHADOW);
    PatB(hdc, prc->right-1, prc->top+1, 1, dy-1, RGB_LIGHTSHADOW);
    PatB(hdc, prc->left+1, prc->bottom-1, dx-1, 1, RGB_LIGHTSHADOW);
}


/* SFrameWndProc(hwnd, wMsg, wParam, lParam)
 *
 * Window procedure for "tb_sframe" window class.
 */
INT_PTR CALLBACK
SFrameWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT ps;
    HDC     hdc;
    RECT        rc;

    switch (wMsg)
    {

    case WM_ERASEBKGND:

        return 0L;

    case WM_PAINT:

        hdc = BeginPaint(hwnd, &ps);
        GetClientRect(hwnd, &rc);
        DrawShadowFrame(hdc, &rc);
                InflateRect(&rc, -1, -1);
//              DrawShadowFrame(hdc, &rc);
//              InflateRect(&rc, -1, -1);
//              FillRect(hdc, &rc, GetStockObject(SOBJ_BGSFRAME));
                PatB(hdc, rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top, RGB_BGNFTEXT);
        EndPaint(hwnd, &ps);

        return 0L;
    }

    return DefWindowProc(hwnd, wMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\soundrec\srecnew.c ===
/* (C) Copyright Microsoft Corporation 1991-1994.  All Rights Reserved */
/* snddlg.c
 *
 * Routines for New & Custom Sound dialogs
 *
 */

#include "nocrap.h"
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <memory.h>
#include <mmreg.h>
# include <msacm.h>
#include <msacmdlg.h>
#include "SoundRec.h"
#include "srecnew.h"
#include "srecids.h"
#include "reg.h"

/******************************************************************************
 * DECLARATIONS
 */

/* Global variables
 */
BOOL            gfInFileNew     = FALSE;    // Are we in the file.new dialog?
DWORD           gdwMaxFormatSize= 0L;       // Max format size for ACM

/* Internal function declarations
 */
void FAR PASCAL LoadACM(void);

#ifndef CHICAGO
//
// Removed from the Win95 app due to Properties dialog
//

/*****************************************************************************
 * PUBLIC FUNCTIONS
 */
#if 0
#ifndef CHICAGO

BOOL NewDlg_OnCommand(
    HWND    hdlg,
    int     id,
    HWND    hctl,
    UINT    unotify)
{
    switch(id)
    {
        case IDD_ACMFORMATCHOOSE_CMB_CUSTOM:
            switch (unotify)
            {
                case CBN_SELCHANGE:
                {
                    HWND hSet;
                    int i = ComboBox_GetCurSel(hctl);
                    hSet = GetDlgItem(hdlg, IDC_SETPREFERRED);
                    if (!hSet)
                        break;
                    if (i == 0)
                    {
                        EnableWindow(hSet, FALSE);
                        Button_SetCheck(hSet, 0);
                    }
                    else
                        EnableWindow(hSet, TRUE);
                    break;
                }
            }
            break;
        case IDC_SETPREFERRED:
            if (Button_GetCheck(hctl) != 0)
            {
                TCHAR sz[256];
                HWND hName;
                hName = GetDlgItem(hdlg, IDD_ACMFORMATCHOOSE_CMB_CUSTOM);
                if (!hName)
                    break;
                ComboBox_GetText(hName, sz, SIZEOF(sz));
                SoundRec_SetDefaultFormat(sz);
            }
            break;
            
        default:
            break;
    }
    return FALSE;
}

UINT CALLBACK SoundRec_NewDlgHook(
     HWND       hwnd,
     UINT       uMsg,
     WPARAM     wParam,
     LPARAM     lParam)
{
     switch(uMsg)
     {
         case WM_COMMAND:
             HANDLE_WM_COMMAND(hwnd, wParam, lParam, NewDlg_OnCommand);
             break;
         default:
             break;
     }
     return FALSE;
}
#endif                    
#endif
/* NewSndDialog()
 *
 * NewSndDialog - put up the new sound dialog box
 *
 *---------------------------------------------------------------------
 * 6/15/93      TimHa
 * Change to only work with ACM 2.0 chooser dialog or just default
 * to a 'best' format for the machine.
 *---------------------------------------------------------------------
 *
 */
BOOL FAR PASCAL
NewSndDialog(
    HINSTANCE       hInst,
    HWND            hwndParent,
    PWAVEFORMATEX   pwfxPrev,
    UINT            cbPrev,
    PWAVEFORMATEX   *ppWaveFormat,
    PUINT           pcbWaveFormat)
{
    ACMFORMATCHOOSE     cwf;
    MMRESULT            mmr;
    PWAVEFORMATEX       pwfx;
    DWORD               cbwfx;

    DPF(TEXT("NewSndDialog called\n"));
    
    *ppWaveFormat   = NULL;
    *pcbWaveFormat  = 0;
    
    gfInFileNew     = TRUE;

    mmr = acmMetrics(NULL
                     , ACM_METRIC_MAX_SIZE_FORMAT
                     , (LPVOID)&gdwMaxFormatSize);

    if (mmr != MMSYSERR_NOERROR || gdwMaxFormatSize == 0L)
        goto NewSndDefault;

    //
    // allocate a buffer at least as large as the previous
    // choice or the maximum format
    //
    cbwfx = max(cbPrev, gdwMaxFormatSize);
    pwfx  = (PWAVEFORMATEX)GlobalAllocPtr(GHND, (UINT)cbwfx);
    if (NULL == pwfx)
        goto NewSndDefault;

    ZeroMemory(&cwf,sizeof(cwf));

    cwf.cbStruct    = sizeof(cwf);
    cwf.hwndOwner   = hwndParent;

    //
    // Give them an input format when they can record.
    //
    if (waveInGetNumDevs())
        cwf.fdwEnum     = ACM_FORMATENUMF_INPUT;
    else
        cwf.fdwEnum     = 0L;

    if (pwfxPrev)
    {
        CopyMemory(pwfx, pwfxPrev, cbPrev);
        cwf.fdwStyle = ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT;
    }

    cwf.pwfx        = (LPWAVEFORMATEX)pwfx;
    cwf.cbwfx       = cbwfx;

    cwf.hInstance   = ghInst;
#ifdef CHICAGO
    cwf.fdwStyle    |= ACMFORMATCHOOSE_STYLEF_CONTEXTHELP;    
#endif
    
    mmr = acmFormatChoose(&cwf);
    if (mmr == MMSYSERR_NOERROR)
    {
        *ppWaveFormat   = pwfx;
        *pcbWaveFormat  = (UINT)cwf.cbwfx;
    }
    else
    {
        GlobalFreePtr(pwfx);
    }
    
    gfInFileNew = FALSE;        // outta here
    
    return (mmr == MMSYSERR_NOERROR);                // return our result
    
NewSndDefault:
    
    if (SoundRec_GetDefaultFormat(&pwfx, &cbwfx))
    {
        if (waveInOpen(NULL
                       , (UINT)WAVE_MAPPER
                       , (LPWAVEFORMATEX)pwfx
                       , 0L
                       , 0L
                       , WAVE_FORMAT_QUERY|WAVE_ALLOWSYNC) == MMSYSERR_NOERROR)
        {
            *ppWaveFormat   = pwfx;
            *pcbWaveFormat  = cbwfx;

            gfInFileNew = FALSE;        // outta here
            
            return TRUE;
        }
        else
            GlobalFreePtr(pwfx);
    }
    
    cbwfx = sizeof(WAVEFORMATEX);
    pwfx  = (WAVEFORMATEX *)GlobalAllocPtr(GHND, sizeof(WAVEFORMATEX));

    if (pwfx == NULL)
        return FALSE;

    CreateWaveFormat(pwfx,FMT_DEFAULT,(UINT)WAVE_MAPPER);
    
    *ppWaveFormat   = pwfx;
    *pcbWaveFormat  = cbwfx;
    
    gfInFileNew = FALSE;        // outta here
    
    return TRUE;

} /* NewSndDialog() */

#endif

/* These functions previously expected to dynaload ACM.  From
 * now on, we implicitly load ACM.
 */

/* LoadACM()
 */
void FAR PASCAL
LoadACM()
{
#ifdef CHICAGO        
    extern UINT guChooserContextMenu;
    extern UINT guChooserContextHelp;
#endif
    
    guiACMHlpMsg = RegisterWindowMessage(ACMHELPMSGSTRING);
    
#ifdef CHICAGO    
    guChooserContextMenu = RegisterWindowMessage( ACMHELPMSGCONTEXTMENU );
    guChooserContextHelp = RegisterWindowMessage( ACMHELPMSGCONTEXTHELP );
#endif
    
} /* LoadACM() */

/* Free the MSACM[32] DLL.  Inverse of LoadACM.
 */
void FreeACM(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\soundrec\srecids.h ===
/* RESERVED:
 * The scheme of the o2base library requires a set of 14 or so resources.
 * Every object has resources that are an offset from these 15 resources and
 * it's up to the initialization of the ClassDescriptor to get this right.
 * Currently, this offset is 0, set in srfact.cxx

#define IDOFF_CLASSID         0
#define IDOFF_USERTYPEFULL    1
#define IDOFF_USERTYPESHORT   2
#define IDOFF_USERTYPEAPP     3
#define IDOFF_DOCFEXT         5
#define IDOFF_ICON            10
#define IDOFF_ACCELS          11
#define IDOFF_MENU            12
#define IDOFF_MGW             13
#define IDOFF_MISCSTATUS      14

*/

/* Icons */
#define IDI_APP                 10  // same as IDOFF_ICON
#define IDI_DSOUND              15
#define IDI_CONVERT             16

/* Dialogs */
#ifndef IDC_STATIC
#define IDC_STATIC              -1
#endif

#define IDD_SOUNDRECBOX         100

#define ID_STATUSTXT            200
#define ID_CURPOSTXT            201
#define ID_FILELENTXT           202
#define ID_WAVEDISPLAY          203
#define ID_CURPOSSCRL           204

// These need to start at ID_BTN_BASE and be sequential in the
// order in which the bitmaps occur in sndrec32.bmp (use imagedit)

#define ID_REWINDBTN            205
#define ID_BTN_BASE             ID_REWINDBTN
#define ID_FORWARDBTN           206
#define ID_PLAYBTN              207
#define ID_STOPBTN              208
#define ID_RECORDBTN            209

#define NUM_OF_BUTTONS          (1 + ID_RECORDBTN - ID_BTN_BASE)

#define IDR_PLAYBAR             501

#if defined(THRESHOLD)
#define ID_SKIPSTARTBTN         213
#define ID_SKIPENDBTN           214
#endif //THRESHOLD

#define IDD_SAVEAS              101
#define IDC_CONVERTTO           1000
//#define IDC_CONVERT_FROM        1001
//#define IDC_CONVERT_TO          1002
#define IDC_TXT_FORMAT          1003
#define IDC_CONVERTPLAYABLE     1008
#define IDC_CONVERTRECORDABLE   1009
#define IDC_CONVERTALL          1010


#define IDD_CONVERTING          102
#define IDC_PROGRESSBAR         1000
#define IDC_CONVERT_FROM        1001
#define IDC_CONVERT_TO          1002

#define IDD_PROPERTIES          103
#define IDC_DISPFRAME           1000
#define IDC_DISPICON            1001
#define IDC_FILENAME            1002
#define IDC_COPYRIGHT           1003
#define IDC_FILELEN             1004
#define IDC_AUDIOFORMAT         1005

#define ID_APPLY                1006
#define ID_INIT                 1007

#define IDC_TXT_COPYRIGHT       1008
#define IDC_TXT_FILELEN         1009
#define IDC_TXT_AUDIOFORMAT     1010

#define IDC_CONVERTCHOOSEFROM   1011
#define IDC_DATASIZE            1012
#define IDC_CONVGROUP           1013
#define IDC_TXT_DATASIZE        1014

#define IDD_CONVERTCHOOSE       104     

#define IDC_SETPREFERRED        1000

/* Strings */
#define IDS_APPNAME             100     // SoundRec
#define IDS_APPTITLE            101     // Sound Recorder
#define IDS_HELPFILE            102     // SOUNDREC.HLP
#define IDS_SAVECHANGES         103     // Save changes to '<file>'?
#define IDS_OPEN                104     // Open WAVE File
#define IDS_SAVE                105     // Save WAVE File
#define IDS_ERROROPEN           106     // Error opening '<file>'
#define IDS_ERROREMBED          107     // Out of memory...
#define IDS_ERRORREAD           108     // Error reading '<file>'
#define IDS_ERRORWRITE          109     // Error writing '<file>'
#define IDS_OUTOFMEM            110     // Out of memory
#define IDS_FILEEXISTS          111     // File '<file>' exists -- overwrite it?
//#define IDS_BADFORMAT           112     // File format is incorrect/unsupported
#define IDS_CANTOPENWAVEOUT     113     // Cannot open waveform output device
#define IDS_CANTOPENWAVEIN      114     // Cannot open waveform input device
#define IDS_STATUSSTOPPED       115     // Stopped
#define IDS_STATUSPLAYING       116     // Playing
#define IDS_STATUSRECORDING     117     // Recording -- ...
#define IDS_CANTFINDFONT        118     // Cannot find file '<file>', so...
#define IDS_INSERTFILE          119     // Insert WAVE File
#define IDS_MIXWITHFILE         120     // Mix With WAVE File
#define IDS_CONFIRMREVERT       121     // Revert to last-saved copy... ?
#define IDS_INPUTNOTSUPPORT     122     // ...does not support recording
#define IDS_BADINPUTFORMAT      123     // ...cannot record into files like...
#define IDS_BADOUTPUTFORMAT     124     // ...cannot play files like...
#define IDS_UPDATEBEFORESAVE    125     // Update embedded before save as?
#define IDS_SAVEEMBEDDED        126     // Update embedded before closing?
//#define IDS_CANTSTARTOLE        127     // Can't register the server with OLE
#define IDS_NONEMBEDDEDSAVE     128     // 'Save'
#define IDS_EMBEDDEDSAVE        129     // 'Update'
//#define IDS_NONEMBEDDEDEXIT     130     // 'Exit'
#define IDS_EMBEDDEDEXIT        131     // 'Exit and Update'
//#define IDS_SAVELARGECLIP       132     // Save large clipboard?
//#define IDS_FILENOTFOUND        133     // The file %s does not exist
#define IDS_NOTAWAVEFILE        134     // The file %s is not a valid...
#define IDS_NOTASUPPORTEDFILE   135     // The file %s is not a supported...
#define IDS_FILETOOLARGE        136     // The file %s is too large...
#define IDS_DELBEFOREWARN       137     // Warning: Deleteing before
#define IDS_DELAFTERWARN        138     // Warning: Deleteing after
#define IDS_UNTITLED            139     // (Untitled)
#define IDS_FILTERNULL          140     // Null replacement char
#define IDS_FILTER              141     // Common Dialog file filter
#define IDS_OBJECTLINK          142     // Object link clipboard format
#define IDS_OWNERLINK           143     // Owner link clipboard format
#define IDS_NATIVE              144     // Native clipboard format
#ifdef FAKEITEMNAMEFORLINK
#define IDS_FAKEITEMNAME        145     // Wave
#endif
//#define IDS_CLASSROOT           146     // Root name
//#define IDS_EMBEDDING           147     // Embedding
#define IDS_POSITIONFORMAT      148     // Format of current position string
#define IDS_NOWAVEFORMS         149     // No recording or playback devices are present
#define IDS_PASTEINSERT         150
#define IDS_PASTEMIX            151
#define IDS_FILEINSERT          152
#define IDS_FILEMIX             153
//#define IDS_SOUNDOBJECT         154
#define IDS_CLIPBOARD           156
#define IDS_MONOFMT             157
#define IDS_STEREOFMT           158
#define IDS_CANTPASTE           159
//#define IDS_PLAYVERB            160
//#define IDS_EDITVERB            161

#define IDS_DEFFILEEXT          162
#define IDS_NOWAVEIN            163
#define IDS_SNEWMONOFMT         164
#define IDS_SNEWSTEREOFMT       165
#define IDS_NONE                166
#define IDS_NOACMNEW            167
#define IDS_NOZEROPOSITIONFORMAT 168
#define IDS_NOZEROMONOFMT       169
#define IDS_NOZEROSTEREOFMT     170

//#define IDS_LINKEDUPDATE        171
#define IDS_OBJECTTITLE         172
#define IDS_EXITANDRETURN       173

#define IDS_BADREG              174
#define IDS_FIXREGERROR         175
         

#define IDS_ERR_CANTCONVERT     177
#define IDS_PROPERTIES          178
#define IDS_SHOWPLAYABLE        179
#define IDS_SHOWRECORDABLE      180
#define IDS_SHOWALL             181
#define IDS_DATASIZE            182
#define IDS_NOCOPYRIGHT         183


#define IDS_PLAYVERB            184
#define IDS_EDITVERB            185
#define IDS_OPENVERB            186

#define IDS_MMSYSPROPTITLE      187
#define IDS_MMSYSPROPTAB        188

#define IDS_RTLENABLED          189

#define IDS_HTMLHELPFILE        190     // SOUNDREC.CHM
#define IDS_ERRORFILENAME       191     // Filename is too long

/*
 * menus
 */         
#define IDM_OPEN                12
#define IDM_SAVE                13
#define IDM_SAVEAS              14
#define IDM_REVERT              15
#define IDM_EXIT                16

#define IDM_COPY                20
#define IDM_DELETE              21
#define IDM_INSERTFILE          22
#define IDM_MIXWITHFILE         23
#define IDM_PASTE_INSERT        24
#define IDM_PASTE_MIX           25

#if defined(THRESHOLD)
   #define IDM_SKIPTOSTART      26
   #define IDM_SKIPTOEND        27
   #define IDM_INCREASETHRESH   28
   #define IDM_DECREASETHRESH   29
#endif //threshold

#define IDM_DELETEBEFORE        31
#define IDM_DELETEAFTER         32
#define IDM_INCREASEVOLUME      33
#define IDM_DECREASEVOLUME      34
#define IDM_MAKEFASTER          35
#define IDM_MAKESLOWER          36
#define IDM_ADDECHO             37
#define IDM_REVERSE             38
#define IDM_ADDREVERB           39

#define IDM_INDEX               91
#define IDM_KEYBOARD            92
#define IDM_COMMANDS            93
#define IDM_PROCEDURES          94
#define IDM_USINGHELP           95
#define IDM_ABOUT               96
#define IDM_SEARCH              97

#define IDM_HELPTOPICS          98

#define IDM_VOLUME              99
#define IDM_PROPERTIES          100
                         
#define IDM_NEW                 1000    // need room ...
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\soundrec\srs.cxx ===
//+---------------------------------------------------------------------
//
//   File:       srs.cxx
//
//   Contents:   OLE2 Server Class code
//
//   Classes:
//               SRCtrl
//               SRInPlace
//               SRDV
//
//------------------------------------------------------------------------

#include <stdlib.h>

#include <windows.h>
#include <windowsx.h>
#include <commdlg.h>      // common dialog boxes

#include <ole2.h>
#include <o2base.hxx>     // the base classes and utilities

#include "srecids.h"      // for resources
#include "srs.hxx"

// Our class factory
extern SRFactory *gpSRFactory;
extern "C" HINSTANCE ghInst;

DWORD       gdwRegROT           = 0L;   // Registered on the running object table?
LPMONIKER   gpFileMoniker       = NULL; // Application wide file moniker for linking
LPXBAG      gpXBagOnClipboard   = NULL;
BOOL        gfXBagOnClipboard   = FALSE;
LPSRCTRL    gpCtrlThis          = NULL;


// Glue functions for the C code
//===============================
//
void
FlushOleClipboard(void)
{
    if (!gfOleInitialized)
        return;
    
    if(gfXBagOnClipboard)
    {
        if(OleIsCurrentClipboard(gpXBagOnClipboard) == NOERROR)
        {
            DOUT(TEXT("\\\\Soundrec: OleFlushClipboard()\r\n"));
            //
            // Keep the data object on the clipboard for object pasting
            //
            OleFlushClipboard();
            
            gpXBagOnClipboard->Detach();
            gpXBagOnClipboard = NULL;
        }
        gfXBagOnClipboard = FALSE;
    }
}

               
// copied from pbrush
void
TransferToClipboard(void)
{
    DOUT(TEXT("TransferToClipboard\r\n"));

    if(gpCtrlThis != NULL)
    {
        LPXBAG pXBag;
        HRESULT hr = CXBag::Create(&pXBag, gpCtrlThis, NULL);
        if(hr == NOERROR)
        {
            if(gfXBagOnClipboard)
                OleSetClipboard(NULL);
            hr = OleSetClipboard(pXBag);
            gfXBagOnClipboard = (hr == NOERROR) ? TRUE : FALSE;
            if(hr == NOERROR)
            {
                gpXBagOnClipboard = pXBag;
            }
            else
            {
                DOUT(TEXT("TransferToClipboard FAILED!\r\n"));
            }
        }
    }
    else
    {
        DOUT(TEXT("TransferToClipboard called with a NULL gpCtrlThis!\r\n"));
    }

}
void AdviseDataChange(void)
{
    if(gpCtrlThis)
    {
        gpCtrlThis->_pDV->OnDataChange();
        gpCtrlThis->MarkAsLoaded();
    }
}

void AdviseRename(LPTSTR lpname)
{
    if(gpCtrlThis)
    {
        if (gpCtrlThis->_pOleAdviseHolder != NULL)
        {
            LPMONIKER pmk = NULL;
#if !defined(UNICODE) && !defined(OLE2ANSI)            
            LPOLESTR lpstr = ConvertMBToOLESTR(lpname,-1);
            if(NOERROR == CreateFileMoniker(lpstr, &pmk))
#else
            if(NOERROR == CreateFileMoniker(lpname, &pmk))                
#endif                
                
            {
                gpCtrlThis->_pOleAdviseHolder->SendOnRename(pmk);
                pmk->Release();
            }
#if !defined(UNICODE) && !defined(OLE2ANSI)                        
            TaskFreeMem(lpstr);
#endif            
        }
    }
}

void AdviseSaved(void)
{
    if(gpCtrlThis)
    {
        if (gpCtrlThis->_pOleAdviseHolder != NULL)
        {
            gpCtrlThis->_pOleAdviseHolder->SendOnSave();
        }
    }
}

void AdviseClosed(void)
{
    if(gpCtrlThis)
    {
        if (gpCtrlThis->_pOleAdviseHolder != NULL)
        {
            gpCtrlThis->_pOleAdviseHolder->SendOnClose();
        }
    }
}

void DoOleSave(void)
{
    if(!gfStandalone && gpCtrlThis && gpCtrlThis->_pClientSite)
    {
        gpCtrlThis->_pClientSite->SaveObject();
    }
}

void DoOleClose(BOOL fSave)
{
    if(gpCtrlThis)
    {
        DOUT(TEXT("SoundRec: DoOleClose\r\n"));
        if (gfStandalone)
        {
            RevokeAsRunning(&gdwRegROT);
            if(gpFileMoniker != NULL)
            {
                gpFileMoniker->Release();
                gpFileMoniker = NULL;
            }
            gfClosing = TRUE;
            gpCtrlThis->UnLock();

//        This release will cause a fatal recursion in SRCtrl::~SRCtrl on
//        objects that were created due to link conversations.
                        
            if (gfEmbedded)
                gpCtrlThis->Release();
        }
        else
            gpCtrlThis->Close(fSave ? OLECLOSE_SAVEIFDIRTY: OLECLOSE_NOSAVE);
    }
}

void WriteObjectIfEmpty()
{
    if (gpCtrlThis)
    {
        if (!gpCtrlThis->IsLoaded())
        {
            AdviseDataChange();
        }
    }
}

void OleObjGetHostNames(
    LPTSTR *ppCntr,
    LPTSTR *ppObj)
{
    if (gpCtrlThis)
    {
#if !defined(UNICODE) && !defined(OLE2ANSI)
        *ppCntr = gpCtrlThis->_lpstrCntrAppA;
        *ppObj  = gpCtrlThis->_lpstrCntrObjA;
#else
        *ppCntr = gpCtrlThis->_lpstrCntrApp;
        *ppObj  = gpCtrlThis->_lpstrCntrObj;
#endif        
    }
}

//
// Data Transfer Object
//========================
//

//
// List of formats offered by our data transfer object via EnumFormatEtc
// NOTE: OleClipFormat is a global array of stock formats defined in
//       o2base\dvutils.cxx and initialized via RegisterOleClipFormats()
//       in our class factory.
//
static FORMATETC g_aGetFmtEtcs[] = {
    //
    //Other formats go here..
    //{ CF_WHATEVER, NULL, DVASPECT_ALL, -1L, TYMED_HGLOBAL }

    //
    // put the embed source first so containers recognize this is an object
    //
    { (unsigned short)-OCF_EMBEDSOURCE, NULL, DVASPECT_CONTENT, -1L, TYMED_ISTORAGE },

    //
    // everything else
    //
    { (unsigned short)-OCF_OBJECTDESCRIPTOR, NULL, DVASPECT_CONTENT, -1L, TYMED_HGLOBAL },
    { CF_WAVE, NULL, DVASPECT_CONTENT, -1L, TYMED_HGLOBAL },
    { CF_METAFILEPICT, NULL, DVASPECT_CONTENT, -1L, TYMED_MFPICT },
    { CF_DIB, NULL, DVASPECT_CONTENT, -1L, TYMED_HGLOBAL },

    //    
    // I am reserving the *LAST TWO* for the links.  We can prevent a
    // link from being offered
    //    
    { (unsigned short)-OCF_LINKSOURCE, NULL, DVASPECT_CONTENT, -1L, TYMED_ISTREAM | TYMED_HGLOBAL },
    { (unsigned short)-OCF_LINKSRCDESCRIPTOR, NULL, DVASPECT_CONTENT, -1L, TYMED_HGLOBAL }

};


//+---------------------------------------------------------------
//
//  Member:     CXBag::Create, static
//
//  Synopsis:   Create a new, initialized transfer object
//
//---------------------------------------------------------------
HRESULT
CXBag::Create(LPXBAG *ppXBag, LPSRCTRL pHost, LPPOINT pptSelected)
{
//    Assert(ppXBag != NULL && pHost != NULL && pptSelected != NULL);

    LPXBAG pXBag = new CXBag(pHost);
    if((*ppXBag = pXBag) == NULL)
        return E_OUTOFMEMORY;

    return NOERROR;
}


//+---------------------------------------------------------------
//
//  Member:     CXBag::CXBag
//
//  Synopsis:   constructor
//
//---------------------------------------------------------------
CXBag::CXBag(LPSRCTRL pHost)
{
    _pHost = pHost;
    _ulRefs = 1;
    _pStgBag = NULL;
}

//+---------------------------------------------------------------
//
//  Member:     CXBag::~CXBag
//
//  Synopsis:   destructor
//
//---------------------------------------------------------------
CXBag::~CXBag()
{
    _pHost = NULL;
    if(_pStgBag != NULL)
        _pStgBag->Release();
}


//+---------------------------------------------------------------
//
//  Member:     CXBag::SnapShotAndDetach
//
//  Synopsis:   Save a snapshot then detach from Host
//
//---------------------------------------------------------------
HRESULT
CXBag::SnapShotAndDetach(void)
{
    STGMEDIUM medium;
    medium.pUnkForRelease = NULL;    // transfer ownership to caller
    medium.hGlobal = NULL;
    medium.tymed = TYMED_ISTORAGE;
    HRESULT hr = BagItInStorage(&medium, FALSE);

    _pHost = NULL;
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     CXBag::BagItInStorage, private
//
//  Synopsis:   Save or copy a snapshot into specified stg
//
//---------------------------------------------------------------
HRESULT
CXBag::BagItInStorage(LPSTGMEDIUM pmedium, BOOL fStgProvided)
{
    HRESULT hr = NOERROR;
    LPPERSISTSTORAGE pPStg = NULL;

    LPSTORAGE pStg = fStgProvided ? pmedium->pstg: NULL;
    if(!fStgProvided)
    {
        //
        // allocate a temp docfile that will delete on last release
        //
        hr = StgCreateDocfile(
            NULL,
            STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_DELETEONRELEASE,
            0,
            &pStg);
        pmedium->tymed = TYMED_ISTORAGE;
        pmedium->pstg = pStg;
    }

    if(pStg == NULL)
        goto LExit;

    if(_pStgBag == NULL)
    {
        if(_pHost == NULL)
        {
            hr = E_UNEXPECTED;  // We got prematurely detached!
            goto LExit;
        }
        _pHost->QueryInterface(IID_IPersistStorage, (LPVOID FAR*)&pPStg);
        Assert(pPStg != NULL);
        hr = OleSave(pPStg, pStg, FALSE /* fSameAsLoad */);
        pPStg->SaveCompleted(NULL);
    }
    else
    {
        _pStgBag->CopyTo(NULL, NULL, NULL, pStg);
    }

LExit:
    if(pPStg != NULL)
        pPStg->Release();
    return hr;
}

IMPLEMENT_STANDARD_IUNKNOWN(CXBag)

//+---------------------------------------------------------------
//
//  Member:     CXBag::QueryInterface, public
//
//  Synopsis:   Expose our IFaces
//
//---------------------------------------------------------------
STDMETHODIMP
CXBag::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid,IID_IUnknown))
    {
        *ppv = (LPVOID)this;
    }
    else if (IsEqualIID(riid,IID_IDataObject))
    {
        *ppv = (LPVOID)(LPDATAOBJECT)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    ((IUnknown FAR*) *ppv)->AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------
//
//  Member:     CXBag::QueryGetData
//
//     OLE:     IDataObject
//
//  Synopsis:   Answer whether a request for this format might suceed
//
//---------------------------------------------------------------
STDMETHODIMP
CXBag::QueryGetData(LPFORMATETC pformatetc)
{
    HRESULT hr = DV_E_FORMATETC;
    //
    // Pick out the formats we are willing to offer on IStorage
    //
    if ( (pformatetc->cfFormat == OleClipFormat[OCF_EMBEDSOURCE]) &&
         (pformatetc->dwAspect == DVASPECT_CONTENT) &&
         (pformatetc->tymed == TYMED_ISTORAGE) )
    {
        hr = NOERROR;
    }
    //
    // Pick out the formats we are willing to offer on TYMED_ISTREAM
    //
    else if (pformatetc->tymed == TYMED_ISTREAM)
    {
        DOUT(TEXT("CXBag::QueryGetData[ISTREAM]\r\n"));
        //
        // Do not offer a static link if we don't have a filename
        //
        if (pformatetc->cfFormat == OleClipFormat[OCF_LINKSOURCE] )
        {
            hr = NOERROR;
        }
    }
    //
    // Pick out the formats we are willing to offer on HGLOBAL
    //
    else if (pformatetc->tymed == TYMED_HGLOBAL)
    {
        DOUT(TEXT("CXBag::QueryGetData[HGLOBAL]"));        
        if (pformatetc->cfFormat == OleClipFormat[OCF_OBJECTDESCRIPTOR])
        {
            hr = NOERROR;
        }
        else if (pformatetc->cfFormat == OleClipFormat[OCF_LINKSRCDESCRIPTOR])
        {
            hr = NOERROR;
        }
        else if (pformatetc->cfFormat == CF_DIB)
        {
            DOUT(TEXT("CXBag::QueryGetData[DIB]"));
            hr = NOERROR;
        }
        
    }
    else if ( (pformatetc->tymed == TYMED_MFPICT) &&
              ( pformatetc->cfFormat == CF_METAFILEPICT) )
    {
        DOUT(TEXT("CXBag::QueryGetData[MFPICT]"));
        hr = NOERROR;
    }

    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     CXBag::EnumFormatEtc
//
//     OLE:     IDataObject
//
//  Synopsis:   Answer an enumerator over supported formats
//
//---------------------------------------------------------------
STDMETHODIMP
CXBag::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC FAR* ppenumFormatEtc)
{
    HRESULT hr = E_NOTIMPL;
    *ppenumFormatEtc = NULL;
    if (dwDirection == DATADIR_GET)
    {
        BOOL fNoLink = IsDocUntitled();
        ULONG cFormats = ARRAY_SIZE(g_aGetFmtEtcs);

        /* Don't enumerate the link support */
        if (fNoLink)
            cFormats -= 2;  

        hr = CreateFORMATETCEnum(g_aGetFmtEtcs, cFormats,
                ppenumFormatEtc);
    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     CXBag::GetData
//
//     OLE:     IDataObject
//
//  Synopsis:   Deliver data in requested format
//
//---------------------------------------------------------------
STDMETHODIMP
CXBag::GetData(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{
    pmedium->pUnkForRelease = NULL;    // transfer ownership to caller
    pmedium->hGlobal = NULL;
    
    HRESULT hr = DV_E_FORMATETC;
    if ( (pformatetcIn->cfFormat == OleClipFormat[OCF_EMBEDSOURCE]) &&
         (pformatetcIn->dwAspect == DVASPECT_CONTENT) &&
         (pformatetcIn->tymed == TYMED_ISTORAGE) )
    {
        DOUT(TEXT("CXBag::GetData:OCF_EMBEDSOURCE\r\n"));        
        hr = BagItInStorage(pmedium,FALSE);
    }
    else if(pformatetcIn->tymed & TYMED_ISTREAM)
    {
        if ( pformatetcIn->cfFormat == OleClipFormat[OCF_LINKSOURCE] )
        {
            DOUT(TEXT("CXBag::GetData OCF_LINKSOURCE on STREAM\r\n"));
            if(_pHost != NULL)
            {
                hr = _pHost->_pDV->GetLINKSOURCE( (LPSRVRDV)(_pHost->_pDV),
                                                    pformatetcIn,
                                                    pmedium,
                                                    FALSE /* fHere */ );
            }
        }
    }
    else if((pformatetcIn->tymed & TYMED_HGLOBAL) && (_pHost != NULL))
    {
        pmedium->tymed = TYMED_HGLOBAL;
        if ( pformatetcIn->cfFormat == OleClipFormat[OCF_OBJECTDESCRIPTOR] )
        {
            DOUT(TEXT("CXBag::GetData OCF_OBJECTDESCRIPTOR on HGLOBAL\r\n"));
            hr = _pHost->_pDV->GetOBJECTDESCRIPTOR( (LPSRVRDV)(_pHost->_pDV),
                                                    pformatetcIn,
                                                    pmedium,
                                                    FALSE /* fHere */ );
        }
        else if (pformatetcIn->cfFormat == OleClipFormat[OCF_LINKSRCDESCRIPTOR])
        {
            DOUT(TEXT("CXBag::GetData OCF_LINKSRCDESCRIPTOR on HGLOBAL\r\n"));
            hr = _pHost->_pDV->GetOBJECTDESCRIPTOR( (LPSRVRDV)(_pHost->_pDV),
                                                    pformatetcIn,
                                                    pmedium,
                                                    FALSE /* fHere */ );
        }
        else if ( pformatetcIn->cfFormat == CF_WAVE )
        {
            DOUT(TEXT("CXBag::GetData CF_WAVE on HGLOBAL\r\n"));
            if ((pmedium->hGlobal = GetNativeData()) != NULL)
                hr = NOERROR;
        }
        else if ( pformatetcIn->cfFormat == CF_DIB )
        {
            DOUT(TEXT("CXBag::GetData CF_DIB on HGLOBAL\r\n"));            
            if ((pmedium->hGlobal = ::GetDIB(NULL)) != NULL)
                hr = NOERROR;
        }
                
    }
    else if (pformatetcIn->tymed & TYMED_MFPICT)
    {
        pmedium->tymed = TYMED_MFPICT;
        if (pformatetcIn->cfFormat == CF_METAFILEPICT)
        {
            DOUT(TEXT("CXBag::GetData CF_METAFILEPICT\r\n"));
            if (_pHost != NULL)
            {
                if ((pmedium->hGlobal = GetPicture())!= NULL)
                    hr = NOERROR;
            }
        }
    }
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     CXBag::GetDataHere
//
//     OLE:     IDataObject
//
//  Synopsis:   Deliver requested format in specified medium
//
//---------------------------------------------------------------
STDMETHODIMP
CXBag::GetDataHere(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium)
{
    HRESULT hr = DV_E_FORMATETC;
            
    if ( (pformatetc->cfFormat == OleClipFormat[OCF_EMBEDSOURCE]) &&
         (pformatetc->dwAspect == DVASPECT_CONTENT) &&
         (pformatetc->tymed == TYMED_ISTORAGE) )
    {
        DOUT(TEXT("CXBag::GetDataHere:OCF_EMBEDSOURCE\r\n"));
        hr = BagItInStorage(pmedium,TRUE);
    }
    else if(pformatetc->tymed & TYMED_ISTREAM)
    {
        if (pformatetc->cfFormat = (WORD)OleClipFormat[OCF_LINKSOURCE])
        {
            DOUT(TEXT("CXBag::GetDataHere:OCF_LINKSOURCE\r\n"));
            
            if (_pHost != NULL)
            {
                hr = _pHost->_pDV->GetLINKSOURCE((LPSRVRDV)(_pHost->_pDV)
                                                 ,pformatetc
                                                 ,pmedium
                                                 ,TRUE);
            }
        }
    }                                        
    else if ((pformatetc->tymed & TYMED_HGLOBAL) && (_pHost != NULL))
    {
        if ( pformatetc->cfFormat == OleClipFormat[OCF_OBJECTDESCRIPTOR] )
        {
            DOUT(TEXT("CXBag::GetDataHere:OCF_OBJECTDESCRIPTOR\r\n"));
            
            hr = _pHost->_pDV->GetOBJECTDESCRIPTOR( _pHost->_pDV,
                    pformatetc,
                    pmedium,
                    TRUE /* fHere */ );
        }
        else if ( pformatetc->cfFormat == OleClipFormat[OCF_LINKSRCDESCRIPTOR])
        {
            DOUT(TEXT("CXBag::GetDataHere:OCF_LINKSRCDESCRIPTOR\r\n"));
            
            hr = _pHost->_pDV->GetOBJECTDESCRIPTOR( _pHost->_pDV,
                    pformatetc,
                    pmedium,
                    TRUE /* fHere */ );
        }
        else if ( pformatetc->cfFormat == CF_WAVE )
        {
            DOUT(TEXT("CXBag::GetDataHere CF_WAVE on HGLOBAL\r\n"));
            if ((pmedium->hGlobal = GetNativeData()) != NULL)
                hr = NOERROR;
        }
        else if ( pformatetc->cfFormat == CF_DIB )
        {
            DOUT(TEXT("CXBag::GetDataHere CF_DIB on HGLOBAL\r\n"));

            if ((pmedium->hGlobal = ::GetDIB(pmedium->hGlobal)) != NULL)
                hr = NOERROR;
        }
        
    }
    else if (pformatetc->tymed & TYMED_MFPICT)
    {
        pmedium->tymed = TYMED_MFPICT;
        if (pformatetc->cfFormat == CF_METAFILEPICT)
        {
            DOUT(TEXT("CXBag::GetData CF_METAFILEPICT\r\n"));
            if (_pHost != NULL)
            {
                if ((pmedium->hGlobal = GetPicture()) != NULL)
                    hr = NOERROR;
            }
        }
    }

#if 0
        //
        // Replace with appropriate format handlers...
        //
        else if ( pformatetc->cfFormat == g_cfSourceList )
        {
            hr = _pBaggedList->Copy(pmedium->hGlobal);
        }
#endif
    return hr;
}


//
// (Open-Editing) Server Object for SoundRec
//==========================================
//

//+---------------------------------------------------------------
//
//  Member:     SRCtrl::ClassInit, public
//
//  Synopsis:   Initializes the SRCtrl class
//
//  Arguments:  [pClass] -- our class descriptor
//
//  Returns:    TRUE iff the class could be initialized successfully
//
//  Notes:      This method initializes the verb tables in the
//              class descriptor.
//
//---------------------------------------------------------------

static OLECHAR lpszPlay[64];
static OLECHAR lpszEdit[64];
static OLECHAR lpszOpen[64];

BOOL
SRCtrl::ClassInit(LPCLASSDESCRIPTOR pClass)
{
    // These are our verb tables.  They are used by the base class
    // in implementing methods of the IOleObject interface.
    // NOTE: the verb table must be in ascending, consecutive order
    static OLEVERB OleVerbs[] =
    {
    //  { lVerb, lpszVerbName, fuFlags, grfAttribs },
        { OLEIVERB_INPLACEACTIVATE, NULL, 0, 0 },
        { OLEIVERB_UIACTIVATE, NULL, 0, 0 },
        { OLEIVERB_HIDE, NULL, 0, 0 },
        { OLEIVERB_OPEN, NULL, 0, 0 },
        { OLEIVERB_SHOW, NULL, 0, 0 },
        { OLEIVERB_PRIMARY, lpszPlay, MF_ENABLED, OLEVERBATTRIB_ONCONTAINERMENU },
        { 1, lpszEdit, MF_ENABLED, OLEVERBATTRIB_ONCONTAINERMENU },
        { 2, lpszOpen, MF_ENABLED, OLEVERBATTRIB_ONCONTAINERMENU }
    };
#if !defined(UNICODE) && !defined(OLE2ANSI)
    TCHAR sz[64];
    LoadString(ghInst, IDS_PLAYVERB, sz, ARRAY_SIZE(sz));
    MultiByteToWideChar(CP_ACP, 0, sz, -1, lpszPlay, ARRAY_SIZE(lpszPlay));
    
    LoadString(ghInst, IDS_EDITVERB, sz, ARRAY_SIZE(sz));
    MultiByteToWideChar(CP_ACP, 0, sz, -1, lpszEdit, ARRAY_SIZE(lpszEdit));
    
    LoadString(ghInst, IDS_OPENVERB, sz, ARRAY_SIZE(sz));
    MultiByteToWideChar(CP_ACP, 0, sz, -1, lpszOpen, ARRAY_SIZE(lpszOpen));
    
#else
    LoadString(ghInst, IDS_PLAYVERB, lpszPlay, ARRAY_SIZE(lpszPlay));
    LoadString(ghInst, IDS_EDITVERB, lpszEdit, ARRAY_SIZE(lpszEdit));
    LoadString(ghInst, IDS_OPENVERB, lpszOpen, ARRAY_SIZE(lpszOpen));
#endif
    
    pClass->_pVerbTable = OleVerbs;
    pClass->_cVerbTable = ARRAY_SIZE(OleVerbs);

    return TRUE;
}

//+---------------------------------------------------------------
//
//  Member:     SRCtrl::Create, public
//
//  Synopsis:   Creates and initializes an SRCtrl object
//
//  Arguments:  [pUnkOuter] -- A controlling unknown.  NULL if we are not
//                             being created as part of an aggregation
//              [pClass]    -- The OlePad class descriptor
//              [ppUnkCtrl] -- Where we return our controlling unknown
//              [ppObj]     -- Pointer to the SRCtrl object created
//
//  Returns:    Success if the object could be successfully created and
//              initialized.
//
//---------------------------------------------------------------

HRESULT
SRCtrl::Create( LPUNKNOWN pUnkOuter,
        LPCLASSDESCRIPTOR pClass,
        LPUNKNOWN FAR* ppUnkCtrl,
        LPSRCTRL FAR* ppObj)
{
    // set out parameters to NULL
    *ppUnkCtrl = NULL;
    *ppObj = NULL;

    if(gpCtrlThis)
    {
        DOUT(TEXT("SRCtrl::Create non-NULL gpCtrlThis!"));
        return E_FAIL;
    }

    // create an object
    HRESULT hr = E_OUTOFMEMORY;
    LPSRCTRL pObj = new SRCtrl(pUnkOuter);
    if (pObj != NULL)
    {
        // initialize it
        if (OK(hr = pObj->Init(pClass)))
        {
            // return the object and its controlling unknown
            *ppUnkCtrl = &pObj->_PrivUnk;
            *ppObj = gpCtrlThis = pObj;
        }
    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SRCtrl::SRCtrl, protected
//
//  Synopsis:   Constructor for the SRCtrl class
//
//  Arguments:  [pUnkOuter] -- the controlling unknown or NULL if we are
//                              not being created as part of an aggregate
//
//  Notes:      This is the first part of a two-stage construction process.
//              The second part is in the Init method.  Use the static
//              Create method to properly instantiate an SRCtrl object
//
//---------------------------------------------------------------

#pragma warning(disable:4355)   // `this' argument to base-member init. list.
SRCtrl::SRCtrl(LPUNKNOWN pUnkOuter):
        _PrivUnk(this)  // the controlling unknown holds a pointer to the object
{
    static SrvrCtrl::LPFNDOVERB VerbFuncs[] =
    {
        &SrvrCtrl::DoInPlaceActivate, // OLEIVERB_INPLACEACTIVATE
        &SrvrCtrl::DoUIActivate,      // OLEIVERB_UIACTIVATE
        &SrvrCtrl::DoHide,            // OLEIVERB_HIDE
        &SRCtrl::DoOpen,              // OLEIVERB_OPEN
        &SRCtrl::DoShow,              // OLEIVERB_SHOW
        &SRCtrl::DoPlay,              // Play, OLEIVERB_PRIMARY
        &SRCtrl::DoOpen,              // Edit 
        &SRCtrl::DoOpen               // Open
    };

    _pUnkOuter = (pUnkOuter != NULL) ? pUnkOuter : (LPUNKNOWN)&_PrivUnk;

    _pDVCtrlUnk = NULL;
    _pIPCtrlUnk = NULL;

    _pVerbFuncs = VerbFuncs;
    _cLock = 0;
    _fLoaded = FALSE;
}
#pragma warning(default:4355)

//+---------------------------------------------------------------
//
//  Member:     SRCtrl::DoPlay, public, static
//
//  Synopsis:   Implementation of the play verb.
//              This verb results in a transition to the open state.
//
//---------------------------------------------------------------

HRESULT
SRCtrl::DoPlay(LPVOID pv,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    DOUT(TEXT("SrvrCtrl::DoPlay\r\n"));
    LPSRCTRL pCtrl = (LPSRCTRL)pv;

    BOOL fClose = FALSE;
    
    /* if we are already open, just play it.
     * if we aren't, play it and close.
     */
    if (!gfStandalone)
    {
        fClose = pCtrl->State() != OS_OPEN;
        
        /* We've never been loaded.  This means someone (Project 4.0) is
         * calling our primary verb incorrectly on Insert->Object.  They
         * really want us to DoOpen.
         */
        if (!pCtrl->IsLoaded())
            return (pCtrl->DoOpen(pv, iVerb, lpmsg, pActiveSite, lindex,
                hwndParent,lprcPosRect));
    }

    if (IsWindowVisible(ghwndApp))
        SetForegroundWindow(ghwndApp);
    
    AppPlay(fClose);
    
    return pCtrl->TransitionTo(OS_OPEN);
}

//+---------------------------------------------------------------
//
//  Member:     SRCtrl::DoShow, public
//
//  Synopsis:   Implementation of the standard verb OLEIVERB_SHOW.
//              This verb results in a transition to the open state.
//
//---------------------------------------------------------------

HRESULT
SRCtrl::DoShow(LPVOID pv,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    DOUT(TEXT("SrvrCtrl::DoShow\r\n"));

    LPSRCTRL pCtrl = (LPSRCTRL)pv;
    if(pCtrl->State() == OS_OPEN)
    {
        HWND hwnd = NULL;
        if(pCtrl->_pInPlace)
            pCtrl->_pInPlace->GetWindow(&hwnd);
        if(hwnd != NULL)
            SetForegroundWindow(hwnd);
    }
    WriteObjectIfEmpty();
    return pCtrl->TransitionTo(OS_OPEN);
}

//+---------------------------------------------------------------
//
//  Member:     SRCtrl::DoOpen, public
//
//  Synopsis:   Implementation of the standard verb OLEIVERB_OPEN.
//              This verb results in a transition to the open state.
//
//---------------------------------------------------------------
HRESULT
SRCtrl::DoOpen(LPVOID pv,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    DOUT(TEXT("SRCtrl::DoOpen\r\n"));

    LPSRVRCTRL pCtrl = (LPSRVRCTRL)pv;
    if(pCtrl->State() == OS_OPEN)
    {
        HWND hwnd = NULL;
        if(pCtrl->_pInPlace)
            pCtrl->_pInPlace->GetWindow(&hwnd);
        if(hwnd != NULL)
            SetForegroundWindow(hwnd);
        if (IsWindowVisible(ghwndApp))
            SetForegroundWindow(ghwndApp);

    }
    return pCtrl->TransitionTo(OS_OPEN);
}

//+---------------------------------------------------------------
//
//  Member:     SRCtrl::Init, protected
//
//  Synopsis:   Initializes an SRCtrl object
//
//  Arguments:  [pClass] -- the class descriptor
//
//  Returns:    SUCCESS iff the class could be initialized
//
//  Notes:      This is the second part of a two-stage construction
//              process.  Use the static Create method to properly
//              instantiate an SRCtrl object.
//
//---------------------------------------------------------------

HRESULT
SRCtrl::Init(LPCLASSDESCRIPTOR pClass)
{
    HRESULT hr = NOERROR;

    if (OK(hr = SrvrCtrl::Init(pClass)))
    {
        LPSRDV pSRDV;
        LPUNKNOWN pDVCtrlUnk;
        if (OK(hr = SRDV::Create(this, pClass, &pDVCtrlUnk, &pSRDV)))
        {
            LPSRINPLACE pSRInPlace;
            LPUNKNOWN pIPCtrlUnk;
            if (OK(hr = SRInPlace::Create(this,
                    pClass,
                    &pIPCtrlUnk,
                    &pSRInPlace)))
            {
                _pDVCtrlUnk = pDVCtrlUnk;
                _pDV = pSRDV;
                _pIPCtrlUnk = pIPCtrlUnk;
                _pInPlace = pSRInPlace;

                pDVCtrlUnk->AddRef();
//        This was in paintbrush.  I expect it's because standalone objects don't
//        do state transitions correctly
//                Lock();
            }
            pDVCtrlUnk->Release();  // on failure this will free DV subobject
        }
    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SRCtrl::~SRCtrl
//
//  Synopsis:   Destructor for the SRCtrl class
//
//---------------------------------------------------------------

SRCtrl::~SRCtrl(void)
{
    DOUT(TEXT("SRCtrl::~SRCtrl\r\n"));
    if(_state > OS_PASSIVE)
    {
        // make sure we are back to the loaded state
        TransitionTo(OS_LOADED);
    }
    
    //
    // If we are not being shut down by the user (via FILE:EXIT etc.,)
    // then we must cause app shutdown here...
    //

// This AddRef is necessary to prevent a reentrancy within
// TerminateServer because it does a QI and Release to get a storage
// if an uncommitted object is on the clipboard at exit time. 
    AddRef();
    
    if (!gfUserClose && !gfTerminating)
        TerminateServer();

    if (gpFileMoniker != NULL)
        gpFileMoniker->Release();

    //
    // release the controlling unknowns of our subobjects, which should
    // free them...
    //
    DOUT(TEXT("~SRCtrl: DV->Release\r\n"));
    if (_pDVCtrlUnk != NULL)
    {
        _pDVCtrlUnk->Release();
    }
    
    DOUT(TEXT("~SRCtrl: IP->Release\r\n"));
    if (_pIPCtrlUnk != NULL)
    {
        _pIPCtrlUnk->Release();
    }
    
    gpCtrlThis = NULL;
}


// the standard IUnknown methods all delegate to the controlling unknown.
IMPLEMENT_DELEGATING_IUNKNOWN(SRCtrl)

IMPLEMENT_PRIVATE_IUNKNOWN(SRCtrl)

//+---------------------------------------------------------------
//
//  Member:     SRCtrl::PrivateUnknown::QueryInterface
//
//  Synopsis:   QueryInterface on our controlling unknown
//
//---------------------------------------------------------------

STDMETHODIMP
SRCtrl::PrivateUnknown::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
#if DBG
    TCHAR achBuffer[256];
    wsprintf(achBuffer,
            TEXT("SRCtrl::PrivateUnknown::QueryInterface (%lx)\r\n"),
            riid.Data1);
    DOUT(achBuffer);
#endif
    
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (void FAR *)this;
    }
    else if (IsEqualIID(riid, IID_IOleObject))
    {
        *ppv = (void FAR *) (LPOLEOBJECT)_pSRCtrl;
    }
    else    // try each of our delegate subobjects until one succeeds
    {
        HRESULT hr;
        if (!OK(hr = _pSRCtrl->_pDVCtrlUnk->QueryInterface(riid, ppv)))
            hr = _pSRCtrl->_pIPCtrlUnk->QueryInterface(riid, ppv);
        return hr;
    }

    //
    // Important:  we must addref on the pointer that we are returning,
    // because that pointer is what will be released!
    //
    ((IUnknown FAR*) *ppv)->AddRef();
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SRCtrl::GetMoniker
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      Our overide creates a file moniker for the Standalone case
//
//---------------------------------------------------------------

STDMETHODIMP
SRCtrl::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk)
{
    DOUT(TEXT("SRCtrl::GetMoniker\r\n"));

    HRESULT hr = E_INVALIDARG;

    if (ppmk == NULL)
    {
        DOUT(TEXT("SRCtrl::GetMoniker E_INVALIDARG\r\n"));
        return hr;
    }
    *ppmk = NULL;   // set out parameters to NULL

    if(gfStandalone || gfLinked)    // set by FlagEmbededObject()
    {
        if(gpFileMoniker != NULL)
        {
            *ppmk = gpFileMoniker;
            gpFileMoniker->AddRef();
            hr = NOERROR;
        }
        else
        {
#if !defined(UNICODE) && !defined(OLE2ANSI)            
            LPOLESTR lpLinkFilename = ConvertMBToOLESTR(gachLinkFilename, -1);
            if((hr = CreateFileMoniker(lpLinkFilename, &gpFileMoniker)) == NOERROR)
            {
                gpFileMoniker->AddRef(); //because we are keeping this pointer
                *ppmk = gpFileMoniker;
                RegisterAsRunning((LPUNKNOWN)this, *ppmk, &gdwRegROT);
            }
            else
            {
                DOUT(TEXT("SRCtrl::GetMoniker CreateFileMoniker FAILED!\r\n"));
            }
            TaskFreeMem(lpLinkFilename);
#else
            if((hr = CreateFileMoniker(gachLinkFilename, &gpFileMoniker)) == NOERROR)
            {
                gpFileMoniker->AddRef(); //because we are keeping this pointer
                *ppmk = gpFileMoniker;
                RegisterAsRunning((LPUNKNOWN)this, *ppmk, &gdwRegROT);
            }
            else
            {
                DOUT(TEXT("SRCtrl::GetMoniker CreateFileMoniker FAILED!\r\n"));
            }
#endif                        
        }
    }
    else
    {
        return SrvrCtrl::GetMoniker(dwAssign, dwWhichMoniker, ppmk);
    }
    return hr;
}
//+---------------------------------------------------------------
//
//  Member:     SRCtrl::IsUpToDate
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      Return S_FALSE if we are dirty (not up-to-date)
//
//---------------------------------------------------------------

STDMETHODIMP
SRCtrl::IsUpToDate(void)
{
    DOUT(TEXT("SRCtrl::IsUpToDate\r\n"));

    return gfDirty ? S_FALSE : S_OK;
}
#if 0
//+---------------------------------------------------------------
//
//  Member:     SRCtrl::GetHostNames, public
//
//  Synopsis:   Returns any host names set by the container
//
//  Arguments:  [plpstrCntrApp] -- location for string indicating the top-level
//                                  container application.
//              [plpstrCntrObj] -- location for string indicating the top-level
//                                  document.
//
//  Notes:      The method makes available the strings originally set by the
//              container using IOleObject::SetHostNames.  These strings are
//              used in the title bar of an open-edited object.  It is useful
//              to containers that need to forward this information to their
//              embeddings.  The returned strings are allocated using the
//              standard task allocator and should be freed appropriately by
//              the caller.
//
//---------------------------------------------------------------

void
SRCtrl::GetHostNames(LPTSTR FAR* plpstrCntrApp, LPTSTR FAR* plpstrCntrObj)
{
    if (_lpstrCntrApp != NULL)
    {
        TaskAllocString(_lpstrCntrApp, plpstrCntrApp);
    }
    else
    {
        *plpstrCntrApp = NULL;
    }

    if (_lpstrCntrObj != NULL)
    {
        TaskAllocString(_lpstrCntrObj, plpstrCntrObj);
    }
    else
    {
        *plpstrCntrObj = NULL;
    }
}
#endif
void
SRCtrl::Lock(void)
{
    ++_cLock;
#if DBG
    TCHAR achBuffer[256];
    wsprintf(achBuffer, TEXT("\\\\SRCtrl::Lock (%d)\r\n"), _cLock);
    DOUT(achBuffer);
#endif
    CoLockObjectExternal((LPUNKNOWN)&_PrivUnk, TRUE, TRUE);
}

void
SRCtrl::UnLock(void)
{
    --_cLock;
#if DBG
    TCHAR achBuffer[256];
    wsprintf(achBuffer, TEXT("\\\\SRCtrl::UnLock (%d)\r\n"), _cLock);
    DOUT(achBuffer);
#endif
    Assert(_cLock >= 0);
    CoLockObjectExternal((LPUNKNOWN)&_PrivUnk, FALSE, TRUE);
}

BOOL
SRCtrl::IsLoaded(void)
{
    return _fLoaded;
}

void
SRCtrl::MarkAsLoaded(void)
{
    _fLoaded = TRUE;
}

HRESULT
SRCtrl::PassiveToLoaded()
{
    DOUT(TEXT("=== SRCtrl::PassiveToLoaded\r\n"));
    Lock();    
    return SrvrCtrl::PassiveToLoaded();
}

HRESULT
SRCtrl::LoadedToPassive()
{
    DOUT(TEXT("=== SRCtrl::LoadedToPassive\r\n"));
    HRESULT hr = SrvrCtrl::LoadedToPassive();
    UnLock();
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     SRCtrl::RunningToOpened
//
//  Synopsis:   Effects the running to open state transition
//
//  Returns:    SUCCESS in all but catastrophic circumstances
//
//---------------------------------------------------------------

HRESULT
SRCtrl::RunningToOpened()
{
    DOUT(TEXT("SRCtrl::RunningToOpened\r\n"));

    // ...  show open editing window
    if (!gfStandalone)
    {
        FixMenus();
    
        if (gfShowWhilePlaying)
            ShowWindow(ghwndApp, SW_SHOW | SW_SHOWNORMAL);
        if (IsWindowVisible(ghwndApp))
            SetForegroundWindow(ghwndApp);
    }
    OleNoteObjectVisible((LPUNKNOWN)&_PrivUnk, TRUE);

    //
    // notify our container so it can hatch-shade our object 
    // indicating that it is open-edited...
    //
    
    if (_pClientSite != NULL)
        _pClientSite->OnShowWindow(TRUE);

    SetFocus(ghwndApp);

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SRCtrl::OpenedToRunning
//
//  Synopsis:   Effects the open to running state transition
//
//  Returns:    SUCCESS in all but catastrophic circumstances
//
//---------------------------------------------------------------

HRESULT
SRCtrl::OpenedToRunning()
{
    DOUT(TEXT("SRCtrl::OpenedToRunning\r\n"));
    
    //
    // If we are transitioning to a standalone app, we don't want the app
    // to disappear.
    //
    ShowWindow(ghwndApp,SW_HIDE);
    
    HRESULT hr = SrvrCtrl::OpenedToRunning();
    
    OleNoteObjectVisible((LPUNKNOWN)&_PrivUnk, FALSE);
    
    return hr;
}


const OLECHAR szContentsStrm[] = OLETEXT("contents");
const OLECHAR szOLE1Strm[] = OLETEXT("\1Ole10Native");

//---------------------------------------------------------------
//
//  The Format Tables
//
//---------------------------------------------------------------

//
// GetData format information
// note: the LINKSRCDESCRIPTOR and OBJECTDESCRIPTOR are identical structures
//       so we use the OBJECTDESCRIPTOR get/set fns for both.
//

    static FORMATETC SRGetFormatEtc[] =
    {// { cfFormat, ptd, dwAspect, lindex, tymed },
#if 0
// NTBUG # 11225: CorelDraw 5.0 does not like our implementation of
//                CF_EMBEDDEDOBJECT and cannot save our data in the
//                Insert->Object->CreateFromFile scenerio        
        
        { (unsigned short)-OCF_EMBEDDEDOBJECT, NULL, DVASPECT_CONTENT, -1L, TYMED_ISTORAGE },
#else
        { (unsigned short)-OCF_EMBEDSOURCE, NULL, DVASPECT_CONTENT, -1L, TYMED_ISTORAGE },
#endif
        { CF_METAFILEPICT, DVTARGETIGNORE, DVASPECT_CONTENT, -1L, TYMED_MFPICT },
        { CF_DIB, DVTARGETIGNORE, DVASPECT_CONTENT, -1L, TYMED_HGLOBAL },            
        { (unsigned short)-OCF_OBJECTDESCRIPTOR, NULL, DVASPECT_CONTENT, -1L, TYMED_HGLOBAL },
        { (unsigned short)-OCF_LINKSRCDESCRIPTOR, NULL, DVASPECT_CONTENT, -1L, TYMED_HGLOBAL },
        { (unsigned short)-OCF_LINKSOURCE, NULL, DVASPECT_CONTENT, -1L, TYMED_ISTREAM }
    };
    
    static SrvrDV::LPFNGETDATA SRGetFormatFuncs[] =
    {   &SRDV::GetEMBEDDEDOBJECT,
        &SRDV::GetMETAFILEPICT,
        &SRDV::GetDIB,
        &SRDV::GetOBJECTDESCRIPTOR,
        &SRDV::GetOBJECTDESCRIPTOR,
        &SRDV::GetLINKSOURCE
    };

//+---------------------------------------------------------------
//
//  Member:     SRDV::ClassInit (static)
//
//  Synopsis:   Initializes the SRDV class
//
//  Arguments:  [pClass] -- our class descriptor
//
//  Returns:    TRUE iff the class could be initialized successfully
//
//  Notes:      This method initializes the format tables in the
//              class descriptor.
//
//---------------------------------------------------------------

BOOL
SRDV::ClassInit(LPCLASSDESCRIPTOR pClass)
{
    // fill in the class descriptor structure with the format tables
    pClass->_pGetFmtTable = SRGetFormatEtc;
    pClass->_cGetFmtTable = ARRAY_SIZE(SRGetFormatEtc);

    pClass->_pSetFmtTable = NULL;
    pClass->_cSetFmtTable = 0;

    //
    // walk our format tables and complete the cfFormat field from
    // the array of standard OLE clipboard formats.
    //
    LPFORMATETC pfe = SRGetFormatEtc;
    int c = ARRAY_SIZE(SRGetFormatEtc);

    for (int i = 0; i < c; i++, pfe++)
    {
        // if the clipformat is negative, then it really is an index into
        // our table of standard OLECLIPFORMATS
        int j = - (short)pfe->cfFormat;
        if (j >= 0 && j <= OCF_LAST)
            pfe->cfFormat = (WORD)OleClipFormat[j];
    }

    pfe = g_aGetFmtEtcs;
    c = ARRAY_SIZE(g_aGetFmtEtcs);

    for (i = 0; i < c; i++, pfe++)
    {
        // if the clipformat is negative, then it really is an index into
        // our table of standard OLECLIPFORMATS
        
        int j = - (short)pfe->cfFormat;
        if (j >= 0 && j <= OCF_LAST)
        {
            pfe->cfFormat = (WORD)OleClipFormat[j];
        }
    }
    
    return TRUE;
}

HRESULT
SRDV::GetDIB( LPSRVRDV pDV,
        LPFORMATETC pformatetc,
        LPSTGMEDIUM pmedium,
        BOOL fHere)
{
    HRESULT hr = NOERROR;
    LPVIEWOBJECT pView = (LPVIEWOBJECT)pDV;
    HANDLE hDIB;
            
    if (!fHere)
    {
        // fill in the pmedium structure
        pmedium->tymed = TYMED_HGLOBAL;
    }

    hDIB = ::GetDIB(pmedium->hGlobal);
    if (hDIB)
        pmedium->hGlobal = hDIB;
    else
        hr = E_OUTOFMEMORY;
    
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     SRDV::Create, public
//
//  Synopsis:   Creates and initializes an SRDV object
//
//  Arguments:  [pCtrl]     -- our control subobject
//              [pClass]    -- The class descriptor
//              [ppUnkCtrl] -- Where we return our controlling unknown
//              [ppObj]     -- where the created object is returned
//
//  Returns:    Success if the object could be successfully created and
//              initialized.
//
//---------------------------------------------------------------

HRESULT
SRDV::Create(LPSRCTRL pCtrl,
        LPCLASSDESCRIPTOR pClass,
        LPUNKNOWN FAR* ppUnkCtrl,
        LPSRDV FAR* ppObj)
{
    // set out parameters to NULL
    *ppUnkCtrl = NULL;
    *ppObj = NULL;

    // create an object
    HRESULT hr;
    LPSRDV pObj;
    pObj = new SRDV((LPUNKNOWN)(LPOLEOBJECT)pCtrl);
    if (pObj == NULL)
    {
        hr =  E_OUTOFMEMORY;
    }
    else
    {
        // initialize it
        if (OK(hr = pObj->Init(pCtrl, pClass)))
        {
            // return the object and its controlling unknown
            *ppUnkCtrl = &pObj->_PrivUnk;
            *ppObj = pObj;
        }
        else
        {
            pObj->_PrivUnk.Release();   //hari-kari
        }
    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SRDV::SRDV, protected
//
//  Synopsis:   Constructor for the SRDV class
//
//  Arguments:  [pUnkOuter] -- the controlling unknown.  This is either
//                             a SRCtrl subobject or NULL we are being
//                             created as a transfer object.
//
//  Notes:      This is the first part of a two-stage construction process.
//              The second part is in the Init method.  Use the static
//              Create method to properly instantiate an SRDV object
//
//---------------------------------------------------------------

#pragma warning(disable:4355)   // `this' argument to base-member init. list.
SRDV::SRDV(LPUNKNOWN pUnkOuter):
    _PrivUnk(this)  // the controlling unknown holds a pointer to the object
{
    _pUnkOuter = (pUnkOuter != NULL) ? pUnkOuter : (LPUNKNOWN)&_PrivUnk;

    _pGetFuncs = SRGetFormatFuncs;
    _pSetFuncs = NULL;

    _sizel = _header._sizel;
}
#pragma warning(default:4355)

//+---------------------------------------------------------------
//
//  Member:     SRDV::Init, protected
//
//  Synopsis:   Initializes an SRDV object
//
//  Arguments:  [pCtrl]  -- our controlling SRCtrl subobject
//              [pClass] -- the class descriptor
//
//  Returns:    SUCCESS iff the class could be initialized
//
//  Notes:      This is the second part of a two-stage construction
//              process.  Use the static Create method to properly
//              instantiate an SRDV object.
//
//---------------------------------------------------------------

HRESULT
SRDV::Init(LPSRCTRL pCtrl, LPCLASSDESCRIPTOR pClass)
{
    HRESULT hr = SrvrDV::Init(pClass, pCtrl);
    //
    //do our own xtra init here...
    //
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SRDV::~SRDV
//
//  Synopsis:   Destructor for the SRDV class
//
//---------------------------------------------------------------

SRDV::~SRDV(void)
{
    //
    // TODO: check on anything we may have to clean up here...
    //
}

// the standard IUnknown methods all delegate to a controlling unknown.
IMPLEMENT_DELEGATING_IUNKNOWN(SRDV)

IMPLEMENT_PRIVATE_IUNKNOWN(SRDV)

//+---------------------------------------------------------------
//
//  Member:     SRDV::PrivateUnknown::QueryInterface
//
//  Synopsis:   QueryInterface on our controlling unknown
//
//---------------------------------------------------------------

STDMETHODIMP
SRDV::PrivateUnknown::QueryInterface (REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid,IID_IUnknown))
    {
        *ppv = (LPVOID)this;
    }
    else if (IsEqualIID(riid,IID_IDataObject))
    {
        *ppv = (LPVOID)(LPDATAOBJECT)_pSRDV;
    }
    else if (IsEqualIID(riid,IID_IViewObject))
    {
        *ppv = (LPVOID)(LPVIEWOBJECT)_pSRDV;
    }
    else if (IsEqualIID(riid,IID_IPersist))
    {
        //
        // The standard handler wants this
        //
        *ppv = (LPVOID)(LPPERSIST)(LPPERSISTSTORAGE)_pSRDV;
    }
    else if (IsEqualIID(riid,IID_IPersistStorage))
    {
        *ppv = (LPVOID)(LPPERSISTSTORAGE)_pSRDV;
    }
    else if (IsEqualIID(riid,IID_IPersistFile))
    {
        *ppv = (LPVOID)(LPPERSISTFILE)_pSRDV;
    }
    else   
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    //
    // Important:  we must addref on the pointer that we are returning,
    // because that pointer is what will be released!
    //
    ((IUnknown FAR*) *ppv)->AddRef();
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SRDV::RenderContent, public
//
//  Synopsis:   Draws our contents into a display context
//
//  Arguments:  The arguments are the same as to the IViewObject::Draw method
//
//  Returns:    SUCCESS if the content was rendered
//
//  Notes:      This virtual method of the base class is called to implement
//              IViewObject::Draw for the DVASPECT_CONTENT aspect.
//
//----------------------------------------------------------------

HRESULT
SRDV::RenderContent(DWORD dwDrawAspect,
        LONG lindex,
        void FAR* pvAspect,
        DVTARGETDEVICE FAR * ptd,
        HDC hicTargetDev,
        HDC hdcDraw,
        LPCRECTL lprectl,
        LPCRECTL lprcWBounds,
        BOOL (CALLBACK *pfnContinue) (ULONG_PTR),
        ULONG_PTR dwContinue)
{
    DOUT(TEXT("SoundRec: RenderContent\r\n"));
    
    int x = GetSystemMetrics(SM_CXICON);
    int y = GetSystemMetrics(SM_CYICON);
    HDC hdc = GetDC(ghwndApp);
    HDC hdcMem = CreateCompatibleDC(hdc);
    HBITMAP hbm = CreateCompatibleBitmap(hdc, x, y);
    HBITMAP hbmOld = (HBITMAP)SelectObject(hdcMem, hbm);
    
    PatBlt(hdcMem, 0, 0, x, y, WHITENESS); 
    DrawIcon(hdcMem, 0, 0, ghiconApp);    
    
    StretchBlt(hdcDraw, lprectl->left, lprectl->top,
                lprectl->right - lprectl->left, lprectl->bottom - lprectl->top,
                hdcMem, 0, 0, x, y, SRCCOPY);
    
    hbm = (HBITMAP)SelectObject(hdcMem, hbmOld);
    
    if (hdcMem)
        DeleteDC(hdcMem);
    if (hbm)
        DeleteObject(hbm);
    if (hdc)
        ReleaseDC(ghwndApp, hdc);
    
    return NOERROR;
}


/*
 * SRDV::Load
 * Implements IPersistFile::Load
 *
 * Side effects: gfLinked - we know we are linked.
 */

STDMETHODIMP
SRDV::Load (LPCOLESTR lpstrFile, DWORD grfMode)
{
    DOUT(TEXT("SoundRec:SRDV::Load\r\n"));
    
#if !defined(UNICODE) && !defined(OLE2ANSI)
    LPTSTR lpszFileName = ConvertOLESTRToMB(lpstrFile,-1);
    FileLoad(lpszFileName);
    TaskFreeMem(lpszFileName);
#else
    TCHAR szFileName[256];
    
    lstrcpy(szFileName,lpstrFile);
    FileLoad(szFileName);
#endif
    gfLinked = TRUE;
    if (gpCtrlThis)
        gpCtrlThis->MarkAsLoaded();
    
    return ResultFromScode( S_OK );
}
    


//+---------------------------------------------------------------
//
//  Member:     LoadFromStorage
//
//  Synopsis:   Loads our data from a storage
//
//  Arguments:  [pStg] -- storage to load from
//
//  Returns:    SUCCESS if our native data was loaded
//
//  Notes:      This is a virtual method in our base class that is called
//              on an IPersistStorage::Load and an IPersistFile::Load when
//              the file is a docfile.  We override this method to
//              do our server-specific loading.
//
//----------------------------------------------------------------

HRESULT
SRDV::LoadFromStorage(LPSTORAGE pStg)
{
    DOUT(TEXT("SoundRec: LoadFromStorage\r\n"));
    LPSTREAM pStrm;

    // Open the OLE 1 Stream. 
    HRESULT hr = pStg->OpenStream(szOLE1Strm, NULL, STGM_SALL,0, &pStrm);
    
    if (OK(hr))
    {
        DWORD cbSize = 0L;

        pStrm->Read(&cbSize, sizeof(DWORD), NULL);
        
        if (cbSize > 0L)
        {
            LPBYTE lpbData = NULL;
            HANDLE hData = GlobalAlloc(GMEM_DDESHARE | GMEM_ZEROINIT, cbSize);
        
            if(hData != NULL)
            {
                if ((lpbData = (LPBYTE)GlobalLock(hData)) != NULL)
                {
                    pStrm->Read(lpbData, cbSize - sizeof(DWORD), NULL);
                    PutNativeData(lpbData, cbSize);
                    
                    GlobalUnlock(hData);
                    GlobalFree(hData);
                    if (gpCtrlThis)
                        gpCtrlThis->MarkAsLoaded();
                }
                else
                {
                    DOUT(TEXT("!Cannot Allocate Memory\r\n"));
                }
            }
        }
        pStrm->Release();
    }
    else
    {
//  There might be, in the future this ole2 stream, also, beta
//  ole objects will break without this.
        
        hr = pStg->OpenStream(szContentsStrm, NULL, STGM_SALL,0, &pStrm);
        if (OK(hr))
        {
            // Read the whole contents stream into memory and use that as a stream
            // to do our bits and pieces reads.
            pStrm = ConvertToMemoryStream(pStrm);

            hr = _header.Read(pStrm);
            if (OK(hr))
            {
                _sizel = _header._sizel;
                if(_header._dwNative > 0)
                {
                    //
                    //TODO: this code needs to be optimized. It is bad to create
                    //      three redundant copies of the wave data! At a minimum,
                    //      the ReadWaveFile (file.c) function should get a
                    //      companion MMIOProc capable of reading directly from
                    //      the stream...
                    //
                    LPBYTE lpbData = NULL;
                    HANDLE hData = GlobalAlloc(GMEM_DDESHARE | GMEM_ZEROINIT, _header._dwNative);
                    if(hData != NULL)
                    {
                        if ((lpbData = (LPBYTE)GlobalLock(hData)) != NULL)
                        {
                            pStrm->Read(lpbData, _header._dwNative, NULL);
                            PutNativeData(lpbData, _header._dwNative);
                            GlobalUnlock(hData);
                            GlobalFree(hData);
                            if (gpCtrlThis)
                                gpCtrlThis->MarkAsLoaded();
                        }
                    }
                    else
                    {
                        DOUT(TEXT("!Cannot Allocate Memory\r\n"));
                    }
                }
            }
            pStrm->Release();
        }
        else
        {
            DOUT(TEXT("!Cannot Open Stream\r\n"));
        }
    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SaveToStorage
//
//  Synopsis:   Saves our data to a storage
//
//  Arguments:  [pStg]        -- storage to save to
//              [fSameAsLoad] -- flag indicating whether this is the same
//                               storage that we originally loaded from
//
//  Returns:    SUCCESS if our native data was saved
//
//  Notes:      This is a virtual method in our base class that is called
//              on an IPersistStorage::Save and IPersistFile::Save when the
//              file is a docfile.  We override this method to
//              do our server-specific saving.
//
//----------------------------------------------------------------

HRESULT
SRDV::SaveToStorage(LPSTORAGE pStg, BOOL fSameAsLoad)
{
    DOUT(TEXT("SoundRec: SaveToStorage\r\n"));

    HRESULT hr;

    // Mark our storage as OLE1
    if (!OK(hr = WriteClassStg(pStg, CLSID_OLE1SOUNDREC)))
        return hr;
    
    // open or create the native data stream and write our native data
    LPSTREAM pStrm;

    hr = pStg->CreateStream(szOLE1Strm,
            STGM_SALL | STGM_CREATE,
            0L,
            0L,
            &pStrm);

    if (!OK(hr))
        return hr;
    
    if (OK(hr))
    {
        HANDLE hNative = GetNativeData();
        DWORD cbSize;
        
        if (hNative != NULL && (cbSize = (DWORD)GlobalSize(hNative)) > 0)
        {
            hr = pStrm->Write(&cbSize, sizeof(cbSize), NULL);
            if (OK(hr))
            {
                LPBYTE pNative = (LPBYTE)GlobalLock(hNative);
                if(pNative != NULL)
                {
                    hr = pStrm->Write(pNative, cbSize, NULL);
                    GlobalUnlock(hNative);
                }
            }
        }
        if (hNative)
            GlobalFree(hNative);
    }
    
    pStrm->Release();
    
#ifdef OLE2ONLY
    hr = pStg->CreateStream(szContentsStrm,
            STGM_SALL | STGM_CREATE,
            0L,
            0L,
            &pStrm);

    if (OK(hr))
    {
        // update the members that may have changed
        _header._sizel = _sizel;

        HANDLE hNative = GetNativeData();
        _header._dwNative = GlobalSize(hNative);
        hr = _header.Write(pStrm);
        if (OK(hr))
        {
            if(_header._dwNative > 0)
            {
                LPBYTE pNative = (LPBYTE)GlobalLock(hNative);
                if(pNative != NULL)
                {
                    hr = pStrm->Write(pNative, _header._dwNative, NULL);
                    GlobalUnlock(hNative);
                }
            }
        }
        GlobalFree(hNative);
        pStrm->Release();
    }
#endif    
    return hr;
}


#ifdef WE_SUPPORT_INPLACE

//+---------------------------------------------------------------
//
//  Member:     SRCtrl::RunningToInPlace
//
//  Synopsis:   Effects the running to inplace-active state transition
//
//  Returns:    SUCCESS if the object results in the in-place state
//
//---------------------------------------------------------------

HRESULT
SRCtrl::RunningToInPlace(void)
{
    return SrvrCtrl::RunningToInPlace();
}

//+---------------------------------------------------------------
//
//  Member:     SRCtrl::InPlaceToRunning
//
//  Synopsis:   Effects the inplace-active to running state transition
//
//  Returns:    SUCCESS in all but catastrophic circumstances
//
//---------------------------------------------------------------

HRESULT
SRCtrl::InPlaceToRunning(void)
{
    return SrvrCtrl::InPlaceToRunning();
}

//+---------------------------------------------------------------
//
//  Member:     SRCtrl::UIActiveToInPlace
//
//  Synopsis:   Effects the U.I. active to inplace-active state transition
//
//  Returns:    SUCCESS in all but catastrophic circumstances
//
//---------------------------------------------------------------

HRESULT
SRCtrl::UIActiveToInPlace(void)
{
    return SrvrCtrl::UIActiveToInPlace();
}

#endif // WE_SUPPORT_INPLACE


//+---------------------------------------------------------------
//
//  Member:     SRInPlace::ClassInit (static)
//
//  Synopsis:   Load any static resources
//
//  Arguments:  [pClass] -- an initialized ClassDescriptor
//
//  Returns:    TRUE iff window class sucesfully registered
//
//---------------------------------------------------------------

BOOL
SRInPlace::ClassInit(LPCLASSDESCRIPTOR pClass)
{
    HINSTANCE hinst = pClass->_hinst;

    return TRUE;
}

//+---------------------------------------------------------------
//
//  Member:     SRInPlace::Create (static)
//
//  Synopsis:   Create a new, fully initialize sub-object
//
//  Arguments:  [pSRCtrl] --  pointer to control we are a part of
//              [pClass] -- pointer to initialized class descriptor
//              [ppUnkCtrl] -- (out parameter) pObj's controlling unknown
//              [ppObj] -- (out parameter) the new sub-object
//
//  Returns:    NOERROR iff sucessful
//
//---------------------------------------------------------------

HRESULT
SRInPlace::Create( LPSRCTRL pSRCtrl,
        LPCLASSDESCRIPTOR pClass,
        LPUNKNOWN FAR* ppUnkCtrl,
        LPSRINPLACE FAR* ppObj)
{
    // set out parameters to NULL
    *ppUnkCtrl = NULL;
    *ppObj = NULL;

    // create an object
    HRESULT hr;
    LPSRINPLACE pObj;
    pObj = new SRInPlace((LPUNKNOWN)(LPOLEOBJECT)pSRCtrl);
    if (pObj == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        // initialize it
        if (OK(hr = pObj->Init(pSRCtrl, pClass)))
        {
            // return the object and its controlling unknown
            *ppUnkCtrl = &pObj->_PrivUnk;
            *ppObj = pObj;
        }
        else
        {
            pObj->_PrivUnk.Release();    //hari-kari
        }
    }
    if(OK(hr))
    {
        hr = NOERROR;
    }
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     SRInPlace::SRInPlace
//
//  Synopsis:   Construct a new IP sub-object
//
//  Arguments:  [pUnkOuter] -- Unknown to aggregate with
//
//---------------------------------------------------------------

#pragma warning(disable:4355)   // `this' argument to base-member init. list.
SRInPlace::SRInPlace(LPUNKNOWN pUnkOuter):
        _PrivUnk(this)  // controlling unknown holds a pointer to us
{
    _pUnkOuter = (pUnkOuter != NULL) ? pUnkOuter : (LPUNKNOWN)&_PrivUnk;
}
#pragma warning(default:4355)


//+---------------------------------------------------------------
//
//  Member:     SRInPlace::~SRInPlace
//
//  Synopsis:   Destroy this sub-object
//
//---------------------------------------------------------------

SRInPlace::~SRInPlace(void)
{
}

//+---------------------------------------------------------------
//
//  Member:     SRInPlace::Init
//
//  Synopsis:   Initialize sub-object
//
//  Arguments:  [pSRCtrl] --  pointer to control we are a part of
//              [pClass]  -- pointer to an initialized class descriptor
//
//  Returns:    NOERROR if sucessful
//
//---------------------------------------------------------------

HRESULT
SRInPlace::Init(LPSRCTRL pSRCtrl, LPCLASSDESCRIPTOR pClass)
{
    HRESULT hr = SrvrInPlace::Init(pClass, pSRCtrl);
    return hr;
}

IMPLEMENT_DELEGATING_IUNKNOWN(SRInPlace)

IMPLEMENT_PRIVATE_IUNKNOWN(SRInPlace)

//+---------------------------------------------------------------
//
//  Member:     SRInPlace::QueryInterface, public
//
//     OLE:     IUnkown
//
//---------------------------------------------------------------
STDMETHODIMP
SRInPlace::PrivateUnknown::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid,IID_IUnknown))
    {
        *ppv = (LPVOID)this;
    }
    else if (IsEqualIID(riid,IID_IOleInPlaceObject)
          || IsEqualIID(riid,IID_IOleWindow))
    {
        *ppv = (LPVOID)(LPOLEINPLACEOBJECT)_pSRInPlace;
    }
    else if (IsEqualIID(riid,IID_IOleInPlaceActiveObject))
    {
        *ppv = (LPVOID)(LPOLEINPLACEACTIVEOBJECT)_pSRInPlace;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    //
    // Important:  we must addref on the pointer that we are returning,
    // because that pointer is what will be released!
    //
    ((IUnknown FAR*) *ppv)->AddRef();
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:    SRInPlace::AttachWin
//
//  Synopsis:  Create our InPlace window
//
//  Arguments: [hwndParent] -- our container's hwnd
//
//  Returns:   hwnd of InPlace window, or NULL
//
//---------------------------------------------------------------
HWND
SRInPlace::AttachWin(HWND hwndParent)
{
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\soundrec\srecnew.h ===
/* (C) Copyright Microsoft Corporation 1992.  All Rights Reserved */

/* strings */

#define IDS_DEFAULT     200
#define IDS_MSPCM       201
#define IDS_MSADPCM     202
#define IDS_RBLOW       203
#define IDS_RBMED       204
#define IDS_RBHIGH      205
#define IDS_CUSTOM      206
#define IDS_STANDARD    207

/* Dialog Controls */

#define IDA_NEWCONFIG   100
#define IDPB_HELP       101
#define IDPB_DEFAULT    102
#define IDRB_HIGH       103
#define IDRB_MEDIUM     104
#define IDRB_LOW        105
#define IDRB_MONO       106
#define IDRB_STEREO     107
#define IDCB_FORMATTYPE 108
#define IDLB_ATTRIB     109
#define IDRB_CUSTOM     110
#define IDF_BOGUS       112
#define IDPB_CUSTOM     113

#define ID_ACMVER       114


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\soundrec\soundrec.h ===
/* (C) Copyright Microsoft Corporation 1991.  All Rights Reserved */
/* SoundRec.h
 */
/* Revision History.
   LaurieGr  7/Jan/91  Ported to WIN32 / WIN16 common code
   LaurieGr  16/Feb/94 Merged Daytona and Motown versions
*/

/* Set NT type debug flags */

#if DBG
# ifndef DEBUG
# define DEBUG
# endif
#endif

/* Enable Win95 UI code for Windows NT with the new shell */
#if WINVER >= 0x0400
#define CHICAGO
#endif

#include <stdlib.h>

#ifndef RC_INVOKED
#ifndef OLE1_REGRESS
#ifdef INCLUDE_OLESTUBS
#include "oleglue.h"
#endif
#else
#pragma message("OLE1 alert")
#include "server.h"
#endif
#endif

#define SIZEOF(x)       (sizeof(x)/sizeof(TCHAR))

#if DBG
extern void FAR PASCAL AssertSFL(
        LPSTR lpszClause,
        LPSTR lpszFileName,
        int nLine);
#define Assert(f) ((f)? (void)0 : AssertSFL(#f, __FILE__, __LINE__))
#else   // !DBG
#define Assert(x)
#endif // DBG

typedef BYTE * HPBYTE;     /* note a BYTE is NOT the same as a CHAR */
typedef BYTE * NPBYTE;     /* A CHAR can be TWO BYTES (UNICODE!!)   */


#define FMT_DEFAULT     0x0000
#define FMT_STEREO      0x0010
#define FMT_MONO        0x0000
#define FMT_16BIT       0x0008
#define FMT_8BIT        0x0000
#define FMT_RATE        0x0007      /* 1, 2, 4 */
#define FMT_11k         0x0001
#define FMT_22k         0x0002
#define FMT_44k         0x0004

//
// convertsion routines in wave.c
//
LONG PASCAL wfSamplesToBytes(WAVEFORMATEX* pwf, LONG lSamples);
LONG PASCAL wfBytesToSamples(WAVEFORMATEX* pwf, LONG lBytes);
LONG PASCAL wfSamplesToTime (WAVEFORMATEX* pwf, LONG lSamples);
LONG PASCAL wfTimeToSamples (WAVEFORMATEX* pwf, LONG lTime);

#define wfTimeToBytes(pwf, lTime)   wfSamplesToBytes(pwf, wfTimeToSamples(pwf, lTime))
#define wfBytesToTime(pwf, lBytes)  wfSamplesToTime(pwf, wfBytesToSamples(pwf, lBytes))

#define wfSamplesToSamples(pwf, lSamples)  wfBytesToSamples(pwf, wfSamplesToBytes(pwf, lSamples))
#define wfBytesToBytes(pwf, lBytes)        wfSamplesToBytes(pwf, wfBytesToSamples(pwf, lBytes))

//
// function to determine if a WAVEFORMATEX is a valid PCM format we support for
// editing and such.
//
BOOL PASCAL IsWaveFormatPCM(WAVEFORMATEX* pwf);

void PASCAL WaveFormatToString(LPWAVEFORMATEX lpwf, LPTSTR sz);
BOOL PASCAL CreateWaveFormat(LPWAVEFORMATEX lpwf, WORD fmt, UINT uiDeviceID);
BOOL PASCAL CreateDefaultWaveFormat(LPWAVEFORMATEX lpwf, UINT uDeviceID);

//
// used to set focus to a dialog control
//
#define SetDlgFocus(hwnd)   SendMessage(ghwndApp, WM_NEXTDLGCTL, (WPARAM)(hwnd), 1L)

#define FAKEITEMNAMEFORLINK

#define SZCODE const TCHAR

/* constants */
#define TIMER_MSEC              50              // msec. for display update
#define SCROLL_RANGE            10000           // scrollbar range
#define SCROLL_LINE_MSEC        100             // scrollbar arrow left/right
#define SCROLL_PAGE_MSEC        1000            // scrollbar page left/right

#define WM_USER_DESTROY         (WM_USER+10)
#define WM_USER_KILLSERVER      (WM_USER+11)
#define WM_USER_WAITPLAYEND (WM_USER+12)
#define WM_BADREG           (WM_USER+125)

#define MAX_WAVEHDRS            10
#define MAX_DELTASECONDS        350
#define MAX_MSECSPERBUFFER      10000

#define MIN_WAVEHDRS            2
#define MIN_DELTASECONDS        5
#define MIN_MSECSPERBUFFER      62

#define DEF_BUFFERDELTASECONDS      60
#define DEF_NUMASYNCWAVEHEADERS     10
#define DEF_MSECSPERASYNCBUFFER     250


/* colors */

#define RGB_PANEL           GetSysColor(COLOR_BTNFACE)   // main window background

#define RGB_STOP            GetSysColor(COLOR_BTNTEXT) // color of "Stop" status text
#define RGB_PLAY            GetSysColor(COLOR_BTNTEXT) // color of "Play" status text
#define RGB_RECORD          GetSysColor(COLOR_BTNTEXT) // color of "Record" status text

#define RGB_FGNFTEXT        GetSysColor(COLOR_BTNTEXT) // NoFlickerText foreground
#define RGB_BGNFTEXT        GetSysColor(COLOR_BTNFACE) // NoFlickerText background

#define RGB_FGWAVEDISP      RGB(  0, 255,   0)  // WaveDisplay foreground
#define RGB_BGWAVEDISP      RGB(  0,   0,   0)  // WaveDisplay background

#define RGB_DARKSHADOW      GetSysColor(COLOR_BTNSHADOW)     // dark 3-D shadow
#define RGB_LIGHTSHADOW     GetSysColor(COLOR_BTNHIGHLIGHT)  // light 3-D shadow

/* a window proc */
typedef LONG (FAR PASCAL * LPWNDPROC) (void);

/* globals from "SoundRec.c" */
extern TCHAR            chDecimal;
extern TCHAR            gachAppName[];  // 8-character name
extern TCHAR            gachAppTitle[]; // full name
extern TCHAR            gachHelpFile[]; // name of help file
extern TCHAR            gachHtmlHelpFile[]; // name of help file
extern TCHAR            gachDefFileExt[]; // 3-character file extension
extern HWND             ghwndApp;       // main application window
extern HMENU            ghmenuApp;      // main application menu
extern HANDLE           ghAccel;        // accelerators
extern HINSTANCE        ghInst;         // program instance handle
extern TCHAR            gachFileName[_MAX_PATH]; // cur. file name (or UNTITLED)
extern BOOL             gfLZero;        // leading zeros?
extern BOOL             gfIsRTL;        // no compile BIDI support
extern BOOL             gfDirty;        // file was modified and not saved?
                                        // -1 seems to mean "cannot save"
                                        // Damned funny value for a BOOL!!!!
extern BOOL             gfClipboard;    // current doc is in clipboard
extern HWND             ghwndWaveDisplay; // waveform display window handle
extern HWND             ghwndScroll;    // scroll bar control window handle
extern HWND             ghwndPlay;      // Play button window handle
extern HWND             ghwndStop;      // Stop button window handle
extern HWND             ghwndRecord;    // Record button window handle
extern HWND             ghwndForward;   // [>>] button
extern HWND             ghwndRewind;    // [<<] button

extern UINT         guiACMHlpMsg;   // ACM Help's message value

/* hack fix for the multiple sound card problem */
#define NEWPAUSE
#ifdef NEWPAUSE
extern BOOL         gfPaused;
extern BOOL         gfPausing;
extern HWAVE            ghPausedWave;
extern BOOL             gfWasPlaying;
extern BOOL             gfWasRecording;
#endif
#ifdef THRESHOLD
extern HWND             ghwndSkipStart; // [>N] button
extern HWND             ghwndSkipEnd;   // [>-] button
#endif // THRESHOLD

extern int              gidDefaultButton;// which button should have focus
extern HICON            ghiconApp;      // Application's icon
extern TCHAR             aszUntitled[];  // Untitled string resource
extern TCHAR             aszFilter[];    // File name filter
#ifdef FAKEITEMNAMEFORLINK
extern  TCHAR            aszFakeItemName[];      // Wave
#endif
extern TCHAR             aszPositionFormat[];
extern TCHAR         aszNoZeroPositionFormat[];

/* globals from "wave.c" */
extern DWORD            gcbWaveFormat;  // size of WAVEFORMAT
extern WAVEFORMATEX *   gpWaveFormat;   // format of WAVE file
extern LPTSTR           gpszInfo;
extern HPBYTE            gpWaveSamples;  // pointer to waveoform samples
extern LONG             glWaveSamples;  // number of samples total in buffer
extern LONG             glWaveSamplesValid; // number of samples that are valid
extern LONG             glWavePosition; // current wave position in samples
                                        // from start of buffer
extern LONG             glStartPlayRecPos; // pos. when play or record started
extern HWAVEOUT         ghWaveOut;      // wave-out device (if playing)
extern HWAVEIN          ghWaveIn;       // wave-out device (if recording)
extern DWORD            grgbStatusColor; // color of status text
extern HBRUSH           ghbrPanel;      // color of main window

extern BOOL             gfEmbeddedObject; // TRUE if editing embedded OLE object
extern BOOL             gfRunWithEmbeddingFlag; // TRUE if we are run with "-Embedding"

extern int              gfErrorBox;      // TRUE iff we do not want to display an
                                         // error box (e.g. because one is active)

//OLE2 stuff:
extern BOOL gfStandalone;               // CG
extern BOOL gfEmbedded;                 // CG
extern BOOL gfLinked;                   // CG
extern BOOL gfCloseAtEndOfPlay;         // jyg need I say more?

/* SRECNEW.C */
extern BOOL         gfInFileNew;    // are we doing a File.New op?

void FAR PASCAL LoadACM(void);
void FreeACM(void);

#include "srecids.h"

typedef enum {
        enumCancel,
        enumSaved,
        enumRevert
}       PROMPTRESULT;


/* prototypes from "SoundRec.c" */
INT_PTR CALLBACK SoundRecDlgProc(HWND hDlg, UINT wMsg,
        WPARAM wParam, LPARAM lParam);
BOOL ResolveIfLink(PTCHAR szFileName);

/* prototypes from "file.c" */
void FAR PASCAL BeginWaveEdit(void);
void FAR PASCAL EndWaveEdit(BOOL fDirty);
PROMPTRESULT FAR PASCAL PromptToSave(BOOL fMustClose, BOOL fSetForground);
void FAR PASCAL UpdateCaption(void);
BOOL FAR PASCAL FileNew(WORD fmt, BOOL fUpdateDisplay, BOOL fNewDlg);
BOOL FAR PASCAL FileOpen(LPCTSTR szFileName);
BOOL FAR PASCAL FileSave(BOOL fSaveAs);
BOOL FAR PASCAL FileRevert(void);
LPCTSTR FAR PASCAL FileName(LPCTSTR szPath);
MMRESULT ReadWaveFile(HMMIO hmmio, LPWAVEFORMATEX* ppWaveFormat,
    DWORD *pcbWaveFormat, LPBYTE * ppWaveSamples, DWORD *plWaveSamples,
    LPTSTR szFileName, BOOL fCacheRIFF);
BOOL FAR PASCAL WriteWaveFile(HMMIO hmmio, WAVEFORMATEX* pWaveFormat,
        UINT cbWaveFormat, HPBYTE pWaveSamples, LONG lWaveSamples);

/* prototypes from "errorbox.c" */
short FAR cdecl ErrorResBox(HWND hwnd, HANDLE hInst, UINT flags,
        UINT idAppName, UINT idErrorStr, ...);

/* prototypes from "edit.c" */
void FAR PASCAL InsertFile(BOOL fPaste);
void FAR PASCAL MixWithFile(BOOL fPaste);
void FAR PASCAL DeleteBefore(void);
void FAR PASCAL DeleteAfter(void);
void FAR PASCAL ChangeVolume(BOOL fIncrease);
void FAR PASCAL MakeFaster(void);
void FAR PASCAL MakeSlower(void);
void FAR PASCAL IncreasePitch(void);
void FAR PASCAL DecreasePitch(void);
void FAR PASCAL AddEcho(void);
#if defined(REVERB)
void FAR PASCAL AddReverb(void);
#endif //REVERB
void FAR PASCAL Reverse(void);

/* prototypes from "wave.c" */
BOOL FAR PASCAL AllocWaveBuffer(long lBytes, BOOL fErrorBox, BOOL fExact);
BOOL FAR PASCAL NewWave(WORD fmt,BOOL fNewDlg);
BOOL FAR PASCAL DestroyWave(void);
BOOL FAR PASCAL PlayWave(void);
BOOL FAR PASCAL RecordWave(void);
void FAR PASCAL WaveOutDone(HWAVEOUT hWaveOut, LPWAVEHDR pWaveHdr);
void FAR PASCAL WaveInData(HWAVEIN hWaveIn, LPWAVEHDR pWaveHdr);
void FAR PASCAL StopWave(void);
void FAR PASCAL SnapBack(void);
void FAR PASCAL UpdateDisplay(BOOL fStatusChanged);
void FAR PASCAL FinishPlay(void);
void FAR PASCAL SkipToStart(void);
void FAR PASCAL SkipToEnd(void);
void FAR PASCAL IncreaseThresh(void);
void FAR PASCAL DecreaseThresh(void);

/* prototypes from "init.c" */
BOOL PASCAL AppInit( HINSTANCE hInst, HINSTANCE hPrev);
BOOL PASCAL SoundDialogInit(HWND hwnd, int iCmdShow);
BOOL PASCAL GetIntlSpecs(void);

/* prototype from "wavedisp.c" */
INT_PTR CALLBACK WaveDisplayWndProc(HWND hwnd, UINT wMsg,
        WPARAM wParam, LPARAM lParam);

/* prototype from "nftext.c" */
INT_PTR CALLBACK NFTextWndProc(HWND hwnd, UINT wMsg,
        WPARAM wParam, LPARAM lParam);

/* prototype from "sframe.c" */
void FAR PASCAL DrawShadowFrame(HDC hdc, LPRECT prc);
INT_PTR CALLBACK SFrameWndProc(HWND hwnd, UINT wMsg,
        WPARAM wParam, LPARAM lParam);

/* prototype from "server.c" */
BOOL FAR PASCAL IsClipboardNative(void);

/* prototypes from "srecnew.c" */
BOOL FAR PASCAL NewSndDialog(HINSTANCE hInst, HWND hwndParent,
    PWAVEFORMATEX pwfxPrev, UINT cbPrev,
    PWAVEFORMATEX *ppWaveFormat, PUINT pcbWaveFormat);

/* start parameters (set in oleglue.c) */

typedef struct tStartParams {
    BOOL    fOpen;
    BOOL    fPlay;
    BOOL    fNew;
    BOOL    fClose;
    TCHAR   achOpenFilename[_MAX_PATH];
} StartParams;

extern StartParams gStartParams;

#ifdef DEBUG
    int __iDebugLevel;

    extern void FAR cdecl dprintfA(LPSTR, ...);
    extern void FAR cdecl dprintfW(LPWSTR, ...);
    
#ifdef UNICODE
    #define dprintf dprintfW
#else
    #define dprintf dprintfA
#endif

#if 0    
    #define DPF  if (__iDebugLevel >  0) dprintf
    #define DPF1 if (__iDebugLevel >= 1) dprintf
    #define DPF2 if (__iDebugLevel >= 2) dprintf
    #define DPF3 if (__iDebugLevel >= 3) dprintf
    #define DPF4 if (__iDebugLevel >= 4) dprintf
    #define CPF
#endif

#ifdef PPC    
    //
    // The below line crashes the PPC compiler for NT 3.51
    //
    #define DPF(a)    
#else
    #define DPF  if (0) ((int (*)(TCHAR *, ...)) 0)
#endif        
    #define DPF1 if (0) ((int (*)(TCHAR *, ...)) 0)
    #define DPF2 if (0) ((int (*)(TCHAR *, ...)) 0)
    #define DPF3 if (0) ((int (*)(TCHAR *, ...)) 0)
    #define DPF4 if (0) ((int (*)(TCHAR *, ...)) 0)

    #define CPF  if (0) ((int (*)(TCHAR *, ...)) 0)
#else
    
#ifdef PPC
    //
    // The below line crashes the PPC compiler for NT 3.51
    //
    #define DPF(a)
#else
    #define DPF  if (0) ((int (*)(TCHAR *, ...)) 0)
#endif    
    #define DPF1 if (0) ((int (*)(TCHAR *, ...)) 0)
    #define DPF2 if (0) ((int (*)(TCHAR *, ...)) 0)
    #define DPF3 if (0) ((int (*)(TCHAR *, ...)) 0)
    #define DPF4 if (0) ((int (*)(TCHAR *, ...)) 0)

    #define CPF  if (0) ((int (*)(TCHAR *, ...)) 0)
#endif //DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\soundrec\srfact.cxx ===
//+---------------------------------------------------------------------
//
//   File:       srfact.cxx
//
//   Contents:   Class Factory
//
//   Classes:    SRFactory
//
//------------------------------------------------------------------------

//#pragma warning(disable:4103)
#include <stdlib.h>

#include <windows.h>
#include <windowsx.h>
#include <commdlg.h>      // common dialog boxes

#include <ole2.h>
#include <o2base.hxx>     // the base classes and utilities

#include <initguid.h>
#include "srs.hxx"

SRFactory * gpSRFactory = NULL;
DWORD gdwRegisterClass = 0;

extern "C" BOOL
CreateSRClassFactory(HINSTANCE hinst,BOOL fEmbedded)
{
    BOOL fRet = FALSE;
    if(SRFactory::Create(hinst))
    {
        gpSRFactory->AddRef();
        if(fEmbedded)
        {
            DOUT(TEXT("SoundRec: Registering SRFactory\r\n"));

            HRESULT hr = CoRegisterClassObject(CLSID_SOUNDREC,
                    (LPUNKNOWN)(LPCLASSFACTORY)gpSRFactory,
                    CLSCTX_LOCAL_SERVER,
                    //REGCLS_MULTI_SEPARATE,
                    REGCLS_SINGLEUSE,
                    &gdwRegisterClass);
            if(OK(hr))
            {
                CoLockObjectExternal((LPUNKNOWN)(LPCLASSFACTORY)gpSRFactory,
                    TRUE, TRUE);
                fRet = TRUE;
            }
#if DBG
            else
            {
                TCHAR achBuffer[256];
                wsprintf(achBuffer,
                        TEXT("SoundRec: CoRegisterClassObject (%lx)\r\n"),
                        (long)hr);
                OutputDebugString(achBuffer);
            }
#endif
        }
        else
        {
            fRet = TRUE;
        }
    }

    return fRet;
}

extern "C" HRESULT
ReleaseSRClassFactory(void)
{
    HRESULT hr = NOERROR;
    if(gdwRegisterClass)
    {
#if DBG            
        OutputDebugString(TEXT("SoundRec: Revoking SRFactory\r\n"));
#endif
        CoLockObjectExternal((LPUNKNOWN)(LPCLASSFACTORY)gpSRFactory,
             FALSE, TRUE);
        hr = CoRevokeClassObject(gdwRegisterClass);
        gdwRegisterClass = 0;

        gpSRFactory->Release();
        gpSRFactory = NULL;
    }
    return hr;
}


BOOL
SRFactory::Create(HINSTANCE hinst)
{
    gpSRFactory = new SRFactory;
    //
    // initialize our classes
    //
    if (gpSRFactory == NULL
             || !gpSRFactory->Init(hinst)
             || !SRCtrl::ClassInit(gpSRFactory->_pClass)
             || !SRDV::ClassInit(gpSRFactory->_pClass)
             || !SRInPlace::ClassInit(gpSRFactory->_pClass))
    {
        return FALSE;
    }
    return TRUE;
}

//+---------------------------------------------------------------
//
//  Member:     SRFactory:::Init
//
//  Synopsis:   Initializes the class factory
//
//  Arguments:  [hinst] -- instance handle of the module with
//                         class descriptor resources
//
//  Returns:    TRUE iff the factory was successfully initialized
//
//----------------------------------------------------------------

BOOL
SRFactory::Init(HINSTANCE hinst)
{
    //
    // Register the standard OLE clipboard formats.
    // These are available in the OleClipFormat array.
    //
    RegisterOleClipFormats();
    
    if((_pClass = new ClassDescriptor) == NULL)
        return FALSE;
    
    BOOL fRet = _pClass->Init(hinst, 0); //IDS_CLASSID);

    //
    // Patch _pClass->_haccel with a resource reload
    // (for InPlace) due to mismatch between the base class
    // resource scheme and legacy code...
    //
    if(fRet)
    {
        if((_pClass->_haccel = LoadAccelerators(hinst, TEXT("SOUNDREC"))) == NULL)
            fRet = FALSE;
    }
    return fRet;
    
}

STDMETHODIMP
SRFactory::LockServer(BOOL fLock)
{
    return CoLockObjectExternal((LPUNKNOWN)gpSRFactory, fLock, TRUE);
}

//+---------------------------------------------------------------
//
//  Member:     SRFactory:::CreateInstance
//
//  Synopsis:   Member of IClassFactory interface
//
//----------------------------------------------------------------

STDMETHODIMP
SRFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID iid, LPVOID FAR* ppv)
{
#if DBG        
    OutputDebugString(TEXT("SRFactory::CreateInstance\r\n"));
#endif    

    *ppv = NULL;    //NULL output param
    //
    // create an object, then query for the appropriate interface
    //
    LPUNKNOWN pUnk;
    LPSRCTRL pTemp;
    HRESULT hr;
    if (OK(hr = SRCtrl::Create(pUnkOuter, _pClass, &pUnk, &pTemp)))
    {
        hr = pUnk->QueryInterface(iid, ppv);
        pUnk->Release();    // on failure this will release obj, otherwise
                            // it will ensure an object ref count of 1
    }
    return hr;
}


/*
 * for the creation of a moniker
 */
BOOL
CreateStandaloneObject(void)
{
    DOUT(TEXT("Soundrec CreateStandaloneObject\r\n"));

    //
    //Ensure a unique filename in gachLinkFilename so we can create valid
    //FileMonikers...
    //
    if(gachLinkFilename[0] == 0)
        BuildUniqueLinkName();

    BOOL fSuccess = FALSE;
    LPVOID pvUnk;
    HRESULT hr = gpSRFactory->CreateInstance(NULL, IID_IUnknown, (LPVOID FAR*)&pvUnk);
    if(hr == NOERROR)
    {
        //CoLockObjectExternal((LPUNKNOWN)(LPOLEOBJECT)gpCtrlThis, TRUE, TRUE);
        extern LPSRCTRL gpCtrlThis;
        gpCtrlThis->Lock();
        fSuccess = TRUE;
    }
    else
    {
        DOUT(TEXT("Soundrec CreateStandaloneObject FAILED!\r\n"));
        fSuccess = FALSE;
    }
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\soundrec\soundrec.c ===
/* (C) Copyright Microsoft Corporation 1991-1994.  All Rights Reserved */
/* SoundRec.c
 *
 * SoundRec main loop etc.
 * Revision History.
 * 4/2/91  LaurieGr (AKA LKG) Ported to WIN32 / WIN16 common code
 * 21/2/94 LaurieGr Merged Daytona and Motown versions
 *         LaurieGr Merged common button and trackbar code from StephenE
 */

#undef NOWH                     // Allow SetWindowsHook and WH_*
#include <windows.h>
#include <shellapi.h>
#include <shlobj.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <htmlhelp.h>

#ifdef USE_MMCNTRLS
#include "mmcntrls.h"
#else
#include <commctrl.h>
#include "buttons.h"
#endif

#include <mmreg.h>

#define INCLUDE_OLESTUBS
#include "soundrec.h"
#include "srecids.h"
#include "fixreg.h"
#include "reg.h"
#include "convert.h"
#include "helpids.h"

#include <stdarg.h>
#include <stdio.h>

/* globals */

BOOL            gfUserClose;            // user-driven shutdown
HWND            ghwndApp;               // main application window
HINSTANCE       ghInst;                 // program instance handle
TCHAR           gachFileName[_MAX_PATH];// current file name (or UNTITLED)
BOOL            gfDirty;                // file was modified and not saved?
BOOL            gfClipboard;            // we have data in clipboard
int             gfErrorBox;             // TRUE if we have a message box active
HICON           ghiconApp;              // app's icon
HWND            ghwndWaveDisplay;       // waveform display window handle
HWND            ghwndScroll;            // scroll bar control window handle
HWND            ghwndPlay;              // Play button window handle
HWND            ghwndStop;              // Stop button window handle
HWND            ghwndRecord;            // Record button window handle
#ifdef THRESHOLD
HWND            ghwndSkipStart;         // Needed to enable/disable...
HWND            ghwndSkipEnd;           // ...the skip butons
#endif //THRESHOLD
HWND            ghwndForward;           // [>>] button
HWND            ghwndRewind;            // [<<] button
BOOL            gfWasPlaying;           // was playing before scroll, fwd, etc.
BOOL            gfWasRecording;         // was recording before scroll etc.
BOOL            gfPaused;               // are we paused now?
BOOL            gfPausing;              // are we stopping into a paused state?
HWAVE           ghPausedWave;           // holder for the paused wave handle

int             gidDefaultButton;       // which button should have input focus
BOOL            gfEmbeddedObject;       // Are we editing an embedded object?
BOOL            gfRunWithEmbeddingFlag; // TRUE if we are run with "-Embedding"
BOOL            gfHideAfterPlaying;
BOOL            gfShowWhilePlaying;
BOOL            gfInUserDestroy = FALSE;
TCHAR           chDecimal = TEXT('.');
BOOL            gfLZero = 1;            // do we use leading zeros?
BOOL            gfIsRTL = 0;       // no compile BIDI
UINT            guiACMHlpMsg = 0;       // help message from ACM, none == 0

//Data used for supporting context menu help
BOOL   bF1InMenu=FALSE;					//If true F1 was pressed on a menu item.
UINT   currMenuItem=0;					//The current selected menu item if any.


BITMAPBTN       tbPlaybar[] = {
    { ID_REWINDBTN   - ID_BTN_BASE, ID_REWINDBTN, 0 },       /* index 0 */
    { ID_FORWARDBTN  - ID_BTN_BASE, ID_FORWARDBTN,0 },       /* index 1 */
    { ID_PLAYBTN     - ID_BTN_BASE, ID_PLAYBTN,   0 },       /* index 2 */
    { ID_STOPBTN     - ID_BTN_BASE, ID_STOPBTN,   0 },       /* index 3 */
    { ID_RECORDBTN   - ID_BTN_BASE, ID_RECORDBTN, 0 }        /* index 4 */
};

#include <msacmdlg.h>

#ifdef CHICAGO

/* these id's are part of the main windows help file */
#define IDH_AUDIO_CUST_ATTRIB   2403
#define IDH_AUDIO_CUST_FORMAT   2404
#define IDH_AUDIO_CUST_NAME 2405
#define IDH_AUDIO_CUST_REMOVE   2406
#define IDH_AUDIO_CUST_SAVEAS   2407

const DWORD aChooserHelpIds[] = {
    IDD_ACMFORMATCHOOSE_CMB_FORMAT,     IDH_AUDIO_CUST_ATTRIB,
    IDD_ACMFORMATCHOOSE_CMB_FORMATTAG,  IDH_AUDIO_CUST_FORMAT,
    IDD_ACMFORMATCHOOSE_CMB_CUSTOM,     IDH_AUDIO_CUST_NAME,
    IDD_ACMFORMATCHOOSE_BTN_DELNAME,    IDH_AUDIO_CUST_REMOVE,
    IDD_ACMFORMATCHOOSE_BTN_SETNAME,    IDH_AUDIO_CUST_SAVEAS,
    0, 0
};

UINT guChooserContextMenu = 0;
UINT guChooserContextHelp = 0;
#endif

/*
 * constants
 */
SZCODE          aszNULL[]       = TEXT("");
SZCODE          aszClassKey[]   = TEXT(".wav");
SZCODE          aszIntl[]       = TEXT("Intl");

/*
 * statics
 */
static HHOOK    hMsgHook;

/*
 * functions
 */
BOOL SoundRec_OnHScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos);
BOOL SoundRec_OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT *lpdis);
void SoundRec_ControlPanel(HINSTANCE hinst, HWND hwnd);
BOOL NEAR PASCAL FreeWaveHeaders(void);

/*
 * HelpMsgFilter - filter for F1 key in dialogs
 */
LRESULT CALLBACK
HelpMsgFilter(
    int         nCode,
    WPARAM      wParam,
    LPARAM      lParam)
{
    LPMSG       msg;
	    
    if (nCode >= 0){
	msg = (LPMSG)lParam;
	if ((msg->message == WM_KEYDOWN) && (LOWORD(msg->wParam) == VK_F1))
	{
		// testing for <0 tests MSB whether int is 16 or 32 bits
	    // MSB set means key is down

	    if (( GetAsyncKeyState(VK_SHIFT)
		| GetAsyncKeyState(VK_CONTROL)
		| GetAsyncKeyState(VK_MENU)) < 0 )
		    //
		    // do nothing
		    //
		    ;
	    else
	    {
			if(nCode == MSGF_MENU)
            {
				bF1InMenu = TRUE;
			    SendMessage(ghwndApp, WM_COMMAND, IDM_HELPTOPICS, 0L);
            }
	    }
	}
    }
    return CallNextHookEx(hMsgHook, nCode, wParam, lParam);
}

/* WinMain(hInst, hPrev, lpszCmdLine, cmdShow)
 *
 * The main procedure for the App.  After initializing, it just goes
 * into a message-processing loop until it gets a WM_QUIT message
 * (meaning the app was closed).
 */
int WINAPI                      // returns exit code specified in WM_QUIT
WinMain(
    HINSTANCE hInst,            // instance handle of current instance
    HINSTANCE hPrev,            // instance handle of previous instance
    LPSTR lpszCmdLine,          // null-terminated command line
    int iCmdShow)               // how window should be initially displayed
{
    HWND            hDlg;
    MSG             rMsg;

    //
    // save instance handle for dialog boxes
    //
    ghInst = hInst;

    DPF(TEXT("AppInit ...\n"));
    //
    // call initialization procedure
    //
    if (!AppInit(hInst, hPrev))
    {
	DPF(TEXT("AppInit failed\n"));
	return FALSE;
    }

    //
    // setup the message filter to handle grabbing F1 for this task
    //
    hMsgHook = SetWindowsHookEx(WH_MSGFILTER, HelpMsgFilter, ghInst, GetCurrentThreadId());

    //
    // display "SoundRec" dialog box
    //
    hDlg = CreateDialogParam( ghInst
			    , MAKEINTRESOURCE(IDD_SOUNDRECBOX)
			    , NULL
			    , SoundRecDlgProc
			    , iCmdShow );
    if (hDlg)
    {
	//
	// Polling messages from event queue
	//
	while (GetMessage(&rMsg, NULL, 0, 0))
	{
	    if (ghwndApp) {
		if (TranslateAccelerator(ghwndApp, ghAccel, &rMsg))
		    continue;

		if (IsDialogMessage(ghwndApp,&rMsg))
		    continue;
	    }

	    TranslateMessage(&rMsg);
	    DispatchMessage(&rMsg);
	}
    }

    //
    // free the current document
    //
    DestroyWave();

    //
    // if the message hook was installed, remove it and free
    // up our proc instance for it.
    //
    if (hMsgHook)
    {
	UnhookWindowsHookEx(hMsgHook);
    }

    //
    // random cleanup
    //
    DeleteObject(ghbrPanel);

    if(gfOleInitialized)
    {
	FlushOleClipboard();
	OleUninitialize();
	gfOleInitialized = FALSE;
    }


    return TRUE;
}

/*
 * Process file drop/drag options.
 */
void SoundRec_OnDropFiles(
    HWND        hwnd,
    HDROP       hdrop)
{
    TCHAR    szPath[_MAX_PATH];

    if (DragQueryFile(hdrop, (UINT)(-1), NULL, 0) > 0)
    {
	//
	// If user dragged/dropped a file regardless of keys pressed
	// at the time, open the first selected file from file
	// manager.
	//
	DragQueryFile(hdrop,0,szPath,SIZEOF(szPath));
	SetActiveWindow(hwnd);

	ResolveIfLink(szPath);

	if (FileOpen(szPath))
	{
	    gfHideAfterPlaying = FALSE;
	    //
	    // This is a bit hacked.  The Ole caption should just never change.
	    //
	    if (gfEmbeddedObject && !gfLinked)
	    {
		LPTSTR      lpszObj, lpszApp;
		extern void SetOleCaption(LPTSTR lpsz);

		DoOleSave();
		AdviseSaved();

		OleObjGetHostNames(&lpszApp,&lpszObj);
		lpszObj = (LPTSTR)FileName((LPCTSTR)lpszObj);
		SetOleCaption(lpszObj);
	    }
	    PostMessage(ghwndApp, WM_COMMAND, ID_PLAYBTN, 0L);
	}
    }
    DragFinish(hdrop);     // Delete structure alocated
}

/* Pause(BOOL fBeginPause)
 *
 * If <fBeginPause>, then if user is playing or recording do a StopWave().
 * The next call to Pause() should have <fBeginPause> be FALSE -- this will
 * cause the playing or recording to be resumed (possibly at a new position
 * if <glWavePosition> changed.
 */
void
Pause(BOOL fBeginPause)
{
    if (fBeginPause) {
	if (ghWaveOut != NULL) {
#ifdef NEWPAUSE
	    gfPausing = TRUE;
	    gfPaused = FALSE;
	    ghPausedWave = (HWAVE)ghWaveOut;
#endif
	    gfWasPlaying = TRUE;

	    // User intentionally stopped us.  Don't go away.
	    if (gfCloseAtEndOfPlay && IsWindowVisible(ghwndApp))
		gfCloseAtEndOfPlay = FALSE;

	    StopWave();
	}
	else if (ghWaveIn != NULL) {
#ifdef NEWPAUSE
	    gfPausing = TRUE;
	    gfPaused = FALSE;
	    ghPausedWave = (HWAVE)ghWaveIn;
#endif
	    gfWasRecording = TRUE;

	    // User intentionally stopped us.  Don't go away.
	    if (gfCloseAtEndOfPlay && IsWindowVisible(ghwndApp))
		gfCloseAtEndOfPlay = FALSE;

	    StopWave();
	}
    }
    else {
	if (gfWasPlaying) {
	    gfWasPlaying = FALSE;
	    PlayWave();
#ifdef NEWPAUSE
	    gfPausing = FALSE;
	    gfPaused = FALSE;
#endif
	}
	else if (gfWasRecording) {
	    gfWasRecording = FALSE;
	    RecordWave();
#ifdef NEWPAUSE
	    gfPausing = FALSE;
	    gfPaused = FALSE;
#endif
	}
    }
}

void DoHtmlHelp()
{
	//note, using ANSI version of function because UNICODE is foobar in NT5 builds
    char chDst[MAX_PATH];
    WideCharToMultiByte(CP_ACP, 0, gachHtmlHelpFile, 
									    -1, chDst, MAX_PATH, NULL, NULL); 
	HtmlHelpA(GetDesktopWindow(), chDst, HH_DISPLAY_TOPIC, 0L);
}
	 

void ProcessHelp(HWND hwnd)
{
	static TCHAR HelpFile[] = TEXT("SOUNDREC.HLP");
	
	//Handle context menu help
	if(bF1InMenu) 
	{
		switch(currMenuItem)
		{
		case IDM_NEW:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_FILE_NEW);
		break;
		case IDM_OPEN:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_FILE_OPEN);
		break;
		case IDM_SAVE:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_FILE_SAVE);
		break;
		case IDM_SAVEAS:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_FILE_SAVE_AS);
		break;
		case IDM_REVERT:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_FILE_REVERT);
		break;
		case IDM_PROPERTIES:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_FILE_PROPERTIES);
		break;
		case IDM_EXIT:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_FILE_EXIT);
		break;
		case IDM_COPY:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_EDIT_COPY);
		break;
		case IDM_PASTE_INSERT:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_EDIT_PASTE_INSERT);
		break;
		case IDM_PASTE_MIX:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_EDIT_PASTE_MIX);
		break;
		case IDM_INSERTFILE:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_EDIT_INSERT_FILE);
		break;
		case IDM_MIXWITHFILE:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_EDIT_MIX_WITH_FILE);
		break;
		case IDM_DELETEBEFORE:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_EDIT_DELETE_BEFORE_CURRENT_POSITION);
		break;
		case IDM_DELETEAFTER:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_EDIT_DELETE_AFTER_CURRENT_POSITION);
		break;
		case IDM_VOLUME:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_EDIT_AUDIO_PROPERTIES);
		break;
		case IDM_INCREASEVOLUME:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_EFFECTS_INCREASE_VOLUME);
		break;
		case IDM_DECREASEVOLUME:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_EFFECTS_DECREASE_VOLUME);
		break;
		case IDM_MAKEFASTER:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_EFFECTS_INCREASE_SPEED);
		break;
		case IDM_MAKESLOWER:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_EFFECTS_DECREASE_SPEED);
		break;
		case IDM_ADDECHO:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_EFFECTS_ADD_ECHO);
		break;
		case IDM_REVERSE:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_EFFECTS_REVERSE);
		break;
		case IDM_HELPTOPICS:
		case IDM_INDEX:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_HELP_HELP_TOPICS);
		break;
		case IDM_ABOUT:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_HELP_ABOUT);
		break;
		default://In the default case just display the HTML Help.
			DoHtmlHelp();
		}
		bF1InMenu = FALSE; //This flag will be set again if F1 is pressed in a menu.
	}
	else
		DoHtmlHelp();
}

/*
 * SoundRec_OnCommand
 */
BOOL
SoundRec_OnCommand(
    HWND            hwnd,
    int             id,
    HWND            hwndCtl,
    UINT            codeNotify)
{

    if (gfHideAfterPlaying && id != ID_PLAYBTN)
    {
	DPF(TEXT("Resetting HideAfterPlaying\n"));
	gfHideAfterPlaying = FALSE;
    }

    switch (id)
    {
	case IDM_NEW:

	    if (PromptToSave(FALSE, FALSE) == enumCancel)
		return FALSE;
#ifdef CHICAGO
	    if (FileNew(FMT_DEFAULT,TRUE,FALSE))
#else
	    if (FileNew(FMT_DEFAULT,TRUE,TRUE))
#endif
	    {
		/* return to being a standalone */
		gfHideAfterPlaying = FALSE;
	    }

	    break;

	case IDM_OPEN:

	    if (FileOpen(NULL)) {
		/* return to being a standalone */
		gfHideAfterPlaying = FALSE;
	    }

	    if (IsWindowEnabled(ghwndPlay))
	    {
		SetDlgFocus(ghwndPlay);
	    }
	    break;

	case IDM_SAVE:      // also OLE UPDATE
	    if (!gfEmbeddedObject || gfLinked)
	    {
		if (!FileSave(FALSE))
		    break;
	    }
	    else
	    {
		DoOleSave();
		gfDirty = FALSE;
	    }
	    break;

	case IDM_SAVEAS:
	    if (FileSave(TRUE))
	    {
		/* return to being a standalone */
		gfHideAfterPlaying = FALSE;
	    }
	    break;

	case IDM_REVERT:
	    UpdateWindow(hwnd);

	    // User intentionally stopped us.  Don't go away.
	    if (gfCloseAtEndOfPlay && IsWindowVisible(ghwndApp))
		gfCloseAtEndOfPlay = FALSE;

	    StopWave();
	    SnapBack();

	    if (FileRevert())
	    {
		/* return to being a standalone */
		gfHideAfterPlaying = FALSE;
	    }
	    break;

	case IDM_EXIT:
	    PostMessage(hwnd, WM_CLOSE, 0, 0L);
	    return TRUE;

	case IDCANCEL:

	    // User intentionally stopped us.  Don't go away.
	    if (gfCloseAtEndOfPlay && IsWindowVisible(ghwndApp))
		gfCloseAtEndOfPlay = FALSE;

	    StopWave();
	    SnapBack();
	    break;

	case IDM_COPY:
	    if (!gfOleInitialized)
	    {
		InitializeOle(ghInst);
		if (gfStandalone && gfOleInitialized)
		    CreateStandaloneObject();
	    }
	    TransferToClipboard();
	    gfClipboard = TRUE;
	    break;

	case IDM_PASTE_INSERT:
	case IDM_INSERTFILE:
	    UpdateWindow(hwnd);

	    // User intentionally stopped us.  Don't go away.
	    if (gfCloseAtEndOfPlay && IsWindowVisible(ghwndApp))
		gfCloseAtEndOfPlay = FALSE;

	    StopWave();
	    SnapBack();
	    InsertFile(id == IDM_PASTE_INSERT);
	    break;

	case IDM_PASTE_MIX:
	case IDM_MIXWITHFILE:
	    UpdateWindow(hwnd);

	    // User intentionally stopped us.  Don't go away.
	    if (gfCloseAtEndOfPlay && IsWindowVisible(ghwndApp))
		gfCloseAtEndOfPlay = FALSE;

	    StopWave();
	    SnapBack();
	    MixWithFile(id == IDM_PASTE_MIX);
	    break;

	case IDM_DELETEBEFORE:
	    UpdateWindow(hwnd);
	    Pause(TRUE);
	    DeleteBefore();
	    Pause(FALSE);
	    break;

	case IDM_DELETE:
	    if (glWaveSamplesValid == 0L)
		return 0L;

	    glWavePosition = 0L;

	    // fall through to delete after.

	case IDM_DELETEAFTER:
	    UpdateWindow(hwnd);
	    Pause(TRUE);
	    DeleteAfter();
	    Pause(FALSE);
	    break;

#ifdef THRESHOLD
// Threshold was an experiment to allow facilities to skip to the start
// of the sound or to the end of the sound.  The trouble was that it
// required the ability to detect silence and different sound cards in
// different machines with different background noises gave quite different
// ideas of what counted as silence.  Manual control over the threshold level
// did sort-of work but was just too complicated.  It really wanted to be
// intuitive or intelligent (or both).
	case IDM_SKIPTOSTART:
	case ID_SKIPSTARTBTN:
	    UpdateWindow(hwnd);
	    Pause(TRUE);
	    SkipToStart();
	    Pause(FALSE);
	    break;

	case ID_SKIPENDBTN:
	case IDM_SKIPTOEND:
	    UpdateWindow(hwnd);
	    Pause(TRUE);
	    SkipToEnd();
	    Pause(FALSE);
	    break;

	case IDM_INCREASETHRESH:
	    IncreaseThresh();
	    break;

	case IDM_DECREASETHRESH:
	    DecreaseThresh();
	    break;
#endif //THRESHOLD

	case IDM_INCREASEVOLUME:
	    UpdateWindow(hwnd);
	    Pause(TRUE);
	    ChangeVolume(TRUE);
	    Pause(FALSE);
	    break;

	case IDM_DECREASEVOLUME:
	    UpdateWindow(hwnd);
	    Pause(TRUE);
	    ChangeVolume(FALSE);
	    Pause(FALSE);
	    break;

	case IDM_MAKEFASTER:
	    UpdateWindow(hwnd);
	    Pause(TRUE);
	    MakeFaster();
	    Pause(FALSE);
	    break;

	case IDM_MAKESLOWER:
	    UpdateWindow(hwnd);
	    Pause(TRUE);
	    MakeSlower();
	    Pause(FALSE);
	    break;

	case IDM_ADDECHO:
	    UpdateWindow(hwnd);
	    Pause(TRUE);
	    AddEcho();
	    Pause(FALSE);
	    break;

#if defined(REVERB)
	case IDM_ADDREVERB:
	    UpdateWindow(hwnd);
	    Pause(TRUE);
	    AddReverb();
	    Pause(FALSE);
	    break;
#endif //REVERB

	case IDM_REVERSE:
	    UpdateWindow(hwnd);
	    Pause(TRUE);
	    Reverse();
	    Pause(FALSE);
	    break;

	case IDM_VOLUME:
	    SoundRec_ControlPanel(ghInst, hwnd);
	    break;

	case IDM_PROPERTIES:
	{
	    WAVEDOC wd;
	    SGLOBALS sg;
	    DWORD dw;

	    wd.pwfx     = gpWaveFormat;
	    wd.pbdata   = gpWaveSamples;
	    wd.cbdata   = wfSamplesToBytes(gpWaveFormat, glWaveSamplesValid);
	    wd.fChanged = FALSE;
	    wd.pszFileName  = (LPTSTR)FileName(gachFileName);
	    // 
	    // Need to extract these from the file
	    //
	    wd.hIcon    = NULL;
	    wd.pszCopyright = gpszInfo;
	    wd.lpv      = &sg;

	    //
	    // modify globals w/o returning from prop dialog
	    //
	    sg.ppwfx    = &gpWaveFormat;
	    sg.pcbwfx   = &gcbWaveFormat;
	    sg.pcbdata  = &dw;
	    sg.ppbdata  = &gpWaveSamples;
	    sg.plSamplesValid = &glWaveSamplesValid;
	    sg.plSamples = &glWaveSamples;
	    sg.plWavePosition = &dw;

	    SoundRec_Properties(hwnd, ghInst, &wd);
	    break;
	}

#ifndef CHICAGO
	case IDM_INDEX:
	    WinHelp(hwnd, gachHelpFile, HELP_INDEX, 0L);
	    break;

	case IDM_SEARCH:
	    WinHelp(hwnd, gachHelpFile, HELP_PARTIALKEY,
		    (DWORD)(LPTSTR)aszNULL);
	    break;
#else
	case IDM_HELPTOPICS:
		ProcessHelp(hwnd);
       break;
#endif

	case IDM_USINGHELP:
	    WinHelp(hwnd, (LPTSTR)NULL, HELP_HELPONHELP, 0L);
	    break;



	case IDM_ABOUT:
	{
	    LPTSTR lpAbout = NULL;
	    lpAbout = SoundRec_GetFormatName(gpWaveFormat);
	    ShellAbout(hwnd,
		       gachAppTitle,
		       lpAbout,
		       (HICON)SendMessage(hwnd, WM_QUERYDRAGICON, 0, 0L));
	    //                , ghiconApp
	    if (lpAbout)
		GlobalFreePtr(lpAbout);
	    break;
	}

	case ID_REWINDBTN:
#if 1
	    //Related to BombayBug 1609
	    Pause(TRUE);
	    glWavePosition = 0L;
	    Pause(FALSE);
	    UpdateDisplay(FALSE);
#else
	    //Behave as if the user pressed the 'Home' key
	    //Call the handler directly
	    SoundRec_OnHScroll(hwnd,ghwndScroll,SB_TOP,0);
#endif
	    break;

	case ID_PLAYBTN:
	    // checks for empty file moved to PlayWave in wave.c
	    // if at end of file, go back to beginning.
	    if (glWavePosition == glWaveSamplesValid)
		glWavePosition = 0;

	    PlayWave();
	    break;

	case ID_STOPBTN:
	    // User intentionally stopped us.  Don't go away.
	    if (gfCloseAtEndOfPlay && IsWindowVisible(ghwndApp))
		gfCloseAtEndOfPlay = FALSE;

	    StopWave();

//       I added this update because StopWave doesn't call it and
//       if you hit stop too quickly, the buttons aren't updated
//       Should StopWave() be calling UpdateDisplay()?

	    UpdateDisplay(TRUE);
	    SnapBack();
	    break;

	case ID_RECORDBTN:
	    /* Never let us be forced to quit after recording. */
	    gfHideAfterPlaying = FALSE;
	    RecordWave();
	    break;

	case ID_FORWARDBTN:
#if 1
	    //Bombay bug 1610
	    //Behave as if the user pressed the 'End' key
	    Pause(TRUE);
	    glWavePosition = glWaveSamplesValid;
	    Pause(FALSE);
	    UpdateDisplay(FALSE);
#else
	    //Call the handler directly
	    SoundRec_OnHScroll(hwnd,ghwndScroll,SB_BOTTOM,0);
#endif
	    break;

	default:
	    return FALSE;
    }
    return TRUE;
} /* SoundRec_OnCommand */


/*
 * handle WM_INIT from SoundRecDlgProc
 */
void
SoundRec_OnInitMenu(HWND hwnd, HMENU hMenu)
{
    BOOL    fUntitled;      // file is untitled?
    UINT    mf;

    //
    // see if we can insert/mix into this file.
    //
    mf = (glWaveSamplesValid == 0 || IsWaveFormatPCM(gpWaveFormat))
	 ? MF_ENABLED : MF_GRAYED;

    EnableMenuItem(hMenu, IDM_INSERTFILE  , mf);
    EnableMenuItem(hMenu, IDM_MIXWITHFILE , mf);

    //
    // see if any CF_WAVE data is in the clipboard
    //
    mf = ( (mf == MF_ENABLED)
	 && IsClipboardFormatAvailable(CF_WAVE) //DOWECARE (|| IsClipboardNative())
	 ) ? MF_ENABLED : MF_GRAYED;

    EnableMenuItem(hMenu, IDM_PASTE_INSERT, mf);
    EnableMenuItem(hMenu, IDM_PASTE_MIX   , mf);

    //
    //  see if we can delete before or after the current position.
    //
    EnableMenuItem(hMenu, IDM_DELETEBEFORE, glWavePosition > 0 ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hMenu, IDM_DELETEAFTER,  (glWaveSamplesValid-glWavePosition) > 0 ? MF_ENABLED : MF_GRAYED);

    //
    // see if we can do editing operations on the file.
    //
    mf = IsWaveFormatPCM(gpWaveFormat) ? MF_ENABLED : MF_GRAYED;

    EnableMenuItem(hMenu, IDM_INCREASEVOLUME , mf);
    EnableMenuItem(hMenu, IDM_DECREASEVOLUME , mf);
    EnableMenuItem(hMenu, IDM_MAKEFASTER     , mf);
    EnableMenuItem(hMenu, IDM_MAKESLOWER     , mf);
    EnableMenuItem(hMenu, IDM_ADDECHO        , mf);
    EnableMenuItem(hMenu, IDM_REVERSE        , mf);

    /* enable "Revert..." if the file was opened or saved
     * (not created using "New") and is currently dirty
     * and we're not using an embedded object
    */
    fUntitled = (lstrcmp(gachFileName, aszUntitled) == 0);
    EnableMenuItem( hMenu,
		    IDM_REVERT,
		    (!fUntitled && gfDirty && !gfEmbeddedObject)
			    ? MF_ENABLED : MF_GRAYED);

    if (gfHideAfterPlaying) {
	DPF(TEXT("Resetting HideAfterPlaying"));
	gfHideAfterPlaying = FALSE;
    }

} /* SoundRec_OnInitMenu() */

/*
 * Handle WM_HSCROLL from SoundRecDlgProc
 * */
BOOL
SoundRec_OnHScroll(
    HWND        hwnd,
    HWND        hwndCtl,
    UINT        code,
    int         pos)
{
    BOOL    fFineControl;
    long    lNewPosition;   // new position in wave buffer
    LONG    l;

    LONG    lBlockInc;
    LONG    lInc;

    fFineControl = (0 > GetKeyState(VK_SHIFT));

    if (gfHideAfterPlaying) {
	DPF(TEXT("Resetting HideAfterPlaying"));
	gfHideAfterPlaying = FALSE;
    }

    lBlockInc = wfBytesToSamples(gpWaveFormat,gpWaveFormat->nBlockAlign);

    switch (code)
    {
	case SB_LINEUP:         // left-arrow
	    // This is a mess.  NT implemented SHIFT and Motown implemented CTRL
	    // To do about the same thing!!
	    if (fFineControl)
		lNewPosition = glWavePosition - 1;
	    else {
		l = (GetKeyState(VK_CONTROL) < 0) ?
			(SCROLL_LINE_MSEC/10) : SCROLL_LINE_MSEC;

		lNewPosition = glWavePosition -
		    MulDiv(l, (long) gpWaveFormat->nSamplesPerSec, 1000L);
	    }
	    break;

	case SB_PAGEUP:         // left-page
	    // NEEDS SOMETHING SENSIBLE !!! ???
	    if (fFineControl)
		lNewPosition = glWavePosition - 10;
	    else
		lNewPosition = glWavePosition -
		    MulDiv((long) SCROLL_PAGE_MSEC,
		      (long) gpWaveFormat->nSamplesPerSec, 1000L);
	    break;

	case SB_LINEDOWN:       // right-arrow
	    if (fFineControl)
		lNewPosition = glWavePosition + 1;
	    else {
		l = (GetKeyState(VK_CONTROL) & 0x8000) ?
			(SCROLL_LINE_MSEC/10) : SCROLL_LINE_MSEC;
		lInc = MulDiv(l, (long) gpWaveFormat->nSamplesPerSec, 1000L);
		lInc = (lInc < lBlockInc)?lBlockInc:lInc;
		lNewPosition = glWavePosition + lInc;
	    }
	    break;

	case SB_PAGEDOWN:       // right-page
	    if (fFineControl)
		lNewPosition = glWavePosition + 10;
	    else {
		lInc = MulDiv((long) SCROLL_PAGE_MSEC,
			  (long) gpWaveFormat->nSamplesPerSec, 1000L);
		lInc = (lInc < lBlockInc)?lBlockInc:lInc;
		lNewPosition = glWavePosition + lInc;
	    }
	    break;

	case SB_THUMBTRACK:     // thumb has been positioned
	case SB_THUMBPOSITION:  // thumb has been positioned
	    lNewPosition = MulDiv(glWaveSamplesValid, pos, SCROLL_RANGE);
	    break;

	case SB_TOP:            // Home
	    lNewPosition = 0L;
	    break;

	case SB_BOTTOM:         // End
	    lNewPosition = glWaveSamplesValid;
	    break;

	case SB_ENDSCROLL:      // user released mouse button
	    /* resume playing, if necessary */
	    Pause(FALSE);
	    return TRUE;

	default:
	    return TRUE;

    }

    //
    // snap position to nBlockAlign
    //
    if (lNewPosition != glWaveSamplesValid)
	lNewPosition = wfSamplesToSamples(gpWaveFormat,lNewPosition);

    if (lNewPosition < 0)
	lNewPosition = 0;
    if (lNewPosition > glWaveSamplesValid)
	lNewPosition = glWaveSamplesValid;

    /* if user is playing or recording, pause until scrolling
     * is complete
     */
    Pause(TRUE);

    glWavePosition = lNewPosition;
    UpdateDisplay(FALSE);
    return TRUE;
} /* SoundRec_OnHScroll() */


/*
 * WM_SYSCOLORCHANGE needs to be send to all child windows (esp. trackbars)
 */
void SoundRec_PropagateMessage(
    HWND        hwnd,
    UINT        uMessage,
    WPARAM      wParam,
    LPARAM      lParam)
{
    HWND hwndChild;

    for (hwndChild = GetWindow(hwnd, GW_CHILD); hwndChild != NULL;
    hwndChild = GetWindow(hwndChild, GW_HWNDNEXT))
    {
	SendMessage(hwndChild, uMessage, wParam, lParam);
    }
}


/* SoundRecDlgProc(hwnd, wMsg, wParam, lParam)
 *
 * This function handles messages belonging to the main window dialog box.
 */
INT_PTR CALLBACK
SoundRecDlgProc(
    HWND            hwnd,
    UINT            wMsg,
    WPARAM          wParam,
    LPARAM          lParam)
{

    switch (wMsg)
    {

	case WM_BADREG:
	    //
	    // Bad registry entries detected.  Clean it up.
	    //
	    FixReg(hwnd);
	    return TRUE;

	case WM_COMMAND:
	    return HANDLE_WM_COMMAND( hwnd, wParam, lParam
				      , SoundRec_OnCommand );

	case WM_INITDIALOG:
	    //
	    // Start async registry check.
	    //
	    if (!IgnoreRegCheck())
		BackgroundRegCheck(hwnd);
	    //
	    // restore window position
	    //
	    SoundRec_GetSetRegistryRect(hwnd, SGSRR_GET);
	    return SoundDialogInit(hwnd, (int)lParam);

	case WM_SIZE:
	    return FALSE;   // let dialog manager do whatever else it wants

	case WM_WININICHANGE:
	    if (!lParam || !lstrcmpi((LPTSTR)lParam, aszIntl))
		if (GetIntlSpecs())
		    UpdateDisplay(TRUE);

	    return (TRUE);

	case WM_INITMENU:
	    HANDLE_WM_INITMENU(hwnd, wParam, lParam, SoundRec_OnInitMenu);
	    return (TRUE);

	case WM_PASTE:
	    UpdateWindow(hwnd);

	    // User intentionally stopped us.  Don't go away.
	    if (gfCloseAtEndOfPlay && IsWindowVisible(ghwndApp))
		gfCloseAtEndOfPlay = FALSE;

	    StopWave();
	    SnapBack();
	    InsertFile(TRUE);
	    break;

	case WM_DRAWITEM:
	    return HANDLE_WM_DRAWITEM( hwnd, wParam, lParam, SoundRec_OnDrawItem );

	case WM_NOTIFY:
	{
	    LPNMHDR         pnmhdr;
	    pnmhdr = (LPNMHDR)lParam;

	    //
	    // tooltips notifications
	    //
	    switch (pnmhdr->code)
	    {
		case TTN_NEEDTEXT:
		{
		    LPTOOLTIPTEXT       lpTt;
		    lpTt = (LPTOOLTIPTEXT)lParam;

		    LoadString( ghInst, (UINT)lpTt->hdr.idFrom, lpTt->szText
				, SIZEOF(lpTt->szText) );
		    break;
		}
		default:
		    break;
	    }
	    break;
	}

	case WM_HSCROLL:
	    HANDLE_WM_HSCROLL(hwnd, wParam, lParam, SoundRec_OnHScroll);
	    return (TRUE);

	case WM_SYSCOMMAND:
	    if (gfHideAfterPlaying)
	    {
		DPF(TEXT("Resetting HideAfterPlaying"));
		gfHideAfterPlaying = FALSE;
	    }

	    switch (wParam & 0xFFF0)
	    {
		case SC_CLOSE:
		    PostMessage(hwnd, WM_CLOSE, 0, 0L);
		    return TRUE;
	    }
	    break;

	case WM_QUERYENDSESSION:
	    if (PromptToSave(FALSE, TRUE) == enumCancel)
		return TRUE;

	    SoundRec_GetSetRegistryRect(hwnd, SGSRR_SET);
	   #if 0 // this is bogus if someone else cancels the shutdown!
	    ShowWindow(hwnd, SW_HIDE);
	   #endif
	    return FALSE;


	case WM_SYSCOLORCHANGE:
	    if (ghbrPanel)
		DeleteObject(ghbrPanel);

	    ghbrPanel = CreateSolidBrush(RGB_PANEL);
	    SoundRec_PropagateMessage(hwnd, wMsg, wParam, lParam);
	    break;

	case WM_ERASEBKGND:
	{
	    RECT            rcClient;       // client rectangle
	    GetClientRect(hwnd, &rcClient);
	    FillRect((HDC)wParam, &rcClient, ghbrPanel);
	    return TRUE;
	}

	case MM_WOM_DONE:
	    WaveOutDone((HWAVEOUT)wParam, (LPWAVEHDR) lParam);
	    return TRUE;

	case MM_WIM_DATA:
	    WaveInData((HWAVEIN)wParam, (LPWAVEHDR) lParam);
	    return TRUE;

	case WM_TIMER:
	    //
	    //  timer message is only used for SYNCRONOUS drivers
	    //
	    UpdateDisplay(FALSE);
	    return TRUE;

	case WM_MENUSELECT:
		//Keep track of which menu bar item is currently popped up.
		//This will be used for displaying the appropriate help from the mplayer.hlp file
		//when the user presses the F1 key.
		currMenuItem = (UINT)LOWORD(wParam);
		return TRUE;

	case MM_WIM_CLOSE:
	    return TRUE;

	case WM_CTLCOLORBTN:
	case WM_CTLCOLORSTATIC:
	{
	    POINT           pt;
	    pt.x = pt.y = 0;
	    ClientToScreen((HWND)lParam, &pt);
	    ScreenToClient(hwnd, &pt);
	    SetBrushOrgEx((HDC) wParam, -pt.x, -pt.y, NULL);
	    return (INT_PTR)ghbrPanel;
	}

	case WM_CLOSE:
	    if (gfInUserDestroy)
	    {
		DestroyWindow(hwnd);
		return TRUE;
	    }

	    DPF(TEXT("WM_CLOSE received\n"));
	    gfUserClose = TRUE;
	    if (gfHideAfterPlaying)
	    {
		DPF(TEXT("Resetting HideAfterPlaying\n"));
		gfHideAfterPlaying = FALSE;
	    }
	    if (gfErrorBox) {
		//  DPF("we have a error box up, ignoring WM_CLOSE.\n");
		return TRUE;
	    }
	    if (PromptToSave(TRUE, FALSE) == enumCancel)
		return TRUE;

	    //
	    // Don't free our data before terminating.  When the clipboard
	    // is flushed, we need to commit the data.
	    //
	    TerminateServer();
	    FileNew(FMT_DEFAULT, FALSE, FALSE);
	    FreeACM();
        FreeWaveHeaders();

	    //
	    //  NOTE: TerminateServer() will destroy the window!
	    //
	    SoundRec_GetSetRegistryRect(hwnd, SGSRR_SET);
	    return TRUE; //!!!

	case WM_USER_DESTROY:
	    DPF(TEXT("WM_USER_DESTROY\n"));

	    if (ghWaveOut || ghWaveIn) {
		DPF(TEXT("Ignoring, we have a device open.\n"));
		//
		// Close later, when the play finishes.
		//
		return TRUE;
	    }
	    gfInUserDestroy = TRUE;
	    PostMessage(hwnd, WM_CLOSE, 0, 0);
	    return TRUE;

	case WM_DESTROY:
	    DPF(TEXT("WM_DESTROY\n"));

	    WinHelp(hwnd, gachHelpFile, HELP_QUIT, 0L);
	    ghwndApp = NULL;

	    //
	    //  Tell my app to die
	    //
	    PostQuitMessage(0);
	    return TRUE;

	case WM_DROPFILES:
	    HANDLE_WM_DROPFILES(hwnd, wParam, lParam, SoundRec_OnDropFiles);
	    break;

	default:
#ifdef CHICAGO
	    //
	    // if we have an ACM help message registered see if this
	    // message is it.
	    //
	    if (guiACMHlpMsg && wMsg == guiACMHlpMsg)
	    {
		//
		// message was sent from ACM because the user
		// clicked on the HELP button on the chooser dialog.
		// report help for that dialog.
		//
		WinHelp(hwnd, gachHelpFile, HELP_CONTEXT, IDM_NEW);
		return TRUE;
	    }

	    //
	    //  Handle context-sensitive help messages from acm dialog
	    //
	    if( wMsg == guChooserContextMenu )
	    {
		WinHelp( (HWND)wParam, NULL, HELP_CONTEXTMENU,
			   (UINT_PTR)(LPSTR)aChooserHelpIds );
	    }
	    else if( wMsg == guChooserContextHelp )
	    {
		WinHelp( ((LPHELPINFO)lParam)->hItemHandle, NULL,
			HELP_WM_HELP, (UINT_PTR)(LPSTR)aChooserHelpIds );
	    }
#endif
	    break;
    }
    return FALSE;

} /* SoundRecDlgProc */

/*
 * Bitmap Buttons
 * */
BOOL SoundRec_OnDrawItem (
    HWND        hwnd,
    const DRAWITEMSTRUCT *lpdis )
{
    int         i;

    i = lpdis->CtlID - ID_BTN_BASE;

    if (lpdis->CtlType == ODT_BUTTON ) {

	/*
	** Now draw the button according to the buttons state information.
	*/

	tbPlaybar[i].fsState = LOBYTE(lpdis->itemState);

	if (lpdis->itemAction & (ODA_DRAWENTIRE | ODA_SELECT)) {

	    BtnDrawButton( hwnd, lpdis->hDC, (int)lpdis->rcItem.right,
			   (int)lpdis->rcItem.bottom,
			   &tbPlaybar[i] );
	    return(TRUE);
	}
	else if (lpdis->itemAction & ODA_FOCUS) {

	    BtnDrawFocusRect(lpdis->hDC, &lpdis->rcItem, lpdis->itemState);
	    return(TRUE);
	}
    }
    return(FALSE);
}



/*
 * void SoundRec_ControlPanel
 *
 * Launch "Audio" control panel/property sheet upon request.
 *
 * */
void SoundRec_ControlPanel(
    HINSTANCE   hInst,
    HWND        hParent)
{
    const TCHAR gszOpen[]     = TEXT("open");
    const TCHAR gszRunDLL[]   = TEXT("RUNDLL32.EXE");
    const TCHAR gszMMSYSCPL[] = TEXT("MMSYS.CPL,ShowAudioPropertySheet");
    ShellExecute (NULL, gszOpen, gszRunDLL, gszMMSYSCPL, NULL, SW_SHOWNORMAL);
}


/* ResolveLink
 *
 * This routine is called when the user drags and drops a shortcut
 * onto Media Player.  If it succeeds, it returns the full path
 * of the actual file in szResolved.
 */
BOOL ResolveLink(LPTSTR szPath, LPTSTR szResolved, LONG cbSize)
{
    IShellLink *psl = NULL;
    HRESULT hres;

    if (!gfOleInitialized)
    {
	if (!InitializeOle(ghInst))
	    return FALSE;
    }

    hres = CoCreateInstance(&CLSID_ShellLink, NULL, CLSCTX_INPROC,
			    &IID_IShellLink, &psl);

    if (SUCCEEDED(hres) && (psl != NULL))
    {
	IPersistFile *ppf;

	psl->lpVtbl->QueryInterface(psl, &IID_IPersistFile, &ppf);

	if (ppf)
	{
	    WCHAR wszPath[MAX_PATH];
#ifdef UNICODE
	    lstrcpy (wszPath, szPath);
#else
	    AnsiToUnicodeString(szPath, wszPath, UNKNOWN_LENGTH);
#endif
	    hres = ppf->lpVtbl->Load(ppf, wszPath, 0);
	    ppf->lpVtbl->Release(ppf);

	    if (FAILED(hres))
	    {
		psl->lpVtbl->Release(psl);
		psl = NULL;
	    }
	}
	else
	{
	    psl->lpVtbl->Release(psl);
	    psl = NULL;
	}
    }   

    if (psl)
    {
	psl->lpVtbl->Resolve(psl, NULL, SLR_NO_UI);
	psl->lpVtbl->GetPath(psl, szResolved, cbSize, NULL, 0);
	psl->lpVtbl->Release(psl);
    }

    return SUCCEEDED(hres);
}


/* ResolveIfLink
 *
 * Called to check whether a given file name is a shortcut
 * on Windows 95.
 *
 * Copies the resolved file name into the buffer provided,
 * overwriting the original name.
 *
 * Returns TRUE if the function succeeded, whether or not the
 * file name was changed.  FALSE indicates that an error occurred.
 *
 * Andrew Bell, 16 February 1995
 */
BOOL ResolveIfLink(PTCHAR szFileName)
{
    SHFILEINFO sfi;
    BOOL       rc = TRUE;

    if ((SHGetFileInfo(szFileName, 0, &sfi, sizeof sfi, SHGFI_ATTRIBUTES) == 1)
	&& ((sfi.dwAttributes & SFGAO_LINK) == SFGAO_LINK))
    {
	TCHAR szResolvedLink[MAX_PATH];

	if (ResolveLink(szFileName, szResolvedLink, SIZEOF(szResolvedLink)))
	    lstrcpy(szFileName, szResolvedLink);
	else
	    rc = FALSE;
    }

    return rc;
}



#if DBG
void FAR cdecl dprintfA(LPSTR szFormat, ...)
{
    char ach[128];
    int  s,d;
    va_list va;

    va_start(va, szFormat);
    s = vsprintf (ach,szFormat, va);
    va_end(va);

    for (d=sizeof(ach)-1; s>=0; s--)
    {
	if ((ach[d--] = ach[s]) == '\n')
	    ach[d--] = '\r';
    }

    OutputDebugStringA("SNDREC32: ");
    OutputDebugStringA(ach+d+1);
}
#ifdef UNICODE
void FAR cdecl dprintfW(LPWSTR szFormat, ...)
{
    WCHAR ach[128];
    int  s,d;
    va_list va;

    va_start(va, szFormat);
    s = vswprintf (ach,szFormat, va);
    va_end(va);

    for (d=(sizeof(ach)/sizeof(WCHAR))-1; s>=0; s--)
    {
	if ((ach[d--] = ach[s]) == TEXT('\n'))
	    ach[d--] = TEXT('\r');
    }

    OutputDebugStringW(TEXT("SNDREC32: "));
    OutputDebugStringW(ach+d+1);
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\soundrec\wave.c ===
/* (C) Copyright Microsoft Corporation 1991-1994.  All Rights Reserved */
/* wave.c
 *
 * Waveform input and output.
 */

/** Revision History.
 *  4/2/91    LaurieGr (AKA LKG) Ported to WIN32 / WIN16 common code
 *  17/Feb/94 LaurieGr Merged Daytona and Motown versions.

 *  READ ME

 *  The new soundrec was changed to use multiple headers for the following
 *  reason.  The Win3.1 version of soundrec did one waveOutWrite (with one
 *  WAVEHDR) for the entire buffer, this worked okay for relatively small
 *  files, but the moment we started using large files (>
 *  3meg) it was becoming cumbersome since it needed all of that
 *  data page-locked.  It occasionally paged for > 1 min.
 *  Note: The o-scope display for soundrec is also updated on
 *  the WOM_DONE message, it no longer looks at the buffer given on the
 *  waveOutWrite before the WOM_DONE message for the buffer
 *  is received.  This is why input mapping was not implemented
 *  in ACM on product one, there were drawing artifacts in the
 *  o-scope window.

 *  The pausing algorithm was changed for the following reason.
 *  If you launch two instances of soundrec (with two wave devices)
 *  and do the following...  Play a .wav file on instance #1
 *  (allocates first device); play a .wav file on instance #2
 *  (allocates second device); press stop on instance #1
 *  (frees first device); press rewind on instance #2
 *  (frees second device, allocates first device).
 *  Essentially, you press rewind in soundrec and you
 *  switch devices.  Since there is no explicit stop,
 *  the device should not be closed.
 */

#include "nocrap.h"
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>

#ifdef USE_MMCNTRLS
#define NOTOOLBAR
#define NOMENUHELP
#define NODRAGLIST
#define NOBITMAPBTN
#define NOMENUHELP
#define NODRAGLIST
#include "mmcntrls.h"
#else
#include <commctrl.h>
#include "buttons.h"
#endif

#define INCLUDE_OLESTUBS
#include "SoundRec.h"
#include "srecnew.h"
#include "reg.h"

#ifndef LPHWAVE
typedef HWAVE FAR *LPHWAVE;
#endif

/* globals that maintain the state of the current waveform */
BOOL            gfSyncDriver;           // true if open device is sync
PWAVEFORMATEX   gpWaveFormat;           // format of WAVE file
DWORD           gcbWaveFormat;          // size of WAVEFORMAT
LPTSTR          gpszInfo = NULL;        // file info
HPBYTE          gpWaveSamples = NULL;   // pointer to waveoform samples
LONG            glWaveSamples = 0;  // number of samples total in buffer
LONG            glWaveSamplesValid = 0; // number of samples that are valid
LONG            glWavePosition = 0; // current wave position in samples from start
LONG            glStartPlayRecPos;  // position when play or record started
LONG            glSnapBackTo = 0;
HWAVEOUT        ghWaveOut = NULL;   // wave-out device (if playing)
HWAVEIN         ghWaveIn = NULL;    // wave-out device (if recording)
BOOL            gfStoppingHard = FALSE; // StopWave() was called?
                                        // true during the call to FinishPlay()
static BOOL     fStopping = FALSE;  // StopWave() was called?
DWORD           grgbStatusColor;    // color of status text

DWORD           gdwCurrentBufferPos;    // Current playback/record pos (bytes)
DWORD           gdwBytesPerBuffer;      // Bytes in each buffer we give drvr
DWORD           gdwTotalLengthBytes;    // Length of entire buffer in bytes
DWORD           gdwBufferDeltaMSecs;    // # msecs added to end on record
BOOL            gfTimerStarted;

WAVEHDR    FAR *gapWaveHdr[MAX_WAVEHDRS];
UINT            guWaveHdrs;             // 1/2 second of buffering?
UINT            guWaveHdrsInUse;        // # we actually could write
UINT            gwMSecsPerBuffer;       // 1/8 second

#ifdef THRESHOLD
int iNoiseLevel = 15;      // 15% of full volume is defined to be quiet
int iQuietLength = 1000;  // 1000 samples in a row quiet means quiet
#endif // THRESHOLD

BOOL        fFineControl = FALSE; // fine scroll control (SHIFT key down)

/*------------------------------------------------------------------
|  fFineControl:
|  This turns on place-saving to help find your way
|  a wave file.  It's controlled by the SHIFT key being down.
|  If the key is down when you scroll (see soundrec.c) then it scrolls
|  fine amounts - 1 sample or 10 samples rather than about 100 or 1000.
|  In addition, if the SHIFT key is down when a sound is started
|  playing or recording, the position will be remembered and it will
|  snap back to that position.  fFineControl says whether we are
|  remembering such a position to snap back to.  SnapBack does the
|  position reset and then turns the flag off.  There is no such flag
|  or mode for scrolling, the SHIFT key state is examined on every
|  scroll command (again - see Soundrec.c)
 --------------------------------------------------------------------*/



/* dbgShowMemUse: display memory usage figures on debugger */
void dbgShowMemUse()
{
    MEMORYSTATUS ms;

    GlobalMemoryStatus(&ms);
//    dprintf( "load %d\n    PHYS tot %d avail %d\n    PAGE tot %d avail %d\n    VIRT tot %d avail %d\n"
//           , ms.dwMemoryLoad
//           , ms.dwTotalPhys, ms.dwAvailPhys
//           , ms.dwTotalPageFile, ms.dwAvailPageFile
//           , ms.dwTotalVirtual, ms.dwAvailVirtual
//           );

} // dbgShowMemUse

/* PLAYBACK and PAGING on NT
|
|  In order to try to get decent performance at the highest data rates we
|  need to try very hard to get all the data into storage.  The paging rate
|  on several x86 systems is only just about or even a little less than the
|  maximum data rate.  We therefore do the following:
|  a. Pre-touch the first 1MB of data when we are asked to start playing.
|     If it is already in storage, this is almost instantaneous.
|     If it needs to be faulted in, there will be a delay, but it will be well
|     worth having this delay at the start rather than clicks and pops later.
|     (At 44KHz 16 bit stereo it could be about 7 secs, 11KHz 8 bit mono it
|     would only be about 1/2 sec anyway).
|  b. Kick off a separate thread to run through the data touching 1 byte per
|     page.  This thread is Created when we start playing, periscopes the global
|     static flag fStopping and exits when it reaches the end of the buffer or when
|     that flag is set.  The global thread handle is kept in ghPreTouch and this is
|     initially invalid.  We WAIT on this handle (if valid) to clear the thread out
|     before creating a new one (so there will be at most one).  We do NOT do any
|     of this for record.  The paging does not have to happen in real time for
|     record.  It can get quite a way behind and still manage.
|
|  This whole thing is really a bit of a hack and sits uncomfortably on NT.
|  The memory management works by paging out the least recently used (LRU)
|  pages.  By stepping right though a 10Meg buffer, we will cause a lot of
|  code to get paged out.  It would be better to have a file and read it
|  in section by section into a much smaller buffer (like MPlayer does).

   Note that the use of multiple headers doesn't really affect anything.
   The headers merely point at different sections of the wave buffer.
   It merely makes the addressing of the starting point slightly different.
*/
HANDLE ghPreTouch = NULL;

typedef struct {
        LPBYTE Addr;  // start of buffer to pre-touch
        DWORD  Len;   // length of buffer to pre-touch
} PRETOUCHTHREADPARM;

/* PreToucher
**
** Asynchronous pre-toucher thread.  The thread parameter dw
** is realy a poionter to a PRETOUCHTHREADPARAM
*/
DWORD PreToucher(DWORD_PTR dw)
{
    PRETOUCHTHREADPARM * pttp;

    long iSize;
    BYTE * pb;

    pttp = (PRETOUCHTHREADPARM *) dw;
    if (!pttp) return 0;

    iSize = pttp->Len;
    pb = pttp->Addr;

    GlobalFreePtr(pttp);
    if (!pb) return 0;

    while (iSize>0 && !fStopping) {
        volatile BYTE b;
        b = *pb;
        pb += 4096;    // move to next page.  Are they ALWAYS 4096?
        iSize -= 4096; // and count it off
    }
//  dprintf(("All pretouched!"));
    return 0;
} // PreToucher


/* StartPreTouchThread
**
** Start a thread running which will run through the wave buffer
** pre-touching one byte every page to ensure that the stuff is
** faulted into memory before we actually need it.
** This was needed to make 44KHz 16 bit stereo work on a
** 25MHx 386 with 16MB memory running Windows NT.
*/
void StartPreTouchThread(LPBYTE lpb, LONG cb)
{
    /* before we start the thing running, pretouch the first bit of memory
       to give the paging a head start.  THEN start the thread running.
    */
    {    long bl = cb;
         BYTE * pb = lpb;
         if (bl>1000000) bl = 1000000;   /* 1 Meg, arbitrarily */
         pb += bl;
         while (bl>0){
             volatile BYTE b;
             b = *pb;
             pb-=4096;
             bl -= 4096;
         }
    }


    {
         PRETOUCHTHREADPARM * pttp;
         DWORD dwThread;

         if (ghPreTouch!=NULL) {
             fStopping = TRUE;
             WaitForSingleObject(ghPreTouch, INFINITE);
             CloseHandle(ghPreTouch);
             ghPreTouch = NULL;
         }
         fStopping = FALSE;
         pttp = (PRETOUCHTHREADPARM *)GlobalAllocPtr(GHND, sizeof(PRETOUCHTHREADPARM));
                /* freed by the invoked thread */

         if (pttp!=NULL) {
             pttp->Addr = lpb;
             pttp->Len = cb;
             ghPreTouch = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)PreToucher, pttp, 0, &dwThread);
             // If the CreateThread fails there will be a memory leak.  It's very small,
             // unlikely and not frequent.  Not worth fixing.
         }
    }
} // StartPreTouchThread



/* wfBytesToSamples(pwf, lBytes)
 *
 * convert a byte offset into a sample offset.
 *
 * lSamples = (lBytes/nAveBytesPerSec) * nSamplesPerSec
 *
 */
LONG PASCAL wfBytesToSamples(WAVEFORMATEX* pwf, LONG lBytes)
{
    return MulDiv(lBytes,pwf->nSamplesPerSec,pwf->nAvgBytesPerSec);
}

/* wfSamplesToBytes(pwf, lSample)
 *
 * convert a sample offset into a byte offset, with correct alignment
 * to nBlockAlign.
 *
 * lBytes = (lSamples/nSamplesPerSec) * nBytesPerSec
 *
 */
LONG PASCAL wfSamplesToBytes(WAVEFORMATEX* pwf, LONG lSamples)
{
    LONG lBytes;

    lBytes = MulDiv(lSamples,pwf->nAvgBytesPerSec,pwf->nSamplesPerSec);

    // now align the byte offset to nBlockAlign
#ifdef ROUND_UP
    lBytes = ((lBytes + pwf->nBlockAlign-1) / pwf->nBlockAlign) * pwf->nBlockAlign;
#else
    lBytes = (lBytes / pwf->nBlockAlign) * pwf->nBlockAlign;
#endif

    return lBytes;
}

/* wfSamplesToTime(pwf, lSample)
 *
 * convert a sample offset into a time offset in miliseconds.
 *
 * lTime = (lSamples/nSamplesPerSec) * 1000
 *
 */
LONG PASCAL wfSamplesToTime(WAVEFORMATEX* pwf, LONG lSamples)
{
    return MulDiv(lSamples,1000,pwf->nSamplesPerSec);
}

/* wfTimeToSamples(pwf, lTime)
 *
 * convert a time index into a sample offset.
 *
 * lSamples = (lTime/1000) * nSamplesPerSec
 *
 */
LONG PASCAL wfTimeToSamples(
    WAVEFORMATEX*   pwf,
    LONG            lTime)
{
    return MulDiv(lTime,pwf->nSamplesPerSec,1000);
}

/*
 * function to determine if a WAVEFORMAT is a valid PCM format we support for
 * editing and such.
 *
 * we only handle the following formats...
 *
 *  Mono 8bit
 *  Mono 16bit
 *  Stereo 8bit
 *  Stereo 16bit
 * */
BOOL PASCAL IsWaveFormatPCM(WAVEFORMATEX* pwf)
{
    if (!pwf)
        return FALSE;

    if (pwf->wFormatTag != WAVE_FORMAT_PCM)
        return FALSE;

    if (pwf->nChannels < 1 || pwf->nChannels > 2)
        return FALSE;

    if ((pwf->wBitsPerSample != 8) && (pwf->wBitsPerSample != 16))
        return FALSE;

    return TRUE;
} // IsWaveFormatPCM

void PASCAL WaveFormatToString(LPWAVEFORMATEX lpwf, LPTSTR sz)
{
    TCHAR achFormat[80];

    //
    //  this is what we expect the resource strings to be...
    //
    // IDS_MONOFMT      "Mono %d%c%03dkHz, %d-bit"
    // IDS_STEREOFMT    "Stereo %d%c%03dkHz, %d-bit"
    //
    if (gfLZero || ((WORD)(lpwf->nSamplesPerSec / 1000) != 0)){
    LoadString(ghInst,lpwf->nChannels == 1 ? IDS_MONOFMT:IDS_STEREOFMT,
                   achFormat, SIZEOF(achFormat));

    wsprintf(sz, achFormat,
                 (UINT)  (lpwf->nSamplesPerSec / 1000), chDecimal,
                 (UINT)  (lpwf->nSamplesPerSec % 1000),
                 (UINT)  (lpwf->nAvgBytesPerSec * 8 / lpwf->nSamplesPerSec / lpwf->nChannels));
    } else {
        LoadString(ghInst,lpwf->nChannels == 1 ? IDS_NOZEROMONOFMT:
                   IDS_NOZEROSTEREOFMT, achFormat, SIZEOF(achFormat));

        wsprintf(sz, achFormat,
                 chDecimal,
                 (WORD)  (lpwf->nSamplesPerSec % 1000),
                 (WORD)  (lpwf->nAvgBytesPerSec * 8 / lpwf->nSamplesPerSec / lpwf->nChannels));
    }
} // WaveFormatToString

#ifdef THRESHOLD

/*
 * SkipToStart()
 *
 * move forward through sound file to the start of a noise.
 * What is defined as a noise is rather arbitrary.  See NoiseLevel
 */
void FAR PASCAL SkipToStart(void)
{  BYTE * pb;   // pointer to 8 bit sample
   int  * pi;   // pointer to 16 bit sample
   BOOL f8;     // 8 bit samples
   BOOL fStereo; // 2 channels
   int  iLo;    // minimum quiet value
   int  iHi;    // maximum quiet value

   fStereo = (gpWaveFormat->nChannels != 1);
   f8 = (pWaveFormat->wBitsPerSample == 8);

   if (f8)
   {  int iDelta = MulDiv(128, iNoiseLevel, 100);
      iLo = 128 - iDelta;
      iHi = 128 + iDelta;
   }
   else
   {  int iDelta = MulDiv(32767, iNoiseLevel, 100);
      iLo = 0 - iDelta;
      iHi = 0 + iDelta;
   }

   pb = (BYTE *) gpWaveSamples
                           + wfSamplesToBytes(gpWaveFormat, glWavePosition);
   pi = (int *)pb;

   while (glWavePosition < glWaveSamplesValid)
   {   if (f8)
       {   if ( ((int)(*pb) > iHi) || ((int)(*pb) < iLo) )
              break;
           ++pb;
           if (fStereo)
           {   if ( ((int)(*pb) > iHi) || ((int)(*pb) < iLo) )
               break;
               ++pb;
           }
       }
       else
       {   if ( (*pi > iHi) || (*pi < iLo) )
              break;
           ++pi;
           if (fStereo)
           {  if ( (*pi > iHi) || (*pi < iLo) )
                 break;
              ++pi;
           }
       }
       ++glWavePosition;
   }
   UpdateDisplay(FALSE);
} /* SkipToStart */


/*
 * SkipToEnd()
 *
 * move forward through sound file to a quiet place.
 * What is defined as quiet is rather arbitrary.
 * (Currently less than 20% of full volume for 1000 samples)
 */
void FAR PASCAL SkipToEnd(void)
{  BYTE * pb;   // pointer to 8 bit sample
   int  * pi;   // pointer to 16 bit sample
   BOOL f8;     // 8 bit samples
   BOOL fStereo; // 2 channels
   int  cQuiet;  // number of successive quiet samples so far
   LONG lQuietPos; // Start of quiet period
   LONG lPos;      // Search counter

   int  iLo;    // minimum quiet value
   int  iHi;    // maximum quiet value

   fStereo = (gpWaveFormat->nChannels != 1);
   f8 = (gpWaveFormat->wBitsPerSample == 8);

   if (f8)
   {  int iDelta = MulDiv(128, iNoiseLevel, 100);
      iLo = 128 - iDelta;
      iHi = 128 + iDelta;
   }
   else
   {  int iDelta = MulDiv(32767, iNoiseLevel, 100);
      iLo = 0 - iDelta;
      iHi = 0 + iDelta;
   }

   pb = (BYTE *) gpWaveSamples
                           + wfSamplesToBytes(gpWaveFormat, glWavePosition);
   pi = (int *)pb;

   cQuiet = 0;
   lQuietPos = glWavePosition;
   lPos = glWavePosition;

   while (lPos < glWaveSamplesValid)
   {   BOOL fQuiet = TRUE;
       if (f8)
       {   if ( ((int)(*pb) > iHi) || ((int)(*pb) < iLo) ) fQuiet = FALSE;
           if (fStereo)
           {   ++pb;
               if ( ((int)(*pb) > iHi) || ((int)(*pb) < iLo) ) fQuiet = FALSE;
           }
           ++pb;
       }
       else
       {   if ( (*pi > iHi) || (*pi < iLo) ) fQuiet = FALSE;
           if (fStereo)
           {   ++pi;
               if ( (*pi > iHi) || (*pi < iLo) ) fQuiet = FALSE;
           }
           ++pi;
       }
       if (!fQuiet) cQuiet = 0;
       else if (cQuiet == 0)
       {    lQuietPos = lPos;
            ++cQuiet;
       }
       else
       {  ++cQuiet;
          if (cQuiet>=iQuietLength) break;
       }

       ++lPos;
   }
   glWavePosition = lQuietPos;
   UpdateDisplay(FALSE);
} /* SkipToEnd */


/*
 * IncreaseThresh()
 *
 * Increase the threshold of what counts as quiet by about 25%
 * Ensure it changes by at least 1 unless on the stop already
 *
 */
void FAR PASCAL IncreaseThresh(void)
{   iNoiseLevel = MulDiv(iNoiseLevel+1, 5, 4);
    if (iNoiseLevel>100) iNoiseLevel = 100;
} // IncreaseThreshold


/*
 * DecreaseThresh()
 *
 * Decrease the threshold of what counts as quiet by about 25%
 * Ensure it changes by at least 1 unless on the stop already
 * It's a divisor, so we INcrease the divisor, but never to 0
 *
 */
void FAR PASCAL DecreaseThresh(void)
{   iNoiseLevel = MulDiv(iNoiseLevel, 4, 5)-1;
    if (iNoiseLevel <=0) iNoiseLevel = 0;
} // DecreaseThreshold

#endif //THRESHOLD


/* fOK = AllocWaveBuffer(lSamples, fErrorBox, fExact)
 *
 * If <gpWaveSamples> is NULL, allocate a buffer <lSamples> in size and
 * point <gpWaveSamples> to it.
 *
 * If <gpWaveSamples> already exists, then just reallocate it to be
 * <lSamples> in size.
 *
 * if fExact is FALSE, then when memory is tight, allocate less than
 * the amount asked for - so as to give reasonable performance,
 * if fExact is TRUE then when memory is short, FAIL.
 * NOTE: On NT on a 16MB machine it WILL GIVE you 20MB, i.e. it does
 * NOT FAIL - but may (unacceptably) take SEVERAL MINUTES to do so.
 * So better to monitor the situation ourselves and ask for less.
 *
 * On success, return TRUE.  On failure, return FALSE but if and only
 * if fErrorBox is TRUE then display a MessageBox first.
 */
BOOL FAR PASCAL AllocWaveBuffer(
        LONG    lSamples,       // samples to allocate
        BOOL    fErrorBox,      // TRUE if you want an error displayed
        BOOL    fExact)         // TRUE means allocate the full amount requested or FAIL
{
    LONG_PTR    lAllocSamples;  // may be bigger than lSamples
    LONG_PTR    lBytes;     // bytes to allocate
    LONG_PTR    lBytesReasonable;  // bytes reasonable to use (phys mem avail).

    MEMORYSTATUS ms;

    lAllocSamples = lSamples;

    lBytes = wfSamplesToBytes(gpWaveFormat, lSamples);

    /* Add extra space to compensate for code generation bug which
        causes reference past end */
    /* don't allocate anything to be zero bytes long */
    lBytes += sizeof(DWORD_PTR);

    if (gpWaveSamples == NULL || glWaveSamplesValid == 0L)
    {
        if (gpWaveSamples != NULL)
        {   DPF(TEXT("Freeing %x\n"),gpWaveSamples);
            GlobalFreePtr(gpWaveSamples);
        }
        GlobalMemoryStatus(&ms);
        lBytesReasonable = ms.dwAvailPhys;  // could multiply by a fudge factor
        if (lBytesReasonable<1024*1024)
             lBytesReasonable = 1024*1024;

        if (lBytes>lBytesReasonable)
        {
        if (fExact) goto ERROR_OUTOFMEM; // Laurie's first goto in 10 years.

            // dprintf("Reducing buffer from %d to %d\n", lBytes, lBytesReasonable);
            lAllocSamples = wfBytesToSamples(gpWaveFormat,(long)lBytesReasonable);
            lBytes = lBytesReasonable+sizeof(DWORD_PTR);
        }

        /* allocate <lBytes> of memory */

        gpWaveSamples = GlobalAllocPtr(GHND|GMEM_SHARE, lBytes);

        if (gpWaveSamples == NULL)
        {
            DPF(TEXT("wave.c Alloc failed, point A.  Wanted %d\n"), lBytes);
            glWaveSamples = glWaveSamplesValid = 0L;
            glWavePosition = 0L;
            goto ERROR_OUTOFMEM;
        }
        else {
            DPF(TEXT("wave.c Allocated  %d bytes at %x\n"), lBytes, (DWORD_PTR)gpWaveSamples );
        }

        glWaveSamples = (long)lAllocSamples;
    }
    else
    {
        HPBYTE  pch;

        GlobalMemoryStatus(&ms);
        lBytesReasonable = ms.dwAvailPhys;
        
        if (lBytesReasonable<1024*1024) lBytesReasonable = 1024*1024;

        if (lBytes > lBytesReasonable+wfSamplesToBytes(gpWaveFormat,glWaveSamplesValid))
        {
        if (fExact) goto ERROR_OUTOFMEM; // Laurie's second goto in 10 years.

            lBytesReasonable += wfSamplesToBytes(gpWaveFormat,glWaveSamplesValid);
            lAllocSamples = wfBytesToSamples(gpWaveFormat,(long)lBytesReasonable);
            lBytes = lBytesReasonable+4;
        }

        DPF(TEXT("wave.c ReAllocating  %d bytes at %x\n"), lBytes, (DWORD_PTR)gpWaveSamples );

        pch = GlobalReAllocPtr(gpWaveSamples, lBytes, GHND|GMEM_SHARE);

        if (pch == NULL)
        {
            DPF(TEXT("wave.c Realloc failed.  Wanted %d\n"), lBytes);
            goto ERROR_OUTOFMEM;
        }
        else{ DPF(TEXT("wave.c Reallocated %d at %x\n"), lBytes,(DWORD_PTR)pch);
        }
        
        gpWaveSamples = pch;
        glWaveSamples = (long)lAllocSamples;
    }

    /* make sure <glWaveSamplesValid> and <glWavePosition> don't point
     * to places they shouldn't
     */
    if (glWaveSamplesValid > glWaveSamples)
        glWaveSamplesValid = glWaveSamples;
    if (glWavePosition > glWaveSamplesValid)
        glWavePosition = glWaveSamplesValid;

    dbgShowMemUse();

    return TRUE;

ERROR_OUTOFMEM:
    if (fErrorBox) {
        ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
            IDS_APPTITLE, IDS_OUTOFMEM);
    }
    dbgShowMemUse();
    return FALSE;
} // AllocWaveBuffer


/* CreateDefaultWaveFormat(lpWaveFormat)
 *
 * Fill in <*lpWaveFormat> with the "best" format that can be used
 * for recording.  If recording does not seem to be available, return
 * FALSE and set to a default "least common denominator"
 * wave audio format.
 *
 */
WORD wFormats[] =
    {
        FMT_16BIT | FMT_22k | FMT_MONO,  /* Best: 16-bit 22KHz */
        FMT_16BIT | FMT_11k | FMT_MONO,  /* Best: 16-bit 11KHz */
        FMT_8BIT  | FMT_22k | FMT_MONO,  /* Next: 8-bit 22KHz  */
        FMT_8BIT  | FMT_11k | FMT_MONO   /* Last: 8-bit 11KHz  */
    };
#define NUM_FORMATS (sizeof(wFormats)/sizeof(wFormats[0]))

/*
 * This relies on the behaviour of WAVE_MAPPER to supply a correct
 * header.
 *
 *---------------------------------------------------------------
 * 6/16/93          TimHa
 * Change back to getting a 'best' default format from the
 * above array of formats.  This is only used if ACM 2.0 isn't
 * available to do a format for us.
 *---------------------------------------------------------------
 *
 * */
BOOL PASCAL
CreateDefaultWaveFormat(LPWAVEFORMATEX lpwf, UINT uDeviceID)
{
    int i;

    lpwf->wFormatTag = WAVE_FORMAT_PCM;

    for (i = 0; i < NUM_FORMATS; i++) {
        if (CreateWaveFormat(lpwf, wFormats[i], (UINT)WAVE_MAPPER)){
            return TRUE;
        }

    }
    //
    // Couldn't find anything: leave worst format and return.
    //
    return FALSE;
} /* CreateDefaultWaveFormat */

/* BOOL PASCAL CreateWaveFormat(LPWAVEFORMATEX lpwf, WORD fmt, UINT uDeviceID)
 *
 * */
BOOL PASCAL
CreateWaveFormat(LPWAVEFORMATEX lpwf, WORD fmt, UINT uDeviceID)
{
    if (fmt == FMT_DEFAULT)
        return CreateDefaultWaveFormat(lpwf, uDeviceID);

    lpwf->wFormatTag      = WAVE_FORMAT_PCM;
    lpwf->nSamplesPerSec  = (fmt & FMT_RATE) * 11025;
    lpwf->nChannels       = (WORD)(fmt & FMT_STEREO) ? 2 : 1;
    lpwf->wBitsPerSample  = (WORD)(fmt & FMT_16BIT) ? 16 : 8;
    lpwf->nBlockAlign     = (WORD)lpwf->nChannels * ((lpwf->wBitsPerSample + 7) / 8);
    lpwf->nAvgBytesPerSec = lpwf->nSamplesPerSec * lpwf->nBlockAlign;

    return waveInOpen(NULL
                      , uDeviceID
                      , (LPWAVEFORMATEX)lpwf
                      , 0L
                      , 0L
                      , WAVE_FORMAT_QUERY|WAVE_ALLOWSYNC) == 0;
    
} /* CreateWaveFormat */


/*
 * */
BOOL NEAR PASCAL FreeWaveHeaders(void)
{
    UINT    i;

    DPF(TEXT("FreeWaveHeaders!\n"));

    // #pragma message("----FreeWaveHeaders: should probably call on exit!")

    //
    //  free any previously allocated wave headers..
    //
    for (i = 0; i < MAX_WAVEHDRS; i++)
    {
        if (gapWaveHdr[i])
        {
            GlobalFreePtr(gapWaveHdr[i]);
            gapWaveHdr[i] = NULL;
        }
    }

    return (TRUE);
} /* FreeWaveHeaders() */


/*
 * */
BOOL NEAR PASCAL
AllocWaveHeaders(
    WAVEFORMATEX *  pwfx,
    UINT            uWaveHdrs)
{
    UINT        i;
    LPWAVEHDR   pwh;

    FreeWaveHeaders();

    //
    //  allocate all of the wave headers/buffers for streaming
    //
    for (i = 0; i < uWaveHdrs; i++)
    {
        pwh = GlobalAllocPtr(GMEM_MOVEABLE, sizeof(WAVEHDR));
        
        if (pwh == NULL)
            goto AWH_ERROR_NOMEM;

        pwh->lpData         = NULL;
        pwh->dwBufferLength = 0L;
        pwh->dwFlags        = 0L;
        pwh->dwLoops        = 0L;

        gapWaveHdr[i] = pwh;
    }

    return (TRUE);

AWH_ERROR_NOMEM:
    FreeWaveHeaders();
    return (FALSE);
} /* AllocWaveHeaders() */


/* WriteWaveHeader

   Writes wave header - also actually starts the wave I/O
   by WaveOutWrite or WaveInAddBuffer.
*/
UINT NEAR PASCAL WriteWaveHeader(LPWAVEHDR pwh,BOOL fJustUnprepare)
{
    UINT        uErr;
    BOOL        fInput;
    DWORD       dwLengthToWrite;
#if 1
    //see next "mmsystem workaround"
    BOOL        fFudge;
#endif
    fInput = (ghWaveIn != NULL);

    if (pwh->dwFlags & WHDR_PREPARED)
    {
        if (fInput)
            uErr = waveInUnprepareHeader(ghWaveIn, pwh, sizeof(WAVEHDR));
        else
            uErr = waveOutUnprepareHeader(ghWaveOut, pwh, sizeof(WAVEHDR));

        //
        //  because Creative Labs thinks they know what they are doing when
        //  they don't, we cannot rely on the unprepare succeeding like it
        //  should after they have posted the header back to us... they fail
        //  the waveInUnprepareHeader with WAVERR_STILLPLAYING (21h) even
        //  though the header has been posted back with the WHDR_DONE bit
        //  set!!
        //
        //  absolutely smurphingly brilliant! and i thought Media Vision was
        //  the leader in this type of 'Creativity'!! they have competition!
        //
#if 0
        if (uErr)
        {
            if (fInput && (uErr == WAVERR_STILLPLAYING) && (pwh->dwFlags & WHDR_DONE))
            {
                DPF(TEXT("----PERFORMING STUPID HACK FOR CREATIVE LABS' SBPRO----\n"));
                pwh->dwFlags &= ~WHDR_PREPARED;
            }
            else
            {
                DPF(TEXT("----waveXXUnprepareHeader FAILED! [%.04Xh]\n"), uErr);
                return (uErr);
            }
        }
#else
        if (uErr)
        {
            DPF(TEXT("----waveXXUnprepareHeader FAILED! [%.04Xh]\n"), uErr);
            return (uErr);
        }
#endif
    }

    if (fJustUnprepare)
        return (0);

    dwLengthToWrite = gdwTotalLengthBytes - gdwCurrentBufferPos;

    if (gdwBytesPerBuffer < dwLengthToWrite)
        dwLengthToWrite = gdwBytesPerBuffer;

    //
    //  if there is nothing to write (either no more data for output or no
    //  more room for input), then return -1 which signifies this case...
    //
    if (dwLengthToWrite == 0L)
    {
        DPF(TEXT("WriteWaveHeader: no more data!\n"));
        return (UINT)-1;
    }

#if 1
//"mmsystem workaround"  Apparently waveXXXPrepareHeader can't pagelock 1 byte, so make us 2
    fFudge = (dwLengthToWrite==1);
    pwh->dwBufferLength = dwLengthToWrite + ((fFudge)?1L:0L);
#else
    pwh->dwBufferLength = dwLengthToWrite;
#endif

    pwh->lpData         = (LPSTR)&gpWaveSamples[gdwCurrentBufferPos];
    pwh->dwBytesRecorded= 0L;
    pwh->dwFlags        = 0L;
    pwh->dwLoops        = 0L;
    pwh->lpNext         = NULL;
    pwh->reserved       = 0L;

    if (fInput)
        uErr = waveInPrepareHeader(ghWaveIn, pwh, sizeof(WAVEHDR));
    else
        uErr = waveOutPrepareHeader(ghWaveOut, pwh, sizeof(WAVEHDR));

    if (uErr)
    {
        DPF(TEXT("waveXXPrepareHeader FAILED! [%.04Xh]\n"), uErr);
        return uErr;
    }

#if 1
//"mmsystem workaround". Unfudge
    if (fFudge)
        pwh->dwBufferLength -= 1;
#endif

    if (fInput)
        uErr = waveInAddBuffer(ghWaveIn, pwh, sizeof(WAVEHDR));
    else
        uErr = waveOutWrite(ghWaveOut, pwh, sizeof(WAVEHDR));

    if (uErr)
    {
        DPF(TEXT("waveXXAddBuffer FAILED! [%.04Xh]\n"), uErr);

        if (fInput)
            waveInUnprepareHeader(ghWaveIn, pwh, sizeof(WAVEHDR));
        else
            waveOutUnprepareHeader(ghWaveOut, pwh, sizeof(WAVEHDR));

        return uErr;
    }

    gdwCurrentBufferPos += dwLengthToWrite;

    return 0;
} /* WriteWaveHeader() */


/* if fFineControl is set then reset the position and clear the flag */
void FAR PASCAL SnapBack(void)
{
    if (fFineControl)
    {
        glWavePosition = glSnapBackTo;
        UpdateDisplay(TRUE);
        fFineControl = FALSE;
    }
} /* SnapBack */


/* fOK = NewWave()
 *
 * Destroy the current waveform, and create a new empty one.
 *
 * On success, return TRUE.  On failure, display an error message
 * and return FALSE.
 */
BOOL FAR PASCAL
NewWave(WORD fmt, BOOL fNewDlg)
{
    BOOL    fOK = TRUE;
    
    DPF(TEXT("NewWave called: %s\n"),(gfEmbeddedObject?TEXT("Embedded"):TEXT("App")));
#ifndef CHICAGO
    //
    // bring up the dialog to get a new waveformat IFF this was
    // selected from the File menu
    //
    if (fNewDlg)
    {
        PWAVEFORMATEX pWaveFormat;
        UINT cbWaveFormat;

        if (NewSndDialog(ghInst, ghwndApp, gpWaveFormat, gcbWaveFormat, &pWaveFormat, &cbWaveFormat))
        {
            /* User made a selection */
            /* destroy the current document */
            DestroyWave();
            gpWaveFormat = pWaveFormat;
            gcbWaveFormat = cbWaveFormat;
            gidDefaultButton = ID_RECORDBTN;
        }
        else
        {
            /* user cancelled or out of mem */
            /* should probably handle outofmem differently */
            goto RETURN_ERROR;
        }
    }
    else
#endif        
    {

        DWORD           cbwfx;
        LPWAVEFORMATEX  pwfx;


        if (!SoundRec_GetDefaultFormat(&pwfx, &cbwfx))
        {
            cbwfx = sizeof(WAVEFORMATEX);
            pwfx  = (WAVEFORMATEX *)GlobalAllocPtr(GHND, sizeof(WAVEFORMATEX));

            if (pwfx == NULL)
                goto ERROR_OUTOFMEM;

            CreateWaveFormat(pwfx,fmt,(UINT)WAVE_MAPPER);
        }
        
        // destroy the current document
        DestroyWave();

        gcbWaveFormat = cbwfx;
        gpWaveFormat = pwfx;
    }

    if (gpWaveFormat == NULL)
        goto ERROR_OUTOFMEM;

    /* allocate an empty wave buffer */

    if (!AllocWaveBuffer(0L, TRUE, FALSE))
    {
        GlobalFreePtr(gpWaveFormat);
        gpWaveFormat = NULL;
        gcbWaveFormat = 0;
        goto RETURN_ERROR;
    }

    if (!AllocWaveHeaders(gpWaveFormat, guWaveHdrs))
        goto ERROR_OUTOFMEM;

    UpdateDisplay(TRUE);

    goto RETURN_SUCCESS;

ERROR_OUTOFMEM:
    ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
                IDS_APPTITLE, IDS_OUTOFMEM);
    goto RETURN_ERROR;

RETURN_ERROR:
    fOK = FALSE;

RETURN_SUCCESS:

#if 1
//bombay bug #1609  HackFix We're not getting focus on the right guy!
//                  UpdateDisplay should have done this

    if (IsWindowVisible(ghwndApp))
    {
        if (IsWindowEnabled(ghwndRecord))
            SetDlgFocus(ghwndRecord);
        else if (IsWindowEnabled(ghwndPlay))
            SetDlgFocus(ghwndPlay);
        else if (IsWindowEnabled(ghwndScroll))
            SetDlgFocus(ghwndScroll);
    }
#endif

    return fOK;
} // NewWave



/* fOK = DestroyWave()
 *
 * Destroy the current wave.  Do not access <gpWaveSamples> after this.
 *
 * On success, return TRUE.  On failure, display an error message
 * and return FALSE.
 */
BOOL FAR PASCAL
DestroyWave(void)
{
    DPF(TEXT("DestroyWave called\n"));

    if ((ghWaveIn != NULL) || (ghWaveOut != NULL))
        StopWave();
    if (gpWaveSamples != NULL)
    {
        DPF(TEXT("Freeing %x\n"),gpWaveSamples);
        GlobalFreePtr(gpWaveSamples);
    }
    if (gpWaveFormat != NULL)
        GlobalFreePtr(gpWaveFormat);

    if (gpszInfo != NULL)
        GlobalFreePtr(gpszInfo);

    //
    //      DON'T free wave headers!
    //
    ////////FreeWaveHeaders();

    glWaveSamples = 0L;
    glWaveSamplesValid = 0L;
    glWavePosition = 0L;
    gcbWaveFormat = 0; 

    gpWaveFormat = NULL;
    gpWaveSamples = NULL;
    gpszInfo = NULL;

#ifdef NEWPAUSE

    //***extra cautionary cleanup
    if (ghPausedWave && gfPaused)
    {
        if (gfWasPlaying)
            waveOutClose((HWAVEOUT)ghPausedWave);
        else
        if (gfWasRecording)
            waveInClose((HWAVEIN)ghPausedWave);
    }
    gfPaused = FALSE;
    ghPausedWave = NULL;

#endif

    return TRUE;
} /* DestroyWave */



UINT NEAR PASCAL SRecWaveOpen(LPHWAVE lphwave, LPWAVEFORMATEX lpwfx, BOOL fInput)
{
    UINT    uErr;

    if (!lphwave || !lpwfx)
        return (1);

#ifdef NEWPAUSE
    if (gfPaused && ghPausedWave)
    {
        /* we are in a paused state.  Restore the handle. */
        *lphwave = ghPausedWave;
        gfPaused = FALSE;
        ghPausedWave = NULL;
        return MMSYSERR_NOERROR;
    }
#endif

    *lphwave = NULL;

    //
    //  first open the wave device DISALLOWING sync drivers (sync drivers
    //  do not work with a streaming buffer scheme; which is our preferred
    //  mode of operation)
    //
    //  if we cannot open a non-sync driver, then we will attempt for
    //  a sync driver and disable the streaming buffer scheme..
    //

#if 0
    gfSyncDriver = FALSE;
#else
    //
    //  if the control key is down, then FORCE use of non-streaming scheme.
    //  all that this requires is that we set the gfSyncDriver flag
    //
    if (guWaveHdrs < 2)
        gfSyncDriver = TRUE;
    else
    {
#if 0

//********* Curtis, I don't know gfSyncDriver is always getting set now!
//********* please find out!  It probably has something to do with the
//********* hook for f1 help

        if (GetAsyncKeyState(VK_CONTROL) & 0x8000)
            gfSyncDriver = TRUE;
        else
            gfSyncDriver = FALSE;
#else
        gfSyncDriver = FALSE;
#endif

    }
#endif

    if (fInput)
    {
        uErr = waveInOpen((LPHWAVEIN)lphwave
                        , (UINT)WAVE_MAPPER
                        , (LPWAVEFORMATEX)lpwfx
                        , (DWORD_PTR)ghwndApp
                        , 0L
                        , CALLBACK_WINDOW);
        if (uErr)
        {

/**** bug #967.  SPEAKER.DRV does not correctly return WAVERR_SYNC, but it
 ****            does return in error */
//            if (uErr == WAVERR_SYNC)
//            {

            uErr = waveInOpen((LPHWAVEIN)lphwave
                              , (UINT)WAVE_MAPPER
                              , (LPWAVEFORMATEX)lpwfx
                              , (DWORD_PTR)ghwndApp
                              , 0L
                              , CALLBACK_WINDOW|WAVE_ALLOWSYNC);
            if (uErr == MMSYSERR_NOERROR)
            {
                gfSyncDriver = TRUE;
            }

//            }

        }
    }
    else
    {
        uErr = waveOutOpen((LPHWAVEOUT)lphwave
                           , (UINT)WAVE_MAPPER
                           , (LPWAVEFORMATEX)lpwfx
                           , (DWORD_PTR)ghwndApp
                           , 0L
                           , CALLBACK_WINDOW);
        if (uErr)
        {

/**** bug #967.  SPEAKER.DRV does not correctly return WAVERR_SYNC, but it
 ****            does return in error */
////////////if (uErr == WAVERR_SYNC)
////////////{

                uErr = waveOutOpen((LPHWAVEOUT)lphwave
                                   , (UINT)WAVE_MAPPER
                                   , (LPWAVEFORMATEX)lpwfx
                                   , (DWORD_PTR)ghwndApp
                                   , 0L
                                   , CALLBACK_WINDOW|WAVE_ALLOWSYNC);
                if (uErr == MMSYSERR_NOERROR)
                {
                    gfSyncDriver = TRUE;
                }

////////////}

        }
    }
    return (uErr);
} /* SRecWaveOpen() */


/* SRecPlayBegin
**
** Sets
**     gdwCurrentBufferPos
**     gdwBytesPerBuffer
**     gfTimerStarted
**     fStopping
**     gfStoppingHard
**     grgbStatusColor
**     fCanPlay
**     glWavePosition
**     * gapWaveHdr[0]
** Calls
**     StopWave
**     UpdateDisplay
**     WriteWaveHeader
*/
BOOL NEAR PASCAL SRecPlayBegin(BOOL fSyncDriver)
{
    BOOL    fOK = TRUE;
    WORD    wIndex;
    UINT    uErr;

    //
    //
    //
    //
    gdwCurrentBufferPos = wfSamplesToBytes(gpWaveFormat, glWavePosition);

    if (fSyncDriver)
    {
        gdwBytesPerBuffer = gdwTotalLengthBytes - gdwCurrentBufferPos;

        uErr = WriteWaveHeader(gapWaveHdr[0],FALSE);

        if (uErr)
        {
            if (uErr == MMSYSERR_NOMEM)
            {
                // Prepare failed
                goto PB_ERROR_OUTOFMEM;
            }

            goto PB_ERROR_WAVEOUTWRITE;
        }
    }
    else
    {
        gdwBytesPerBuffer = wfTimeToSamples(gpWaveFormat, gwMSecsPerBuffer);
        gdwBytesPerBuffer = wfSamplesToBytes(gpWaveFormat, gdwBytesPerBuffer);

#if defined(_WIN32)
        StartPreTouchThread( &(gpWaveSamples[gdwCurrentBufferPos])
                           , gdwTotalLengthBytes - gdwCurrentBufferPos
                           );
#endif //_WIN32

        //
        // First wave header to be played is zero
        //
        fStopping = FALSE;

        waveOutPause(ghWaveOut);

        for (wIndex=0; wIndex < guWaveHdrs; wIndex++)
        {
            uErr = WriteWaveHeader(gapWaveHdr[wIndex],FALSE);
            if (uErr)
            {
                //
                // WriteWaveHeader will return -1 if there is no
                // more data to write. This is not an error!
                //
                // It indicates that the previous block was the
                // last one queued. Flag that we are doing cleanup
                // (just waiting for headers to complete) and save
                // which header is the last one to wait for.
                //
                if (uErr == (UINT)-1)
                {
                    if (wIndex == 0)
                    {
                        StopWave();
                        goto PB_RETURN_SUCCESS;
                    }

                    break;
                }

                //
                // If we run out of memory, but have already written
                // at least 2 wave headers, we can still keep going.
                // If we've written 0 or 1, we can't stream and will
                // stop.
                //
                if (uErr == MMSYSERR_NOMEM)
                {
                    if (wIndex > 1)
                        break;

                    // Prepare failed
                    StopWave();
                    goto PB_ERROR_OUTOFMEM;
                }

                StopWave();
                goto PB_ERROR_WAVEOUTWRITE;
            }
        }

        waveOutRestart(ghWaveOut);
    }

    /* update the display, including the status string */
    UpdateDisplay(TRUE);

    if (fSyncDriver)
    {
        /* do display updates */
        gfTimerStarted = (BOOL)SetTimer(ghwndApp, 1, TIMER_MSEC, NULL);
    }

    /* if user stops, focus will go back to "Play" button */
    gidDefaultButton = ID_PLAYBTN;

    fStopping = FALSE;
    goto PB_RETURN_SUCCESS;


PB_ERROR_WAVEOUTWRITE:

    ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
            IDS_APPTITLE, IDS_CANTOPENWAVEOUT);
    goto PB_RETURN_ERROR;

PB_ERROR_OUTOFMEM :
    ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
            IDS_APPTITLE, IDS_OUTOFMEM);
////goto PB_RETURN_ERROR;

PB_RETURN_ERROR:

    fOK = FALSE;

PB_RETURN_SUCCESS:

    return fOK;
} /* SRecPlayBegin() */



/* fOK = PlayWave()
 *
 * Start playing from the current position.
 *
 * On success, return TRUE.  On failure, display an error message
 * and return FALSE.
 */
BOOL FAR PASCAL
PlayWave(void)
{
    BOOL            fOK = TRUE;             // does this function succeed?
    UINT            uErr;

    DPF(TEXT("PlayWave called\n"));


    /* we are currently playing....*/
    if (ghWaveOut != NULL)
        return TRUE;

#if 1

//       Still trying to get this right with some bogus estimations
//       We shouldn't have to do this correction, but our conversions
//       are never 1:1

    // try to align us.
    glWavePosition = wfSamplesToSamples(gpWaveFormat,glWavePosition);
    {
        long lBlockInSamples;

        // if the distance between the glWaveSamplesValid and glWavePosition
        // is less than a "block"

        lBlockInSamples = wfBytesToSamples(gpWaveFormat,
                                           gpWaveFormat->nBlockAlign);

        if (glWaveSamplesValid - glWavePosition < lBlockInSamples)
            glWavePosition -= lBlockInSamples;
        if (glWavePosition < 0L)
            glWavePosition = 0L;
    }
#endif

    //
    //  refuse to play a zero length wave file.
    //
    if (glWaveSamplesValid == glWavePosition)
        goto RETURN_ERROR;

    /* stop playing or recording */
    StopWave();

    gdwTotalLengthBytes = wfSamplesToBytes(gpWaveFormat, glWaveSamples);

    /* open the wave output device */
    uErr = SRecWaveOpen((LPHWAVE)&ghWaveOut, gpWaveFormat, FALSE);
    if (uErr)
    {
        ghWaveOut = NULL;

        /* cannot open the waveform output device -- if the problem
        ** is that <gWaveFormat> is not supported, tell the user that
        ** 
        ** If the wave format is bad, then the play button is liable
        ** to be grayed, and the user is not going to be able to ask
        ** it to try to play, so we don't get here, so he doesn't get
        ** a decent diagnostic!!!
        */
        if (uErr == WAVERR_BADFORMAT)
        {
            ErrorResBox(ghwndApp, ghInst,
                        MB_ICONEXCLAMATION | MB_OK, IDS_APPTITLE,
                        IDS_BADOUTPUTFORMAT);
            goto RETURN_ERROR;
        }
        else
        {
            /* unknown error */
            goto ERROR_WAVEOUTOPEN;
        }
    }

    if (ghWaveOut == NULL)
        goto ERROR_WAVEOUTOPEN;

    /* start waveform output */

    // if fFineControl is still set then this is a pause as it has never
    // been properly stopped.  This means that we should keep remembering
    // the old position and stay in fine control mode, (else set new position)
    if (!fFineControl) {
        glSnapBackTo = glWavePosition;
        fFineControl = (0 > GetKeyState(VK_SHIFT));
    }

    glStartPlayRecPos = glWavePosition;

    //
    //  now kickstart the output...
    //

    if (SRecPlayBegin(gfSyncDriver) == FALSE)
    {
        waveOutClose(ghWaveOut);
        ghWaveOut = NULL;
        ghPausedWave = NULL;
        gfPaused = FALSE;
        goto RETURN_ERROR;
    }
    goto RETURN_SUCCESS;

ERROR_WAVEOUTOPEN:
    if (!waveInGetNumDevs() && !waveOutGetNumDevs()) {
        /* No recording or playback devices */
        ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
                    IDS_APPTITLE, IDS_NOWAVEFORMS);
    } else {
        ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
                    IDS_APPTITLE, IDS_CANTOPENWAVEOUT);
    }
    //goto RETURN_ERROR;

RETURN_ERROR:
    UpdateDisplay(TRUE);

    /* fix bug 4454 (WinWorks won't close) --EricLe */
    if (!IsWindowVisible(ghwndApp))
        PostMessage(ghwndApp, WM_CLOSE, 0, 0L);

    fOK = FALSE;

RETURN_SUCCESS:

    return fOK;
} // PlayWave



BOOL NEAR PASCAL SRecRecordBegin(BOOL fSyncDriver)
{
    UINT            uErr;
    long            lSamples;
    long            lOneSec;
    HCURSOR         hcurSave;
    DWORD           dwBytesAvailable;
    WORD            w;

    /* ok we go the wave device now allocate some memory to record into.
     * try to get at most 60sec from the current position.
     */

    lSamples = glWavePosition + wfTimeToSamples(gpWaveFormat, gdwBufferDeltaMSecs);
    lOneSec  = wfTimeToSamples(gpWaveFormat, 1000);

    hcurSave = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    //  set the current buffer position (in BYTES) to the current position
    //  of the thumb (in SAMPLES)...
    //
    gdwCurrentBufferPos = wfSamplesToBytes(gpWaveFormat, glWavePosition);

    //
    //  compute the the size of each buffer for the async case only
    //
    if (!fSyncDriver)
    {
        gdwBytesPerBuffer = wfTimeToSamples(gpWaveFormat, gwMSecsPerBuffer);
        gdwBytesPerBuffer = wfSamplesToBytes(gpWaveFormat, gdwBytesPerBuffer);
    }

    for (;;)
    {
        DPF(TEXT("RecordWave trying %ld samples %ld.%03ldsec\n"), lSamples,  wfSamplesToTime(gpWaveFormat, lSamples)/1000, wfSamplesToTime(gpWaveFormat, lSamples) % 1000);

        if (lSamples < glWaveSamplesValid)
            lSamples = glWaveSamplesValid;

        if (AllocWaveBuffer(lSamples, FALSE, FALSE))
        {
            dwBytesAvailable    = wfSamplesToBytes(gpWaveFormat, glWaveSamples - glWavePosition);
            gdwTotalLengthBytes = dwBytesAvailable + gdwCurrentBufferPos;

            if (fSyncDriver)
            {
                //
                //  for the sync driver case, there is only one buffer--so
                //  set the size of our 'buffer' to be the total size...
                //
                gdwBytesPerBuffer = dwBytesAvailable;

                //
                //  try to prepare and add the complete buffer--if this fails,
                //  then we will try a smaller buffer..
                //
                uErr = WriteWaveHeader(gapWaveHdr[0], FALSE);
                if (uErr == 0)
                    break;
            }
            else
            {
                //
                //  Make sure we can prepare enough wave headers to stream
                //  even if realloc succeeded
                //
                for (w = 0; w < guWaveHdrs; w++)
                {
                    uErr = WriteWaveHeader(gapWaveHdr[w], FALSE);
                    if (uErr)
                    {
                        //
                        //  WriteWaveHeader will return -1 if there is no
                        //  more data to write. This is not an error!
                        //
                        //  It indicates that the previous block was the
                        //  last one queued. Flag that we are doing cleanup
                        //  (just waiting for headers to complete) and save
                        //  which header is the last one to wait for.
                        //
                        if (uErr == (UINT)-1)
                        {
                            if (w == 0)
                            {
                                StopWave();
                                return (TRUE);
                            }

                            break;
                        }

                        //
                        //  If we run out of memory, but have already written
                        //  at least 2 wave headers, we can still keep going.
                        //  If we've written 0 or 1, we can't stream and will
                        //  stop.
                        //
                        if (uErr == MMSYSERR_NOMEM)
                        {
                            if (w > 1)
                                break;

                            StopWave();
                            goto BEGINREC_ERROR_OUTOFMEM;
                        }

                        goto BEGINREC_ERROR_WAVEINSTART;
                    }
                }

                //
                //  we wrote enough (we think), so break out of the realloc
                //  loop
                //
                break;
            }
        }

        //
        // we can't get the memory we want, so try 25% less.
        //
        if (lSamples <= glWaveSamplesValid ||
            lSamples < glWavePosition + lOneSec)
        {
            SetCursor(hcurSave);
            goto BEGINREC_ERROR_OUTOFMEM;
        }

        lSamples = glWavePosition + ((lSamples-glWavePosition)*75)/100;
    }

    SetCursor(hcurSave);

    glStartPlayRecPos = glWavePosition;

    BeginWaveEdit();

    if (waveInStart(ghWaveIn) != 0)
        goto BEGINREC_ERROR_WAVEINSTART;

    /* update the display, including the status string */
    UpdateDisplay(TRUE);

    //
    //  only start timer in the sync driver case--async case we use the
    //  buffers being posted back as our display update timer...
    //
    if (fSyncDriver)
    {
        /* do display updates */
        gfTimerStarted = (BOOL)SetTimer(ghwndApp, 1, TIMER_MSEC, NULL);
    }

    /* if user stops, focus will go back to "Record" button */
    gidDefaultButton = ID_RECORDBTN;

    fStopping = FALSE;

    return TRUE;

BEGINREC_ERROR_OUTOFMEM:
    ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
            IDS_APPTITLE, IDS_OUTOFMEM);
    goto BEGINREC_ERROR;


BEGINREC_ERROR_WAVEINSTART:
    /* This is necessary to un-add the buffer */
    waveInReset(ghWaveIn);

    EndWaveEdit(FALSE);

    /* The wave device will get closed in WaveInData() */
//    goto BEGINREC_ERROR;

BEGINREC_ERROR:

    return FALSE;

} /* SRecRecordBegin() */




/* fOK = RecordWave()
 *
 * Start recording at the current position.
 *
 * On success, return TRUE.  On failure, display an error message
 * and return FALSE.
 */
BOOL FAR PASCAL
RecordWave(void)
{
    UINT uErr;

    /* stop playing or recording */
    StopWave();

    glWavePosition = wfSamplesToSamples(gpWaveFormat, glWavePosition);

    /* open the wave input device */
    uErr = SRecWaveOpen((LPHWAVE)&ghWaveIn, gpWaveFormat, TRUE);
    if (uErr)
    {

        /* cannot open the waveform input device -- if the problem
         * is that <gWaveFormat> is not supported, advise the user to
         * do File/New to record; if the problem is that recording is
         * not supported even at 11KHz, tell the user
         */
        if (uErr == WAVERR_BADFORMAT)
        {
            WAVEFORMATEX    wf;

            /* is 11KHz mono recording supported? */
            if (!CreateWaveFormat(&wf, FMT_11k|FMT_MONO|FMT_8BIT,
                                  (UINT)WAVE_MAPPER))
            {
                /* even 11KHz mono recording is not supported */
                ErrorResBox(ghwndApp, ghInst,
                            MB_ICONEXCLAMATION | MB_OK, IDS_APPTITLE,
                            IDS_INPUTNOTSUPPORT);
                goto RETURN_ERROR;
            }
            else
            {
                /* 11KHz mono is supported, but the format
                 * of the current file is not supported
                 */
                ErrorResBox(ghwndApp, ghInst,
                            MB_ICONEXCLAMATION | MB_OK, IDS_APPTITLE,
                            IDS_BADINPUTFORMAT);
                goto RETURN_ERROR;
            }
        }
        else
        {
            /* unknown error */
            goto ERROR_WAVEINOPEN;
        }
    }

    if (ghWaveIn == NULL)
        goto ERROR_WAVEINOPEN;

    if (!SRecRecordBegin(gfSyncDriver))
        goto RETURN_ERROR;

    goto RETURN_SUCCESS;

ERROR_WAVEINOPEN:
    if (!waveInGetNumDevs() && !waveOutGetNumDevs()) {
        /* No recording or playback devices */
        ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
                    IDS_APPTITLE, IDS_NOWAVEFORMS);
    } else {
        ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
                    IDS_APPTITLE, IDS_CANTOPENWAVEIN);
    }

    // goto RETURN_ERROR;

RETURN_ERROR:
    if (ghWaveIn)
        waveInClose(ghWaveIn);
    ghWaveIn = NULL;
    ghPausedWave = NULL;

    if (glWaveSamples > glWaveSamplesValid)
    {
        /* reallocate the wave buffer to be small */
        AllocWaveBuffer(glWaveSamplesValid, TRUE, TRUE);
    }

    UpdateDisplay(TRUE);

RETURN_SUCCESS:
    return TRUE;
} /* RecordWave */





/* YieldStop(void)
 *
 *      Yeild for mouse and keyboard messages so that the stop can be
 *      processed.
 */

BOOL NEAR PASCAL YieldStop(void)
{
    BOOL    f;
    MSG         msg;

    f = FALSE;

    // Perhaps someone might deign to write a line or two
    // to explain why this loop is here twice and what it's actually doing?

    while (PeekMessage(&msg, ghwndStop, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE | PM_NOYIELD))
    {
        f = TRUE;
    TranslateMessage(&msg);
    DispatchMessage(&msg);
    }

    while (PeekMessage(&msg, ghwndStop, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE | PM_NOYIELD))
    {
        f = TRUE;
    TranslateMessage(&msg);
    DispatchMessage(&msg);
    }

    return (f);
} /* YieldStop() */


BOOL NEAR PASCAL IsAsyncStop(void)
{
    //
    //  we need to check for the esc key being pressed--BUT, we don't want
    //  to stop unless ONLY the esc key is pressed. so if someone tries to
    //  bring up task man with xxx-esc, it will not stop the playing wave..
    //
    if (GetAsyncKeyState(VK_ESCAPE) & 0x8000)
    {
        if ((GetAsyncKeyState(VK_CONTROL) & 0x8000) ||
            (GetAsyncKeyState(VK_MENU)    & 0x8000) ||
            (GetAsyncKeyState(VK_SHIFT)   & 0x8000))
        {
            return (FALSE);
        }

        //
        //  looks like only the esc key..
        //
        return (TRUE);
    }

    return (FALSE);
} /* IsAsyncStop() */




/* WaveOutDone(hWaveOut, pWaveHdr)
 *
 * Called when wave block with header <pWaveHdr> is finished playing.
 * This function causes playing to end.
 */
void FAR PASCAL
WaveOutDone(
HWAVEOUT        hWaveOut,                       // wave out device
LPWAVEHDR       pWaveHdr)               // wave header
{
    BOOL        f;
    MSG         msg;
    WORD        w;
    BOOL        fStillMoreToGo;
    UINT        u;

////DPF(TEXT("WaveOutDone()\n"));

    //
    //  check for plunger message--if we get this message, then we are done
    //  and need to close the wave device if it is still open...
    //
    if (pWaveHdr == NULL) {

#ifdef NEWPAUSE
        if (!gfPausing) {
            if (ghWaveOut) {
                waveOutClose(ghWaveOut);
                ghWaveOut = NULL;
                ghPausedWave = NULL;
            }
        }
        else
        {
            gfPaused = TRUE;
            ghWaveOut = NULL;
        }
#else
        if (ghWaveOut) {
            waveOutClose(ghWaveOut);
            ghWaveOut = NULL;
        }
#endif
    } else /* pWaveHdr!=NULL */
    if (gfSyncDriver) {
        WriteWaveHeader(pWaveHdr, TRUE);

        //
        //  !! must do this for sync drivers !!
        //
        if (!gfStoppingHard)
            /* I really don't understand the details of this yet.
            ** What you might call the random stab method of programming!
            ** Laurie
            */
            glWavePosition = glWaveSamplesValid;

#ifdef NEWPAUSE
        if (!gfPausing) {
            waveOutClose(ghWaveOut);
            ghWaveOut = NULL;
            ghPausedWave = NULL;
        } else {
            ghWaveOut = NULL;
            gfPaused = TRUE;
        }
#else
        waveOutClose(ghWaveOut);
        ghWaveOut = NULL;
#endif
    } else { /* pWaveHdr!=NULL & !gfSyncDriver */
        if (!fStopping) {
            while (1) {
                glWavePosition += wfBytesToSamples(gpWaveFormat, pWaveHdr->dwBufferLength);

                //
                // Go into cleanup mode (stop writing new data) on any error
                //
                u = WriteWaveHeader(pWaveHdr, FALSE);
                if (u) {
                    if (u == (UINT)-1) {
                        /* pWaveHdr!=NULL & !gfSyncDriver
                           & WriteWaveHeader() returned -1
                        */
                        fStopping = TRUE;

                        //
                        //  we cannot assume that the wave position is going
                        //  to end up exactly at the end with compressed data
                        //  because of this, we cannot do this postion compare
                        //  to see if we are 'completely' done (all headers
                        //  posted back, etc
                        //
                        //  so we jump to a piece of code that searches for
                        //  any buffers that are still outstanding...
                        //
#if 0
                        if (glWavePosition >= glWaveSamplesValid)
                        {
                            waveOutClose(ghWaveOut);
                            ghWaveOut = NULL;
                        }
                        break;
#else
                        fStillMoreToGo = FALSE;
                        goto KLUDGE_FOR_NOELS_BUG;
#endif
                    }

                    DPF(TEXT("WaveOutDone: CRITICAL ERROR ON WRITING BUFFER [%.04Xh]\n"), u);
                    StopWave();
                } else {
                    if (IsAsyncStop()) {
                        StopWave();
                        return;
                    }
                    if (YieldStop()) {
                        return;
                    }
                }

                f = PeekMessage(&msg, ghwndApp, MM_WOM_DONE, MM_WOM_DONE,
                                    PM_REMOVE | PM_NOYIELD);
                if (!f)
                    break;

                //
                //  don't let plunger msg mess us up!
                //
                if (msg.lParam == 0L)
                    break;

                pWaveHdr = (LPWAVEHDR)msg.lParam;
            }
        } else {
            fStillMoreToGo = FALSE;

            if (gfStoppingHard) {
                while (1) {
                    DPF(TEXT("HARDSTOP PLAY: another one bites the dust!\n"));

                    WriteWaveHeader(pWaveHdr, TRUE);

                    f = PeekMessage(&msg, ghwndApp, MM_WOM_DONE, MM_WOM_DONE,
                                        PM_REMOVE | PM_NOYIELD);

                    if (!f)
                        break;

                    //
                    //  don't let plunger msg mess us up!
                    //
                    if (msg.lParam == 0L)
                        break;

                    pWaveHdr = (LPWAVEHDR)msg.lParam;
                }
            } else {
                glWavePosition += wfBytesToSamples(gpWaveFormat, pWaveHdr->dwBufferLength);

                WriteWaveHeader(pWaveHdr, TRUE);

KLUDGE_FOR_NOELS_BUG:
                for (w = 0; w < guWaveHdrs; w++) {
                    if (gapWaveHdr[w]->dwFlags & WHDR_PREPARED) {
                        DPF(TEXT("PLAY: still more headers outstanding...\n"));
                        fStillMoreToGo = TRUE;
                        break;
                    }
                }
            }

            if (!fStillMoreToGo) {
                //
                //  if the user did not push stop (ie we played through
                //  normally) put the position at the end of the wave.
                //
                //  note we need to do this for sync drivers and compressed
                //  wave's
                //
                if (!gfStoppingHard)
                    glWavePosition = glWaveSamplesValid;
#ifdef NEWPAUSE
                if (!gfPausing) {
                    waveOutClose(ghWaveOut);
                    ghWaveOut = NULL;
                    ghPausedWave = NULL;
                } else {
                    ghWaveOut = NULL;
                    gfPaused = TRUE;
                }
#else
                waveOutClose(ghWaveOut);
                ghWaveOut = NULL;
#endif
                {
                    if (gfCloseAtEndOfPlay)
                        PostMessage(ghwndApp, WM_CLOSE, 0, 0L);
                }
            }
        }
    }

    UpdateDisplay(TRUE);

    //
    //
    //
    //
    if (ghWaveOut == NULL) {
        if (gfTimerStarted) {
            KillTimer(ghwndApp, 1);
            gfTimerStarted = FALSE;
        }
        SnapBack();
    }

    /* If we were showing the window temporarily while playing,
        hide it now. */

    if (ghWaveOut == NULL && gfHideAfterPlaying) {
        DPF(TEXT("Done playing, so hide window.\n"));
        ShowWindow(ghwndApp, SW_HIDE);
    }

    if (ghWaveOut == NULL && !IsWindowVisible(ghwndApp))
        PostMessage(ghwndApp, WM_CLOSE, 0, 0L);

} /* WaveOutDone */



/* WaveInData(hWaveIn, pWaveHdr)
 *
 * Called when wave block with header <pWaveHdr> is finished being
 * recorded.  This function causes recording to end.
 */
void FAR PASCAL
WaveInData(
HWAVEIN         hWaveIn,                // wave in device
LPWAVEHDR       pWaveHdr)               // wave header
{
    BOOL        f;
    MSG         msg;
    WORD        w;
    BOOL        fStillMoreToGo;
    UINT        u;

    //
    //  check for plunger message--if we get this message, then we are done
    //  and need to close the wave device if it is still open...
    //
    if (pWaveHdr == NULL)
    {

//*** BOMBAY:1370 how do we pause without closing the handle?

#ifdef NEWPAUSE

        if (!gfPausing)
        {
            if (ghWaveIn)
            {
                waveInClose(ghWaveIn);
                ghWaveIn = NULL;
                ghPausedWave = NULL;
            }
        }
        else
        {
            gfPaused = TRUE;
            ghWaveIn = NULL;
        }

#else

        if (ghWaveIn)
        {
            waveInClose(ghWaveIn);
            ghWaveIn = NULL;
        }

#endif

    }
    else if (gfSyncDriver)
    {
        glWavePosition = glStartPlayRecPos + wfBytesToSamples(gpWaveFormat,
                                                pWaveHdr->dwBytesRecorded);
        if (glWaveSamplesValid < glWavePosition)
            glWaveSamplesValid = glWavePosition;

        WriteWaveHeader(pWaveHdr, TRUE);

//*** BOMBAY:1370 How do we pause without closing the handle?

#ifdef NEWPAUSE

        if (!gfPausing)
        {
            waveInClose(ghWaveIn);
            ghWaveIn = NULL;
            ghPausedWave = NULL;
        }
        else
        {
            ghWaveIn = NULL;
            gfPaused = TRUE;
        }

#else

        waveInClose(ghWaveIn);
        ghWaveIn = NULL;

#endif

    }
    else
    {
        if (!fStopping)
        {
            while (1)
            {
                glWavePosition += wfBytesToSamples(gpWaveFormat, pWaveHdr->dwBytesRecorded);

                //
                //  go into cleanup mode (stop writing new data) on any error
                //
                u = WriteWaveHeader(pWaveHdr, FALSE);
                if (u)
                {
                    //
                    //  if the return value is '-1' then we are out of data
                    //  space--but probably have headers outstanding so we
                    //  need to wait for all headers to come in before
                    //  shutting down.
                    //
                    if (u == (UINT)-1)
                    {
                        DPF(TEXT("WaveInData: stopping cuz out of data space\n"));
                        fStopping = TRUE;
                        break;
                    }

                    DPF(TEXT("WaveInData: CRITICAL ERROR ON ADDING BUFFER [%.04Xh]\n"), u);
                    StopWave();
                }
                else
                {
                    if (IsAsyncStop())
                    {
                        StopWave();
                        return;
                    }

                    if (YieldStop())
                        return;
                }

                f = PeekMessage(&msg, ghwndApp, MM_WIM_DATA, MM_WIM_DATA,
                                    PM_REMOVE | PM_NOYIELD);
                if (!f)
                    break;

                //
                //  don't let plunger msg mess us up!
                //
                if (msg.lParam == 0L)
                    break;

                pWaveHdr = (LPWAVEHDR)msg.lParam;
            }
        }
        else
        {
            fStillMoreToGo = FALSE;

            if (gfStoppingHard)
            {
                while (1)
                {
                    DPF(TEXT("HARDSTOP RECORD: another one bites the dust!\n"));

                    //
                    //  NOTE! update the position cuz info could have been
                    //  recorded and we have not received its callback yet..
                    //  length will be zero if not used--so this works great
                    //
                    glWavePosition += wfBytesToSamples(gpWaveFormat, pWaveHdr->dwBytesRecorded);
                    WriteWaveHeader(pWaveHdr, TRUE);

                    f = PeekMessage(&msg, ghwndApp, MM_WIM_DATA, MM_WIM_DATA,
                                        PM_REMOVE | PM_NOYIELD);

                    if (!f)
                        break;

                    //
                    //  don't let plunger msg mess us up!
                    //
                    if (msg.lParam == 0L)
                        break;

                    pWaveHdr = (LPWAVEHDR)msg.lParam;
                }
            }
            else
            {
                glWavePosition += wfBytesToSamples(gpWaveFormat, pWaveHdr->dwBytesRecorded);

                //
                //  we're stopping, so get this header unprepared and proceed
                //  to shut this puppy down!
                //
                WriteWaveHeader(pWaveHdr, TRUE);

                for (w = 0; w < guWaveHdrs; w++)
                {
                    if (gapWaveHdr[w]->dwFlags & WHDR_PREPARED)
                    {
                        DPF(TEXT("RECORD: still more headers outstanding...\n"));
                        fStillMoreToGo = TRUE;
                        break;
                    }
                }
            }

            if (!fStillMoreToGo)
            {
//*** BOMBAY:1370 How do we pause without closing the handle?

#ifdef NEWPAUSE
                if (!gfPausing)
                {
                    waveInClose(ghWaveIn);
                    ghWaveIn = NULL;
                    ghPausedWave = NULL;
                }
                else
                {
                    ghWaveIn = NULL;
                    gfPaused = TRUE;
                }
#else
                waveInClose(ghWaveIn);
                ghWaveIn = NULL;
#endif
            }
        }
    }

    //
    //  update <glWaveSamplesValid>
    //
    UpdateDisplay(TRUE);

    //
    //  if we closed the wave device, then we are completely done so do what
    //  we do when we are completely done...
    //
    //  NOTE! we must have already called UpdateDisplay(TRUE) before doing
    //  the following!
    //
    if (ghWaveIn == NULL)
    {
        if (gfTimerStarted)
        {
            KillTimer(ghwndApp, 1);
            gfTimerStarted = FALSE;
        }

        if (glWaveSamples > glWaveSamplesValid)
        {
            /* reallocate the wave buffer to be small */
            AllocWaveBuffer(glWaveSamplesValid, TRUE, TRUE);
        }

        if (pWaveHdr)
        {
            /* ask user to save file if they close it */
            EndWaveEdit(TRUE);
        }
        SnapBack();
    }
} /* WaveInData */

/*
 *  @doc INTERNAL SOUNDREC
 *
 *  @api void FAR PASCAL | FinishPlay | Processes messages until a stop
 *      has flushed all WOM_DONE/WIM_DONE messages out of the message queue.
 *
 *  @rdesc  None.
 */
void FAR PASCAL FinishPlay(
        void)
{
        MSG             msg;
        while (GetMessage(&msg, NULL, 0, 0))
        {
                if (!TranslateAccelerator(ghwndApp, ghAccel, &msg))
                {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                }

#ifdef NEWPAUSE
//        Why is this commented out?
                
//        if (gfPausing && gfPaused)
//            break;
#endif
                if ((ghWaveOut == NULL) && (ghWaveIn == NULL))
                        break;
        }
} /* FinishPlay() */



/* StopWave()
 *
 * Request waveform recording or playback to stop.
 */
void FAR PASCAL
     StopWave(void)
{
    DPF(TEXT("------------StopWave() called!\n"));

    if (ghWaveOut != NULL)
    {
        waveOutReset(ghWaveOut);

        //
        //  post a 'plunger' message that will guarantee that at least one
        //  message goes through so we stop even in bizarre cases...
        //
        if (!gfSyncDriver)
        {
            DPF(TEXT("Post Plunger (WOM)\n"));
            PostMessage(ghwndApp, MM_WOM_DONE, 0, 0L);
        }
        fStopping      = TRUE;  // the pre-touch thread periscopes this flag
        if (ghPreTouch!=NULL){
            WaitForSingleObject(ghPreTouch, INFINITE);
            CloseHandle(ghPreTouch);
            ghPreTouch = NULL;
        }
    }
    else if (ghWaveIn != NULL)
    {
        waveInReset(ghWaveIn);
        //
        //  post a 'plunger' message that will guarantee that at least one
        //  message goes through so we stop even in bizarre cases...
        //
        if (!gfSyncDriver)
        {
            DPF(TEXT("Post Plunger (WIM)\n"));
            PostMessage(ghwndApp, MM_WIM_DATA, 0, 0L);
        }
    }
    else
        return;

    fStopping      = TRUE;
    gfStoppingHard = TRUE;

    /* get messages from event queue and dispatch them,
     * until the MM_WOM_DONE or MM_WIM_DATA message is
     * processed
     */
    FinishPlay();
    gfStoppingHard = FALSE;

// Should StopWave() be calling UpdateDisplay()?
}


#if 0 // this is obsolete
/* EnableButtonRedraw(fAllowRedraw)
 *
 * Allow/disallow the buttons to redraw, depending on <fAllowRedraw>.
 * This is designed to reduce button flicker.
 */
void NEAR PASCAL
     EnableButtonRedraw(BOOL fAllowRedraw)
{
    SendMessage(ghwndPlay, WM_SETREDRAW, fAllowRedraw, 0);
    SendMessage(ghwndStop, WM_SETREDRAW, fAllowRedraw, 0);
    SendMessage(ghwndRecord, WM_SETREDRAW, fAllowRedraw, 0);

    if (fAllowRedraw)
    {
        InvalidateRect(ghwndPlay, NULL, FALSE);
        InvalidateRect(ghwndStop, NULL, FALSE);
        InvalidateRect(ghwndRecord, NULL, FALSE);
    }
}
#endif //0  - obsolete function


/* UpdateDisplay(fStatusChanged)
 *
 * Update the current position and file length on the display.
 * If <fStatusChanged> is TRUE, also update the status line and button
 * enable/disable state.
 *
 * As a side effect, update <glWaveSamplesValid> if <glWavePosition>
 * is greater than <glWaveSamplesValid>.
 */
void FAR PASCAL
     UpdateDisplay(
                    BOOL fStatusChanged)         // update status line
{
   MMTIME          mmtime;
   UINT            uErr;
   int             id;
   TCHAR           ach[120];
   long            lTime;
   long            lLen;
   int             iPos;
   HWND            hwndFocus;
   BOOL            fCanPlay;
   BOOL            fCanRecord;

   hwndFocus = GetFocus();

   if (fStatusChanged)
   {

      // EnableButtonRedraw(FALSE);

      /* update the buttons and the status line */
      if (ghWaveOut != NULL)
      {
         /* we are now playing */
         id = IDS_STATUSPLAYING;
         grgbStatusColor = RGB_PLAY;

         SendMessage(ghwndPlay,BM_SETCHECK,TRUE,0L);

         EnableWindow(ghwndPlay, FALSE);
         EnableWindow(ghwndStop, TRUE);
         EnableWindow(ghwndRecord, FALSE);

         if ((hwndFocus == ghwndPlay) ||  (hwndFocus == ghwndRecord))
            if (IsWindowVisible(ghwndApp))
               SetDlgFocus(ghwndStop);
      }
      else
      if (ghWaveIn != NULL)
      {
         /* we are now recording */
         id = IDS_STATUSRECORDING;
         grgbStatusColor = RGB_RECORD;

         SendMessage(ghwndRecord,BM_SETCHECK,TRUE,0L);
         EnableWindow(ghwndPlay, FALSE);
         EnableWindow(ghwndStop, TRUE);
         EnableWindow(ghwndRecord, FALSE);

         if ((hwndFocus == ghwndPlay) ||  (hwndFocus == ghwndRecord))
            if (IsWindowVisible(ghwndApp))
               SetDlgFocus(ghwndStop);

      }
      else
      {
         fCanPlay = (0 == waveOutOpen(NULL
                                      , (UINT)WAVE_MAPPER
                                      , (LPWAVEFORMATEX)gpWaveFormat
                                      , 0L
                                      , 0L
                                      , WAVE_FORMAT_QUERY|WAVE_ALLOWSYNC));

         fCanRecord = (0 == waveInOpen(NULL
                                       , (UINT)WAVE_MAPPER
                                       , (LPWAVEFORMATEX)gpWaveFormat
                                       , 0L
                                       , 0L
                                       , WAVE_FORMAT_QUERY|WAVE_ALLOWSYNC));

         /* we are now stopped */
         id = IDS_STATUSSTOPPED;
         grgbStatusColor = RGB_STOP;

         //
         //  'un-stick' the buttons if they are currently
         //  stuck
         //
         SendMessage(ghwndPlay,BM_SETCHECK,FALSE,0L);
         SendMessage(ghwndRecord,BM_SETCHECK,FALSE,0L);

         EnableWindow(ghwndPlay, fCanPlay && glWaveSamplesValid > 0);
         EnableWindow(ghwndStop, FALSE);
         EnableWindow(ghwndRecord, fCanRecord);

         if (hwndFocus && !IsWindowEnabled(hwndFocus) &&
            GetActiveWindow() == ghwndApp && IsWindowVisible(ghwndApp))
         {
            if (gidDefaultButton == ID_RECORDBTN && fCanRecord)
               SetDlgFocus(ghwndRecord);
            else if (fCanPlay && glWaveSamplesValid > 0)
               SetDlgFocus(ghwndPlay);
            else
               SetDlgFocus(ghwndScroll);
         }
      }

   }
   // EnableButtonRedraw(TRUE);
   if (ghWaveOut != NULL || ghWaveIn != NULL)
   {
      if (gfTimerStarted)
      {
         glWavePosition = 0L;
         mmtime.wType = TIME_SAMPLES;

         if (ghWaveOut != NULL)
            uErr = waveOutGetPosition(ghWaveOut, &mmtime, sizeof(mmtime));
         else
            uErr = waveInGetPosition(ghWaveIn, &mmtime, sizeof(mmtime));

         if (uErr == MMSYSERR_NOERROR)
         {
            switch (mmtime.wType)
            {
         case TIME_SAMPLES:
            glWavePosition = glStartPlayRecPos + mmtime.u.sample;
            break;

         case TIME_BYTES:
            glWavePosition = glStartPlayRecPos + wfBytesToSamples(gpWaveFormat, mmtime.u.cb);
            break;
            }
         }
      }
   }

   /* SEMI-HACK: Guard against bad values */
   if (glWavePosition < 0L) {
      DPF(TEXT("Position before zero!\n"));
      glWavePosition = 0L;
   }

   if (glWavePosition > glWaveSamples) {
      DPF(TEXT("Position past end!\n"));
      glWavePosition = glWaveSamples;
   }

   /* side effect: update <glWaveSamplesValid> */
   if (glWaveSamplesValid < glWavePosition)
      glWaveSamplesValid = glWavePosition;

   /* display the current wave position */
   lTime = wfSamplesToTime(gpWaveFormat, glWavePosition);
   if (gfLZero || ((int)(lTime/1000) != 0))
      wsprintf(ach, aszPositionFormat, (int)(lTime/1000), chDecimal, (int)((lTime/10)%100));
   else
      wsprintf(ach, aszNoZeroPositionFormat, chDecimal, (int)((lTime/10)%100));

   SetDlgItemText(ghwndApp, ID_CURPOSTXT, ach);

   /* display the current wave length */

   //
   //  changes whether the right-hand status box displays max length or current
   //  position while recording... the status box used to display the max
   //  length... if the status box gets added back for some reason, then we
   //  MAY want to change this back to the old way..
   //
#if 1
   lLen = ghWaveIn ? glWaveSamples : glWaveSamplesValid;
#else
   lLen = glWaveSamplesValid;
#endif
   lTime = wfSamplesToTime(gpWaveFormat, lLen);

   if (gfLZero || ((int)(lTime/1000) != 0))
      wsprintf(ach, aszPositionFormat, (int)(lTime/1000), chDecimal, (int)((lTime/10)%100));
   else
      wsprintf(ach, aszNoZeroPositionFormat, chDecimal, (int)((lTime/10)%100));

   SetDlgItemText(ghwndApp, ID_FILELENTXT, ach);

   /* update the wave display */
   InvalidateRect(ghwndWaveDisplay, NULL, fStatusChanged);
   UpdateWindow(ghwndWaveDisplay);

   /* update the scroll bar position */
   if (glWaveSamplesValid > 0)
      iPos = (int)MulDiv((DWORD) SCROLL_RANGE, glWavePosition, lLen);
   else
      iPos = 0;

   //
   // windows will re-draw the scrollbar even
   // if the position does not change.
   //
#if 0
   if (iPos != GetScrollPos(ghwndScroll, SB_CTL))
      SetScrollPos(ghwndScroll, SB_CTL, iPos, TRUE);
   //        if (iPos != GetScrollPos(ghwndScroll, SB_CTL))
   //       SendMessage(ghwndScroll, TBM_SETPOS, TRUE, (LPARAM)(WORD)iPos);
#endif

   // Now we're using a much nicer trackbar
   // SetScrollPos(ghwndScroll, SB_CTL, iPos, TRUE);
   SendMessage(ghwndScroll,TBM_SETPOS, TRUE, (LPARAM)(WORD)iPos);  // WORD worries me. LKG. ???
   SendMessage(ghwndScroll,TBM_SETRANGEMAX, 0, (glWaveSamplesValid > 0)?SCROLL_RANGE:0);

   EnableWindow(ghwndForward, glWavePosition < glWaveSamplesValid);
   EnableWindow(ghwndRewind,  glWavePosition > 0);

   if (hwndFocus == ghwndForward && glWavePosition >= glWaveSamplesValid)
      SetDlgFocus(ghwndRewind);

   if (hwndFocus == ghwndRewind && glWavePosition == 0)
      SetDlgFocus(ghwndForward);

#ifdef DEBUG
   if ( ((ghWaveIn != NULL) || (ghWaveOut != NULL)) &&
      (gapWaveHdr[0]->dwFlags & WHDR_DONE) )
      //!!            DPF2(TEXT("DONE BIT SET!\n"));
      ;
#endif
} /* UpdateDisplay */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\agfxp.h ===
#ifdef AGFX_EXPORTS
#define AGFX_API __declspec(dllexport)
#else
#define AGFX_API __declspec(dllimport)
#endif

EXTERN_C AGFX_API void WINAPI gfxLogon(DWORD dwProcessId);
EXTERN_C AGFX_API void WINAPI gfxLogoff(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\verinfo\usa\verinfo.h ===
/*
 *      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 *      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 *	!!!!!!!IF YOU CHANGE TABS TO SPACES, YOU WILL BE KILLED!!!!!!!
 *      !!!!!!!!!!!!!!DOING SO MESSES UP THE BUILD PROCESS!!!!!!!!!!!!
 *      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 *      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 */


/*
 *  verinfo.h - internal header file to define the build version
 *
 */

//
//  WARNING! the following defines are used by some of the components in
//  the multimedia core. do *NOT* put LEADING ZERO's on these numbers or
//  they will end up as OCTAL numbers in the C code!
//

#include <ntverp.h>
#define VERSIONPRODUCTNAME VER_PRODUCTNAME_STR

#ifdef MTN

#define OFFICIAL	1
#define FINAL		0

#ifdef ALTACM

#define /*ALTACM*/ MMVERSION		2
#define /*ALTACM*/ MMREVISION		0
#define /*ALTACM*/ MMRELEASE		90

#ifdef RC_INVOKED
#define VERSIONCOPYRIGHT	"Copyright (C) Microsoft Corp. 1992-1999\0"
#endif

#if defined(DEBUG_RETAIL)
#define /*ALTACM*/ VERSIONSTR	"Motown Retail Debug Version 2.00.090\0"
#elif defined(DEBUG)
#define /*ALTACM*/ VERSIONSTR	"Motown Internal Debug Version 2.00.090\0"
#else
#define /*ALTACM*/ VERSIONSTR	"2.00\0"
#endif

#elif defined(ALTVFW)

#define /*ALTVFW*/ MMVERSION		4
#define /*ALTVFW*/ MMREVISION		0
#define /*ALTVFW*/ MMRELEASE		90

#ifdef RC_INVOKED
#define VERSIONCOPYRIGHT	"Copyright (C) Microsoft Corp. 1992-1999\0"
#endif

#if defined(DEBUG_RETAIL)
#define /*ALTVFW*/ VERSIONSTR	"Motown Retail Debug Version 4.00.090\0"
#elif defined(DEBUG)
#define /*ALTVFW*/ VERSIONSTR	"Motown Internal Debug Version 4.00.090\0"
#else
#define /*ALTVFW*/ VERSIONSTR	"4.00\0"
#endif

#else

#define /*MTN*/ MMVERSION		4
#define /*MTN*/ MMREVISION		0
#define /*MTN*/ MMRELEASE		90

#ifdef RC_INVOKED
#define VERSIONCOPYRIGHT	"Copyright (C) Microsoft Corp. 1991-1999\0"
#endif

#if defined(DEBUG_RETAIL)
#define /*MTN*/ VERSIONSTR	"Motown Retail Debug Version 4.00.090\0"
#elif defined(DEBUG)
#define /*MTN*/ VERSIONSTR	"Motown Internal Debug Version 4.00.090\0"
#else
#define /*MTN*/ VERSIONSTR	"4.00\0"
#endif

#endif

#elif defined(ACM)

#define OFFICIAL	1
#define FINAL		0

#define /*ACM*/ MMVERSION		5
#define /*ACM*/ MMREVISION		00
#define /*ACM*/ MMRELEASE		VER_PRODUCTBUILD

#ifdef RC_INVOKED
#define VERSIONCOPYRIGHT	"Copyright (C) Microsoft Corp. 1992-1999\0"
#endif

#if defined(DEBUG_RETAIL)
#define /*ACM*/ VERSIONSTR	"ACM Retail Debug Version 4.00.000\0"
#elif defined(DEBUG)
#define /*ACM*/ VERSIONSTR	"ACM Internal Debug Version 4.00.000\0"
#else
#define /*ACM*/ VERSIONSTR	"4.00\0"
#endif

#elif defined(VFW)

#define OFFICIAL	1
#define FINAL		0

#define /*VFW*/ MMVERSION		1
#define /*VFW*/ MMREVISION		10
#define /*VFW*/ MMRELEASE		190

#ifdef RC_INVOKED
#define VERSIONCOPYRIGHT	"Copyright (C) Microsoft Corp. 1992-1999\0"
#endif

#ifdef WIN32

#if defined(DEBUG_RETAIL)
#define /*VFW*/ VERSIONSTR	"Video for Windows Retail Debug Version 1.15.001 (NT)\0"
#elif defined(DEBUG)
#define /*VFW*/ VERSIONSTR	"Video for Windows Internal Debug Version 1.15.001 (NT)\0"
#else
#define /*VFW*/ VERSIONSTR	"1.15\0"
#endif

#else // WIN32

#if defined(DEBUG_RETAIL)
#define /*VFW*/ VERSIONSTR	"Video for Windows Retail Debug Version 1.15.001\0"
#elif defined(DEBUG)
#define /*VFW*/ VERSIONSTR	"Video for Windows Internal Debug Version 1.15.001\0"
#else
#define /*VFW*/ VERSIONSTR	"1.15\0"
#endif
#endif

#endif

/***************************************************************************
 *  DO NOT TOUCH BELOW THIS LINE                                           *
 ***************************************************************************/

#ifdef RC_INVOKED
#define VERSIONCOMPANYNAME	VER_COMPANYNAME_STR

/*
 *  Version flags
 */

#ifndef OFFICIAL
#define VER_PRIVATEBUILD	VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD	0
#endif

#define VERSIONFLAGS		(VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)
#define VERSIONFILEFLAGSMASK	0x0030003FL

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndvol\newvol.c ===
/* (C) Copyright Microsoft Corporation 1993.  All Rights Reserved */

#include <windows.h>
#include <mmsystem.h>
#include <string.h>
#include "newvol.h"
#include "volume.h"     // for ini file string identifiers
#include "sndcntrl.h"

#ifdef TESTMIX
#include "mixstub.h"
#endif
//
// Globals
//
#define SHOWMUX
int NumberOfDevices = 0;
PVOLUME_CONTROL    Vol = NULL;

UINT               FirstMasterIndex;

/*
 * Profile file, section and key names
 */
TCHAR gszVolumeSection[64];
TCHAR gszProfileFile[MAX_PATH];

DWORD AdjustMaster(WORD v)
{
    DWORD dwResult;

    if (bMuted) {
        return 1;
    }

    dwResult = (v >> 8) + 1;

    return dwResult;
}

//
// Add a control to our list
//
// Note that the G..Ptr macros in windowsx.h are inadequate and incorrect -
// especially for multithreaded systems where stuff can move while it is
// temporarily unlocked.
//

PVOLUME_CONTROL AddNewControl(VOID)
{
    HGLOBAL         hMem;
    PVOLUME_CONTROL pVol;

    if (Vol == NULL) {
        hMem = GlobalAlloc(GHND, sizeof(VOLUME_CONTROL));
        if (hMem == NULL) {
            return NULL;
        } else {
            Vol = GlobalLock(hMem);
            NumberOfDevices = 1;
        }
    } else {
        HGLOBAL hMemOld;

        hMemOld = GlobalHandle((LPVOID)Vol);
        GlobalUnlock(hMemOld);
        hMem = GlobalReAlloc(hMemOld,
                             sizeof(VOLUME_CONTROL) * (NumberOfDevices + 1),
                             GHND);
        if (hMem == NULL) {
            Vol = GlobalLock(hMemOld);
            return NULL;
        }

        Vol = GlobalLock(hMem);
        NumberOfDevices++;
    }
    pVol = Vol + (NumberOfDevices - 1);

    /*
    **  Finish initialization
    */

    pVol->Index          = NumberOfDevices - 1;

    pVol->MixerId        = (HMIXEROBJ)-1;
    pVol->ControlId      = (DWORD)-1;
    pVol->MuxControlId   = (DWORD)-1;
    pVol->MuteControlId  = (DWORD)-1;
    pVol->MuxSelectIndex = (DWORD)-1;

    return pVol;
}

WORD CombineVolume(WORD Master, WORD Slave)
{
   DWORD Result;

   //
   // treat both numbers as 8-bit volumes, and multiply them
   //

   Result = AdjustMaster(Master) * (DWORD)(Slave >> 8);

   return LOWORD(Result);
}

/*
**  Set the device volume.
**
**  The master volume (and mute setting) are simulated here by
**  scaling the individual device volumes if there is no mixer
**  or the mixer doesn't support the settings
*/
BOOL SetDeviceVolume(PVOLUME_CONTROL pVol, DWORD Volume)
{
    DWORD dwMaster;

    /*
    **  Mixer volumes get set when we get the notification
    */

    if (pVol->VolumeType != VolumeTypeMixerControl) {
        pVol->LRVolume = Volume;
    }

   /*
    *  If it's not the master volume we're setting then
    *  combine the setting with the master volume setting
    */

    if (pVol->Type != MasterVolume) {

        /*
        **  Only simulate controls which don't have real master controls
        */

        if (!pVol->NoMasterSimulation) {
            /*
             * if mute is selected, scale the volume by 1 (not 0)
             * as the master volume. This will still result in an
             * inaudible volume, but will allow us to recover the volume setting
             * from the device when this app restarts.
             */
            dwMaster = MasterDevice(FALSE)->LRVolume;

            Volume = CombineVolume(LOWORD(dwMaster),
                                   LOWORD(Volume)) +
                    (CombineVolume(HIWORD(dwMaster),
                                   HIWORD(Volume)) << 16);
        }
    }

    switch (pVol->Type) {
    case MasterVolume:
        {
           int i;
           for (i = 0; i < NumberOfDevices; i++) {
               if (!Vol[i].NoMasterSimulation && Vol[i].Type != MasterVolume) {
                   SetDeviceVolume(&Vol[i], Vol[i].LRVolume);
               }
           }
        }
        if (pVol->VolumeType == VolumeTypeMixerControl) {
            SetMixerVolume(pVol->MixerId,
                           pVol->ControlId,
                           pVol->Stereo,
                           Volume);
        }
        break;

    case AuxVolume:
        auxSetVolume(pVol->id, Volume);
        break;

    case MidiOutVolume:
#if (WINVER >= 0x0400)
        midiOutSetVolume((HMIDIOUT)pVol->id, Volume);
#else
        midiOutSetVolume(pVol->id, Volume);
#endif
        break;

    case WaveOutVolume:
#if (WINVER >= 0x0400)
        waveOutSetVolume((HWAVEOUT)pVol->id, Volume);
#else
        waveOutSetVolume(pVol->id, Volume);
#endif
        break;

    case MixerControlVolume:
        SetMixerVolume(pVol->MixerId,
                       pVol->ControlId,
                       pVol->Stereo,
                       Volume);
        break;

    }

    if (pVol->VolumeType != VolumeTypeMixerControl) {
        /*
        **  Update the slider(s)
        */

        UpdateVolume(pVol);
    }

    return TRUE;
}

/*
 *  Get the volume associated with a mixer device
 */

VOID GetMixerVolume(HMIXEROBJ MixerId, DWORD dwControlId, BOOL Stereo, LPDWORD pVolume)
{
    MIXERCONTROLDETAILS mxd;
    DWORD               Volume[2];

    Volume[0] = 0;
    Volume[1] = 0;

    mxd.cbStruct        = sizeof(mxd);
    mxd.dwControlID     = dwControlId;
    mxd.cChannels       = Stereo ? 2 : 1;
    mxd.cMultipleItems  = 0;
    mxd.cbDetails       = sizeof(DWORD);
    mxd.paDetails       = (LPVOID)Volume;

    mixerGetControlDetails(MixerId, &mxd, MIXER_GETCONTROLDETAILSF_VALUE);

    if (Stereo) {
        *pVolume = (DWORD)MAKELONG(Volume[0], Volume[1]);
    } else {
        *pVolume = (DWORD)MAKELONG(Volume[0], Volume[0]);
    }
}

/*
 *  Set the volume associated with a mixer device
 */

VOID SetMixerVolume(HMIXEROBJ MixerId, DWORD dwControlId, BOOL Stereo, DWORD NewVolume)
{
    MIXERCONTROLDETAILS mxd;
    DWORD               Volume[2];

    Volume[0] = LOWORD(NewVolume);
    Volume[1] = HIWORD(NewVolume);

    mxd.cbStruct        = sizeof(mxd);
    mxd.dwControlID     = dwControlId;
    mxd.cChannels       = Stereo ? 2 : 1;
    mxd.cMultipleItems  = 0;
    mxd.cbDetails       = sizeof(DWORD);
    mxd.paDetails       = (LPVOID)Volume;

    mixerSetControlDetails(MixerId, &mxd, MIXER_SETCONTROLDETAILSF_VALUE);
}


/*
 *  Get the volume for a given device.  Returns the volume
 *  setting packed in a DWORD
 */

DWORD GetDeviceVolume(PVOLUME_CONTROL pVol)
{
    DWORD Volume;
    DWORD Left;
    DWORD Right;
    DWORD dwMaster;
    PVOLUME_CONTROL pMaster;

    //
    // Default if calls fail
    //

    Volume = pVol->LRVolume;

    switch (pVol->Type) {

    case AuxVolume:
        auxGetVolume(pVol->id, &Volume);
        break;

    case MidiOutVolume:
#if (WINVER >= 0x0400)
        midiOutGetVolume((HMIDIOUT)pVol->id, &Volume);
#else
        midiOutGetVolume(pVol->id, &Volume);
#endif
        break;

    case WaveOutVolume:
#if (WINVER >= 0x0400)
        waveOutGetVolume((HWAVEOUT)pVol->id, &Volume);
#else
        waveOutGetVolume(pVol->id, &Volume);
#endif
        break;

    case MixerControlVolume:
    case MasterVolume:

        /*
        ** don't scale by master vol in this case
        */

        if (pVol->VolumeType != VolumeTypeMixerControl) {
            return Volume;
        }

        GetMixerVolume(pVol->MixerId,
                       pVol->ControlId,
                       pVol->Stereo,
                       &Volume);

        if (pVol->NoMasterSimulation || pVol->Type == MasterVolume) {
            return Volume;
        }
        break;
    }

    /*
    **  Translate it back through the master volume
    **  Use 1 as the master volume if mute is set (see SetDeviceVolume)
    */

    pMaster = MasterDevice(pVol->RecordControl);

    if (!pVol->NoMasterSimulation && pMaster != NULL) {
        dwMaster = pMaster->LRVolume;

        Left = ((DWORD)LOWORD(Volume)) / AdjustMaster(LOWORD(dwMaster));
        Left <<= 8;
        if (Left > 65535) {
            Left = 65535;
        }

        Right = ((DWORD)HIWORD(Volume)) / AdjustMaster(HIWORD(dwMaster));
        Right <<= 8;
        if (Right > 65535) {
            Right = 65535;
        }
    } else {
        if (bMuted &&
            (pMaster == NULL ||
             pMaster->MuteControlId == (DWORD)-1)) {

            Left = LOWORD(Volume) >> 8;
            Right = HIWORD(Volume) >> 8;
        } else {
            Left = LOWORD(Volume);
            Right = HIWORD(Volume);
        }
    }

    pVol->LRVolume = (DWORD)MAKELONG(Left, Right);

    return pVol->LRVolume;
}

/*
**  Update the displayed 'selected' state for a line
*/

VOID UpdateSelected(PVOLUME_CONTROL pVol)
{
    if (pVol->hCheckBox != NULL) {
        BOOL bSelected = ControlSelected(pVol);
        if (pVol->Type == MasterVolume) {
            SetWindowText(pVol->hCheckBox,
                          _string(bSelected ? IDS_MUTE : IDS_UNMUTE));
        } else {
            SendMessage(pVol->hCheckBox,
                        BM_SETCHECK,
                        (WPARAM)bSelected,
                        0L);
        }
    }
}

/*
**  Update the displayed volume for a slider by getting the actual level from
**  the device and then updating the local values and informing the window
**  control(s)
*/

VOID UpdateVolume(PVOLUME_CONTROL pVol)
{
    UINT    oldVolume, oldBalance;
    DWORD   dwVolumes;
    UINT    max, min, left, right, temp;

    oldVolume = pVol->Volume;
    oldBalance = pVol->Balance;

    dwVolumes = GetDeviceVolume(pVol);

    /* figure out pan information */
    right = HIWORD(dwVolumes);
    left = LOWORD(dwVolumes);
    max = (right > left) ? right : left;
    min = (right > left) ? left : right;

    if (max == 0) {
        /* special case since then there's no panning. Therefore
            we dont know what the panning level is, therefore
            dont change the slider balance */
        pVol->Volume = 0;
        pVol->Balance = oldBalance;       /* centered */
    } else {
        pVol->Volume = max >> 8;
        temp = (UINT) (((DWORD) (max - min) << 7) / max);
        if (temp > 0x7f) temp = 0x7f;

        if (right > left)
            pVol->Balance = 0x80 + temp;
        else
            pVol->Balance = 0x7f - temp;
    }

    /* change the slider if necessary */
    if (oldVolume != pVol->Volume && pVol->hChildWnd && IsWindow(pVol->hChildWnd)) {
        SendMessage(pVol->hChildWnd,SL_PM_SETKNOBPOS,
            pVol->Volume, 0);
    }
    if (oldBalance != pVol->Balance && IsWindow(pVol->hMeterWnd)) {
        SendMessage(pVol->hMeterWnd,MB_PM_SETKNOBPOS,
            pVol->Balance, 0);
    }
}

/*
 *  Extract pertinent information for a given device type
 *  If there is an equivalent mixer device don't bother.
 */
BOOL ExtractInfo(UINT id,
                 VOLUME_DEVICE_TYPE Type,
                 LPBOOL VolSupport,
                 LPBOOL StereoSupport,
                 LPTSTR lpName,
                 PUINT Technology)
{
    UINT MixerId;

    switch (Type) {
    case MasterVolume:
        break;
    case AuxVolume:
        if (mixerGetID((HMIXEROBJ)id, &MixerId, MIXER_OBJECTF_AUX) == MMSYSERR_NOERROR) {
            return FALSE;
        }  else {
           AUXCAPS ac;
           if (auxGetDevCaps(id, &ac, sizeof(ac)) != MMSYSERR_NOERROR) {
              return FALSE;
           }
           *VolSupport = (ac.dwSupport & AUXCAPS_VOLUME) != 0;
           *StereoSupport = (ac.dwSupport & AUXCAPS_LRVOLUME) != 0;
           lstrcpyn(lpName, ac.szPname, MAXPNAMELEN);
           *Technology =
               ac.wTechnology == AUXCAPS_CDAUDIO ? VolumeTypeCD :
               ac.wTechnology == AUXCAPS_AUXIN ? VolumeTypeLineIn :
                  VolumeTypeAux;
        }
        break;
    case MidiOutVolume:
       if (mixerGetID((HMIXEROBJ)id, &MixerId, MIXER_OBJECTF_MIDIOUT) == MMSYSERR_NOERROR) {
           return FALSE;
       }  else {
          MIDIOUTCAPS mc;
          if (midiOutGetDevCaps(id, &mc, sizeof(mc)) != MMSYSERR_NOERROR) {
             return FALSE;
          }
          *VolSupport = (mc.dwSupport & MIDICAPS_VOLUME) != 0;
          *StereoSupport = (mc.dwSupport & MIDICAPS_LRVOLUME) != 0;
          lstrcpyn(lpName, mc.szPname, MAXPNAMELEN);
          *Technology =
              mc.wTechnology == MOD_SYNTH || mc.wTechnology == MOD_SQSYNTH ||
              mc.wTechnology == MOD_FMSYNTH ? VolumeTypeSynth :
              VolumeTypeMidi;
       }
       break;
    case WaveOutVolume:
        if (mixerGetID((HMIXEROBJ)id, &MixerId, MIXER_OBJECTF_WAVEOUT) == MMSYSERR_NOERROR) {
            return FALSE;
        }  else {
           WAVEOUTCAPS wc;
           if (waveOutGetDevCaps(id, &wc, sizeof(wc)) != MMSYSERR_NOERROR) {
              return FALSE;
           }
           *VolSupport = (wc.dwSupport & WAVECAPS_VOLUME) != 0;
           *StereoSupport = (wc.dwSupport & WAVECAPS_LRVOLUME) != 0;
           lstrcpyn(lpName, wc.szPname, MAXPNAMELEN);
           *Technology = VolumeTypeWave;
        }
        break;
    }

    return TRUE;
}

/*
**  NonMixerDevices
**
**  Search to see if there is a non-mixer device which is not
**  duplicated by a mixer device
**
**  If there is one return TRUE, otherwise FALSE
*/

BOOL NonMixerDevices()
{
    VOLUME_DEVICE_TYPE DeviceType;

    for (DeviceType = WaveOutVolume;
         DeviceType < NumberOfDeviceTypes;
         DeviceType++) {
        UINT DeviceId;
        UINT N;

        N = DeviceType == AuxVolume          ? auxGetNumDevs() :
            DeviceType == MidiOutVolume      ? midiOutGetNumDevs() :
                                               waveOutGetNumDevs();

        for (DeviceId = 0; DeviceId < N; DeviceId++) {
            BOOL VolumeSupport;
            BOOL StereoSupport;
            TCHAR Pname[MAXPNAMELEN];
            UINT Technology;

            if (ExtractInfo(DeviceId,
                            DeviceType,
                            &VolumeSupport,
                            &StereoSupport,
                            Pname,
                            &Technology) &&
                VolumeSupport) {
                return TRUE;
            }
        }
    }

    return FALSE;
}

/*
**  Returns an allocated array of the controls for a given line
**  Caller must LocalFree it.
*/

PMIXERCONTROL GetMixerLineControls(HMIXEROBJ MixerId,
                                   DWORD dwLineID,
                                   DWORD cControls)
{
    MIXERLINECONTROLS MixerLineControls;

    MixerLineControls.cbStruct = sizeof(MixerLineControls);
    MixerLineControls.cControls = cControls;
    MixerLineControls.dwLineID  = dwLineID;
    MixerLineControls.cbmxctrl  = sizeof(MIXERCONTROL);

    MixerLineControls.pamxctrl =
        (LPMIXERCONTROL)LocalAlloc(LPTR, cControls * sizeof(MIXERCONTROL));

    if (MixerLineControls.pamxctrl == NULL) {
        //
        // Ulp!
        //

        return NULL;
    }

    if (mixerGetLineControls(MixerId,
                             &MixerLineControls,
                             MIXER_GETLINECONTROLSF_ALL) != MMSYSERR_NOERROR) {
        LocalFree((HLOCAL)MixerLineControls.pamxctrl);
        return NULL;
    }

    return MixerLineControls.pamxctrl;
}

BOOL GetControlByType(
    HMIXEROBJ MixerId,
    DWORD dwLineId,
    DWORD dwControlType,
    PMIXERCONTROL MixerControl
)
{
    MIXERLINECONTROLS MixerLineControls;

    MixerLineControls.cbStruct      = sizeof(MixerLineControls);
    MixerLineControls.cControls     = 1;
    MixerLineControls.dwLineID      = dwLineId;
    MixerLineControls.dwControlType = dwControlType;
    MixerLineControls.cbmxctrl      = sizeof(MIXERCONTROL);

    MixerLineControls.pamxctrl = MixerControl;

    if (mixerGetLineControls(MixerId,
                             &MixerLineControls,
                             MIXER_GETLINECONTROLSF_ONEBYTYPE) != MMSYSERR_NOERROR) {
        return FALSE;
    }

    return TRUE;
}

/*
**  See if a given volume control is selected through its mux/mixer
**  Note that this state can change every time the relevant mux/mixer
**  control changes
*/
BOOL ControlSelected(
    PVOLUME_CONTROL pVol
)
{
    MIXERCONTROLDETAILS mxd;
    BOOL                bResult;

    if (pVol->Type != MixerControlVolume ||
        pVol->MuxSelectIndex == (DWORD)-1) {
        bResult = TRUE;
    } else {

        mxd.cbStruct        = sizeof(mxd);
        mxd.dwControlID     = pVol->MuxControlId;
        mxd.cChannels       = 1;
        mxd.cMultipleItems  = pVol->MuxItems;
        mxd.cbDetails       = sizeof(DWORD);
        mxd.paDetails       =
            (LPVOID)LocalAlloc(LPTR, mxd.cbDetails * mxd.cMultipleItems);

        if (mxd.paDetails == NULL) {
            return FALSE;
        }

        mixerGetControlDetails(pVol->MixerId, &mxd, MIXER_GETCONTROLDETAILSF_VALUE);
        bResult = ((LPDWORD)mxd.paDetails)[pVol->MuxSelectIndex] != 0;
        LocalFree((HLOCAL)mxd.paDetails);
    }


    if (pVol->MuteControlId != (DWORD)-1) {
        bResult = bResult && !GetMixerMute(pVol);
    }

    return bResult;
}

/*
**  The user wants this device to do its thing
*/

VOID SelectControl(
    PVOLUME_CONTROL pVol,
    BOOL            Select
)
{
    MIXERCONTROLDETAILS mxd;

    if (pVol->Type != MixerControlVolume ||
        pVol->MuxSelectIndex == (DWORD)-1 &&
        pVol->MuteControlId == (DWORD)-1) {
        return;
    }

    if (pVol->MuxSelectIndex == (DWORD)-1) {
        SetMixerMute(pVol, !Select);
    } else {
        mxd.cbStruct        = sizeof(mxd);
        mxd.dwControlID     = pVol->MuxControlId;
        mxd.cChannels       = 1;
        mxd.cMultipleItems  = pVol->MuxItems;
        mxd.cbDetails       = sizeof(DWORD);
        mxd.paDetails       =
            (LPVOID)LocalAlloc(LPTR, mxd.cbDetails * mxd.cMultipleItems);

        if (mxd.paDetails == NULL) {
            return;
        }

        if (pVol->MuxOrMixer) {
            /*
            **  Mux
            */

            ZeroMemory(mxd.paDetails, sizeof(DWORD) * mxd.cMultipleItems);
        } else {
            /*
            **  Mixer
            */

            mixerGetControlDetails(pVol->MixerId, &mxd, MIXER_GETCONTROLDETAILSF_VALUE);
        }

        ((LPDWORD)mxd.paDetails)[pVol->MuxSelectIndex] = (DWORD)Select;
        mixerSetControlDetails(pVol->MixerId, &mxd, MIXER_SETCONTROLDETAILSF_VALUE);

        /*
        **  If we have both mute and mux then turn off the mute if we
        **  activate this device
        */

        if (Select && pVol->MuteControlId != (DWORD)-1) {
            SetMixerMute(pVol, FALSE);
        }

        LocalFree((HLOCAL)mxd.paDetails);
    }
}

BOOL GetMixerMute(PVOLUME_CONTROL pVol)
{
    MIXERCONTROLDETAILS mxd;
    DWORD               dwMute;

    if (pVol->MuteControlId == (DWORD)-1) {
        return FALSE;
    }

    mxd.cbStruct        = sizeof(mxd);
    mxd.dwControlID     = pVol->MuteControlId;
    mxd.cChannels       = 1;
    mxd.cMultipleItems  = 0;
    mxd.cbDetails       = sizeof(DWORD);
    mxd.paDetails       = (LPDWORD)&dwMute;

    mixerGetControlDetails(pVol->MixerId, &mxd, MIXER_GETCONTROLDETAILSF_VALUE);

    if (pVol->Type == MasterVolume) {
        bMuted = (BOOL)dwMute;
    }
    return (BOOL)dwMute;
}
VOID SetMixerMute(PVOLUME_CONTROL pVol, BOOL Set)
{
    MIXERCONTROLDETAILS mxd;

    if (pVol->MuteControlId == (DWORD)-1) {
        return;
    }

    mxd.cbStruct        = sizeof(mxd);
    mxd.dwControlID     = pVol->MuteControlId;
    mxd.cChannels       = 1;
    mxd.cMultipleItems  = 0;
    mxd.cbDetails       = sizeof(DWORD);
    mxd.paDetails       = (LPDWORD)&Set;

    mixerSetControlDetails(pVol->MixerId, &mxd, MIXER_SETCONTROLDETAILSF_VALUE);
}

/*
**  Add a master control
**
**  Paramters
**      MixerId   - The mixer id
**      dwMaster  - The control id for volume setting
**      dwMute    - The control id for muting
**      Record    - whether it's a record or play master
*/

VOID
AddMasterControl(
    HMIXEROBJ      MixerId,
    LPMIXERLINE    LineInfo,
    LPMIXERCONTROL ControlInfo,
    DWORD          dwMute,
    BOOL           Record
)
{
    PVOLUME_CONTROL pVol;

    pVol = AddNewControl();

    if (pVol == NULL) {
        return;
    }

    pVol->Type             = MasterVolume;
    pVol->MixerId          = MixerId;
    pVol->VolumeType       = VolumeTypeMixerControl;
    pVol->Stereo           = LineInfo->cChannels > 1;
    pVol->ControlId        = ControlInfo->dwControlID;
    pVol->RecordControl    = Record;
    pVol->MuteControlId    = dwMute;
    pVol->DestLineId       = LineInfo->dwLineID;
    lstrcpy(pVol->Name, LineInfo->szShortName);

    if (FirstMasterIndex == (DWORD)-1) {
        FirstMasterIndex = pVol->Index;
    }

    if (pVol->MuteControlId != (DWORD)-1) {
        bMuted = GetMixerMute(pVol);
    }
}

VOID
AddVolumeControl(
    HMIXEROBJ      MixerId,
    BOOL           NoMasterSimulation,
    LPMIXERLINE    LineInfo,
    LPMIXERCONTROL ControlInfo,
    BOOL           Record,
    LPMIXERCONTROL MuxControl,
    DWORD          MuxSelectIndex,
    BOOL           MuxOrMixer,
    DWORD          MuteControlId,
    DWORD          DestLineId
)
{
    PVOLUME_CONTROL pVol;

    pVol = AddNewControl();

    if (pVol == NULL) {
        return;
    }

    pVol->Type             = MixerControlVolume;
    pVol->MixerId          = MixerId;
    pVol->VolumeType       = VolumeTypeMixerControl;
    pVol->Stereo           = LineInfo->cChannels > 1;
#ifndef SHOWMUX
    pVol->ControlId        = ControlInfo->dwControlID;
#else
    if (ControlInfo != NULL)
        pVol->ControlId    = ControlInfo->dwControlID;
    else
        pVol->ControlId    = (DWORD)-1;
#endif
    pVol->RecordControl    = Record;
    pVol->DestLineId       = DestLineId;

    if (Record) {
        bRecordControllable = TRUE;
    }

    pVol->NoMasterSimulation = NoMasterSimulation;
    pVol->MuxSelectIndex   = MuxSelectIndex;
    pVol->MuteControlId    = MuteControlId;
    if (MuxSelectIndex != (DWORD)-1) {
        pVol->MuxControlId     = MuxControl->dwControlID;
        pVol->MuxOrMixer       = MuxControl->dwControlType ==
                                             MIXERCONTROL_CONTROLTYPE_MUX;

        pVol->MuxItems         = MuxControl->cMultipleItems;
    }

    lstrcpy(pVol->Name, LineInfo->szShortName);
}

//
// Get the mixer stuff we're interested in
//

VOID GetMixerControls(HMIXEROBJ MixerId)
{

    MIXERCAPS       MixerCaps;
    DWORD           DestLineIndex;

    //
    //  Find the number of dest lines
    //

    if (mixerGetDevCaps((UINT)MixerId, &MixerCaps, sizeof(MixerCaps)) !=
        MMSYSERR_NOERROR) {
        return;
    }

    /*
    **  For each destination :
    **     If it's an output
    **        Find the master and mute controls if there are any
    **        Scan the source lines for suitable devices
    **
    **  NB should this just be for speakers?
    */

    for (DestLineIndex = 0;
         DestLineIndex < MixerCaps.cDestinations;
         DestLineIndex++) {

         MIXERLINE    DestLineInfo;
         MIXERCONTROL MasterVolumeControl, MasterMuteControl;
         MIXERCONTROL MuxControl;
         DWORD        dwMute;
         DWORD        dwMaster;
         BOOL         MasterFound;
         BOOL         IncludeLine;
         BOOL         RecordDestination;
         BOOL         MuxValid;
         DWORD        SourceIndex;

         MasterFound = FALSE;
         dwMute = (DWORD)-1;
         dwMaster = (DWORD)-1;

         DestLineInfo.cbStruct = sizeof(DestLineInfo);
         DestLineInfo.dwDestination = DestLineIndex;

         if (mixerGetLineInfo(MixerId,
                              &DestLineInfo,
                              MIXER_GETLINEINFOF_DESTINATION) !=
             MMSYSERR_NOERROR) {
             return;              // Bad mixer or something
         }

         if (DestLineInfo.fdwLine & MIXERLINE_LINEF_DISCONNECTED) {
             continue;
         }

         switch (DestLineInfo.dwComponentType) {

             case MIXERLINE_COMPONENTTYPE_DST_SPEAKERS:
             case MIXERLINE_COMPONENTTYPE_DST_HEADPHONES:
                 RecordDestination = FALSE;
                 IncludeLine = TRUE;
                 break;

             case MIXERLINE_COMPONENTTYPE_DST_WAVEIN:
                 RecordDestination = TRUE;
                 IncludeLine = TRUE;
                 break;

             default:
                 IncludeLine = FALSE;
                 break;
         }

         if (!IncludeLine) {
             continue;
         }

         if (GetControlByType(MixerId,
                              DestLineInfo.dwLineID,
                              MIXERCONTROL_CONTROLTYPE_MUX,
                              &MuxControl) ||
             GetControlByType(MixerId,
                              DestLineInfo.dwLineID,
                              MIXERCONTROL_CONTROLTYPE_MIXER,
                              &MuxControl)) {
             /*
             **  Found a mux for this destination.
             */

             MuxValid = TRUE;
         } else {

             /*
             **  No Mux
             */

             MuxValid = FALSE;
         }

         /*
         **  Master and mute for all dest types
         */

         if (GetControlByType(MixerId,
                              DestLineInfo.dwLineID,
                              MIXERCONTROL_CONTROLTYPE_VOLUME,
                              &MasterVolumeControl)) {

             MasterFound = TRUE;
             dwMaster    = MasterVolumeControl.dwControlID;

             if (GetControlByType(MixerId,
                                  DestLineInfo.dwLineID,
                                  MIXERCONTROL_CONTROLTYPE_MUTE,
                                  &MasterMuteControl)) {
                 dwMute = MasterMuteControl.dwControlID;
             }

             /*
             **  Add master information
             */

             AddMasterControl(MixerId,
                              &DestLineInfo,
                              &MasterVolumeControl,
                              dwMute,
                              RecordDestination);

         }

         /*
         **  Now find each individual source control we want to
         **  control
         */

         for (SourceIndex = 0;
              SourceIndex < DestLineInfo.cConnections;
              SourceIndex++) {
             MIXERLINE         SourceLineInfo;
             MIXERCONTROL      SourceLineVolumeControl;
             LPMIXERCONTROL    lpSLVC = &SourceLineVolumeControl;

             BOOL              IncludeLine;
             DWORD             MuxSelectIndex;
             DWORD             MuteControlId;

             MuxSelectIndex = (DWORD)-1;

             SourceLineInfo.cbStruct      = sizeof(SourceLineInfo);
             SourceLineInfo.dwDestination = DestLineIndex;
             SourceLineInfo.dwSource      = SourceIndex;

             if (mixerGetLineInfo(MixerId,
                                  &SourceLineInfo,
                                  MIXER_GETLINEINFOF_SOURCE) !=
                 MMSYSERR_NOERROR) {
                 return;
             }

             if (SourceLineInfo.fdwLine & MIXERLINE_LINEF_DISCONNECTED) {
                 continue;
             }


             switch (SourceLineInfo.dwComponentType) {

                 /*
                 **  Only allow things we understand (and remove things
                 **  like pc speaker to keep the number of sliders down).
                 */

                 case MIXERLINE_COMPONENTTYPE_SRC_LINE:
                 case MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE:
                 case MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER:
                 case MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC:
                 case MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT:
                 case MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY:
                 case MIXERLINE_COMPONENTTYPE_SRC_TELEPHONE:
                 case MIXERLINE_COMPONENTTYPE_SRC_DIGITAL:
                     IncludeLine = TRUE;
                     break;

                 default:
                     IncludeLine = TRUE;
                     break;
             }

             if (!IncludeLine) {
                 continue;
             }

             /*
             **  Try to get the relevant volume control
             */

             if (!GetControlByType(MixerId,
                                   SourceLineInfo.dwLineID,
                                   MIXERCONTROL_CONTROLTYPE_VOLUME,
                                   &SourceLineVolumeControl)) {
#ifdef SHOWMUX
                 lpSLVC = NULL;
#else
                 continue;
#endif
             }

             /*
             **  See if there's a mute
             */
             {
                 MIXERCONTROL MuteControl;

                 if (GetControlByType(MixerId,
                                      SourceLineInfo.dwLineID,
                                      MIXERCONTROL_CONTROLTYPE_MUTE,
                                      &MuteControl)) {
                     MuteControlId = MuteControl.dwControlID;
                 } else {
                     MuteControlId = (DWORD)-1;
                 }
             }

             /*
             ** See if we need an id to switch the recording on or
             ** off
             */

             if (MuxValid) {
                 LPMIXERCONTROLDETAILS_LISTTEXT ListText;

                 ListText = (LPMIXERCONTROLDETAILS_LISTTEXT)
                            LocalAlloc(LPTR,
                                       sizeof(*ListText) *
                                           MuxControl.cMultipleItems);

                 if (ListText != NULL) {
                     MIXERCONTROLDETAILS mxd;

                     mxd.cbStruct       = sizeof(mxd);
                     mxd.dwControlID    = MuxControl.dwControlID;
                     mxd.cChannels      = 1;   // Why the ???
                     mxd.cMultipleItems = MuxControl.cMultipleItems;
                     mxd.cbDetails      = sizeof(*ListText);
                     mxd.paDetails      = (LPVOID)ListText;

                     if (mixerGetControlDetails(
                             MixerId,
                             &mxd,
                             MIXER_GETCONTROLDETAILSF_LISTTEXT) ==
                         MMSYSERR_NOERROR) {
                         UINT i;

                         /*
                         **  Look for our line
                         */

                         for (i = 0; i < MuxControl.cMultipleItems; i++) {
                             if (ListText[i].dwParam1 ==
                                 SourceLineInfo.dwLineID) {
                                 MuxSelectIndex = i;
                             }
                         }
                     }

                     LocalFree((HLOCAL)ListText);
                 }
             }

             /*
             **  Add this volume control to the list
             */

             AddVolumeControl(MixerId,
                              MasterFound || RecordDestination,
                              &SourceLineInfo,
//                              &SourceLineVolumeControl,
                              lpSLVC,
                              RecordDestination,
                              MuxValid ? &MuxControl : NULL,
                              MuxSelectIndex,
                              MuxValid ? FALSE :
                                         MuxControl.dwControlType ==
                                         MIXERCONTROL_CONTROLTYPE_MUX,
                              MuteControlId,
                              DestLineInfo.dwLineID);
         }
    }
}

//
// Scan through all relevant devices.
// If pVol is 0 just count them, otherwise save away info
// about them as well
//

VOID FindDevices(VOLUME_DEVICE_TYPE Type)
{
   UINT N;
   UINT id;

   N = Type == MasterVolume       ? 0 :
       Type == AuxVolume          ? auxGetNumDevs() :
       Type == MidiOutVolume      ? midiOutGetNumDevs() :
       Type == WaveOutVolume      ? waveOutGetNumDevs() :
       Type == MixerControlVolume ? mixerGetNumDevs() :
       0;


   for (id = 0; id < N; id++) {
      if (Type == MixerControlVolume) {
          //
          //  Find out how many suitable volume controls this mixer
          //  supports.
          //
          //  This is incredibly laborious because we can't just enumerate
          //  the controls (!).
          //
          //  This next call has the side effect of generating the mixer
          //  master stuff too and a set of mixer handles.
          //

          GetMixerControls(MixerId);
          return;
      } else {
          BOOL Volume;
          BOOL Stereo;
          TCHAR Name[MAXPNAMELEN];
          UINT Technology;

          if (ExtractInfo(id, Type, &Volume, &Stereo, Name, &Technology)) {
              if (Volume) {
                 PVOLUME_CONTROL pVol;

                 /*
                 **  Supports volume setting
                 */

                 pVol = AddNewControl();

                 if (pVol) {
                     pVol->id = id;
                     pVol->Type = Type;
                     pVol->VolumeType = Technology;
                     pVol->Stereo = Stereo;
                     pVol++;
                 }
              }
          } else {
             continue; // Don't use this one
          }
      }
   }
}

/*
 *  Create and initialize our volume array
 *
 *  On exit
 *    NumberOfDevices is set to the number of devices we want
 *    Vol is an array of size NumberOfDevices (may be 0)
 */

BOOL VolInit(VOID)
{
    int i;
    WORD wLeft, wRight, wMax, wMin, wTemp;

    /*
    **  Free any volume stuff currently present
    */

    if (Vol) {
        HGLOBAL hVol;
        int     i;

        /*
        **  Free all the windows
        */
        for (i = 0; i < NumberOfDevices; i++) {
            DestroyOurWindow(&Vol[i].hChildWnd);
            DestroyOurWindow(&Vol[i].hMeterWnd);
            DestroyOurWindow(&Vol[i].hStatic);
            DestroyOurWindow(&Vol[i].hCheckBox);
        }

        /*
        **  Free the memory
        */

        hVol = GlobalHandle(Vol);
        GlobalUnlock(hVol);
        GlobalFree(hVol);
        Vol = NULL;

        /*
        **  Initialize globals
        */

        bRecordControllable = FALSE;
    }

    /*
    **  No master volume controls found yet
    */

    FirstMasterIndex = (DWORD)-1;

    /*
     *  Scan all the device types we're interested in :
     *     wave out
     *     midi out
     *     aux
     */

     if ((DWORD)MixerId != (DWORD)-1) {
         FindDevices(MixerControlVolume);
     } else {
         for (i = WaveOutVolume; i < NumberOfDeviceTypes; i++) {
             FindDevices(i);
         }
     }

     if (NumberOfDevices == 0) {
         return FALSE;
     }

     if (FirstMasterIndex == (DWORD)-1) {
         PVOLUME_CONTROL pMaster;
         BOOL            bStereo;

         /*
         **  Find if any devices are stereo
         */

         bStereo = FALSE;

         for (i = 0; i < NumberOfDevices; i++) {
             if (Vol[i].Stereo) {
                 bStereo = TRUE;
                 break;
             }
         }

         /*
         **  Create a default volume control
         */

         pMaster = AddNewControl();
         if (pMaster == NULL) {
             return FALSE;
         }

         pMaster->Type       = MasterVolume;
         pMaster->VolumeType = -1;

         pMaster->Stereo     = bStereo;

         FirstMasterIndex = pMaster->Index;

         wLeft = (WORD)MasterLeft;
         wRight = (WORD)MasterRight;

         pMaster->LRVolume = MAKELONG(wLeft, wRight);

         if (wRight > wLeft) {
             wMax = wRight;
             wMin = wLeft;
         } else {
             wMax = wLeft;
             wMin = wRight;
         }

         if (wMax == 0) {

            pMaster->Volume = 0;
            pMaster->Balance = 0x80;       /* centered */

         } else {

            pMaster->Volume = wMax >> 8;

            wTemp = (UINT) (((DWORD) (wMax - wMin) << 7) / wMax);
            if (wTemp > 0x7f) wTemp = 0x7f;

            if (wRight > wLeft)
                pMaster->Balance = 0x80 + wTemp;
            else
                pMaster->Balance = 0x7f - wTemp;
         }

     }

     return TRUE;
}

/*
**  Called when a mixer calls us back with a control change
*/

VOID ControlChange(HMIXER hMixer, DWORD ControlId)
{
    UINT        i;
    HMIXEROBJ   MixerId;
    MMRESULT    mmr;

    mmr = mixerGetID((HMIXEROBJ)hMixer, (PUINT)&MixerId, MIXER_OBJECTF_HMIXER);

    if (mmr != MMSYSERR_NOERROR) {
        return;
    }
    for (i = 0; i < (UINT)NumberOfDevices; i++) {

        if (Vol[i].MixerId == MixerId) {
            if (Vol[i].VolumeType == VolumeTypeMixerControl) {
                if (ControlId == Vol[i].ControlId) {
                    UpdateVolume(&Vol[i]);

                    /*
                    **  Volume controls only affect one control
                    **  (unlike muxes)
                    */

                    break;
                } else {
                    if (ControlId == Vol[i].MuxControlId ||
                        ControlId == Vol[i].MuteControlId) {

                        UpdateSelected(&Vol[i]);
                    }
                }
            }
        } /* MixerId == Vol[i].MixerId */
    }
}

PVOLUME_CONTROL FirstDevice(BOOL bRecord)
{
    UINT i;
    for (i = 0; i < (UINT)NumberOfDevices; i++) {
        if (Vol[i].Type          != MasterVolume &&
            Vol[i].RecordControl == bRecord) {
            return &Vol[i];
        }
    }

    return NULL;
}
PVOLUME_CONTROL LastDevice(BOOL bRecord)
{
    UINT i;
    for (i = NumberOfDevices; i > 0; i--) {
        if (Vol[i - 1].Type          != MasterVolume &&
            Vol[i - 1].RecordControl == bRecord) {
            return &Vol[i - 1];
        }
    }

    return NULL;
}

PVOLUME_CONTROL NextDevice(PVOLUME_CONTROL pVol)
{
    UINT            i;

    for (i = pVol->Index == (UINT)NumberOfDevices - 1 ? 0 : pVol->Index + 1 ;
         i != pVol->Index;
         i = i == (UINT)NumberOfDevices - 1 ? 0 : i + 1) {

        if (Vol[i].Type != MasterVolume &&
            Vol[i].RecordControl == pVol->RecordControl) {
           break;
        }
    }

    return &Vol[i];
}

PVOLUME_CONTROL NextDeviceNoWrap(PVOLUME_CONTROL pVol)
{
    UINT            i;

    for (i = pVol->Index + 1 ;
         i < (UINT)NumberOfDevices;
         i = i + 1) {

        if (Vol[i].Type != MasterVolume &&
            Vol[i].RecordControl == pVol->RecordControl) {
           return &Vol[i];
        }
    }

    return NULL;
}
PVOLUME_CONTROL PrevDevice(PVOLUME_CONTROL pVol)
{
    UINT            i;

    for (i = pVol->Index == 0 ? NumberOfDevices - 1 : pVol->Index - 1;
         i != pVol->Index;
         i = i == 0 ? NumberOfDevices - 1 : i - 1) {

        if (Vol[i].Type != MasterVolume &&
            Vol[i].RecordControl == pVol->RecordControl) {
           return &Vol[i];
        }
    }

    return &Vol[i];
}

PVOLUME_CONTROL PrevDeviceNoWrap(PVOLUME_CONTROL pVol)
{
    UINT            i;

    for (i = pVol->Index;
         i != 0;
         i = i - 1) {

        if (Vol[i - 1].Type != MasterVolume &&
            Vol[i - 1].RecordControl == pVol->RecordControl) {
           return &Vol[i - 1];
        }
    }

    return NULL;
}

PVOLUME_CONTROL MasterDevice(BOOL bRecord)
{
    UINT i;

    for (i = 0 ; i < (UINT)NumberOfDevices; i++) {
        if (Vol[i].Type == MasterVolume &&
            Vol[i].RecordControl == bRecord) {
            return &Vol[i];
        }
    }

    return NULL;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\agfxc.cpp ===
// agfxc.cpp : Client side code for agfx.
//
// Created by FrankYe on 7/3/2000
//

#define UNICODE
#define _UNICODE

#include <windows.h>
#include <mmsystem.h>
#include <mmsysp.h>
#include <tchar.h>
#include <regstr.h>
#include <ks.h>
#include <ksmedia.h>
#include "agfxp.h"
#include "audiosrv.h"
#include "audiosrvc.h"

// ISSUE-2000/09/25-FrankYe TODO list
// - move heap helpers somewhere else
// - remove ClientUpdatePnpInfo, and hHeap extern definitions

extern "C" void ClientUpdatePnpInfo(void);
extern "C" HANDLE hHeap;

//
// This global variable tracks the most device interfaces contained in any
// DEVICEINTERFACELIST structure created by these functions.  This helps
// validate the input to gfxDestroyDeviceInterfaceList
//
LONG gcMostDeviceInterfaces = 0;

#define RPC_CALL_START RpcTryExcept {
#define RPC_CALL_END_(status) } RpcExcept(1) { status = RpcExceptionCode(); } RpcEndExcept
#define RPC_CALL_END } RpcExcept(1) { RpcExceptionCode(); } RpcEndExcept

//=============================================================================
//===   Heap helpers   ===
//=============================================================================
static BOOL HeapFreeIfNotNull(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)
{
    return lpMem ? HeapFree(hHeap, dwFlags, lpMem) : TRUE;
}


//=============================================================================
//===   gfx API   ===
//=============================================================================
WINMMAPI LONG WINAPI gfxModifyGfx(DWORD Id, ULONG Order)
{
    LONG status;
    ClientUpdatePnpInfo();
    RPC_CALL_START;
    status = s_gfxModifyGfx(Id, Order);
    RPC_CALL_END_(status);
    return status;
}


WINMMAPI LONG WINAPI gfxAddGfx(IN PCWSTR ZoneFactoryDi, IN PCWSTR GfxFactoryDi, IN ULONG Type, IN ULONG Order, OUT PULONG pNewId)
{
    LONG status;
    
    if (IsBadStringPtr(ZoneFactoryDi, (UINT_PTR)(-1))) return ERROR_INVALID_PARAMETER;    
    if (IsBadStringPtr(GfxFactoryDi, (UINT_PTR)(-1))) return ERROR_INVALID_PARAMETER;
    if (IsBadWritePtr(pNewId, sizeof(*pNewId))) return ERROR_INVALID_PARAMETER;
    
    ClientUpdatePnpInfo();
    
    RPC_CALL_START;
    status = s_gfxAddGfx((PWSTR)ZoneFactoryDi, (PWSTR)GfxFactoryDi, Type, Order, pNewId);
    RPC_CALL_END_(status);
    return status;
}


WINMMAPI LONG WINAPI gfxRemoveGfx(DWORD Id)
{
    LONG status;
    ClientUpdatePnpInfo();
    RPC_CALL_START;
    status = s_gfxRemoveGfx(Id);
    RPC_CALL_END_(status);
    return status;
}

WINMMAPI LONG WINAPI gfxDestroyDeviceInterfaceList(PDEVICEINTERFACELIST pDiList)
{
    LONG Count;
    PTSTR *ppDi;
    LONG result;

    if (IsBadReadPtr(&pDiList->Count, sizeof(pDiList->Count))) return ERROR_INVALID_PARAMETER;
    Count = pDiList->Count;
    if (Count < 0 || Count > gcMostDeviceInterfaces) return ERROR_INVALID_PARAMETER;
    if (IsBadWritePtr(pDiList, (PBYTE)&pDiList->DeviceInterface[Count] - (PBYTE)pDiList)) return ERROR_INVALID_PARAMETER;
    ppDi = &pDiList->DeviceInterface[0];
    while (Count-- > 0) if (IsBadStringPtr(*ppDi, (UINT_PTR)(-1))) return ERROR_INVALID_PARAMETER;

    // Now we are reasonably confident that we have good input
    // parameters.  We design the following logic to return the
    // first error encountered, if any.

    ClientUpdatePnpInfo();
    
    result = NO_ERROR;
    Count = pDiList->Count;
    ppDi = &pDiList->DeviceInterface[0];
    while (Count-- > 0) if (!HeapFree(hHeap, 0, *(ppDi++)) && (NO_ERROR == result)) result = GetLastError();
    if ((!HeapFree(hHeap, 0, pDiList)) && (NO_ERROR == result)) result = GetLastError();

    SetLastError(result);
    return result;
}

WINMMAPI LONG WINAPI gfxEnumerateGfxs(PCWSTR ZoneFactoryDi, GFXENUMCALLBACK pGfxEnumCallback, PVOID Context)
{
    LONG lresult;
    UNIQUE_PGFXLIST pGfxList = NULL;

    if (IsBadStringPtr(ZoneFactoryDi, (UINT_PTR)(-1))) return ERROR_INVALID_PARAMETER;
    if (IsBadCodePtr((FARPROC)pGfxEnumCallback)) return ERROR_INVALID_PARAMETER;

    ClientUpdatePnpInfo();
    
    RPC_CALL_START;
    lresult = s_gfxCreateGfxList((PWSTR)ZoneFactoryDi, &pGfxList);
    RPC_CALL_END_(lresult);
    // ISSUE-2000/09/25-FrankYe Should not have to check for pGfxList != NULL. Fix this interface
    if (!lresult && pGfxList)
    {
	if (pGfxList->Count > 0)
	{
	    int i = 0;

	    while (i < pGfxList->Count)
	    {
		if (!lresult) lresult = pGfxEnumCallback(Context,
							 pGfxList->Gfx[i].Id,
							 pGfxList->Gfx[i].GfxFactoryDi,
							 *(LPCLSID)(&pGfxList->Gfx[i].Clsid),
							 pGfxList->Gfx[i].Type,
							 pGfxList->Gfx[i].Order);
		HeapFree(hHeap, 0, pGfxList->Gfx[i].GfxFactoryDi);
		i++;
	    }
	}

	HeapFree(hHeap, 0, pGfxList);
    }

    return lresult;
}

WINMMAPI LONG WINAPI gfxCreateGfxFactoriesList(PCWSTR ZoneFactoryDi, OUT PDEVICEINTERFACELIST *ppDiList)
{
    LONG lresult;
    UNIQUE_PDILIST pDiList = NULL;

    if (IsBadWritePtr(ppDiList, sizeof(*ppDiList))) return ERROR_INVALID_PARAMETER;

    ClientUpdatePnpInfo();
    
    RPC_CALL_START;
    lresult = s_gfxCreateGfxFactoriesList((PWSTR)ZoneFactoryDi, &pDiList);
    RPC_CALL_END_(lresult);

    if (!lresult) {
        gcMostDeviceInterfaces = max(gcMostDeviceInterfaces, pDiList->Count);
        *ppDiList = (PDEVICEINTERFACELIST)pDiList;
    }
    
    return lresult;
}

WINMMAPI LONG WINAPI gfxCreateZoneFactoriesList(OUT PDEVICEINTERFACELIST *ppDiList)
{
    LONG lresult;
    UNIQUE_PDILIST pDiList = NULL;

    if (IsBadWritePtr(ppDiList, sizeof(*ppDiList))) return ERROR_INVALID_PARAMETER;

    ClientUpdatePnpInfo();
    
    RPC_CALL_START;
    lresult = s_gfxCreateZoneFactoriesList(&pDiList);
    RPC_CALL_END_(lresult);

    if (!lresult) {
        gcMostDeviceInterfaces = max(gcMostDeviceInterfaces, pDiList->Count);
        *ppDiList = (PDEVICEINTERFACELIST)pDiList;
    }
    
    return lresult;
}

WINMMAPI LONG WINAPI gfxBatchChange(PGFXREMOVEREQUEST paGfxRemoveRequests, ULONG cGfxRemoveRequests,
	                   PGFXMODIFYREQUEST paGfxModifyRequests, ULONG cGfxModifyRequests,
		           PGFXADDREQUEST    paGfxAddRequests,    ULONG cGfxAddRequests)
{
    ULONG Index;
    LONG  Error;

    if ((cGfxRemoveRequests > 0) && IsBadWritePtr(paGfxRemoveRequests, cGfxRemoveRequests * sizeof(*paGfxRemoveRequests))) return ERROR_INVALID_PARAMETER;
    if ((cGfxModifyRequests > 0) && IsBadWritePtr(paGfxModifyRequests, cGfxModifyRequests * sizeof(*paGfxModifyRequests))) return ERROR_INVALID_PARAMETER;
    if ((cGfxAddRequests > 0)    && IsBadWritePtr(paGfxAddRequests,    cGfxAddRequests    * sizeof(*paGfxAddRequests)))    return ERROR_INVALID_PARAMETER;

    ClientUpdatePnpInfo();
    
    Error = ERROR_SUCCESS;
    for (Index = 0; Index < cGfxRemoveRequests && ERROR_SUCCESS == Error; Index++)
    {
	Error = gfxRemoveGfx(paGfxRemoveRequests[Index].IdToRemove);
	paGfxRemoveRequests[Index].Error = Error;
    }

    for (Index = 0; Index < cGfxModifyRequests && ERROR_SUCCESS == Error; Index++)
    {
	Error = gfxModifyGfx(paGfxModifyRequests[Index].IdToModify,
		             paGfxModifyRequests[Index].NewOrder);
	paGfxModifyRequests[Index].Error = Error;
    }

    for (Index = 0; Index < cGfxAddRequests && ERROR_SUCCESS == Error; Index++)
    {
	Error = gfxAddGfx(paGfxAddRequests[Index].ZoneFactoryDi,
			  paGfxAddRequests[Index].GfxFactoryDi,
			  paGfxAddRequests[Index].Type,
			  paGfxAddRequests[Index].Order,
			 &paGfxAddRequests[Index].NewId);
	paGfxAddRequests[Index].Error = Error;
    }

    return Error;
}

WINMMAPI LONG WINAPI gfxOpenGfx(DWORD dwGfxId, PHANDLE pFileHandle)
{
    LONG status;
    ClientUpdatePnpInfo();
    RPC_CALL_START;
    status = s_gfxOpenGfx(GetCurrentProcessId(), dwGfxId, (RHANDLE*)pFileHandle);
    RPC_CALL_END_(status);
    return status;
}

WINMMAPI void WINAPI gfxLogon(DWORD dwProcessId)
{
    ClientUpdatePnpInfo();
    RPC_CALL_START;
    s_gfxLogon(AudioSrv_IfHandle, dwProcessId);
    RPC_CALL_END;
}

WINMMAPI void WINAPI gfxLogoff(void)
{
    ClientUpdatePnpInfo();
    RPC_CALL_START;
    s_gfxLogoff();
    RPC_CALL_END;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\sndrec32\soundrec\wavedisp.c ===
/* (C) Copyright Microsoft Corporation 1991.  All Rights Reserved */
/* wavedisp.c
 *
 * Implements waveform display control ("td_wavedisplay").
 *
 * This is NOT a general-purpose control (see the globals below).
 *
 * The waveform is represented as a string of characters in a font that
 * consists of vertical lines that correspond to different amplitudes.
 * Actually there is no font, it's just done with patBlts
 *
 * WARNING: this control cheats: it stores information in globals, so you
 * couldn't put it in a DLL (or use two of them in the same app)
 * without changing it.
 */
/* Revision History.
 *  4/2/92 LaurieGr (AKA LKG) Ported to WIN32 / WIN16 common code
 *  25/6/92LaurieGr enhanced, Also had to reformat to 80 cols because
 *                  NT has only crappy fonts again.
 *  21/Feb/94 LaurieGr merged Daytona and Motown versions
 */

#include "nocrap.h"
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <math.h>
#include "SoundRec.h"

/* constants */
#define MAX_TRIGGER_SEARCH  200     // limit search for trigger pt.
#define MIN_TRIGGER_SAMPLE  (128 - 8)   // look for silent part
#define MAX_TRIGGER_SAMPLE  (128 + 8)   // look for silent part

#define MIN_TRIG16_SAMPLE   (-1024)     // look for silent part
#define MAX_TRIG16_SAMPLE   (1024)      // look for silent part


/* globals */
static NPBYTE   gpbWaveDisplay;         // text string in WaveLine font
                                        // initially has samples in it
                                        // enough room for 4 bytes/sample
static RECT     grcWaveDisplay;         // wave display rectangle
static HBITMAP  ghbmWaveDisplay;        // mono bitmap.
static HDC      ghdcWaveDisplay;        // memory DC for bitmap.
// static iXScale = 1;                     // samples per pel across screen

/* UpdateWaveDisplayString()
 *
 * Copy samples from just before the current position in the sample buffer
 * to the wave display string.  The code tries to find a good "trigger point"
 * in the waveform so that the waveform will be aligned at the beginning of
 * a wave.
 *
 * The current position is in gpWaveSamples at glWavePosition which is
 * measured in samples (not bytes).
 *
 * The wave display string will contain numbers in the range -16..15
 *
 *  for 8  bit:   x' = abs(x-128)/8
 *  for 16 bit:   x' = abs(x)/2048
 *
 * When the display is "in motion" (i.e. actually playing or recording
 * we try to keep the display somewhat static by looking for a trigger
 * point (like an oscilloscope would) and display that part of the wave
 * that has just either played or been recorded.
 *
 */
static void NEAR PASCAL
UpdateWaveDisplayString(void)
{

    // piSrc and pbSrc are init NULL to kill a compiler diagnostic.
    // The compiler cannot follow the logic and thinks that they may be
    // used before being set.  (It's wrong. Hint: look at cbSrc and cbTrigger)

    BYTE *  pbSrc = NULL;   // pointer into <gpWaveSamples> to 8 bits
    short * piSrc = NULL;   // pointer into <gpWaveSamples> to 16 bits
                            // (use one or other according to wave format)

    int     cbSrc;          // number of samples that can be copied
    BYTE *  pbDst;          // pointer into <gpbWaveDisplay>
    int     cbDst;          // size of <gpWaveDisplay>
    int     cbTrigger;      // limit the search for a "trigger"
    BYTE    b;
    int     i;
    int     cnt;

    WORD    nSkipChannels;
    BOOL    fStereoIn;
    BOOL    fEightIn;

    cbDst = grcWaveDisplay.right - grcWaveDisplay.left; // rectangle size
    pbDst = gpbWaveDisplay;

    // Note: IsWaveFormatPCM() is called before this function is ever called, therefore
    //       we can always rely on the fact that gpWaveFormat->wwFormatTag == WAVE_FORMAT_PCM.
    //       This also implies, as mentioned in the docs on WAVEFORMATEX, that the
    //       gpWaveFormat->wBitsPerSample should be equal to 8 or 16.

    // Note: We average the first two channels if they exist, any additional channels are 
    //       ignored.
    
    fStereoIn = gpWaveFormat->nChannels != 1;
    fEightIn  = ((LPWAVEFORMATEX)gpWaveFormat)->wBitsPerSample == 8;
    nSkipChannels = max (0, gpWaveFormat->nChannels - 2);
    
    /* search for a "trigger point" if we are recording or playing */
    if ((ghWaveOut != NULL) || (ghWaveIn != NULL))
    {   // we are in motion - align the *right* hand side of the window.
        cbTrigger = MAX_TRIGGER_SEARCH;

        if (gpWaveSamples == NULL)
        {
            /* no document at all is open */
            cbSrc = 0;
        }
        else
        {
            long    lStartOffsetSrc, lEndOffsetSrc;

            /* align the *right* side of wave display to the current
             * position in the wave buffer, so that during recording
             * we see only samples that have just been recorded
             */
            lStartOffsetSrc = glWavePosition - (cbDst + cbTrigger);
            lEndOffsetSrc = glWavePosition;
            if (lStartOffsetSrc < 0)
                lEndOffsetSrc -= lStartOffsetSrc, lStartOffsetSrc = 0L;
            if (lEndOffsetSrc > glWaveSamplesValid)
                lEndOffsetSrc = glWaveSamplesValid;

            // Bombay Bug 1360: lStartOffsetSrc > lEndOffsetSrc causes GP Fault
            // if glWaveSamplesValid < lStartOffsetSrc we have a problem.

            if (lStartOffsetSrc > lEndOffsetSrc)
            {
                lStartOffsetSrc = lEndOffsetSrc - (cbDst + cbTrigger);
                if (lStartOffsetSrc < 0)
                    lStartOffsetSrc = 0L;
            }

            cbSrc = (int)wfSamplesToBytes(gpWaveFormat, lEndOffsetSrc - lStartOffsetSrc);

            /* copy samples from buffer into local one */
            memmove( gpbWaveDisplay
                   , gpWaveSamples + wfSamplesToBytes(gpWaveFormat, lStartOffsetSrc)
                   , cbSrc
                   );

            pbSrc = (BYTE *) gpbWaveDisplay;
            piSrc = (short *) gpbWaveDisplay;
        }

        if (cbTrigger > 0) {
            cbTrigger = min(cbSrc, cbTrigger);   // don't look beyond buffer end

            /* search for a silent part in waveform */
            if (fEightIn)
            {
                while (cbTrigger > 0)
                {
                    b = *pbSrc;
                    if ((b > MIN_TRIGGER_SAMPLE) && (b < MAX_TRIGGER_SAMPLE))
                        break;
                    cbSrc--, pbSrc++, cbTrigger--;
                    if (fStereoIn)
                        pbSrc+=(nSkipChannels+1);
                }
            }
            else
            {   // not EightIn
                while (cbTrigger > 0)
                {
                    i = *piSrc;
                    if ((i > MIN_TRIG16_SAMPLE) && (i < MAX_TRIG16_SAMPLE))
                        break;
                    cbSrc--, piSrc++, cbTrigger--;
                    if (fStereoIn)
                        piSrc+=(nSkipChannels+1);
                }
            }

            /* search for a non-silent part in waveform (this is the "trigger") */
            if (fEightIn)
            {
                while (cbTrigger > 0)
                {
                    b = *pbSrc;
                    if ((b <= MIN_TRIGGER_SAMPLE) || (b >= MAX_TRIGGER_SAMPLE))
                        break;
                    cbSrc--, pbSrc++, cbTrigger--;
                    if (fStereoIn)
                        pbSrc+=(nSkipChannels+1);
                }
            }
            else
            {   // not EightIn
                while (cbTrigger > 0)
                {
                    i = *piSrc;
                    if ((i <= MIN_TRIG16_SAMPLE) || (i >= MAX_TRIG16_SAMPLE))
                        break;
                    cbSrc--, piSrc++, cbTrigger--;
                    if (fStereoIn)
                        piSrc+=(nSkipChannels+1);
                }
            }
        }
    }
    else  // it's not playing or recording - static display
    {
        long    lStartOffsetSrc, lEndOffsetSrc;

        /* align the *left* side of wave display to the current
         * position in the wave buffer
         */
        lStartOffsetSrc = glWavePosition;
        lEndOffsetSrc = glWavePosition + cbDst;
        if (lEndOffsetSrc > glWaveSamplesValid)
            lEndOffsetSrc = glWaveSamplesValid;

        cbSrc = (int)wfSamplesToBytes( gpWaveFormat
                                     , lEndOffsetSrc - lStartOffsetSrc
                                     );

        //
        // copy samples from buffer into local one
        //
        memmove( gpbWaveDisplay
               , gpWaveSamples
                 + wfSamplesToBytes(gpWaveFormat, lStartOffsetSrc)
               , cbSrc
               );

        pbSrc = (BYTE *) gpbWaveDisplay;
        piSrc = (short *) gpbWaveDisplay;
    }

    cnt = min(cbSrc, cbDst);
    cbDst -= cnt;

    /* map cnt number of samples from pbSrc to string characters at pbDst
    ** fEightIn => 8 byte samples, else 16
    ** fStereoIn => Average left and right channels
    **
    ** pbSrc and pbDst both point into the same buffer addressed by
    ** gpbWaveDisplay, pbSrc >= pbDst.  We process left to right, so OK.
    */

    if (fEightIn)
    {
        BYTE *pbDC = pbDst;
        int dccnt = cnt;
        DWORD dwSum = 0L;
        
        while (cnt-- > 0)
        {
            b = *pbSrc++;
            if (fStereoIn)
            {
                // Average left and right channels.
                b /= 2;
                b += (*pbSrc++ / 2);
                // Skip channels past Stereo
                pbSrc+=nSkipChannels;
            }
            dwSum += *pbDst++ = (BYTE)(b/8 + 112);   // 128 + (b-128)/8            
        }

        /* Eliminate DC offsets by subtracting the average offset
         * over all samples.
         */
        if (dwSum)
        {
            dwSum /= (DWORD)dccnt;
            dwSum -= 128;
            while (dwSum && dccnt-- > 0)
                *pbDC++ -= (BYTE)dwSum;
        }
        
    }
    else
    {
        BYTE *pbDC = pbDst;
        int dccnt = cnt;
        LONG lSum = 0L;
        
        while (cnt-- > 0)
        {
            i = *piSrc++;
            if (fStereoIn)
            {
                // Average left and right channels.
                i /= 2;
                i += (*piSrc++ / 2);
                // Skip channels past Stereo
                piSrc+=nSkipChannels;
            }
            lSum += *pbDst++ = (BYTE)(i/2048 + 128);
        }
        
        /* Eliminate DC offsets by subtracting the average offset
         * over all samples.
         */
        if (lSum)
        {
            lSum /= dccnt;
            lSum -= 128;
            while (lSum && dccnt-- > 0)
                *pbDC++ -= (BYTE)lSum;
        }
        
    }
    /* if necessary, pad the strings with whatever character represents
     * the "silence level".  This is 128, the midpoint level.
     */
    while (cbDst-- > 0)
        *pbDst++ = 128;
}

/* WaveDisplayWndProc()
 *
 * This is the window procedure for the "WaveDisplay" control.
 */
INT_PTR CALLBACK
WaveDisplayWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT ps;
    RECT        rc;
    int         i;
    int         n;
    int         dx;
    int         dy;

    switch (wMsg)
    {
    case WM_CREATE:
        /* make the window a bit bigger so that it lines up with
         * the frames of the shadow-frames beside it
         */

        /* allocate <gpbWaveDisplay> */
        GetClientRect(hwnd, &grcWaveDisplay);
        InflateRect(&grcWaveDisplay, -1, -1); // account for border

        gpbWaveDisplay = (NPBYTE)GlobalAllocPtr(GHND,
                         (grcWaveDisplay.right+MAX_TRIGGER_SEARCH) * 4);
                         // 4 is the maximum bytes per sample allowed

        if (gpbWaveDisplay == NULL)
                return -1;                   // out of memory

        ghdcWaveDisplay = CreateCompatibleDC(NULL);

        if (ghdcWaveDisplay == NULL)
                return -1;                   // out of memory

        ghbmWaveDisplay = CreateBitmap(
                grcWaveDisplay.right-grcWaveDisplay.left,
                grcWaveDisplay.bottom-grcWaveDisplay.top,
                1,1,NULL);

        if (ghbmWaveDisplay == NULL)
                return -1;                   // out of memory

        SelectObject(ghdcWaveDisplay, ghbmWaveDisplay);
        break;

    case WM_DESTROY:
        /* free <gpbWaveDisplay> */
        if (gpbWaveDisplay != NULL)
        {
                GlobalFreePtr(gpbWaveDisplay);
                gpbWaveDisplay = NULL;
        }

        if (ghbmWaveDisplay != NULL)
        {
                DeleteDC(ghdcWaveDisplay);
                DeleteObject(ghbmWaveDisplay);
                ghdcWaveDisplay = NULL;
                ghbmWaveDisplay = NULL;
        }

        break;

    case WM_ERASEBKGND:
        /* draw the border and fill */
        GetClientRect(hwnd, &rc);
        DrawShadowFrame((HDC)wParam, &rc);
        return 0L;

    case WM_PAINT:
        BeginPaint(hwnd, &ps);

        if (!IsWaveFormatPCM(gpWaveFormat))
        {
                FillRect(ps.hdc, &grcWaveDisplay, ghbrPanel);
        }
        else if (gpbWaveDisplay != NULL)
        {
            /* update <gpbWaveDisplay> */
            UpdateWaveDisplayString();

            dx = grcWaveDisplay.right-grcWaveDisplay.left;
            dy = grcWaveDisplay.bottom-grcWaveDisplay.top;

            //
            // update the bitmap.
            //
            PatBlt(ghdcWaveDisplay,0,0,dx,dy,BLACKNESS);
            PatBlt(ghdcWaveDisplay,0,dy/2,dx,1,WHITENESS);

            for (i=0; i<dx; i++)
            {
                n = (BYTE)gpbWaveDisplay[i];  // n.b. must get it UNSIGNED
                n = n-128;                    // -16..15

                if (n > 0)
                    PatBlt(ghdcWaveDisplay,
                           i, dy/2-n,
                           1, n*2+1,         WHITENESS);
                
                if (n < -1)
                {
                    n++;                      // neg peak == pos peak
                    PatBlt(ghdcWaveDisplay,
                        i, dy/2+n,
                        1, -(n*2)+1,      WHITENESS);
                }
            }

            /* draw the waveform */
            SetTextColor(ps.hdc, RGB_BGWAVEDISP);
            SetBkColor(ps.hdc, RGB_FGWAVEDISP);

            BitBlt(ps.hdc, grcWaveDisplay.left, grcWaveDisplay.top,
                dx,dy, ghdcWaveDisplay, 0, 0, SRCCOPY);
        }

        EndPaint(hwnd, &ps);
        return 0L;
    }

    return DefWindowProc(hwnd, wMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\audiosrvc.h ===
//
// Audio server
//
EXTERN_C LONG AudioSrvBinding(void);
EXTERN_C void AudioSrvBindingFree(void);
EXTERN_C BOOL winmmWaitForService(void);
EXTERN_C LONG winmmRegisterSessionNotificationEvent(HANDLE hEvent, PHANDLE phNotify);
EXTERN_C LONG winmmUnregisterSessionNotification(HANDLE hNotify);
EXTERN_C LONG winmmSessionConnectState(PINT ConnectState);
EXTERN_C LONG wdmDriverOpenDrvRegKey(IN PCTSTR DeviceInterface, IN REGSAM samDesired, OUT HKEY *phkey);
EXTERN_C void winmmAdvisePreferredDeviceChange(void);
EXTERN_C LONG winmmGetPnpInfo(OUT LONG *pcbPnpInfo, OUT PMMPNPINFO *ppPnpInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\audiosrvc.c ===
/* File: audiosrvc.c                             */
/* Copyright (c) 2000-2001 Microsoft Corporation */

#define UNICODE
#define _UNICODE

#include "winmmi.h"
#include "audiosrv.h" 
 
#define RPC_CALL_START RpcTryExcept {
#define RPC_CALL_END_(status) } RpcExcept(1) { status = RpcExceptionCode(); } RpcEndExcept
#define RPC_CALL_END } RpcExcept(1) { RpcExceptionCode(); } RpcEndExcept

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t cb)
{
    return HeapAlloc(hHeap, HEAP_ZERO_MEMORY, cb);
}

void  __RPC_USER MIDL_user_free( void __RPC_FAR * pv)
{
    HeapFree(hHeap, 0, pv);
}

LONG AudioSrvBinding(void)
{
    RPC_STATUS status;
    PTSTR pszUuid             = NULL;
    PTSTR pszProtocolSequence = TEXT("ncalrpc");
    PTSTR pszNetworkAddress   = NULL;
    PTSTR pszEndpoint         = TEXT("AudioSrv");
    PTSTR pszOptions          = NULL;
    PTSTR pszStringBinding    = NULL;
    PTSTR pszString           = NULL;

    // dprintf(("AudioSrvBinding"));

    WinAssert(NULL == AudioSrv_IfHandle);
    
    status = RpcStringBindingCompose(pszUuid,
                                     pszProtocolSequence,
                                     pszNetworkAddress,
                                     pszEndpoint,
                                     pszOptions,
                                     &pszStringBinding);

    if (RPC_S_OK == status)
    {
        status = RpcBindingFromStringBinding(pszStringBinding, &AudioSrv_IfHandle);
        RpcStringFree(&pszStringBinding);
    }

    if (RPC_S_OK != status) dprintf(("AudioSrvBinding: returning %d", status));

    return status;
}

void AudioSrvBindingFree(void)
{
    RPC_STATUS status;
    
    // dprintf(("AudioSrvBindingFree"));

    status = AudioSrv_IfHandle ? RpcBindingFree(&AudioSrv_IfHandle) : RPC_S_OK;
    if (RPC_S_OK == status) WinAssert(NULL == AudioSrv_IfHandle);
    
    if (RPC_S_OK != status) dprintf(("AudioSrvBindingFree: RpcBindingFree returned %d", status));
}

BOOL winmmWaitForService(void)
{
    static BOOL fWaited = FALSE;
    static BOOL fStarted = FALSE;

    const LONG Timeout = 120000;

    SC_HANDLE schScm = NULL;
    SC_HANDLE schAudioSrv = NULL;

    if (fWaited) return fStarted;

    schScm = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (!schScm)
    {
        DWORD dw = GetLastError();
        dprintf(("winmmWaitForService: could not OpenSCManager, LastError=%d", dw));
        return FALSE;
    }

    schAudioSrv = OpenService(schScm, TEXT("AudioSrv"), SERVICE_QUERY_CONFIG | SERVICE_QUERY_STATUS);
    if (schAudioSrv)
    {
        int cWaits = 0;
        while (!fWaited) {
            SERVICE_STATUS ServiceStatus;
    
            if (QueryServiceStatus(schAudioSrv, &ServiceStatus))
            {
                if ( (ServiceStatus.dwCurrentState == SERVICE_RUNNING) ||
                     (ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING) ||
                     (ServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING) ||
                     (ServiceStatus.dwCurrentState == SERVICE_PAUSED) )
                {
                    fStarted = TRUE;
                    fWaited = TRUE;
                }  else if (ServiceStatus.dwCurrentState == SERVICE_STOPPED &&
                            ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_NEVER_STARTED)
                {
                    if (cWaits == 0)
                    {
                        DWORD cbNeeded;

                        // Check that the service StartType is set such that
                        // it will start
                        if (QueryServiceConfig(schAudioSrv, NULL, 0, &cbNeeded) || ERROR_INSUFFICIENT_BUFFER == GetLastError())
                        {
                            QUERY_SERVICE_CONFIG *ServiceConfig;
                            ServiceConfig = HeapAlloc(hHeap, 0, cbNeeded);
                            if (ServiceConfig) {
                                if (QueryServiceConfig(schAudioSrv, ServiceConfig, cbNeeded, &cbNeeded)) {
                                    if (ServiceConfig->dwStartType != SERVICE_AUTO_START) {
                                        fWaited = TRUE;
                                    }
                                } else {
                                    DWORD dwLastError = GetLastError();
                                    dprintf(("winmmWaitForService: QueryServiceConfig failed LastError=%d", dwLastError));
                                    fWaited = TRUE;
                                }
                                HeapFree(hHeap, 0, ServiceConfig);
                            } else {
                                dprintf(("winmmWaitForService: HeapAlloc failed"));
                            }
                        } else {
                            DWORD dwLastError = GetLastError();
                            dprintf(("winmmWaitForService: QueryServiceConfig failed LastError=%d", dwLastError));
                            fWaited = TRUE;
                        }
                    }
                } else if (ServiceStatus.dwCurrentState != SERVICE_START_PENDING)
                {
                    // Unfamiliar dwCurrentState, or was started and then stopped
                    fWaited = TRUE;
                }
            } else {
                DWORD dwLastError = GetLastError();
                dprintf(("winmmWaitForService: QueryServiceStatus failed LastError=%d", dwLastError));
                fWaited = TRUE;
            }

            if (!fWaited && ((cWaits * 2000) > Timeout))
            {
                dprintf(("winmmWaitForService timed out.  Could be design problem.  Open a bug!"));
                WinAssert(FALSE);
                fWaited = TRUE;
            }
                
            if (!fWaited) {
                Sleep(2000);
                cWaits++;
            }
        }
        CloseServiceHandle(schAudioSrv);
    } else {
        DWORD dwLastError = GetLastError();
        dprintf(("winmmWaitForService: OpenService failed LastError=%d", dwLastError));
    }

    CloseServiceHandle(schScm);

    return fStarted;
}


LONG winmmRegisterSessionNotificationEvent(HANDLE hEvent, PHANDLE phRegNotify)
{
    LONG lresult;
    winmmWaitForService();
    RPC_CALL_START;
    lresult = s_winmmRegisterSessionNotificationEvent(GetCurrentProcessId(), (RHANDLE)hEvent, (PHANDLE_SESSIONNOTIFICATION)phRegNotify);
    RPC_CALL_END_(lresult);
    return lresult;
}

LONG winmmUnregisterSessionNotification(HANDLE hRegNotify)
{
    LONG lresult;

    winmmWaitForService();
    
    RPC_CALL_START;
    
    // if (!AudioSrv_IfHandle) dprintf(("winmmUnregisterSessionNotification : warning: called with AudioSrv_IfHandle == NULL"));

    // If we have a binding handle, then let's call the server to close this
    // context handle otherwise we need to call RpcSsDestroyClientContext to
    // destroy it without contacting the server
    if (AudioSrv_IfHandle)
    {
    	lresult = s_winmmUnregisterSessionNotification((PHANDLE_SESSIONNOTIFICATION)&hRegNotify);
    }
    else
    {
    	RpcSsDestroyClientContext(&hRegNotify);
        lresult = RPC_S_OK;
    }
    
    RPC_CALL_END_(lresult);
    return lresult;
}
LONG winmmSessionConnectState(PINT ConnectState)
{
    LONG lresult;
    winmmWaitForService();
    RPC_CALL_START;
    lresult = s_winmmSessionConnectState(GetCurrentProcessId(), ConnectState);
    RPC_CALL_END_(lresult);
    return lresult;
}

LONG wdmDriverOpenDrvRegKey(IN PCTSTR DeviceInterface, IN REGSAM samDesired, OUT HKEY *phkey)
{
    LONG lresult;
    winmmWaitForService();
    RPC_CALL_START;
    lresult = s_wdmDriverOpenDrvRegKey(GetCurrentProcessId(), DeviceInterface, samDesired, (RHANDLE*)phkey);
    RPC_CALL_END_(lresult);
    return lresult;
}

void winmmAdvisePreferredDeviceChange(void)
{
    winmmWaitForService();
    RPC_CALL_START;
    s_winmmAdvisePreferredDeviceChange();
    RPC_CALL_END;
    return;
}

LONG winmmGetPnpInfo(OUT LONG *pcbPnpInfo, OUT PMMPNPINFO *ppPnpInfo)
{
    LONG cbPnpInfo = 0;
    BYTE *pPnpInfo = NULL;
    LONG lresult;
    
    winmmWaitForService();
    RPC_CALL_START;
    lresult = s_winmmGetPnpInfo(&cbPnpInfo, &pPnpInfo);
    RPC_CALL_END_(lresult);
    if (ERROR_SUCCESS == lresult)
    {
    	*pcbPnpInfo = cbPnpInfo;
    	*ppPnpInfo = (PMMPNPINFO)pPnpInfo;
    }
    return lresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\csrthrd.c ===
/******************************************************************************

   Copyright (c) 1993-1998 Microsoft Corporation

   Title:   csrthrd.c - code to create a thread inside the server process

*****************************************************************************/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntcsrsrv.h>
#include <windows.h>

typedef PVOID (NTAPI *ADD_SERVER_THREAD)(HANDLE, PCLIENT_ID, ULONG);

/*
**  Create a server thread
*/

BOOLEAN CreateServerPlayingThread(PVOID ThreadStartRoutine)
{
    CLIENT_ID ClientId;
    HANDLE    hThread;

    hThread = NULL;

    RtlCreateUserThread(NtCurrentProcess(),
                        NULL,
                        (BOOLEAN)TRUE,
                        0,
                        0,
                        0,
                        (PUSER_THREAD_START_ROUTINE)ThreadStartRoutine,
                        NULL,
                        &hThread,
                        &ClientId);

    if (!hThread) {
#if DBG
        OutputDebugStringA("WINMM: Server failed to create user thread\n");
#endif
        return FALSE;

    } else {
        HMODULE hModCSR;
        ADD_SERVER_THREAD pCsrAddStaticServerThread;

        hModCSR = GetModuleHandleW((LPCWSTR)L"csrsrv.dll");

#if DBG
        if (hModCSR == NULL) {
            OutputDebugStringA("WINMM: Could not get CSRSRV.DLL handle\n");
            DebugBreak();
        }
#endif

        pCsrAddStaticServerThread =
            (ADD_SERVER_THREAD)GetProcAddress(hModCSR, "CsrAddStaticServerThread");

        if (pCsrAddStaticServerThread == NULL) {
#if DBG
            OutputDebugStringA("WINMM: Could not get address if CsrAddStaticServerThread\n");
            DebugBreak();
#endif
            return FALSE;
        }

        (*pCsrAddStaticServerThread)(hThread, &ClientId, 0);

        /*
        * Resume the sound thread now that we've initialising things.
        */

        NtResumeThread(hThread, NULL);
        //NtClose(hThread);

        return TRUE;
    }
}

HANDLE CreatePnpNotifyThread(PVOID ThreadStartRoutine)
{
    CLIENT_ID   ClientId;
    HANDLE      hThread;

    hThread = NULL;

    RtlCreateUserThread(NtCurrentProcess(),
                        NULL,
                        (BOOLEAN)TRUE,
                        0,
                        0,
                        0,
                        (PUSER_THREAD_START_ROUTINE)ThreadStartRoutine,
                        NULL,
                        &hThread,
                        &ClientId);

    if (NULL == hThread)
    {
#if DBG
        OutputDebugStringA("WINMM: Server failed to create PnpNotify thread\n");
#endif
        return FALSE;

    } else {
        HMODULE hModCSR;
        ADD_SERVER_THREAD pCsrAddStaticServerThread;

        hModCSR = GetModuleHandleW((LPCWSTR)L"csrsrv.dll");

#if DBG
        if (NULL == hModCSR)
        {
            OutputDebugStringA("WINMM: Could not get CSRSRV.DLL handle");
            DebugBreak();
        }
#endif

        pCsrAddStaticServerThread =
            (ADD_SERVER_THREAD)GetProcAddress(hModCSR, "CsrAddStaticServerThread");

        if (pCsrAddStaticServerThread == NULL) {
#if DBG
            OutputDebugStringA("WINMM: Could not get address if CsrAddStaticServerThread\n");
            DebugBreak();
#endif
            return FALSE;
        }

        (*pCsrAddStaticServerThread)(hThread, &ClientId, 0);

        /*
        * Resume the sound thread now that we've initialising things.
        */

        NtResumeThread(hThread, NULL);
        //NtClose(hThread);

        return hThread;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\drvr.h ===
/******************************************************************************

   Copyright (c) 1985-1998 Microsoft Corporation

   Title:   drvr.h - Installable driver code internal header file.

   Version: 1.00

   Date:    10-Jun-1990

   Author:  DAVIDDS ROBWI

------------------------------------------------------------------------------

   Change log:

      DATE        REV            DESCRIPTION
   -----------   -----   -----------------------------------------------------------
   10-JUN-1990   ROBWI   Based on windows 3.1 installable driver code by davidds
   28-FEB-1992   ROBINSP Port to NT

*****************************************************************************/

typedef LRESULT (*DRIVERPROC)
        (DWORD_PTR dwDriverID, HDRVR hDriver, UINT wMessage, LPARAM lParam1, LPARAM lParam2);

#define DRIVER_PROC_NAME "DriverProc"

#if 0
extern BOOL                     fUseWinAPI;
#else
    #define fUseWinAPI FALSE
#endif

typedef struct tagDRIVERTABLE
{
  UINT          fFirstEntry:1;
  UINT          fBusy:1;
  DWORD_PTR     dwDriverIdentifier;
  DWORD_PTR     hModule;
  DRIVERPROC    lpDriverEntryPoint;
} DRIVERTABLE;
typedef DRIVERTABLE FAR *LPDRIVERTABLE;

LRESULT FAR PASCAL InternalBroadcastDriverMessage(UINT, UINT, LPARAM, LPARAM, UINT);
LRESULT FAR PASCAL InternalCloseDriver(UINT, LPARAM, LPARAM, BOOL);
LRESULT FAR PASCAL InternalOpenDriver(LPCWSTR, LPCWSTR, LPARAM, BOOL);
LRESULT FAR PASCAL InternalLoadDriver(LPCWSTR, LPCWSTR, LPWSTR, UINT, BOOL);
UINT FAR PASCAL InternalFreeDriver(UINT, BOOL);
void FAR PASCAL InternalInstallDriverChain (void);
void FAR PASCAL InternalDriverDisable (void);
void FAR PASCAL InternalDriverEnable (void);
int  FAR PASCAL GetDrvrUsage(HANDLE);
HANDLE FAR PASCAL LoadAliasedLibrary (LPCWSTR, LPCWSTR, LPWSTR, LPWSTR, UINT);

/* Defines for internalbroadcastdrivermessage flags */
#define IBDM_SENDMESSAGE       0x0001
#define IBDM_REVERSE           0x0002
#define IBDM_ONEINSTANCEONLY   0x0004

/* Multi-thread protection for OpenDriver etc */
#define DrvEnter() EnterCriticalSection(&DriverListCritSec)
#define DrvLeave() LeaveCriticalSection(&DriverListCritSec)

/*
 *  DriverListCritSec keeps our handling of the driver list and count
 *  protected
 *
 *  DriverLoadFreeCritSec keeps our loads and frees from overlapping
 */

extern CRITICAL_SECTION DriverListCritSec;
extern CRITICAL_SECTION DriverLoadFreeCritSec;

#define REGSTR_PATH_WAVEMAPPER  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Wave Mapper")
#define REGSTR_VALUE_MAPPABLE   TEXT("Mappable")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\debug.c ===
/****************************************************************************
    debug.c

    winmm debug support module

    Copyright (c) 1990-2001 Microsoft Corporation

    History
        10/1/92  Updated for NT by Robin Speed (RobinSp)
****************************************************************************/

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "winmmi.h"
#include <wchar.h>
#include <stdarg.h>

// no REAL logging for now ! - NT doesn't have Dr Watson !
#define LogParamError(a, b)

RTL_RESOURCE     gHandleListResource;

/***************************************************************************
 * @doc INTERNAL
 *
 * @func HANDLE | NewHandle | allocate a fixed handle in MMSYSTEM's local heap
 *
 * @parm  UINT | uType | unique id describing handle type
 * @parm  UINT | uSize | size in bytes to be allocated
 *
 * @rdesc Returns pointer/handle to memory object
 *
 * @comm a standard handle header (HNDL) will be added to the object,
 *       and it will be linked into the list of MMSYSTEM handles.
 *
 ***************************************************************************/
HANDLE NewHandle(UINT uType, PCWSTR cookie, UINT uSize)
{
    PHNDL pHandle;
    pHandle = (PHNDL)HeapAlloc(hHeap, 0, sizeof(HNDL) + uSize);

    if (pHandle == NULL) {
        return pHandle;
    } else {
        ZeroMemory(pHandle, sizeof(HNDL) + uSize);   // zero the whole bludy lot
        if (!mmInitializeCriticalSection(&pHandle->CritSec)) {
	        HeapFree(hHeap, 0, (LPSTR)pHandle);
	        return NULL;
        }

        pHandle->hThread   = GetCurrentTask();        // For WOW validation
        pHandle->uType     = uType;
        pHandle->cookie    = cookie;

        RtlAcquireResourceExclusive(&gHandleListResource, TRUE);
        EnterCriticalSection(&HandleListCritSec);
        pHandle->pNext = pHandleList;
        pHandleList = pHandle;
        LeaveCriticalSection(&HandleListCritSec);
    }
    return PHtoH(pHandle);
}

void AcquireHandleListResourceShared()
{
    RtlAcquireResourceShared(&gHandleListResource, TRUE);
}

void AcquireHandleListResourceExclusive()
{
    RtlAcquireResourceExclusive(&gHandleListResource, TRUE);
}    

void ReleaseHandleListResource()
{
    RtlReleaseResource(&gHandleListResource);
}    

/***************************************************************************
 * @doc INTERNAL
 *
 * @func HANDLE | FreeHandle | free handle allocated with NewHandle
 *
 * @parm HANDLE | hUser | handle returned from NewHandle
 *
 * @comm handle will be unlinked from list, and memory will be freed
 *
 *
 ***************************************************************************/

void FreeHandle(HANDLE hUser)
{
    /* Find handle and free from list */

    PHNDL pHandle;
    PHNDL *pSearch;

    if (hUser == NULL) {
        return;
    }

    //
    // Point to our handle data
    //

    pHandle = HtoPH(hUser);

    AcquireHandleListResourceExclusive();
    EnterCriticalSection(&HandleListCritSec);

    pSearch = &pHandleList;

    while (*pSearch != NULL) {
        if (*pSearch == pHandle) {
            //
            // Found it
            // Remove it from the list
            //
            *pSearch = pHandle->pNext;
            LeaveCriticalSection(&HandleListCritSec);
            
            //  Making sure no one is using the handle while we mark it as invalid.
            EnterCriticalSection(&pHandle->CritSec);
            pHandle->uType = 0;
            pHandle->fdwHandle = 0L;
            pHandle->hThread = NULL;
            pHandle->pNext = NULL;
            LeaveCriticalSection(&pHandle->CritSec);

            DeleteCriticalSection(&pHandle->CritSec);
            HeapFree(hHeap, 0, (LPSTR)pHandle);
            ReleaseHandleListResource();
            return;
        } else {
            pSearch = &(*pSearch)->pNext;
        }
    }

    dprintf1(("Freeing handle which is not in the list !"));
    WinAssert(FALSE);
    LeaveCriticalSection(&HandleListCritSec);
    ReleaseHandleListResource();
}


/***************************************************************************
 * @doc INTERNAL
 *
 * @func HANDLE | InvalidateHandle | invalidate handle allocated with
 *          NewHandle for parameter validation
 *
 * @parm HANDLE | hUser | handle returned from NewHandle
 *
 * @comm handle will be marked as TYPE_UNKNOWN, causing handle based API's to
 *          fail.
 *
 *
 ***************************************************************************/

void InvalidateHandle(HANDLE hUser)
{
    /* Find handle and free from list */

    PHNDL pHandle;

    if (hUser == NULL) {
        return;
    }

    //
    // Point to our handle data
    //

    pHandle = HtoPH(hUser);

    pHandle->uType = TYPE_UNKNOWN;
}


/**************************************************************************

    @doc INTERNAL

    @api void | winmmSetDebugLevel | Set the current debug level

    @parm int | iLevel | The new level to set

    @rdesc There is no return value

**************************************************************************/

void winmmSetDebugLevel(int level)
{
#if DBG
    winmmDebugLevel = level;
    dprintf(("debug level set to %d", winmmDebugLevel));
#endif
}

STATICDT UINT inited=0;

#if DBG
extern int mciDebugLevel;
#endif

#if DBG
void InitDebugLevel(void)
{
    if (!inited) {

        INT level;

        level = GetProfileInt("MMDEBUG", "WINMM", 99);
        if (level != 99) {
            winmmDebugLevel = level;
        }

        level = GetProfileInt("MMDEBUG", "MCI", 99);
        if (level != 99) {
            mciDebugLevel = level;
        }

        inited = 1;
    }
    dprintf2(("Starting, debug level=%d", winmmDebugLevel));
}
#endif

#ifdef DEBUG_RETAIL

/***************************************************************************
 * @doc INTERNAL WAVE MIDI
 *
 * @func BOOL | ValidateHeader | validates a wave or midi date header
 *
 * @parm LPVOID | lpHeader| pointer to wave/midi header
 * @parm  UINT  | wSize  | size of header passed by app
 * @parm  UINT  | wType  | unique id describing header/handle type
 *
 * @rdesc Returns TRUE  if <p> is non NULL and <wSize> is the correct size
 *        Returns FALSE otherwise
 *
 * @comm  if the header is invalid an error will be generated.
 *
 ***************************************************************************/

BOOL ValidateHeader(PVOID pHdr, UINT uSize, UINT uType)
{
    // Detect bad header

    if (!ValidateWritePointer(pHdr, uSize)) {
        DebugErr(DBF_ERROR, "Invalid header pointer");
        return FALSE;
    }

    // Check type

    switch (uType) {
    case TYPE_WAVEOUT:
    case TYPE_WAVEIN:
        {
            PWAVEHDR pHeader = pHdr;

            // Check header
            if (uSize < sizeof(WAVEHDR)) {
                DebugErr(DBF_ERROR, "Invalid header size");
                LogParamError(ERR_BAD_VALUE, uSize);
                return FALSE;
            }

            if (pHeader->dwFlags & ~WHDR_VALID) {
                LogParamError(ERR_BAD_FLAGS, ((PWAVEHDR)pHeader)->dwFlags);
                return FALSE;
            }

            // Check buffer
            if (!(uType == TYPE_WAVEOUT
                    ? ValidateReadPointer(pHeader->lpData, pHeader->dwBufferLength)
                    : ValidateWritePointer(pHeader->lpData, pHeader->dwBufferLength))
               ) {
                DebugErr(DBF_ERROR, "Invalid buffer pointer");
                return FALSE;
            }
        }
        break;

    case TYPE_MIDIIN:
	case TYPE_MIDIOUT:
	case TYPE_MIDISTRM:
        {
            PMIDIHDR pHeader = pHdr;

            if ((TYPE_MIDISTRM == uType) &&
                uSize < sizeof(MIDIHDR))
            {
                DebugErr(DBF_ERROR, "Invalid header size");
                LogParamError(ERR_BAD_VALUE, uSize);
                return FALSE;
            }
            else if (uSize < sizeof(MIDIHDR31))
            {
                DebugErr(DBF_ERROR, "Invalid header size");
                LogParamError(ERR_BAD_VALUE, uSize);
                return FALSE;
            }

            if (pHeader->dwFlags & ~MHDR_VALID) {
                LogParamError(ERR_BAD_FLAGS, ((PMIDIHDR)pHeader)->dwFlags);
                return FALSE;
            }

            // Check buffer
            if (!(uType == TYPE_MIDIOUT
                    ? ValidateReadPointer(pHeader->lpData, pHeader->dwBufferLength)
                    : ValidateWritePointer(pHeader->lpData, pHeader->dwBufferLength))
               ) {
                DebugErr(DBF_ERROR, "Invalid buffer pointer");
                return FALSE;
            }
        }
        break;

    default:
        WinAssert(FALSE);
        break;
    }

	return TRUE;
}

#ifndef USE_KERNEL_VALIDATION
/***************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidateReadPointer | validates that a pointer is valid to
 *  read from.
 *
 * @parm LPVOID | lpPoint| pointer to validate
 * @parm DWORD  | dLen   | supposed length of said pointer
 *
 * @rdesc Returns TRUE  if <p> is a valid pointer
 *        Returns FALSE if <p> is not a valid pointer
 *
 * @comm will generate error if the pointer is invalid
 *
 ***************************************************************************/

BOOL ValidateReadPointer(PVOID pPoint, ULONG Len)
{
    // For now just check access to first and last byte
    // Only validate if Len non zero.  Midi APIs pass data in the
    // pointer and pass a length of zero.  Otherwise on 64 bit machines
    // we look 4Gigs out from the pointer when we check Len-1 and Len==0.
    // That doesn't work very well.
    if (Len) {
        try {
            volatile BYTE b;
            b = ((PBYTE)pPoint)[0];
            b = ((PBYTE)pPoint)[Len - 1];
        } except(EXCEPTION_EXECUTE_HANDLER) {
            LogParamError(ERR_BAD_PTR, pPoint);
            return FALSE;
        }
    }
    return TRUE;
}

/***************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidateWritePointer | validates that a pointer is valid to
 *  write to.
 *
 * @parm LPVOID | lpPoint| pointer to validate
 * @parm DWORD  | dLen   | supposed length of said pointer
 *
 * @rdesc Returns TRUE  if <p> is a valid pointer
 *        Returns FALSE if <p> is not a valid pointer
 *
 * @comm will generate error if the pointer is invalid
 *
 ***************************************************************************/
BOOL ValidateWritePointer(PVOID pPoint, ULONG Len)
{
    // For now just check read and write access to first and last byte
    // Only validate if Len non zero.  Midi APIs pass data in the
    // pointer and pass a length of zero.  Otherwise on 64 bit machines
    // we look 4Gigs out from the pointer when we check Len-1 and Len==0.
    // That doesn't work very well.
    if (Len) {
        try {
               volatile BYTE b;
               b = ((PBYTE)pPoint)[0];
               ((PBYTE)pPoint)[0] = b;
               b = ((PBYTE)pPoint)[Len - 1];
               ((PBYTE)pPoint)[Len - 1] = b;

        } except(EXCEPTION_EXECUTE_HANDLER) {
            LogParamError(ERR_BAD_PTR, pPoint);
            return FALSE;
        }
    }
    return TRUE;
}
#endif // USE_KERNEL_VALIDATION

/***************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidDriverCallback |
 *
 *  validates that a driver callback is valid, to be valid a driver
 *  callback must be a valid window, task, or a function in a FIXED DLL
 *  code segment.
 *
 * @parm DWORD  | dwCallback | callback to validate
 * @parm DWORD  | wFlags     | driver callback flags
 *
 * @rdesc Returns 0  if <dwCallback> is a valid callback
 *        Returns error condition if <dwCallback> is not a valid callback
 ***************************************************************************/

BOOL ValidDriverCallback(HANDLE hCallback, DWORD dwFlags)
{
    switch (dwFlags & DCB_TYPEMASK) {
    case DCB_WINDOW:
        if (!IsWindow(hCallback)) {
            LogParamError(ERR_BAD_HWND, hCallback);
            return FALSE;
        }
        break;

    case DCB_EVENT:
        //if (hCallback is not an event)
        //    LogParamError(ERR_BAD_CALLBACK, hCallback);
        //    return FALSE;
        //}
        break;


    case DCB_TASK:
        //if (IsBadCodePtr((FARPROC)hCallback)) {
        //    LogParamError(ERR_BAD_CALLBACK, hCallback);
        //    return FALSE;
        //}
        break;

    case DCB_FUNCTION:
        if (IsBadCodePtr((FARPROC)hCallback)) {
            LogParamError(ERR_BAD_CALLBACK, hCallback);
            return FALSE;
        }
        break;
    }

    return TRUE;
}

#ifndef USE_KERNEL_VALIDATION
/**************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidateString |
 *
 **************************************************************************/
BOOL ValidateString(LPCSTR pPoint, DWORD Len)
{
    // For now just check access - do a 'strnlen'

    try {
           volatile BYTE b;
           LPCSTR p = pPoint;

           while (Len--) {
               b = *p;
               if (!b) {
                   break;
               }
               p++;
           }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        LogParamError(ERR_BAD_STRING_PTR, pPoint);
        return FALSE;
    }
    return TRUE;
}

/**************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidateStringW |
 *
 **************************************************************************/
BOOL ValidateStringW(LPCWSTR pPoint, DWORD Len)
{
    // For now just check access - do a 'strnlen'

    try {
           volatile WCHAR b;
           LPCWSTR p = pPoint;

           while (Len--) {
               b = *p;
               if (!b) {
                   break;
               }
               p++;
           }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        LogParamError(ERR_BAD_STRING_PTR, pPoint);
        return FALSE;
    }
    return TRUE;
}
#endif //USE_KERNEL_VALIDATION

/**************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidateHandle | validates a handle created with NewHandle
 *
 * @parm PHNDL | hLocal | handle returned from NewHandle
 * @parm UINT  | wType  | unique id describing handle type
 *
 * @rdesc Returns TRUE  if <h> is a valid handle of type <wType>
 *        Returns FALSE if <h> is not a valid handle
 *
 * @comm  if the handle is invalid an error will be generated.
 *
 **************************************************************************/
BOOL ValidateHandle(HANDLE hLocal, UINT uType)

{
   BOOL OK;

   //
   //  if the handle is less than 64k or a mapper id then
   //  don't bother with the overhead of the try-except.
   //
   //  BUGBUG:  MM needs to be audited for WIN64!
   //
   //  This code is a mess.  The mapper ids are defined as 32-bit
   //  unsigned values and then compared against a HANDLE?  Of course
   //  an unsigned 32-bit -1 will never equal a 64-bit -1 so on WIN64,
   //  an exception is taken everytime an invalid handle is passed in.
   //  Someone hacked in enough coercions to mask valid warnings for WIN64.
   //  Even worse, there is at least one function that returns 0xffffffff
   //  explicity versus a define or const value.
   //
   //  For now, change the const compare to a handle compare and add an
   //  invalid handle compare.  This results in the same code on x86 as
   //  before (the compiler folds all of the redundant compares), and doesn't
   //  increase the codesize for IA64 (parallel compares are used) even though
   //  the extra compare for WIN64 is useless.
   //
   if (hLocal < (HANDLE)0x10000 ||
       INVALID_HANDLE_VALUE == hLocal ||
       WAVE_MAPPER == (UINT_PTR)hLocal ||
       MIDI_MAPPER == (UINT_PTR)hLocal ||
       AUX_MAPPER  == (UINT_PTR)hLocal)
   {
       LogParamError(ERR_BAD_HANDLE, hLocal);
       return FALSE;
   }

   try {
       OK = HtoPH(hLocal)->uType == uType;

    } except(EXCEPTION_EXECUTE_HANDLER) {
      LogParamError(ERR_BAD_HANDLE, hLocal);
      return FALSE;
   }

   return OK;
}


#if DBG
char * Types[4] = {"Unknown callback type",
                   "Window callback",
                   "Task callback",
                   "Function callback"};
#endif
/**************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidateCallbackType | validates a callback address,
 *              window handle, or task handle
 *
 * @parm PHNDL | hLocal | handle returned from NewHandle
 * @parm UINT  | wType  | unique id describing handle type
 *
 * @rdesc Returns TRUE  if <h> is a valid handle of type <wType>
 *        Returns FALSE if <h> is not a valid handle
 *
 * @comm  if the handle is invalid an error will be generated.
 *
 **************************************************************************/
BOOL ValidateCallbackType(DWORD_PTR dwCallback, UINT uType)
{

#define DCALLBACK_WINDOW   HIWORD(CALLBACK_WINDOW)      // dwCallback is a HWND
#define DCALLBACK_TASK     HIWORD(CALLBACK_TASK)        // dwCallback is a HTASK
#define DCALLBACK_FUNCTION HIWORD(CALLBACK_FUNCTION)    // dwCallback is a FARPROC
#define DCALLBACK_EVENT    HIWORD(CALLBACK_EVENT)       // dwCallback is an EVENT

    UINT type = uType & HIWORD(CALLBACK_TYPEMASK);

#if DBG
    if (type>5) {
        type = 0;
    }
    dprintf3(("Validating Callback, type=%d (%hs), handle=%8x", type, Types[type], dwCallback));
#endif
    switch (type) {
        case DCALLBACK_WINDOW:
            return(IsWindow((HWND)dwCallback));
            break;

	case DCALLBACK_EVENT:
	{
	    // ?? how to verify that this is an event handle??
	    //DWORD dwFlags;
	    //GetHandleInformation((HANDLE)dwCallback, &dwFlags);
            return TRUE;
	}
            break;

        case DCALLBACK_FUNCTION:
            return(!(IsBadCodePtr((FARPROC)dwCallback)));
            break;

        case DCALLBACK_TASK:
            if (THREAD_PRIORITY_ERROR_RETURN == GetThreadPriority((HANDLE)dwCallback)) {
                dprintf1(("Invalid callback task handle"));
                // I suspect we do not have the correct thread handle, in
                // which case we can only return TRUE.
                //return(FALSE);
            }
            return(TRUE);
            break;

    }
    return TRUE;
}

/**************************************************************************
   @doc INTERNAL

   @func void | dout | Output debug string if debug flag is set

   @parm LPSTR | szString
 **************************************************************************/

#if DBG
int fDebug = 1;
#else
int fDebug = 0;
#endif

//void dout(LPSTR szString)
//{
//    if (fDebug) {
//        OutputDebugStringA(szString);
//    }
//}

#ifdef LATER

    This routine should probably be replaced in the headers by redefining
    to use OutputDebugString

#endif

#undef OutputDebugStr
// Make our function visible
/*****************************************************************************
*   @doc EXTERNAL DDK
*
*   @api void | OutputDebugStr | This function sends a debugging message
*      directly to the COM1 port or to a secondary monochrome display
*      adapter. Because it bypasses DOS, it can be called by low-level
*      callback functions and other code at interrupt time.
*
*   @parm LPSTR | lpOutputString | Specifies a far pointer to a
*      null-terminated string.
*
*   @comm This function is available only in the debugging version of
*      Windows. The DebugOutput keyname in the [mmsystem]
*      section of SYSTEM.INI controls where the debugging information is
*      sent. If fDebugOutput is 0, all debug output is disabled.
******************************************************************************/

/*****************************************************************************
 *   This function is basicly the same as OutputDebugString() in KERNEL.
 *
 *
 *   DESCRIPTION:    outputs a string to the debugger
 *
 *   ENTRY:          szString - string to output
 *
 *   EXIT:
 *       none
 *   USES:
 *       flags
 *
 *****************************************************************************/

VOID APIENTRY OutputDebugStr(LPCSTR szString)
{
    OutputDebugStringA((LPSTR)szString);  // Will always be an ASCII string
    // When the MM WOW thunk is changed to call OutputDebugString directly
    // we can remove this routine from our code
}

#endif // DEBUG_RETAIL


#if DBG

int winmmDebugLevel = 0;

/***************************************************************************

    @doc INTERNAL

    @api void | winmmDbgOut | This function sends output to the current
        debug output device.

    @parm LPSTR | lpszFormat | Pointer to a printf style format string.
    @parm ??? | ... | Args.

    @rdesc There is no return value.

****************************************************************************/
extern BOOL Quiet = FALSE;

void winmmDbgOut(LPSTR lpszFormat, ...)

{
    char buf[512];
    UINT n;
    va_list va;

    if (Quiet) {
        return;
    }

    n = wsprintf(buf, "WINMM(p%d:t%d): ", GetCurrentProcessId(), GetCurrentThreadId());

    va_start(va, lpszFormat);
    n += vsprintf(buf+n, lpszFormat, va);
    va_end(va);

    buf[n++] = '\n';
    buf[n] = 0;
    OutputDebugString(buf);
    Sleep(0);  // let terminal catch up
}

/***************************************************************************

    @doc INTERNAL

    @api void | dDbgAssert | This function prints an assertion message.

    @parm LPSTR | exp | Pointer to the expression string.
    @parm LPSTR | file | Pointer to the file name.
    @parm int | line | The line number.

    @rdesc There is no return value.

****************************************************************************/

void dDbgAssert(LPSTR exp, LPSTR file, int line)
{
    dprintf(("Assertion failure:"));
    dprintf(("  Exp: %s", exp));
    dprintf(("  File: %s, line: %d", file, line));
    DebugBreak();
}
#else  // Still need to export this thing to help others
void winmmDbgOut(LPSTR lpszFormat, ...)
{
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\drvr.c ===
/******************************************************************************

   Copyright (c) 1985-2001 Microsoft Corporation

   Title:   drvr.c - Installable driver code. Common code

   Version: 1.00

   Date:    10-Jun-1990

   Author:  DAVIDDS ROBWI

------------------------------------------------------------------------------

   Change log:

      DATE        REV            DESCRIPTION
   -----------   ----- -----------------------------------------------------------
   10-JUN-1990   ROBWI From windows 3.1 installable driver code by davidds
   28-FEB-1992   ROBINSP Port to NT

*****************************************************************************/

#include <windows.h>
#include <winmmi.h>
#include <stdlib.h>
#include <string.h>
#include "drvr.h"

int     cInstalledDrivers = 0;      // Count of installed drivers
HANDLE  hInstalledDriverList = 0;   // List of installed drivers

typedef LONG   (FAR PASCAL *SENDDRIVERMESSAGE31)(HANDLE, UINT, LPARAM, LPARAM);
typedef LRESULT (FAR PASCAL *DEFDRIVERPROC31)(DWORD_PTR, HANDLE, UINT, LPARAM, LPARAM);

extern SENDDRIVERMESSAGE31      lpSendDriverMessage;
extern DEFDRIVERPROC31          lpDefDriverProc;

extern void lstrncpyW (LPWSTR pszTarget, LPCWSTR pszSource, size_t cch);

__inline PWSTR lstrDuplicateW(PCWSTR pstr)
{
    PWSTR pstrDuplicate = (PWSTR)HeapAlloc(hHeap, 0, (lstrlenW(pstr)+1)*sizeof(WCHAR));
    if (pstrDuplicate) lstrcpyW(pstrDuplicate, pstr);
    return pstrDuplicate;
}


//============================================================================
// Basic hash helpers taken from LKRhash
//============================================================================

// Produce a scrambled, randomish number in the range 0 to RANDOM_PRIME-1.
// Applying this to the results of the other hash functions is likely to
// produce a much better distribution, especially for the identity hash
// functions such as Hash(char c), where records will tend to cluster at
// the low end of the hashtable otherwise.  LKRhash applies this internally
// to all hash signatures for exactly this reason.

__inline DWORD
HashScramble(DWORD dwHash)
{
    // Here are 10 primes slightly greater than 10^9
    //  1000000007, 1000000009, 1000000021, 1000000033, 1000000087,
    //  1000000093, 1000000097, 1000000103, 1000000123, 1000000181.

    // default value for "scrambling constant"
    const DWORD RANDOM_CONSTANT = 314159269UL;
    // large prime number, also used for scrambling
    const DWORD RANDOM_PRIME =   1000000007UL;

    return (RANDOM_CONSTANT * dwHash) % RANDOM_PRIME ;
}

// Small prime number used as a multiplier in the supplied hash functions
const DWORD HASH_MULTIPLIER = 101;

#undef HASH_SHIFT_MULTIPLY

#ifdef HASH_SHIFT_MULTIPLY
# define HASH_MULTIPLY(dw)   (((dw) << 7) - (dw))
#else
# define HASH_MULTIPLY(dw)   ((dw) * HASH_MULTIPLIER)
#endif

// Fast, simple hash function that tends to give a good distribution.
// Apply HashScramble to the result if you're using this for something
// other than LKRhash.

__inline DWORD
HashStringA(
    const char* psz,
    DWORD       dwHash)
{
    // force compiler to use unsigned arithmetic
    const unsigned char* upsz = (const unsigned char*) psz;

    for (  ;  *upsz;  ++upsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  *upsz;

    return dwHash;
}


// Unicode version of above

__inline DWORD
HashStringW(
    const wchar_t* pwsz,
    DWORD          dwHash)
{
    for (  ;  *pwsz;  ++pwsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  *pwsz;

    return dwHash;
}

// Quick-'n'-dirty case-insensitive string hash function.
// Make sure that you follow up with _stricmp or _mbsicmp.  You should
// also cache the length of strings and check those first.  Caching
// an uppercase version of a string can help too.
// Again, apply HashScramble to the result if using with something other
// than LKRhash.
// Note: this is not really adequate for MBCS strings.

__inline DWORD
HashStringNoCase(
    const char* psz,
    DWORD       dwHash)
{
    const unsigned char* upsz = (const unsigned char*) psz;

    for (  ;  *upsz;  ++upsz)
        dwHash = HASH_MULTIPLY(dwHash)
                     +  (*upsz & 0xDF);  // strip off lowercase bit

    return dwHash;
}


// Unicode version of above

__inline DWORD
HashStringNoCaseW(
    const wchar_t* pwsz,
    DWORD          dwHash)
{
    for (  ;  *pwsz;  ++pwsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  (*pwsz & 0xFFDF);

    return dwHash;
}


/*
   FYI here are the first bunch of prime numbers up to around 1000

     2      3      5      7     11     13     17     19     23     29
     31     37     41     43     47     53     59     61     67     71
     73     79     83     89     97    101    103    107    109    113
    127    131    137    139    149    151    157    163    167    173
    179    181    191    193    197    199    211    223    227    229
    233    239    241    251    257    263    269    271    277    281
    283    293    307    311    313    317    331    337    347    349
    353    359    367    373    379    383    389    397    401    409
    419    421    431    433    439    443    449    457    461    463
    467    479    487    491    499    503    509    521    523    541
    547    557    563    569    571    577    587    593    599    601
    607    613    617    619    631    641    643    647    653    659
    661    673    677    683    691    701    709    719    727    733
    739    743    751    757    761    769    773    787    797    809
    811    821    823    827    829    839    853    857    859    863
    877    881    883    887    907    911    919    929    937    941
    947    953    967    971    977    983    991    997   1009   1013
*/

//============================================================================
//   StringId dictionary
//============================================================================

#define HASH_TABLESIZE (127)
PMMDRV StringIdDict[HASH_TABLESIZE];

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | StringId_Create | This function creates a unique string
 *   identifying a particular MME device.  The string can be used to
 *   subsequently retrieve the ID for the same MME device even if the devices
 *   have been renumbered.
 *
 * @parm IN PMMDRV | pdrv | Pointer to an MME driver.
 *
 * @parm IN UINT | port | Driver-relative device ID.
 *
 * @parm OPTIONAL OUT PWSTR* | pStringId | Address of a buffer to receive the
 *   pointer to the string.
 *
 * @parm OPTIONAL OUT ULONG* | pcbStringId | Receives size of buffer required
 *   to store the string.

 * @rdesc MMRESULT | Zero if successfull otherwise an error code defined
 *   in mmsystem.h.
 *
 * @comm The string is allocated by this function using the heap identified
 *   by the global variable hHeap.  The caller is responsible for ensuring
 *   the string is freed.
 *
 ****************************************************************************/
MMRESULT StringId_Create(IN PMMDRV pdrv, IN UINT port, OUT PWSTR* pStringId, OUT ULONG* pcbStringId)
{
    MMRESULT mmr;
    int cchStringId;
    PWSTR StringId;
    LONG  StringIdType;
    PCWSTR StringIdBase;

    // 8 chars type field + next colon delimiter
    cchStringId = 8 + 1;

    if (pdrv->cookie)
    {
	// 8 chars for device interface length field + next colon delimiter
	cchStringId += 8 + 1;
	// device interface name + next colon delimiter
        cchStringId += lstrlenW(pdrv->cookie) + 1;
        StringIdType = 1;
        StringIdBase = pdrv->cookie;
    }
    else
    {
	// file name + next colon delimiter
	cchStringId += lstrlenW(pdrv->wszDrvEntry) + 1;
        StringIdType = 0;
        StringIdBase = pdrv->wszDrvEntry;
    }

    // message proc name + next colon delimiter
    cchStringId += lstrlenW(pdrv->wszMessage) + 1;

    //  8 chars driver-relative ID, 1 terminator
    cchStringId += 8 + 1;

    mmr = MMSYSERR_NOERROR;

    if (pStringId)
    {
        StringId = HeapAlloc(hHeap, 0, cchStringId * sizeof(WCHAR));
        if (StringId)
        {
            int cchPrinted;
            switch (StringIdType)
            {
            	case 0:
            	    cchPrinted = swprintf(StringId, L"%08X:%s:%s:%08X", StringIdType, StringIdBase, pdrv->wszMessage, port);
            	    break;
            	case 1:
            	    cchPrinted = swprintf(StringId, L"%08X:%08X:%s:%s:%08X", StringIdType, lstrlenW(StringIdBase), StringIdBase, pdrv->wszMessage, port);
            	    break;
            	default:
            	    WinAssert(FALSE);
            	    break;
            }
            WinAssert(cchPrinted < cchStringId);
            *pStringId = StringId;
            // dprintf(("StringId_Create : note: created StringId=\"%ls\"", StringId));
        }
        else
        {
            mmr = MMSYSERR_NOMEM;
        }
    }

    if (!mmr && pcbStringId) *pcbStringId = cchStringId * sizeof(WCHAR);

    return mmr;
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | StringIdDict_Initialize | This function ensures the
 *   dictionary is initialized.  It should be called by any function that uses
 *   the dictionary
 *
 * @rdesc void
 *
 ****************************************************************************/
void StringIdDict_Initialize(void)
{
    int i;
    static BOOL fInitialized = FALSE;
    
    if (fInitialized) return;
    
    for (i = 0; i < (sizeof(StringIdDict)/sizeof(StringIdDict[0])); i++) StringIdDict[i] = NULL;
    fInitialized = TRUE;
}

MMRESULT StringIdDict_SearchType0And1(IN ULONG Type, IN PWSTR pstrTypeXData, IN ULONG HashAx, OUT PMMDRV *ppdrv, OUT UINT *pport)
{
    PWSTR pstrDriver = NULL;
    PWSTR pstrMessage = NULL;
    PWSTR pstrPort = NULL;
    PWSTR pstr = pstrTypeXData;

    MMRESULT mmr = MMSYSERR_NOERROR;

    WinAssert((0 == Type) || (1 == Type));

    if (0 == Type)
    {
    	// "<driver-filename>:<driver-message-proc-name>:<driver-port>"
    	pstrDriver = pstr;
    	pstrMessage = wcschr(pstrDriver, L':');
    	if (pstrMessage) *pstrMessage++ = L'\0';
    }
    else // 1 == Type
    {
    	// "<driver-device-interface-length>:<driver-device-interface>:<driver-message-proc-name>:<driver-port>"
    	int cchDeviceInterface = wcstol(pstr, &pstrDriver, 16);
    	if (L':' != *pstrDriver) pstrDriver = NULL;
    	if (pstrDriver) {
    	    *pstrDriver++ = L'\0';
    	    pstrMessage = pstrDriver + cchDeviceInterface;
            if (L':' == *pstrMessage) *pstrMessage++ = L'\0';
            else pstrMessage = NULL;
    	}
    }

    if (pstrMessage)
    {
    	pstrPort = wcschr(pstrMessage, L':');
        if (pstrPort) *pstrPort++ = L'\0';
    }

    // now hash the substrings and search the hash chain for a match
    if (pstrDriver && pstrMessage && pstrPort)
    {
    	UINT   port;
    	PMMDRV pdrv;
    	int    cHashMisses;
    	PWCHAR pch;
    	
    	HashAx = HashStringNoCaseW(pstrDriver, HashAx);
    	HashAx = HashStringNoCaseW(pstrMessage, HashAx);
        HashAx = HashScramble(HashAx) % HASH_TABLESIZE;
        	
        mmr = MMSYSERR_NODRIVER;

        port = wcstol(pstrPort, &pch, 16);

        for (pdrv = StringIdDict[HashAx], cHashMisses = 0;
    	     pdrv;
    	     pdrv = pdrv->NextStringIdDictNode, cHashMisses++)
    	{
    	    if (0 == Type)
    	    {
    	        if (pdrv->cookie) continue;
    	        if (lstrcmpiW(pdrv->wszDrvEntry, pstrDriver)) continue;
    	    }
    	    else // 1 == Type
    	    {
    	        if (!pdrv->cookie) continue;
    	        if (lstrcmpiW(pdrv->cookie, pstrDriver)) continue;
    	    }
    	    if (lstrcmpiW(pdrv->wszMessage, pstrMessage)) continue;


    	    *ppdrv = pdrv;
    	    *pport = port;

    	    if (cHashMisses) dprintf(("StringIdDict_SearchType0And1 : note: %d hash misses", cHashMisses));
    	
    	    mmr = MMSYSERR_NOERROR;
    	    break;
    	}
    }
    else
    {
    	mmr = MMSYSERR_INVALPARAM;
    }

    return mmr;
}

MMRESULT StringIdDict_Search(IN PCWSTR InStringId, OUT PMMDRV *ppdrv, OUT UINT *pport)
{
    PWSTR StringId;
    MMRESULT mmr = MMSYSERR_NOERROR;

    StringIdDict_Initialize();

    StringId = lstrDuplicateW(InStringId);
    if (StringId)
    {
    	ULONG Type;
    	PWSTR pstr;
    	PWSTR pstrType;

	pstr = StringId;
	pstrType = pstr;
    	
        Type = wcstol(pstrType, &pstr, 16);
        if (*pstr == L':')
        {
            ULONG HashAx;	// Hash accumulator

            *pstr++ = L'\0';
            HashAx = HashStringNoCaseW(pstrType, 0);

            switch (Type)
            {
                case 0:
    	            mmr = StringIdDict_SearchType0And1(Type, pstr, HashAx, ppdrv, pport);
    	            break;
    	        case 1:
    	            mmr = StringIdDict_SearchType0And1(Type, pstr, HashAx, ppdrv, pport);
    	            break;
    	        default:
    	            mmr = MMSYSERR_INVALPARAM;
    	            break;
            }
        }
        else
        {
            mmr = MMSYSERR_INVALPARAM;
        }

        HeapFree(hHeap, 0, StringId);
    }
    else
    {
    	mmr = MMSYSERR_NOMEM;
    }

    if (mmr) dprintf(("StringIdDict_Search : error: returning mmresult %d", mmr));
    return mmr;
}

void StringIdDict_Insert(PMMDRV pdrv)
{
    ULONG HashAx;
    MMRESULT mmr;

    StringIdDict_Initialize();

    if (!pdrv->cookie)
    {
    	HashAx = HashStringNoCaseW(L"00000000", 0);
    	HashAx = HashStringNoCaseW(pdrv->wszDrvEntry, HashAx);
    }
    else
    {
    	HashAx = HashStringNoCaseW(L"00000001", 0);
    	HashAx = HashStringNoCaseW(pdrv->cookie, HashAx);
    }
    HashAx = HashStringNoCaseW(pdrv->wszMessage, HashAx);

    HashAx = HashScramble(HashAx) % HASH_TABLESIZE;

    // dprintf(("StringIdDict_Insert : note: driver hashed to %d", HashAx));
    pdrv->NextStringIdDictNode = StringIdDict[HashAx];
    pdrv->PrevStringIdDictNode = NULL;
    if (pdrv->NextStringIdDictNode) pdrv->NextStringIdDictNode->PrevStringIdDictNode = pdrv;
    StringIdDict[HashAx] = pdrv;

#if DBG    
{
    //  Checking the consistency of the driver lists and the hash table

    UINT    cDriversHash = 0;
    UINT    cDrivers     = 0;
    UINT    ii;
    PMMDRV  pLink, pStart;
        
    for (ii = (sizeof(StringIdDict)/sizeof(StringIdDict[0])); ii; ii--)
    {
        for (pLink = StringIdDict[ii-1]; pLink; pLink = pLink->NextStringIdDictNode)
        {
            cDriversHash++;
        }
    }
        
    for (pStart = (PMMDRV)&waveoutdrvZ, pLink = pStart->Next; pLink != pStart; pLink = pLink->Next)
        cDrivers++;
        
    for (pStart = (PMMDRV)&waveindrvZ, pLink = pStart->Next; pLink != pStart; pLink = pLink->Next)
        cDrivers++;
        
    for (pStart = (PMMDRV)&midioutdrvZ, pLink = pStart->Next; pLink != pStart; pLink = pLink->Next)
        cDrivers++;
        
    for (pStart = (PMMDRV)&midiindrvZ, pLink = pStart->Next; pLink != pStart; pLink = pLink->Next)
        cDrivers++;
        
    for (pStart = (PMMDRV)&mixerdrvZ, pLink = pStart->Next; pLink != pStart; pLink = pLink->Next)
        cDrivers++;
        
    for (pStart = (PMMDRV)&auxdrvZ, pLink = pStart->Next; pLink != pStart; pLink = pLink->Next)
        cDrivers++;
        
    WinAssert(cDriversHash == cDrivers);        
}    
#endif  //  DBG    

    return;
}

void StringIdDict_Remove(PMMDRV pdrv)
{
    if (pdrv->NextStringIdDictNode) pdrv->NextStringIdDictNode->PrevStringIdDictNode = pdrv->PrevStringIdDictNode;
    if (pdrv->PrevStringIdDictNode) {
        pdrv->PrevStringIdDictNode->NextStringIdDictNode = pdrv->NextStringIdDictNode;
    } else {
        int i;
        for ( i = 0; i < HASH_TABLESIZE; i++ ) {
            if (pdrv == StringIdDict[i]) {
                StringIdDict[i] = pdrv->NextStringIdDictNode;
                break;
            }
        }
        WinAssert(i != HASH_TABLESIZE);
    }
    
#if DBG
{
    //  Checking the consistency of the driver lists and the hash table

    UINT    cDriversHash = 0;
    UINT    cDrivers     = 0;
    UINT    ii;
    PMMDRV  pLink, pStart;
        
    for (ii = (sizeof(StringIdDict)/sizeof(StringIdDict[0])); ii; ii--)
    {
        for (pLink = StringIdDict[ii-1]; pLink; pLink = pLink->NextStringIdDictNode)
        {
            cDriversHash++;
        }
    }
    
    for (pStart = (PMMDRV)&waveoutdrvZ, pLink = pStart->Next; pLink != pStart; pLink = pLink->Next)
        cDrivers++;
        
    for (pStart = (PMMDRV)&waveindrvZ, pLink = pStart->Next; pLink != pStart; pLink = pLink->Next)
        cDrivers++;
        
    for (pStart = (PMMDRV)&midioutdrvZ, pLink = pStart->Next; pLink != pStart; pLink = pLink->Next)
        cDrivers++;
        
    for (pStart = (PMMDRV)&midiindrvZ, pLink = pStart->Next; pLink != pStart; pLink = pLink->Next)
        cDrivers++;
        
    for (pStart = (PMMDRV)&mixerdrvZ, pLink = pStart->Next; pLink != pStart; pLink = pLink->Next)
        cDrivers++;
        
    for (pStart = (PMMDRV)&auxdrvZ, pLink = pStart->Next; pLink != pStart; pLink = pLink->Next)
        cDrivers++;
    
    cDrivers--;  // to account for the driver we just removed.
        
    WinAssert(cDriversHash == cDrivers);        
}    
#endif  //  DBG    
    
}


//=============================================================================
//===   Misc Utilities   ===
//=============================================================================

/***************************************************************************
 *
 * @doc INTERNAL
 *
 * @api void | winmmGetBuildYearAndMonth |  Returns build year and month
 *      of this source file.
 *
 * @parm unsigned* | pBuildYear | Receives build year.
 *
 * @parm unsigned* | pBuildMonth | Receives build month.
 *
 * @rdesc No return value.
 *
 * @comm Computes build year and month based on compiler macro __DATE__
 *
 ***************************************************************************/
void winmmGetBuildYearAndMonth(unsigned *pBuildYear, unsigned *pBuildMonth)
{
    char szBuildDate[] = __DATE__;
    char *Month[12] = {"Jan", "Feb", "Mar",
    	               "Apr", "May", "Jun",
    	               "Jul", "Aug", "Sep",
    	               "Oct", "Nov", "Dec"};
    char szBuildMonth[4];
    int i;

    lstrcpynA(szBuildMonth, szBuildDate, 4);
    szBuildMonth[3] = '\0';
    for (i = 0; i < 12; i++)
    {
    	if (!lstrcmpiA(Month[i], szBuildMonth)) break;
    }
    WinAssert(i < 12);
    *pBuildMonth = i + 1;

    *pBuildYear = atoi(&szBuildDate[7]);

    return;
    
}

/***************************************************************************
 *
 * @doc INTERNAL
 *
 * @api BOOL | winmmFileTimeIsPreXp |  Determines whether given filetime is
 *      before approximate XP ship date.
 *
 * @parm FILETIME* | FileTime | Points to file time to check.
 *
 * @rdesc BOOL | TRUE if file time is before approximate XP ship date
 *
 * @comm This is based on the build date of this source module, or the
 *      anticipated Windows XP RC2 ship month, whichever is later.
 *
 ***************************************************************************/
BOOL winmmFileTimeIsPreXp(CONST FILETIME *FileTime)
{
    const unsigned XpRc2Month = 7;
    const unsigned XpRc2Year  = 2001;
    
    SYSTEMTIME SystemTime;
    BOOL fPreXp = FALSE;

    if (FileTimeToSystemTime(FileTime, &SystemTime))
    {
    	unsigned BuildYear, BuildMonth;
    	winmmGetBuildYearAndMonth(&BuildYear, &BuildMonth);
    	if (BuildYear > XpRc2Year) {
    	    BuildYear = XpRc2Year;
    	    BuildMonth = XpRc2Month;
    	} else if ((BuildYear == XpRc2Year) && (BuildMonth > XpRc2Month)) {
    	    BuildMonth = XpRc2Month;
    	}
    	
    	if ((SystemTime.wYear < BuildYear) ||
    	    ((SystemTime.wYear == BuildYear) && (SystemTime.wMonth < BuildMonth)))
    	{
    	    fPreXp = TRUE;
    	}
    }

    return fPreXp;
}



/***************************************************************************
 *
 * @doc INTERNAL
 *
 * @api LONG | InternalBroadcastDriverMessage |  Send a message to a
 *      range of drivers.
 *
 * @parm UINT | hDriverStart | index of first driver to send message to
 *
 * @parm UINT | message | Message to broadcast.
 *
 * @parm LONG | lParam1 | First message parameter.
 *
 * @parm LONG | lParam2 | Second message parameter.
 *
 * @parm UINT | flags | defines range of drivers as follows:
 *
 * @flag IBDM_SENDMESSAGE | Only send message to hDriverStart.
 *
 * @flag IBDM_ONEINSTANCEONLY | This flag is ignored if IBDM_SENDMESSAGE is
 *       set. Only send message to single instance of each driver.
 *
 * @flag IBDM_REVERSE | This flag is ignored if IBDM_SENDMESSAGE is set.
 *       Send message to drivers with indices between
 *       hDriverStart and 1 instead of hDriverStart and cInstalledDrivers.
 *       If IBDM_REVERSE is set and hDriverStart is 0 then send messages
 *       to drivers with indices between cInstalledDrivers and 1.
 *
 * @rdesc returns non-zero if message was broadcast. If the IBDM_SENDMESSAGE
 *        flag is set, returns the return result from the driver proc.
 *
 ***************************************************************************/

LRESULT FAR PASCAL InternalBroadcastDriverMessage(UINT hDriverStart,
					       UINT message,
					       LPARAM lParam1,
					       LPARAM lParam2,
					       UINT flags)
{
    LPDRIVERTABLE lpdt;
    LRESULT       result=0;
    int           id;
    int           idEnd;


    DrvEnter();
    if (!hInstalledDriverList || (int)hDriverStart > cInstalledDrivers) {
	DrvLeave();
	return(FALSE);
    }

    if (flags & IBDM_SENDMESSAGE)
	{
	if (!hDriverStart) {
	    DrvLeave();
	    return (FALSE);
	}
	flags &= ~(IBDM_REVERSE | IBDM_ONEINSTANCEONLY);
	idEnd = hDriverStart;
	}

    else
	{
	if (flags & IBDM_REVERSE)
	    {
	    if (!hDriverStart)
		hDriverStart = cInstalledDrivers;
	    idEnd = -1;
	    }
	else
	    {
	    if (!hDriverStart) {
		DrvLeave();
		return (FALSE);
	    }
	    idEnd = cInstalledDrivers;
	    }
	}

    hDriverStart--;

    lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);

    for (id = hDriverStart; id != idEnd; ((flags & IBDM_REVERSE) ? id-- : id++))
	{
	DWORD_PTR  dwDriverIdentifier;
	DRIVERPROC lpDriverEntryPoint;

	if (lpdt[id].hModule)
	    {
	    if ((flags & IBDM_ONEINSTANCEONLY) &&
		!lpdt[id].fFirstEntry)
		continue;

	    lpDriverEntryPoint = lpdt[id].lpDriverEntryPoint;
	    dwDriverIdentifier = lpdt[id].dwDriverIdentifier;

	   /*
	    *  Allow normal messages to overlap - it's up to the
	    *  users not to send messages to stuff that's been unloaded
	    */

	    GlobalUnlock(hInstalledDriverList);
	    DrvLeave();

	    result =
		(*lpDriverEntryPoint)(dwDriverIdentifier,
				      (HANDLE)(UINT_PTR)(id+1),
				      message,
				      lParam1,
				      lParam2);

	    if (flags & IBDM_SENDMESSAGE) {
		return result;
	    }

	    DrvEnter();
	    lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);

	    }
	}

    GlobalUnlock(hInstalledDriverList);
    DrvLeave();

    return(result);
}


/***************************************************************************
 *
 * @doc DDK
 *
 * @api LONG | DrvSendMessage |  This function sends a message
 *      to a specified driver.
 *
 * @parm HANDLE | hDriver | Specifies the handle of the destination driver.
 *
 * @parm UINT | wMessage | Specifies a driver message.
 *
 * @parm LPARAM | lParam1 | Specifies the first message parameter.
 *
 * @parm LPARAM | lParam2 | Specifies the second message parameter.
 *
 * @rdesc Returns the results returned from the driver.
 *
 ***************************************************************************/

LRESULT APIENTRY DrvSendMessage(HANDLE hDriver, UINT message, LPARAM lParam1, LPARAM lParam2)
{
    if (fUseWinAPI)
	return (*lpSendDriverMessage)(hDriver, message, lParam1, lParam2);

    return(InternalBroadcastDriverMessage((UINT)(UINT_PTR)hDriver,
					  message,
					  lParam1,
					  lParam2,
					  IBDM_SENDMESSAGE));
}

/**************************************************************************
 *
 * @doc DDK
 *
 * @api LONG | DefDriverProc |  This function provides default
 * handling of system messages.
 *
 * @parm DWORD | dwDriverIdentifier | Specifies the identifier of
 * the device driver.
 *
 * @parm HANDLE | hDriver | Specifies the handle of the device driver.
 *
 * @parm UINT | wMessage | Specifies a driver message.
 *
 * @parm LPARAM | lParam1 | Specifies the first message parameter.
 *
 * @parm LPARAM | lParam2 | Specifies the second message parameter.
 *
 * @rdesc Returns 1L for DRV_LOAD, DRV_FREE, DRV_ENABLE, and DRV_DISABLE.
 * It returns 0L for all other messages.
 *
***************************************************************************/



LRESULT APIENTRY DefDriverProc(DWORD_PTR  dwDriverIdentifier,
			      HDRVR  hDriver,
			      UINT   message,
			      LPARAM lParam1,
			      LPARAM lParam2)
{

    switch (message)
	{
	case DRV_LOAD:
	case DRV_ENABLE:
	case DRV_DISABLE:
	case DRV_FREE:
	    return(1L);
	    break;
	case DRV_INSTALL:
	case DRV_REMOVE:
	    return(DRV_OK);
	    break;
       }

    return(0L);
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | DrvIsPreXp | Determines whether the installable driver's
 *      last modified date is before the approximate Windows XP ship date.
 *
 * @parm HANDLE | hDriver | Handle to installable driver.
 *
 * @rdesc BOOL | TRUE if the installable driver's last modified date is before
 *      the approximate Windows XP ship date.
 *
 * @comm If there was an error getting file attributes, then let's err on
 *    the side of an old driver and return TRUE.
 *
 ****************************************************************************/
BOOL DrvIsPreXp(IN HANDLE hDriver)
{
    WIN32_FILE_ATTRIBUTE_DATA fad;
    HMODULE hModule;
    BOOL fPreXp = TRUE;
    
    hModule = DrvGetModuleHandle(hDriver);
    if (hModule)
    {
    	TCHAR filename[MAX_PATH];

    	if (GetModuleFileName(hModule, filename, sizeof(filename)/sizeof(TCHAR)))
    	{
    	    if (GetFileAttributesEx(filename, GetFileExInfoStandard, &fad))
            {
    	        fPreXp = winmmFileTimeIsPreXp(&fad.ftLastWriteTime);
            }
            else
            {
    	        LONG error = GetLastError();
    	        dprintf(("DrvIsPreXp : error: GetFileAttributesEx failed, LastError=%d", error));
            }
    	    // dprintf(("DrvIsPreXp : note: %s fPreXp=%d", filename, fPreXp));
    	}
    	else
    	{
            LONG error = GetLastError();
            dprintf(("DrvIsPreXp : error: GetModuleFileName failed, LastError=%d", error));
    	}
    }
    else
    {
        dprintf(("DrvIsPreXp : error: DrvGetModuleHandle failed"));
    }
    
    return fPreXp;
}

MMRESULT mregCreateStringIdFromDriverPort(IN struct _MMDRV *pmmDrv, IN UINT port, OUT PWSTR* pStringId, OUT ULONG* pcbStringId)
{
    return StringId_Create(pmmDrv, port, pStringId, pcbStringId);
}

/*****************************************************************************
 * @doc INTERNAL WAVE
 *
 * @api MMRESULT | mregGetIdFromStringId | This function finds the waveOut
 *   device ID associated with the waveOut device identified by a unique
 *   string created by waveOutCreateStringIdFromId.
 *
 * @parm PCWSTR | StringId | Pointer to a unicode string identifying a
 *   waveOut device.
 *
 * @parm UINT* | puDeviceID | Address of a buffer to receive the waveOut
 *   device ID.
 *
 * @rdesc MMRESULT | Zero if successfull otherwise an error code defined
 *   in mmsystem.h.
 *
 * @comm The StringId is normally obtained by calling waveOutCreateStringIdFromId.
 *
 * @xref waveOutCreateStringIdFromId
 *
 ****************************************************************************/
MMRESULT mregGetIdFromStringId(IN PMMDRV pdrvZ, IN PCWSTR StringId, OUT UINT *puDeviceID)
{
    PMMDRV pdrv;
    PMMDRV pdrvTarget;
    UINT portTarget;
    UINT idTarget;
    MMRESULT mmr;

    if (!ValidateWritePointer(puDeviceID, sizeof(*puDeviceID))) return MMSYSERR_INVALPARAM;
    if (!ValidateStringW(StringId, (-1))) return MMSYSERR_INVALPARAM;

    EnterNumDevs("mregGetIdFromStringId");

    mmr = StringIdDict_Search(StringId, &pdrvTarget, &portTarget);
    if (!mmr)
    {
        idTarget = portTarget;
        for (pdrv = pdrvZ->Next; pdrv != pdrvZ; pdrv = pdrv->Next)
        {
    	    if (pdrv == pdrvTarget) break;
            
            //  Skipping mapper...
            if (pdrv->fdwDriver & MMDRV_MAPPER) continue;
            
    	    idTarget += pdrv->NumDevs;
        }
    }

    LeaveNumDevs("mregGetIdFromStringId");

    WinAssert(pdrv != pdrvZ);
    *puDeviceID = idTarget;

    return mmr;
}

MMRESULT mregQueryStringId(IN PMMDRV pdrv, IN UINT port, OUT WCHAR* pStringIdBuffer, IN ULONG cbStringIdBuffer)
{
    PWSTR StringId;
    MMRESULT mmr;

    mmr = mregCreateStringIdFromDriverPort(pdrv, port, &StringId, NULL);
    if (!mmr)
    {
	if (ValidateWritePointer(pStringIdBuffer, cbStringIdBuffer))
	{
	    int cchStringIdBuffer = cbStringIdBuffer / sizeof(WCHAR);
	
	    if (cchStringIdBuffer >= lstrlenW(StringId) + 1)
	    {
		cchStringIdBuffer = lstrlenW(StringId) + 1;
		mmr = MMSYSERR_NOERROR;
	    } else {
		mmr = MMSYSERR_MOREDATA;
	    }
	    lstrcpynW(pStringIdBuffer, StringId, cchStringIdBuffer);
	} else {
	    mmr = MMSYSERR_INVALPARAM;
	}
	
    	HeapFree(hHeap, 0, StringId);
    }
    	
    return mmr;

}

MMRESULT mregQueryStringIdSize(IN PMMDRV pdrv, IN UINT port, OUT ULONG* pcbStringId)
{
    PWSTR StringId;
    MMRESULT mmr;

    if (ValidateWritePointer(pcbStringId, sizeof(*pcbStringId)))
    {
        mmr = mregCreateStringIdFromDriverPort(pdrv, port, NULL, pcbStringId);
    }
    else
    {
	mmr = MMSYSERR_INVALPARAM;
    }

    return mmr;
}

PMMDRV mregGetDrvListFromClass(DWORD dwClass)
{
    PMMDRV pdrvZ;

    switch (dwClass)
    {
    	case TYPE_WAVEOUT:
	    pdrvZ = &waveoutdrvZ;
    	    break;
    	case TYPE_WAVEIN:
	    pdrvZ = &waveindrvZ;
    	    break;
    	case TYPE_MIDIOUT:
	    pdrvZ = &midioutdrvZ;
    	    break;
    	case TYPE_MIDIIN:
	    pdrvZ = &midiindrvZ;
    	    break;
    	case TYPE_AUX:
	    pdrvZ = &auxdrvZ;
    	    break;
    	case TYPE_MIXER:
	    pdrvZ = &mixerdrvZ;
    	    break;
    	default:
    	    pdrvZ = NULL;
    	    WinAssert(FALSE);
    }

    return pdrvZ;
}

/*==========================================================================*/
BOOL FAR PASCAL mregHandleInternalMessages(
    PMMDRV      pmmdrv,
    DWORD       dwClass,
    UINT        idPort,
    UINT        uMessage,
    DWORD_PTR   dwParam1,
    DWORD_PTR   dwParam2,
    MMRESULT  * pmmr)
{
    UINT            cbSize;
    PMMDRV          pmd = (PMMDRV)pmmdrv;
    BOOL            fResult = TRUE;
    MMRESULT        mmr = MMSYSERR_NOERROR;
    HMODULE         hModule;
#ifndef UNICODE
    TCHAR szBuff[MAX_PATH];
#endif // End UNICODE

    switch (uMessage)
    {
	case DRVM_MAPPER_PREFERRED_GET:
	    if (TYPE_WAVEOUT == dwClass) {
		if ((pmmdrv->fdwDriver & MMDRV_MAPPER) &&
		    ValidateWritePointer((PUINT)dwParam1, sizeof(UINT)) &&
		    ValidateWritePointer((PDWORD)dwParam2, sizeof(DWORD)))
		{
		    waveOutGetCurrentPreferredId((PUINT)dwParam1, (PDWORD)dwParam2);
		    mmr = MMSYSERR_NOERROR;
		} else {
		    mmr = MMSYSERR_INVALPARAM;
		}
	    } else if (TYPE_WAVEIN == dwClass) {
		if ((pmmdrv->fdwDriver & MMDRV_MAPPER) &&
		    ValidateWritePointer((PUINT)dwParam1, sizeof(UINT)) &&
		    ValidateWritePointer((PDWORD)dwParam2, sizeof(DWORD)))
		{
		    waveInGetCurrentPreferredId((PUINT)dwParam1, (PDWORD)dwParam2);
		    mmr = MMSYSERR_NOERROR;
		} else {
		    mmr = MMSYSERR_INVALPARAM;
		}
	    } else if (TYPE_MIDIOUT == dwClass) {
		if ((pmmdrv->fdwDriver & MMDRV_MAPPER) &&
		    ValidateWritePointer((PUINT)dwParam1, sizeof(UINT)) &&
		    ValidateWritePointer((PDWORD)dwParam2, sizeof(DWORD)))
		{
		    midiOutGetCurrentPreferredId((PUINT)dwParam1, (PDWORD)dwParam2);
		    mmr = MMSYSERR_NOERROR;
		} else {
		    mmr = MMSYSERR_INVALPARAM;
		}
	    } else {
		mmr = MMSYSERR_INVALPARAM;
	    }
	    break;
		
	case DRVM_MAPPER_PREFERRED_SET:
	    if (TYPE_WAVEOUT == dwClass) {
		if (pmmdrv->fdwDriver & MMDRV_MAPPER) {
		    mmr = waveOutSetPersistentPreferredId((UINT)dwParam1, (DWORD)dwParam2);
		} else {
		    mmr = MMSYSERR_INVALPARAM;
		}
	    } else if (TYPE_WAVEIN == dwClass) {
		if (pmmdrv->fdwDriver & MMDRV_MAPPER) {
		    mmr = waveInSetPersistentPreferredId((UINT)dwParam1, (DWORD)dwParam2);
		} else {
		    mmr = MMSYSERR_INVALPARAM;
		}
	    } else if (TYPE_MIDIOUT == dwClass) {
		if (pmmdrv->fdwDriver & MMDRV_MAPPER) {
		    mmr = midiOutSetPersistentPreferredId((UINT)dwParam1, (DWORD)dwParam2);
		} else {
		    mmr = MMSYSERR_INVALPARAM;
		}
	    } else {
		mmr = MMSYSERR_INVALPARAM;
	    }
	    break;

	case DRVM_MAPPER_CONSOLEVOICECOM_GET:
	    if (TYPE_WAVEOUT == dwClass) {
		if ((pmmdrv->fdwDriver & MMDRV_MAPPER) &&
		    ValidateWritePointer((PUINT)dwParam1, sizeof(UINT)) &&
		    ValidateWritePointer((PDWORD)dwParam2, sizeof(DWORD)))
		{
		    waveOutGetCurrentConsoleVoiceComId((PUINT)dwParam1, (PDWORD)dwParam2);
		    mmr = MMSYSERR_NOERROR;
		} else {
		    mmr = MMSYSERR_INVALPARAM;
		}
	    } else if (TYPE_WAVEIN == dwClass) {
		if ((pmmdrv->fdwDriver & MMDRV_MAPPER) &&
		    ValidateWritePointer((PUINT)dwParam1, sizeof(UINT)) &&
		    ValidateWritePointer((PDWORD)dwParam2, sizeof(DWORD)))
		{
		    waveInGetCurrentConsoleVoiceComId((PUINT)dwParam1, (PDWORD)dwParam2);
		    mmr = MMSYSERR_NOERROR;
		} else {
		    mmr = MMSYSERR_INVALPARAM;
		}
	    } else {
		mmr = MMSYSERR_INVALPARAM;
	    }
            break;

	case DRVM_MAPPER_CONSOLEVOICECOM_SET:
	    if (TYPE_WAVEOUT == dwClass) {
		if (pmmdrv->fdwDriver & MMDRV_MAPPER) {
		    mmr = waveOutSetPersistentConsoleVoiceComId((UINT)dwParam1, (DWORD)dwParam2);
		} else {
		    mmr = MMSYSERR_INVALPARAM;
		}
	    } else if (TYPE_WAVEIN == dwClass) {
		if (pmmdrv->fdwDriver & MMDRV_MAPPER) {
		    mmr = waveInSetPersistentConsoleVoiceComId((UINT)dwParam1, (DWORD)dwParam2);
		} else {
		    mmr = MMSYSERR_INVALPARAM;
		}
	    } else {
		mmr = MMSYSERR_INVALPARAM;
	    }
            break;

	case DRV_QUERYFILENAME:
		// Get Driver's FileName
		if ( ((cbSize = (DWORD)dwParam2 * sizeof(WCHAR)) > 0) &&
		     (ValidateWritePointer( (LPVOID)dwParam1, cbSize)) )
		{
			lstrncpyW ((LPWSTR)dwParam1,
				   pmd->wszDrvEntry,
				   (DWORD)dwParam2-1);
			((LPWSTR)dwParam1)[ dwParam2-1 ] = TEXT('\0');
		}
		else
		{
			mmr = MMSYSERR_INVALPARAM;
		}
		break;

    case DRV_QUERYDRVENTRY:
    case DRV_QUERYNAME:
    case DRV_QUERYDEVNODE:
    case DRV_QUERYDRIVERIDS:
		//      Note:   Not applicable or obsolete.
		mmr = MMSYSERR_NOTSUPPORTED;
		break;

    case DRV_QUERYDEVICEINTERFACE:
    {
	// dwParam1 is a pointer to a buffer to contain device interface
	// dwParam2 is the length in bytes of the buffer
	PWSTR pwstrDeviceInterfaceOut = (PWSTR)dwParam1;
	UINT cbDeviceInterfaceOut = (UINT)dwParam2;
	PWSTR pwstrDeviceInterface = (PWSTR)pmd->cookie;
	int cchDeviceInterfaceOut = cbDeviceInterfaceOut / sizeof(WCHAR);

	if (ValidateWritePointer(pwstrDeviceInterfaceOut, cbDeviceInterfaceOut))
	{
	    if (pwstrDeviceInterface)
	    {
		if (cchDeviceInterfaceOut >= lstrlenW(pwstrDeviceInterface) + 1)
		{
		    cchDeviceInterfaceOut = lstrlenW(pwstrDeviceInterface) + 1;
		    mmr = MMSYSERR_NOERROR;
		} else {
		    mmr = MMSYSERR_MOREDATA;
		}
		lstrcpynW(pwstrDeviceInterfaceOut, pwstrDeviceInterface, cchDeviceInterfaceOut);
	    } else {
		if (cchDeviceInterfaceOut >= 1)
		{
		    *pwstrDeviceInterfaceOut = '\0';
		    mmr = MMSYSERR_NOERROR;
		} else {
		    mmr = MMSYSERR_MOREDATA;
		}
	    }
	} else {
	    mmr = MMSYSERR_INVALPARAM;
	}
	break;
    }

    case DRV_QUERYDEVICEINTERFACESIZE:
    {
	// dwParam1 is a pointer to a buffer to contain a ULONG count of bytes
	// in the device interface name
	PULONG pcbDeviceInterface = (PULONG)dwParam1;
	
	if (ValidateWritePointer(pcbDeviceInterface, sizeof(ULONG)))
	{
	    if (pmd->cookie)
	    {
		*pcbDeviceInterface = (lstrlenW((PWSTR)pmd->cookie) + 1) * sizeof(WCHAR);
	    } else {
		*pcbDeviceInterface = 1 * sizeof(WCHAR);
	    }
	    mmr = MMSYSERR_NOERROR;
	} else {
	    mmr = MMSYSERR_INVALPARAM;
	}
	break;
    }

    case DRV_QUERYSTRINGID:
    {
    	mmr = mregQueryStringId(pmmdrv, idPort, (WCHAR*)dwParam1, (ULONG)dwParam2);
    	break;
    }

    case DRV_QUERYSTRINGIDSIZE:
    {
    	mmr = mregQueryStringIdSize(pmmdrv, idPort, (ULONG*)dwParam1);
    	break;
    }

    case DRV_QUERYIDFROMSTRINGID:
    {
        mmr = mregGetIdFromStringId(mregGetDrvListFromClass(dwClass), (PCWSTR)dwParam1, (UINT*)dwParam2);
        break;
    }

    case DRV_QUERYMAPPABLE:
        {
            TCHAR   szRegKey[MAX_PATH+1];
            HKEY    hKey;

            if (dwParam1 || dwParam2)
                return MMSYSERR_INVALPARAM;

#ifdef UNICODE
            wsprintfW (szRegKey, TEXT("%s\\%s"), REGSTR_PATH_WAVEMAPPER, pmd->wszDrvEntry);
#else
            {
                CHAR aszDrvEntry[CHAR_GIVEN_BYTE(sizeof(pmd->wszDrvEntry))+1];

                cbSize = sizeof(aszDrvEntry);
                UnicodeStrToAsciiStr((LPBYTE)aszDrvEntry, (LPBYTE)aszDrvEntry + cbSize,
                                     pmd->wszDrvEntry);

                wsprintfA (szRegKey, TEXT("%s\\%s"), REGSTR_PATH_WAVEMAPPER, aszDrvEntry);
            }
#endif

            if (RegOpenKey (HKEY_LOCAL_MACHINE, szRegKey, &hKey) != ERROR_SUCCESS)
            {
                mmr = MMSYSERR_NOERROR;
            }
            else
            {
                DWORD   dwMappable;
                DWORD   dwSize;
                DWORD   dwType;

                dwSize = sizeof(dwMappable);
                if (RegQueryValueEx (hKey,
                                     REGSTR_VALUE_MAPPABLE,
                                     NULL,
                                     &dwType,
                                     (void *)&dwMappable,
                                     &dwSize) != ERROR_SUCCESS)
                {
                    dwMappable = 1;
                }

                RegCloseKey (hKey);

                mmr = (dwMappable) ? MMSYSERR_NOERROR :
                                     MMSYSERR_NOTSUPPORTED;
            }
        }
        break;
	
	case DRV_QUERYMAPID:
		WinAssert(DRV_QUERYMAPID != uMessage);
		mmr = MMSYSERR_NOTSUPPORTED;
		break;

	case DRV_QUERYNUMPORTS:
		if (ValidateWritePointer( (LPVOID)dwParam1, sizeof(DWORD)))
		{
			*((LPDWORD)dwParam1) = pmd->NumDevs;
		}
		else
		{
			mmr = MMSYSERR_INVALPARAM;
		}
		break;

	case DRV_QUERYMODULE:
		if (ValidateWritePointer( (LPVOID)dwParam1, sizeof(DWORD)))
		{
			hModule = DrvGetModuleHandle(pmd->hDriver);
			*((HMODULE *)dwParam1) = hModule;
		}
		else
		{
			mmr = MMSYSERR_INVALPARAM;
		}
		break;

	default:
			// Not an internal message
		fResult = FALSE;
		break;
	}

	if (pmmr)
		*pmmr = mmr;
	
    return fResult;
} // End mregHandleInternalMessage


/*==========================================================================*/
/*
@doc    INTERNAL MMSYSTEM
@func   <t UINT> | mregRemoveDriver |
	Sends exit message to the driver message entry, and closes the
	installable driver.  Then releases resources referenced by the MMDRV
	structure.  Finally removes the MMDRV structure from its list and
	frees it.


@parm   <t PMMDRV> | pdrv |
	Pointer to the MMDRV node associated with the driver

@rdesc  No return value

@comm   This function assumes the list containing pdrv is locked.

@xref   mregDecUsage
*/
void mregRemoveDriver(PMMDRV pdrv)
{
    WinAssert(pdrv->cookie);
    WinAssert(pdrv->drvMessage);
    WinAssert(pdrv->hDriver);

    StringIdDict_Remove(pdrv);

    pdrv->drvMessage(0, DRVM_EXIT, 0L, 0L, (DWORD_PTR)pdrv->cookie);
    DrvClose(pdrv->hDriver, 0, 0);

    pdrv->Prev->Next = pdrv->Next;
    pdrv->Next->Prev = pdrv->Prev;

    DeleteCriticalSection(&pdrv->MixerCritSec);
    wdmDevInterfaceDec(pdrv->cookie);

    ZeroMemory(pdrv, sizeof(*pdrv));
    HeapFree(hHeap, 0, pdrv);

    return;
}

void mregAddDriver(PMMDRV pdrvZ, PMMDRV pdrv)
{
    pdrv->Prev = pdrvZ->Prev;
    pdrv->Next = pdrvZ;
    pdrv->Prev->Next = pdrv;
    pdrv->Next->Prev = pdrv;

    StringIdDict_Insert(pdrv);
}

/*==========================================================================*/
/*
@doc    INTERNAL MMSYSTEM
@func   <t UINT> | mregIncUsage |
	Increments the usage count of the specified media resource. If the
	usage count is non-zero, the media resource cannot be unloaded. The
	usage count is increased when instances of the media resource are
	opened, such as with a <f waveOutOpen> call.

@parm   <t HMD> | hmd |
	Contains the media resource handle to increment.

@rdesc  Returns the current usage count.

@xref   mregDecUsage, mregQueryUsage
*/
UINT FAR PASCAL mregIncUsagePtr(
    PMMDRV pmd
)
{
    return InterlockedIncrement(&pmd->Usage);
}

UINT FAR PASCAL mregIncUsage(
    HMD hmd
)
{
    return mregIncUsagePtr(HtoPT(PMMDRV, hmd));
}

/*==========================================================================*/
/*
@doc    INTERNAL MMSYSTEM
@func   <t UINT> | mregDecUsage |
	Decrements the usage count of the specified media resource. If the
	usage count is zero, the media resource can be unloaded. The usage
	count is decresed when instance of the media resource are closed, such
	as with a <f waveOutClose> call.

@parm   <t PMMDRV> | pdrv |
	Pointer to the media resource to decrement.

@rdesc  Returns the current usage count.

@comm   Unless the caller has other usages on the pdrv, it must not use
        it after this call returns.

@xref   mregIncUsage, mregQueryUsage
*/
UINT FAR PASCAL mregDecUsagePtr(
    PMMDRV pdrv
)
{
    UINT refcount;

    EnterNumDevs("mregDecUsage");
    refcount = InterlockedDecrement(&pdrv->Usage);
    if (0 == refcount)
    {
        WinAssert(pdrv->fdwDriver & MMDRV_DESERTED);
        mregRemoveDriver(pdrv);
    }
    LeaveNumDevs("mregDecUsage");
    return refcount;
}

UINT FAR PASCAL mregDecUsage(
    HMD hmd
)
{
    return mregDecUsagePtr(HtoPT(PMMDRV, hmd));
}


/*==========================================================================*/
/*
@doc    INTERNAL MMSYSTEM
@func   <t MMRESULT> | mregFindDevice |
	Given a Device Identifier of a specific Resource Class, returns the
	corresponding Resource handle and port. This can then be used to
	communicate with the driver.  The resource handle is referenced
	(i.e., its usage is incremented).  The caller is responsible for
	ensureing it is eventually released by calling mregDecUsage.

@parm   <t UINT> | uDeviceID |
	Contains the Device Identifier whose handle and port is to be returned.
	If this contains -1, then it is assumed that a mapper of the specified
	class is being sought. These identifiers correspond to the <lq>Device
	IDs<rq> used with various functions such as <f waveOutOpen>. This
	enables the various components to search for internal media resource
	handles based on Device IDs passed to public APIs.
@parm   <t WORD> | fwFindDevice |
	Contains the flags specifying the class of device.
@flag   <cl MMDRVI_WAVEIN> | Wave Input device.
@flag   <cl MMDRVI_WAVEOUT> | Wave Output device.
@flag   <cl MMDRVI_MIDIIN> | MIDI Input device.
@flag   <cl MMDRVI_MIDIOUT> | MIDI Output device.
@flag   <cl MMDRVI_AUX> | Aux device.
@flag   <cl MMDRVI_MIXER> | Mixer device.
@flag   <cl MMDRVI_JOY> | Joystick device.
@flag   <cl MMDRVI_MAPPER> | Mapper device of the specified class. This is used
	in addition to any of the above resource classes in order to specify
	that the class mapper is to be returned. If this is not specified, the
	mapper is not returned as a match to a query.

@parm   <t HMD> <c FAR>* | phmd |
	Points to a buffer in which to place the Media Resource Handle.
@parm   <t UINT> <c FAR>* | puDevicePort |
	Points to a buffer in which to place the Device Port. This is used as
	a parameter when sending messages to the device to specify which port.

@rdesc  Returns <cl MMSYSERR_BADDEVICEID> if the specified Device Identifier was
	out of range, else <cl MMSYSERR_NOERROR> on success.

@xref   mregEnumDevice, mregGetNumDevs, mregDecUsage
*/

MMRESULT FAR PASCAL mregFindDevice(
	UINT            uDeviceID,
	WORD            fwFindDevice,
	HMD FAR*        phmd,
	UINT FAR*       puDevicePort)
{
	PMMDRV   pmd;
	UINT     port;
	MMRESULT mmr;

	WinAssert((TYPE_MIDIOUT == (fwFindDevice & MMDRVI_TYPE)) || (TYPE_MIDIIN == (fwFindDevice & MMDRVI_TYPE)));
	switch (fwFindDevice & MMDRVI_TYPE)
	{
	case    TYPE_MIDIOUT:
          mmr = midiReferenceDriverById(&midioutdrvZ, uDeviceID, &pmd, &port);
	  break;

	case    TYPE_MIDIIN:
           mmr = midiReferenceDriverById(&midiindrvZ, uDeviceID, &pmd, &port);
	   break;

	default:
	   return MMSYSERR_BADDEVICEID;

	}

	if (!mmr)
	{
	    WinAssert(pmd);
	    *phmd = PTtoH(HMD, pmd);
	    *puDevicePort = port;
	}
	return mmr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\clock.c ===
/*****************************************************************************
    microclk.c

    Micro-ClockWork for MIDI subsystem

    Copyright (c) 1993-1999 Microsoft Corporation

*****************************************************************************/

#define INCL_WINMM
#include "winmmi.h"
#include "muldiv32.h"

//#define STRICT
//#include <windows.h>
//#include <windowsx.h>
//#include "mmsystem.h"
//#include "mmddk.h"
//#include "mmsysi.h"
//#include "debug.h"

//
// This stuff needs to be do-able from inside a callback.
//
#ifndef WIN32
#pragma alloc_text(FIXMIDI, clockSetRate)
#pragma alloc_text(FIXMIDI, clockTime)
#pragma alloc_text(FIXMIDI, clockOffsetTo)
#endif

/****************************************************************************
 * @doc INTERNAL  CLOCK
 *
 * @func void | clockInit | This function initializes a clock for the first
 * time. It prepares the clock for use without actually starting it.
 *
 * @parm PCLOCK | pclock | The clock to initialize.
 *
 * @parm MILLISECS | msPrev | The number of milliseconds that have passed
 * up to the time when the clock is started. This option is provided so
 * that a clock may be initialized and started in the middle of a stream
 * without actually running to that point. Normally, this will be zero.
 *
 * @parm TICKS | tkPrev | The number of ticks that have elapsed up to the
 * next time the clock starts. This should specify the same instant in
 * time as msPrev.
 *
 * @comm The clock's numerator and divisor will be set to 1 indicating that
 * the clock will run in milliseconds. Use clockSetRate before starting the
 * clock for the first time if this is not the desired rate.
 *
 ***************************************************************************/

void FAR PASCAL clockInit
(
    PCLOCK      pclock,
    MILLISECS   msPrev,
    TICKS       tkPrev,
    CLK_TIMEBASE fnTimebase
)
{
//    dprintf1(( "clockInit(%04X) %lums %lutk", pclock, msPrev, tkPrev));

    pclock->msPrev      = msPrev;
    pclock->tkPrev      = tkPrev;
    pclock->dwNum       = 1;
    pclock->dwDenom     = 1;
    pclock->dwState     = CLK_CS_PAUSED;
    pclock->msT0        = 0;
    pclock->fnTimebase  = fnTimebase;
}

/****************************************************************************
 * @doc INTERNAL  CLOCK
 *
 * @func void | clockSetRate | This functions sets a new rate for the clock.
 *
 * @parm PCLOCK | pclock | The clock to set the rate.
 *
 * @parm TICKS | tkWhen | This parameter specifies the absolute tick
 * time at which the rate change happened. This must be at or before the
 * current tick; you cannot schedule a pending rate change.
 *  @flag CLK_TK_NOW | Specify this flag if you want the rate change to
 *  happen now (this will be the time the clock was paused if it is paused
 *  now).
 *
 * @parm DWORD | dwNum | Specifies the new numerator for converting
 * milliseconds to ticks.
 *
 * @parm DWORD | dwDenom | Specifies the new denominator for converting
 * milliseconds to ticks.
 *
 * @comm The clock's state will not be changed by this call; if it is
 * paused, it will stay paused.
 *
 ***************************************************************************/

void FAR PASCAL clockSetRate
(
    PCLOCK      pclock,
    TICKS       tkWhen,
    DWORD       dwNum,
    DWORD       dwDenom
)
{
    MILLISECS   msInPrevEpoch = pclock->fnTimebase(pclock) - pclock->msT0;
    TICKS       tkInPrevEpoch;

    dprintf1(( "clockSetRate(%04X) %lutk Rate=%lu/%lu", pclock, tkWhen, dwNum, dwDenom));

    if (CLK_CS_PAUSED == pclock->dwState)
    {
        //
        // !!! Calling clockSetRate on a paused clock which has never been
        // started causes problems !!!
        //
    
        dprintf1(( "clockSetRate called when clock is paused."));
    }
    
    if (0 == dwNum || 0 == dwDenom)
    {
        dprintf1(( "Attempt to set 0 or infinite tick ratio!"));
        return;
    }

    if (CLK_TK_NOW == tkWhen)
    {
        tkInPrevEpoch = clockTime(pclock);
    }
    else
    {
        tkInPrevEpoch = tkWhen - pclock->tkPrev;
        msInPrevEpoch = muldiv32(tkInPrevEpoch, pclock->dwDenom, pclock->dwNum);
    }

    pclock->tkPrev += tkInPrevEpoch;
    pclock->msPrev += msInPrevEpoch;
    pclock->msT0   += msInPrevEpoch;

    pclock->dwNum   = dwNum;
    pclock->dwDenom = dwDenom;
}


/****************************************************************************
 * @doc INTERNAL  CLOCK
 *
 * @func void | clockPause | This functions pauses a clock.
 *
 * @parm PCLOCK | pclock | The clock to pause.
 *
 * @parm TICKS | tkWhen | The tick time to pause the clock.
 *  @flag CLK_TK_NOW | Specify this flag if you want the rate change to
 *  happen now (this will be the time the clock was paused if it is paused
 *  now).
 *
 * @comm If the clock is already paused, this call will have no effect.
 *
 ***************************************************************************/

void FAR PASCAL clockPause
(
    PCLOCK      pclock,
    TICKS       tkWhen
)
{
    MILLISECS   msNow = pclock->fnTimebase(pclock) - pclock->msT0;
    TICKS       tkNow;

//    dprintf1(( "clockPause(%04X) %lutk", pclock, tkWhen));

    if (CLK_CS_PAUSED == pclock->dwState)
    {
        dprintf1(( "Pause already paused clock!"));
        return;
    }

    //
    // Start a new epoch at the same rate. Then start will just have to
    // change the state and set a new T0.
    //
    if (CLK_TK_NOW == tkWhen)
    {
        tkNow = pclock->tkPrev +
                muldiv32(msNow, pclock->dwNum, pclock->dwDenom);
    }
    else
    {
        msNow = muldiv32(tkWhen - pclock->tkPrev, pclock->dwDenom, pclock->dwNum);
        tkNow = tkWhen;
    }

    pclock->dwState = CLK_CS_PAUSED;
    pclock->msPrev  += msNow;
    pclock->tkPrev  = tkNow;
}

/****************************************************************************
 * @doc INTERNAL  CLOCK
 *
 * @func void | clockRestart | This functions starts a paused clock.
 *
 * @parm PCLOCK | pclock | The clock to start.
 *
 * @comm If the clock is already running, this call will have no effect.
 *
 ***************************************************************************/

void FAR PASCAL clockRestart
(
    PCLOCK      pclock,
    TICKS       tkWhen,                     // What time it is now
    MILLISECS   msWhen                      // Offset for fnTimebase()
)
{
    MILLISECS   msDelta;

//    dprintf1(( "clockRestart(%04X)", pclock));

    if (CLK_CS_RUNNING == pclock->dwState)
    {
        dprintf1(( "Start already running clock!"));
        return;
    }

    // We've been given what tick time the clock SHOULD be at. Adjust the
    // clock to match this. We need to add the equivalent number of ms
    // into msPrev
    //
    msDelta = muldiv32(tkWhen - pclock->tkPrev, pclock->dwDenom, pclock->dwNum);

    dprintf1(( "clockRestart: Was tick %lu, now %lu, added %lu ms", pclock->tkPrev, tkWhen, msDelta));

    pclock->tkPrev  = tkWhen;
    pclock->msPrev += msDelta;
    pclock->dwState = CLK_CS_RUNNING;
    pclock->msT0    = msWhen;
}

/****************************************************************************
 * @doc INTERNAL  CLOCK
 *
 * @func DWORD | clockTime | This function returns the current absolute tick
 * time.
 *
 * @parm PCLOCK | pclock | The clock to read.
 *
 * @rdesc The current time.
 *
 * @comm If the clock is paused, the returned time will be the time the
 * clock was paused.
 *
 ***************************************************************************/

TICKS FAR PASCAL clockTime
(
    PCLOCK      pclock
)
{
    MILLISECS   msNow;
    TICKS       tkNow;
    TICKS       tkDelta;

    msNow = pclock->fnTimebase(pclock) - pclock->msT0;
    tkNow = pclock->tkPrev;

    if (CLK_CS_RUNNING == pclock->dwState)
    {
        tkDelta = muldiv32(msNow, pclock->dwNum, pclock->dwDenom);
        tkNow += tkDelta;
    }

//  dprintf1(( "clockTime() timeGetTime() %lu msT0 %lu", (MILLISECS)pclock->fnTimebase(pclock), pclock->msT0));
//  dprintf1(( "clockTime() tkPrev %lutk msNow %lums dwNum %lu dwDenom %lu tkDelta %lutk", pclock->tkPrev, msNow, pclock->dwNum, pclock->dwDenom, tkDelta));
//  dprintf1(( "clockTime(%04X) -> %lutk", pclock, tkNow));
    return tkNow;
}

/****************************************************************************
 * @doc INTERNAL  CLOCK
 *
 * @func DWORD | clockMsTime | This function returns the current absolute
 * millisecond time.
 *
 * @parm PCLOCK | pclock | The clock to read.
 *
 * @rdesc The current time.
 *
 * @comm If the clock is paused, the returned time will be the time the
 * clock was paused.
 *
 ***************************************************************************/

MILLISECS FAR PASCAL clockMsTime
(
    PCLOCK      pclock
)
{
    MILLISECS   msNow = pclock->fnTimebase(pclock) - pclock->msT0;
    MILLISECS   msRet;

    msRet = pclock->msPrev;

    if (CLK_CS_RUNNING == pclock->dwState)
    {
        msRet += msNow;
    }

//    dprintf1(( "clockMsTime(%04X) -> %lums", pclock, msRet));
    return msRet;
}

/****************************************************************************
 * @doc INTERNAL  CLOCK
 *
 * @func DWORD | clockOffsetTo | This function determines the number
 * of milliseconds in the future that a given tick time will occur,
 * assuming the clock runs continously and monotonically until then.
 *
 * @parm PCLOCK | pclock | The clock to read.
 *
 * @parm TICKS | tkWhen | The tick value to calculate the offset to.
 *
 * @rdesc The number of milliseconds until the desired time. If the time
 * has already passed, 0 will be returned. If the clock is paused,
 * the largest possible value will be returned ((DWORD)-1L).
 *
 ***************************************************************************/

MILLISECS FAR PASCAL clockOffsetTo
(
    PCLOCK      pclock,
    TICKS       tkWhen
)
{
    TICKS       tkOffset;
    MILLISECS   msOffset;

    if (CLK_CS_PAUSED == pclock->dwState)
    {
        msOffset = (MILLISECS)-1L;
    }
    else
    {
        tkOffset = clockTime(pclock);
        if (tkOffset >= tkWhen)
        {
            msOffset = 0;
        }
        else
        {
            msOffset = muldiv32(tkWhen-tkOffset, pclock->dwDenom, pclock->dwNum);
        }
    }

//    dprintf1(( "clockOffsetTo(%04X, %lutk)@%lutk -> %lums", pclock, tkWhen, tkOffset, msOffset));

    return msOffset;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\auxout.c ===
/****************************************************************************
    auxout.c

    Level 1 kitchen sink DLL aux support module

    Copyright (c) 1990-2001 Microsoft Corporation

    Changes for NT :
        Change parameters for MapAuxId to return the driver index rather
        than a pointer

        change list of include files

        widen function parameters and return codes

        Change WINAPI to APIENTRY

    History
        10/1/92  Updated for NT by Robin Speed (RobinSp)
****************************************************************************/
#include "winmmi.h"

/****************************************************************************
 * @doc INTERNAL  AUX
 *
 * @func MMRESULT | auxReferenceDriverById | This function maps a logical id
 *   to a device driver and physical id.
 *
 * @parm IN UINT | id | The logical id to be mapped.
 *
 * @parm OUT PAUXRV* OPTIONAL | ppauxdrv | Pointer to AUXDRV structure
 *    describing the driver supporting the id.
 *
 * @parm OUT UINT* OPTIONAL | pport | The driver-relative device number. If
 *    the caller supplies this buffer then it must also supply ppauxdrv.
 *
 * @rdesc The return value is zero if successful, MMSYSERR_BADDEVICEID if
 *   the id is out of range.
 *
 * @comm If the caller specifies ppwavedrv then this function increments
 *       the zuxdrv's usage before returning.  The caller must ensure
 *       the usage is eventually decremented.
 *
 ****************************************************************************/
MMRESULT auxReferenceDriverById(IN UINT id, OUT PAUXDRV *ppauxdrv OPTIONAL, OUT UINT *pport OPTIONAL)
{
    PAUXDRV  pdrv;
    MMRESULT mmr;

    // Should not be called asking for port but not auxdrv
    WinAssert(!(pport && !ppauxdrv));

    EnterNumDevs("auxReferenceDriverById");
    
    if (AUX_MAPPER == id)
    {
	id = 0;
    	for (pdrv = auxdrvZ.Next; pdrv != &auxdrvZ; pdrv = pdrv->Next)
    	{
    	    if (pdrv->fdwDriver & MMDRV_MAPPER) break;
    	}
    } else {
    	for (pdrv = auxdrvZ.Next; pdrv != &auxdrvZ; pdrv = pdrv->Next)
        {
            if (pdrv->fdwDriver & MMDRV_MAPPER) continue;
            if (pdrv->NumDevs > id) break;
            id -= pdrv->NumDevs;
        }
    }

    if (pdrv != &auxdrvZ)
    {
    	if (ppauxdrv)
    	{
    	    mregIncUsagePtr(pdrv);
    	    *ppauxdrv = pdrv;
    	    if (pport) *pport = id;
    	}
    	mmr = MMSYSERR_NOERROR;
    } else {
        mmr = MMSYSERR_BADDEVICEID;
    }

    LeaveNumDevs("auxReferenceDriverById");
    
    return mmr;
}

PCWSTR auxReferenceDevInterfaceById(UINT id)
{
    PAUXDRV pdrv;
    if (!auxReferenceDriverById(id, &pdrv, NULL))
    {
    	PCWSTR DevInterface;
    	DevInterface = pdrv->cookie;
    	if (DevInterface) wdmDevInterfaceInc(DevInterface);
    	mregDecUsagePtr(pdrv);
    	return DevInterface;
    }
    return NULL;
}

/*****************************************************************************
 * @doc EXTERNAL AUX
 *
 * @func MMRESULT | auxOutMessage | This function sends a messages to an auxiliary
 * output device.  It also performs error checking on the device ID passed.
 *
 * @parm UINT | uDeviceID | Identifies the auxiliary output device to be
 *   queried. Specify a valid device ID (see the following comments
 *   section), or use the following constant:
 *   @flag AUX_MAPPER | Auxiliary audio mapper. The function will
 *     return an error if no auxiliary audio mapper is installed.
 *
 * @parm UINT | uMessage  | The message to send.
 *
 * @parm DWORD | dw1Param1 | Parameter 1.
 *
 * @parm DWORD | dw2Param2 | Parameter 2.
 *
 * @rdesc Returns the value returned from the driver.
 *
 ****************************************************************************/
MMRESULT APIENTRY auxOutMessage(
        UINT        uDeviceID,
        UINT        uMessage,
        DWORD_PTR   dwParam1,
        DWORD_PTR   dwParam2)
{
    PAUXDRV  auxdrvr;
    UINT     port;
    DWORD    mmr;

    ClientUpdatePnpInfo();

    mmr = auxReferenceDriverById(uDeviceID, &auxdrvr, &port);
    if (mmr) return mmr;
        
    if (!auxdrvr->drvMessage)
    {
        mmr = MMSYSERR_NODRIVER;
    }
    else if (!mregHandleInternalMessages (auxdrvr, TYPE_AUX, port, uMessage, dwParam1, dwParam2, &mmr))
    {
    	mmr = (MMRESULT)auxdrvr->drvMessage(port, uMessage, 0L, dwParam1, dwParam2);
    }

    mregDecUsagePtr(auxdrvr);
    return mmr;
}

/*****************************************************************************
 * @doc EXTERNAL AUX
 *
 * @api UINT | auxGetNumDevs | This function retrieves the number of auxiliary
 *   output devices present in the system.
 *
 * @rdesc Returns the number of auxiliary output devices present in the system.
 *
 * @xref auxGetDevCaps
 ****************************************************************************/
UINT APIENTRY auxGetNumDevs(void)
{
    UINT    cDevs;

      ClientUpdatePnpInfo();

      EnterNumDevs("auxGetNumDevs");
        cDevs = (UINT)wTotalAuxDevs;
      LeaveNumDevs("auxGetNumDevs");

    return cDevs;
}

/*****************************************************************************
 * @doc EXTERNAL AUX
 *
 * @api MMRESULT | auxGetDevCaps | This function queries a specified
 *   auxiliary output device to determine its capabilities.
 *
 * @parm UINT | uDeviceID | Identifies the auxiliary output device to be
 *   queried. Specify a valid device ID (see the following comments
 *   section), or use the following constant:
 *   @flag AUX_MAPPER | Auxiliary audio mapper. The function will
 *     return an error if no auxiliary audio mapper is installed.
 *
 * @parm LPAUXCAPS | lpCaps | Specifies a far pointer to an AUXCAPS
 *   structure.  This structure is filled with information about the
 *   capabilities of the device.
 *
 * @parm UINT | wSize | Specifies the size of the AUXCAPS structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_NODRIVER | The driver failed to install.
 *
 * @comm The device ID specified by <p uDeviceID> varies from zero
 *   to one less than the number of devices present. AUX_MAPPER may
 *   also be used. Use <f auxGetNumDevs> to determine the number of
 *   auxiliary devices present in the system.
 *
 * @xref auxGetNumDevs
 ****************************************************************************/
 //
 // ISSUE-2001/01/08-FrankYe Silly casts to UINT in these functions,
 //    should validate first
 //
    
MMRESULT APIENTRY auxGetDevCapsW(UINT_PTR uDeviceID, LPAUXCAPSW lpCaps, UINT wSize)
{
    DWORD_PTR       dwParam1, dwParam2;
    MDEVICECAPSEX   mdCaps;
    PCWSTR          DevInterface;
    MMRESULT        mmr;

    if (!wSize)
            return MMSYSERR_NOERROR;
    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();

    DevInterface = auxReferenceDevInterfaceById((UINT)uDeviceID);
    dwParam2 = (DWORD_PTR)DevInterface;

    if (0 == dwParam2)
    {
        dwParam1 = (DWORD_PTR)lpCaps;
        dwParam2 = (DWORD)wSize;
    }
    else
    {
        mdCaps.cbSize = (DWORD)wSize;
        mdCaps.pCaps  = lpCaps;
        dwParam1      = (DWORD_PTR)&mdCaps;
    }

    mmr = (MMRESULT)auxOutMessage((UINT)uDeviceID, AUXDM_GETDEVCAPS, dwParam1, dwParam2);
    if (DevInterface) wdmDevInterfaceDec(DevInterface);
    return mmr;
}

MMRESULT APIENTRY auxGetDevCapsA(UINT_PTR uDeviceID, LPAUXCAPSA lpCaps, UINT wSize)
{
    AUXCAPS2W       wDevCaps2;
    AUXCAPS2A       aDevCaps2;
    DWORD_PTR       dwParam1, dwParam2;
    MDEVICECAPSEX   mdCaps;
    PCWSTR          DevInterface;
    MMRESULT        mmRes;

    if (!wSize)
            return MMSYSERR_NOERROR;
    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();

    DevInterface = auxReferenceDevInterfaceById((UINT)uDeviceID);
    dwParam2 = (DWORD_PTR)DevInterface;

    memset(&wDevCaps2, 0, sizeof(wDevCaps2));

    if (0 == dwParam2)
    {
        dwParam1 = (DWORD_PTR)&wDevCaps2;
        dwParam2 = (DWORD)sizeof(wDevCaps2);
    }
    else
    {
        mdCaps.cbSize = (DWORD)sizeof(wDevCaps2);
        mdCaps.pCaps  = &wDevCaps2;
        dwParam1      = (DWORD_PTR)&mdCaps;
    }

    mmRes = (MMRESULT)auxOutMessage( (UINT)uDeviceID, AUXDM_GETDEVCAPS,
                                    dwParam1,
                                    dwParam2);

    if (DevInterface) wdmDevInterfaceDec(DevInterface);
    
    //
    // Don't copy data back if bad return code
    //

    if (mmRes != MMSYSERR_NOERROR) {
        return mmRes;
    }

    aDevCaps2.wMid             = wDevCaps2.wMid;
    aDevCaps2.wPid             = wDevCaps2.wPid;
    aDevCaps2.vDriverVersion   = wDevCaps2.vDriverVersion;
    aDevCaps2.wTechnology      = wDevCaps2.wTechnology;
    aDevCaps2.dwSupport        = wDevCaps2.dwSupport;
    aDevCaps2.ManufacturerGuid = wDevCaps2.ManufacturerGuid;
    aDevCaps2.ProductGuid      = wDevCaps2.ProductGuid;
    aDevCaps2.NameGuid         = wDevCaps2.NameGuid;

    // copy and convert lpwText to lpText here.
    Iwcstombs( aDevCaps2.szPname, wDevCaps2.szPname, MAXPNAMELEN);
    CopyMemory((PVOID)lpCaps, (PVOID)&aDevCaps2, min(sizeof(aDevCaps2), wSize));

    return mmRes;
}

/*****************************************************************************
 * @doc EXTERNAL AUX
 *
 * @api MMRESULT | auxGetVolume | This function returns the current volume
 *   setting of an auxiliary output device.
 *
 * @parm UINT | uDeviceID | Identifies the auxiliary output device to be
 *   queried.
 *
 * @parm LPDWORD | lpdwVolume | Specifies a far pointer to a location
 *   to be filled with the current volume setting.  The low-order word of
 *   this location contains the left channel volume setting, and the high-order
 *   word contains the right channel setting. A value of 0xFFFF represents
 *   full volume, and a value of 0x0000 is silence.
 *
 *   If a device does not support both left and right volume
 *   control, the low-order word of the specified location contains
 *   the volume level.
 *
 *   The full 16-bit setting(s)
 *   set with <f auxSetVolume> are returned, regardless of whether
 *   the device supports the full 16 bits of volume level control.
 *
 * @comm  Not all devices support volume control.
 *   To determine whether the device supports volume control, use the
 *   AUXCAPS_VOLUME flag to test the <e AUXCAPS.dwSupport> field of the
 *   <t AUXCAPS> structure (filled by <f auxGetDevCaps>).
 *
 *   To determine whether the device supports volume control on both the
 *   left and right channels, use the AUXCAPS_LRVOLUME flag to test the
 *   <e AUXCAPS.dwSupport> field of the <t AUXCAPS> structure (filled
 *   by <f auxGetDevCaps>).
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_NODRIVER | The driver failed to install.
 *
 * @xref auxSetVolume
 ****************************************************************************/
MMRESULT APIENTRY auxGetVolume(UINT uDeviceID, LPDWORD lpdwVolume)
{
    PCWSTR   DevInterface;
    MMRESULT mmr;

    V_WPOINTER(lpdwVolume, sizeof(DWORD), MMSYSERR_INVALPARAM);
    
    ClientUpdatePnpInfo();

    DevInterface = auxReferenceDevInterfaceById(uDeviceID);
    mmr = (MMRESULT)auxOutMessage(uDeviceID, AUXDM_GETVOLUME, (DWORD_PTR)lpdwVolume, (DWORD_PTR)DevInterface);
    if (DevInterface) wdmDevInterfaceDec(DevInterface);
    return mmr;
}

/*****************************************************************************
 * @doc EXTERNAL AUX
 *
 * @api MMRESULT | auxSetVolume | This function sets the volume in an
 *   auxiliary output device.
 *
 * @parm UINT | uDeviceID |  Identifies the auxiliary output device to be
 *   queried.  Device IDs are determined implicitly from the number of
 *   devices present in the system.  Device ID values range from zero
 *   to one less than the number of devices present.  Use <f auxGetNumDevs>
 *   to determine the number of auxiliary devices in the system.
 *
 * @parm DWORD | dwVolume | Specifies the new volume setting.  The
 *   low-order UINT specifies the left channel volume setting, and the
 *   high-order word specifies the right channel setting.
 *   A value of 0xFFFF represents full volume, and a value of 0x0000
 *   is silence.
 *
 *   If a device does not support both left and right volume
 *   control, the low-order word of <p dwVolume> specifies the volume
 *   level, and the high-order word is ignored.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_NODRIVER | The driver failed to install.
 *
 * @comm Not all devices support volume control.
 *   To determine whether the device supports volume control, use the
 *   AUXCAPS_VOLUME flag to test the <e AUXCAPS.dwSupport> field of the
 *   <t AUXCAPS> structure (filled by <f auxGetDevCaps>).
 *
 *   To determine whether the device supports volume control on both the
 *   left and right channels, use the AUXCAPS_LRVOLUME flag to test the
 *   <e AUXCAPS.dwSupport> field of the <t AUXCAPS> structure (filled
 *   by <f auxGetDevCaps>).
 *
 *   Most devices do not support the full 16 bits of volume level control
 *   and will use only the high-order bits of the requested volume setting.
 *   For example, for a device that supports 4 bits of volume control,
 *   requested volume level values of 0x4000, 0x4fff, and 0x43be will
 *   all produce the same physical volume setting, 0x4000. The
 *   <f auxGetVolume> function will return the full 16-bit setting set
 *   with <f auxSetVolume>.
 *
 *   Volume settings are interpreted logarithmically. This means the
 *   perceived volume increase is the same when increasing the
 *   volume level from 0x5000 to 0x6000 as it is from 0x4000 to 0x5000.
 *
 * @xref auxGetVolume
 ****************************************************************************/
MMRESULT APIENTRY auxSetVolume(UINT uDeviceID, DWORD dwVolume)
{
    PCWSTR   DevInterface;
    MMRESULT mmr;

    ClientUpdatePnpInfo();

    DevInterface = auxReferenceDevInterfaceById(uDeviceID);
    mmr = (MMRESULT)auxOutMessage(uDeviceID, AUXDM_SETVOLUME, dwVolume, (DWORD_PTR)DevInterface);
    if (DevInterface) wdmDevInterfaceDec(DevInterface);
    return mmr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\drvrrare.c ===
/******************************************************************************

   Copyright (c) 1985-1998 Microsoft Corporation

   Title:   drvrrare.c - Installable driver code. Less common code

   Version: 1.00

   Date:    10-Jun-1990

   Author:  DAVIDDS ROBWI

------------------------------------------------------------------------------

   Change log:

      DATE        REV            DESCRIPTION
   -----------   -----   -----------------------------------------------------------
   28-FEB-1992   ROBINSP Port to NT
   23-Apr-1992   StephenE   Unicoded
   22-Apr-1993   RobinSp Add NT multithread protection

Multithread design :

   Uses 2 critical sections :

   DriverListCritSec :

      protects the list of drivers :

          hInstalledDriverList  - handle of global driver list
          cInstalledDrivers	- high water mark of installed drivers

      so that only 1 thread at a time has the list locked and can refer
      to or update it.

   DriverLoadFreeCritSec

      Makes sure that actual loads and frees of drivers don't overlap
      and that the actual loading of a driver via LoadLibrary coincides
      with its first message being DRV_LOAD.

      This can easily happen if the DRV_OPEN from another thread can get
      in before the DRV_LOAD has been sent.


*****************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define MMNOSOUND
#define MMNOWAVE
#define MMNOMIDI
#define MMNOSEQ
#define MMNOTIMER
#define MMNOJOY
#define MMNOMCI
#define NOTIMERDEV
#define NOJOYDEV
#define NOMCIDEV
#define NOSEQDEV
#define NOWAVEDEV
#define NOMIDIDEV
#define NOTASKDEV
#include <winmmi.h>
#include "drvr.h"

extern HANDLE  hInstalledDriverList;  // List of installed driver instances
extern int     cInstalledDrivers;     // High water count of installed driver instances

extern DWORD FAR PASCAL DriverProc(DWORD dwID, HDRVR hdrv, UINT msg, DWORD dw1, DWORD dw2);

/* Support for using 3.1 APIs if available */

typedef HANDLE (FAR PASCAL *OPENDRIVER31)(LPCSTR, LPCSTR, LPARAM);
typedef LONG   (FAR PASCAL *CLOSEDRIVER31)(HANDLE, LPARAM, LPARAM);
typedef HANDLE (FAR PASCAL *GETDRIVERMODULEHANDLE31)(HANDLE);
typedef LONG   (FAR PASCAL *SENDDRIVERMESSAGE31)(HANDLE, UINT, LPARAM, LPARAM);
typedef LONG   (FAR PASCAL *DEFDRIVERPROC31)(DWORD, HANDLE, UINT, LPARAM, LPARAM);

OPENDRIVER31            lpOpenDriver;
CLOSEDRIVER31           lpCloseDriver;
GETDRIVERMODULEHANDLE31 lpGetDriverModuleHandle;
SENDDRIVERMESSAGE31     lpSendDriverMessage;
DEFDRIVERPROC31         lpDefDriverProc;
#if 0
BOOL                    fUseWinAPI = 0;
                    // NOTE:  fUseWinAPI is not being used at present
                    // as we only have a partial device loading story
#endif

/***************************************************************************

   strings

****************************************************************************/

#if 0
extern char far szBoot[];
extern char far szUser[];
extern char far szOpenDriver[];
extern char far szCloseDriver[];
extern char far szDrvModuleHandle[];
extern char far szSendDriverMessage[];
extern char far szDefDriverProc[];
extern char far szDriverProc[];
#endif

/***************************************************************************
 *
 * @doc   DDK
 *
 * @api   LONG | DrvClose | This function closes an open driver
 *        instance and decrements
 *        the driver's open count. Once the driver's open count becomes zero,
 *        the driver is unloaded.
 *
 * @parm  HANDLE | hDriver | Specifies the handle of the installable
 *        driver to close.
 *
 * @parm  LPARAM | lParam1 | Specifies the first message parameter for
 *        the DRV_CLOSE message. This data is passed directly to the driver.
 *
 * @parm  LPARAM | lParam2 | Specifies the second message parameter
 *        for DRV_CLOSE message. This data is passed directly to the driver.
 *
 * @rdesc Returns zero if the driver aborted the close;
 *        otherwise, returns the return result from the driver.

 * @xref DrvOpen
 *
 ***************************************************************************/


LRESULT APIENTRY DrvClose(HANDLE hDriver, LPARAM lParam1, LPARAM lParam2)
{
    /*  The driver will receive the following message sequence:
     *
     *      DRV_CLOSE
     *      if DRV_CLOSE returns non-zero
     *          if driver usage count = 1
     *              DRV_DISABLE
     *              DRV_FREE
     */

    if (fUseWinAPI)
       return ((*lpCloseDriver)(hDriver, lParam1, lParam2));
    else
       return InternalCloseDriver((UINT)(UINT_PTR)hDriver, lParam1, lParam2, TRUE);
}

/***************************************************************************
 *
 * @doc   DDK
 *
 * @api   LONG | DrvOpen | This function opens an installable driver.
 *        The first time a driver is opened it is loaded
 *        and enabled. A driver must be opened before messages are sent
 *        to it.
 *
 * @parm  LPSTR | szDriverName | Specifies a far pointer to a
 *        null-terminated character string
 *        containing a driver filename or a keyname from a
 *        section of the SYSTEM.INI file.
 *
 * @parm  LPSTR | szSectionName | Specifies a far pointer to a
 *        null-terminated character string containing the name of
 *        the driver section to search. If <p szSectionName> is
 *        not null, the specified section of the SYSTEM.INI file is
 *        searched instead of the [Drivers] section. If
 *        <p szSectionName> is null, the default [Drivers] section is used.
 *
 * @parm  LPARAM | lParam | Specifies a message parameter to
 *        pass to the driver procedure with the <m DRV_OPEN> message.
 *
 * @rdesc Returns a handle to the driver.
 *
 * @comm Installable drivers must export a <f DriverProc> routine of
 *        the form:
 *
 * @cb   LONG FAR PASCAL | DriverProc | This entry point receives the
 * messages sent to an installable driver. This entry will always
 * handle the system messages as a minimum set of messages.
 *
 * @parm DWORD | dwDriverIdentifier | Specifies the device driver
 *       identifier.
 *
 * @parm HANDLE | hDriver | Specifies the device driver handle.
 *
 * @parm UINT | wMessage | Specifies the message for the device
 *       driver.
 *
 * @parm LONG | lParm1 | Specifies message dependent data.
 *
 * @parm LONG | lParm2 | Specifies message dependent data.
 *
 * @xref DrvClose
 *
****************************************************************************/

HANDLE APIENTRY DrvOpen( LPCWSTR    szDriverName,
                         LPCWSTR    szSectionName,
                         LPARAM     lParam2)
{
    /*  The driver will receive the following message sequence:
     *
     *      if driver not loaded and can be found
     *          DRV_LOAD
     *          if DRV_LOAD returns non-zero
     *              DRV_ENABLE
     *      if driver loaded correctly
     *          DRV_OPEN
     */

    HDRVR hdrv;

    if (fUseWinAPI) {

        /*------------------------------------------------------------*\
         * UNICODE: convert szDriver and szSectionName to ascii
         * and then call WIN31 driver
        \*------------------------------------------------------------*/
        LPSTR   aszDriver;
        LPSTR   aszSectionName;
        INT     lenD;
        INT     lenS;

        lenD = lstrlenW( szDriverName ) * sizeof( WCHAR ) + sizeof( WCHAR );
        aszDriver = HeapAlloc( hHeap, 0, lenD );
        if ( aszDriver == (LPSTR)NULL ) {
            return NULL;
        }

        lenS = lstrlenW( szSectionName ) * sizeof( WCHAR ) + sizeof( WCHAR );
        aszSectionName = HeapAlloc( hHeap, 0, lenS );
        if ( aszSectionName == (LPSTR)NULL ) {
            HeapFree( hHeap, 0, aszDriver );
            return NULL;
        }

        // Unicode to Ascii
        UnicodeStrToAsciiStr( (PBYTE)aszDriver,
                              (PBYTE)aszDriver + lenD,
                              szDriverName );

        UnicodeStrToAsciiStr( (PBYTE)aszSectionName,
                              (PBYTE)aszSectionName + lenS,
                              szSectionName );

        hdrv = (HDRVR)((*lpOpenDriver)( aszDriver, aszSectionName, lParam2 ));

        HeapFree( hHeap, 0, aszDriver );
        HeapFree( hHeap, 0, aszSectionName );

    }
    else {
        dprintf2(("DrvOpen(%ls), Looking in Win.ini [%ls]", szDriverName, szSectionName ? szSectionName : L"NULL !!" ));

        hdrv = (HDRVR)InternalOpenDriver(szDriverName, szSectionName, lParam2, TRUE);
    }

#if DBG
    if (hdrv) {
        WCHAR            ach[255];
        static SZCODE   szFormat[] = "DrvOpen(): Opened %ls (%ls)\r\n";

        GetModuleFileNameW( DrvGetModuleHandle( hdrv ),
                            ach,
                            sizeof(ach) / sizeof(WCHAR)
                          );
        dprintf2((szFormat, szDriverName, ach));
    }
#endif

    return (HANDLE)hdrv;
}

/***************************************************************************
 *
 * @doc   DDK
 *
 * @api   HANDLE | DrvGetModuleHandle | This function returns the library
 *        module handle of the specified installable driver.
 *
 * @parm  HANDLE | hDriver | Specifies the handle of the installable driver.
 *
 * @rdesc Returns the module handle of the driver specified by the
 *        driver handle <p hDriver>.
 *
 * @comm  A module handle is not the same as an installable driver handle.
 *
 ***************************************************************************/

HMODULE APIENTRY DrvGetModuleHandle(HDRVR hDriver)
{
    LPDRIVERTABLE lpdt;
    HMODULE       h = 0;

    if (fUseWinAPI)
        return ((*lpGetDriverModuleHandle)(hDriver));

    DrvEnter();
    if (hDriver && ((int)(UINT_PTR)hDriver <= cInstalledDrivers))
    {
        lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);
        h = (HMODULE)lpdt[(UINT)(UINT_PTR)hDriver-1].hModule;
        GlobalUnlock(hInstalledDriverList);
    }
    DrvLeave();

    return(h);
}


LRESULT FAR PASCAL InternalCloseDriver(UINT   hDriver,
                                    LPARAM lParam1,
                                    LPARAM lParam2,
                                    BOOL   fSendDisable)
{
    LRESULT       result;

    // check handle in valid range.

    DrvEnter();

    if ((int)hDriver > cInstalledDrivers) {
        DrvLeave();
        return(FALSE);
    }

    DrvLeave();

    result = DrvSendMessage((HANDLE)(UINT_PTR)hDriver, DRV_CLOSE, lParam1, lParam2);

    if (result) {
        InternalFreeDriver(hDriver, fSendDisable);
    }

    return(result);
}


LRESULT FAR PASCAL InternalOpenDriver( LPCWSTR szDriverName,
                                    LPCWSTR szSectionName,
                                    LPARAM  lParam2,
                                    BOOL    fSendEnable)
{
    DWORD_PTR     hDriver;
    LPDRIVERTABLE lpdt;
    LRESULT       result;
    WCHAR         sz[128];

    if (0 != (hDriver = InternalLoadDriver( szDriverName,
                                            szSectionName,
                                            sz,
                                            sizeof(sz) / sizeof(WCHAR),
                                            fSendEnable ) ) )
    {
        /*
         * Set the driver identifier to the DRV_OPEN call to the
         * driver handle. This will let people build helper functions
         * that the driver can call with a unique identifier if they
         * want to.
         */

        DrvEnter();
        lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);
        lpdt[hDriver-1].dwDriverIdentifier = (DWORD)hDriver;
        GlobalUnlock(hInstalledDriverList);
        DrvLeave();

        result = DrvSendMessage( (HANDLE)hDriver, DRV_OPEN, (LPARAM)(LPSTR)sz,
                                 lParam2);
        if (!result) {
            dprintf1(("DrvSendMessage failed, result = %8x",result));
            InternalFreeDriver((UINT)hDriver, fSendEnable);
        } else {
            DrvEnter();
            lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);
            lpdt[hDriver-1].dwDriverIdentifier = result;
            GlobalUnlock(hInstalledDriverList);
            DrvLeave();
            result = hDriver;
        }
    }
    else
        result = 0L;

    return result;
}

/***************************************************************************
 *
 * @doc   INTERNAL
 *
 * @api   LONG | InternalLoadDriver | Loads an installable driver. If this is
 *        the first time that the driver is opened, the driver will be loaded
 *        and enabled.
 *
 * @parm  LPSTR | szDriverName | A null-terminated character string
 *        containing a driver filename or a keyname from the [Drivers]
 *        section of system.ini.
 *
 * @parm  LPSTR | szSectionName | A null-terminated character string
 *        that specifies a driver section to search. If szSectionName is
 *        not null, the specified section of system.ini is searched instead
 *        of the [Drivers] section. If szSectionName is null, the
 *        default [Drivers] section is used.
 *
 * @parm  LPSTR | lpstrTail | caller supplied buffer to return the "tail"
 *        of the system.ini line in. The tail is any characters that follow
 *        the filename.
 *
 * @parm  UINT | cbTail | size of supplied buffer as a character count.
 *
 * @parm  BOOL | fSendEnable | TRUE if driver should be enabled
 *
 * @rdesc Returns a long whose loword is the handle to the driver and whose
 *        high word is an error code or the module handle
 *
 * @xref  InternalOpenDriver
 *
 ****************************************************************************/

LRESULT FAR PASCAL InternalLoadDriver(LPCWSTR  szDriverName,
                                   LPCWSTR  szSectionName,
                                   LPWSTR   lpstrTail,
                                   UINT     cbTail,
                                   BOOL     fSendEnable)
{
    int           index;
    LPDRIVERTABLE lpdt;
    LONG          result;
    HANDLE        h;
    DRIVERPROC    lpDriverEntryPoint;


    /*  The driver will receive the following message sequence:
     *
     *      if driver not loaded and can be found
     *          DRV_LOAD
     *          if DRV_LOAD returns non-zero and fSendEnable
     *              DRV_ENABLE
     */

    /* Allocate a table entry */

    // This can be made more efficient by keeping a count of how many drivers
    // we have loaded and how many entries there are in the table.  Then when
    // we should reuse an entry we would not reallocate - unlike at present.

    DrvEnter();
    if (!hInstalledDriverList) {
        h = GlobalAlloc(GHND, (DWORD)((UINT)sizeof(DRIVERTABLE)));
        // Note: it is valid to assume that the memory has been ZERO'ed
        // ...might want to add a debug WinAssert to verify...
    } else {

        /* Alloc space for the next driver we will install. We may not really
         * install the driver in the last entry but rather in an intermediate
         * entry which was freed.
         */

        h = GlobalReAlloc(hInstalledDriverList,
            (DWORD)((UINT)sizeof(DRIVERTABLE)*(cInstalledDrivers+1)),
            GHND);
        // Note: it is valid to assume that the new memory has been ZERO'ed
        // ...might want to add a debug WinAssert to verify...

    }

    if (!h) {
        dprintf1(("Failed to allocate space for Installed driver list"));
        DrvLeave();
        return(0L);
    }

    cInstalledDrivers++;
    hInstalledDriverList = h;
    lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);

    /* find an unused entry in the table */

    for (index=0;index<cInstalledDrivers;index++)
    {
        if (lpdt[index].hModule == 0 && !lpdt[index].fBusy)
            break;
    }

    if (index+1 < cInstalledDrivers) {

        /* The driver went into an unused entry in the middle somewhere so
         * restore table size.
         */

        cInstalledDrivers--;
    }

    /* Protect the entry we just allocated so that OpenDriver
     * can be called at any point from now on without overriding
     * the entry
     */

    lpdt[index].fBusy = 1;

    GlobalUnlock(hInstalledDriverList);
    DrvLeave();

   /*
    *  Make sure Loadlibrary and DRV_LOAD messages to driver are consistent
    */

    EnterCriticalSection(&DriverLoadFreeCritSec);

    h = LoadAliasedLibrary( szDriverName,
                            szSectionName ? szSectionName : wszDrivers,
                            wszSystemIni,
                            lpstrTail,
                            cbTail );
    if (0 == h)
    {
        dprintf1(("Failed to LoadLibrary %ls  Error is %d", szDriverName, GetLastError()));
        LeaveCriticalSection(&DriverLoadFreeCritSec);
        result = 0;
        goto LoadCleanUp;
    }


    lpDriverEntryPoint =
        (DRIVERPROC)GetProcAddress(h, DRIVER_PROC_NAME);

    if (lpDriverEntryPoint == NULL)
    {
        // Driver does not have correct entry point
        dprintf1(("Cannot find entry point %ls in %ls", DRIVER_PROC_NAME, szDriverName));

        FreeLibrary(h);
        LeaveCriticalSection(&DriverLoadFreeCritSec);
        result = 0L;
        goto LoadCleanUp;
    }

    DrvEnter();
    lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);

    lpdt[index].lpDriverEntryPoint = lpDriverEntryPoint;

    // Set hModule here so that GetDrvrUsage() and DrvSendMessage() work

    lpdt[index].hModule = (UINT_PTR)h;

    GlobalUnlock(hInstalledDriverList);
    DrvLeave();

    if (GetDrvrUsage(h) == 1)
    {
        LRESULT LoadResult;

        // First instance of the driver.

        LoadResult = DrvSendMessage((HANDLE)(UINT_PTR)(index+1), DRV_LOAD, 0L, 0L);

        DrvEnter();
        lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);

        if (!LoadResult)
        {
            // Driver failed load call.

            lpdt[index].lpDriverEntryPoint = NULL;
            lpdt[index].hModule = (UINT_PTR)NULL;
            GlobalUnlock(hInstalledDriverList);
            DrvLeave();
            FreeLibrary(h);
            LeaveCriticalSection(&DriverLoadFreeCritSec);
            result = 0L;
            goto LoadCleanUp;
        }
        lpdt[index].fFirstEntry = 1;
        GlobalUnlock(hInstalledDriverList);
        DrvLeave();

        if (fSendEnable) {
            DrvSendMessage((HANDLE)(UINT_PTR)(index+1), DRV_ENABLE, 0L, 0L);
        }
    }

    LeaveCriticalSection(&DriverLoadFreeCritSec);


    result = index + 1;

LoadCleanUp:
    DrvEnter();
    lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);
    lpdt[index].fBusy = 0;
    GlobalUnlock(hInstalledDriverList);
    DrvLeave();
    return(result);
}


/***************************************************************************
 *
 * @doc   INTERNAL
 *
 * @api   UINT | InternalFreeDriver | This function decrements the usage
 *        count of the specified driver. When the driver usage count reaches
 *        0, the driver is sent a DRV_FREE message and then freed.
 *
 * @parm  HANDLE | hDriver | Driver handle of the installable driver to be
 *        freed.
 *
 * @parm  BOOL | fSendDisable | TRUE if a DRV_DISABLE message should be sent
 *        before the DRV_FREE message if the usage count reaches zero.
 *
 * @rdesc Returns current driver usage count.
 *
 * @comm  Using LoadLibrary or FreeLibrary directly on a library installed
 *        with OpenDriver will break this function. A module handle is not
 *        the same as an installable driver handle.
 *
 * @xref  CloseDriver
 *
 ***************************************************************************/

UINT FAR PASCAL InternalFreeDriver(UINT hDriver, BOOL fSendDisable)
{
    LPDRIVERTABLE lpdt;
    UINT          w;
    int           index;
    HMODULE       hModule;

    /*  The driver will receive the following message sequence:
     *
     *      if usage count of driver is 1
     *          DRV_DISABLE (normally)
     *          DRV_FREE
     */

    EnterCriticalSection(&DriverLoadFreeCritSec);

    DrvEnter();
    if ((int)hDriver > cInstalledDrivers || !hDriver) {
        DrvLeave();
	LeaveCriticalSection(&DriverLoadFreeCritSec);
        return(0);
    }

    lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);

    /*
     * If the driver usage count is 1, then send
     * free and disable messages.
     */

    /*
       Clear dwDriverIdentifier so that the sendmessage for
       DRV_OPEN and DRV_ENABLE have dwDriverIdentifier = 0
       if an entry gets reused and so that the DRV_DISABLE and DRV_FREE
       messages below also get dwDriverIdentifier = 0.
    */

    lpdt[hDriver-1].dwDriverIdentifier = 0;
                            
    hModule = (HMODULE)lpdt[hDriver-1].hModule;


    GlobalUnlock(hInstalledDriverList);
    DrvLeave();

    w = GetDrvrUsage((HANDLE)hModule);

    if (w == 1)
        {
        if (fSendDisable)
            DrvSendMessage((HANDLE)(UINT_PTR)hDriver, DRV_DISABLE, 0L, 0L);
        DrvSendMessage((HANDLE)(UINT_PTR)hDriver, DRV_FREE, 0L, 0L);
        }
    FreeLibrary(hModule);

    DrvEnter();
    lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);

    /* Only one entry for the driver in the driver list has the first
     * instance flag set. This is to make it easier to handle system
     * messages that only need to be sent to a driver once.
     *
     * To maintain the flag, we must set the flag in one of the other
     * entries if we remove the driver entry with the flag set.
     *
     * Note that InternalFreeDriver returns the new usage count of
     * the driver so if it is zero, we know that there are no other
     * entries for the driver in the list and so we don't have to
     * do this loop.
     */

    if (lpdt[hDriver - 1].fFirstEntry) {
        for (index=0;index<cInstalledDrivers;index++)
            if (lpdt[index].hModule == lpdt[hDriver-1].hModule && !lpdt[index].fFirstEntry)
                {
                lpdt[index].fFirstEntry = 1;
                break;
                }
    }

    // Clear the rest of the table entry

    lpdt[hDriver-1].hModule = 0;        // this indicates free entry
    lpdt[hDriver-1].fFirstEntry = 0;    // this is also just to be tidy
    lpdt[hDriver-1].lpDriverEntryPoint = 0; // this is also just to be tidy

    GlobalUnlock(hInstalledDriverList);
    DrvLeave();

    LeaveCriticalSection(&DriverLoadFreeCritSec);

    return(w-1);
}

#if 0

UINT GetWinVer()
{
    WORD w = GetVersion();

    return (w>>8) | (w<<8);
}

#endif

#if 0
void NEAR PASCAL DrvInit(void)
{
HANDLE  hlibUser;
LPDRIVERTABLE lpdt;

    /* If the window's driver interface is present then use it.
     */

    DOUT(("DrvInit\r\n"));

    hlibUser = GetModuleHandle(szUser);

    if(lpOpenDriver = (OPENDRIVER31)GetProcAddress(hlibUser,szOpenDriver))
        fUseWinAPI = TRUE;
    else
        {
        fUseWinAPI = FALSE;
        DOUT((" - No Windows Driver I/F detected. Using MMSYSTEM\r\n"));

        //
        // force MMSYSTEM into the driver table, without enabling it.
        //
        DrvEnter();
        cInstalledDrivers = 0;
        hInstalledDriverList = GlobalAlloc(GHND|GMEM_SHARE, (DWORD)((UINT)sizeof(DRIVERTABLE)));

#if DBG
        if (hInstalledDriverList == NULL)
            {
            DOUT(("no memory for driver table\r\n"));
            // FatalExit(-1);
            return;
            }
#endif
        lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);

        //
        //  NOTE! we are not setting fFirstEntry==TRUE
        //
        //  because under windows 3.0 MMSOUND will enable/disable us
        //  we *dont* wan't the driver interface doing it!
        //
        lpdt->lpDriverEntryPoint = (DRIVERPROC)DriverProc;
        lpdt->hModule = ghInst;
        lpdt->fFirstEntry = 0;

        GlobalUnlock(hInstalledDriverList);
        DrvLeave();
        }

    if (fUseWinAPI)
        {
        DOUT((" - Windows Driver I/F detected\r\n"));

        if (GetWinVer() < 0x30A)
            DOUT(("MMSYSTEM: WARNING !!! WINDOWS DRIVER I/F BUT VERSION LESS THAN 3.1\r\n"));

        // link to the relevant user APIs.

        lpCloseDriver = (CLOSEDRIVER31)GetProcAddress(hlibUser, szCloseDriver);
        lpGetDriverModuleHandle = (GETDRIVERMODULEHANDLE31)GetProcAddress(hlibUser, szDrvModuleHandle);
        lpSendDriverMessage = (SENDDRIVERMESSAGE31)GetProcAddress(hlibUser, szSendDriverMessage);
        lpDefDriverProc = (DEFDRIVERPROC31)GetProcAddress(hlibUser, szDefDriverProc);
        }
}
#endif

#if 0
/***************************************************************************
 *
 * @doc   INTERNAL
 *
 * @api   void | InternalInstallDriverChain | This function loads the
 *        drivers specified on the Drivers= line of the [Boot] section
 *        of system.ini. The Drivers are loaded but not opened.
 *
 * @rdesc None
 *
 ***************************************************************************/

void FAR PASCAL InternalInstallDriverChain(void)
{
    char    szBuffer[150];
    BOOL    bFinished;
    int     iStart;
    int     iEnd;

    if (!fUseWinAPI)
        {
        /* Load DLL's from DRIVERS section in system.ini
        */

        szBuffer[0] = TEXT('\0');

        winmmGetPrivateProfileString(szBoot,      /* [Boot] section */
                                     szDrivers,   /* Drivers= */
                                     szNull,      /* Default if no match */
                                     szBuffer,    /* Return buffer */
                                     sizeof(szBuffer),
                                     szSystemIni);

        if (!*szBuffer) {
            return;
        }

        bFinished = FALSE;
        iStart    = 0;
        while (!bFinished)
            {
            iEnd = iStart;
            while (szBuffer[iEnd] && (szBuffer[iEnd] != ' ') &&
                (szBuffer[iEnd] != ','))
            iEnd++;

            if (szBuffer[iEnd] == NULL)
            bFinished = TRUE;
            else
            szBuffer[iEnd] = NULL;

            /* Load and enable the driver.
            */
            InternalLoadDriver(&(szBuffer[iStart]), NULL, NULL, 0, TRUE);

            iStart = iEnd+1;
            }
        }
}
#endif

/***************************************************************************
 *
 * @doc   INTERNAL
 *
 * @api   void | InternalDriverEnable | This function enables all the
 *        currently loaded installable drivers. If the user driver i/f
 *        has been detected, this function will do nothing.
 *
 * @rdesc None
 *
 ***************************************************************************/

void FAR PASCAL InternalDriverEnable(void)
{

    if (!fUseWinAPI)
        InternalBroadcastDriverMessage(1, DRV_ENABLE, 0L, 0L, IBDM_ONEINSTANCEONLY);
}

/***************************************************************************
 *
 * @doc   INTERNAL
 *
 * @api   void | InternalDriverDisable | This function disables all the
 *        currently loaded installable drivers. If the user driver I/F
 *        has been detected, this function will do nothing.
 *
 *
 * @rdesc None
 *
 ***************************************************************************/

void FAR PASCAL InternalDriverDisable(void)
{

    if (!fUseWinAPI)
        InternalBroadcastDriverMessage(0, DRV_DISABLE, 0L, 0L,
            IBDM_ONEINSTANCEONLY | IBDM_REVERSE);
}

/***************************************************************************
 *
 * @doc   INTERNAL
 *
 * @api   BOOL | TestExeFormat | This function tests if the executable
 *        supplied is loadable as a 32-bit executable
 *
 * @parm  LPWSTR | szExe | The file to test
 *
 * @rdesc BOOL | TRUE if format was OK, FALSE otherwise
 *
 ***************************************************************************/

BOOL TestExeFormat(LPWSTR szExe)
{
    HANDLE SectionHandle;
    HANDLE FileHandle;
    PVOID BaseAddress;
    SIZE_T ViewSize;
    WCHAR ExpandedName[MAX_PATH];
    LPWSTR FilePart;

    //
    // See if it's already loaded
    //

    if (GetModuleHandleW(szExe)) {
        return TRUE;
    }

    //
    // Search for our DLL
    //

    if (!SearchPathW(NULL,
                     szExe,
                     NULL,
                     MAX_PATH,
                     ExpandedName,
                     &FilePart)) {
        return FALSE;
    }

    //
    // Get a handle for it
    //

    FileHandle = CreateFileW(ExpandedName,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             0,
                             NULL);

    if (FileHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    //
    // We create and map a section for this file as an IMAGE
    // to make sure it's recognized as such
    //

    if (!NT_SUCCESS(NtCreateSection(
                         &SectionHandle,
                         SECTION_ALL_ACCESS,
                         NULL,
                         NULL,
                         PAGE_READONLY,
                         SEC_IMAGE,
                         FileHandle))) {
         CloseHandle(FileHandle);
         return FALSE;
    }

    //
    // Map it whereever it will go
    //

    ViewSize = 0;
    BaseAddress = NULL;

    //
    // See if the loader is happy with the format
    //

    if (!NT_SUCCESS(NtMapViewOfSection(SectionHandle,
                                       NtCurrentProcess(),
                                       &BaseAddress,
                                       0L,
                                       0L,
                                       NULL,
                                       &ViewSize,
                                       ViewShare,
                                       0L,
                                       PAGE_READONLY))) {
        NtClose(SectionHandle);
        CloseHandle(FileHandle);
        return FALSE;
    }

    NtUnmapViewOfSection(NtCurrentProcess(), BaseAddress);
    NtClose(SectionHandle);
    CloseHandle(FileHandle);

    return TRUE;

}

/***************************************************************************
 *
 * @doc   INTERNAL
 *
 * @api   HANDLE | LoadAliasedLibrary | This function loads the library module
 *        contained in the specified file and returns its module handle
 *        unless the specified  name matches a keyname in the
 *        specified section section of the specified ini file in which case
 *        the library module in the file specified on the ini line is loaded.
 *
 * @parm  LPSTR | szLibFileName | points to a null-terminated character
 *        string containing the filename or system.ini keyname.
 *
 * @parm  LPSTR | szSection | points to a null-terminated character
 *        string containing the section name.
 *
 * @parm  LPSTR | szIniFile | points to a null-terminated character
 *        string containing the ini filename.
 *
 * @parm  LPSTR | lpstrTail | caller supplied buffer to return the "tail"
 *        of the system.ini line in. The tail is any characters that follow
 *        the filename.
 *
 * @parm  UINT | cbTail | size of supplied buffer.
 *
 * @rdesc Returns the library's module handle.
 *
 * @xref  LoadLibrary
 *
 ***************************************************************************/

HANDLE LoadAliasedLibrary( LPCWSTR  szLibFileName,
                           LPCWSTR  szSection,
                           LPWSTR   szIniFile,
                           LPWSTR   lpstrTail,
                           UINT     cbTail)
{
#define SZ_SIZE 128
#define SZ_SIZE_BYTES (SZ_SIZE * sizeof( WCHAR ))

    WCHAR         sz[SZ_SIZE];
    LPWSTR        pch;
    HANDLE        hReturn;
    DWORD         OldErrorMode;
//  OFSTRUCT      of;

    if (!szLibFileName || !*szLibFileName)
        return(NULL); // File not found

    // read the filename and additional info. into sz

    sz[0] = L'\0';
    if (winmmGetPrivateProfileString(szSection,          // ini section
                                 szLibFileName,      // key name
                                 szLibFileName,      // default if no match
                                 sz,                 // return buffer
                                 SZ_SIZE,            // sizeof of return buffer
                                 szIniFile)==0)         // ini. file
	{
		return NULL;
	}

    sz[SZ_SIZE - 1] = 0;

#if 1
    if (0 == lstrcmpiW(sz, L"wdmaud.drv"))
    {
        if (0 != lstrcmpiW(sz, szLibFileName))
        {
//            Squirt("LoadAliasedLibrary: [%ls:%ls]", szLibFileName, sz);
//            Squirt("Should not load [%ls]", szLibFileName);
            return NULL;
        }
    }
#endif

    //
    // strip off the additional info.
    //
    pch = (LPWSTR)sz;

    //
    // at exit from loop pch pts to ch after first space or null ch
    //
    while (*pch) {
        if ( *pch == ' ' ) {
            *pch++ = '\0';
            break;
        }
        pch++;
    }

//
//  These lines are removed for unicode because:
//      there is not a unicode version of OpenFile.
//      LoadLibrary performs the same test as the one below anyway
//
//  if (!GetModuleHandle( sz ) &&
//      OpenFile(sz, &of, OF_EXIST|OF_READ|OF_SHARE_DENY_NONE) == -1) {
//
//      return(NULL);
//  }

    //
    // copy additional info. to lpstrTail
    //
    if (lpstrTail && cbTail) {
        while (cbTail-- && (0 != (*lpstrTail++ = *pch++)))
            ;

        *(lpstrTail-1) = 0;
    }

    //
    // If we're running in the server check if it's a good image.
    // The server bug checks if it tries to load bad images (LoadLibrary
    // inconsistency).
    //
    // To do this we simulate the load process far enough to make
    // the check that it's a valid image
    //

    if (WinmmRunningInServer && !TestExeFormat(sz)) {
        return NULL;
    }

    //
    // Disable hard error popups
    //

    OldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    //
    // Try to load it
    //

    hReturn = LoadLibraryW( sz );

    SetErrorMode(OldErrorMode);

    return hReturn;

#undef SZ_SIZE_BYTES
#undef SZ_SIZE
}



/***************************************************************************
 *
 * @doc   INTERNAL
 *
 * @api   int | GetDrvrUsage | Runs through the driver list and figures
 *        out how many instances of this driver module handle we have.
 *        We use this instead of GetModuleUsage so that we can have drivers
 *        loaded as normal DLLs and as installable drivers.
 *
 * @parm  HANDLE | h | Driver's module handle
 *
 * @rdesc Returns the library's driver usage count.
 *
 ***************************************************************************/

int FAR PASCAL GetDrvrUsage(HANDLE h)
{
    LPDRIVERTABLE lpdt;
    int           index;
    int           count;

    DrvEnter();
    if (!hInstalledDriverList || !cInstalledDrivers) {
        DrvLeave();
        return(0);
    }

    count = 0;
    lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);
    for (index=0;index<cInstalledDrivers;index++)
        {
        if (lpdt->hModule==(UINT_PTR)h)
            {
            count++;
            }
        lpdt++;
        }
    GlobalUnlock(hInstalledDriverList);

    DrvLeave();

    return(count);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\joy.c ===
/******************************************************************************

   Copyright (c) 1985-1999 Microsoft Corporation

   Title:   joy.c - MMSYSTEM Joystick interface code

   Version: 1.01

   Date:    10-Jun-1997

   Author:  GLENNS ROBWI

------------------------------------------------------------------------------

   Change log:

      DATE        REV            DESCRIPTION
  --------   ----- -----------------------------------------------------------
    2/7/90             Changes to avoid a bug in Windows which won't allow
                       FreeLibrary to be called during WEP.

    10/11/90      .61  Use windows timer + general cleanup

    20-Aug-92          Convert to Windows NT

    20-Nov-97          Use DINPUT instead of old driver

    1/10/98            Add debug output for joy* API
*****************************************************************************/

#define INITGUID
#define UNICODE

#include <stdlib.h>
#include <windows.h>
#include <regstr.h>
#include <winioctl.h>
#include "winmmi.h"
#include "joy.h"

/****************************************************************************
    Local data
****************************************************************************/


CRITICAL_SECTION   joyCritSec;          //also used in winmm.c
static LPJOYDEVICE g_pJoyDev[cJoyMax];
static DWORD       g_dwNumOpen = 0;
static UINT        g_wmJoyChanged = 0;
static UINT        g_timerID = 0;
static HANDLE      g_hThreadMonitor = NULL;
static DWORD       g_dwThreadID = 0;
static BOOL        g_fThreadExist = FALSE;
static WCHAR       cwszREGKEYNAME[] = L"DINPUT.DLL";
static CHAR        cszREGKEYNAME[] = "DINPUT.DLL";

static HKEY        hkJoyWinmm;
static TCHAR       g_szJoyWinmm[] = REGSTR_PATH_PRIVATEPROPERTIES TEXT("\\Joystick\\Winmm");
static BOOL        g_fHasWheel = FALSE;
static DWORD       g_dwEnableWheel;
static TCHAR       g_szEnableWheel[] = TEXT("wheel");

#ifdef DBG
    static DWORD       g_dwDbgLevel;
    static TCHAR       g_szDbgLevel[] = TEXT("level");
#endif

LPDIRECTINPUTW         g_pdi;
LPDIRECTINPUTJOYCONFIG g_pdijc;

HINSTANCE g_hinstDinputDll;
FARPROC   g_farprocDirectInputCreateW;
HANDLE    g_hEventWinmm;

/****************************************************************************
   Internal Data Structures
****************************************************************************/
#ifndef HID_USAGE_SIMULATION_RUDDER
    #define HID_USAGE_SIMULATION_RUDDER         ((USAGE) 0xBA)
#endif
#ifndef HID_USAGE_SIMULATION_THROTTLE
    #define HID_USAGE_SIMULATION_THROTTLE       ((USAGE) 0xBB)
#endif
#ifndef HID_USAGE_SIMULATION_ACCELERATOR
    #define HID_USAGE_SIMULATION_ACCELERATOR    ((USAGE) 0xC4)
#endif
#ifndef HID_USAGE_SIMULATION_BRAKE
    #define HID_USAGE_SIMULATION_BRAKE          ((USAGE) 0xC5)
#endif
#ifndef HID_USAGE_SIMULATION_CLUTCH
    #define HID_USAGE_SIMULATION_CLUTCH         ((USAGE) 0xC6)
#endif
#ifndef HID_USAGE_SIMULATION_SHIFTER
    #define HID_USAGE_SIMULATION_SHIFTER        ((USAGE) 0xC7)
#endif
#ifndef HID_USAGE_SIMULATION_STEERING
    #define HID_USAGE_SIMULATION_STEERING       ((USAGE) 0xC8)
#endif
#ifndef HID_USAGE_GAME_POV
    #define HID_USAGE_GAME_POV                  ((USAGE) 0x20)
#endif
#ifndef DIDFT_OPTIONAL
    #define DIDFT_OPTIONAL 0x80000000
#endif

#define MAX_BTNS 32
#define MAX_CTRLS 46 //14 below + buttons
#define MAX_FINAL 7+MAX_BTNS  //6 axes + POV + buttons
typedef enum eCtrls {
    eGEN_X=0,
    eGEN_Y,
    eGEN_Z,     
    eGEN_RX,
    eGEN_RY,  
    eGEN_RZ,
    eSIM_THROTTLE,
    eSIM_STEERING,
    eSIM_ACCELERATOR,
    eGEN_SLIDER,
    eGEN_DIAL,
    eSIM_RUDDER,
    eSIM_BRAKE,
    eGEN_POV,
    eBTN } eCtrls;

typedef struct WINMMJOYSTATE { 
    DWORD    lX; 
    DWORD    lY; 
    DWORD    lZ; 
    DWORD    lR; 
    DWORD    lU; 
    DWORD    lV; 
    DWORD   dwPOV;
    BYTE    rgbButtons[32];
} WINMMJOYSTATE, *LPWINMMJOYSTATE; 

#define MAKEVAL(f)                                   \
    { 0,                                             \
      FIELD_OFFSET(WINMMJOYSTATE, f),                \
      DIDFT_OPTIONAL,                                \
      0,                                             \
    }                                                                   \

#define MAKEBTN(n)                                                      \
    { 0,                                                                \
      FIELD_OFFSET(WINMMJOYSTATE, rgbButtons[n]),                          \
      DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL,                \
      0,                                              \
    }                                                                   \

//Note that only the offset fields are used now
static DIOBJECTDATAFORMAT c_rgodfWinMMJoy[] = {
    MAKEVAL(lX),
    MAKEVAL(lY),
    MAKEVAL(lZ),
    MAKEVAL(lR),
    MAKEVAL(lU),
    MAKEVAL(lV),
    MAKEVAL(dwPOV),
    MAKEBTN(0),
    MAKEBTN(1),
    MAKEBTN(2),
    MAKEBTN(3),
    MAKEBTN(4),
    MAKEBTN(5),
    MAKEBTN(6),
    MAKEBTN(7),
    MAKEBTN(8),
    MAKEBTN(9),
    MAKEBTN(10),
    MAKEBTN(11),
    MAKEBTN(12),
    MAKEBTN(13),
    MAKEBTN(14),
    MAKEBTN(15),
    MAKEBTN(16),
    MAKEBTN(17),
    MAKEBTN(18),
    MAKEBTN(19),
    MAKEBTN(20),
    MAKEBTN(21),
    MAKEBTN(22),
    MAKEBTN(23),
    MAKEBTN(24),
    MAKEBTN(25),
    MAKEBTN(26),
    MAKEBTN(27),
    MAKEBTN(28),
    MAKEBTN(29),
    MAKEBTN(30),
    MAKEBTN(31),
};

static GUID rgoWinMMGUIDs[MAX_CTRLS];

DIDATAFORMAT c_dfWINMMJoystick = {
    sizeof(DIDATAFORMAT),
    sizeof(DIOBJECTDATAFORMAT),
    DIDF_ABSAXIS,
    sizeof(WINMMJOYSTATE),
    sizeof(c_rgodfWinMMJoy)/sizeof(DIOBJECTDATAFORMAT),
    c_rgodfWinMMJoy,
};

#define RESET_VAL(index)   c_rgodfWinMMJoy[index].pguid = 0; \
                           c_rgodfWinMMJoy[index].dwType = DIDFT_OPTIONAL; \
                           c_rgodfWinMMJoy[index].dwFlags = 0; \

#define RESET_BTN(index)   c_rgodfWinMMJoy[index].pguid = 0; \
                           c_rgodfWinMMJoy[index].dwType = DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL; \
                           c_rgodfWinMMJoy[index].dwFlags = 0; \

#define RESET_RGODFWINMMJOY()  \
    RESET_VAL(0);   \
    RESET_VAL(1);   \
    RESET_VAL(2);   \
    RESET_VAL(3);   \
    RESET_VAL(4);   \
    RESET_VAL(5);   \
    RESET_VAL(6);   \
    RESET_VAL(7);   \
    RESET_BTN(8);   \
    RESET_BTN(9);   \
    RESET_BTN(10);  \
    RESET_BTN(11);  \
    RESET_BTN(12);  \
    RESET_BTN(13);  \
    RESET_BTN(14);  \
    RESET_BTN(15);  \
    RESET_BTN(16);  \
    RESET_BTN(17);  \
    RESET_BTN(18);  \
    RESET_BTN(19);  \
    RESET_BTN(20);  \
    RESET_BTN(21);  \
    RESET_BTN(22);  \
    RESET_BTN(23);  \
    RESET_BTN(24);  \
    RESET_BTN(25);  \
    RESET_BTN(26);  \
    RESET_BTN(27);  \
    RESET_BTN(28);  \
    RESET_BTN(29);  \
    RESET_BTN(30);  \
    RESET_BTN(31);  \
    RESET_BTN(32);  \
    RESET_BTN(33);  \
    RESET_BTN(34);  \
    RESET_BTN(35);  \
    RESET_BTN(36);  \
    RESET_BTN(37);  \
    RESET_BTN(38);  \
    
#ifndef cchLENGTH
#define cchLENGTH(_sz)  (sizeof(_sz)/sizeof(_sz[0]))
#endif

/****************************************************************************
   Internal functions
****************************************************************************/
BOOL CALLBACK DIEnumDeviceObjectsCallback(LPCDIDEVICEOBJECTINSTANCE lpddoi,LPVOID pvRef);
HRESULT WINAPI joyOpen(UINT idJoy, LPJOYCAPSW pjc );
void WINAPI    joyClose( UINT idJoy );
void WINAPI    joyCloseAll( void );
void CALLBACK  joyPollCallback(HWND hWnd, UINT wMsg, UINT_PTR uIDEvent, DWORD dwTime);  //TIMER MESSAGE for Joystick
DWORD WINAPI   joyMonitorThread(LPVOID);
void WINAPI    DllEnterCrit(void);
void WINAPI    DllLeaveCrit(void);
BOOL WINAPI    DllInCrit( void );
void AssignToArray(LPCDIDEVICEOBJECTINSTANCE lpddoi, eCtrls CtrlID, LPDIOBJECTDATAFORMAT pDevs);
void AssignToRGODF(LPDIOBJECTDATAFORMAT pDof, int CtrlID);
void AssignMappings(DIOBJECTDATAFORMAT *dwAll, DWORD *dwCaps, DWORD *dwBtns, DWORD *dwAxes);
BOOL CALLBACK DIEnumDeviceObjectsCallback(LPCDIDEVICEOBJECTINSTANCE lpddoi,LPVOID pvRef);
HRESULT        hresMumbleKeyEx(HKEY hk, LPCTSTR ptszKey, REGSAM sam, DWORD dwOptions, PHKEY phk);

/****************************************************************************

    @doc WINAPI

    @api BOOL | JoyInit | This function initializes the joystick services.

    @rdesc The return value is TRUE if the services are initialised.

****************************************************************************/

BOOL JoyInit(void)
{
    HRESULT hres;
    LONG lRc;

    JOY_DBGPRINT( JOY_BABBLE, ("JoyInit: starting.") );

    memset(&g_pJoyDev, 0, sizeof(g_pJoyDev) );
    g_wmJoyChanged  =   RegisterWindowMessage(MSGSTR_JOYCHANGED);
    g_dwNumOpen     =   0x0;
    g_fHasWheel     =   FALSE;

#ifdef DBG
    g_dwDbgLevel = JOY_DEFAULT_DBGLEVEL;

    hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE,
                           g_szJoyWinmm,
                           KEY_ALL_ACCESS,
                           REG_OPTION_NON_VOLATILE,
                           &hkJoyWinmm);

    if ( SUCCEEDED(hres) )
    {
        DWORD cb = sizeof(g_dwDbgLevel);

        lRc = RegQueryValueEx(hkJoyWinmm, g_szDbgLevel, 0, 0, (LPBYTE)&g_dwDbgLevel, &cb);

        if ( lRc != ERROR_SUCCESS )
        {
            DWORD dwDefault = 0;

            lRc = RegSetValueEx(hkJoyWinmm, g_szDbgLevel, 0, REG_DWORD, (LPBYTE)&dwDefault, cb);
        }

        RegCloseKey(hkJoyWinmm);
    }
#endif

    g_dwEnableWheel = 1;

    hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE,
                           g_szJoyWinmm,
                           KEY_ALL_ACCESS,
                           REG_OPTION_NON_VOLATILE,
                           &hkJoyWinmm);

    if ( SUCCEEDED(hres) )
    {
        DWORD cb = sizeof(g_dwEnableWheel);

        lRc = RegQueryValueEx(hkJoyWinmm, g_szEnableWheel, 0, 0, (LPBYTE)&g_dwEnableWheel, &cb);

        if ( lRc != ERROR_SUCCESS )
        {
            DWORD dwDefault = 1;

            lRc = RegSetValueEx(hkJoyWinmm, g_szEnableWheel, 0, REG_DWORD, (LPBYTE)&dwDefault, cb);
        }

        RegCloseKey(hkJoyWinmm);
    }

    if( !g_hEventWinmm ) {
        g_hEventWinmm = OpenEvent(SYNCHRONIZE, 0, TEXT("DINPUTWINMM"));
        if( !g_hEventWinmm ) {
            g_hEventWinmm = CreateEvent(0, TRUE, 0, TEXT("DINPUTWINMM"));
        }
        if( !g_hEventWinmm ) {
            JOY_DBGPRINT( JOY_ERR, ("JoyInit: create named event fails (0x%08lx).", GetLastError() ) );
        }
    }

    return TRUE;
}


/****************************************************************************

    @doc WINAPI

    @api void | JoyCleanup | This function clean up the joystick services.

****************************************************************************/

void JoyCleanup(void)
{
    joyCloseAll();

    if ( g_hEventWinmm && WAIT_OBJECT_0 != WaitForSingleObject(g_hEventWinmm, 10))  
    {
        //DInput has not been released.
        if( g_pdijc) {
            IDirectInputJoyConfig_Release(g_pdijc);
        }

        if ( g_pdi ) {
            IDirectInput_Release(g_pdi);
        }

        (void*)g_pdijc = (void*)g_pdi = NULL;
    }

    if ( g_hinstDinputDll )
    {
        FreeLibrary(g_hinstDinputDll);
    }

    if( g_hEventWinmm ) {
        CloseHandle( g_hEventWinmm );
        g_hEventWinmm = NULL;
    }

    JOY_DBGPRINT( JOY_BABBLE, ("JoyCleanup: finished.") );
}

/*****************************************************************************
 *
 *  @doc    WINAPI
 *
 *  @func   MMRESULT | joyGetDevCapsW |
 *
 *          Implementation of legacy joyGetDevCapsW for HID devices on NT.
 *
 *  @parm   IN UINT_PTR | idJoy |
 *
 *          ID of Joystick
 *
 *  @parm   OUT LPJOYCAPSW | pjc |
 *
 *          JOYCAPSW structure to be filled by this routine.
 *
 *  @parm   UINT | cbjc |
 *
 *          Size in bytes of the JOYCAPSW structure.
 *
 *  @returns
 *
 *          MMRESULT code
 *
 *****************************************************************************/
MMRESULT WINAPI joyGetDevCapsW( UINT_PTR  idJoy, LPJOYCAPSW pjc, UINT cbjc )
{
    HRESULT       hres;
    MMRESULT      mmRes;

    JOY_DBGPRINT( JOY_BABBLE, ("joyGetDevCapsW: idJoy=%d, pjc=0x%08x, cbjc=%d", idJoy, pjc, cbjc) );

    V_WPOINTER(pjc, sizeof(JOYCAPSW), MMSYSERR_INVALPARAM);

    if( ( sizeof(JOYCAPSW) != cbjc ) &&  ( sizeof(JOYCAPS2W) != cbjc ) && ( FIELD_OFFSET(JOYCAPSW, wRmin) != cbjc ) )
    {
        JOY_DBGPRINT( JOY_ERR, ("joyGetDevCapsW: return %d (bad size)", JOYERR_PARMS) );
        return JOYERR_PARMS;
    }

    mmRes = JOYERR_NOERROR;

    memset(pjc, 0, min(cbjc, sizeof(JOYCAPS2W)) );

    if ( idJoy == (UINT_PTR)(-1) )
    {
        lstrcpyW(pjc->szRegKey,  cwszREGKEYNAME );
    } else if ( idJoy >= cJoyMax )
    {
        JOY_DBGPRINT( JOY_ERR, ("joyGetDevCapsW: return %d (idJoy > 16)", MMSYSERR_NODRIVER) );
        mmRes = MMSYSERR_NODRIVER;
    } else
    {
        DllEnterCrit();

        hres = joyOpen((UINT)idJoy, pjc);

        DllLeaveCrit();

        if ( FAILED(hres) )
        {
            JOY_DBGPRINT( JOY_ERR, ("joyGetDevCapsW: return %d", JOYERR_PARMS) );
            mmRes = JOYERR_PARMS;
        }
    }

    JOY_DBGPRINT( JOY_BABBLE, ("joyGetDevCapsW: return %d", mmRes) );
    return mmRes;
}


int static __inline Iwcstombs(LPSTR lpstr, LPCWSTR lpwstr, int len)
{
    return WideCharToMultiByte(GetACP(), 0, lpwstr, -1, lpstr, len, NULL, NULL);
}

/*****************************************************************************
 *
 *  @doc    WINAPI
 *
 *  @func   MMRESULT | joyGetDevCapsA |
 *
 *          Implementation of legacy joyGetDevCapsA for devices on NT.
 *          We call the Uincode version joyGetDevCapsW and then munge
 *          the structure into ASCII.
 *
 *  @parm   UINT_PTR | idJoy |
 *
 *          ID of Joystick
 *
 *  @parm   LPJOYCAPSA | pjc |
 *
 *          JOYCAPSA structure to be filled by this routine.
 *
 *  @parm   UINT | cbjc |
 *
 *          Size in bytes of the JOYCAPSA structure.
 *
 *  @returns
 *
 *          MMRESULT code
 *
 *****************************************************************************/
MMRESULT WINAPI joyGetDevCapsA( UINT_PTR idJoy, LPJOYCAPSA pjc, UINT cbjc )
{
#define UToA(dst, cchDst, src)  WideCharToMultiByte(CP_ACP, 0, src, -1, dst, cchDst, 0, 0)

    JOYCAPS2W   Caps2W;
    JOYCAPS2A   Caps2A;
    MMRESULT    mmRes;

    JOY_DBGPRINT( JOY_BABBLE, ("joyGetDevCapsA: idJoy=%d, pjc=0x%08x, cbjc=%d", idJoy, pjc, cbjc) );

    V_WPOINTER(pjc, cbjc, MMSYSERR_INVALPARAM);

    mmRes = JOYERR_NOERROR;

    if ( idJoy == (UINT_PTR)(-1) )
    {
        lstrcpyA(pjc->szRegKey,  cszREGKEYNAME );
        goto _done;
    } else if ( idJoy >= cJoyMax )
    {
        JOY_DBGPRINT( JOY_ERR, ("joyGetDevCapsA: return %d (idJoy > 16)", MMSYSERR_NODRIVER) );
        return MMSYSERR_NODRIVER;
    }

    if( ( sizeof(JOYCAPSA) != cbjc ) && ( sizeof(JOYCAPS2A) != cbjc ) && ( FIELD_OFFSET(JOYCAPSA, wRmin) != cbjc ) )
    {
        JOY_DBGPRINT( JOY_ERR, ("joyGetDevCapsA: return JOYERR_PARMS( bad size )") );
        return JOYERR_PARMS;
    }

    memset(pjc, 0, min(cbjc, sizeof(Caps2A)) );
    memset(&Caps2W, 0, sizeof(Caps2W));

    mmRes = joyGetDevCapsW(idJoy, (LPJOYCAPSW)&Caps2W, sizeof(Caps2W));

    if ( mmRes == JOYERR_NOERROR )
    {

        //
        // Copy product name (etc) into ASCII version
        //

        UToA(Caps2A.szPname , sizeof(Caps2A.szPname ), Caps2W.szPname );
        UToA(Caps2A.szRegKey, sizeof(Caps2A.szRegKey), Caps2W.szRegKey);
        UToA(Caps2A.szOEMVxD, sizeof(Caps2A.szOEMVxD), Caps2W.szOEMVxD);

        //
        // Copy the rest of the fields
        //

        Caps2A.wMid             =   Caps2W.wMid;
        Caps2A.wPid             =   Caps2W.wPid;
        Caps2A.wXmin            =   Caps2W.wXmin;
        Caps2A.wXmax            =   Caps2W.wXmax;
        Caps2A.wYmin            =   Caps2W.wYmin;
        Caps2A.wYmax            =   Caps2W.wYmax;
        Caps2A.wZmin            =   Caps2W.wZmin;
        Caps2A.wZmax            =   Caps2W.wZmax;
        Caps2A.wNumButtons      =   Caps2W.wNumButtons;
        Caps2A.wPeriodMin       =   Caps2W.wPeriodMin;
        Caps2A.wPeriodMax       =   Caps2W.wPeriodMax;
        Caps2A.wRmin            =   Caps2W.wRmin;
        Caps2A.wRmax            =   Caps2W.wRmax;
        Caps2A.wUmin            =   Caps2W.wUmin;
        Caps2A.wUmax            =   Caps2W.wUmax;
        Caps2A.wVmin            =   Caps2W.wVmin;
        Caps2A.wVmax            =   Caps2W.wVmax;
        Caps2A.wCaps            =   Caps2W.wCaps;
        Caps2A.wMaxAxes         =   Caps2W.wMaxAxes;
        Caps2A.wNumAxes         =   Caps2W.wNumAxes;
        Caps2A.wMaxButtons      =   Caps2W.wMaxButtons;
        Caps2A.ManufacturerGuid =   Caps2W.ManufacturerGuid;
        Caps2A.ProductGuid      =   Caps2W.ProductGuid;
        Caps2A.NameGuid         =   Caps2W.NameGuid;

        //
        // Pass back as much data as the requestor asked for
        //

        CopyMemory(pjc, &Caps2A, min(cbjc, sizeof(Caps2A)));
    }

_done:
    JOY_DBGPRINT( JOY_BABBLE, ("joyGetDevCapsA: return %d", mmRes) );
    return mmRes;

#undef UToA
}


/****************************************************************************

   @doc EXTERNAL

   @api UINT | joyGetNumDevs | This function returns the number of joystick
   devices supported by the system.

   @rdesc Returns the number of joystick devices supported by the joystick
   driver. If no driver is present, the function returns zero.

   @comm Use <f joyGetPos> to determine whether a given
   joystick is actually attached to the system. The <f joyGetPos> function returns
   a JOYERR_UNPLUGGED error code if the specified joystick is not connected.

   @xref joyGetDevCaps joyGetPos

****************************************************************************/

UINT WINAPI joyGetNumDevs( void )
{
    // simply return the max number of joysticks we can support
    JOY_DBGPRINT( JOY_BABBLE, ("joyGetNumDevs: return %d", cJoyMax) );
    return cJoyMax;
}


/*****************************************************************************
 *
 *  @doc    WINAPI
 *
 *  @func   MMRESULT | joyGetPosEx |
 *
 *          Get Joystick Position Information.
 *          Calls DInput for all the hard work
 *
 *  @parm   UINT | idJoy |
 *
 *          Id of the Joystick.
 *
 *  @parm   LPJOYINFOEX | pji |
 *
 *          Structure to be filled with Joystick Information data
 *
 *****************************************************************************/
MMRESULT WINAPI joyGetPosEx( UINT idJoy, LPJOYINFOEX  pji )
{
    MMRESULT mmRes;
    HRESULT  hres;
    static   DWORD dwLastBrake=0xFFFF, dwLastAccl=0xFFFF;
    static   DWORD dwMaxBrake=0, dwMaxAccl=0;
    static   DWORD dwMaxY=0xFFFF, dwMidY=0x7FFF, dwMinY=0;

    JOY_DBGPRINT( JOY_BABBLE, ("joyGetPosEx: idJoy=%d, pji=0x%08x", idJoy, pji) );

    V_WPOINTER(pji, sizeof(JOYINFOEX), MMSYSERR_INVALPARAM);

    if ( pji->dwSize < sizeof(JOYINFOEX) )
    {
        JOY_DBGPRINT( JOY_ERR, ("joyGetPosEx: return JOYERR_PARMS(pji->dwSize < sizeof(JOYINFOEX))") );
        return JOYERR_PARMS;
    }

    DllEnterCrit();

    mmRes = JOYERR_NOERROR;

    if ( idJoy >= cJoyMax )
    {
        JOY_DBGPRINT( JOY_ERR, ("joyGetPosEx: return %d (idJoy > 16)", JOYERR_PARMS) );
        mmRes = JOYERR_PARMS;
    } else if ( SUCCEEDED( hres = joyOpen(idJoy, NULL ) ) )
    {
        LPJOYDEVICE pJoyDev;
        DWORD       dwFlags;

        pJoyDev = g_pJoyDev[idJoy];

        dwFlags = pJoyDev->dwFlags;

        /* Have any of the Flag fields that we care about changed ? */
        while ( ! fEqualMaskFlFl( JOY_RETURNRAWDATA  | JOY_USEDEADZONE ,
                                  pji->dwFlags,    /* Desired State */
                                  dwFlags )        /* Current State */
              )
        {
            union {
                DIPROPHEADER diph;
                DIPROPDWORD  dipdw;
                DIPROPRANGE  diprg;
                DIPROPCAL    dipcal;
            } u;

            DIPROPDWORD dipdw;

            u.diph.dwSize       =   sizeof(u.dipdw);
            u.diph.dwHeaderSize =   sizeof(u.diph);
            u.diph.dwObj        =   0x0;
            u.diph.dwHow        =   DIPH_DEVICE;


            hres = IDirectInputDevice2_Unacquire( pJoyDev->pdid);
            if ( SUCCEEDED(hres) )
            {

            }

            else
            { // Could not unacquire device
                mmRes = JOYERR_UNPLUGGED;
                dprintf1( (("Unacquire, FAILED hres=%08lX"), hres ));
                break;
            }

            if ( ! fEqualMaskFlFl( JOY_RETURNRAWDATA, pji->dwFlags, dwFlags ) )
            {
                /* Change in Calibration Mode */
                if( pji->dwFlags & JOY_RETURNRAWDATA )
                {
                    /* RAW data */
                    u.dipdw.dwData = DIPROPCALIBRATIONMODE_RAW;
                    SetMaskpFl(JOY_RETURNRAWDATA, &dwFlags );

                } else
                {
                    /* Cooked Data */
                    u.dipdw.dwData      = DIPROPCALIBRATIONMODE_COOKED;
                    ClrMaskpFl(JOY_RETURNRAWDATA, &dwFlags );
                }

                hres = IDirectInputDevice2_SetProperty(pJoyDev->pdid, DIPROP_CALIBRATIONMODE, &u.dipdw.diph);

                if ( SUCCEEDED(hres) )
                {
                    /* Change in Calibration Mode */
                    if ( pji->dwFlags & JOY_RETURNRAWDATA )
                    {
                        u.diph.dwSize   =   sizeof(u.dipcal);
                        u.diph.dwObj    =   DIJOFS_Y;
                        u.diph.dwHow    =   DIPH_BYOFFSET;

                        hres = IDirectInputDevice2_GetProperty( pJoyDev->pdid, DIPROP_CALIBRATION, &u.dipcal.diph );
                        if ( SUCCEEDED(hres) )
                        {
                            dwMaxY = u.dipcal.lMax;
                            dwMidY = u.dipcal.lCenter;
                            dwMinY = u.dipcal.lMin;
                        }
                    } else
                    {
                        u.diph.dwSize   =   sizeof(u.diprg);
                        u.diph.dwObj    =   DIJOFS_Y;
                        u.diph.dwHow    =   DIPH_BYOFFSET;

                        hres = IDirectInputDevice2_GetProperty( pJoyDev->pdid, DIPROP_RANGE, &u.dipcal.diph );
                        if ( SUCCEEDED(hres) )
                        {
                            dwMaxY = u.diprg.lMax;
                            dwMinY = u.diprg.lMin;
                            dwMidY = (dwMaxY + dwMinY) >> 1;
                        }
                    }
                } else
                { // SetProperty( ) FAILED
                    mmRes = JOYERR_UNPLUGGED;
                    dprintf1((("SetProperty(DIPROP_CALIBRATIONMODE), FAILED hres=%08lX"), hres ));
                    break;
                }

            } else if ( ! fEqualMaskFlFl( JOY_USEDEADZONE, pji->dwFlags, dwFlags ) )
            {
                /* Change in DeadZone */
                if ( pji->dwFlags & JOY_USEDEADZONE )
                {
                    /* Default DeadZone */
                    u.dipdw.dwData      = 100 * DEADZONE_PERCENT;
                    SetMaskpFl(JOY_USEDEADZONE, &dwFlags);

                } else
                { //
                    /* No DeadZone */
                    u.dipdw.dwData      = 0x0;
                    ClrMaskpFl(JOY_USEDEADZONE, &dwFlags);
                }

                hres = IDirectInputDevice2_SetProperty(pJoyDev->pdid, DIPROP_DEADZONE, &u.dipdw.diph);

                if ( SUCCEEDED(hres) )
                {

                }

                else
                { // SetProperty( ) FAILED
                    mmRes = JOYERR_UNPLUGGED;
                    dprintf4( (("SetProperty(DIPROP_DEADZONE), FAILED hres=%08lX"), hres ));
                    break;
                }
            } else
            { // Weird Error
                break;
            }
        } // while

        pJoyDev->dwFlags = dwFlags;

        if ( SUCCEEDED(hres) )
        {
            WINMMJOYSTATE  js;

            IDirectInputDevice2_Poll(pJoyDev->pdid);
            hres = IDirectInputDevice2_GetDeviceState(pJoyDev->pdid, sizeof(js), &js);

            if ( FAILED(hres) )
            {
                hres = IDirectInputDevice2_Acquire(pJoyDev->pdid);
                if ( SUCCEEDED(hres) )
                {
                    IDirectInputDevice2_Poll(pJoyDev->pdid);
                    hres = IDirectInputDevice2_GetDeviceState(pJoyDev->pdid, sizeof(js), &js);
                }
            }

            if ( SUCCEEDED(hres) )
            {
                pji->dwButtons = 0;
                pji->dwButtonNumber = 0;

                /* Button Press Information */
                if ( pji->dwFlags & JOY_RETURNBUTTONS )
                {
                    DWORD dwButton;
                    DWORD dwMinButtonFld;

                    dwMinButtonFld = min( cJoyPosButtonMax, pJoyDev->dwButtons );

                    for ( dwButton = 0 ;
                        dwButton < dwMinButtonFld;
                        dwButton++
                        )
                    {
                        if ( js.rgbButtons[dwButton] & 0x80 )
                        {
                            /* Button Press */
                            pji->dwButtons |= (0x1 << dwButton);

                            /* Button Number */
                            pji->dwButtonNumber++;
                        }
                    }

                }

                /* Axis Information */

                pji->dwXpos = (DWORD)js.lX;          /* x position */
                pji->dwYpos = (DWORD)js.lY;          /* y position */
                pji->dwRpos = (DWORD)js.lR;         /* rudder/4th axis position */
                pji->dwZpos = (DWORD)js.lZ;          /* z position */
                pji->dwUpos = (DWORD)js.lU;         /* 5th axis position */
                pji->dwVpos = (DWORD)js.lV;         /* 6th axis position */
                /*  Note the WinMM POV is a WORD value  */
                pji->dwPOV  = (WORD)js.dwPOV;   /* point of view state */

                if ( g_fHasWheel )
                {
                    if( dwMaxAccl < pji->dwYpos ) {
                        dwMaxAccl = pji->dwYpos;
                    }

                    if( dwMaxBrake < pji->dwRpos ) {
                        dwMaxBrake = pji->dwRpos;
                    }

                    /*
                     * Make up Y value with dwRpos(brake) and dwYpos(accelerator).
                     */
                    if( dwLastAccl != pji->dwYpos ) {
                        dwLastAccl = pji->dwYpos;
                        pji->dwYpos = pji->dwYpos>>1;
                    } else if ( dwLastBrake != pji->dwRpos ) {
                        dwLastBrake = pji->dwRpos;
                        pji->dwYpos = dwMaxY - (pji->dwRpos>>1);
                    } else {
                        if( (pji->dwYpos == dwMaxAccl) && (pji->dwRpos == dwMaxBrake ) ) {
                            pji->dwYpos = dwMidY;
                        } else if ( (dwMaxAccl - pji->dwYpos) > (dwMaxBrake - pji->dwRpos) )
                            /*
                             * In this case, use percentage can get a little
                             * more precision, but not worth doing that.
                             */
                        {
                            pji->dwYpos = pji->dwYpos>>1;
                        } else
                        {
                            pji->dwYpos = dwMaxY - (pji->dwRpos>>1);
                        }
                    }
                    pji->dwRpos = 0x0;         /* rudder/4th axis position */
                }

            } else
            { // GetDeviceState FAILED
                mmRes = JOYERR_UNPLUGGED;
                dprintf1(( ("GetDeviceState, FAILED hres=%08lX"), hres ));
            }
        } else
        { // Acquire FAILED
            mmRes = JOYERR_UNPLUGGED;
            dprintf1(( ("Acquire, FAILED hres=%08lX"), hres ));
        }
    } else
    { // Joy_Open FAILED
        mmRes =  JOYERR_PARMS;
        dprintf1(( ("joyOpen, FAILED hres=%08lX"), hres ));
    }

    DllLeaveCrit();

    if ( mmRes == JOYERR_NOERROR )
    {
        JOY_DBGPRINT( JOY_BABBLE, ("joyGetPosEx: return OK, x:%d, y:%d, z:%d, r:%d, u:%d, v:%d, btn: %x", \
                                   pji->dwXpos, pji->dwXpos, pji->dwZpos, pji->dwRpos, pji->dwUpos, pji->dwVpos, pji->dwButtons) );
    } else
    {
        JOY_DBGPRINT( JOY_BABBLE, ("joyGetPosEx: return %d", mmRes) );
    }

    return mmRes;
}


/*****************************************************************************
 *
 *  @doc    WINAPI
 *
 *  @func   MMRESULT | joyGetPos |
 *
 *          Get Joystick Position Information.
 *
 *  @parm   UINT | idJoy |
 *
 *          Id of the Joystick.
 *
 *  @parm   LPJOYINFO | pji |
 *
 *          Structure to be filled with Joystick Information data
 *
 *****************************************************************************/

MMRESULT WINAPI joyGetPos( UINT idJoy, LPJOYINFO pji )
{
    JOYINFOEX jiex;
    MMRESULT  mmRes;

    JOY_DBGPRINT( JOY_BABBLE, ("joyGetPos: idJoy=%d, pji=0x%08x", idJoy, pji) );

    V_WPOINTER(pji, sizeof(JOYINFO), MMSYSERR_INVALPARAM);

    jiex.dwSize  = sizeof(jiex);
    jiex.dwFlags = JOY_RETURNX | JOY_RETURNY | JOY_RETURNZ | JOY_RETURNBUTTONS;

    if ( (mmRes = joyGetPosEx (idJoy, &jiex)) == JOYERR_NOERROR )
    {
        pji->wXpos    = (UINT)jiex.dwXpos;
        pji->wYpos    = (UINT)jiex.dwYpos;
        pji->wZpos    = (UINT)jiex.dwZpos;
        pji->wButtons = (UINT)jiex.dwButtons;
    }

    if ( mmRes == JOYERR_NOERROR )
    {
        JOY_DBGPRINT( JOY_BABBLE, ("joyGetPos: return OK, x:%d, y:%d, z:%d, btn:%x", \
                                   pji->wXpos, pji->wXpos, pji->wZpos, pji->wButtons) );
    } else
    {
        JOY_DBGPRINT( JOY_BABBLE, ("joyGetPos: return %d", mmRes) );
    }

    return mmRes;
}


/****************************************************************************

    @doc EXTERNAL

    @api UINT | joyGetThreshold | This function queries the current
    movement threshold of a joystick device.

    @parm UINT | idJoy | Identifies the joystick device to be queried.

    @parm PUINT | lpwThreshold | Specifies a far pointer to a UINT variable
    that is filled with the movement threshold value.

    @rdesc Returns JOYERR_NOERROR if successful.  Otherwise, returns one of the
    following error codes:

    @flag MMSYSERR_NODRIVER | The joystick driver is not present.

    @flag JOYERR_PARMS | The specified joystick device ID <p idJoy> is invalid.

    @comm The movement threshold is the distance the joystick must be
      moved before a WM_JOYMOVE message is sent to a window that has
      captured the device. The threshold is initially zero.

    @xref joySetThreshold

****************************************************************************/

MMRESULT WINAPI joyGetThreshold( UINT idJoy, PUINT puThreshold )
{
    HRESULT       hres;
    MMRESULT      mmRes = JOYERR_NOERROR;
    JOYCAPSW      jc;

    JOY_DBGPRINT( JOY_BABBLE, ("joyGetThreshold: idJoy=%d, uThreshold=%d", idJoy, *puThreshold) );

    V_WPOINTER(puThreshold, sizeof(UINT), MMSYSERR_INVALPARAM);

    if (idJoy >= cJoyMax)
    {
        JOY_DBGPRINT( JOY_ERR, ("joyGetThreshold: return %d ", MMSYSERR_INVALPARAM) );
        return MMSYSERR_INVALPARAM;
    }

    memset(&jc, 0, sizeof(jc));

    DllEnterCrit();

    hres = joyOpen(idJoy, &jc);

    DllLeaveCrit();

    if ( FAILED(hres) )
    {
        JOY_DBGPRINT( JOY_ERR, ("joyGetThreshold: return MMSYSERROR_NOERROR, but no joystick configured.") );
        mmRes = MMSYSERR_INVALPARAM;
    } else
    {
        *puThreshold = g_pJoyDev[idJoy]->uThreshold;
    }

    JOY_DBGPRINT( JOY_BABBLE, ("joyGetThreshold: return %d", mmRes) );
    return mmRes;
}

/****************************************************************************

    @doc WINAPI

    @api UINT | joySetThreshold | This function sets the movement threshold
     of a joystick device.

    @parm UINT | idJoy | Identifies the joystick device.  This value is either

    @parm UINT | uThreshold | Specifies the new movement threshold.

    @rdesc Returns JOYERR_NOERROR if successful.  Otherwise, returns one of the
    following error codes:

    @flag MMSYSERR_NODRIVER | The joystick driver is not present.

    @flag JOYERR_PARMS | The specified joystick device ID <p idJoy> is invalid.

    @comm The movement threshold is the distance the joystick must be
      moved before a MM_JOYMOVE message is sent to a window that has
      captured the device.

    @xref joyGetThreshold joySetCapture

****************************************************************************/

MMRESULT WINAPI joySetThreshold(UINT idJoy, UINT uThreshold)
{
    HRESULT       hres;
    MMRESULT      mmRes = JOYERR_NOERROR;
    JOYCAPSW      jc;

    JOY_DBGPRINT( JOY_BABBLE, ("joySetThreshold: idJoy=%d, uThreshold=%d", idJoy, uThreshold) );

    if ( (idJoy >= cJoyMax) || (uThreshold>0xFFFF)  )
    {
        JOY_DBGPRINT( JOY_ERR, ("joySetThreshold: return MMSYSERR_INVALPARAM (idJoy>16 or uThreshold>65535)") );
        return MMSYSERR_INVALPARAM;
    }

    memset(&jc, 0, sizeof(jc));

    DllEnterCrit();
    hres = joyOpen(idJoy, &jc);
    DllLeaveCrit();

    if ( FAILED(hres) )
    {
        JOY_DBGPRINT( JOY_ERR, ("joySetThreshold: return MMSYSERROR_NOERROR, but no joystick configured") );
        mmRes = MMSYSERR_INVALPARAM;
    } else
    {
        g_pJoyDev[idJoy]->uThreshold = (UINT)uThreshold;
    }

    JOY_DBGPRINT( JOY_BABBLE, ("joySetThreshold: return %d", mmRes) );
    return mmRes;
}


/****************************************************************************

    @doc WINAPI

    @api UINT | joySetCapture | This function causes joystick messages to
    be sent to the specified window.

    @parm HWND | hWnd | Specifies a handle to the window to which messages
    are to be sent.

    @parm UINT | idJoy | Identifies the joystick device to be captured.

    @parm UINT | uPeriod | Specifies the polling rate, in milliseconds.

    @parm BOOL | fChanged | If this parameter is set to TRUE, then messages
    are sent only when the position changes by a value greater than the
    joystick movement threshold.

    @rdesc Returns JOYERR_NOERROR if successful.  Otherwise, returns one of the
    following error codes:

    @flag MMSYSERR_NODRIVER | The joystick driver is not present.

    @flag JOYERR_PARMS | The specified window handle <p hWnd>
    or joystick device ID <p idJoy> is invalid.

    @flag JOYERR_NOCANDO | Cannot capture joystick input because some
    required service (for example, a Windows timer) is unavailable.

    @flag JOYERR_UNPLUGGED | The specified joystick is not connected to the
    system.

    @comm     This function fails if the specified joystick device is
    currently captured.  You should call the <f joyReleaseCapture> function when
    the joystick capture is no longer needed.  If the window is destroyed,
    the joystick will be released automatically.

    @xref  joyReleaseCapture joySetThreshold joyGetThreshold

****************************************************************************/

MMRESULT WINAPI joySetCapture(HWND hwnd, UINT idJoy, UINT uPeriod, BOOL fChanged)
{
    JOYINFO     joyinfo;
    LPJOYINFO   lpinfo = &joyinfo;
    UINT        w;
    JOYCAPS     JoyCaps;
    MMRESULT    mmRes = MMSYSERR_NOERROR;

    JOY_DBGPRINT( JOY_BABBLE, ("joySetCapture: hwnd=0x%08x, idJoy=%d, uPeriod=%d, fChanged=%d", \
                               hwnd, idJoy, uPeriod, fChanged) );

    if ( !hwnd || !IsWindow(hwnd) )
    {
        JOY_DBGPRINT( JOY_ERR, ("joySetCapture: return JOYERROR_PARMS(hwnd=NULL || !IsWindow(hwnd))"));
        return JOYERR_PARMS;
    }

    if ( idJoy >= cJoyMax )
    {
        JOY_DBGPRINT( JOY_ERR, ("joySetCapture: return JOYERR_PARMS(idJoy > 16)") );
        return JOYERR_PARMS;
    }

    if ( g_dwNumOpen >= cJoyMaxInWinmm )
    {
        JOY_DBGPRINT( JOY_ERR, ("joySetCapture: return MMSYSERR_NODRIVER") );
        return MMSYSERR_NODRIVER;      //we don't support to capture more than two joysticks
    }

    if ( uPeriod < MIN_PERIOD )
    {
        uPeriod = MIN_PERIOD;
    } else if ( uPeriod > MAX_PERIOD )
    {
        uPeriod = MAX_PERIOD;
    }

    if ( g_pJoyDev[idJoy] )
    {            //already opened
        if ( hwnd == g_pJoyDev[idJoy]->hwnd )
        {
            if( (g_pJoyDev[idJoy]->uPeriod == uPeriod)
              && (g_pJoyDev[idJoy]->fChanged = fChanged) ) {
                JOY_DBGPRINT( JOY_ERR, ("joySetCapture: return JOYERR_NOCANDO") );
                return JOYERR_NOCANDO;
            }

            g_pJoyDev[idJoy]->uPeriod = uPeriod;                      //assign new values
            g_pJoyDev[idJoy]->fChanged = fChanged;

            JOY_DBGPRINT( JOY_ERR, ("joySetCapture: return JOYERR_NOERROR") );
            return JOYERR_NOERROR;
        } else
        {
            if ( IsWindow(g_pJoyDev[idJoy]->hwnd) )
            {    //already get focus
                JOY_DBGPRINT( JOY_ERR, ("joySetCapture: return JOYERR_NOCANDO") );
                return JOYERR_NOCANDO;              //is being used by another windows
            }
        }
    }

    if ( joyGetDevCaps (idJoy, &JoyCaps, sizeof(JOYCAPS)) == JOYERR_NOERROR )
    {
        uPeriod = min(JoyCaps.wPeriodMax,max(JoyCaps.wPeriodMin,uPeriod));
    } else
    {
        JOY_DBGPRINT( JOY_ERR, ("joySetCapture: return MMSYSERR_NODRIVER") );
        return MMSYSERR_NODRIVER;
    }

    // ensure that position info. is ok.
    if ( w = joyGetPos(idJoy, lpinfo) )
    {      //something wrong, so just return
        JOY_DBGPRINT( JOY_ERR, ("joySetCapture: return %d", w) );
        return(w);
    }

    DllEnterCrit();

    mmRes = (MMRESULT)joyOpen(idJoy, NULL);

    if ( SUCCEEDED(mmRes) )
    {
        if ( !(g_pJoyDev[idJoy]->uIDEvent = SetTimer(NULL, 0, uPeriod, joyPollCallback)) )
        {
            joyClose(idJoy);
            mmRes = JOYERR_NOCANDO;
            goto _OUT;
        }

        g_pJoyDev[idJoy]->hwnd = hwnd;
        g_pJoyDev[idJoy]->uIDJoy = g_dwNumOpen;
        g_pJoyDev[idJoy]->uPeriod = uPeriod;
        g_pJoyDev[idJoy]->fChanged = fChanged;
        g_pJoyDev[idJoy]->uThreshold = 0;

        g_dwNumOpen++;

        mmRes = JOYERR_NOERROR;
    } else
    {
        mmRes = MMSYSERR_NODRIVER;
    }

    _OUT:
    DllLeaveCrit();

    JOY_DBGPRINT( JOY_BABBLE, ("joySetCapture: return %d", mmRes) );
    return mmRes;
}

/****************************************************************************

    @doc WINAPI

    @api UINT | joyReleaseCapture | This function releases the capture
    set by <f joySetCapture> on the specified joystick device.

    @parm UINT | idJoy | Identifies the joystick device to be released.
    This value is either JOYSTICKID1 or JOYSTICK2.

    @rdesc Returns JOYERR_NOERROR if successful.  Otherwise, returns one of the
    following error codes:

    @flag MMSYSERR_NODRIVER | The joystick driver is not present.

    @flag JOYERR_PARMS | The specified joystick device ID <p idJoy> is invalid.

    @xref joySetCapture
****************************************************************************/

MMRESULT WINAPI joyReleaseCapture(UINT idJoy)
{
    JOY_DBGPRINT( JOY_BABBLE, ("joyReleaseCapture: idJoy=%d", idJoy) );

    if ( idJoy >= cJoyMax )
    {
        JOY_DBGPRINT( JOY_ERR, ("joyReleaseCapture: return JOYERR_PARMS(idJoy > 16)") );
        return JOYERR_PARMS;
    }

    if ( !g_pJoyDev[idJoy] )
    {
        JOY_DBGPRINT( JOY_ERR, ("joyReleaseCapture: return MMSYSERR_NODRIVER") );
        return MMSYSERR_INVALPARAM;
    }

    DllEnterCrit();

    // kill the timer
    if ( g_pJoyDev[idJoy]->uIDEvent )
    {
        KillTimer (NULL, g_pJoyDev[idJoy]->uIDEvent);
    }

    DllLeaveCrit();

    JOY_DBGPRINT( JOY_ERR, ("joyReleaseCapture: return JOYERR_NOERROR") );
    return JOYERR_NOERROR;
}


/****************************************************************************
    @doc WINAPI

    @api void | joyPollCallback | Function called for joystick
     timer polling scheme initiated from SetCapture call.

    @parm HWND | hWnd | Identifies the window associated with the timer
    event.

    @parm UINT | wMsg | Specifies the WM_TIMER message.

    @parm UINT | uIDEvent | Specifies the timer's ID.

    @parm DWORD | dwTime | Specifies the current system time.

****************************************************************************/

void CALLBACK joyPollCallback(HWND hWnd, UINT wMsg, UINT_PTR uIDEvent, DWORD dwTime)
{
#define     diff(w1,w2) (UINT)(w1 > w2 ? w1-w2 : w2-w1)

    static  JOYINFO  oldInfo[cJoyMaxInWinmm] = {{ 0, 0, 0, 0},{ 0, 0, 0, 0}};
    static  LPJOYDEVICE pJoyDev;
    JOYINFO Info;
    UINT    idJoy, w ,fBtnMask;

    for ( idJoy=0;idJoy<cJoyMax;idJoy++ )
    {
        if ( g_pJoyDev[idJoy] == NULL )
            continue;

        if ( uIDEvent == g_pJoyDev[idJoy]->uIDEvent )
        {
            pJoyDev = g_pJoyDev[idJoy];
            uIDEvent = pJoyDev->uIDJoy;
            break;
        }
    }

    if ( idJoy == cJoyMax )
    {
#ifdef DBG
        dprintf1((("MMSYSTEM: Invalid timer handle in joy.c\n") ));
        KillTimer (NULL, uIDEvent);
#endif
        return;
    }

    if ( !pJoyDev->hwnd || !IsWindow(pJoyDev->hwnd) )
    {
        joyReleaseCapture((UINT)uIDEvent);
    }

    if ( !joyGetPos((UINT)uIDEvent,(LPJOYINFO)&Info) )
    {

        for ( w=0,fBtnMask=1; w<4; w++,fBtnMask <<=1 )
        {
            if ( (Info.wButtons ^ oldInfo[uIDEvent].wButtons) & fBtnMask )
            {
                PostMessage( pJoyDev->hwnd,
                             (UINT)(uIDEvent + ((Info.wButtons & fBtnMask) ? MM_JOY1BUTTONDOWN : MM_JOY1BUTTONUP)),
                             (WPARAM)(Info.wButtons | fBtnMask << 8),
                             MAKELPARAM(Info.wXpos,Info.wYpos));
            }
        }

        if ( !pJoyDev->fChanged ||
             diff(Info.wXpos,oldInfo[uIDEvent].wXpos)>pJoyDev->uThreshold ||
             diff(Info.wYpos,oldInfo[uIDEvent].wYpos)>pJoyDev->uThreshold )
        {
            PostMessage( pJoyDev->hwnd,
                         (UINT)(MM_JOY1MOVE+uIDEvent),
                         (WPARAM)(Info.wButtons),
                         MAKELPARAM(Info.wXpos,Info.wYpos)); // WARNING: note the truncations
        }

        if ( !pJoyDev->fChanged ||
             diff(Info.wZpos,oldInfo[uIDEvent].wZpos)>pJoyDev->uThreshold )
        {
            PostMessage(
                       pJoyDev->hwnd,
                       (UINT)(MM_JOY1ZMOVE+uIDEvent),
                       (WPARAM)Info.wButtons,
                       MAKELPARAM(Info.wZpos,0));
        }

        oldInfo[uIDEvent] = Info;
    }

#undef  diff
}

void AssignToArray(LPCDIDEVICEOBJECTINSTANCE lpddoi, eCtrls CtrlID, DIOBJECTDATAFORMAT* pDevs)
{
    if (CtrlID < eSIM_THROTTLE) //axes
        if (!(lpddoi->dwType & DIDFT_AXIS)) //some bizarre FF stuff
            return;
    if (CtrlID < eBTN) //only want first one
        if (pDevs[CtrlID].dwType)
            return;
    //need to save GUIDs for the const data format pointers to pint to
    rgoWinMMGUIDs[CtrlID] = lpddoi->guidType;
    pDevs[CtrlID].pguid = &(rgoWinMMGUIDs[CtrlID]);
    pDevs[CtrlID].dwFlags = lpddoi->dwFlags;
    pDevs[CtrlID].dwOfs = lpddoi->dwOfs;
    pDevs[CtrlID].dwType = lpddoi->dwType;
}

//Assigns to the custom data format while preserving the offsets
void AssignToRGODF(DIOBJECTDATAFORMAT* pDof, int CtrlID)
{
    AssertF(CtrlID<MAX_FINAL);
    c_rgodfWinMMJoy[CtrlID].pguid = pDof->pguid;
    //c_rgodfWinMMJoy[CtrlID].pguid = NULL;
    c_rgodfWinMMJoy[CtrlID].dwFlags = pDof->dwFlags;
    c_rgodfWinMMJoy[CtrlID].dwType  = pDof->dwType;
}

/* This version assigns on the basis of Usage/Usage Page
 * This causes problems when using IHV remapping as this 
 * swaps the usage/usage page but not the guid. When we
 * then go into dinput to get the values it carefully swaps
 * it all back for us and we lose the mapping. Instead use the 
 * next version that assigns on the basis of guid (where applicable)
 * so the dinput remappings remain in place.
BOOL CALLBACK DIEnumDeviceObjectsCallback(LPCDIDEVICEOBJECTINSTANCE lpddoi,LPVOID pvRef)
{
    AssertF(lpddoi);
    if (!pvRef)
        return DIENUM_STOP; //we can't store them
    
    //check the data down to dwType is valid
    if (lpddoi->dwSize < 3*sizeof(DWORD)+sizeof(GUID))
    {
        //show some debug info
        return DIENUM_CONTINUE;
    }
    
    //first we check if it is a button
    if (lpddoi->dwType & DIDFT_BUTTON)
    {
        //the button number is the usage
        //and we want up to 32 of them
        if (lpddoi->wUsage<33)
            AssignToArray(lpddoi,eBTN+lpddoi->wUsage-1,pvRef);
        return DIENUM_CONTINUE;
    }

    switch (lpddoi->wUsagePage) {
    case HID_USAGE_PAGE_GENERIC:
        switch (lpddoi->wUsage) {
        case HID_USAGE_GENERIC_X:
            AssignToArray(lpddoi,eGEN_X,pvRef);
            return DIENUM_CONTINUE;
        case HID_USAGE_GENERIC_Y:
            AssignToArray(lpddoi,eGEN_Y,pvRef);
            return DIENUM_CONTINUE;
        case HID_USAGE_GENERIC_Z:
            AssignToArray(lpddoi,eGEN_Z,pvRef);
            return DIENUM_CONTINUE;
        case HID_USAGE_GENERIC_RX:
            AssignToArray(lpddoi,eGEN_RX,pvRef);
            return DIENUM_CONTINUE;
        case HID_USAGE_GENERIC_RY:
            AssignToArray(lpddoi,eGEN_RY,pvRef);
            return DIENUM_CONTINUE;
        case HID_USAGE_GENERIC_RZ:
            AssignToArray(lpddoi,eGEN_RZ,pvRef);
            return DIENUM_CONTINUE;
        case HID_USAGE_GENERIC_SLIDER:
            AssignToArray(lpddoi,eGEN_SLIDER,pvRef);
            return DIENUM_CONTINUE;
        case HID_USAGE_GENERIC_DIAL:
            AssignToArray(lpddoi,eGEN_DIAL,pvRef);
            return DIENUM_CONTINUE;
        case HID_USAGE_GENERIC_HATSWITCH:
            AssignToArray(lpddoi,eGEN_POV,pvRef);
            return DIENUM_CONTINUE;
        }
    break;
    
    case HID_USAGE_PAGE_SIMULATION:
        switch (lpddoi->wUsage) {
        case HID_USAGE_SIMULATION_STEERING:
            AssignToArray(lpddoi,eSIM_STEERING,pvRef);
            return DIENUM_CONTINUE;
        case HID_USAGE_SIMULATION_ACCELERATOR:
            AssignToArray(lpddoi,eSIM_ACCELERATOR,pvRef);
            return DIENUM_CONTINUE;
        case HID_USAGE_SIMULATION_THROTTLE:
            AssignToArray(lpddoi,eSIM_THROTTLE,pvRef);
            return DIENUM_CONTINUE;
        case HID_USAGE_SIMULATION_RUDDER:
            AssignToArray(lpddoi,eSIM_RUDDER,pvRef);
            return DIENUM_CONTINUE;
        case HID_USAGE_SIMULATION_BRAKE:
            AssignToArray(lpddoi,eSIM_BRAKE,pvRef);
            return DIENUM_CONTINUE;
        }
        break;
    }
    return DIENUM_CONTINUE;
}
******************************************************************/

//This one assigns on the basis of GUID
BOOL CALLBACK DIEnumDeviceObjectsCallback(LPCDIDEVICEOBJECTINSTANCE lpddoi,LPVOID pvRef)
{
    AssertF(lpddoi);
    if (!pvRef)
        return DIENUM_STOP; //we can't store them
    
    //check the data down to dwType is valid
    if (lpddoi->dwSize < 3*sizeof(DWORD)+sizeof(GUID))
    {
        //show some debug info
        return DIENUM_CONTINUE;
    }
    
    if (lpddoi->wUsagePage == HID_USAGE_PAGE_GENERIC &&
            lpddoi->wUsage == HID_USAGE_GENERIC_DIAL)
        AssignToArray(lpddoi,eGEN_DIAL,pvRef);
    else if (lpddoi->wUsagePage == HID_USAGE_PAGE_SIMULATION)
    {
        switch (lpddoi->wUsage) 
        {
        case HID_USAGE_SIMULATION_STEERING:
            AssignToArray(lpddoi,eSIM_STEERING,pvRef);break;
        case HID_USAGE_SIMULATION_ACCELERATOR:
            AssignToArray(lpddoi,eSIM_ACCELERATOR,pvRef);break;
        case HID_USAGE_SIMULATION_THROTTLE:
            AssignToArray(lpddoi,eSIM_THROTTLE,pvRef);break;
        case HID_USAGE_SIMULATION_RUDDER:
            AssignToArray(lpddoi,eSIM_RUDDER,pvRef);break;
        case HID_USAGE_SIMULATION_BRAKE:
            AssignToArray(lpddoi,eSIM_BRAKE,pvRef);break;
        }
    }
    else if (IsEqualGUID(&(lpddoi->guidType),&GUID_Button))
    {
        //the button number is the usage
        //and we want up to 32 of them
        if (lpddoi->wUsage<33)
            AssignToArray(lpddoi,eBTN+lpddoi->wUsage-1,pvRef);
    }
    else if (IsEqualGUID(&(lpddoi->guidType),&GUID_XAxis))
        AssignToArray(lpddoi,eGEN_X,pvRef);
    else if (IsEqualGUID(&(lpddoi->guidType),&GUID_YAxis))
        AssignToArray(lpddoi,eGEN_Y,pvRef);
    else if (IsEqualGUID(&(lpddoi->guidType),&GUID_ZAxis))
        AssignToArray(lpddoi,eGEN_Z,pvRef);
    else if (IsEqualGUID(&(lpddoi->guidType),&GUID_RxAxis))
        AssignToArray(lpddoi,eGEN_RX,pvRef);
    else if (IsEqualGUID(&(lpddoi->guidType),&GUID_RyAxis))
        AssignToArray(lpddoi,eGEN_RY,pvRef);
    else if (IsEqualGUID(&(lpddoi->guidType),&GUID_RzAxis))
        AssignToArray(lpddoi,eGEN_RZ,pvRef);
    else if (IsEqualGUID(&(lpddoi->guidType),&GUID_Slider))
        AssignToArray(lpddoi,eGEN_SLIDER,pvRef);
    else if (IsEqualGUID(&(lpddoi->guidType),&GUID_POV))
        AssignToArray(lpddoi,eGEN_POV,pvRef);
    
    return DIENUM_CONTINUE;
}

#define USED_RX 0x01
#define USED_RY 0x02
//#define USED_RZ 0x04
//#define USED_RUDDER 0x08
//#define USED_BRAKE 0x10
#define USED_THROT 0x20 
#define USED_SLIDER 0x40
#define USED_DIAL 0x80

//Perform mapping of ctrls to axes/pov/btns as in joyhid.c
//return caps word and number of buttons and axes
void AssignMappings(DIOBJECTDATAFORMAT *dwAll, DWORD *dwCaps, DWORD *dwBtns, DWORD *dwAxes)
{
    int i;
    BYTE bUsed=0x00; //to prevent dual mapping
    *dwAxes=0;
    //Do the X-Axis
    if (dwAll[eGEN_X].dwType)
    {
        AssignToRGODF(&(dwAll[eGEN_X]),0);
        (*dwAxes)++;
    }
    else if (dwAll[eSIM_STEERING].dwType)
    {
        AssignToRGODF(&(dwAll[eSIM_STEERING]),0);
        (*dwAxes)++;
    }
    else if (dwAll[eGEN_RY].dwType)
    {
        AssignToRGODF(&(dwAll[eGEN_RY]),0);
        bUsed |= USED_RY;
        (*dwAxes)++;
    }
    //Y-Axis
    if (dwAll[eGEN_Y].dwType)
    {
        AssignToRGODF(&(dwAll[eGEN_Y]),1);
        (*dwAxes)++;
    }
    else if (dwAll[eSIM_ACCELERATOR].dwType)
    {
        AssignToRGODF(&(dwAll[eSIM_ACCELERATOR]),1);
        (*dwAxes)++;
    }
    else if (dwAll[eGEN_RX].dwType)
    {
        AssignToRGODF(&(dwAll[eGEN_RX]),1);
        bUsed |= USED_RX;
        (*dwAxes)++;
    }
    //Z-Axis
    if (dwAll[eGEN_Z].dwType)
    {
        AssignToRGODF(&(dwAll[eGEN_Z]),2);
        *dwCaps |= JOYCAPS_HASZ;
        (*dwAxes)++;
    }
    else if (dwAll[eSIM_THROTTLE].dwType)
    {
        AssignToRGODF(&(dwAll[eSIM_THROTTLE]),2);
        *dwCaps |= JOYCAPS_HASZ;
        bUsed |= USED_THROT;
        (*dwAxes)++;
    }
    else if (dwAll[eGEN_SLIDER].dwType)
    {
        AssignToRGODF(&(dwAll[eGEN_SLIDER]),2);
        *dwCaps |= JOYCAPS_HASZ;
        bUsed |= USED_SLIDER;
        (*dwAxes)++;
    }
    else if (dwAll[eGEN_DIAL].dwType)
    {
        AssignToRGODF(&(dwAll[eGEN_DIAL]),2);
        *dwCaps |= JOYCAPS_HASZ;
        bUsed |= USED_DIAL;
        (*dwAxes)++;
    }
    //RUV need use same set
    for (i=0;i<3;++i)
    {
      if (!i) //R Only
      {
        if (dwAll[eSIM_RUDDER].dwType)
        {
            AssignToRGODF(&(dwAll[eSIM_RUDDER]),3);
            *dwCaps |= JOYCAPS_HASR;
            (*dwAxes)++;
            continue;
        }
        if (dwAll[eGEN_RZ].dwType)
        {
            AssignToRGODF(&(dwAll[eGEN_RZ]),3);
            *dwCaps |= JOYCAPS_HASR;
            (*dwAxes)++;
            continue;
        }
        if (dwAll[eSIM_BRAKE].dwType)
        {
            AssignToRGODF(&(dwAll[eSIM_BRAKE]),3);
            *dwCaps |= JOYCAPS_HASR;
            (*dwAxes)++;
            continue;
        }
      }
      if (i<2) //not V
      {
        if (dwAll[eSIM_THROTTLE].dwType && !(bUsed&USED_THROT))
        {
            AssignToRGODF(&(dwAll[eSIM_THROTTLE]),3+i);
            if (!i)
                *dwCaps |= JOYCAPS_HASR;
            else
                *dwCaps |= JOYCAPS_HASU;
            bUsed |= USED_THROT;
            (*dwAxes)++;
            continue;
        }
        if (dwAll[eGEN_SLIDER].dwType && !(bUsed&USED_SLIDER))
        {
            AssignToRGODF(&(dwAll[eGEN_SLIDER]),3+i);
            if (!i)
                *dwCaps |= JOYCAPS_HASR;
            else
                *dwCaps |= JOYCAPS_HASU;
            bUsed |= USED_SLIDER;
            (*dwAxes)++;
            continue;
        }
        if (dwAll[eGEN_DIAL].dwType && !(bUsed&USED_DIAL))
        {
            AssignToRGODF(&(dwAll[eGEN_DIAL]),3+i);
            if (!i)
                *dwCaps |= JOYCAPS_HASR;
            else
                *dwCaps |= JOYCAPS_HASU;
            bUsed |= USED_DIAL;
            (*dwAxes)++;
            continue;
        }
        if (dwAll[eGEN_RY].dwType && !(bUsed&USED_RY))
        {
            AssignToRGODF(&(dwAll[eGEN_RY]),3+i);
            if (!i)
                *dwCaps |= JOYCAPS_HASR;
            else
                *dwCaps |= JOYCAPS_HASU;
            bUsed |= USED_RY;
            (*dwAxes)++;
            continue;
        }
      }
      //All 3
      if (dwAll[eGEN_RX].dwType && !(bUsed&USED_RX))
      {
        AssignToRGODF(&(dwAll[eGEN_RX]),3+i);
        if (!i)
            *dwCaps |= JOYCAPS_HASR;
        else if (i==1)
            *dwCaps |= JOYCAPS_HASU;
        else 
            *dwCaps |= JOYCAPS_HASV;
        bUsed |= USED_RX;
        (*dwAxes)++;
      }
    } //RUV loop
    //POV control
    if (dwAll[eGEN_POV].dwType)
    {
        AssignToRGODF(&(dwAll[eGEN_POV]),6);
        *dwCaps |= JOYCAPS_HASPOV;
    }
    //now the buttons
    *dwBtns = 0;
    for (i=0;i<MAX_BTNS;++i)
    {
        if (dwAll[eBTN+i].dwType)
        {
            AssignToRGODF(&(dwAll[eBTN+i]),7+i);
            (*dwBtns)++;
        }
    }
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   LRESULT | joyOpen |
 *
 *          Called to open a Joystick with a specified Id.
 *
 *  @parm   UINT | idJoy |
 *
 *          Id of the Joystick to be opened.
 *
 *  @returns LRESULT
 *          DRV_OK indicates the required joystick driver was loaded and
 *          can be accessed
 *
 *****************************************************************************/

HRESULT WINAPI joyOpen(UINT idJoy, LPJOYCAPSW pjc )
{
    HRESULT         hres = S_OK;
    LPJOYDEVICE     pJoyDev;
    DWORD           dwBtns = 0x00;
    DWORD           dwCaps = 0x00;
    DWORD           dwAxes = 0x00;

    AssertF(DllInCrit());

    if ( idJoy >= cJoyMax )
    {
        hres = E_FAIL;
        goto done;
    }

    pJoyDev  = g_pJoyDev[idJoy];
    if ( pJoyDev == NULL )
    {

        if ( !g_hinstDinputDll )
        {
            g_hinstDinputDll = LoadLibrary(TEXT("DINPUT.DLL"));

            if ( g_hinstDinputDll )
            {
                g_farprocDirectInputCreateW = GetProcAddress( g_hinstDinputDll, "DirectInputCreateW" );

                if ( !g_farprocDirectInputCreateW )
                {
                    dprintf1(( ("GetProcAddress(DirectInputCreateW) failed.") ));
                    FreeLibrary(g_hinstDinputDll);
                    g_hinstDinputDll = 0;
                    hres = E_FAIL;
                    goto done;
                }
            } else
            {
                dprintf1(( ("LoadLibrary(dinput.dll) failed.") ));
                hres = E_FAIL;
                goto done;
            }
        }

        if ( !g_pdi )
        {
            // Create the DirectInput interface object
            hres = (HRESULT)g_farprocDirectInputCreateW( ghInst, DIRECTINPUT_VERSION, &g_pdi, NULL) ;
        }

        if ( SUCCEEDED(hres) ) {
            // thread will not do anything until we let go oF the critical section
            if ( !g_fThreadExist )
            {
                g_hThreadMonitor = CreateThread(0, 0, joyMonitorThread, 0, 0, &g_dwThreadID);
                if ( g_hThreadMonitor )
                {
                    SetThreadPriority( g_hThreadMonitor, THREAD_PRIORITY_LOWEST );
                    g_fThreadExist = TRUE;
                }

                CloseHandle( g_hThreadMonitor );
            }
        }

        if ( SUCCEEDED(hres) )
        {
            if ( !g_pdijc )
            {
                /* Query for the JoyConfig interface */
                hres = IDirectInput_QueryInterface(g_pdi,& IID_IDirectInputJoyConfig, &g_pdijc);
            }

            if ( SUCCEEDED(hres) )
            {
                DIJOYCONFIG jc;

                /* Get GUID that maps idJoy  */
                jc.dwSize = sizeof(jc);

                IDirectInputJoyConfig_SendNotify( g_pdijc );

                hres = IDirectInputJoyConfig_GetConfig(g_pdijc, idJoy, &jc, DIJC_REGHWCONFIGTYPE | DIJC_GUIDINSTANCE | DIJC_GAIN );
                if ( SUCCEEDED(hres) )
                {
                    LPDIRECTINPUTDEVICEW   pdidTemp;
                    LPDIRECTINPUTDEVICE2W  pdid;

                    hres = IDirectInput_CreateDevice(g_pdi, &jc.guidInstance, &pdidTemp, NULL);
                    /* Create the device object */
                    if ( SUCCEEDED(hres) )
                    {
                        hres = IDirectInputDevice_QueryInterface(pdidTemp, &IID_IDirectInputDevice2, &pdid);

                        IDirectInputDevice_Release(pdidTemp);
                        (void*)pdidTemp = NULL;

                        if ( SUCCEEDED(hres) )
                        {
                        /* enumerate our controls into the superset*/
                        DIOBJECTDATAFORMAT didoAll[MAX_CTRLS];
                        int i=0;
                        for (i=0;i<MAX_CTRLS;++i)
                        {
                            didoAll[i].dwFlags = 0;//DIDFT_ANYINSTANCE | DIDFT_OPTIONAL;
                            didoAll[i].dwOfs = 0;
                            didoAll[i].dwType = 0;
                            didoAll[i].pguid = NULL;
                        }
                        hres = IDirectInputDevice2_EnumObjects(
                                   pdid,   
                                   DIEnumDeviceObjectsCallback,
                                   didoAll,
                                   DIDFT_ALL);

                        // c_rgodfWinMMJoy needs to be reset for every device.
                        RESET_RGODFWINMMJOY();

                        // Assign our values to the custom device format
                        AssignMappings(didoAll,&dwCaps,&dwBtns,&dwAxes);
                        if ( SUCCEEDED(hres) )
                        {
                            
                            DIDEVCAPS   dc;

                            dc.dwSize = sizeof(DIDEVCAPS_DX3);
                            hres = IDirectInputDevice2_GetCapabilities(pdid, &dc);

                            if ( SUCCEEDED(hres) )
                            {
                                hres = IDirectInputDevice2_SetCooperativeLevel(pdid, NULL, DISCL_NONEXCLUSIVE | DISCL_BACKGROUND );
                                if ( SUCCEEDED(hres) )
                                {
                                    //set to our new custom device format
                                    hres = IDirectInputDevice2_SetDataFormat(pdid, (LPCDIDATAFORMAT)&c_dfWINMMJoystick);
                                    if ( SUCCEEDED(hres) )
                                    {
                                        pJoyDev = LocalAlloc( LPTR, sizeof(JOYDEVICE) );
                                        if ( pJoyDev )
                                        {
                                            memset( pJoyDev, 0, sizeof(*pJoyDev) );
                                            pJoyDev->pdid = pdid;
                                            pJoyDev->dwButtons = dc.dwButtons;
                                            pJoyDev->dwFlags = 0x0;
                                            pJoyDev->uState = INUSE;

                                            // get values for pJoyDev->jcw
                                            {
                                                DIDEVICEINSTANCE didi;
                                                didi.dwSize = sizeof(didi);

                                                IDirectInputDevice2_Acquire(pdid);
                                                hres = IDirectInputDevice2_GetDeviceInfo(pdid, &didi);

                                                if ( SUCCEEDED(hres) )
                                                {
                                                    DIPROPDWORD dipd;

                                                    if( g_dwEnableWheel ) {
                                                        DIDEVICEOBJECTINSTANCE didoi;

                                                        didoi.dwSize = sizeof(DIDEVICEOBJECTINSTANCE);

                                                        hres = IDirectInputDevice2_GetObjectInfo( pdid, &didoi, DIJOFS_Y, DIPH_BYOFFSET);
                                                        if ( SUCCEEDED(hres) )
                                                        {
                                                            if ( didoi.wUsagePage == 2 && didoi.wUsage == 196 ) // This is Accelerator
                                                            {
                                                                if ( jc.hwc.hws.dwFlags  & JOY_HWS_HASR )
                                                                { // Is this Brake?
                                                                    hres = IDirectInputDevice2_GetObjectInfo( pdid, &didoi, DIJOFS_RZ, DIPH_BYOFFSET);
                                                                    if ( SUCCEEDED(hres) )
                                                                    {
                                                                        if ( didoi.wUsagePage == 2 && didoi.wUsage == 197 ) // This is Accelerator
                                                                        {
                                                                            //Yes, this is brake, great!
                                                                            g_fHasWheel = TRUE;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    } // g_dwEnableWheel


                                                    memset( &(pJoyDev->jcw), 0, sizeof(pJoyDev->jcw) );

                                                    dipd.diph.dwSize = sizeof(dipd);
                                                    dipd.diph.dwHeaderSize = sizeof(dipd.diph);
                                                    dipd.diph.dwHow  = DIPH_BYOFFSET;
                                                    // use our mapped one instead if available
                                                    if (c_rgodfWinMMJoy[6].dwType)
                                                        dipd.diph.dwObj = c_rgodfWinMMJoy[6].dwOfs;
                                                    else
                                                        dipd.diph.dwObj = DIJOFS_POV(0);

                                                    hres = IDirectInputDevice2_GetProperty( pdid , DIPROP_GRANULARITY, & dipd.diph );

                                                    if ( SUCCEEDED(hres) )
                                                    {
                                                        //(pJoyDev->jcw).wCaps |= JOYCAPS_HASPOV; //should now be set by AssignMappings
                                                        AssertF(dwCaps&JOYCAPS_HASPOV);
                                                        //Do this instead to copy VJOYD
                                                        dwCaps |= JOYCAPS_POV4DIR;
                                                        /***************
                                                        if ( dipd.dwData >= 9000 )
                                                        { // 4 directional POV
                                                            (pJoyDev->jcw).wCaps |= JOYCAPS_POV4DIR;
                                                        } else
                                                        { // Continuous POV
                                                            (pJoyDev->jcw).wCaps |= JOYCAPS_POVCTS;
                                                        }
                                                        *****************/
                                                    } else
                                                    {
                                                        hres = S_OK;
                                                    }

                                                    (pJoyDev->jcw).wMid = LOWORD(didi.guidProduct.Data1);    // manufacturer ID
                                                    (pJoyDev->jcw).wPid = HIWORD(didi.guidProduct.Data1);    // product ID
                                                    LoadString (ghInst,STR_JOYSTICKNAME,(LPTSTR)(&((pJoyDev->jcw).szPname)),cchLENGTH((pJoyDev->jcw).szPname));

                                                    /*
                                                     * Already memset to 0
                                                     *
                                                       (pJoyDev->jcw).wXmin =
                                                       (pJoyDev->jcw).wYmin =
                                                       (pJoyDev->jcw).wZmin =
                                                       (pJoyDev->jcw).wRmin =
                                                       (pJoyDev->jcw).wUmin =
                                                       (pJoyDev->jcw).wVmin = 0;
                                                     */

                                                    (pJoyDev->jcw).wXmax =
                                                    (pJoyDev->jcw).wYmax =
                                                    (pJoyDev->jcw).wZmax =
                                                    (pJoyDev->jcw).wRmax =
                                                    (pJoyDev->jcw).wUmax =
                                                    (pJoyDev->jcw).wVmax = 0xFFFF;

                                                    (pJoyDev->jcw).wPeriodMin  = MIN_PERIOD;                   // minimum message period when captured
                                                    (pJoyDev->jcw).wPeriodMax  = MAX_PERIOD;                   // maximum message period when captured

                                                    //Now set buttons and axes by Assign Mappings
                                                    //(pJoyDev->jcw).wNumAxes    = dc.dwAxes;                    // number of axes in use
                                                    //(pJoyDev->jcw).wNumButtons = dc.dwButtons;                 // number of buttons
                                                    //(pJoyDev->jcw).wMaxAxes    = cJoyPosAxisMax;               // maximum number of axes supported
                                                    //(pJoyDev->jcw).wMaxButtons = cJoyPosButtonMax;             // maximum number of buttons supported
                                                    (pJoyDev->jcw).wNumAxes    = dwAxes;
                                                    (pJoyDev->jcw).wNumButtons = dwBtns;
                                                    (pJoyDev->jcw).wMaxAxes    = 6;               // maximum number of axes supported
                                                    (pJoyDev->jcw).wMaxButtons = MAX_BTNS;             // maximum number of buttons supported

                                                    lstrcpyW((pJoyDev->jcw).szRegKey,  cwszREGKEYNAME );        // registry key
                                                    
                                                    //Copy settings from AssignMappings
                                                    (pJoyDev->jcw).wCaps |= dwCaps;
                                                    /***************
                                                    // Now done in AssignMappings
                                                    if( !g_fHasWheel ) {
                                                        if ( jc.hwc.hws.dwFlags  & JOY_HWS_HASZ )
                                                            (pJoyDev->jcw).wCaps |= JOYCAPS_HASZ;
                                                        if ( jc.hwc.hws.dwFlags  & JOY_HWS_HASR )
                                                            (pJoyDev->jcw).wCaps |= JOYCAPS_HASR;
                                                    }

                                                    if ( jc.hwc.hws.dwFlags  & JOY_HWS_HASU )
                                                        (pJoyDev->jcw).wCaps |= JOYCAPS_HASU;
                                                    if ( jc.hwc.hws.dwFlags  & JOY_HWS_HASV )
                                                        (pJoyDev->jcw).wCaps |= JOYCAPS_HASV;
                                                    *******************/
                                                }
                                            }

                                            if( pjc ) {
                                                memcpy( pjc, &(pJoyDev->jcw), sizeof(pJoyDev->jcw) );
                                            }

                                        } else
                                        { // Local Alloc FAILED
                                            hres = E_OUTOFMEMORY;

                                            dprintf1( ("LocalAlloc, FAILED") );
                                        }

                                    } else
                                    { // SetDataFormat FAILED
                                        dprintf1(( ("SetDataFormat, FAILED hres=%08lX"), hres ));
                                    }
                                } else
                                { // SetCooperativeLevel FAILED
                                    dprintf1(( ("SetCooperativeLevel, FAILED hres=%08lX"), hres ));
                                }

                            } else
                            { // GetCapabilities FAILED
                                dprintf1(( ("GetCapabilities, FAILED hres=%08lX"), hres ));
                            }
                            } else
                            { // EnumObjects FAILED
                                dprintf1(( ("EnumObjects, FAILED hres=%08lX"), hres ));
                            }
                        } else
                        { // QueryInterface FAILED
                            dprintf1(( ("QueryInterface, FAILED hres=%08lX"), hres ));
                        }
                        /* If we fail to intitialize the device, then release the interface */
                        if ( FAILED(hres) )
                        {
                            LocalFree( (HLOCAL)pJoyDev );
                            IDirectInputDevice2_Release(pdid);
                        }
                    } else
                    { // Create Device Failed
                        dprintf1(( ("CreateDevice, FAILED hres=%08lX"), hres ));
                    }
                } else
                { // JoyGetConfig FAILED
                    dprintf1(( ("joyGetConfig, FAILED hres=%08lX"), hres ));
                }

                /* Release the JoyConfig Interface */
                //IDirectInputJoyConfig_Release(pdijc);
            } else
            { // QI for JoyConfig FAILED
                dprintf1(( ("QueryInterface for JoyConfig, FAILED hres=%08lX"), hres ));
            }

            /* Release the Direct Input interface */
            //IDirectInput_Release(pdi);
        } else
        { // IDirectInputCreate FAILED
            dprintf1(( ("IDirectInputCreate, FAILED hres=%08lX"), hres ));
        }
        g_pJoyDev[idJoy] = pJoyDev;

    } else
    { // Device Interface already exists
        pJoyDev->uState = INUSE;
        if( pjc ) {
            memcpy( pjc, &(pJoyDev->jcw), sizeof(pJoyDev->jcw) );
        }

        hres = S_OK;
    }
    done:
    return hres;
}


/****************************************************************************

    @doc WINAPI

    @api void | joyMonitorThread | This function monitors whether there is a joystick
            that has not being used for a specific time. If yes, close this joystick. If
            there is no joystick opened. This thread will exit itself.

****************************************************************************/

DWORD WINAPI joyMonitorThread(LPVOID lpv)
{
    UINT idJoy;
    LPJOYDEVICE pjd;
    BOOL fJoyOpen = TRUE;
    DWORD dwWaitResult;
    
    while ( fJoyOpen )
    {
        fJoyOpen = FALSE;            //prepare to exit, and this thread will die.

        if( g_hEventWinmm ) {
            dwWaitResult = WaitForSingleObject(g_hEventWinmm, 60000);
            if ( dwWaitResult == WAIT_OBJECT_0 ) {
                //DInput has been released.
                JOY_DBGPRINT( JOY_BABBLE, ("joyMonitorThread: DInput has been released.") );
                break;
            } else if ( dwWaitResult == WAIT_TIMEOUT ) {
                ;
            } else {
            	//g_hEventWinmm is ABANDONED.
            	SleepEx( 60000, FALSE );
            }
        } else {
            //g_hEventWinmm is NULL.
            SleepEx( 60000, FALSE );
        }

        for ( idJoy = 0x0; idJoy < cJoyMax; idJoy++ )
        {
            pjd = g_pJoyDev[idJoy];

            if ( pjd != NULL )
            {
                DllEnterCrit();
                if ( pjd->uState == INUSE )
                {
                    pjd->uState = DEATHROW;
                    fJoyOpen = TRUE;                //A joystick is still likely being used
                } else if ( pjd->uState == DEATHROW )
                {
                    pjd->uState = EXECUTE;
                    fJoyOpen = TRUE;                //A joystick is still likely being used
                } else
                { /* if ( pjd->bState == EXECUTE ) */
                    AssertF( pjd->uState == EXECUTE );
                    joyClose(idJoy);
                }
                DllLeaveCrit();
            }
        }

        if ( fJoyOpen == FALSE )
        {
            DllEnterCrit();
            joyCloseAll();
            DllLeaveCrit();
        }

    }

    g_fThreadExist = FALSE;

    return 0;
}


/*****************************************************************************
 *
 *  @doc    WINAPI
 *
 *  @func   VOID | joyClose |
 *
 *          Close a Joystick with specific Id.
 *
 *  @parm   UINT | idJoy |
 *
 *          Id of the Joystick to be closed.
 *
 *
 *****************************************************************************/
void WINAPI joyClose( UINT idJoy )
{
    if ( idJoy < cJoyMax )
    {
        /* If the device is open, close it */
        if ( g_pJoyDev[idJoy] )
        {
            if ( g_hEventWinmm && WAIT_OBJECT_0 != WaitForSingleObject(g_hEventWinmm, 10))
            {
                //DInput has not been released.
                IDirectInputDevice2_Unacquire(g_pJoyDev[idJoy]->pdid);
                IDirectInputDevice2_Release(g_pJoyDev[idJoy]->pdid);
            }

            /* Free local memory */
            LocalFree( (HLOCAL)g_pJoyDev[idJoy] );
            g_pJoyDev[idJoy] = NULL;
        }
    }
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   VOID | joyCloseAll |
 *
 *          Close all currently opened Joysticks
 *
 *
 *****************************************************************************/
void WINAPI joyCloseAll( void )
{
    UINT idJoy;

    for ( idJoy=0; idJoy<cJoyMax; idJoy++ )
    {
        joyClose(idJoy);
    }
}


/****************************************************************************

    @doc WINAPI

    @api MMRESULT | joyConfigChanged | tells the joystick driver to that
    the configuration information about the joystick has changed.

    @rdesc Returns JOYERR_NOERROR if successful.  Otherwise, returns one of the
    following error codes:

    @flag MMSYSERR_BADDEVICEID | The joystick driver is not present.

    @comm This is used by configuration utilites to tell the driver
      to update its info.   As well, it can be used by apps to
      set specific capabilites.  This will be documented later...

****************************************************************************/

MMRESULT WINAPI joyConfigChanged( DWORD dwFlags )
{
    JOY_DBGPRINT( JOY_BABBLE, ("joyConfigChanged: dwFalgs=0x%08x", dwFlags) );

    if ( dwFlags )
    {
        JOY_DBGPRINT( JOY_BABBLE, ("joyConfigChanged: dwFalgs=0x%08x", dwFlags) );
        return JOYERR_PARMS;
    }

    DllEnterCrit();

    joyCloseAll();

    DllLeaveCrit();

    PostMessage (HWND_BROADCAST, g_wmJoyChanged, 0, 0L);

    JOY_DBGPRINT( JOY_BABBLE, ("joyConfigChanged: return 0") );

    return 0L;
}

/****************************************************************************

    @doc INTERNAL

    @api UINT | joySetCalibration | This function sets the values used to
     convert the values returned by the joystick drivers GetPos function
     to the range specified in GetDevCaps.

    @parm UINT | idJoy | Identifies the joystick device

    @parm PUINT | pwXbase | Specifies the base value for the X pot.  The
      previous value will be copied back to the variable pointed to here.

    @parm PUINT | pwXdelta | Specifies the delta value for the X pot.   The
      previous value will be copied back to the variable pointed to here.

    @parm PUINT | pwYbase | Specifies the base value for the Y pot.  The
      previous value will be copied back to the variable pointed to here.

    @parm PUINT | pwYdelta | Specifies the delta value for the Y pot.   The
      previous value will be copied back to the variable pointed to here.

    @parm PUINT | pwZbase | Specifies the base value for the Z pot.  The
      previous value will be copied back to the variable pointed to here.

    @parm PUINT | pwZdelta | Specifies the delta value for the Z pot.   The
      previous value will be copied back to the variable pointed to here.

    @rdesc The return value is zero if the function was successful, otherwise
       it is an error number.

    @comm The base represents the lowest value the joystick driver returns,
      whereas the delta represents the multiplier to use to convert
      the actual value returned by the driver to the valid range
      for the joystick API's.
      i.e.  If the driver returns a range of 43-345 for the X pot, and
      the valid mmsystem API range is 0-65535, the base value will be
      43, and the delta will be 65535/(345-43)=217.  Thus the base,
      and delta convert 43-345 to a range of 0-65535 with the formula:
      ((wXvalue-43)*217) , where wXvalue was given by the joystick driver.

****************************************************************************/

// !!! We don't support it in WINMM again.
UINT APIENTRY joySetCalibration(UINT id, PUINT pwXbase, PUINT pwXdelta,
                                PUINT pwYbase, PUINT pwYdelta, PUINT pwZbase,
                                PUINT pwZdelta)
{
    JOY_DBGPRINT( JOY_BABBLE, ("joySetCalibration: not supported, please use DINPUT.") );
    return 0;
}


/************************************************************

    Debug

*************************************************************/

#ifdef DBG
int g_cCrit = -1;
UINT g_thidCrit;
TCHAR g_tszLogFile[MAX_PATH];
#endif

/*****************************************************************************
 *
 *  @doc    WINAPI
 *
 *  @func   void | //DllEnterCrit |
 *
 *          Take the DLL critical section.
 *
 *          The DLL critical section is the lowest level critical section.
 *          You may not attempt to acquire any other critical sections or
 *          yield while the DLL critical section is held.  Failure to
 *          comply is a violation of the semaphore hierarchy and will
 *          lead to deadlocks.
 *
 *****************************************************************************/

void WINAPI DllEnterCrit(void)
{
    EnterCriticalSection(&joyCritSec);

#ifdef DBG
    if ( ++g_cCrit == 0 )
    {
        g_thidCrit = GetCurrentThreadId();
    }

    AssertF(g_thidCrit == GetCurrentThreadId());
#endif
}

/*****************************************************************************
 *
 *  @doc    WINAPI
 *
 *  @func   void | //DllLeaveCrit |
 *
 *          Leave the DLL critical section.
 *
 *****************************************************************************/

void WINAPI DllLeaveCrit( void )
{
#ifdef DBG
    AssertF(g_thidCrit == GetCurrentThreadId());
    AssertF(g_cCrit >= 0);

    if ( --g_cCrit < 0 )
    {
        g_thidCrit = 0;
    }
#endif

    LeaveCriticalSection(&joyCritSec);
}

/*****************************************************************************
 *
 *  @doc    WINAPI
 *
 *  @func   void | DllInCrit |
 *
 *          Nonzero if we are in the DLL critical section.
 *
 *****************************************************************************/

#ifdef DBG
BOOL WINAPI DllInCrit( void )
{
    return( g_cCrit >= 0 && g_thidCrit == GetCurrentThreadId() );
}
#endif


#ifdef DBG
int WINAPI AssertPtszPtszLn(LPCTSTR ptszExpr, LPCTSTR ptszFile, int iLine)
{
    winmmDbgOut( ("Assertion failed: `%s' at %s(%d)"), ptszExpr, ptszFile, iLine);
    DebugBreak();
    return 0;
}

void joyDbgOut(LPSTR lpszFormat, ...)
{
    char buf[512];
    UINT n;
    va_list va;

    n = wsprintfA(buf, "WINMM::joy: ");

    va_start(va, lpszFormat);
    n += vsprintf(buf+n, lpszFormat, va);
    va_end(va);

    buf[n++] = '\n';
    buf[n] = 0;
    OutputDebugStringA(buf);
    Sleep(0);  // let terminal catch up
}

#endif

/*****************************************************************************
 *
 *  @doc
 *
 *  @func   HRESULT | hresMumbleKeyEx |
 *
 *          Either open or create the key, depending on the degree
 *          of access requested.
 *
 *  @parm   HKEY | hk |
 *
 *          Base key.
 *
 *  @parm   LPCTSTR | ptszKey |
 *
 *          Name of subkey, possibly NULL.
 *
 *  @parm   REGSAM | sam |
 *
 *          Security access mask.
 *
 *  @parm   DWORD   | dwOptions |
 *          Options for RegCreateEx
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives output key.
 *
 *  @returns
 *
 *          Return value from <f RegOpenKeyEx> or <f RegCreateKeyEx>,
 *          converted to an <t HRESULT>.
 *
 *****************************************************************************/

HRESULT hresMumbleKeyEx(HKEY hk, LPCTSTR ptszKey, REGSAM sam, DWORD dwOptions, PHKEY phk)
{
    HRESULT hres;
    LONG lRc;

    /*
     *  If caller is requesting write access, then create the key.
     *  Else just open it.
     */
    if ( IsWriteSam(sam) )
    {
        lRc = RegOpenKeyEx(hk, ptszKey, 0, sam, phk);

        if ( lRc == ERROR_SUCCESS )
        {
            // Don't need to create it already exists

        }

        else
        {
            lRc = RegCreateKeyEx(hk, ptszKey, 0, 0,
                                 dwOptions,
                                 sam, 0, phk, 0);
        }
    } else
    {
        lRc = RegOpenKeyEx(hk, ptszKey, 0, sam, phk);
    }

    if ( lRc == ERROR_SUCCESS )
    {
        hres = S_OK;
    } else
    {
        if ( lRc == ERROR_KEY_DELETED || lRc == ERROR_BADKEY )
        {
            lRc = ERROR_FILE_NOT_FOUND;
        }
        hres = hresLe(lRc);
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\joy.h ===
/****************************************************************************
 *   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *   KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *   IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *   PURPOSE.
 *
 *   Copyright (c) 1993-1999 Microsoft Corporation
 *
 *  File:       joy.h
 *  Content:    joystick include file
 *
 *@@BEGIN_MSWINAPI
 *
 *  History:
 *   Date        By        Reason
 *   ====        ==        ======
 *   05-oct-94   craige    re-write
 *   25-Nov-97   qzheng    convert to use DINPUT in NT instead of old driver
 *@@END_MSWINAPI
 *
 ***************************************************************************/

#ifndef JOY_H
#define JOY_H

#include <windows.h>
#include <mmsystem.h>
#include <mmreg.h>

#include <devioctl.h>
#include <ntddjoy.h>
#include <mmddk.h>

#define DIRECTINPUT_VERSION 0x50A

#include <dinput.h>
#include <dinputd.h>
#include <mmsystem.h>
#include <hidusage.h>
/*****************************************************************************
 *
 *      Registered window messages
 *
 *****************************************************************************/

#define MSGSTR_JOYCHANGED       TEXT("MSJSTICK_VJOYD_MSGSTR")

/****DEFINES****/
#define cJoyMax     ( 16 )
#define cJoyPosAxisMax     ( 6 )
#define cJoyPosButtonMax   (32 )
#define cJoyMaxInWinmm  (2)

#define cMsecTimer  (20000)
#define INUSE       ( 0 )
#define DEATHROW    ( 1 )
#define EXECUTE     ( 2 )
#define INVALID     (-1 )
#define DEADZONE_PERCENT    ( 5 )

#undef MIN_PERIOD
#define MIN_PERIOD  10
#define MAX_PERIOD  1000

typedef struct tagJOYDEVICE
{
    LPDIRECTINPUTDEVICE2W   pdid;           // Device Interface

    DWORD                   dwButtons;      // Number of Buttons
    DWORD                   dwFlags;        // Cached dwFlags field for last JoyGetPosEx
    HWND                    hwnd;           // the windows owns the focus of the joystick

    UINT                    uPeriod;        // poll period
    UINT                    uThreshold;
    UINT_PTR                uIDEvent;       // timer ID
    BOOL                    fChanged;       //
    UINT                    uIDJoy;         // index of the currently caputured joystick
    UINT                    uState;
    
    JOYCAPSW                jcw;            // the caps of the joystick
} JOYDEVICE, *LPJOYDEVICE;


/*
 *  fEqualMask - checks that all masked bits are equal
 */
BOOL static __inline fEqualMaskFlFl(DWORD flMask, DWORD fl1, DWORD fl2)
{
    return ((fl1 ^ fl2) & flMask) == 0;
}

/*
 * SetMaskFl - Set mask bits in fl
 */
void static __inline SetMaskpFl( DWORD flMask, PDWORD pfl )
{
    *pfl |= flMask;
}

/*
 * ClrMaskFl - Clear mask bits in fl
 */
void static __inline ClrMaskpFl( DWORD flMask, PDWORD pfl )
{
    *pfl &= (! flMask) ;
}


/***************************************************************************
 *
 *  Debugging macros needed by inline functions
 *
 ***************************************************************************/
#if defined(DBG) || defined(RDEBUG)
#define XDBG
#endif

int WINAPI AssertPtszPtszLn(LPCTSTR ptszExpr, LPCTSTR ptszFile, int iLine);

#ifdef DBG
    #define AssertFPtsz(c, ptsz) ((c) ? 0 : AssertPtszPtszLn(ptsz, TEXT(__FILE__), __LINE__))
#else   /* !DBG */
    #define AssertFPtsz(c, ptsz)
#endif

#define AssertF(c)      AssertFPtsz(c, TEXT(#c))

/*****************************************************************************
 *
 *  @doc    INLINE
 *
 *  @method BOOL | IsWriteSam |
 *
 *          Nonzero if the registry security access mask will
 *          obtain (or attempt to obtain) write access.
 *
 *  @parm   REGSAM | regsam |
 *
 *          Registry security access mask.
 *
 *****************************************************************************/

    BOOL IsWriteSam(REGSAM sam)
    {
        return sam & (KEY_SET_VALUE | KEY_CREATE_SUB_KEY | MAXIMUM_ALLOWED);
    }

    #define hresLe(le) MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, (USHORT)(le))

#ifdef DBG
    void joyDbgOut(LPSTR lpszFormat, ...);

    #define JOY_ERR                0x00000001
    #define JOY_WARN               0x00000002
    #define JOY_BABBLE             0x00000004

    #define JOY_DEFAULT_DBGLEVEL   0x00000000
#endif

#ifdef DBG
    extern DWORD g_dwDbgLevel;
    #define JOY_DBGPRINT( _debugMask_, _x_ ) \
        if( (((_debugMask_) & g_dwDbgLevel)) ){ \
            joyDbgOut _x_; \
        }
#else
    #define JOY_DBGPRINT( _debugMask_, _x_ )
#endif

#endif // JOY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\mciparse.c ===
/*******************************Module*Header*********************************\
* Module Name: mciparse.c
*
* Media Control Architecture Command Parser
*
* Created: 3/2/90
* Author:  DLL (DavidLe)
*
* History:
* 5/22/91: Ported to Win32 - NigelT
* 4 Mar 1992: SteveDav - much work for NT.  Bring up to Win 3.1 level
*
* Copyright (c) 1991-1998 Microsoft Corporation
*
\******************************************************************************/

//****************************************************************************
//
// This has to be defined in order to pick up the
// correct version of MAKEINTRESOURCE
//
//****************************************************************************
#define UNICODE

/*****************************************************************************
 * Notes:                                                                    *
 *                                                                           *
 *  MCI command tables are (normally) loaded from resource type files.  The  *
 *  format of a command table is shown below.  Note that because the table   *
 *  contains string data, the binary values are UNALIGNED.  This causes      *
 *  specific problems on MIPS machines.                                      *
 *                                                                           *
 *  Because of compatibility with Windows 3.1 the binary data is WORD size   *
 *                                                                           *
 * Table format:                                                             *
 *                                                                           *
 * verb\0   MCI_MESSAGE,0   MCI_command_type                                 *
 *                                                                           *
 * e.g.                                                                      *
 * 'o' 'p' 'e' 'n' 03 08 00 00 00 'n' 'o' 't' 'i' 'f' 'y' 00                 *
 * 01  00  00  00  00 05 00                                                  *
 *                                                                           *
 * which is "open" MCI_OPEN,0,   MCI_COMMAND_HEAD                            *
 *        "notify" MCI_NOTIFY,0  MCI_FLAG                                    *
 *                                                                           *
 * beware of the byte ordering!                                              *
 *                                                                           *
 ****************************************************************************/


#include "winmmi.h"
#include "mci.h"
#include "wchar.h"
#include <digitalv.h>

#define _INC_WOW_CONVERSIONS
#include "mmwow32.h"

extern WSZCODE wszOpen[];       // in MCI.C

STATICFN UINT mciRegisterCommandTable( HANDLE hResource, PUINT lpwIndex,
                              UINT wType, HANDLE hModule);
STATICFN UINT mciParseArgument ( UINT uMessage, DWORD dwValue, UINT wID,
    LPWSTR FAR *lplpstrOutput, LPDWORD lpdwFlags, LPWSTR lpArgument,
    LPWSTR lpCurrentCommandItem);

//
//  Define the init code for this file. This is commented out in debug builds
//  so that codeview doesn't get confused.


#if DBG
extern int mciDebugLevel;
#endif

// Number of command tables registered, including "holes"
STATICDT UINT number_of_command_tables = 0;

// Command table list
COMMAND_TABLE_TYPE command_tables[MAX_COMMAND_TABLES];

STATICDT WSZCODE wszTypeTableExtension[] = L".mci";
STATICDT WSZCODE wszCoreTable[]          = L"core";

// Core table is loaded when the first MCI command table is requested
STATICDT BOOL bCoreTableLoaded = FALSE;

// One element for each device type.  Value is the table type to use
// or 0 if there is no device type specific table.
STATICDT UINT table_types[] =
{
    MCI_DEVTYPE_VCR,                // vcr
    MCI_DEVTYPE_VIDEODISC,          // videodisc
    MCI_DEVTYPE_OVERLAY,            // overlay
    MCI_DEVTYPE_CD_AUDIO,           // cdaudio
    MCI_DEVTYPE_DAT,                // dat
    MCI_DEVTYPE_SCANNER,            // scanner
    MCI_DEVTYPE_ANIMATION,          // animation
    MCI_DEVTYPE_DIGITAL_VIDEO,      // digitalvideo
    MCI_DEVTYPE_OTHER,              // other
    MCI_DEVTYPE_WAVEFORM_AUDIO,     // waveaudio
    MCI_DEVTYPE_SEQUENCER           // sequencer
};

/*
 * @doc INTERNAL MCI
 * @func UINT | mciEatCommandEntry | Read a command resource entry and
 * return its length and its value and identifier
 *
 * @parm LPWCSTR | lpEntry | The start of the command resource entry
 *
 * @parm LPDWORD | lpValue | The value of the entry, returned to caller
 * May be NULL
 *
 * @parm PUINT | lpID | The identifier of the entry, returned to caller
 * May be NULL
 *
 * @rdesc The total number of bytes in the entry
 *
 */
UINT mciEatCommandEntry (
    LPCWSTR  lpEntry,
    LPDWORD lpValue,
    PUINT   lpID)
{
    LPCWSTR lpScan = lpEntry;
    LPBYTE  lpByte;

#if DBG
    DWORD   Value;
    UINT    Id;
#endif

// NOTE:  The data will generally be UNALIGNED

    /* Skip to end */
    while (*lpScan++ != '\0'){}

    /* lpScan now points at the byte beyond the terminating zero */
    lpByte = (LPBYTE)lpScan;


    if (lpValue != NULL) {
        *lpValue = *(UNALIGNED DWORD *)lpScan;
    }

#if DBG
    Value = *(UNALIGNED DWORD *)lpScan;
#endif

    lpByte += sizeof(DWORD);

    if (lpID != NULL) {
        *lpID = *(UNALIGNED WORD *)lpByte;
    }

#if DBG
    Id = *(UNALIGNED WORD *)lpByte;
#endif

    lpByte += sizeof(WORD);
//
// WARNING !! This assumes that the table being looked at has WORD
// size entries in the RCDATA resource
//

#if DBG
    dprintf5(("mciEatCommandEntry(%ls)  Value: %x   Id: %x", lpEntry, Value, Id));
#endif

    return (UINT)(lpByte - (LPBYTE)lpEntry);  // Total size of entry in bytes
}

//
// Return the size used by this token in the parameter list
//

UINT mciGetParamSize (
    DWORD dwValue,
    UINT wID)
{
    // MCI_RETURN returns 8 for sizeof(STRING) as there is a length
    // field as well as the string pointer.  For non MCI_RETURN uses
    // of MCI_STRING we should return 4 (== sizeof pointer)
    // Similarly, MCI_CONSTANT used within MCI_RETURN is size 0, but
    // size 4 when used as an input parameter.

    if (wID == MCI_RETURN) {
        if (dwValue==MCI_STRING) {
            return(8);
        } else if (dwValue==MCI_CONSTANT) {
            wID = 0;
        } else {
            wID=dwValue;
        }
    }

    switch (wID)
    {
        case MCI_CONSTANT:
        case MCI_INTEGER:
        case MCI_STRING:
        case MCI_HWND:
        case MCI_HPAL:
        case MCI_HDC:
            return sizeof(DWORD_PTR);  // In Win64, sizeof pointer is 8

        case MCI_RECT:
            return sizeof(RECT);

    }
    // Note that some items will not be found - deliberately.  For example
    // MCI_FLAG causes 0 to be returned.
    return 0;
}

/*
 * @doc INTERNAL MCI
 * @func UINT | mciRegisterCommandTable | This function adds a new
 * table for the MCI parser.
 *
 * @parm HANDLE | hResource | Handle to the RCDATA resource
 *
 * @parm PUINT | lpwIndex | Pointer to command table index
 *
 * @parm UINT   | wType | Specifies the device type for this command table.
 * Driver tables and the core table are type 0.
 *
 * @rdesc Returns the command table index number that was assigned or MCI_ERROR_VALUE
 * on error.
 *
 */
STATICFN UINT mciRegisterCommandTable (
    HANDLE hResource,
    PUINT lpwIndex,
    UINT wType,
    HANDLE hModule)
{
    UINT uID;


    /* First check for free slots */

    mciEnter("mciRegisterCommandTable");

    for (uID = 0; uID < number_of_command_tables; ++uID) {
        if (command_tables[uID].hResource == NULL) {
            break;
        }
    }

    /* If no empty slots then allocate another one */
    if (uID >= number_of_command_tables)
    {
        if (number_of_command_tables == MAX_COMMAND_TABLES)
        {
            dprintf1(("mciRegisterCommandTable: No more tables"));
            mciFree(lpwIndex);  // Cannot use it - must free it
            mciLeave("mciRegisterCommandTable");
            return (UINT)MCI_ERROR_VALUE;

        } else {

           uID = number_of_command_tables++;
           // The table goes at the end of the list
        }
    }

    /* Fill in the slot */
    command_tables[uID].wType = wType;
    command_tables[uID].hResource = hResource;
    command_tables[uID].lpwIndex = lpwIndex;
    command_tables[uID].hModule = hModule;
#if DBG
    command_tables[uID].wLockCount = 0;
#endif

    // now that hResource has been filled in marking the entry as used
    // we can allow others access.
    mciLeave("mciRegisterCommandTable");

#if DBG
    if (mciDebugLevel > 2)
    {
        dprintf2(("mciRegisterCommandTable INFO: assigned slot %d", uID));
        dprintf2(("mciRegisterCommandTable INFO: #tables is %d", number_of_command_tables));
    }
#endif
    return uID;
}

/*
 * @doc DDK MCI
 * @api UINT | mciLoadCommandResource | Registers the indicated
 * resource as an MCI command table and builds a command table
 * index.  If a file with the resource name and the extension '.mci' is
 * found in the path then the resource is taken from that file.
 *
 * @parm HANDLE | hInstance | The instance of the module whose executable
 * file contains the resource.  This parameter is ignored if an external file
 * is found.
 *
 * @parm LPCWSTR | lpResName | The name of the resource
 *
 * @parm UINT | wType | The table type.  Custom device specific tables MUST
 * give a table type of 0.
 *
 * @rdesc Returns the command table index number that was assigned or MCI_ERROR_VALUE
 * on error.
 *
 */
UINT  mciLoadCommandResource (
    HANDLE hInstance,
    LPCWSTR lpResName,
    UINT wType)
{
    BOOL        fResType = !HIWORD(lpResName);
    PUINT       lpwIndex, lpwScan;
    HANDLE      hExternal = NULL;
    HANDLE      hResource;
    HANDLE      hResInfo;
    LPWSTR      lpResource, lpScan;
    int         nCommands = 0;
    UINT        wLen;
    UINT        wID;
                        // Name + '.' + Extension + '\0'
    WCHAR       strFile[8 + 1 + 3 + 1];
    LPWSTR      lpstrFile = strFile;
    LPCWSTR     lpstrType = lpResName;

#if DBG
    if (!fResType) {
        dprintf3(("mciLoadCommandResource INFO:  Resource name >%ls< ", (LPWSTR)lpResName));
    } else if (LOWORD(lpResName)) {
        dprintf3(("mciLoadCommandResource INFO:  Resource ID >%d<", (UINT)LOWORD(lpResName)));
    } else {
        dprintf3(("mciLoadCommandResource INFO:  NULL resource pointer"));
    }
#endif

    // Initialize the device list
    if (!MCI_bDeviceListInitialized && !mciInitDeviceList()) {
        return (UINT)MCI_ERROR_VALUE;   // MCIERR_OUT_OF_MEMORY;
    }

    // Load the core table if its not already there
    if (!bCoreTableLoaded)

    {
        bCoreTableLoaded = TRUE;
        // Now we can call ourselves recursively to first load the core
        // table.  Check if this is a request to load CORE - if yes,
        // simply drop through.

        // If its not our core table being loaded...
        // which is decided by comparing the string with CORE, or if a
        // resource id has been given, the resource id is ID_CORE and comes
        // from our module

        // The test is structured this way so that lstrcmpiW is only called
        // if we have a valid pointer.

#define fNotCoreTable ( fResType  \
                         ? ((hInstance != ghInst) || (ID_CORE_TABLE != (UINT)(UINT_PTR)lpResName)) \
                         : (0 != lstrcmpiW (wszCoreTable, (LPWSTR)lpResName)))

        if (fNotCoreTable) {

            // We are not being asked to load the core table.  So we
            // explicitly load the core table first
            if (mciLoadCommandResource (ghInst, MAKEINTRESOURCE(ID_CORE_TABLE), 0) == MCI_ERROR_VALUE)
            {
                dprintf1(("mciLoadCommandResource:  Cannot load core table"));
            }
        }
    }

    // Unless this is a resource ID, go and look for a file
    if (!fResType) {

        WCHAR ExpandedName[MAX_PATH];
        LPWSTR FilePart;

        // Check for a file with the extension ".mci"
        // Copy up to the first eight characters of device type
        // !!LATER!!  Try a check for a resource first, then a file
        while (lpstrType < lpResName + 8 && *lpstrType != '\0') {
            *lpstrFile++ = *lpstrType++;
        }

        // Tack extension onto end
        wcscpy (lpstrFile, wszTypeTableExtension);

        // If the file exists and can be loaded then set flag to use it.
        // (Otherwise we will try and load the resource from WINMM.DLL.)

        if (!SearchPathW(NULL, strFile, NULL, MAX_PATH, ExpandedName,
                        &FilePart)) {
            hExternal = NULL;
        } else {
            UINT OldErrorMode;

            OldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

            // Use "ExpandedName" to prevent a second search taking place
            hExternal = LoadLibraryExW( ExpandedName, //strFile,
                                        NULL,
                                        DONT_RESOLVE_DLL_REFERENCES);
            SetErrorMode(OldErrorMode);
        }
    }

    // Load the given table from the file or from the module if not found
    if (hExternal != NULL &&
        (hResInfo = FindResourceW(hExternal, lpResName, RT_RCDATA )) != NULL)
    {
        hInstance = hExternal;
    } else {
        hResInfo = FindResourceW(hInstance, lpResName, RT_RCDATA );
    }

    if (hResInfo == NULL)
    {
#if DBG
        if (!fResType) {
            dprintf3(("mciLoadCommandResource Cannot find command resource name >%ls< ", (LPWSTR)lpResName));
        } else {
            dprintf3(("mciLoadCommandResource Cannot find command resource ID >%d<", (UINT)LOWORD(lpResName)));
        }
#endif
        if (NULL != hExternal) {
            FreeLibrary(hExternal);  // Clean up after ourselves
        }
        return (UINT)MCI_ERROR_VALUE;
    }

    if ((hResource = LoadResource (hInstance, hResInfo)) == NULL)
    {
#if DBG
        if (!fResType) {
            dprintf3(("mciLoadCommandResource Cannot load command resource name >%ls< ", (LPWSTR)lpResName));
        } else {
            dprintf3(("mciLoadCommandResource Cannot load command resource ID >%d<", (UINT)LOWORD(lpResName)));
        }
#endif
        if (NULL != hExternal) {
            FreeLibrary(hExternal);  // Clean up after ourselves
        }
        return (UINT)MCI_ERROR_VALUE;
    }

    if ((lpResource = LockResource (hResource)) == NULL)
    {
        dprintf1(("mciLoadCommandResource:  Cannot lock resource"));
        FreeResource (hResource);
        if (NULL != hExternal) {
            FreeLibrary(hExternal);  // Clean up after ourselves
        }
        return (UINT)MCI_ERROR_VALUE;
    }

    /* Count the number of commands  */
    lpScan = lpResource;

    while (TRUE)
    {
        (LPBYTE)lpScan = (LPBYTE)lpScan + mciEatCommandEntry(lpScan, NULL, &wID);

        // End of command?
        if (wID == MCI_COMMAND_HEAD)
            ++nCommands;

        // End of command list?
        else if (wID == MCI_END_COMMAND_LIST)
            break;
    }


    // There must be at least one command in the table
    if (nCommands == 0)
    {
        dprintf1(("mciLoadCommandResource:  No commands in the specified table"));
        UnlockResource (hResource);
        FreeResource (hResource);
        if (NULL != hExternal) {
            FreeLibrary(hExternal);  // Clean up after ourselves
        }
        return (UINT)MCI_ERROR_VALUE;
    } else {
        dprintf3(("mciLoadCommandResource:  %d commands in the specified table", nCommands));
    }

    // Allocate storage for the command table index
    // Leave room for a MCI_TABLE_NOT_PRESENT entry to terminate it
    if ((lpwIndex = mciAlloc (sizeof (*lpwIndex) * (nCommands + 1)))
                        == NULL)
    {
        dprintf1(("mciLoadCommandResource:  cannot allocate command table index"));
        UnlockResource (hResource);
        FreeResource (hResource);
        if (NULL != hExternal) {
            FreeLibrary(hExternal);  // Clean up after ourselves
        }
        return (UINT)MCI_ERROR_VALUE;
    }

    /* Build Command Table */
    lpwScan = lpwIndex;
    lpScan = lpResource;

    while (TRUE)
    {
    // Get next command entry
        wLen = mciEatCommandEntry (lpScan, NULL, &wID);

        if (wID == MCI_COMMAND_HEAD)
        {
            // Add an offset index to this command from start of resource
            *lpwScan++ = (UINT)((LPBYTE)lpScan - (LPBYTE)lpResource);
        }
        else if (wID == MCI_END_COMMAND_LIST)
        {
            // Mark the end of the table
            *lpwScan = (UINT)MCI_TABLE_NOT_PRESENT;
            break;
        }
        (LPBYTE)lpScan = (LPBYTE)lpScan + wLen;
    }

    UnlockResource (hResource);
    return mciRegisterCommandTable (hResource, lpwIndex, wType, hExternal);
}

/*
 * @doc INTERNAL MCI
 * @func UINT | mciLoadTableType | If the table of the given type
 * has not been loaded, register it
 *
 * @parm UINT | wType | The table type to load
 *
 * @rdesc Returns the command table index number that was assigned or MCI_ERROR_VALUE
 * on error.
 */
UINT mciLoadTableType (
    UINT wType)
{
    UINT wID;
#ifdef OLD
    WCHAR buf[MCI_MAX_DEVICE_TYPE_LENGTH];
#endif

    // Check to see if this table type is already loaded
    for (wID = 0; wID < number_of_command_tables; ++wID) {
        if (command_tables[wID].wType == wType) {
            return wID;
        }
    }

    // Must load table
    // First look up what device type specific table to load for this type
    if (wType < MCI_DEVTYPE_FIRST || wType > MCI_DEVTYPE_LAST) {
        return (UINT)MCI_ERROR_VALUE;
    }

    // Load string that corresponds to table type
#ifdef OLD

#ifdef WIN31CODE
    // Load string that corresponds to table type
    buf[0] = 0;    // In case load string fails to set anything

    LoadString (ghInst, table_types[wType - MCI_DEVTYPE_FIRST],
                buf, sizeof(buf));
    {

    //Must be at least one character in type name
    int nTypeLen;
    if ((nTypeLen = wcslen (buf)) < 1)
        return MCI_ERROR_VALUE;
    }
#else
    // Load string that corresponds to table type
    buf[0] = 0;    // In case load string fails to set anything

    if (!LoadString (ghInst, table_types[wType - MCI_DEVTYPE_FIRST],
                buf, sizeof(buf))) {
        //Must put at least one character into type name
        return MCI_ERROR_VALUE;
   }
#endif    // WIN31CODE

    // Register the table with MCI
    return mciLoadCommandResource (ghInst, buf, wType);

#else // not old
    // Command tables are stored as RCDATA blocks with an id of the device type
    // If mciLoadCommandResource fails to find the command table then it
    // will return MCI_ERROR_VALUE

    //if (!FindResource(ghInst, wType, RT_RCDATA))
//        return MCI_ERROR_VALUE;
//
    // Register the table with MCI
    return mciLoadCommandResource (ghInst, MAKEINTRESOURCE(wType), wType);
#endif
}


/*
 * @doc DDK MCI
 *
 * @api BOOL | mciFreeCommandResource | Frees the memory used
 * by the specified command table.
 *
 * @parm UINT | wTable | The table index returned from a previous call to
 * mciLoadCommandResource.
 *
 * @rdesc FALSE if the table index is not valid, TRUE otherwise.
 *
 */
BOOL APIENTRY mciFreeCommandResource (
    UINT wTable)
{
    MCIDEVICEID wID;
    HANDLE  hResource;
    PUINT   lpwIndex;

    dprintf3(("mciFreeCommandResource INFO:  Free table %d", wTable));
    dprintf3(("mciFreeCommandResource INFO:  Lockcount is %d", command_tables[wTable].wLockCount));

/* Validate input -- do not let the core table be free'd */
    if (wTable == MCI_TABLE_NOT_PRESENT || wTable >= number_of_command_tables)
    {

#if DBG
        // wTable == MCI_TABLE_NOT_PRESENT is OK
        if (wTable != MCI_TABLE_NOT_PRESENT) {
            dprintf1(("mciFreeCommandResource: Cannot free table number %d", wTable));
        }
#endif
        return FALSE;
    }

    mciEnter("mciFreeCommandResource");

    // If this table is being used elsewhere then keep it around
    for (wID = 1; wID < MCI_wNextDeviceID; ++wID)
    {
        if (MCI_lpDeviceList[wID] != NULL)
        {
            if (MCI_lpDeviceList[wID]->wCustomCommandTable == wTable ||
                MCI_lpDeviceList[wID]->wCommandTable == wTable)
            {
#if DBG
                if (mciDebugLevel > 2) {
                    dprintf1(("mciFreeCommandResource INFO:  table in use"));
                }
#endif
                mciLeave("mciFreeCommandResource");
                return FALSE;
            }
        }
    }

#if 0
/* Search the list of tables */
    for (wID = 0; wID < number_of_command_tables; ++wID)

/* If this resource is still in use, keep it around */
        if (command_tables[wID].hResource == hResource)
        {
#if DBG
            if (mciDebugLevel > 2)
                DOUT(("mciFreeCommandResource INFO:  resource in use\r\n"));
#endif
            mciLeave("mciFreeCommandResource");
            return FALSE;
        }
#endif

    hResource = command_tables[wTable].hResource;
    command_tables[wTable].hResource = NULL;
    // This slot can now be picked up by someone else

    lpwIndex = command_tables[wTable].lpwIndex;
    command_tables[wTable].lpwIndex = NULL;
    command_tables[wTable].wType = 0;

    FreeResource (hResource);
    mciFree (lpwIndex);
    hResource = command_tables[wTable].hModule;
    mciLeave("mciFreeCommandResource");

    if (hResource != NULL)
    {
        FreeLibrary (hResource);
    }

    // Make space at top of list
    if (wTable == number_of_command_tables - 1)
    {
        --number_of_command_tables;
    }

    dprintf3(("mciFreeCommandResource INFO:  number_of_command_tables: %d", number_of_command_tables));

    return TRUE;
}

#if DBG
void mciCheckLocks ()
{
    UINT wTable;

    if (mciDebugLevel <= 2) {
        return;
    }

    for (wTable = 0; wTable < number_of_command_tables; ++wTable)
    {
        if (command_tables[wTable].hResource == NULL) {
            continue;
        }

        dprintf2(("mciCheckLocks INFO: table %d   Lock count %d", wTable, command_tables[wTable].wLockCount));

    //  dprintf2(("user: %x ", GlobalFlags (command_tables[wTable].hResource) & GMEM_LOCKCOUNT));
    //
    //  if (GlobalFlags (command_tables[wTable].hResource) & GMEM_DISCARDABLE) {
    //      dprintf(("discardable"));
    //  } else {
    //      dprintf(("NOT discardable"));
    //  }
    }
}
#endif

/*
 * @doc INTERNAL MCI
 * @func BOOL | mciUnlockCommandTable | Unlocks the command table given by
 * a table index
 *
 * @parm UINT | wCommandTable | Table to unlock
 *
 * @rdesc TRUE if success, FALSE otherwise
 *
 * @comm Used external to this module by mci.c
 *
 */
BOOL mciUnlockCommandTable (
    UINT wCommandTable)
{
    UnlockResource(command_tables[wCommandTable].hResource);
#if DBG
    --command_tables[wCommandTable].wLockCount;
    if (mciDebugLevel > 2)
    {
        dprintf2(("mciUnlockCommandTable INFO:  table %d", wCommandTable));
        mciCheckLocks();
    }
#endif
    return TRUE;
}

/*
 * @doc INTERNAL MCI
 * @func LPWSTR | FindCommandInTable | Look up the given
 * command string in the GIVEN parser command table
 *
 * @parm UINT  | wTable | Command table to use
 *
 * @parm LPCWSTR | lpstrCommand | The command to look up.  It must
 * be in lower case with no leading or trailing blanks and with at
 * least one character.
 *
 * @parm PUINT | lpwMessage | The message corresponding to the command
 * Returned to caller.
 *
 * @rdesc NULL if the command is unknown or on error, otherwise a pointer to
 * the command list ffr the input command string.
 *
 * @comm If the command is found, the command resource will be locked on exit.
 *
 */
LPWSTR FindCommandInTable (
    UINT wTable,
    LPCWSTR lpstrCommand,
    PUINT lpwMessage)
{
    PUINT lpwIndex;
    LPWSTR lpResource, lpstrThisCommand;
    UINT  wMessage;

#if DBG
    if (HIWORD(lpstrCommand)) {
        dprintf3(("FindCommandInTable(%04XH, %ls)", wTable, lpstrCommand));
    } else {
        dprintf3(("FindCommandInTable(%04XH, id = %x)", wTable, (UINT)LOWORD(lpstrCommand)));
    }
#endif

    //
    /* Validate table */
    //

    mciEnter("FindCommandInTable");

    if (wTable >= number_of_command_tables)
    {

        //
        // Check the core table but its not yet loaded
        //

        if (wTable == 0)
        {

            //
            // Try to load it
            //

//            if (mciLoadCommandResource (ghInst, wszCoreTable, 0) == MCI_ERROR_VALUE)
            if (mciLoadCommandResource (ghInst, (LPCWSTR)ID_CORE_TABLE, 0) == MCI_ERROR_VALUE)
            {
                mciLeave("FindCommandInTable");
                dprintf1(("FindCommandInTable:  cannot load core table"));
                return NULL;
            }
        }
        else
        {
            mciLeave("FindCommandInTable");
            dprintf1(("FindCommandInTable:  invalid table ID: %04XH", wTable));
            return NULL;
        }

    }

    if ((lpResource = LockResource (command_tables[wTable].hResource)) == NULL)
    {
        mciLeave("FindCommandInTable");
        dprintf1(("MCI FindCommandInTable:  Cannot lock table resource"));
        return NULL;
    }
#if DBG
    ++command_tables[wTable].wLockCount;
#endif

    //
    // Look at each command in the table
    // We use the index table rather than the return value from
    // mciEatCommandEntry to step through the table
    //

    lpwIndex = command_tables[wTable].lpwIndex;
    if (lpwIndex == NULL)
    {
        mciLeave("FindCommandInTable");
        dprintf1(("MCI FindCommandInTable:  null command table index"));
        return NULL;
    }

    while (*lpwIndex != MCI_TABLE_NOT_PRESENT)
    {
        lpstrThisCommand = (LPWSTR)(*lpwIndex++ + (LPBYTE)lpResource);

        //
        // Get message number from the table
        //

        mciEatCommandEntry ((LPCWSTR)lpstrThisCommand, (LPDWORD)&wMessage, NULL);

        //
        // Does this command match the input?
        // IF we have a string pointer, check the command name matches,
        // OR for a message, check the message values match
        //

        if  (HIWORD  (lpstrCommand) != 0 &&
             lstrcmpiW(lpstrThisCommand, lpstrCommand) == 0  ||

             HIWORD (lpstrCommand) == 0 &&
             wMessage == (UINT)LOWORD(PtrToUlong(lpstrCommand)))
        {

            //
            // Retain the locked resource pointer
            //

            command_tables[wTable].lpResource = lpResource;


            //
            // Address the message ID which comes after the command name
            //

            if (lpwMessage != NULL) *lpwMessage = wMessage;

            //
            // Leave table locked on exit
            //

            mciLeave("FindCommandInTable");
            dprintf3(("mciFindCommandInTable: found >%ls<  Message %x", lpstrThisCommand, wMessage));
            return lpstrThisCommand;
        }

        //
        // Strings don't match, go to the next command in the table
        //

    }

    UnlockResource (command_tables[wTable].hResource);
#if DBG
    --command_tables[wTable].wLockCount;
#endif

    mciLeave("FindCommandInTable");
    dprintf3(("  ...not found"));
    return NULL;
}

/*
 * @doc INTERNAL MCI
 * @func LPWSTR | FindCommandItem | Look up the given
 * command string in the parser command tables
 *
 * @parm MCIDEVICEID | wDeviceID | The device ID used for this command.
 * If 0 then only the system core command table is searched.
 *
 * @parm LPCWSTR | lpstrType | The type name of the device
 *
 * @parm LPCWSTR | lpstrCommand | The command to look up.  It must
 * be in lower case with no leading or trailing blanks and with at
 * least one character.  If the HIWORD is 0 then the LOWORD contains
 * the command message ID instead of a command name and the function is
 * merely to find the command list pointer.
 *
 * If the high word is 0 then the low word is an command ID value instead
 * of a command name
 *
 * @parm PUINT | lpwMessage | The message corresponding to the command
 * Returned to caller.
 *
 * @parm LPUINT | lpwTable | The table index in which the command was found
 * Returned to caller.
 *
 * @rdesc NULL if the command is unknown, otherwise a pointer to
 * the command list for the input command string.
 */
LPWSTR    FindCommandItem (
    MCIDEVICEID wDeviceID,
    LPCWSTR lpstrType,
    LPCWSTR lpstrCommand,
    PUINT  lpwMessage,
    PUINT  lpwTable)
{
    LPWSTR lpCommand = NULL;
    UINT wTable;
    LPMCI_DEVICE_NODE nodeWorking;
    UINT uDeviceType = 0;

    UNREFERENCED_PARAMETER(lpstrType);

    //
    // Only check hiword per comments above
    //

    if (HIWORD (lpstrCommand) != (WORD)NULL) {
        if (*lpstrCommand == '\0')
        {
            dprintf1(("MCI FindCommandItem:  lpstrCommand is NULL or empty string"));
            return NULL;
        } else {
            dprintf3(("FindCommandItem(%ls)", lpstrCommand));
        }
    } else {
        dprintf3(("FindCommandItem(command id = %x)", (UINT)LOWORD(lpstrCommand)));
    }

    //
    // If a specific device ID was specified then look in any custom table
    // or type table
    //

    if (wDeviceID != 0 && wDeviceID != MCI_ALL_DEVICE_ID)
    {
        //
        // If the device ID is valid
        //

        mciEnter("FindCommandItem");

        if (!MCI_VALID_DEVICE_ID (wDeviceID) ||
            (NULL == (nodeWorking = MCI_lpDeviceList[wDeviceID])))
        {
            dprintf1(("MCI FindCommandItem:  Invalid device ID or pointer"));
            mciLeave("FindCommandItem");
            return NULL;
        }

        uDeviceType = nodeWorking->wDeviceType;
        //
        // If there is a custom command table then use it
        //

        if ((wTable = nodeWorking->wCustomCommandTable) != MCI_TABLE_NOT_PRESENT)
        {
            lpCommand = FindCommandInTable (wTable, lpstrCommand, lpwMessage);
            if (lpCommand != NULL) {
                mciLeave("FindCommandItem");
                goto exit;
            }
        }

        //
        // Get the device type table from the existing device
        // Relies on mciReparseCommand in mciLoadDevice to catch all device type
        // tables when device is not yet open.
        //

        if ((wTable = nodeWorking->wCommandTable) != MCI_TABLE_NOT_PRESENT)
        {
            lpCommand = FindCommandInTable (wTable, lpstrCommand, lpwMessage);
            if (lpCommand != NULL) {
                mciLeave("FindCommandItem");
                goto exit;
            }
        }
        mciLeave("FindCommandItem");
    }

#if 0
    // If no device was specified
    if (uDeviceType == 0 && lpstrType != NULL && *lpstrType != '\0')
    {
    // See if the type is one known
        uDeviceType = mciLookUpType (lpstrType);
        if (uDeviceType == 0)
        {
    // Otherwise see if the type is an element with a known extension
            WCHAR strTemp[MCI_MAX_DEVICE_NAME_LENGTH];
            if (mciExtractDeviceType (lpstrType, strTemp, sizeof(strTemp)))
                uDeviceType = mciLookUpType (strTemp);
        }
    }

/*
    If the command was not found in the custom table look in the type specific
    table
*/
    if (uDeviceType != 0)
    {
        wTable = mciLoadTableType (uDeviceType);
        if (wTable != MCI_TABLE_NOT_PRESENT)
        {
            lpCommand = FindCommandInTable (wTable, lpstrCommand, lpwMessage);
            if (lpCommand != NULL) {
                goto exit;
            }
        }
    }
#endif

    //
    // If no match was found in the device or type specific tables
    // Look in the core table
    //

    wTable = 0;
    lpCommand = FindCommandInTable (wTable, lpstrCommand, lpwMessage);
    if (lpCommand == NULL) {
        wTable = (UINT)MCI_TABLE_NOT_PRESENT;
    }

exit:;
    if (lpwTable != NULL) {
        *lpwTable = wTable;
    }

#if DBG
    if (mciDebugLevel > 2)
    {
        dprintf2(("FindCommandItem INFO:  check locks..."));
        mciCheckLocks();
    }
#endif

#if DBG
    dprintf3(("  found: %ls in table %d", lpCommand ? lpCommand : L"(NULL)", wTable));
#endif
    return lpCommand;
}

/*
 * @doc INTERNAL MCI
 * @func LPWSTR | mciCheckToken | Check to see if the command item matches
 * the given string, allowing multiple blanks in the input parameter to
 * match a corresponding single blank in the command token and ignoring
 * case.
 *
 * @parm LPCWSTR | lpstrToken | The command token to check
 *
 * @parm LPCWSTR | lpstrParam | The input parameter
 *
 * @rdesc NULL if no match, otherwise points to the first character
 * after the parameter
 *
 */
STATICFN LPWSTR      mciCheckToken (
    LPCWSTR lpstrToken,
    LPCWSTR lpstrParam)
{
    /* Check for legal input */
    if (lpstrToken == NULL || lpstrParam == NULL) {
        return NULL;
    }

    while (*lpstrToken != '\0' && MCI_TOLOWER(*lpstrParam) == *lpstrToken)
    {
        // If the token contains a blank, allow more than one blank in the
        // parameter.  If the next character is a blank, skip to the next
        // non-blank.
        if (*lpstrToken == ' ') {
            while (*lpstrParam == ' ') {
                ++lpstrParam;
            }
        } else {
            lpstrParam++;
        }
        lpstrToken++;
    }
    if (*lpstrToken != '\0'|| (*lpstrParam != '\0' && *lpstrParam != ' ')) {
        return NULL;
    } else {
        return (LPWSTR)lpstrParam;
    }
}

/*
 * @doc INTERNAL MCI
 * @func BOOL | mciParseInteger | Parse the given integer
 *
 * @parm LPWSTR FAR * | lplpstrInput | The string containing the argument.
 * It is updated and returned to the caller pointing to the first character
 * after the argument or to the first character that is in error.
 *
 * @parm LPDWORD | lpdwArgument | The place to put the output
 *
 * @rdesc Returns TRUE if not error
 *
 * @comm If there are colons in the input (':') the result is "colonized".
 * This means that each time a colon is read, the current result is written
 * and any subsequent digits are shifted left one byte.  No one "segment"
 * can be more than 0xFF.  For example, "0:1:2:3" is parsed to 0x03020100.
 *
 */
STATICFN BOOL NEAR mciParseInteger (
    LPCWSTR FAR * lplpstrInput,
    LPDWORD lpdwArgument)
{
    LPCWSTR lpstrInput = *lplpstrInput;
    BOOL fDigitFound;
    DWORD dwResult;
    DWORD Shift = 0;
    int   nDigitPosition = 0;
    BOOL  bSigned = FALSE;

    // Leading blanks have been removed by mciParseParams

    if (*lpstrInput == '-')
    {
        ++lpstrInput;
        bSigned = TRUE;
    }

    // Read digits
    *lpdwArgument = 0;                      /* Initialize */
    dwResult = 0;
    fDigitFound = FALSE;                    /* Initialize */
    while (*lpstrInput >= '0' && *lpstrInput <= '9' || *lpstrInput == ':')
    {
        // ':' indicates colonized data
        if (*lpstrInput == ':')
        {
            // Cannot mix colonized and signed forms
            if (bSigned)
            {
                dprintf1(("mciParseInteger: Bad integer: mixing signed and colonized forms"));
                return FALSE;
            }
            // Check for overflow in accumulated colonized byte
            if (dwResult > 0xFF) {
                dprintf1(("mciParseInteger: Overflow in accumulated colonized byte"));
                return FALSE;
            }

            // Copy and move to next byte converted in output
            *lpdwArgument += dwResult << Shift;
            Shift += 8;
            ++lpstrInput;

            // Initialize next colonized byte
            dwResult = 0;
            ++nDigitPosition;

            // Only allow four colonized components
            if (nDigitPosition > 3)
            {
                dprintf1(("mciParseInteger: Bad integer:  Too many colonized components"));
                return FALSE;
            }
        }
        else
        {
            WCHAR cDigit = (WCHAR)(*lpstrInput++ - '0');
            // Satisfies condition that at least one digit must be read
            fDigitFound = TRUE;

            if (dwResult > 0xFFFFFFFF / 10)
            {
                // Overflow if multiply was to occur
                dprintf1(("mciParseInteger: Multiply overflow pending"));
                return FALSE;
            }
            else
            {
                // Multiply for next digit
                dwResult *= 10;
            }

#if 0 // WIN32 Danger Will Robinson horribly bogus technique used here!
            // Check to see if adding the  new digit will overflow
            if (dwResult != 0 && (-(int)dwResult) <= (int)cDigit) {
                // Overflow will occur
                dprintf1(("mciParseInteger: Add overflow pending"));
                return FALSE;
            }
#endif
            // Add new digit
            dwResult += cDigit;
        }
    }
    if (nDigitPosition == 0)
    {
        // No colonized components
        if (bSigned)
        {
            // Check for overflow from negation
            if (dwResult > 0x7FFFFFFF) {
                dprintf1(("mciParseInteger: Negation overflow"));
                return FALSE;
            }

            // Negate result because a '-' sign was parsed
            dwResult = (DWORD)-(int)dwResult;
        }

        *lpdwArgument = dwResult;
    }
    else
    // Store last colonized component
    {
        // Check for overflow
        if (dwResult > 0xFF) {
            dprintf1(("mciParseInteger: Yet another overflow"));
            return FALSE;
        }
        // Store component
        *lpdwArgument += dwResult << Shift;
    }

    *lplpstrInput = lpstrInput;

    /*
    If there were no digits or if the digits were followed by a character
    other than a blank or a '\0', then return a syntax error.
    */
    if (fDigitFound == FALSE ||
        (*lpstrInput != ' ' && *lpstrInput != '\0')) {
        dprintf1(("mciParseInteger: syntax error"));
        return FALSE;
    }
    else {
                dprintf4(("mciParseInteger(%ls, %08XH)", *lplpstrInput, *lpdwArgument));
        return TRUE;
    }
}

/*
 * @doc INTERNAL MCI
 * @func BOOL | mciParseConstant | Parse the given integer
 *
 * @parm LPWSTR FAR * | lplpstrInput | The string containing the argument.
 * It is updated and returned to the caller pointing to the first character
 * after the argument or to the first character that is in error.
 *
 * @parm LPDWORD | lpdwArgument | The place to put the output
 *
 * @parm LPWSTR | lpItem | Pointer into command table.
 *
 * @rdesc Returns TRUE if not error
 *
 */
STATICFN BOOL mciParseConstant (
    LPCWSTR FAR * lplpstrInput,
    LPDWORD lpdwArgument,
    LPWSTR lpItem)
{
    LPWSTR lpPrev;
    DWORD dwValue;
    UINT wID;

    // Skip past constant header
    (LPBYTE)lpItem = (LPBYTE)lpItem +
                     mciEatCommandEntry(lpItem, &dwValue, &wID);

    while (TRUE)
    {
        LPWSTR lpstrAfter;

        lpPrev = lpItem;

        (LPBYTE)lpItem = (LPBYTE)lpItem +
                        mciEatCommandEntry (lpItem, &dwValue, &wID);

        if (wID == MCI_END_CONSTANT) {
            break;
        }

        if ((lpstrAfter = mciCheckToken (lpPrev, *lplpstrInput)) != NULL)
        {
            *lpdwArgument = dwValue;
            *lplpstrInput = lpstrAfter;
            return TRUE;
        }

    }

    return mciParseInteger (lplpstrInput, lpdwArgument);
}

/*
 * @doc INTERNAL MCI
 * @func UINT | mciParseArgument | Parse the given argument
 *
 * @parm DWORD | dwValue | The argument value
 *
 * @parm UINT | wID | The argument ID
 *
 * @parm LPWSTR FAR * | lplpstrOutput | The string containing the argument.
 * It is updated and returned to the caller pointing to the first character
 * after the argument or to the first character that is in error.
 *
 * @parm LPDWORD | lpdwFlags | The output flags
 *
 * @parm LPDWORD | lpArgument | The place to put the output
 *
 * @rdesc Returns 0 if no error or
 * @flag MCIERR_BAD_INTEGER | An integer argument could not be parsed
 * @flag MCIERR_MISSING_STRING_ARGUMENT | An expected string argument
 * @flag MCIERR_PARM_OVERFLOW | The output buffer was a NULL pointer
 * was missing
 *
 */
STATICFN UINT mciParseArgument (
    UINT uMessage,
    DWORD dwValue,
    UINT wID,
    LPWSTR FAR * lplpstrOutput,
    LPDWORD lpdwFlags,
    LPWSTR lpArgument,
    LPWSTR lpCurrentCommandItem)
{
    LPCWSTR lpstrInput =  *lplpstrOutput;
    UINT    wRetval = 0;
    int     dummy;

/* Switch on the argument type */
    dprintf2(("mciParseArgument: msg=%04x, value=%08x, argument=%ls",
	       uMessage, dwValue, lpArgument));
    switch (wID)
    {
        // The parameter is a flag
        case MCI_FLAG:
            break;

        case MCI_CONSTANT:
            if (*lpstrInput == '\0') {
                wRetval = MCIERR_NO_INTEGER;
            }
            else if (!mciParseConstant (&lpstrInput, (LPDWORD)lpArgument,
                     lpCurrentCommandItem)) {
                wRetval = MCIERR_BAD_CONSTANT;
            }

            //  This entire else clause is only for WOW which doesn't exist
            //  on Win64
#ifndef _WIN64
            else if ( WinmmRunningInWOW ) {

                //
                // Horrible hack:  The command table does not contain
                // enough information to perform the thunk correctly,
                // hence this special case.
                //
                if ( uMessage == MCI_WINDOW
                  && dwValue  == MCI_OVLY_WINDOW_HWND
                  && !IsWindow( (HWND)*(LPDWORD)lpArgument ) ) {

                    *(HWND *)lpArgument = HWND32(LOWORD(*(LPDWORD)lpArgument));
                }

		// If the message is MCI_SETVIDEO and we have
		// MCI_DGV_SETVIDEO_VALUE it is possible that we have to
		// convert the constant number to a palette handle, but ONLY
		// if the ITEM field is "palette handle".  We may not know
		// that now as the string may be of the form:
		//      setvideo alias to NNN palette handle
		// OR	setvideo alias to NNN stream
		// Hence any hacking for WOW has to be done when the
		// parsing has been completed.
            }
#endif // !WIN64
            break;


	/* Deal with the integer specific cases */
	case MCI_HDC:
        case MCI_HPAL:
        case MCI_INTEGER:
        case MCI_HWND:
            if (!mciParseInteger (&lpstrInput, (LPDWORD)lpArgument)) {
                wRetval = MCIERR_BAD_INTEGER;
            }

#ifndef _WIN64
            else if ( WinmmRunningInWOW ) {

		switch (wID) {
		    case MCI_HPAL:
			/* The parameter has an HPAL argument, try to parse it */

                        //
                        // If this specified hpal is not valid, mangle the hpal
                        // so that it appears to originate from WOW.  I use GetObject
                        // to test the validity of the specified hpal.
                        //
#ifdef  _WIN64
                        GetObject( (HPALETTE)*(PDWORD_PTR)lpArgument,sizeof(int), &dummy );
#else   //  !WIN64
                        if ( !GetObject( (HPALETTE)*(PDWORD_PTR)lpArgument,
                                         sizeof(int), &dummy ) ) {

                            *(HPALETTE *)lpArgument =
                                HPALETTE32(LOWORD(*(LPDWORD)lpArgument));
                        }
#endif  //  !WIN64

			break;

		    case MCI_HWND:
			/* The parameter has an HWND argument, try to parse it */

                        //
                        // If this specified hwnd is not valid, mangle the hwnd
                        // so that it appears to originate from WOW.
                        //
                        if ( !IsWindow( (HWND)*(LPDWORD)lpArgument ) ) {

                            *(HWND *)lpArgument = HWND32(LOWORD(*(LPDWORD)lpArgument));
                        }
			break;

		    case MCI_HDC:
                        //
                        // If this specified hdc is not valid, mangle the hdc
                        // so that it appears to originate from WOW.  I use GetBkMode
                        // to test the validity of the specified hdc.
                        //
                        if ( !GetBkMode( (HDC)*(LPDWORD)lpArgument ) ) {

                            *(HDC *)lpArgument = HDC32(LOWORD(*(LPDWORD)lpArgument));
                        }
			break;

		    case MCI_INTEGER:
		    default: ;

		}
            }
#endif  //  !WIN64

            break; /* switch */

        case MCI_RECT:
        {
            // Read in four integer parameters.  Resulting structure is the
            // same as a Windows RECT
            LONG lTemp;
            int n;
            for (n = 0; n < 4; ++n)
            {
                if (!mciParseInteger (&lpstrInput, (LPDWORD)&lTemp))
                {
                    wRetval = MCIERR_BAD_INTEGER;
                    break;
                }

                // Each component is a signed 16 bit number
                if (lTemp > 32768 || lTemp < -32767)
                {
                    wRetval = MCIERR_BAD_INTEGER;
                    break;
                }

                ((int FAR *)lpArgument)[n] = (int)lTemp;

                // Remove leading blanks before next digit
                while (*lpstrInput == ' ') ++lpstrInput;
            }
            break;
        }

        case MCI_STRING:
        {
            LPWSTR lpstrOutput;

            /* The parameter has an string argument, read it */

            // Leading blanks have been removed by mciParseParams

            /* Are there any non-blank characters left in the input? */
            if (*lpstrInput == '\0')
            {
                /* Return an error */
                wRetval = MCIERR_MISSING_STRING_ARGUMENT;
                break; /* switch */
            }

            if ((wRetval = mciEatToken (&lpstrInput, ' ', &lpstrOutput, FALSE))
                != 0)
            {
                dprintf1(("mciParseArgument:  error parsing string"));
                return wRetval;
            }

            *(PDWORD_PTR)lpArgument = (DWORD_PTR)lpstrOutput;

            // NOTE:  mciSendString frees the output string after command execution
            // by calling mciParserFree
            break; /* switch */

        } /* case */
    } /* switch */

/* Update the output flags if there was no error */
    if (wRetval == 0)
    {
        if (*lpdwFlags & dwValue)
        {
            if (wID == MCI_CONSTANT)
                wRetval = MCIERR_FLAGS_NOT_COMPATIBLE;
            else
                wRetval = MCIERR_DUPLICATE_FLAGS;
        } else
            *lpdwFlags |= dwValue;
    }
    /*
       Return the input pointer pointing at the first character after
       the argument or to the first character that is in error
    */
    *lplpstrOutput = (LPWSTR)lpstrInput;
    return wRetval;
}

/*
 * @doc MCI INTERNAL
 * @func UINT | mciParseParams | Parse the command parameters
 *
 * @parm LPCWSTR | lpstrParams | The parameter string
 *
 * @parm LPCWSTR | lpCommandList | The command table description
 * of the command tokens
 *
 * @parm LPDWORD | lpdwFlags | Return the parsed flags here
 *
 * @parm LPDWORD | lpdwOutputParams | Return the list of parameters here
 *
 * @parm DWORD | dwParamsSize | The size allocated for the parameter list
 *
 * @parm LPWSTR FAR * FAR * | lpPointerList | A NULL terminated list of
 * pointers allocated by this function that should be free'd when
 * no longer needed.   The list itself should be free'd also.  In both
 * cases, use mciFree().
 *
 * @parm PUINT | lpwParsingError | If not NULL then if the command is
 * 'open', unrecognized keywords return an error here, and the
 * function return value is 0 (unless other errors occur).  This
 * is used to allow reparsing of the command by mciLoadDevice
 *
 * @rdesc Returns zero if successful or one of the following error codes:
 * @flag MCIERR_PARM_OVERFLOW | Not enough space for parameters
 * @flag MCIERR_UNRECOGNIZED_KEYWORD | Unrecognized keyword
 *
 * @comm Any syntax error, including missing arguments, will result in
 * a non-zero error return and invalid output data.
 *
 */
UINT mciParseParams (
   UINT    uMessage,
   LPCWSTR lpstrParams,
   LPCWSTR lpCommandList,
   LPDWORD lpdwFlags,
   LPWSTR lpOutputParams,
   UINT wParamsSize,
   LPWSTR FAR * FAR *lpPointerList,
   PUINT  lpwParsingError)
{
    LPWSTR lpFirstCommandItem, lpCurrentCommandItem;
    UINT wArgumentPosition, wErr, wDefaultID;
    UINT uLen;
    UINT wID;
    DWORD dwValue, dwDefaultValue;
    BOOL bOpenCommand;
    LPWSTR FAR *lpstrPointerList;
    UINT wPointers = 0;
    UINT wHeaderSize;
    LPWSTR lpDefaultCommandItem = NULL;
    UINT wDefaultArgumentPosition;

    if (lpwParsingError != NULL) {
        *lpwParsingError = 0;
    }

    // If the parameter pointer is NULL, return
    if (lpstrParams == NULL)
    {
        dprintf1(("Warning:  lpstrParams is null in mciParseParams()"));
        return 0;
    }

    if ((lpstrPointerList =
         mciAlloc ((MCI_MAX_PARAM_SLOTS + 1) * sizeof (LPWSTR)))
        == NULL)
    {
        *lpPointerList = NULL;
        return MCIERR_OUT_OF_MEMORY;
    }

    // If this is the "open" command then allow parameter errors
    bOpenCommand = lstrcmpiW((LPWSTR)lpCommandList, wszOpen) == 0;

    /* Clear all the flags */
    *lpdwFlags = 0;

    /* Initialize the entry for the callback message window handle */
    /* Each MCI parameter block uses the first word in the parameter */
    /* block for the callback window handle. */
    wHeaderSize = sizeof (((PMCI_GENERIC_PARMS)lpOutputParams)->dwCallback);

    if (wHeaderSize > wParamsSize) {   // bit of our caller...
        wErr = MCIERR_PARAM_OVERFLOW;
        goto error_exit;
    }


    /* Skip past the header */
    lpFirstCommandItem = (LPWSTR)((LPBYTE)lpCommandList
                            + mciEatCommandEntry( lpCommandList, NULL, NULL ));

    uLen = mciEatCommandEntry (lpFirstCommandItem, &dwValue, &wID);

    /* Make room in lpdwOutputParams for the return arguments if any */
    if (wID == MCI_RETURN)
    {
        (LPBYTE)lpFirstCommandItem = (LPBYTE)lpFirstCommandItem + uLen;
        wHeaderSize += mciGetParamSize (dwValue, wID);
        if (wHeaderSize > wParamsSize) {
            wErr = MCIERR_PARAM_OVERFLOW;
            goto error_exit;
        }
    }

    (LPBYTE)lpOutputParams = (LPBYTE)lpOutputParams + wHeaderSize;  // Each output parameter is LPWSTR size

    // Scan the parameter string looking up each parameter in the given
    // command list

    while (TRUE)
    {
        LPCWSTR lpstrArgument = NULL;

        /* Remove leading blanks */
        while (*lpstrParams == ' ') { ++lpstrParams;
        }

        /* Break at end of parameter string */
        if (*lpstrParams == '\0') { break;
        }

        /* Scan for this parameter in the command list */
        lpCurrentCommandItem = lpFirstCommandItem;

        wArgumentPosition = 0;

        uLen = mciEatCommandEntry (lpCurrentCommandItem, &dwValue, &wID);

        /* While there are more tokens in the Command List */
        while (wID != MCI_END_COMMAND)
        {
            /* Check for a default argument if not already read */
            if (lpDefaultCommandItem == NULL &&
                *lpCurrentCommandItem == '\0')
            {
                // Remember default argument
                lpDefaultCommandItem = lpCurrentCommandItem;
                dwDefaultValue = dwValue;
                wDefaultID = wID;
                wDefaultArgumentPosition = wArgumentPosition;
//              break;
            }
            /* Check to see if this token matches */
            else if ((lpstrArgument =
                mciCheckToken (lpCurrentCommandItem, lpstrParams)) != NULL)
            {   break;
            }

            /* This token did not match the input but advance the argument position */
            wArgumentPosition += mciGetParamSize (dwValue, wID);

            /* Go to next token */
            (LPBYTE)lpCurrentCommandItem = (LPBYTE)lpCurrentCommandItem + uLen;

            // Is this command parameter a constant?
            if (wID == MCI_CONSTANT)
            {
                // Skip constant list
                do
                    (LPBYTE)lpCurrentCommandItem = (LPBYTE)lpCurrentCommandItem
                           + mciEatCommandEntry (lpCurrentCommandItem, &dwValue, &wID);
                while (wID != MCI_END_CONSTANT);
            }

            uLen = mciEatCommandEntry (lpCurrentCommandItem, &dwValue, &wID);
        } /* while */

        /* If there were no matches */
        if (lpstrArgument == NULL)
        {
            // If a default argument exists then try it
            if (lpDefaultCommandItem != NULL)
            {
                lpstrArgument = (LPWSTR)lpstrParams;
                dwValue = dwDefaultValue;
                wID = wDefaultID;
                lpCurrentCommandItem = lpDefaultCommandItem;
                wArgumentPosition = wDefaultArgumentPosition;
            }
            else
            {
                // Allow missing paramters on OPEN command if indicated by a
                // non-null lpwParsingError address
                if (!bOpenCommand || lpwParsingError == NULL)
                {
                    wErr = MCIERR_UNRECOGNIZED_KEYWORD;
                    goto error_exit;
                }
                else
                {
                    // Skip the parameter if OPEN command
                    while (*lpstrParams != ' ' && *lpstrParams != '\0')
                        ++lpstrParams;
                    if (lpwParsingError != NULL)
                        *lpwParsingError = MCIERR_UNRECOGNIZED_KEYWORD;
                    continue;
                }
            }
        }

        /* Is there room in the output buffer for this argument? */
        if (wArgumentPosition + wHeaderSize + mciGetParamSize (dwValue, wID)
            > wParamsSize)
        {
            dprintf1(("mciParseParams:  parameter space overflow"));
            wErr = MCIERR_PARAM_OVERFLOW;
            goto error_exit;
        }

        // Remove leading blanks
        while (*lpstrArgument == ' ') {
            ++lpstrArgument;
        }

        /* Process this parameter, filling in any flags or arguments */
        if ((wErr = mciParseArgument (uMessage, dwValue, wID,
                                     (LPWSTR FAR *)&lpstrArgument,
                                     lpdwFlags,
                                     (LPWSTR)((LPBYTE)lpOutputParams + wArgumentPosition),
                                     lpCurrentCommandItem))
            != 0)
        {
            goto error_exit;
        }

        lpstrParams = lpstrArgument;

        if (wID == MCI_STRING)
        {
            if (wPointers >= MCI_MAX_PARAM_SLOTS)
            {
                dprintf1(("Warning: Out of pointer list slots in mciParseParams"));
                break;
            }

            lpstrPointerList[wPointers++] =
                *((LPWSTR *)((LPBYTE)lpOutputParams + wArgumentPosition));
        }

       /* Continue reading the parameter string */
    } /* while */

    // Terminate list
    lpstrPointerList[wPointers] = NULL;

    // Copy reference for caller
    *lpPointerList = lpstrPointerList;


//
//  This is a hack to make sure that
//  the string version of MCI_SETVIDEO can actually set a palette
//  when called from a WOW app.
//

#ifndef _WIN64

    if (WinmmRunningInWOW)
    {
	DWORD dummy;  // To hold response from GetObject
	if  ((uMessage == MCI_SETVIDEO)
	  && (*lpdwFlags & MCI_DGV_SETVIDEO_VALUE)
	  && (*lpdwFlags & MCI_DGV_SETVIDEO_ITEM)
	  && (*(LPDWORD)lpOutputParams == MCI_DGV_SETVIDEO_PALHANDLE)
	  && (!GetObject( (HPALETTE)*(((LPDWORD)lpOutputParams)+1),
                             sizeof(int), &dummy ) ))
	{

	    dprintf2(("Replacing WOW palette handle %x", *(HPALETTE *)(((LPDWORD)lpOutputParams)+1)));
            *(HPALETTE *)(((LPDWORD)lpOutputParams)+1)  =
                      HPALETTE32(LOWORD(*(((LPDWORD)lpOutputParams)+1) ));
	    dprintf2(("WOW palette handle now %x", *(HPALETTE *)(((LPDWORD)lpOutputParams)+1)));
	}
    }
#endif  //  !WIN64

    // Return Success
    return 0;

error_exit:
    *lpPointerList = NULL;

    // Terminate list
    lpstrPointerList[wPointers] = NULL;
    mciParserFree (lpstrPointerList);
    return(wErr);
}

/*
 * @doc INTERNAL  MCI
 * @func UINT | mciParseCommand | This function converts an MCI
 * control string to an MCI control message suitable for sending to
 * <f mciSendCommand>.  The input string usually comes from <f mciSendString>
 * and always has the device name stripped off the front.
 *
 * @parm MCIDEVICEID | wDeviceID | Identifies the device. First searches the
 * parsing table belonging to the driver.
 * Then searches the command tables matching the type
 * of the given device.  Then searches the core command table.
 *
 * @parm LPWSTR | lpstrCommand | An MCI control command without
 * a device name prefix.  There must be no leading or trailing
 * blanks.
 *
 * @parm LPCWSTR | lpstrDeviceName | The device name (second token on the
 * command line).  It is used to identify the device type.
 *
 * @parm LPWSTR FAR * | lpCommandList | If not NULL then the address of
 * the command list for the parsed command (if successful) is copied here.
 * It is used later by mciSendString when parsing arguments
 *
 * @parm PUINT | lpwTable | The table resource ID to be unlocked
 * after parsing.  Returned to caller.
 *
 * @rdesc Returns the command ID or 0 if not found.
 *
 */
UINT mciParseCommand (
    MCIDEVICEID wDeviceID,
    LPWSTR lpstrCommand,
    LPCWSTR lpstrDeviceName,
    LPWSTR * lpCommandList,
    PUINT  lpwTable)
{
    LPWSTR lpCommandItem;
    UINT wMessage;

    dprintf2(("mciParseCommand(%ls, %ls)", lpstrCommand ? lpstrCommand : L"(NULL)", lpstrDeviceName ? lpstrDeviceName : L"(NULL)"));

    // Put the command in lower case
    // mciToLower (lpstrCommand);

    // Look up lpstrCommand in the parser's command tables.
    if ((lpCommandItem = FindCommandItem (wDeviceID, lpstrDeviceName,
                                          lpstrCommand,
                                          &wMessage, lpwTable))
        == NULL) {
        return 0;
    }

    /* Return the command list to the caller */
    if (lpCommandList != NULL) {
        *lpCommandList = lpCommandItem;
    } else {
       dprintf1(("Warning: NULL lpCommandList in mciParseCommand"));
    }

    return wMessage;
}

/*
 * @doc INTERNAL MCI
 * @func VOID | mciParserFree | Free any buffers allocated to
 * receive string arguments.
 *
 * @parm LPWSTR FAR * | lpstrPointerList | A NULL terminated list of far
 * pointers to strings to be free'd
 *
 */
VOID mciParserFree (
    LPWSTR FAR *lpstrPointerList)
{
    LPWSTR FAR *lpstrOriginal = lpstrPointerList;

    if (lpstrPointerList == NULL) {
        return;
    }

    while (*lpstrPointerList != NULL) {
        mciFree (*lpstrPointerList++);
    }

    mciFree (lpstrOriginal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\mci.c ===
/*******************************************************************************
*
* Module Name: mci.c
*
* Media Control Architecture Driver Interface
*
* Contents:  MCI external message API's mciSendString and mciSendCommand
* Author:  DLL (DavidLe)
* Created: 2/13/90
* 5/22/91: Ported to Win32 - NigelT
*
* Copyright (c) 1991-1998 Microsoft Corporation
*
\******************************************************************************/

#define INCL_WINMM
#include "winmmi.h"
#include "mci.h"
#include "wchar.h"

/*
 * MCI critical section stuff
 */

#if DBG
UINT cmciCritSec = 0; // enter'ed count
UINT uCritSecOwner;   // Thread id of critical section owner
#endif

CRITICAL_SECTION mciCritSec;  // used to protect process global mci variables

#if DBG
int mciDebugLevel;
#endif

extern DWORD mciWindowThreadId;
#define MCIERR_AUTO_ALREADY_CLOSED ((MCIERROR)0xFF000000)  // Secret return code

STATICFN UINT mciConvertReturnValue(
    UINT uType, UINT uErr, MCIDEVICEID wDeviceID,
    PDWORD_PTR dwParams, LPWSTR lpstrReturnString,
    UINT uReturnLength);

STATICFN DWORD mciSendStringInternal(
    LPCWSTR lpstrCommand, LPWSTR lpstrReturnString, UINT uReturnLength,
    HANDLE hCallback, LPMCI_SYSTEM_MESSAGE lpMessage);

STATICFN DWORD mciSendSystemString(
    LPCWSTR lpstrCommand, DWORD dwAdditionalFlags, LPWSTR lpstrReturnString,
    UINT uReturnLength);

UINT mciBreakKeyYieldProc ( MCIDEVICEID wDeviceID,
                            DWORD dwYieldData);

extern UINT FAR mciExtractTypeFromID(
    LPMCI_OPEN_PARMSW lpOpen);

// This macro defines the list of messages for which mciSendString
// will not try to auto-open
#define MCI_CANNOT_AUTO_OPEN(wMessage) \
    (wMessage == MCI_OPEN || wMessage == MCI_SYSINFO \
        || wMessage == MCI_SOUND || wMessage == MCI_CLOSE \
        || wMessage == MCI_BREAK)

// This macro devices the list of message which do not require an open
// device.  It is a subset of MCI_CANNOT_AUTO_OPEN
#define MCI_DO_NOT_NEED_OPEN(wMessage) \
    (wMessage == MCI_OPEN || wMessage == MCI_SOUND || wMessage == MCI_SYSINFO)

// Strings used in mciAutoOpenDevice
          WSZCODE wszOpen[]   = L"open";
STATICDT  WSZCODE wszClose[]  = L"close";
STATICDT  WSZCODE wszNotify[] = L"notify";  // IMPORTANT:  MUST be lowercase
STATICDT  WSZCODE wszWait[]   = L"wait";

STATICDT  WSZCODE szCmdFormat[]  = L"%ls %ls";
STATICDT  WSZCODE szLongFormat[] = L"%ld";
STATICDT  WSZCODE szRectFormat[] = L"%d %d %d %d";

// Special device name
STATICDT  WSZCODE wszNew[] = L"new";

/*****************************************************************************
 * @doc INTERNAL
 *
 * @func void | MciNotify  | called by mmWndProc when it recives a
 *                          MM_MCINOTIFY message
 * @rdesc None.
 *
 ****************************************************************************/
void MciNotify(
    DWORD   wParam,
    LONG    lParam)
{
    //
    //  wParam is the notify status
    //  lParam is the MCI device id
    //
    mciEnter("MciNotify");

    if (MCI_VALID_DEVICE_ID((UINT)lParam)           // If a valid device
      && !(ISCLOSING(MCI_lpDeviceList[lParam]))) { // and if not in process of closing
        SETAUTOCLOSING(MCI_lpDeviceList[lParam]);

        //
        // Must not hold MCI critical section when calling mciCloseDevice
        // because DrvClose gets the load/unload critical section while
        // drivers loading will have the load/unload critical section
        // but can call back (eg) to mciRegisterCommandTable causing
        // a deadlock.
        //
        // Even if the incoming notification is ABORTED/SUPERSEDED/FAILED
        // we must still close the device.  Otherwise devices get left open.
        // mciCloseDevice will protect against trying to close a device that
        // we do not own.
        mciLeave("MciNotify");
        mciCloseDevice ((MCIDEVICEID)lParam, 0L, NULL, TRUE);
    } else {
        mciLeave("MciNotify");
    }
}

/*--------------------------------------------------------------------*\
 *  HandleNotify
 *
\*--------------------------------------------------------------------*/
STATICFN void HandleNotify(
    DWORD   uErr,
    MCIDEVICEID wDeviceID,
    DWORD   dwFlags,
    DWORD_PTR   dwParam2)
{
    LPMCI_GENERIC_PARMS lpGeneric = (LPMCI_GENERIC_PARMS)dwParam2;
    HANDLE hCallback;

    if (0 == uErr
      && dwFlags & MCI_NOTIFY
      && lpGeneric != NULL
      && (hCallback = (HANDLE)lpGeneric->dwCallback) != NULL)
    {
        mciDriverNotify (hCallback, wDeviceID, MCI_NOTIFY_SUCCESSFUL);
    }
}

#if DBG

/*--------------------------------------------------------------------*\
 * mciDebugOut
 *
 * Dump the string form of an MCI command
\*--------------------------------------------------------------------*/
UINT NEAR mciDebugOut(
    MCIDEVICEID wDeviceID,
    UINT wMessage,
    DWORD_PTR dwFlags,
    DWORD_PTR dwParam2,
    LPMCI_DEVICE_NODE nodeWorking)
{
    LPWSTR  lpCommand, lpFirstParameter, lpPrevious, lszDebugOut;
    WCHAR   strTemp[256];
    UINT    wID;
    UINT    wOffset, wOffsetFirstParameter;
    UINT    uReturnType = 0;
    DWORD   dwValue;
    DWORD   dwMask = 1;                // used to test each flag bit in turn
    UINT    wTable;

// Find the command table for the given command message ID
    lpCommand = FindCommandItem( wDeviceID, NULL, (LPWSTR)(UINT_PTR)wMessage,
                                 NULL, &wTable );

    if (lpCommand == NULL)
    {
        if (wMessage != MCI_OPEN_DRIVER && wMessage != MCI_CLOSE_DRIVER) {
            ROUT(("WINMM: mciDebugOut:  Command table not found"));
        }
        return 0;
    }

    lszDebugOut = mciAlloc( BYTE_GIVEN_CHAR( 512 ) );
    if (!lszDebugOut) {
        ROUT(("WINMM: Not enough memory to display command"));
        return 0;
    }

//  Dump the command name into the buffer
    wsprintfW( lszDebugOut, L"MCI command: \"%ls", lpCommand );

// Dump the device name
    if (wDeviceID == MCI_ALL_DEVICE_ID)
    {
        wcscat( lszDebugOut, L" all" );
    }
    else if (nodeWorking != NULL)
    {
        if (nodeWorking->dwMCIOpenFlags & MCI_OPEN_ELEMENT_ID)
        {
            wsprintfW( lszDebugOut + wcslen( lszDebugOut ),
                           L" Element ID:0x%lx", nodeWorking->dwElementID );
        }
        else if (nodeWorking->lpstrName != NULL)
        {
            wsprintfW( lszDebugOut + wcslen( lszDebugOut ),
                           L" %ls", nodeWorking->lpstrName );
        }
    }

    // Skip past command entry
    lpCommand = (LPWSTR)((LPBYTE)lpCommand + mciEatCommandEntry( lpCommand, NULL, NULL));

    // Get the next entry
    lpFirstParameter = lpCommand;

    // Skip past the DWORD return value
    wOffsetFirstParameter = 4;

        lpCommand = (LPWSTR)((LPBYTE)lpCommand +
                                mciEatCommandEntry( lpCommand,
                                                    &dwValue, &wID ));

    // If it is a return value, skip it
    if (wID == MCI_RETURN)
    {
        uReturnType = (UINT)dwValue;
        lpFirstParameter = lpCommand;
        wOffsetFirstParameter += mciGetParamSize (dwValue, wID);
        lpCommand = (LPWSTR)((LPBYTE)lpCommand +
                                    mciEatCommandEntry(lpCommand,
                                                       &dwValue, &wID));
    }

// Dump device name parameter to OPEN
    if (wMessage == MCI_OPEN)
    {
        LPCWSTR lpstrDeviceType =
            ((LPMCI_OPEN_PARMSW)dwParam2)->lpstrDeviceType;
        LPCWSTR lpstrElementName =
            ((LPMCI_OPEN_PARMSW)dwParam2)->lpstrElementName;

// Tack on device type
        if (dwFlags & MCI_OPEN_TYPE_ID)
        {
            //  Warning!: Expanding dwOld to DWORD_PTR may not work on
            //            on Win64, just to clear out warning.  MCI may
            //            not get ported to Win64.

            LPMCI_OPEN_PARMSW   lpOpen = (LPMCI_OPEN_PARMSW)dwParam2;
            DWORD_PTR           dwOld = PtrToUlong(lpOpen->lpstrDeviceType);

            if (mciExtractTypeFromID ((LPMCI_OPEN_PARMSW)dwParam2) != 0) {
                strTemp[0] = '\0';
            }
            wcscpy (strTemp, (LPWSTR)lpOpen->lpstrDeviceType);
            mciFree ((LPWSTR)lpOpen->lpstrDeviceType);
            lpOpen->lpstrDeviceType = (LPWSTR)dwOld;

        } else if (lpstrDeviceType != NULL)
            wcscpy (strTemp, (LPWSTR)lpstrDeviceType);

        else {
            strTemp[0] = '\0';
        }

        if (dwFlags & MCI_OPEN_ELEMENT_ID)
        {
// Tack on element ID
            wcscat( strTemp, L" Element ID:");
            wsprintfW( strTemp + wcslen (strTemp), szLongFormat,
                           LOWORD (PtrToUlong(lpstrDeviceType)));
        } else
        {
// Add separator if both type name and element name are present
            if (lpstrDeviceType != 0 && lpstrElementName != 0) {
                wcscat( strTemp, L"!" );
            }

            if (lpstrElementName != 0 && dwFlags & MCI_OPEN_ELEMENT) {
                wcscat( strTemp, lpstrElementName );
            }
        }
        wsprintfW( lszDebugOut + wcslen(lszDebugOut), L" %ls", strTemp );
    }


// Walk through each flag
    while (dwMask != 0)
    {
        // Is this bit set?
        if ((dwFlags & dwMask) != 0 && !
        // The MCI_OPEN_TYPE and MCI_OPEN_ELEMENT flags are taken care of
        // above
            (wMessage == MCI_OPEN && (dwMask == MCI_OPEN_TYPE
                                      || dwMask == MCI_OPEN_ELEMENT)))
        {
            lpPrevious = lpCommand = lpFirstParameter;
            wOffset = 0;
            lpCommand = (LPWSTR)((LPBYTE)lpCommand
                         + mciEatCommandEntry( lpCommand, &dwValue, &wID ));

            // What parameter uses this bit?
            while (wID != MCI_END_COMMAND && dwValue != dwMask)
            {
                wOffset += mciGetParamSize( dwValue, wID);

                if (wID == MCI_CONSTANT) {
                    while (wID != MCI_END_CONSTANT) {
                        lpCommand = (LPWSTR)((LPBYTE)lpCommand
                            + mciEatCommandEntry( lpCommand, NULL, &wID));
                    }
                }
                lpPrevious = lpCommand;
                lpCommand = (LPWSTR)((LPBYTE)lpCommand
                             + mciEatCommandEntry( lpCommand, &dwValue, &wID ));
            }

            if (wID != MCI_END_COMMAND)
            {
// Found the parameter which matches this flag bit
// Print the parameter name
                if (*lpPrevious) {
                    wsprintfW( lszDebugOut + wcslen(lszDebugOut),
                                   L" %ls", lpPrevious);
                }

// Print any argument
                switch (wID)
                {
                    case MCI_STRING:
                        wsprintfW( lszDebugOut + wcslen(lszDebugOut),
                                       L" %ls", *(LPWSTR *)( (LPBYTE)dwParam2
                                       + wOffset + wOffsetFirstParameter) );
                        break;
                    case MCI_CONSTANT:
                    {
                        DWORD dwConst = *(LPDWORD)((LPBYTE)dwParam2 + wOffset +
                                             wOffsetFirstParameter);
                        UINT wLen;
                        BOOL bFound = FALSE;

                        while (wID != MCI_END_CONSTANT)
                        {
                            wLen = mciEatCommandEntry( lpCommand,
                                                       &dwValue, &wID);

                            if (dwValue == dwConst)
                            {
                                bFound = TRUE;
                                wsprintfW( lszDebugOut + wcslen(lszDebugOut),
                                                L" %ls", lpCommand);
                            }

                            lpCommand = (LPWSTR)((LPBYTE)lpCommand + wLen);
                        }
                        if (bFound)
                            break;
// FALL THROUGH
                    }
                    case MCI_INTEGER:
                    case MCI_HWND:
                    case MCI_HPAL:
                    case MCI_HDC:
                        wsprintfW( strTemp, szLongFormat,
                                       *(LPDWORD)((LPBYTE)dwParam2 + wOffset +
                                                    wOffsetFirstParameter));
                        wsprintfW( lszDebugOut + wcslen(lszDebugOut),
                                       L" %ls", strTemp );
                        break;
                }
            }
        }

// Go to the next flag
        dwMask <<= 1;
    }

    mciUnlockCommandTable( wTable);
    wcscat(lszDebugOut, L"\"" );
    ROUTSW((lszDebugOut));

    mciFree(lszDebugOut);
    return uReturnType;
}
#endif

DWORD mciBreak(
    MCIDEVICEID  wDeviceID,
    DWORD   dwFlags,
    LPMCI_BREAK_PARMS lpBreakon)
{
    HWND hwnd;

    if (dwFlags & MCI_BREAK_KEY)
    {
        if (dwFlags & MCI_BREAK_OFF) {
            return MCIERR_FLAGS_NOT_COMPATIBLE;
        }

        if (dwFlags & MCI_BREAK_HWND) {
            hwnd = lpBreakon->hwndBreak;
        }
        else
        {
            hwnd = NULL;
        }

        return  mciSetBreakKey (wDeviceID, lpBreakon->nVirtKey,
                                hwnd)
                    ? 0 : MMSYSERR_INVALPARAM;

    } else if (dwFlags & MCI_BREAK_OFF) {

        mciSetYieldProc (wDeviceID, NULL, 0);
        return 0;
    } else {
        return MCIERR_MISSING_PARAMETER;
    }
}

//***********************************************************************
//  mciAutoCloseDevice
//
// Close the indicated device by sending a message inter-task
//***********************************************************************
STATICFN DWORD mciAutoCloseDevice(
    LPCWSTR lpstrDevice)
{
    LPWSTR  lpstrCommand;
    DWORD   dwRet;
    int     alloc_len = BYTE_GIVEN_CHAR( wcslen( lpstrDevice) ) +
                        sizeof(wszClose) + sizeof(WCHAR);

    if ((lpstrCommand = mciAlloc ( alloc_len ) ) == NULL)
        return MCIERR_OUT_OF_MEMORY;

    wsprintfW( lpstrCommand, szCmdFormat, wszClose, lpstrDevice);

    dwRet = mciSendSystemString( lpstrCommand, 0L, NULL, 0);

    mciFree( lpstrCommand);

    return dwRet;
}


//***********************************************************************
// mciSendSingleCommand
//
// Process a single MCI command
// Called by mciSendCommandInternal
//
//***********************************************************************
DWORD NEAR mciSendSingleCommand(
    MCIDEVICEID wDeviceID,
    UINT wMessage,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2,
    LPMCI_DEVICE_NODE nodeWorking,
    BOOL bWalkAll,
    LPMCI_INTERNAL_OPEN_INFO lpOpenInfo)
{
    DWORD dwRet;

#if DBG
    UINT uReturnType;
    if (mciDebugLevel != 0)
        uReturnType = mciDebugOut( wDeviceID, wMessage, dwParam1, dwParam2,
                                   nodeWorking);

    if (nodeWorking == NULL && !MCI_DO_NOT_NEED_OPEN (wMessage))
        return MCIERR_INTERNAL;
#endif

    switch (wMessage)
    {
        case MCI_OPEN:
            dwRet = mciOpenDevice ((DWORD)dwParam1,
                                   (LPMCI_OPEN_PARMSW)dwParam2, lpOpenInfo);
            break;

        case MCI_CLOSE:
// If we were walking the device list and this device was auto opened
// send the command via a task switch
// If we just called mciCloseDevice (as sometimes happened before a bug
// was fixed mciCloseDevice will unload the driver but the MCI_CLOSE_DRIVER
// command will not get sent because it will be rejected as coming from the
// wrong task.  The result would be (was) that the driver would access violate
// when it next did something.
            if (GetCurrentTask() != nodeWorking->hCreatorTask)
            {
                LPWSTR lpstrCommand;

                if (!bWalkAll) {
                    //
                    //  Only valid to close an auto-opened device if it's
                    //  being close as part of closing MCI_ALL_DEVICE_ID
                    //  We can reach here if an app 'guesses' an MCI device
                    //  id and tries to close it while playing.
                    //
                    dwRet = MCIERR_ILLEGAL_FOR_AUTO_OPEN;
                    break;
                }

                lpstrCommand = mciAlloc( sizeof(wszClose)+ sizeof(WCHAR) +
                               BYTE_GIVEN_CHAR( wcslen( nodeWorking->lpstrName ) ) );

                if ( lpstrCommand == NULL )
                    return MCIERR_OUT_OF_MEMORY;

                wcscpy( lpstrCommand, wszClose);
                wcscat( lpstrCommand, L" ");
                wcscat( lpstrCommand, nodeWorking->lpstrName);
                dwRet = mciSendSystemString( lpstrCommand, 0L, NULL, 0);
                mciFree( lpstrCommand);
            } else
                dwRet = mciCloseDevice( wDeviceID, (DWORD)dwParam1,
                                        (LPMCI_GENERIC_PARMS)dwParam2, TRUE);
            break;

        case MCI_SYSINFO:
            dwRet = mciSysinfo( wDeviceID, (DWORD)dwParam1,
                                (LPMCI_SYSINFO_PARMSW)dwParam2);
            HandleNotify( dwRet, wDeviceID, (DWORD)dwParam1, dwParam2);
            break;

        case MCI_BREAK:
            dwRet = mciBreak( wDeviceID, (DWORD)dwParam1,
                              (LPMCI_BREAK_PARMS)dwParam2);
            HandleNotify( dwRet, wDeviceID, (DWORD)dwParam1, dwParam2);
            break;

        case MCI_SOUND:
        {
            LPMCI_SOUND_PARMSW lpSound = (LPMCI_SOUND_PARMSW)dwParam2;
            if ( PlaySoundW( MCI_SOUND_NAME & dwParam1
                                    ? lpSound->lpstrSoundName
                                    : L".Default",
                                (HANDLE)0,
                                dwParam1 & MCI_WAIT
                                    ? SND_SYNC | SND_ALIAS
                                    : SND_ASYNC | SND_ALIAS ) )
            {
                dwRet = 0;
            } else {
                dwRet = MCIERR_HARDWARE;
            }

            HandleNotify( dwRet, wDeviceID, (DWORD)dwParam1, dwParam2);
            break;
        }
        default:
#if 0 // don't bother (NigelT)
            if (mciDebugLevel > 1)
            {
                dwStartTime = timeGetTime();
            }
#endif
// Initialize GetAsyncKeyState for break key
            {
                if ((dwParam1 & MCI_WAIT) &&
                    nodeWorking->fpYieldProc == mciBreakKeyYieldProc)
                {
                    dprintf4(("Getting initial state of Break key"));
                    GetAsyncKeyState( nodeWorking->dwYieldData);
                    //GetAsyncKeyState( LOWORD(nodeWorking->dwYieldData));
                }
            }

            dwRet = (DWORD)DrvSendMessage( nodeWorking->hDrvDriver, wMessage,
                                    dwParam1, dwParam2);
            break;
    } // switch

#if DBG
    if (mciDebugLevel != 0)
    {
        if (dwRet & MCI_INTEGER_RETURNED)
            uReturnType = MCI_INTEGER;

        switch (uReturnType)
        {
            case MCI_INTEGER:
            {
                WCHAR strTemp[50];

                mciConvertReturnValue( uReturnType, HIWORD(dwRet), wDeviceID,
                                       (PDWORD_PTR)dwParam2, strTemp,
                                       CHAR_GIVEN_BYTE( sizeof(strTemp) ) );
                dprintf2(("    returns: %ls", strTemp));
                break;
            }

            case MCI_STRING:
                dprintf2(("    returns: %ls",(LPWSTR)(1 + (LPDWORD)dwParam2)));
                break;
        }
    }
#endif

    return dwRet;
}

//***********************************************************************
//  mciSendCommandInternal
//
// Internal version of mciSendCommand.  Differs ONLY in that the return
// value is a DWORD where the high word has meaning only for mciSendString
//
//***********************************************************************
STATICFN DWORD mciSendCommandInternal(
    MCIDEVICEID wDeviceID,
    UINT wMessage,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2,
    LPMCI_INTERNAL_OPEN_INFO lpOpenInfo)
{
    DWORD dwRetVal;
    LPMCI_DEVICE_NODE nodeWorking = NULL;
    BOOL bWalkAll;
    DWORD dwAllError = 0;
    HANDLE hCurrentTask;

    hCurrentTask = GetCurrentTask();

    // If the device is "all" and the message is *not*
    // "sysinfo" then we must walk all devices
    if (wDeviceID == MCI_ALL_DEVICE_ID
       && (wMessage != MCI_SYSINFO)
       && (wMessage != MCI_SOUND))
    {
        if (wMessage == MCI_OPEN)
        {
            dwRetVal = MCIERR_CANNOT_USE_ALL;
            goto exitfn;
        }

        bWalkAll = TRUE;

        // Start at device #1
        wDeviceID = 1;
    } else {
        bWalkAll = FALSE;
    }

    mciEnter("mciSendCommandInternal");
    // Walk through all devices if bWalkAll or just one device if !bWalkAll
    do
    {
        // Initialize
        dwRetVal = 0;

        // Validate the device ID if single device
        if (!bWalkAll)
        {
            if (!MCI_DO_NOT_NEED_OPEN(wMessage))
            {

                if (!MCI_VALID_DEVICE_ID(wDeviceID))
                {
                    dwRetVal = MCIERR_INVALID_DEVICE_ID;
                    goto exitfn;
                }

                nodeWorking = MCI_lpDeviceList[wDeviceID];
            }
        }
        else if (wMessage != MCI_SYSINFO)
        {
            nodeWorking = MCI_lpDeviceList[wDeviceID];
        }

        // Skip if walking the device list and the
        // device is not part of the current task

        if (bWalkAll)
        {
            if (nodeWorking == NULL ||
                nodeWorking->hOpeningTask != hCurrentTask)
                    goto no_send;
        }

        // If the device is in the process of closing and the message
        // is not MCI_CLOSE_DEVICE then return an error
        if (nodeWorking != NULL &&
            ISCLOSING(nodeWorking) &&
            wMessage != MCI_CLOSE_DRIVER)
        {
            dwRetVal = MCIERR_DEVICE_LOCKED;
            goto exitfn;
        }

// If this message is being sent from the wrong task (the device was auto-
// opened) fail all but the MCI_CLOSE message which gets sent inter-task
        if (nodeWorking != NULL &&
            nodeWorking->hCreatorTask != hCurrentTask)
        {
            if (wMessage != MCI_CLOSE)
            {
                dwRetVal = MCIERR_ILLEGAL_FOR_AUTO_OPEN;
                goto exitfn;
            }
            else
            {
// Don't even allow close from mciSendCommand if auto-open device has a
// pending close
                if (ISAUTOCLOSING(nodeWorking))
                {
                    dwRetVal = MCIERR_DEVICE_LOCKED;
                    goto exitfn;
                }
            }
        }

        mciLeave("mciSendCommandInternal");
        dwRetVal = mciSendSingleCommand( wDeviceID, wMessage, dwParam1,
                                         dwParam2, nodeWorking, bWalkAll,
                                         lpOpenInfo);
        mciEnter("mciSendCommandInternal");
no_send:

        // If we are processing multiple devices
        if (bWalkAll)
        {
            // If there was an error for this device
            if (dwRetVal != 0)
            {
                // If this is not the first error
                if (dwAllError != 0) {
                    dwAllError = MCIERR_MULTIPLE;
                // Just one error so far
                } else {
                    dwAllError = dwRetVal;
                }
            }
        }
    } while (bWalkAll && ++wDeviceID < MCI_wNextDeviceID);

exitfn:;
    mciLeave("mciSendCommandInternal");
    return dwAllError == MCIERR_MULTIPLE ? dwAllError : dwRetVal;
}


/************************************************************************
 * @doc EXTERNAL MCI
 *
 * @api DWORD | mciSendCommand | This function sends a command message to
 * the specified MCI device.
 *
 * @parm MCIDEVICEID | wDeviceID | Specifies the device ID of the MCI device
 *  to receive the command.  This parameter is
 *  not used with the <m MCI_OPEN> command.
 *
 * @parm UINT | wMessage | Specifies the command message.
 *
 * @parm DWORD | dwParam1 | Specifies flags for the command.
 *
 * @parm DWORD | dwParam2 | Specifies a pointer to a parameter block
 *  for the command.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *  error information.  The low-order word
 *  of the returned DWORD is the error return value.  If the error is
 *  device-specific, the high-order word contains the driver ID; otherwise
 *  the high-order word is zero.
 *
 *  To get a textual description of <f mciSendCommand> return values,
 *  pass the return value to <f mciGetErrorString>.
 *
 *  Error values that are returned when a device is being opened
 *  are listed with the MCI_OPEN message. In addition to the
 *  MCI_OPEN error returns, this function can
 *  return the following values:
 *
 *  @flag MCIERR_BAD_TIME_FORMAT | Illegal value for time format.
 *
 *  @flag MCIERR_CANNOT_USE_ALL | The device name "all" is not allowed
 *  for this command.
 *
 *  @flag MCIERR_CREATEWINDOW | Could not create or use window.
 *
 *  @flag MCIERR_DEVICE_LOCKED | The device is locked until it is
 *  closed automatically.
 *
 *  @flag MCIERR_DEVICE_NOT_READY | Device not ready.
 *
 *  @flag MCIERR_DEVICE_TYPE_REQUIRED | The device name must be a valid
 *  device type.
 *
 *  @flag MCIERR_DRIVER | Unspecified device error.
 *
 *  @flag MCIERR_DRIVER_INTERNAL | Internal driver error.
 *
 *  @flag MCIERR_FILE_NOT_FOUND | Requested file not found.
 *
 *  @flag MCIERR_FILE_NOT_SAVED | The file was not saved.
 *
 *  @flag MCIERR_FILE_READ | A read from the file failed.
 *
 *  @flag MCIERR_FILE_WRITE | A write to the file failed.
 *
 *  @flag MCIERR_FLAGS_NOT_COMPATIBLE | Incompatible parameters
 *  were specified.
 *
 *  @flag MCIERR_HARDWARE | Hardware error on media device.
 *
 *  @flag MCIERR_INTERNAL | Internal error.
 *
 *  @flag MCIERR_INVALID_DEVICE_ID | Invalid device ID.
 *
 *  @flag MCIERR_INVALID_DEVICE_NAME | The device is not open
 *  or is not known.
 *
 *  @flag MCIERR_INVALID_FILE | Invalid file format.
 *
 *  @flag MCIERR_MULTIPLE | Errors occurred in more than one device.
 *
 *  @flag MCIERR_NO_WINDOW | There is no display window.
 *
 *  @flag MCIERR_NULL_PARAMETER_BLOCK | Parameter block pointer was NULL.
 *
 *  @flag MCIERR_OUT_OF_MEMORY | Not enough memory for requested operation.
 *
 *  @flag MCIERR_OUTOFRANGE | Parameter value out of range.
 *
 *  @flag MCIERR_UNNAMED_RESOURCE | Attempt to save unnamed file.
 *
 *  @flag MCIERR_UNRECOGNIZED_COMMAND | Unknown command.
 *
 *  @flag MCIERR_UNSUPPORTED_FUNCTION | Action not available for this
 *  device.
 *
 *  The following additional return values are defined for MCI sequencers:
 *
 *  @flag MCIERR_SEQ_DIV_INCOMPATIBLE | Set Song Pointer incompatible
 *  with SMPTE files.
 *
 *  @flag MCIERR_SEQ_PORT_INUSE | Specified port is in use.
 *
 *  @flag MCIERR_SEQ_PORT_MAPNODEVICE | Current map uses non-existent
 *  device.
 *
 *  @flag MCIERR_SEQ_PORT_MISCERROR | Miscellaneous error with
 *  specified port.
 *
 *  @flag MCIERR_SEQ_PORT_NONEXISTENT | Specified port does not exist.
 *
 *  @flag MCIERR_SEQ_PORTUNSPECIFIED | No current MIDI port.
 *
 *  @flag MCIERR_SEQ_NOMIDIPRESENT | No MIDI ports present.
 *
 *  @flag MCIERR_SEQ_TIMER | Timer error.
 *
 *  The following additional return values are defined for MCI waveform
 *  audio devices:
 *
 *  @flag MCIERR_WAVE_INPUTSINUSE | No compatible waveform recording
 *   device is free.
 *
 *  @flag MCIERR_WAVE_INPUTSUNSUITABLE | No compatible waveform
 *  recording devices.
 *
 *  @flag MCIERR_WAVE_INPUTUNSPECIFIED | Any compatible waveform
 *  recording device may be used.
 *
 *  @flag MCIERR_WAVE_OUTPUTSINUSE | No compatible waveform playback
 *  device is free.
 *
 *  @flag MCIERR_WAVE_OUTPUTSUNSUITABLE | No compatible waveform
 *  playback devices.
 *
 *  @flag MCIERR_WAVE_OUTPUTUNSPECIFIED | Any compatible waveform
 *  playback device may be used.
 *
 *  @flag MCIERR_WAVE_SETINPUTINUSE | Set waveform recording device
 *  is in use.
 *
 *  @flag MCIERR_WAVE_SETINPUTUNSUITABLE | Set waveform recording
 *  device is incompatible with set format.
 *
 *  @flag MCIERR_WAVE_SETOUTPUTINUSE | Set waveform playback device
 *  is in use.
 *
 *  @flag MCIERR_WAVE_SETOUTPUTUNSUITABLE | Set waveform playback
 *  device is incompatible with set format.
 *
 * @comm Use the <m MCI_OPEN> command to obtain the device ID
 *  specified by <p wDeviceID>.
 *
 * @xref mciGetErrorString mciSendString
 */

 /*
 * @doc internal
 *
 * @api DWORD | mciDriverEntry | Actually a callback.  The entry point for MCI drivers.
 *
 * @parm UINT | wMessage | Identifies the requested action to be performed.
 *
 * @parm DWORD | dwParam1 | Specifies data for this message.  Defined separately
 * for each message.
 *
 * @parm DWORD | dwParam2 | Specifies data for this message.  Defined separately
 * for each message.
 *
 * @rdesc The return value is defined separately for each message.
 */

//  WARNING!!  Casting all pointer references to wMessage to UINT_PTR to
//             clear out warnings.  Note:  This will NOT WORK on Win64;
//             we'll have to change this prototype to get this to work
//             on Win64.

DWORD mciSendCommandA(
    MCIDEVICEID wDeviceID,
    UINT wMessage,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2)
{
    LPCSTR   lpStr1;
    LPCSTR   lpStr2;
    LPCSTR   lpStr3;
    DWORD    dwRet;

    /*
    ** If dwParam1 is 0L, we have no information to perform the ascii
    ** to unicode thunks from.  Therefore, I will pass the call straight
    ** thru to mciSendCommandW "as is".
    */
    if ( dwParam1 == 0L ) {
        return mciSendCommandW( wDeviceID, wMessage, dwParam1, dwParam2 );
    }

    /*
    ** If we are still here we have some thunking to do.
    **
    **
    ** Basically this code is very similiar to the WOW thunk code.
    **
    ** We have to special case MCI_OPEN and MCI_SYSINFO because the
    ** command table is either not available or in an inconsistent state.
    **
    ** Otherwise, the code is identical to the WOW code.  Maybe we could do
    ** unicode thunking in the WOW layer and then call mciSendCommandW.
    ** It seems bad that we should have to thunk poor old WOW apps twice!!
    ** they are slow enough as it is :-)
    **
    ** We have the advantage that all pointers are already 32 bit.
    **
    */
    switch ( wMessage ) {

    case MCI_CLOSE_DRIVER:
        dprintf3(( "MCI_CLOSE_DRIVER command" ));
        return mciSendCommandW( wDeviceID, wMessage, dwParam1, dwParam2 );
        break;


    case MCI_OPEN_DRIVER:
        dprintf3(( "MCI_OPEN_DRIVER command" ));

        /* fall thru */

    case MCI_OPEN:
        {
            LPMCI_OPEN_PARMSW lpOpenP = (LPMCI_OPEN_PARMSW)dwParam2;
#if DBG
            dprintf3(( "MCI_OPEN command" ));

            /*
            ** As of yet I don't know how to thunk command extensions
            ** for the open command.
            ** These may well contain strings but we have no way of
            ** knowing because we haven't got access to the command table.
            */
            if ( dwParam1 & 0xFFFF0000 ) {
                dprintf1(( "MCI_OPEN called with command extensions !!" ));
            }
#endif

            /*
            ** First save the original ascii string pointers.
            ** Note that lpstrDeviceType may be a TYPE_ID
            ** Note that lpstrElementName may be a ELEMENT_ID
            */
            lpStr1 = (LPCSTR)lpOpenP->lpstrDeviceType;
            lpStr2 = (LPCSTR)lpOpenP->lpstrElementName;
            lpStr3 = (LPCSTR)lpOpenP->lpstrAlias;

            /*
            ** Now allocate a unicode copy of the ascii, don't try
            ** to copy NULL strings, or ID types
            **
            ** The first string to be copied is lpstrDeviceType.
            ** This pointer is only valid if the MCI_OPEN_TYPE bit
            ** is set and MCI_OPEN_TYPE_ID is not set.  If either
            ** bit is set and lpstrDeviceType is NULL it is an
            ** error that will be picked up later.
            **
            ** The second string is lpstrElementName which is valid
            ** only with MCI_OPEN_ELEMENT set and MCI_OPEN_ELEMENT_ID
            ** not set.  As in the case above it is an error if
            ** either bit is set but the pointer itself is NULL.
            **
            ** The third string is lpstrAlias which is valid only
            ** with MCI_OPEN_ALIAS set.  In this case when this bit
            ** is set there is no modifying bit that changes the
            ** meaning of the pointer.
            **
            ** If an unicode string is not allocated the internal
            ** pointer is set to NULL.  This value can be checked
            ** after the mciSendCommand call to see if the string
            ** has to be freed and the original pointer restored.
            */
            if ( lpStr1 ) {
                if ((dwParam1 & MCI_OPEN_TYPE)
                  && !(dwParam1 & MCI_OPEN_TYPE_ID) ) {
                    lpOpenP->lpstrDeviceType = AllocUnicodeStr( (LPSTR)lpStr1 );
                    if ( lpOpenP->lpstrDeviceType == NULL ) {
                        dwRet = MCIERR_OUT_OF_MEMORY;
                        goto err1;
                    }
                } else lpStr1 = NULL;  // Nothing allocated, will free nothing
            }

            if ( lpStr2 ) {
                if ((dwParam1 & MCI_OPEN_ELEMENT)
                  && !(dwParam1 & MCI_OPEN_ELEMENT_ID) ) {
                    lpOpenP->lpstrElementName = AllocUnicodeStr( (LPSTR)lpStr2 );
                    if ( lpOpenP->lpstrElementName == NULL ) {
                        dwRet = MCIERR_OUT_OF_MEMORY;
                        goto err2;
                    }
                } else lpStr2 = NULL;  // Nothing allocated, will free nothing
            }

            if ( lpStr3 ) {
                if (dwParam1 & MCI_OPEN_ALIAS) {
                    lpOpenP->lpstrAlias = AllocUnicodeStr( (LPSTR)lpStr3 );
                    if ( lpOpenP->lpstrAlias == NULL ) {
                        dwRet = MCIERR_OUT_OF_MEMORY;
                        goto err3;
                    }
                } else lpStr3 = NULL;  // Nothing allocated, will free nothing
            }

            /*
            ** Now call the unicode version
            */
            dwRet = mciSendCommandW( wDeviceID, wMessage, dwParam1, dwParam2 );

            /*
            ** Free the unicode strings.
            ** and restore the original string pointers
            */
            if ( lpStr3 ) {

                FreeUnicodeStr( (LPWSTR)lpOpenP->lpstrAlias );
      err3:     lpOpenP->lpstrAlias = (LPCWSTR)lpStr3;
            }

            if ( lpStr2 ) {
                FreeUnicodeStr( (LPWSTR)lpOpenP->lpstrElementName );
      err2:     lpOpenP->lpstrElementName = (LPCWSTR)lpStr2;
            }

            if ( lpStr1 ) {
                FreeUnicodeStr( (LPWSTR)lpOpenP->lpstrDeviceType );
      err1:     lpOpenP->lpstrDeviceType  = (LPCWSTR)lpStr1;
            }
            return dwRet;
        }

    case MCI_SYSINFO:
        dprintf3(( "MCI_SYSINFO command" ));
        /*
        ** If we are returning a number forget about UNICODE,
        ** applies when (dwParam1 & MCI_SYSINFO_QUANTITY) is TRUE.
        */
        if ( dwParam1 & MCI_SYSINFO_QUANTITY ) {
            return mciSendCommandW( wDeviceID, wMessage, dwParam1, dwParam2 );
        }
        else {

            LPMCI_SYSINFO_PARMSW lpInfoP = (LPMCI_SYSINFO_PARMSW)dwParam2;
            DWORD len = BYTE_GIVEN_CHAR( lpInfoP->dwRetSize );

            /*
            ** First save the original ascii string pointers.
            */
            lpStr1 = (LPSTR)lpInfoP->lpstrReturn;

            /*
            ** If there is somewhere to store the result then we
            ** must allocate temporary space (for Unicode result)
            ** and on return from mciSendCommandW translate the
            ** string to Ascii.
            */
            if (len) {
                if ( lpStr1 ) {
                    lpInfoP->lpstrReturn = mciAlloc( len );
                    if ( lpInfoP->lpstrReturn == NULL ) {
                        lpInfoP->lpstrReturn = (LPWSTR)lpStr1;
                        return MCIERR_OUT_OF_MEMORY;
                    }

                    lpStr2 = mciAlloc( len );
                    if ( lpStr2 == NULL ) {
                        mciFree( (LPWSTR)lpInfoP->lpstrReturn );
                        lpInfoP->lpstrReturn = (LPWSTR)lpStr1;
                        return MCIERR_OUT_OF_MEMORY;
                    }
                }
            } else {

                /*
                ** Should we ZERO the string pointers in the parameter block?
                ** Yes, belts and braces !!
                */
                lpInfoP->lpstrReturn = NULL;

            }

            /*
            ** Now call the unicode version
            */
            dwRet = mciSendCommandW( wDeviceID, wMessage, dwParam1, dwParam2 );

            /*
            ** Copy the unicode return string into ascii, if the
            ** user provided a return string
            */
            if (len && lpStr1) {
                if ((MMSYSERR_NOERROR == dwRet) && len) {
                    UnicodeStrToAsciiStr( (PBYTE)lpStr2,
                                     (PBYTE)lpStr2 + len,
                                     lpInfoP->lpstrReturn );

                    /* On return from mciSendCommandW lpInfoP->dwRetSize is
                    ** equal to the number of characters copied to
                    ** lpInfoP->lpstrReturn less the NULL terminator.
                    ** So add one to lpInfoP->dwRetSize to include the NULL
                    ** in the strncpy below.
                    **
                    ** But ONLY if the original buffer was large enough.
                    */
//#ifdef DBCS
//fix kksuzuka: #3642
//have to copy byte length into ASCII buffer..
                    strncpy( (LPSTR)lpStr1, lpStr2,
                        min(BYTE_GIVEN_CHAR(lpInfoP->dwRetSize+1), CHAR_GIVEN_BYTE(len)));
//#else
//                    strncpy( (LPSTR)lpStr1, lpStr2,
//                        min((UINT)lpInfoP->dwRetSize + 1, CHAR_GIVEN_BYTE(len)) );
//#endif

#if DBG
                    dprintf3(( "Return param (UNICODE)= %ls", lpInfoP->lpstrReturn ));
                    dprintf3(( "Return param (ASCII)  = %s",  lpStr1 ));
#endif
                }

                /*
                ** Free temp storage and restore the original strings
                */
                mciFree( lpInfoP->lpstrReturn );
                lpInfoP->lpstrReturn = (LPWSTR)lpStr1;
                mciFree( lpStr2 );

            }

            return dwRet;
        }


    default:
        {
            /*
            ** NewParms is allocated off the stack in order to minimize
            ** the number of calls to mciAlloc, and it means we do not
            ** have to remember to free it.
            */
            DWORD_PTR   NewParms[MCI_MAX_PARAM_SLOTS];

            /*
            ** dwStrMask is used to store a bitmap representation of which
            ** offsets into dwParam2 contain strings.  ie. bit 4 set
            ** means that dwParam2[4] is a string.
            */
            DWORD   dwStrMask       = 0L;

            /*
            ** fStrReturn is used as a reminder of whether a string return
            ** is expected or not.  If the return type is not a string
            ** we just copy the bytes back as is.  uReturnLength is the
            ** number of bytes to copy back.  dwParm2 is used to ease some
            ** of the addressing used to access the dwParam2 array.
            */
            BOOL        fStrReturn      = FALSE;
            UINT        uReturnLength   = 0;
            PDWORD_PTR  dwParm2         = (PDWORD_PTR)dwParam2;

            /*
            ** The remaining variables are used as we scan our way thru the
            ** command table.
            */
            LPWSTR      lpCommand, lpFirstParameter;
            LPSTR       lpReturnStrTemp;
            UINT        wID;
            DWORD       dwValue;
            UINT        wOffset32, wOffset1stParm32, uTable, uStrlenBytes;
            PDWORD_PTR  pdwParm32;
            DWORD       dwMask = 1;

            if (!dwParam2) {
                return mciSendCommandW( wDeviceID, wMessage, dwParam1, dwParam2);
            }

            /*
            ** Find the command table for the given command ID.
            ** If the command table is not there we have probably been
            ** given a duff device ID.  Anyway exit with an internal
            ** error.
            */
            lpCommand = FindCommandItem( wDeviceID, NULL, (LPWSTR)(UINT_PTR)wMessage,
                                         NULL, &uTable );
            if ( lpCommand == NULL ) {
                return MCIERR_UNSUPPORTED_FUNCTION;
            }
#if DBG
            ZeroMemory(NewParms, sizeof(NewParms));
#endif


            /*
            ** Copy callback field.
            */
            if ( dwParam1 & MCI_NOTIFY ) {
                NewParms[0] = dwParm2[0];
            }

            /*
            ** Skip past command entry
            */
            lpCommand = (LPWSTR)((LPBYTE)lpCommand +
                        mciEatCommandEntry( lpCommand, NULL, NULL ));

            /*
            ** Get and remember the first parameter
            */
            lpFirstParameter = lpCommand;

            /*
            ** Skip past the DWORD callback field
            */
            wOffset1stParm32 = 4;

            lpCommand = (LPWSTR)((LPBYTE)lpCommand +
                        mciEatCommandEntry( lpCommand, &dwValue, &wID ));
            /*
            ** If the first parameter is a return value, we have some
            ** special processing
            */
            if ( wID == MCI_RETURN ) {

                /*
                ** String return types are a special case.
                */
                if ( dwValue == MCI_STRING ) {

                    dprintf3(( "Found a return string" ));
                    /*
                    ** Get unicode string length in bytes and allocate
                    ** some storage, but only if a valid length has been
                    ** given.  Otherwise set this field to NULL, we must
                    ** use 0 here otherwise the MIPS compiler goes
                    ** ape Xxxx.  We set a flag to remind us to unthunk
                    ** the return string later.
                    **
                    ** Note that we are actually allocating lots of equally
                    ** sized storage here.  This saves on the number of times
                    ** that we call mciAlloc.
                    */
                    if ( uStrlenBytes = (UINT)BYTE_GIVEN_CHAR( dwParm2[2] ) ) {

                        NewParms[1] = (DWORD_PTR)mciAlloc( uStrlenBytes * 2 );
                        dprintf4(( "Allocated %d bytes for the return string at %x", uStrlenBytes, NewParms[1] ));

                        if ( NewParms[1] == 0 ) {

                            mciUnlockCommandTable( uTable );
                            return MCIERR_OUT_OF_MEMORY;
                        }

                        lpReturnStrTemp = (LPSTR)(NewParms[1] + uStrlenBytes);
                        fStrReturn = TRUE;
                    }
                    else {

                        NewParms[1] = (DWORD)0;
                    }

                    /*
                    ** Copy string length.
                    */
                    NewParms[2] = dwParm2[2];
                }

                /*
                ** Adjust the offset of the first parameter.
                */
                uReturnLength = mciGetParamSize( dwValue, wID );
                wOffset1stParm32 += uReturnLength;

                /*
                ** Save the new first parameter pointer
                */
                lpFirstParameter = lpCommand;
            }

            /*
            ** Walk through each flag
            */
            while ( dwMask != 0 ) {

                /*
                ** Is this bit set?
                */
                if ( (dwParam1 & dwMask) != 0 ) {

                    wOffset32 = wOffset1stParm32;
                    lpCommand = (LPWSTR)((LPBYTE)lpFirstParameter +
                                mciEatCommandEntry( lpFirstParameter,
                                                    &dwValue, &wID ));

                    /*
                    ** What parameter uses this bit?
                    */
                    while ( wID != MCI_END_COMMAND && dwValue != dwMask ) {

                        wOffset32 += mciGetParamSize( dwValue, wID );

                        if ( wID == MCI_CONSTANT ) {

                            while ( wID != MCI_END_CONSTANT ) {

                                lpCommand = (LPWSTR)((LPBYTE)lpCommand +
                                            mciEatCommandEntry( lpCommand,
                                                                NULL, &wID ));
                            }
                        }

                        lpCommand = (LPWSTR)((LPBYTE)lpCommand +
                                    mciEatCommandEntry( lpCommand,
                                                        &dwValue, &wID ));
                    }

                    if ( wID != MCI_END_COMMAND ) {

                        pdwParm32 = (PDWORD_PTR)((LPBYTE)NewParms + wOffset32);

                        if ( wID == MCI_STRING ) {

                            /*
                            ** Allocate a unicode string for this parameter
                            ** and set the flag.
                            */
                            *pdwParm32 = (DWORD_PTR)AllocUnicodeStr(
                                       (LPSTR)*(PDWORD_PTR)((LPBYTE)dwParm2 +
                                                                 wOffset32) );
                            //
                            // Turn wOffset32 into a bit mask.
                            // wOffset32 is the slot number offset in bytes
                            dwStrMask |= 1 << ((wOffset32 >> 2) - 1);

                            // Calculate the slot position (offset / 4)
                            // decrement to get the number of bits to shift
                            // shift 1 that number of bits left
                            // and OR into the existing dwStrMask.

#if DBG
                            dprintf3(( "String at %x (Addr %x) (UNICODE)= %ls", wOffset32/4, *pdwParm32 , *pdwParm32 ));
                            dprintf3(( "String at %x (Addr %x) (ASCII)  = %s",  wOffset32/4, *pdwParm32 , (LPSTR)*(PDWORD_PTR)((LPBYTE)dwParm2 + wOffset32) ));
#endif
                        }
                        else {    // not a string

                            /*
                            ** Otherwise copy the parameter as is, if
                            ** there is anything to copy...
                            */
                            wID = mciGetParamSize( dwValue, wID);

                            switch (wID) {
                                case 4:
                                    *pdwParm32 = *(LPDWORD)((LPBYTE)dwParm2 + wOffset32);
                                    break;

                                case 0:
                                    break;

                                default:
                                    // This will be sizeof(MCI_RECT) as of today (Jan 93)
                                    CopyMemory(pdwParm32, (LPBYTE)dwParm2 + wOffset32, wID);
                            }
                        }
                    }
                }

                /*
                ** Go to the next flag
                */
                dwMask <<= 1;
            }

            // If no strings needed converting.  Use the original parameter block
            if ( !(dwStrMask | fStrReturn)) {
                // No strings in parameters.  Use original parameter pointer
                dprintf3(( "NO strings for command %4X", wMessage ));
                dwRet = mciSendCommandW( wDeviceID, wMessage, dwParam1, dwParam2);
                uReturnLength = 0;  // We will not need to copy anything back

            } else {

                dprintf3(( "The unicode string mask is %8X   fStrReturn %x", dwStrMask, fStrReturn ));
                dwRet = (DWORD)mciSendCommandW( wDeviceID, wMessage, dwParam1, (DWORD_PTR)NewParms );
            }

            /*
            ** If there is a string return field we unthunk it here.
            */
            if ( fStrReturn && uStrlenBytes ) {

                /*
                ** If mciSendCommand worked then we need to convert the
                ** return string from unicode to ascii.
                */
                if ( MMSYSERR_NOERROR == dwRet ) {

                    UnicodeStrToAsciiStr( (PBYTE)lpReturnStrTemp,
                                     (PBYTE)lpReturnStrTemp + uStrlenBytes,
                                     (LPWSTR)NewParms[1] );

                    /*
                    ** Copy back the return string size.
                    */
                    dwParm2[2] = NewParms[2];

                    /* On return from mciSendCommandW the dwRetSize field is
                    ** equal to the number of characters copied to
                    ** lpInfoP->lpstrReturn less the NULL terminator.
                    ** So add one to lpInfoP->dwRetSize to include the NULL in
                    ** the strncpy below.
                    **
                    ** But ONLY if the original buffer was large enough.
                    */

//#ifdef DBCS
//fix kksuzuka: #3642
//have to copy byte length into ASCII buffer..
                    strncpy( (LPSTR)dwParm2[1], lpReturnStrTemp,
                        min( (size_t)(BYTE_GIVEN_CHAR(NewParms[2]+1)),
                             (size_t)(CHAR_GIVEN_BYTE(uStrlenBytes))) );
//#else
//                    strncpy( (LPSTR)dwParm2[1], lpReturnStrTemp,
//                        min( (UINT)NewParms[2] + 1,
//                             CHAR_GIVEN_BYTE(uStrlenBytes)) );
//#endif

#if DBG
                    dprintf3(( "Returned string (UNICODE)= %ls", NewParms[1] ));
                    dprintf3(( "Returned string (ASCII)  = %s",  dwParm2[1] ));
#endif
                }

                /*
                ** We need to free the string storage whether mciSendCommand
                ** worked or not.
                */
                dprintf4(( "Freeing returned string at %x", NewParms[1] ));
                mciFree( NewParms[1] );
            }

            /*
            ** Else if there is any other sort of return field unthunk
            ** it by copying across the bytes as is.
            */
            else if ( uReturnLength ) {

                dprintf3(( "Copying back %d returned bytes", uReturnLength ));
                CopyMemory( (LPDWORD)dwParam2 + 1, NewParms + 1, uReturnLength );
            }

            /*
            ** Now go through the dwStrMask and free each field as indicated
            ** by the set bits in the mask.  We start at 1 because the
            ** zero'th field is known to be a window handle.
            */
            wOffset32 = 1;

            for ( ; dwStrMask != 0; dwStrMask >>= 1, wOffset32++ ) {

                if ( dwStrMask & 1 ) {

                    /*
                    ** There is a string at NewParms[ wOffset32 ]
                    */
                    dprintf3(( "Freeing string at %d (%x) (UNICODE) = %ls", wOffset32, NewParms[ wOffset32 ], (LPWSTR)NewParms[ wOffset32 ] ));
                    FreeUnicodeStr( (LPWSTR)NewParms[ wOffset32 ] );
                }
            }

            dprintf4(( "Unlocking command table" ));
            mciUnlockCommandTable( uTable );
        }
    }
    return dwRet;
}


DWORD mciSendCommandW(
    MCIDEVICEID wDeviceID,
    UINT wMessage,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2)
{
    UINT  wRet;
    DWORD dwErr;
    MCI_INTERNAL_OPEN_INFO OpenInfo;

// Initialize the device list
    if (!MCI_bDeviceListInitialized && !mciInitDeviceList())
        return MCIERR_OUT_OF_MEMORY;

    dprintf3(("mciSendCommand, command=%x  Device=%x",wMessage, wDeviceID));

//
// Send the command.  This shell is responsible for adding the device ID
// to the error code if necessary
//
    OpenInfo.hCallingTask = GetCurrentTask();
    OpenInfo.lpstrParams = NULL;
    OpenInfo.lpstrPointerList = NULL;
    OpenInfo.wParsingError = 0;
    dwErr = mciSendCommandInternal( wDeviceID, wMessage,
                                    dwParam1, dwParam2, &OpenInfo);

    wRet = LOWORD(dwErr);

    dprintf4(("Return value from mciSendCommandInternal %x", wRet));

// If the return value contains a resource ID then clear it from the high word
// Note that for IA64 the first element of the structure pointed to by
// dwParam2 is always a DWORD_PTR.  However, the second element is not
// currently always a DWORD_PTR, some of the structures currenly have only
// a DWORD element in the second field.  Accordingly, we make sure to only
// update the first DWORD of the second field in the structure, that works
// in every case because none of the bits in 32 - 63 are ever set by existing
// code.
    if (dwErr & MCI_RESOURCE_RETURNED) {
        *(LPDWORD)((PDWORD_PTR)dwParam2+1) &= 0xFFFF;
    }

// If the error message is in a driver, store the driver ID in the high
// word of the error code
    if (wRet >= MCIERR_CUSTOM_DRIVER_BASE) {
        dwErr = (DWORD)wRet | ((DWORD)wDeviceID << 16);
    } else {
        dwErr = (DWORD)wRet;
    }

#if DBG
// Dump the error text if any to the debug terminal
// Note that dwErr != 0 is a VALID return for driver messages.  Only
// trap MCI messages
    if ((dwErr != 0) && (wMessage>=MCI_FIRST))
    {
        WCHAR strTemp[MAXERRORLENGTH];

        if (!mciGetErrorStringW( dwErr,
                                 strTemp,
                                 MAXERRORLENGTH ) ) {

            LoadStringW( ghInst, STR_MCISCERRTXT, strTemp,
                         MAXERRORLENGTH );
        }
        dprintf1(("mciSendCommand: %ls", strTemp));

    }
#endif

    //
    //  Somehow since 3.51 the priorities of threads in WOW have
    //  changed and now the application thread is running at a
    //  higher priority than that of regular threads (i.e. mciavi's
    //  worker thread).  Many applications that use MCI tend to
    //  poll the status of the MCI device that is playing.  This
    //  polling is causing the other threads in WOW to be starved
    //  and brings the playback of AVIs to a crawl.  This sleep
    //  will keep the application thread from buring so much of
    //  the CPU and allow other threads, for example MCIAVI, to
    //  do it's work.
    //
    if ( WinmmRunningInWOW )
    {
        Sleep(0);
    }

    return dwErr;
}

//***************************************************************************
//  mciColonizeDigit
//
// Grab colonized digit
// Return is number of bytes written to output (NOT including NULL)
// or 0 if out of room in output buffer (but is terminated anyway)
// If there is room then at least two digits are written, padded with '0'
// if necessary.  The function assumes that the buffer size is non-zero length,
// as this is checked in the function that calls the function that calls us.
//
//***************************************************************************
STATICFN UINT NEAR mciColonizeDigit(
    LPWSTR  lpstrOutput,
    CHAR    cDigit,
    UINT    uSize)
{
    UINT uCount = 0;

#if DBG
//  There is room for terminating NULL
    if (uSize == 0) {
        dprintf(("MCI: Internal error!!"));
        return 0;
    }
#endif

    uCount = 2;

// If there is room for at least two digits
    if (uSize >= 3)
    {
        if (cDigit >= 100)
        {
            uCount = 3;
            if (uSize < 4)
                goto terminate;
            *lpstrOutput++ = (WCHAR)((cDigit / 100) % 10 + '0');
            cDigit = (CHAR)(cDigit % 100);
        }
        *lpstrOutput++ = (WCHAR)(cDigit / 10 + '0');
        *lpstrOutput++ = (WCHAR)(cDigit % 10 + '0');
    }

terminate:;
    *lpstrOutput++ = '\0';

// If we ran out of room then return an error
    return (uCount >= uSize) ? 0 : uCount;
}

/*
 * @doc INTERNAL MCI
 * @func BOOL | mciColonize | Convert a colonized dword into a string
 * representation
 *
 * @parm LPWSTR | lpstrOutput | Output buffer
 *
 * @parm UINT | uLength | Size of output buffer
 *
 * @parm DWORD | dwData | Value to convert
 *
 * @parm UINT | uType | Either MCI_COLONIZED3_RETURN or
 * MCI_COLONIZED4_RETURN is set (HIWORD portion only!)
 *
 * @comm Example:  For C4, 0x01020304 is converted to "04:03:02:01"
 *                 For C3, 0x01020304 is converted to "04:03:02"
 *
 * @rdesc FALSE if there is not enough room in the output buffer
 *
 */
STATICFN BOOL NEAR mciColonize(
    LPWSTR lpstrOutput,
    UINT uLength,
    DWORD dwData,
    UINT uType)
{
    LPSTR lpstrInput = (LPSTR)&dwData; // For stepping over each byte of input
    UINT uSize;
    int i;

    for (i = 1; i <= (uType & HIWORD(MCI_COLONIZED3_RETURN) ? 3 : 4); ++i)
    {
        uSize = mciColonizeDigit( lpstrOutput, *lpstrInput++, uLength);

        if (uSize == 0)
            return FALSE;

        lpstrOutput += uSize;
        uLength -= uSize;
        if (i < 3 || i < 4 && uType & HIWORD(MCI_COLONIZED4_RETURN))
        {
            --uLength;
            if (uLength == 0)
                return FALSE;
            else
                *lpstrOutput++ = ':';
        }
    }
    return TRUE;
}

//***********************************************************************
//  mciConvertReturnValue
//
// Convert the return value to a return string
//
//***********************************************************************
UINT mciConvertReturnValue(
    UINT uType,
    UINT uErrCode,
    MCIDEVICEID wDeviceID,
    PDWORD_PTR   dwParams,
    LPWSTR lpstrReturnString,
    UINT uReturnLength ) // This is a character length
{
    UINT    wExternalTable;

    if (lpstrReturnString == NULL || uReturnLength == 0)
        return 0;

    switch (uType)
    {
        case MCI_INTEGER:
        case MCI_HWND:
        case MCI_HPAL:
        case MCI_HDC:
// Convert integer or resource return value to string
            if (uErrCode & HIWORD(MCI_RESOURCE_RETURNED))
            {
                int nResId = HIWORD(dwParams[1]);
                LPMCI_DEVICE_NODE nodeWorking;
                HANDLE hInstance;

                mciEnter("mciConvertReturnValue");

                nodeWorking = MCI_lpDeviceList[wDeviceID];

                mciLeave("mciConvertReturnValue");

                if (nodeWorking == NULL)
                {
// Return blank string on memory error
                    dprintf1(("mciConvertReturnValue Warning:NULL device node"));
                    break;
                }

// Return value is a resource
                if (uErrCode & HIWORD(MCI_RESOURCE_DRIVER))
                {
// Return string ID belongs to driver
                    hInstance = nodeWorking->hDriver;
       // WAS       hInstance = nodeWorking->hCreatorTask;

                    wExternalTable = nodeWorking->wCustomCommandTable;
                } else
                {
                    wExternalTable = nodeWorking->wCommandTable;
                    hInstance = ghInst;
                }

// Try to get string from custom or device specific external table
                if ( wExternalTable == MCI_TABLE_NOT_PRESENT ||
                     command_tables[wExternalTable].hModule == NULL ||

                    LoadStringW( command_tables[wExternalTable].hModule,
                                 nResId,
                                 lpstrReturnString,
                                 uReturnLength ) == 0 )
                {
// Try to get string from CORE.MCI if it's not from the driver
                    if (hInstance != ghInst ||
                        command_tables[0].hModule == NULL ||
                        LoadStringW( command_tables[0].hModule, nResId,
                                     lpstrReturnString,
                                     uReturnLength ) == 0) {

// Get string from custom module or WINMM.DLL
                        LoadStringW( hInstance, nResId, lpstrReturnString,
                                     uReturnLength);
                    }
                }

            } else if (uErrCode & HIWORD(MCI_COLONIZED3_RETURN) ||
                        uErrCode & HIWORD(MCI_COLONIZED4_RETURN))
            {
                if (!mciColonize (lpstrReturnString,
                                uReturnLength, (DWORD)dwParams[1], uErrCode))
                    return MCIERR_PARAM_OVERFLOW;
            } else
// Convert integer return value to string
// NEED BETTER ERROR CHECKING        !!LATER!!
// MUST FIND A VERSION OF THIS WHICH WON'T OVERFLOW OUTPUT BUFFER
            {
                DWORD dwTemp;

// Need room for a sign, up to ten digits and a NULL
                if (uReturnLength < 12)
                    return MCIERR_PARAM_OVERFLOW;

                if (uType == MCI_STRING ||
                    uErrCode == HIWORD(MCI_INTEGER_RETURNED))
                    dwTemp = *(LPDWORD)dwParams[1];
                else
                    dwTemp = (DWORD)dwParams[1];
                wsprintfW(lpstrReturnString, szLongFormat, dwTemp);
            }
            break;
        case MCI_RECT:
// Need from for 4 times (a sign plus 5 digits) plus three spaces and a NULL
            if (uReturnLength < 4 * 6 + 4)
                return MCIERR_PARAM_OVERFLOW;

            wsprintfW (lpstrReturnString, szRectFormat,
                          ((PMCI_ANIM_RECT_PARMS)dwParams)->rc.left,
                          ((PMCI_ANIM_RECT_PARMS)dwParams)->rc.top,
                          ((PMCI_ANIM_RECT_PARMS)dwParams)->rc.right,
                          ((PMCI_ANIM_RECT_PARMS)dwParams)->rc.bottom);
            break;
        default:
// Only support INTEGERs & MIXED
            dprintf1(("mciConvertReturnValue Warning:  Unknown return type"));
            return MCIERR_PARSER_INTERNAL;
    }
    return 0;
}

//***********************************************************************
//  mciSeparateCommandParts
//
// Pull off the command name and device name from the command string,
// leaving *lplpstrCommand pointing past the device name
//
// Returns 0 or an error code on failure.  If successful, the caller must
// free the pstrCommandName and pstrDeviceName
//
// If bCompound then check for a '!' separator in the extracted device name
// and return only the element part.  This is done so that inter-task
// commands to auto-opened devices will include the correct device name
//
//***********************************************************************
STATICFN DWORD NEAR mciSeparateCommandParts(
    LPCWSTR FAR *lplpstrCommand,
    BOOL bCompound,
    LPWSTR FAR *lplpstrCommandName,
    LPWSTR FAR *lplpstrDeviceName)
{
    LPWSTR lpstrCommand;
    UINT uErr;

// Localize the input
    lpstrCommand = (LPWSTR)*lplpstrCommand;

// Remove leading spaces

    while (*lpstrCommand == ' ') {
        ++lpstrCommand;
    }

    if (*lpstrCommand == '\0') {
        return MCIERR_MISSING_COMMAND_STRING;
    }

// Pull the command name off the front of the command string
   if ((uErr = mciEatToken ( (LPCWSTR *)&lpstrCommand, ' ', lplpstrCommandName, FALSE))
       != 0) {
       return uErr;
   }

// Skip past spaces
    while (*lpstrCommand == ' ') {
        ++lpstrCommand;
    }

// If we're looking for compound elements then yank off any leading
// device type if it is not the open command
    if (bCompound && lstrcmpiW( wszOpen, *lplpstrCommandName) != 0)
    {
        LPWSTR lpstrTemp = lpstrCommand;
        while (*lpstrTemp != '\0')
        {
            if (*lpstrTemp == '!')
            {
// A ! was found so skip past it
                lpstrCommand = lpstrTemp + 1;
                break;
            } else
                ++lpstrTemp;
        }
    }

// Pull the device name off of the command string
    if ((uErr = mciEatToken( (LPCWSTR *)&lpstrCommand, ' ', lplpstrDeviceName, FALSE))
        != 0)
    {
        mciFree (*lplpstrCommandName);
        return uErr;

    }

// Fix up the results
    *lplpstrCommand = lpstrCommand;

    return 0;
}


/*--------------------------------------------------------------------*\
 * mciSendSystemString
 *
\*--------------------------------------------------------------------*/
STATICFN DWORD mciSendSystemString(
    LPCWSTR lpstrCommand,
    DWORD dwAdditionalFlags,
    LPWSTR lpstrReturnString,
    UINT uReturnLength)
{
    DWORD dwRet;
    LPMCI_SYSTEM_MESSAGE lpMessage;
    DWORD    CurDirSize;

    dprintf2(("\nmciSendSystemString(%ls)", lpstrCommand));

    if (!CreatehwndNotify()) {
        dprintf1(("NULL notification window handle"));
        return MCIERR_INTERNAL;
    }

    // Get a buffer to hold the current path PLUS an MCI_SYSTEM_MESSAGE structure

    CurDirSize = GetCurrentDirectoryW( 0, NULL );  // Get size required.

                                       // Remember the NULL is not included
    if ( !CurDirSize ) {               // Add 1 for the terminator
        dprintf1(("NULL current path"));
        return MCIERR_GET_CD;
    }
    CurDirSize++;

    if (NULL != (lpMessage = mciAlloc( sizeof(MCI_SYSTEM_MESSAGE)
                                       + BYTE_GIVEN_CHAR( CurDirSize ) ))) {

        LPWSTR lpstrPath = (LPWSTR)( (LPBYTE)lpMessage
                                             + sizeof( MCI_SYSTEM_MESSAGE ) );

        if ( GetCurrentDirectoryW( CurDirSize, lpstrPath ) ) {
            lpMessage->lpstrCommand = (LPWSTR)lpstrCommand;
            lpMessage->dwAdditionalFlags = dwAdditionalFlags;
            lpMessage->lpstrReturnString = lpstrReturnString;
            lpMessage->uReturnLength = uReturnLength;
#if DBG
            if ((0 == uReturnLength) && (0 != lpstrReturnString)) {
                dprintf1((" ******** Return length 0, non 0 return address"));
            }
#endif
            lpMessage->hCallingTask = GetCurrentTask();
            lpMessage->lpstrNewDirectory = lpstrPath;
            // This is where we need to do some thread stuff
            dwRet = (DWORD)SendMessage(hwndNotify, MM_MCISYSTEM_STRING, 0, (LPARAM)lpMessage);
            //dwRet = mciSendStringInternal (NULL, NULL, 0, NULL, lpMessage);
        } else {
            dprintf1(("mciSendSystemString: cannot get current directory\n"));
            dwRet = MCIERR_GET_CD;
        }
        mciFree(lpMessage);
    } else {
        dprintf1(("mciSendSystemString: cannot allocate message block\n"));
        dwRet = MCIERR_OUT_OF_MEMORY;
    }
    return dwRet;
}

/*--------------------------------------------------------------------*\
 * mciRelaySystemString
 *
 * Internal:
 *
\*--------------------------------------------------------------------*/
DWORD mciRelaySystemString(
    LPMCI_SYSTEM_MESSAGE lpMessage)
{
    DWORD    dwRet;
    LPWSTR   lpstrOldPath;
    DWORD    CurDirSize;

    lpstrOldPath = 0;   // Initialise to remove warning message

#if DBG
    dprintf2(("mciRelaySystemString(%ls)", lpMessage->lpstrCommand));
#endif

    // Get a buffer to hold the current path

    CurDirSize = GetCurrentDirectoryW(0, lpstrOldPath);  // Get size required.
                                       // Remember the NULL is not included
    if (!CurDirSize) {                 // Add 1 for the terminator AFTER testing
        dprintf1(("NULL current path")); // for 0 from GetCurrentDirectory
        return MCIERR_INTERNAL;
    }
    CurDirSize++;

    /*
     * Allocate space to hold the current path
     * Fill the allocated space with the current path
     * Set the new current directory to that in the message
     * Execute the MCI command via SentStringInternal
     * Reset to old current directory
     *
     * This code is not reentrant on the same PROCESS!!
     */
    if (NULL != (lpstrOldPath = mciAlloc( BYTE_GIVEN_CHAR(CurDirSize) ))) {

        if (GetCurrentDirectoryW(CurDirSize, lpstrOldPath)) {

            if (SetCurrentDirectoryW(lpMessage->lpstrNewDirectory)) {
                dwRet = mciSendStringInternal (NULL, NULL, 0, NULL, lpMessage);
                if (!SetCurrentDirectoryW(lpstrOldPath)) {
                    dprintf1(("mciRelaySystemString: WARNING, cannot restore path\n"));
                }

            } else {
                dprintf1(("mciRelaySystemString: cannot set new path\n"));
                dwRet = MCIERR_SET_CD;
            }

        } else {

            dprintf1(("mciRelaySystemString: cannot get old path\n"));
            dwRet = MCIERR_GET_CD;
        }

        mciFree(lpstrOldPath);

    } else {
        dprintf1(("mciRelaySystemString: cannot allocate old path\n"));
        dwRet = MCIERR_OUT_OF_MEMORY;
    }

    return dwRet;
}

//***********************************************************************
// mciFindNotify
//
// Returns TRUE if "notify" is contained in string with leading blank
// and trailing blank or '\0'
//***********************************************************************
STATICFN BOOL  mciFindNotify(
    LPWSTR lpString)
{
    while (*lpString != '\0')
    {
        // "notify" must be preceded by a blank
        if (*lpString++ == ' ')
        {
            LPWSTR lpTemp;

            lpTemp = wszNotify;
            while (*lpTemp != '\0' && *lpString != '\0' &&
                   *lpTemp == MCI_TOLOWER(*lpString))
            {
                ++lpTemp;
                ++lpString;
            }
            // "notify" must be followed by a blank or a null
            if (*lpTemp == '\0' &&    // implies that wszNotify was found
                (*lpString == '\0' || *lpString == ' '))
                return TRUE;
        }
    }
    return FALSE;
}

/*
 * @doc INTERNAL MCI
 *
 * @func UINT | mciAutoOpenDevice | Try to auto-open the given device and
 * then send the given command with notification sent to the system task
 * window proc which sends a close command to the device on receipt
 *
 * @parm LPWSTR | lpstrDeviceName | The device name to open
 *
 * @parm LPWSTR | lpstrCommand | The full command to send including the
 * device name which must be the same as lpstrDeviceName
 *
 * @parm LPWSTR | lpstrReturnString | The caller's return string buffer
 *
 * @parm UINT | uReturnLength | Size of the caller's return string buffer
 *
 * @rdesc The errorcode to return to the user
 */
STATICFN UINT NEAR mciAutoOpenDevice(

    LPWSTR lpstrDeviceName,
    LPWSTR lpstrCommand,
    LPWSTR lpstrReturnString,
    UINT uReturnLength)
{
    LPWSTR lpstrTempCommand, lpstrTempReturn = NULL;
    UINT uErr;

    dprintf2(("mciAutoOpenDevice(%ls, %ls)", lpstrDeviceName, lpstrCommand));

//
//  Don't allow recursive auto opens on the mciWindow thread!
//  This can happen when the device auto closes between a command (eg
//  status) being issued on the client thread and executed on the
//  mciWindow thread.
//
//  mciSendStringW will detect this return code and try again - probably
//  causing the device to be auto-opened on the caller's thread.
//
    if (PtrToUlong(GetCurrentTask()) == mciWindowThreadId) {
        return MCIERR_AUTO_ALREADY_CLOSED;
    }


// "notify" not allowed.  This will be found by the parser but the wrong
// error message will be returned.
    if (mciFindNotify (lpstrCommand)) {
        return MCIERR_NOTIFY_ON_AUTO_OPEN;
    }

// Build the command string "open <device name>"

// Must be GMEM_SHARE for system task
// "open" + blank + device name + NULL
    if ( (lpstrTempCommand = mciAlloc(
                                 BYTE_GIVEN_CHAR( wcslen(lpstrDeviceName) ) +
                                /* Sizeof(wszOpen) == OPEN+BLANK */
                                /* sizeof(wszOpen) includes the NULL terminator */
                                sizeof( wszOpen ) +
                                sizeof( L' ' ) ) ) == NULL) {
        return MCIERR_OUT_OF_MEMORY;
    }

#ifdef WHICH_IS_BEST
    wcscpy (lpstrTempCommand, wszOpen);
    wcscat (lpstrTempCommand, L" ");
    wcscat (lpstrTempCommand, lpstrDeviceName);
#else
    wsprintfW(lpstrTempCommand, szCmdFormat, wszOpen, lpstrDeviceName);
#endif

// Get the open string into the system task via a SendMessage() to mmWndProc
    uErr = (UINT)mciSendSystemString (lpstrTempCommand, 0L, NULL, 0);

    mciFree (lpstrTempCommand);

    if (uErr != 0) {
        return uErr;
    }

    lpstrTempCommand = NULL;
    // Must make a GMEM_SHARE copy of the return string for system task
    if ( lpstrReturnString != NULL ) {
       if ((lpstrTempReturn = mciAlloc(
                              BYTE_GIVEN_CHAR(uReturnLength + 1) )) == NULL )
        {
            // Close the device
            mciDriverNotify (hwndNotify, mciGetDeviceIDW( lpstrDeviceName), 0);
            return MCIERR_OUT_OF_MEMORY;
        }
#if DBG
        *lpstrTempReturn = 0;
#endif
    }

// Get the user command string into the system task via a SendMessage()
// to mmWndProc
// The notification handle is also mmWndProc
    uErr = (UINT)mciSendSystemString( lpstrCommand, MCI_NOTIFY, lpstrTempReturn,
                                      uReturnLength);

// Copy the return string into the user's buffer
    if (lpstrReturnString != NULL) {
        if (uErr == 0) {
            wcscpy( lpstrReturnString, lpstrTempReturn);
        } else { //  ERROR and no string to be copied
            WinAssert(!*lpstrTempReturn);
        }
        mciFree( lpstrTempReturn);
    }


// If there was an error we must close the device
    if (uErr != 0)
    {
        mciAutoCloseDevice( lpstrDeviceName);
    }

    return uErr;
}
//*************************************************************************
// mciSendStringInternal
//
// Identical to mciSendString() but the lpMessage parameter is tacked on
//
// lpMessage comes from inter-task mciSendString and includes an
// hCallingTask item which is sent down the the OPEN command
//
//*************************************************************************
STATICFN DWORD mciSendStringInternal(
    LPCWSTR lpstrCommand,
    LPWSTR  lpstrReturnString,
    UINT   uReturnLength,       // This is a character length - NOT bytes
    HANDLE hCallback,
    LPMCI_SYSTEM_MESSAGE lpMessage)
{
    UINT    wID;
    UINT    uLen;
    UINT    uErr = 0;
    UINT    uConvertReturnValue;
    UINT    wMessage;
    MCIDEVICEID  wDeviceID;
    PDWORD_PTR lpdwParams = NULL;
    DWORD   dwReturn, dwFlags = 0, dwAdditionalFlags = 0;
    LPWSTR   lpCommandItem;
    DWORD   dwErr = 0, dwRetType;
    UINT    wTable = (UINT)MCI_TABLE_NOT_PRESENT;
    LPWSTR   lpstrDeviceName = NULL;
    LPWSTR   lpstrCommandName = NULL;
    LPWSTR   FAR *lpstrPointerList = NULL;
    LPWSTR   lpstrCommandStart;
    HANDLE  hCallingTask;
    UINT    wParsingError;
    BOOL    bNewDevice;
    LPWSTR   lpstrInputCopy = NULL;

    // Did this call come in from another task
    if (lpMessage != NULL)
    {
        dprintf3(("mciSendStringInternal: remote task call"));
        // Yes so restore info
        lpstrCommand      = lpMessage->lpstrCommand;
        dwAdditionalFlags = lpMessage->dwAdditionalFlags;
        lpstrReturnString = lpMessage->lpstrReturnString;
        uReturnLength     = lpMessage->uReturnLength;

#if DBG
        if ((0 == uReturnLength) && (0 != lpstrReturnString)) {
            dprintf((" -------- Return length 0, non 0 return address"));
        }
#endif
        hCallback         = hwndNotify;
        hCallingTask      = lpMessage->hCallingTask;
        lpstrInputCopy    = NULL;
    } else
    {
        BOOL bInQuotes = FALSE;
        // No, so set hCallingTask to current thread
        hCallingTask = GetCurrentTask();

        if (lpstrCommand == NULL) {
            return MCIERR_MISSING_COMMAND_STRING;
        }
        dprintf2(("mciSendString command ->%ls<-",lpstrCommand));

        // Make a copy of the input string and convert tabs to spaces except
        // when inside a quoted string

        if ( (lpstrInputCopy = mciAlloc(
                    BYTE_GIVEN_CHAR( wcslen(lpstrCommand) + 1 ) ) ) == NULL ) {
            return MCIERR_OUT_OF_MEMORY;
        }
        wcscpy(lpstrInputCopy, lpstrCommand);  // Copies to the allocated area
        lpstrCommand = lpstrInputCopy;           // Reset string pointer to copy
        lpstrCommandStart = (LPWSTR)lpstrCommand;

        while (*lpstrCommandStart != '\0')
        {
            if (*lpstrCommandStart == '"') {
                bInQuotes = !bInQuotes;
            }
            else if (!bInQuotes && *lpstrCommandStart == '\t') {
                *lpstrCommandStart = ' ';
            }
            ++lpstrCommandStart;
        }
    }
    lpstrCommandStart = (LPWSTR)lpstrCommand;

    if (lpstrReturnString == NULL) {

        // As an additional safeguard against writing into
        // the output buffer when the return string pointer is NULL,
        // set its length to 0
        uReturnLength = 0;

    } else {
#if DBG
        if (0 == uReturnLength) {
            dprintf(("Return length of zero, but now writing to return string"));
        }
#endif
        // Set return to empty string so that it won't print out garbage if not
        // touched again
        *lpstrReturnString = '\0';
    }

    // Pull the command name and device name off the command string
    if ((dwReturn = mciSeparateCommandParts( (LPCWSTR FAR *)&lpstrCommand,
                                             lpMessage != NULL,
                                             &lpstrCommandName,
                                             &lpstrDeviceName)) != 0)
        goto exitfn;

    // Get the device id (if any) of the given device name
    wDeviceID = mciGetDeviceIDW(lpstrDeviceName);

    // Allow "new" for an empty device name
    if (wDeviceID == 0 && lstrcmpiW (lpstrDeviceName, wszNew) == 0)
    {
        bNewDevice = TRUE;
        *lpstrDeviceName = '\0';
    } else {
        bNewDevice = FALSE;
    }

//  // If the call does not come from another task
//  if (MCI_VALID_DEVICE_ID(wDeviceID) && hCallingTask == GetCurrentTask())
//  {
//      LPMCI_DEVICE_NODE nodeWorking = MCI_lpDeviceList[wDeviceID];
//      if (nodeWorking == NULL)
//      {
//          uErr = MCIERR_INTERNAL;
//          goto cleanup;
//      }
//      // Was the device opened by this task
//      if (nodeWorking->hOpeningTask != nodeWorking->hCreatorTask)
//      // No so send the string inter-task
//      {
//          mciFree(lpstrCommandName);
//          mciFree(lpstrDeviceName);
//          dwReturn = mciSendSystemString (lpstrCommandStart, lpstrReturnString,
//                                      uReturnLength);
//          goto exitfn;
//      }
//  }

    // Look up the command name
    wMessage = mciParseCommand( wDeviceID, lpstrCommandName, lpstrDeviceName,
                                &lpCommandItem, &wTable);

    // If the device was auto-opened the request will go to the auto thread.
    // We do not hang around to find out what happens.  (The device could
    // close at any time.)

    mciEnter("mciSendStringInternal");

    if (MCI_VALID_DEVICE_ID(wDeviceID))
    {
        LPMCI_DEVICE_NODE nodeWorking;

        nodeWorking = MCI_lpDeviceList[wDeviceID];

        // Is there a pending auto-close message?
        if (ISAUTOCLOSING(nodeWorking))
        {
            uErr = MCIERR_DEVICE_LOCKED;
            mciLeave("mciSendStringInternal");
            goto cleanup;

        // If the call does not come from another task and is not owned by this task
        // and is not the SYSINFO command
        } else if (lpMessage == NULL &&
            nodeWorking->hOpeningTask != nodeWorking->hCreatorTask &&
            wMessage != MCI_SYSINFO)
        // Send the string inter-task
        {
            if ( mciFindNotify( lpstrCommandStart) )
            {
                uErr = MCIERR_NOTIFY_ON_AUTO_OPEN;
                mciLeave("mciSendStringInternal");
                goto cleanup;
            }
            else
            {
                LPWSTR    lpstrReturnStringCopy;

                mciFree(lpstrCommandName);
                mciFree(lpstrDeviceName);
                mciUnlockCommandTable (wTable);

                if (uReturnLength) {
                    lpstrReturnStringCopy = mciAlloc (
                                          BYTE_GIVEN_CHAR(uReturnLength + 1) );
                } else {
                    lpstrReturnStringCopy = NULL;
                }

                mciLeave("mciSendStringInternal");

                // If we failed to allocate a return string we return
                // an error.  Note: return strings are optional
                if ((uReturnLength==0) || (lpstrReturnStringCopy != NULL) )
                {
                    dwReturn = mciSendSystemString( lpstrCommandStart,
                                                    0L,
                                                    lpstrReturnStringCopy,
                                                    uReturnLength);
                    if (uReturnLength) {
                        wcscpy( lpstrReturnString, lpstrReturnStringCopy);
                        mciFree( lpstrReturnStringCopy);
                    }
                } else {
                    dwReturn = MCIERR_OUT_OF_MEMORY;
                }
                goto exitfn;
            }
        } else {
            mciLeave("mciSendStringInternal");
        }
    }
    else {
        mciLeave("mciSendStringInternal");
    }

    // There must be a device name (except for the MCI_SOUND message)
    if (*lpstrDeviceName == '\0' && wMessage != MCI_SOUND && !bNewDevice)
    {
        uErr = MCIERR_MISSING_DEVICE_NAME;
        goto cleanup;
    }

    // The command must appear in the parser tables
    if (wMessage == 0)
    {
        uErr = MCIERR_UNRECOGNIZED_COMMAND;
        goto cleanup;
    }

    // The "new" device name is only legal for the open message
    if (bNewDevice)
    {
        if (wMessage != MCI_OPEN)
        {
            uErr = MCIERR_INVALID_DEVICE_NAME;
            goto cleanup;
        }
    }

    // If there was no device ID
    if (wDeviceID == 0)
    {
        // If auto open is not legal (usually internal commands)
        if (MCI_CANNOT_AUTO_OPEN (wMessage))
        {
            // If the command needs an open device
            if (!MCI_DO_NOT_NEED_OPEN (wMessage))
            {
                dprintf1(("mciSendStringInternal: device needs open"));
                uErr = MCIERR_INVALID_DEVICE_NAME;
                goto cleanup;
            }
        } else {
            // If auto open is legal try to open the device automatically
            uErr = mciAutoOpenDevice( lpstrDeviceName, lpstrCommandStart,
                                      lpstrReturnString, uReturnLength);
            // wDeviceID = MCI_ALL_DEVICE_ID;
            goto cleanup;
        }
    }

    //
    //   Parse the command parameters
    //
    if ((lpdwParams = (PDWORD_PTR)mciAlloc( sizeof(DWORD_PTR) * MCI_MAX_PARAM_SLOTS))
        == NULL)
    {
        uErr = MCIERR_OUT_OF_MEMORY;
        goto cleanup;
    }

    uErr = mciParseParams( wMessage, lpstrCommand, lpCommandItem, &dwFlags,
                           (LPWSTR)lpdwParams,
                           MCI_MAX_PARAM_SLOTS * sizeof(DWORD_PTR),
                           &lpstrPointerList, &wParsingError);
    if (uErr != 0) {
        goto cleanup;
    }

    // The 'new' device keyword requires an alias
    if (bNewDevice && !(dwFlags & MCI_OPEN_ALIAS))
    {
        uErr = MCIERR_NEW_REQUIRES_ALIAS;
        goto cleanup;
    }

    // Parsed OK so execute command

    // Special processing for the MCI_OPEN message's parameters
    if (wMessage == MCI_OPEN)
    {
        // Manually reference the device type and device element
        if (dwFlags & MCI_OPEN_TYPE)
        {
            // The type name was specified explicitly as a parameter
            // so the given device name is the element name
            ((LPMCI_OPEN_PARMSW)lpdwParams)->lpstrElementName = lpstrDeviceName;
            dwFlags |= MCI_OPEN_ELEMENT;
        } else
        {
            // A type must be explicitly specified when "new" is used
            if (bNewDevice)
            {
                uErr = MCIERR_INVALID_DEVICE_NAME;
                goto cleanup;
            }

            // The device type is the given device name.  There is no element name
            ((LPMCI_OPEN_PARMSW)lpdwParams)->lpstrDeviceType = lpstrDeviceName;
            ((LPMCI_OPEN_PARMSW)lpdwParams)->lpstrElementName = NULL;
            dwFlags |= MCI_OPEN_TYPE;
        }
    }

    else if (wMessage == MCI_SOUND && *lpstrDeviceName != '\0')
    {
        // Kludge the sound name for SOUND
        // mciToLower (lpstrDeviceName);
        if (lstrcmpiW(lpstrDeviceName, wszNotify) == 0)
        {
            *lpstrDeviceName = '\0';
            dwFlags |= MCI_NOTIFY;
        }
        else if ( lstrcmpiW( lpstrDeviceName, wszWait ) == 0)
        {
            *lpstrDeviceName = '\0';
            dwFlags |= MCI_WAIT;
        }
        else
        {
            ((LPMCI_SOUND_PARMSW)lpdwParams)->lpstrSoundName = lpstrDeviceName;
            dwFlags |= MCI_SOUND_NAME;
        }
    }

    // Figure out what kind of return value to expect

    // Initialize flag
    uConvertReturnValue = 0;
    // Skip past header
    uLen = mciEatCommandEntry (lpCommandItem, NULL, NULL);

    // Get return value (if any)
    mciEatCommandEntry ( (LPWSTR)((LPBYTE)lpCommandItem + uLen),
                         &dwRetType, &wID);
    if (wID == MCI_RETURN)
    {
        // There is a return value
        if (wDeviceID == MCI_ALL_DEVICE_ID && wMessage != MCI_SYSINFO)
        {
            uErr = MCIERR_CANNOT_USE_ALL;
            goto cleanup;
        }
        switch (dwRetType)
        {
            case MCI_STRING:
                // The return value is a string, point output buffer to user's buffer
                lpdwParams[1] = (DWORD_PTR)lpstrReturnString;
                lpdwParams[2] = (DWORD_PTR)uReturnLength;
                break;
            case MCI_INTEGER:
            case MCI_HWND:
            case MCI_HPAL:
            case MCI_HDC:
                // The return value is an integer, flag to convert it to a string later
  // new        uConvertReturnValue = MCI_INTEGER;
  // new        break;
            case MCI_RECT:
                // The return value is an rect, flag to convert it to a string later
  // new        uConvertReturnValue = MCI_RECT;
  /* NEW */     uConvertReturnValue = (UINT)dwRetType;
                break;
#if DBG
            default:
                dprintf1(("mciSendStringInternal:  Unknown return type %d",dwRetType));
                break;
#endif
        }
    }

    // We don't need this around anymore
    mciUnlockCommandTable (wTable);
    wTable = (UINT)MCI_TABLE_NOT_PRESENT;

    /* Fill the callback entry */
    lpdwParams[0] = (DWORD_PTR)hCallback;

    // Kludge the type number for SYSINFO
    if (wMessage == MCI_SYSINFO) {
        ((LPMCI_SYSINFO_PARMS)lpdwParams)->wDeviceType =
            mciLookUpType(lpstrDeviceName);
    }

    // Now we actually send the command further into the bowels of MCI!

    // The INTERNAL version of mciSendCommand is used in order to get
    // special return description information encoded in the high word
    // of the return value and to get back the list of pointers allocated
    // by any parsing done in the open command
    {
        MCI_INTERNAL_OPEN_INFO OpenInfo;
        OpenInfo.lpstrParams = (LPWSTR)lpstrCommand;
        OpenInfo.lpstrPointerList = lpstrPointerList;
        OpenInfo.hCallingTask = hCallingTask;
        OpenInfo.wParsingError = wParsingError;
        dwErr = mciSendCommandInternal (wDeviceID, wMessage,
                                        dwFlags | dwAdditionalFlags,
                                        (DWORD_PTR)(LPDWORD)lpdwParams,
                                        &OpenInfo);
    // If the command was reparsed there may be a new pointer list
    // and the old one was free'd
        lpstrPointerList = OpenInfo.lpstrPointerList;
    }

    uErr = LOWORD(dwErr);

    if (uErr != 0) {
        // If command execution error
        goto cleanup;
    }

    // Command executed OK

    // See if a string return came back with an integer instead
    if (dwErr & MCI_INTEGER_RETURNED) {
        uConvertReturnValue = MCI_INTEGER;
    }

    // If the return value must be converted
    if (uConvertReturnValue != 0 && uReturnLength != 0) {
        uErr = mciConvertReturnValue( uConvertReturnValue, HIWORD(dwErr),
                                      wDeviceID, lpdwParams,
                                      lpstrReturnString, uReturnLength);
    }

cleanup:;
    if (wTable != MCI_TABLE_NOT_PRESENT) {
        mciUnlockCommandTable (wTable);
    }

    mciFree(lpstrCommandName);
    mciFree(lpstrDeviceName);
    if (lpdwParams != NULL) {
        mciFree (lpdwParams);
    }

    // Free any memory used by string parameters
    mciParserFree (lpstrPointerList);

    dwReturn =  (uErr >= MCIERR_CUSTOM_DRIVER_BASE ?
                (DWORD)uErr | (DWORD)wDeviceID << 16 :
                (DWORD)uErr);

#if DBG
    if (dwReturn != 0)
    {
        WCHAR strTemp[MAXERRORLENGTH];

        if (!mciGetErrorStringW( dwReturn, strTemp,
                                 sizeof(strTemp) / sizeof(WCHAR) ) ) {
            LoadStringW( ghInst, STR_MCISSERRTXT, strTemp,
                         sizeof(strTemp) / sizeof(WCHAR) );
        }
        else {
            dprintf1(( "mciSendString: %ls", strTemp ));
        }
    }
#endif

exitfn:
    if (lpstrInputCopy != NULL) {
        mciFree (lpstrInputCopy);
    }

#if DBG
    mciCheckLocks();
#endif

    return dwReturn;
}

/*
 * @doc EXTERNAL MCI
 *
 * @api DWORD | mciSendString | This function sends a command string to an
 *  MCI device.  The device that the command is sent to is specified in the
 *  command string.
 *
 * @parm LPCTSTR | lpstrCommand | Points to an MCI command string of the form:
 * [command] [device] [parameters].
 *
 * @parm LPTSTR | lpstrReturnString | Specifies a buffer for return
 *  information. If no return information is needed, you can specify
 *  NULL for this parameter.
 *
 * @parm UINT | uReturnLength | Specifies the size of the return buffer
 *  specified by <p lpstrReturnString>.
 *
 * @parm HANDLE | hCallback | Specifies a handle to a window to call back
 *  if "notify" was specified in the command string.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *  error information. The low-order word
 *  of the returned DWORD contains the error return value.
 *
 *  To get a textual description of <f mciSendString> return values,
 *  pass the return value to <f mciGetErrorString>.
 *
 *  The error returns listed for <f mciSendCommand> also apply to
 *  <f mciSendString>. The following error returns are unique to
 *  <f mciSendString>:
 *
 *  @flag MCIERR_BAD_CONSTANT | Unknown value for parameter.
 *
 *  @flag MCIERR_BAD_INTEGER | Invalid or missing integer in command.
 *
 *  @flag MCIERR_DUPLICATE_FLAGS | A flag or value was specified twice.
 *
 *  @flag MCIERR_MISSING_COMMAND_STRING | No command was specified.
 *
 *  @flag MCIERR_MISSING_DEVICE_NAME | No device name was specified.
 *
 *  @flag MCIERR_MISSING_STRING_ARGUMENT | A string value was
 *  missing from the command.
 *
 *  @flag MCIERR_NEW_REQUIRES_ALIAS | An alias must be used
 *  with the "new" device name.
 *
 *  @flag MCIERR_NO_CLOSING_QUOTE | A closing quotation mark is missing.
 *
 *  @flag MCIERR_NOTIFY_ON_AUTO_OPEN | The "notify" flag is illegal
 *  with auto-open.
 *
 *  @flag MCIERR_PARAM_OVERFLOW | The output string was not long enough.
 *
 *  @flag MCIERR_PARSER_INTERNAL | Internal parser error.
 *
 *  @flag MCIERR_UNRECOGNIZED_KEYWORD | Unknown command parameter.
 *
 * @xref mciGetErrorString mciSendCommand
 */
MCIERROR APIENTRY mciSendStringA(
    LPCSTR lpstrCommand,
    LPSTR  lpstrReturnString,
    UINT   uReturnLength,
    HWND   hwndCallback)
{
    MCIERROR    mciErr;
    LPWSTR      lpwstrCom;
    LPWSTR      lpwstrRet;
    LPSTR       lpstrTmp;
    UINT        len;

#ifdef DBG
    dprintf4(( "Entered mciSendString ASCII" ));
#endif

    // uReturnLength is a character count
    // len is now in bytes
    // WARNING:  The length field might only be valid if a return
    // address is given.  If NO return address is specified, then
    // we do not want to waste time allocating anything.

    if (!lpstrReturnString) {
        uReturnLength = 0;
    }

    len = BYTE_GIVEN_CHAR( uReturnLength );

    // We could make the following code slightly more efficient by
    // allocating a single area of size uReturnLength*2 bytes.
    if (len) {
        lpstrTmp = (LPSTR)mciAlloc( len );
        if ( lpstrTmp == (LPSTR)NULL ) {
                return MCIERR_OUT_OF_MEMORY;
        }

        lpwstrRet = (LPWSTR)mciAlloc( len );
        if ( lpwstrRet == (LPWSTR)NULL ) {
                mciFree( lpstrTmp );
                return MCIERR_OUT_OF_MEMORY;
        }
    } else {
        lpstrTmp = NULL;
        lpwstrRet = NULL;
    }

    lpwstrCom = AllocUnicodeStr( (LPSTR)lpstrCommand );

    if ( lpwstrCom == NULL ) {
        if (len) {
            mciFree( lpstrTmp );
            mciFree( lpwstrRet );
        }
        return MCIERR_OUT_OF_MEMORY;
    }

#ifdef DBG
    dprintf4(( "Unicode Command = %ls", lpwstrCom ));
    dprintf4(( "Ascii command = %s", lpstrCommand ));
#endif

    mciErr = mciSendStringW( lpwstrCom, lpwstrRet, uReturnLength, hwndCallback );

    dprintf4(( "mciSendStringW returned %d", mciErr ));

    if (len) {
	dprintf4(( "Copying Unicode string to Ascii: %ls", lpwstrRet));
        UnicodeStrToAsciiStr( (PBYTE)lpstrTmp, (PBYTE)lpstrTmp + len, lpwstrRet );
        strncpy( lpstrReturnString, lpstrTmp, uReturnLength );
	dprintf4(( "........done: %s", lpstrReturnString));

        mciFree( lpstrTmp );
        mciFree( lpwstrRet );
    }
    FreeUnicodeStr( lpwstrCom );
    return mciErr;
}

MCIERROR APIENTRY mciSendStringW(
    LPCWSTR lpstrCommand,
    LPWSTR  lpstrReturnString,
    UINT   uReturnLength,
    HWND hwndCallback)
{
    MCIERROR wRet;

    // Initialize the device list
    if (!MCI_bDeviceListInitialized && !mciInitDeviceList()) {
        return MCIERR_OUT_OF_MEMORY;
    }

    //
    // We can get return code MCIERR_AUTO_ALREADY_CLOSED if the device is
    // auto-open and appears to be open but when we get to the mciWindow
    // thread it has already closed.  In this case we try again.
    //

    do {
        wRet = mciSendStringInternal (lpstrCommand, lpstrReturnString,
                                      uReturnLength, hwndCallback, NULL);
    } while (wRet == MCIERR_AUTO_ALREADY_CLOSED);

    return wRet;
}

/*
 * @doc INTERNAL MCI
 *
 * @api BOOL | mciExecute | This function is a simplified version of the
 *  <f mciSendString> function.  It does not take a buffer for
 *  return information, and displays a dialog box when
 *  errors occur.
 *
 * @parm LPCSTR | lpstrCommand | Points to an MCI command string of the form:
 * [command] [device] [parameters].
 *
 * @rdesc TRUE if successful, FALSE if unsuccessful.
 *
 * @comm This function provides a simple interface to MCI from scripting
 *  languages.  For debugging, set the "mciexecute" entry in the
 *  [mmdebug] section of WIN.INI to 1 and detailed error information will
 *  be displayed in a dialog box.  If "mmcmd" is set to 0, only user-correctable
 *  error information will be displayed.
 *  THIS FUNCTION IS NOW OBSOLETE AND IS ONLY PRESENT FOR 16BIT COMPATIBILITY
 *  HENCE NO UNICODE VERSION IS PROVIDED
 *
 * @xref mciSendString
 */

BOOL APIENTRY mciExecute(
    LPCSTR lpstrCommand)
{
    WCHAR aszError[MAXERRORLENGTH];
    DWORD dwErr;
    HANDLE hName = 0;
    LPWSTR lpstrName = NULL;

    LPWSTR      lpwstrCom;

    lpwstrCom = AllocUnicodeStr( (LPSTR)lpstrCommand );

    if ( lpwstrCom == NULL ) {
        return FALSE;
    }

    dwErr = mciSendStringW(lpwstrCom, NULL, 0, NULL);
        FreeUnicodeStr( lpwstrCom );

    if (LOWORD(dwErr) == 0) {
        return TRUE;
    }

    if (!mciGetErrorStringW( dwErr, aszError, MAXERRORLENGTH )) {
        LoadStringW( ghInst, STR_MCIUNKNOWN, aszError, MAXERRORLENGTH );

    } else {

        if (lpwstrCom != NULL)
        {
            // Skip initial blanks
            while (*lpwstrCom == ' ') {
                ++lpwstrCom;
            }

            // Then skip the command
            while (*lpwstrCom != ' ' && *lpwstrCom != '\0') {
                ++lpwstrCom;
            }

            // Then blanks before the device name
            while (*lpwstrCom == ' ') ++lpwstrCom;

            // Now, get the device name
            if ( *lpwstrCom != '\0' &&
                   mciEatToken ((LPCWSTR *)&lpwstrCom, ' ', &lpstrName, FALSE)
                        != 0
               ) {
                dprintf1(("Could not allocate device name text for error box"));
            }
        }
    }

    MessageBoxW( NULL, aszError, lpstrName, MB_ICONHAND | MB_OK);

    if (lpstrName != NULL) {
        mciFree(lpstrName);
    }

    return FALSE;
}

/*
 * @doc EXTERNAL MCI
 *
 * @api BOOL | mciGetErrorString | This function returns a
 * textual description of the specified MCI error.
 *
 * @parm DWORD | dwError | Specifies the error code returned by
 *  <f mciSendCommand> or <f mciSendString>.
 *
 * @parm LPTSTR | lpstrBuffer | Specifies a pointer to a buffer that is
 *  filled with a textual description of the specified error.
 *
 * @parm UINT | uLength | Specifies the length of the buffer pointed to by
 *  <p lpstrBuffer>.
 *
 * @rdesc Returns TRUE if successful.  Otherwise, the given error code
 *  was not known.
 */
BOOL APIENTRY mciGetErrorStringA(
    DWORD dwError,
    LPSTR lpstrBuffer,
    UINT uLength)
{
    HANDLE hInst = 0;

    if (lpstrBuffer == NULL) {
        return FALSE;
    }

    // If the high bit is set then get the error string from the driver
    // otherwise get it from mmsystem.dll
    if (HIWORD(dwError) != 0) {

        mciEnter("mciGetErrorStringA");
        if (MCI_VALID_DEVICE_ID ((UINT)HIWORD(dwError))) {

            hInst = MCI_lpDeviceList[HIWORD (dwError)]->hDriver;
        }
        mciLeave("mciGetErrorStringA");

        if (hInst == 0) {
            hInst = ghInst;
            dwError = MCIERR_DRIVER;
        }
    } else {
        hInst = ghInst;
    }

    if (LoadStringA(hInst, LOWORD(dwError), lpstrBuffer, uLength ) == 0)
    {
        // If the string load failed then at least terminate the string
        if (uLength > 0) {
            *lpstrBuffer = '\0';
            dprintf1(("Failed to load resource string"));
        }

        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

BOOL APIENTRY mciGetErrorStringW(
    DWORD dwError,
    LPWSTR lpstrBuffer,
    UINT uLength)
{
    HANDLE hInst = 0;

    if (lpstrBuffer == NULL) {
        return FALSE;
    }

    // If the high bit is set then get the error string from the driver
    // otherwise get it from mmsystem.dll
    if (HIWORD(dwError) != 0) {

        mciEnter("mciGetErrorStringW");
        if (MCI_VALID_DEVICE_ID ((UINT)HIWORD(dwError))) {

            hInst = MCI_lpDeviceList[HIWORD (dwError)]->hDriver;
        }
        mciLeave("mciGetErrorStringW");

        if (hInst == 0) {
            hInst = ghInst;
            dwError = MCIERR_DRIVER;
        }
    } else {
        hInst = ghInst;
    }

    if (LoadStringW(hInst, LOWORD(dwError), lpstrBuffer, uLength ) == 0)
    {
        // If the string load failed then at least terminate the string
        if (uLength > 0) {
            *lpstrBuffer = '\0';
            dprintf1(("Failed to load resource string"));
        }

        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

#if 0
/*
 * Return non-zero if load successful
 */
BOOL MCIInit()
{
    return TRUE;
}

/*
 * Return non-zero if load successful
 */
void MCITerminate()
{
/*
    We would like to close all open devices here but cannot because of
    unknown WEP order
*/
    if (hMciHeap != NULL) {
        HeapDestroy(hMciHeap);
    }

    hMciHeap = NULL;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\mci.h ===
/***************************************************************************
 *  mci.h
 *
 *  Copyright (c) 1990-1998 Microsoft Corporation
 *
 *  private include file
 *
 *  History
 *
 *  17 Mar 92 - SteveDav - private file for MCI use
 *  30 Apr 92 - StephenE - Converted to Unicode
 *
 ***************************************************************************/


extern CRITICAL_SECTION mciCritSec;  // used to protect process global mci variables
extern  UINT cmciCritSec;   // enter'ed count
extern  UINT uCritSecOwner;   // thread id of critical section owner

#define IDI_MCIHWND 100
#define MCI_GLOBAL_PROCESS "MCIHWND.EXE"
#define MCI_SERVER_NAME    "MMSNDSRV"

#define SND_FREE 0x80000000

#ifndef DOSWIN32
BOOL ServerInit(VOID);
#endif

extern BOOL CreatehwndNotify(VOID);

#if DBG


    // Use mciCheckIn to check that we are within the critical section,
    // mciCheckOut that we are not in the critical section.  Neither
    // routine does anything on the free build.
    #define mciCheckIn()  (WinAssert(uCritSecOwner==GetCurrentThreadId()))
    #define mciCheckOut()  (WinAssert(uCritSecOwner!=GetCurrentThreadId()))

    #define mciEnter(id) dprintf4(("Entering MCI crit sec at %s   Current count is %d", id, cmciCritSec));    \
                        EnterCriticalSection(&mciCritSec),          \
                        uCritSecOwner=GetCurrentThreadId(),         \
                        ++cmciCritSec

    #define mciLeave(id) dprintf4(("Leaving MCI crit sec at %s", id)); mciCheckIn(); if(!--cmciCritSec) uCritSecOwner=0; LeaveCriticalSection(&mciCritSec)


#else
    // No counting or messages in the retail build
    #define mciCheckIn()
    #define mciCheckOut()
    #define mciEnter(id)  EnterCriticalSection(&mciCritSec)
    #define mciLeave(id)  LeaveCriticalSection(&mciCritSec)

#endif


#define mciFirstEnter(id) { mciCheckOut(); mciEnter(id);}

//
// Define the name of a handler entry point
//

#define MCI_HANDLER_PROC_NAME "DriverProc"

//
// Typedef the entry routine for a driver
//

typedef LONG (HANDLERPROC)(DWORD dwId, UINT msg, LONG lp1, LONG lp2);
typedef HANDLERPROC *LPHANDLERPROC;

//
// MCI driver info structure
//

#define MCI_HANDLER_KEY 0x49434D48 // "MCIH"

typedef struct _MCIHANDLERINFO {
    DWORD           dwKey;
    HANDLE          hModule;
    LPHANDLERPROC   lpHandlerProc;
    DWORD           dwOpenId;

} MCIHANDLERINFO, *LPMCIHANDLERINFO;

#ifndef MMNOMCI

#define SetMCIEvent(h) SetEvent(h);
#define ResetMCIEvent(h) ResetEvent(h);

#define LockMCIGlobal  EnterCriticalSection(&mciGlobalCritSec);

#define UnlockMCIGlobal LeaveCriticalSection(&mciGlobalCritSec);

// Although having two unicode file name may make this structure fairly
// large it is still less than a page.
typedef struct tagGlobalMci {
    UINT    msg;                        // Function required
    DWORD   dwFlags;                    // sndPlaySound flags
    LPCWSTR lszSound;                   //
    WCHAR   szSound[MAX_PATH];          //
    WCHAR   szDefaultSound[MAX_PATH];   // Default sound
} GLOBALMCI, * PGLOBALMCI;

extern PGLOBALMCI base;
extern HANDLE   hEvent;

/****************************************************************************

    MCI support

****************************************************************************/

#define ID_CORE_TABLE 200

#define MCI_VALID_DEVICE_ID(wID) ((wID) > 0 && (wID) < MCI_wNextDeviceID && MCI_lpDeviceList[wID])

// Make sure that no MCI command has more than this number of DWORD parameters
#define MCI_MAX_PARAM_SLOTS 20

/******* WARNING ******** Ascii specific ************************************/
#define MCI_TOLOWER(c)  ((WCHAR)((c) >= 'A' && (c) <= 'Z' ? (c) + 0x20 : (c)))
/****************************************************************************/

typedef struct tagCOMMAND_TABLE_TYPE
{
    HANDLE              hResource;
    HANDLE              hModule;        /* If not NULL then free module */
                                        /* when device is free'd        */
    UINT                wType;
    PUINT               lpwIndex;
    LPWSTR              lpResource;
#if DBG
    UINT                wLockCount;     /* Used for debugging */
#endif
} COMMAND_TABLE_TYPE;

typedef struct tagMCI_DEVICE_NODE {
    LPWSTR  lpstrName;       /* The name used in subsequent calls to         */
                             /* mciSendString to refer to the device         */
    LPWSTR  lpstrInstallName;/* The device name from system.ini              */
    DWORD   dwMCIOpenFlags;  /* Flags set on open may be:                    */
                             /*    MCI_OPEN_ELEMENT_ID                       */
                             /*                                              */
    DWORD_PTR   lpDriverData;    /* DWORD of driver instance data                */
    DWORD   dwElementID;     /* The element ID set by MCI_OPEN_ELEMENT_ID    */
    YIELDPROC fpYieldProc;   /* The current yield procedure if any           */
    DWORD   dwYieldData;     /* Data send to the current yield procedure     */
    MCIDEVICEID wDeviceID;   /* The ID used in subsequent calls to           */
                             /* mciSendCommand to refer to the device        */
    UINT    wDeviceType;     /* The type returned from the DRV_OPEN call     */
                             /* MCI_OPEN_SHAREABLE                           */
                             /* MCI_OPEN_ELEMENT_ID                          */
    UINT    wCommandTable;   /* The device type specific command table       */
    UINT    wCustomCommandTable;    /* The custom device command table if    */
                                    /* any (-1 if none)                      */
    HANDLE  hDriver;         /* Module instance handle for the driver        */
    HTASK   hCreatorTask;    /* The task context the device is in            */
    HTASK   hOpeningTask;    /* The task context which sent the open command */
    HANDLE  hDrvDriver;      /* The installable driver handle                */
    DWORD   dwMCIFlags;      /* General flags for this node                  */
} MCI_DEVICE_NODE;
typedef MCI_DEVICE_NODE *LPMCI_DEVICE_NODE;

/* Defines for dwMCIFlags */
#define MCINODE_ISCLOSING       0x00000001   /* Set during close to lock out other commands */
#define MCINODE_ISAUTOCLOSING   0x00010000   /* Set during auto-close to lock out other    */
                                             /* commands except an internally generated close */
#define MCINODE_ISAUTOOPENED    0x00020000   /* Device was auto opened */
#define MCINODE_16BIT_DRIVER    0x80000000   // Device is a 16-bit driver

// Macros for accessing the flag bits.  Using macros is not normally my
// idea of fun, but this case seems to be justified on the grounds of
// being able to maintain control over who is accessing the flags values.
// Note that the flag value are only needed in the header file.
#define ISCLOSING(node)     (((node)->dwMCIFlags) & MCINODE_ISCLOSING)
#define ISAUTOCLOSING(node) (((node)->dwMCIFlags) & MCINODE_ISAUTOCLOSING)
#define ISAUTOOPENED(node)  (((node)->dwMCIFlags) & MCINODE_ISAUTOOPENED)

#define SETAUTOCLOSING(node) (((node)->dwMCIFlags) |= MCINODE_ISAUTOCLOSING)
#define SETISCLOSING(node)   (((node)->dwMCIFlags) |= MCINODE_ISCLOSING)

typedef struct {
    LPWSTR              lpstrParams;
    LPWSTR             *lpstrPointerList;
    HANDLE              hCallingTask;
    UINT                wParsingError;
} MCI_INTERNAL_OPEN_INFO;
typedef MCI_INTERNAL_OPEN_INFO *LPMCI_INTERNAL_OPEN_INFO;

typedef struct tagMCI_SYSTEM_MESSAGE {
    LPWSTR  lpstrCommand;
    DWORD   dwAdditionalFlags;      /* Used by mciAutoOpenDevice to request */
                                    /* Notify                               */
    LPWSTR  lpstrReturnString;
    UINT    uReturnLength;
    HANDLE  hCallingTask;
    LPWSTR  lpstrNewDirectory;      /* The current directory of the calling */
                                    /* task - includes the drive letter     */
} MCI_SYSTEM_MESSAGE;
typedef MCI_SYSTEM_MESSAGE *LPMCI_SYSTEM_MESSAGE;

#define MCI_INIT_DEVICE_LIST_SIZE   4
#define MCI_DEVICE_LIST_GROW_SIZE   4

#define MAX_COMMAND_TABLES 20

extern BOOL MCI_bDeviceListInitialized;

extern LPMCI_DEVICE_NODE *MCI_lpDeviceList;
extern UINT MCI_wDeviceListSize;

extern MCIDEVICEID MCI_wNextDeviceID;   /* the next device ID to use for a new device */

extern COMMAND_TABLE_TYPE command_tables[MAX_COMMAND_TABLES];

#define mciToLower(lpstrString)   CharLower(lpstrString)

extern BOOL  mciGlobalInit(void);
extern BOOL  mciSoundInit(void);

extern BOOL  mciInitDeviceList(void);

extern UINT  mciOpenDevice( DWORD dwFlags,
                            LPMCI_OPEN_PARMSW lpOpenParms,
                            LPMCI_INTERNAL_OPEN_INFO lpOpenInfo);

extern UINT  mciCloseDevice( MCIDEVICEID wID, DWORD dwFlags,
                             LPMCI_GENERIC_PARMS lpGeneric,
                             BOOL bCloseDriver);

extern UINT  mciLoadTableType(UINT wType);

extern LPWSTR FindCommandInTable (UINT wTable, LPCWSTR lpstrCommand,
                                 PUINT lpwMessage);

extern UINT mciEatToken (LPCWSTR *lplpstrInput, WCHAR cSeparater,
                         LPWSTR *lplpstrOutput, BOOL bMustFind);

extern LPWSTR FindCommandItem (MCIDEVICEID wDeviceID, LPCWSTR lpstrType,
                              LPCWSTR lpstrCommand, PUINT lpwMessage,
                              PUINT lpwTable);

extern UINT mciParseParams (UINT    uMessage,
                            LPCWSTR lpstrParams,
                            LPCWSTR lpCommandList,
                            LPDWORD lpdwFlags,
                            LPWSTR  lpOutputParams,
                            UINT    wParamsSize,
                            LPWSTR  **lpPointerList,
                            PUINT   lpwParsingError);

extern UINT  mciParseCommand (MCIDEVICEID wDeviceID,
                              LPWSTR  lpstrCommand,
                              LPCWSTR lpstrDeviceName,
                              LPWSTR *lpCommandList,
                              PUINT   lpwTable);

extern VOID  mciParserFree (LPWSTR *lpstrPointerList);

extern UINT mciEatCommandEntry(LPCWSTR lpEntry, LPDWORD lpValue, PUINT lpID);

extern UINT mciGetParamSize (DWORD dwValue, UINT wID);

extern DWORD mciSysinfo (MCIDEVICEID wDeviceID, DWORD dwFlags,
                         LPMCI_SYSINFO_PARMSW lpSysinfo);
extern UINT mciLookUpType (LPCWSTR lpstrTypeName);

extern BOOL mciExtractDeviceType (LPCWSTR lpstrDeviceName,
                                  LPWSTR lpstrDeviceType,
                                  UINT uBufLen);
extern BOOL mciUnlockCommandTable (UINT wCommandTable);

extern UINT mciSetBreakKey (MCIDEVICEID wDeviceID, int nVirtKey, HWND hwndTrap);


/***************************************************************************

    MCI memory allocation

***************************************************************************/

#define mciAlloc(cb) winmmAlloc((DWORD)(cb))
#define mciReAlloc(ptr, cb) winmmReAlloc((PVOID)(ptr), (DWORD)(cb))
#define mciFree(ptr) winmmFree((PVOID)(ptr))

/*
// Random stuff for MCI
*/

extern DWORD mciRelaySystemString (LPMCI_SYSTEM_MESSAGE lpMessage);
void MciNotify(DWORD wParam, LONG lParam);        // in MCI.C

#endif // MMNOMCI

/*
// Some defines introduced to avoid  signed/unsigned compares - and to
// remove the need for absolute constants in the code
*/

#define MCI_ERROR_VALUE         ((UINT)(-1))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\midi.c ===
/*****************************************************************************
    midi.c

    Level 1 kitchen sink DLL midi support module

    Copyright (c) 1990-2001 Microsoft Corporation

*****************************************************************************/

#include "winmmi.h"
#define DO_DEFAULT_MIDI_MAPPER

/*****************************************************************************

    local structures

*****************************************************************************/


/*****************************************************************************

    internal prototypes

*****************************************************************************/


/*****************************************************************************

    segmentation

*****************************************************************************/

/*****************************************************************************
 * @doc INTERNAL  MIDI
 *
 * @api MMRESULT | midiPrepareHeader | This function prepares the header and data
 *   if the driver returns MMSYSERR_NOTSUPPORTED.
 *
 * @rdesc Currently always returns MMSYSERR_NOERROR.
 ****************************************************************************/
STATIC MMRESULT   midiPrepareHeader(LPMIDIHDR lpMidiHdr, UINT wSize)
{
    if (!HugePageLock(lpMidiHdr, (DWORD)sizeof(MIDIHDR)))
    return MMSYSERR_NOMEM;

    if (!HugePageLock(lpMidiHdr->lpData, lpMidiHdr->dwBufferLength)) {
    HugePageUnlock(lpMidiHdr, (DWORD)sizeof(MIDIHDR));
    return MMSYSERR_NOMEM;
    }

    lpMidiHdr->dwFlags |= MHDR_PREPARED;

    return MMSYSERR_NOERROR;
}

/*****************************************************************************
 * @doc INTERNAL  MIDI
 *
 * @api MMRESULT | midiUnprepareHeader | This function unprepares the header and
 *   data if the driver returns MMSYSERR_NOTSUPPORTED.
 *
 * @rdesc Currently always returns MMSYSERR_NOERROR.
 ****************************************************************************/
STATIC MMRESULT midiUnprepareHeader(LPMIDIHDR lpMidiHdr, UINT wSize)
{
    HugePageUnlock(lpMidiHdr->lpData, lpMidiHdr->dwBufferLength);
    HugePageUnlock(lpMidiHdr, (DWORD)sizeof(MIDIHDR));

    lpMidiHdr->dwFlags &= ~MHDR_PREPARED;

    return MMSYSERR_NOERROR;
}

/***************************************************************************
 * @doc INTERNAL  MIDI
 *
 * @api MMRESULT | midiReferenceDriverById | This function maps a logical
 *      id to a device driver table index and physical id.
 *
 * @parm IN MIDIDRV | pmididrvZ | The list of midi drivers.
 *
 * @parm IN UINT | id | The logical id to be mapped.
 *
 * @parm OUT PMIDIDRV* OPTIONAL | ppmididrv | Pointer to MIDIDRV structure
 *    describing the driver supporting the id.
 *
 * @parm OUT UINT* OPTIONAL | pport | The driver-relative device number. If
 *    the caller supplies this buffer then it must also supply ppmididrv.
 *
 * @comm If the caller specifies ppmididrv then this function increments
 *       the mididrv's usage before returning.  The caller must ensure
 *       the usage is eventually decremented.
 *
 * @rdesc The return value is zero if successful, MMSYSERR_BADDEVICEID if
 *   the id is out of range.
 *
 * @rdesc The return value contains the dev[] array element in the high UINT and
 *   the driver physical device number in the low UINT.
 *
 * @comm Out of range values map to FFFF:FFFF
 ***************************************************************************/
MMRESULT midiReferenceDriverById(IN PMIDIDRV pmididrvZ, IN UINT id, OUT PMIDIDRV *ppmididrv OPTIONAL, OUT UINT *pport)
{
    PMIDIDRV pmididrv;
    MMRESULT mmr;
    
    // Should not be called asking for port but not mididrv
    WinAssert(!(pport && !ppmididrv));

    if (id == MIDI_MAPPER) {
        /*
        **  Make sure we tried to load the mapper
        */
        MidiMapperInit();
    }

    EnterNumDevs("midiReferenceDriverById");
    
    if (MIDI_MAPPER == id)
    {
        id = 0;
    	for (pmididrv = pmididrvZ->Next; pmididrv != pmididrvZ; pmididrv = pmididrv->Next)
    	{
    	    if (pmididrv->fdwDriver & MMDRV_MAPPER) break;
    	}
    } else {
    	for (pmididrv = pmididrvZ->Next; pmididrv != pmididrvZ; pmididrv = pmididrv->Next)
        {
            if (pmididrv->fdwDriver & MMDRV_MAPPER) continue;
            if (pmididrv->NumDevs > id) break;
            id -= pmididrv->NumDevs;
        }
    }

    if (pmididrv != pmididrvZ)
    {
    	if (ppmididrv)
    	{
    	    mregIncUsagePtr(pmididrv);
    	    *ppmididrv = pmididrv;
    	    if (pport) *pport = id;
    	}
    	mmr = MMSYSERR_NOERROR;
    } else {
        mmr = MMSYSERR_BADDEVICEID;
    }

    LeaveNumDevs("midiReferenceDriverById");
    
    return mmr;
}

PCWSTR midiReferenceDevInterfaceById(PMIDIDRV pdrvZ, UINT_PTR id)
{
    PMIDIDRV pdrv;
    PCWSTR DeviceInterface;
    
    if ((pdrvZ == &midioutdrvZ && ValidateHandle((HANDLE)id, TYPE_MIDIOUT)) ||
        (pdrvZ == &midiindrvZ  && ValidateHandle((HANDLE)id, TYPE_MIDIIN)))
    {
    	DeviceInterface = ((PMIDIDEV)id)->mididrv->cookie;
    	if (DeviceInterface) wdmDevInterfaceInc(DeviceInterface);
    	return DeviceInterface;
    }
    
    if (!midiReferenceDriverById(pdrvZ, (UINT)id, &pdrv, NULL))
    {
    	DeviceInterface = pdrv->cookie;
    	if (DeviceInterface) wdmDevInterfaceInc(DeviceInterface);
    	mregDecUsagePtr(pdrv);
    	return DeviceInterface;
    }

    return NULL;
}

/****************************************************************************
 * @doc INTERNAL  MIDI
 *
 * @api MMRESULT | midiMessage | This function sends messages to the MIDI device
 *   drivers.
 *
 * @parm HMIDI | hMidi | The handle to the MIDI device.
 *
 * @parm UINT | wMsg | The message to send.
 *
 * @parm DWORD | dwP1 | Parameter 1.
 *
 * @parm DWORD | dwP2 | Parameter 2.
 *
 * @rdesc Returns the value of the message sent.
 ***************************************************************************/
STATIC MMRESULT midiMessage(HMIDI hMidi, UINT msg, DWORD_PTR dwP1, DWORD_PTR dwP2)
{
    MMRESULT mrc;
    
    ENTER_MM_HANDLE(hMidi);
    
    ReleaseHandleListResource();
    
    // Is handle deserted?
    
    if (IsHandleDeserted(hMidi))
    {
        LEAVE_MM_HANDLE(hMidi);
        return (MMSYSERR_NODRIVER);
    }
    
    //  Are we busy (in the middle of an open/close)?
    if (IsHandleBusy(hMidi))
    {
        LEAVE_MM_HANDLE(hMidi);
        return (MMSYSERR_HANDLEBUSY);
    }
    
    if (BAD_HANDLE(hMidi, TYPE_MIDIOUT) && BAD_HANDLE(hMidi, TYPE_MIDISTRM) &&
        BAD_HANDLE(hMidi, TYPE_MIDIIN) ) {
	    WinAssert(!"Bad Handle within midiMessage");
        mrc = MMSYSERR_INVALHANDLE;
    } else {
        mrc = (*(((PMIDIDEV)hMidi)->mididrv->drvMessage))
        (((PMIDIDEV)hMidi)->wDevice, msg, ((PMIDIDEV)hMidi)->dwDrvUser, dwP1, dwP2);
    }

    LEAVE_MM_HANDLE(hMidi);

    return mrc;
}

/****************************************************************************
 * @doc INTERNAL  MIDI
 *
 * @func MMRESULT | midiIDMessage | This function sends a message to the device
 * ID specified.  It also performs error checking on the ID passed.
 *
 * @parm PMIDIDRV | mididrv | Pointer to the input or output device list.
 *
 * @parm UINT | wTotalNumDevs | Total number of devices in device list.
 *
 * @parm UINT | uDeviceID | Device ID to send message to.
 *
 * @parm UINT | wMessage | The message to send.
 *
 * @parm DWORD | dwParam1 | Parameter 1.
 *
 * @parm DWORD | dwParam2 | Parameter 2.
 *
 * @rdesc The return value is the low UINT of the returned message.
 ***************************************************************************/
STATIC  MMRESULT   midiIDMessage(
    PMIDIDRV    pmididrvZ,
    UINT        wTotalNumDevs,
    UINT_PTR    uDeviceID,
    UINT        wMessage,
    DWORD_PTR   dwParam1,
    DWORD_PTR   dwParam2)
{
    PMIDIDRV  mididrv;
    UINT      port;
    DWORD     mmr;
    DWORD     dwClass;

    if (uDeviceID>=wTotalNumDevs && uDeviceID!=MIDI_MAPPER) {
    // this cannot be a device ID.
    // it could be a device handle.  Try it.
    // First we have to verify which type of handle it is (OUT or IN)
    // We can work this out as midiIDMessage is only ever called with
    // mididrv== midioutdrv or midiindrv

    if ((pmididrvZ == &midioutdrvZ && ValidateHandle((HANDLE)uDeviceID, TYPE_MIDIOUT))
     || (pmididrvZ == &midiindrvZ && ValidateHandle((HANDLE)uDeviceID, TYPE_MIDIIN) )) {

        // to preserve as much compatibility with previous code paths
        // we do NOT call midiMessage as that calls ENTER_MM_HANDLE

        return (MMRESULT)(*(((PMIDIDEV)uDeviceID)->mididrv->drvMessage))
            (((PMIDIDEV)uDeviceID)->wDevice,
            wMessage,
            ((PMIDIDEV)uDeviceID)->dwDrvUser, dwParam1, dwParam2);
    } else {
        return(MMSYSERR_BADDEVICEID);
    }
    }

    // Get Physical Device, and Port
    mmr = midiReferenceDriverById(pmididrvZ, (UINT)uDeviceID, &mididrv, &port);
    if (mmr)
    {
        return mmr;
    }

    if (pmididrvZ == &midiindrvZ)
       dwClass = TYPE_MIDIIN;
    else if (pmididrvZ == &midioutdrvZ)
       dwClass = TYPE_MIDIOUT;
    else
       dwClass = TYPE_UNKNOWN;

    if (!mididrv->drvMessage)
        return MMSYSERR_NODRIVER;

    // Handle Internal Messages
    if (!mregHandleInternalMessages (mididrv, dwClass, port, wMessage, dwParam1, dwParam2, &mmr))
    {
        // Call Physical Device at Port
        mmr = (MMRESULT)((*(mididrv->drvMessage))(port, wMessage, 0L, dwParam1, dwParam2));
    }

    mregDecUsagePtr(mididrv);
    return mmr;
}


/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiOutGetNumDevs | This function retrieves the number of MIDI
 *   output devices present in the system.
 *
 * @rdesc Returns the number of MIDI output devices present in the system.
 *
 * @xref midiOutGetDevCaps
 ****************************************************************************/
UINT APIENTRY midiOutGetNumDevs(void)
{
    UINT cDevs;

    ClientUpdatePnpInfo();

    EnterNumDevs("midiOutGetNumDevs");
    cDevs = wTotalMidiOutDevs;
    LeaveNumDevs("midiOutGetNumDevs");

    return cDevs;
}

/****************************************************************************
 * @doc EXTERNAL MIDI
 *
 * @api MMRESULT | midiOutMessage | This function sends messages to the MIDI device
 *   drivers.
 *
 * @parm HMIDIOUT | hMidiOut | The handle to the MIDI device.
 *
 * @parm UINT  | msg | The message to send.
 *
 * @parm DWORD | dw1 | Parameter 1.
 *
 * @parm DWORD | dw2 | Parameter 2.
 *
 * @rdesc Returns the value of the message sent.
 ***************************************************************************/
MMRESULT APIENTRY midiOutMessage(HMIDIOUT hMidiOut, UINT msg, DWORD_PTR dw1, DWORD_PTR dw2)
{
    ClientUpdatePnpInfo();

    AcquireHandleListResourceShared();
    
    if (BAD_HANDLE(hMidiOut, TYPE_MIDIOUT) && BAD_HANDLE(hMidiOut, TYPE_MIDISTRM))
    {
        ReleaseHandleListResource();
        return midiIDMessage(&midioutdrvZ, wTotalMidiOutDevs, (UINT_PTR)hMidiOut, msg, dw1, dw2);
    }

    switch(GetHandleType(hMidiOut))
    {
        case TYPE_MIDIOUT:
        return midiMessage((HMIDI)hMidiOut, msg, dw1, dw2);

        case TYPE_MIDISTRM:
        ReleaseHandleListResource();
        return midiStreamBroadcast(HtoPT(PMIDISTRM, hMidiOut), msg, dw1, dw2);
    }

    ReleaseHandleListResource();
    Squirt("We should never get here.");
    WinAssert(FALSE);

    //  Getting rid of warning.
    return MMSYSERR_INVALHANDLE;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiOutGetDevCaps | This function queries a specified
 *   MIDI output device to determine its capabilities.
 *
 * @parm UINT | uDeviceID | Identifies the MIDI output device.
 *
 * @parm LPMIDIOUTCAPS | lpCaps | Specifies a far pointer to a <t MIDIOUTCAPS>
 *   structure.  This structure is filled with information about the
 *   capabilities of the device.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIOUTCAPS> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *   @flag MMSYSERR_NOMEM | Unable load mapper string description.
 *
 * @comm Use <f midiOutGetNumDevs> to determine the number of MIDI output
 *   devices present in the system.  The device ID specified by <p uDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   The MIDI_MAPPER constant may also be used as a device id. Only
 *   <p wSize> bytes (or less) of information is copied to the location
 *   pointed to by <p lpCaps>.  If <p wSize> is zero, nothing is copied,
 *   and the function returns zero.
 *
 * @xref midiOutGetNumDevs
 ****************************************************************************/
MMRESULT APIENTRY midiOutGetDevCapsW(UINT_PTR uDeviceID, LPMIDIOUTCAPSW lpCaps, UINT wSize)
{
    DWORD_PTR       dwParam1, dwParam2;
    MDEVICECAPSEX   mdCaps;
    PMIDIDRV        midioutdrv;
    PCWSTR          DevInterface;
    MMRESULT        mmr;

    if (wSize == 0)
    return MMSYSERR_NOERROR;

    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();

    DevInterface = midiReferenceDevInterfaceById(&midioutdrvZ, uDeviceID);
    dwParam2 = (DWORD_PTR)DevInterface;
    
    if (0 == dwParam2)
    {
        dwParam1 = (DWORD_PTR)lpCaps;
        dwParam2 = (DWORD)wSize;
    }
    else
    {
        mdCaps.cbSize = (DWORD)wSize;
        mdCaps.pCaps  = lpCaps;
        dwParam1      = (DWORD_PTR)&mdCaps;
    }

    //
    //  Don't allow non proper drivers in TS environement
    //
    // ISSUE-2001/01/09-FrankYe Instead of cast to UINT.  Should check whether
    //    this is a handle and get wavedrv from handle if it is.
    midioutdrv = NULL;
    if ((!midiReferenceDriverById(&midioutdrvZ, (UINT)uDeviceID, &midioutdrv, NULL)) &&
    	lstrcmpW(midioutdrv->wszSessProtocol, SessionProtocolName))
    {
        mmr = MMSYSERR_NODRIVER;
    }
    else
    {
        AcquireHandleListResourceShared();

        if (BAD_HANDLE((HMIDI)uDeviceID, TYPE_MIDIOUT))
        {
            ReleaseHandleListResource();
    	    mmr = midiIDMessage( &midioutdrvZ, wTotalMidiOutDevs, uDeviceID, MODM_GETDEVCAPS, dwParam1, dwParam2 );
        }
        else
        {
    	    mmr = (MMRESULT)midiMessage((HMIDI)uDeviceID, MODM_GETDEVCAPS, dwParam1, dwParam2);
        }
    }

    if (midioutdrv) mregDecUsagePtr(midioutdrv);
    if (DevInterface) wdmDevInterfaceDec(DevInterface);
    return mmr;
}

MMRESULT APIENTRY midiOutGetDevCapsA(UINT_PTR uDeviceID, LPMIDIOUTCAPSA lpCaps, UINT wSize)
{
    MIDIOUTCAPS2W   wDevCaps2;
    MIDIOUTCAPS2A   aDevCaps2;
    DWORD_PTR       dwParam1, dwParam2;
    MDEVICECAPSEX   mdCaps;
    MMRESULT        mmRes;
    PMIDIDRV        midioutdrv;
    CHAR            chTmp[ MAXPNAMELEN * sizeof(WCHAR) ];
    PCWSTR          DevInterface;

    if (wSize == 0)
    return MMSYSERR_NOERROR;

    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();

    DevInterface = midiReferenceDevInterfaceById(&midioutdrvZ, uDeviceID);
    dwParam2 = (DWORD_PTR)DevInterface;

    memset(&wDevCaps2, 0, sizeof(wDevCaps2));

    if (0 == dwParam2)
    {
        dwParam1 = (DWORD_PTR)&wDevCaps2;
        dwParam2 = (DWORD)sizeof(wDevCaps2);
    }
    else
    {
        mdCaps.cbSize = (DWORD)sizeof(wDevCaps2);
        mdCaps.pCaps  = &wDevCaps2;
        dwParam1      = (DWORD_PTR)&mdCaps;
    }

    //
    //  Don't allow non proper drivers in TS environement
    //
    // ISSUE-2001/01/09-FrankYe Bad cast to UINT.  Should check whether this
    //    is a handle and get wavedrv from handle if it is.
    midioutdrv = NULL;
    if ( uDeviceID < wTotalMidiOutDevs &&
         !midiReferenceDriverById(&midioutdrvZ, (UINT)uDeviceID, &midioutdrv, NULL) &&
    	 lstrcmpW(midioutdrv->wszSessProtocol, SessionProtocolName) )
    {
    	mregDecUsagePtr(midioutdrv);
    	if (DevInterface) wdmDevInterfaceDec(DevInterface);
    	return MMSYSERR_NODRIVER;
    }

    AcquireHandleListResourceShared();
    if (BAD_HANDLE((HMIDI)uDeviceID, TYPE_MIDIOUT))
    {
        ReleaseHandleListResource();
        mmRes = midiIDMessage( &midioutdrvZ, wTotalMidiOutDevs, (UINT)uDeviceID,
                               MODM_GETDEVCAPS, dwParam1,
                               dwParam2);
    }
    else
    {
        mmRes = midiMessage((HMIDI)uDeviceID, MODM_GETDEVCAPS,
                            dwParam1, dwParam2);
    }

    if (midioutdrv) mregDecUsagePtr(midioutdrv);
    if (DevInterface) wdmDevInterfaceDec(DevInterface);

    //
    // Make sure the call worked before proceeding with the thunk.
    //
    if ( mmRes != MMSYSERR_NOERROR ) {
    return  mmRes;
    }

    aDevCaps2.wMid             = wDevCaps2.wMid;
    aDevCaps2.wPid             = wDevCaps2.wPid;
    aDevCaps2.vDriverVersion   = wDevCaps2.vDriverVersion;
    aDevCaps2.wTechnology      = wDevCaps2.wTechnology;
    aDevCaps2.wVoices          = wDevCaps2.wVoices;
    aDevCaps2.wNotes           = wDevCaps2.wNotes;
    aDevCaps2.wChannelMask     = wDevCaps2.wChannelMask;
    aDevCaps2.dwSupport        = wDevCaps2.dwSupport;
    aDevCaps2.ManufacturerGuid = wDevCaps2.ManufacturerGuid;
    aDevCaps2.ProductGuid      = wDevCaps2.ProductGuid;
    aDevCaps2.NameGuid         = wDevCaps2.NameGuid;

    // copy and convert lpwText to lpText here.
    UnicodeStrToAsciiStr( chTmp, chTmp + sizeof( chTmp ), wDevCaps2.szPname );
    strcpy( aDevCaps2.szPname, chTmp );

    //
    // now copy the required amount into the callers buffer.
    //
    CopyMemory( lpCaps, &aDevCaps2, min(wSize, sizeof(aDevCaps2)));

    return mmRes;
}

/*****************************************************************************
 * @doc EXTERNAL MIDI
 *
 * @api MMRESULT | midiOutGetVolume | This function returns the current volume
 *   setting of a MIDI output device.
 *
 * @parm UINT | uDeviceID | Identifies the MIDI output device.
 *
 * @parm LPDWORD | lpdwVolume | Specifies a far pointer to a location
 *   to be filled with the current volume setting. The low-order UINT of
 *   this location contains the left channel volume setting, and the high-order
 *   UINT contains the right channel setting. A value of 0xFFFF represents
 *   full volume, and a value of 0x0000 is silence.
 *
 *   If a device does not support both left and right volume
 *   control, the low-order UINT of the specified location contains
 *   the mono volume level.
 *
 *   The full 16-bit setting(s)
 *   set with <f midiOutSetVolume> is returned, regardless of whether
 *   the device supports the full 16 bits of volume level control.
 *
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *
 * @comm Not all devices support volume control. To determine whether the
 *   device supports volume control, use the MIDICAPS_VOLUME
 *   flag to test the <e MIDIOUTCAPS.dwSupport> field of the <t MIDIOUTCAPS>
 *   structure (filled by <f midiOutGetDevCaps>).
 *
 *   To determine whether the device supports volume control on both the
 *   left and right channels, use the MIDICAPS_LRVOLUME flag to test
 *   the <e MIDIOUTCAPS.dwSupport> field of the <t MIDIOUTCAPS>
 *   structure (filled by <f midiOutGetDevCaps>).
 *
 * @xref midiOutSetVolume
 ****************************************************************************/
MMRESULT APIENTRY midiOutGetVolume(HMIDIOUT hmo, LPDWORD lpdwVolume)
{
    PCWSTR      DevInterface;
    MMRESULT    mmr;

    V_WPOINTER(lpdwVolume, sizeof(DWORD), MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();

    DevInterface = midiReferenceDevInterfaceById(&midioutdrvZ, (UINT_PTR)hmo);

    AcquireHandleListResourceShared();
    
    if (BAD_HANDLE(hmo, TYPE_MIDIOUT) && BAD_HANDLE(hmo, TYPE_MIDISTRM))
    {
        ReleaseHandleListResource();
    	mmr = midiIDMessage(&midioutdrvZ, wTotalMidiOutDevs, (UINT_PTR)hmo, MODM_GETVOLUME, (DWORD_PTR)lpdwVolume, (DWORD_PTR)DevInterface);
    }
    else
    {
        switch(GetHandleType(hmo))
        {
        case TYPE_MIDIOUT:
            mmr = (MMRESULT)midiMessage((HMIDI)hmo, MODM_GETVOLUME, (DWORD_PTR)lpdwVolume, (DWORD_PTR)DevInterface);
            break;

        case TYPE_MIDISTRM:
            ENTER_MM_HANDLE((HMIDI)hmo);    
            ReleaseHandleListResource();
            mmr = (MMRESULT)midiStreamMessage(HtoPT(PMIDISTRM, hmo)->rgIds, MODM_GETVOLUME, (DWORD_PTR)lpdwVolume, (DWORD_PTR)DevInterface);
            LEAVE_MM_HANDLE((HMIDI)hmo);    
            break;

        default:
            WinAssert(FALSE);
            ReleaseHandleListResource();
            mmr = MMSYSERR_INVALHANDLE;
            break;
        }
    }

    if (DevInterface) wdmDevInterfaceDec(DevInterface);
    return mmr;

}

/*****************************************************************************
 * @doc EXTERNAL MIDI
 *
 * @api MMRESULT | midiOutSetVolume | This function sets the volume of a
 *      MIDI output device.
 *
 * @parm UINT | uDeviceID | Identifies the MIDI output device.
 *
 * @parm DWORD | dwVolume | Specifies the new volume setting.
 *   The low-order UINT contains the left channel volume setting, and the
 *   high-order UINT contains the right channel setting. A value of
 *   0xFFFF represents full volume, and a value of 0x0000 is silence.
 *
 *   If a device does not support both left and right volume
 *   control, the low-order UINT of <p dwVolume> specifies the volume
 *   level, and the high-order UINT is ignored.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *
 * @comm Not all devices support volume changes. To determine whether the
 *   device supports volume control, use the MIDICAPS_VOLUME
 *   flag to test the <e MIDIOUTCAPS.dwSupport> field of the <t MIDIOUTCAPS>
 *   structure (filled by <f midiOutGetDevCaps>).
 *
 *   To determine whether the device supports volume control on both the
 *   left and right channels, use the MIDICAPS_LRVOLUME flag to test
 *   the <e MIDIOUTCAPS.dwSupport> field of the <t MIDIOUTCAPS>
 *   structure (filled by <f midiOutGetDevCaps>).
 *
 *   Most devices do not support the full 16 bits of volume level control
 *   and will use only the high-order bits of the requested volume setting.
 *   For example, for a device that supports 4 bits of volume control,
 *   requested volume level values of 0x4000, 0x4fff, and 0x43be will
 *   all produce the same physical volume setting, 0x4000. The
 *   <f midiOutGetVolume> function will return the full 16-bit setting set
 *   with <f midiOutSetVolume>.
 *
 *   Volume settings are interpreted logarithmically. This means the
 *   perceived increase in volume is the same when increasing the
 *   volume level from 0x5000 to 0x6000 as it is from 0x4000 to 0x5000.
 *
 * @xref midiOutGetVolume
 ****************************************************************************/
MMRESULT APIENTRY midiOutSetVolume(HMIDIOUT hmo, DWORD dwVolume)
{
    PCWSTR   DevInterface;
    MMRESULT mmr;
 
    ClientUpdatePnpInfo();

    DevInterface = midiReferenceDevInterfaceById(&midioutdrvZ, (UINT_PTR)hmo);

    AcquireHandleListResourceShared();
    if (BAD_HANDLE(hmo, TYPE_MIDIOUT) && BAD_HANDLE(hmo, TYPE_MIDISTRM))
    {
        ReleaseHandleListResource();
    	mmr = midiIDMessage(&midioutdrvZ, wTotalMidiOutDevs, (UINT_PTR)hmo, MODM_SETVOLUME, dwVolume, (DWORD_PTR)DevInterface);
    }
    else
    {
        switch(GetHandleType(hmo))
        {
            case TYPE_MIDIOUT:
               mmr = (MMRESULT)midiMessage((HMIDI)hmo, MODM_SETVOLUME, (DWORD)dwVolume, (DWORD_PTR)DevInterface);
               break;

            case TYPE_MIDISTRM:
                ReleaseHandleListResource();
                mmr = (MMRESULT)midiStreamBroadcast(HtoPT(PMIDISTRM, hmo), MODM_SETVOLUME, (DWORD)dwVolume, (DWORD_PTR)DevInterface);
                break;

            default:
                ReleaseHandleListResource();
            	WinAssert(FALSE);
            	mmr = MMSYSERR_INVALHANDLE;
            	break;
        }
    }

    if (DevInterface) wdmDevInterfaceDec(DevInterface);
    return mmr;
}

/*****************************************************************************
 * @doc INTERNAL MIDI
 *
 * @func MMRESULT | midiGetErrorText | This function retrieves a textual
 *   description of the error identified by the specified error number.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPTSTR | lpText | Specifies a far pointer to a buffer which
 *   is filled with the textual error description.
 *
 * @parm UINT | wSize | Specifies the length in characters of the buffer
 *   pointed to by <p lpText>.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADERRNUM | Specified error number is out of range.
 *
 * @comm If the textual error description is longer than the specified buffer,
 *   the description is truncated.  The returned error string is always
 *   null-terminated. If <p wSize> is zero, nothing is copied and MMSYSERR_NOERROR
 *   is returned.  All error descriptions are less than 80 characters long.
 ****************************************************************************/

STATIC MMRESULT midiGetErrorTextW(UINT wError, LPWSTR lpText, UINT wSize)
{
    lpText[0] = 0;

#if MMSYSERR_BASE
    if (((wError < MMSYSERR_BASE) || (wError > MMSYSERR_LASTERROR)) && ((wError < MIDIERR_BASE) || (wError > MIDIERR_LASTERROR)))
#else
    if ((wError > MMSYSERR_LASTERROR) && ((wError < MIDIERR_BASE) || (wError > MIDIERR_LASTERROR)))
#endif
    return MMSYSERR_BADERRNUM;

    if (wSize > 1)
    {
    if (!LoadStringW(ghInst, wError, lpText, wSize))
        return MMSYSERR_BADERRNUM;
    }

    return MMSYSERR_NOERROR;
}

STATIC MMRESULT midiGetErrorTextA(UINT wError, LPSTR lpText, UINT wSize)
{
    lpText[0] = 0;

#if MMSYSERR_BASE
    if (((wError < MMSYSERR_BASE) || (wError > MMSYSERR_LASTERROR)) && ((wError < MIDIERR_BASE) || (wError > MIDIERR_LASTERROR)))
#else
    if ((wError > MMSYSERR_LASTERROR) && ((wError < MIDIERR_BASE) || (wError > MIDIERR_LASTERROR)))
#endif
    return MMSYSERR_BADERRNUM;

    if (wSize > 1)
    {
    if (!LoadStringA(ghInst, wError, lpText, wSize))
        return MMSYSERR_BADERRNUM;
    }

    return MMSYSERR_NOERROR;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiOutGetErrorText | This function retrieves a textual
 *   description of the error identified by the specified error number.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPTSTR | lpText | Specifies a far pointer to a buffer to be
 *   filled with the textual error description.
 *
 * @parm UINT | wSize | Specifies the length in characters of the buffer
 *   pointed to by <p lpText>.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADERRNUM | Specified error number is out of range.
 *
 * @comm If the textual error description is longer than the specified buffer,
 *   the description is truncated.  The returned error string is always
 *   null-terminated. If <p wSize> is zero, nothing is copied, and the
 *   function returns MMSYSERR_NOERROR.  All error descriptions are
 *   less than MAXERRORLENGTH characters long.
 ****************************************************************************/
MMRESULT APIENTRY midiOutGetErrorTextW(UINT wError, LPWSTR lpText, UINT wSize)
{
    if(wSize == 0)
    return MMSYSERR_NOERROR;

    V_WPOINTER(lpText, wSize*sizeof(WCHAR), MMSYSERR_INVALPARAM);

    return midiGetErrorTextW(wError, lpText, wSize);
}

MMRESULT APIENTRY midiOutGetErrorTextA(UINT wError, LPSTR lpText, UINT wSize)
{
    if(wSize == 0)
    return MMSYSERR_NOERROR;

    V_WPOINTER(lpText, wSize, MMSYSERR_INVALPARAM);

    return midiGetErrorTextA(wError, lpText, wSize);
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiOutOpen | This function opens a specified MIDI
 *   output device for playback.
 *
 * @parm LPHMIDIOUT | lphMidiOut | Specifies a far pointer to an HMIDIOUT
 *   handle.  This location is filled with a handle identifying the opened
 *   MIDI output device.  Use the handle to identify the device when calling
 *   other MIDI output functions.
 *
 * @parm UINT | uDeviceID | Identifies the MIDI output device that is
 *   to be opened.
 *
 * @parm DWORD | dwCallback | Specifies the address of a fixed callback
 *   function or
 *   a handle to a window called during MIDI playback to process
 *   messages related to the progress of the playback.  Specify NULL
 *   for this parameter if no callback is desired.
 *
 * @parm DWORD | dwCallbackInstance | Specifies user instance data
 *   passed to the callback.  This parameter is not used with
 *   window callbacks.
 *
 * @parm DWORD | dwFlags | Specifies a callback flag for opening the device.
 *   @flag CALLBACK_WINDOW | If this flag is specified, <p dwCallback> is
 *      assumed to be a window handle.
 *   @flag CALLBACK_FUNCTION | If this flag is specified, <p dwCallback> is
 *      assumed to be a callback procedure address.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are as follows:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_ALLOCATED | Specified resource is already allocated.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *   @flag MIDIERR_NOMAP | There is no current MIDI map. This occurs only
 *   when opening the mapper.
 *   @flag MIDIERR_NODEVICE | A port in the current MIDI map doesn't exist.
 *   This occurs only when opening the mapper.
 *
 * @comm Use <f midiOutGetNumDevs> to determine the number of MIDI output
 *   devices present in the system.  The device ID specified by <p uDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   You may also specify MIDI_MAPPER as the device ID to open the MIDI mapper.
 *
 *   If a window is chosen to receive callback information, the following
 *   messages are sent to the window procedure function to indicate the
 *   progress of MIDI output:  <m MM_MOM_OPEN>, <m MM_MOM_CLOSE>,
 *   <m MM_MOM_DONE>.
 *
 *   If a function is chosen to receive callback information, the following
 *   messages are sent to the function to indicate the progress of MIDI
 *   output: <m MOM_OPEN>, <m MOM_CLOSE>, <m MOM_DONE>.  The callback function
 *   must reside in a DLL.  You do not have to use <f MakeProcInstance> to
 *   get a procedure-instance address for the callback function.
 *
 * @cb void CALLBACK | MidiOutFunc | <f MidiOutFunc> is a placeholder for
 *   the application-supplied function name.  The actual name must be
 *   exported by including it in an EXPORTS statement in the DLL's
 *   module-definition file.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI device
 *   associated with the callback.
 *
 * @parm UINT | wMsg | Specifies a MIDI output message.
 *
 * @parm DWORD | dwInstance | Specifies the instance data
 *   supplied with <f midiOutOpen>.
 *
 * @parm DWORD | dwParam1 | Specifies a parameter for the message.
 *
 * @parm DWORD | dwParam2 | Specifies a parameter for the message.
 *
 * @comm Because the callback is accessed at interrupt time, it must reside
 *   in a DLL and its code segment must be specified as FIXED in the
 *   module-definition file for the DLL.  Any data that the callback accesses
 *   must be in a FIXED data segment as well. The callback may not make any
 *   system calls except for <f PostMessage>, <f timeGetSystemTime>,
 *   <f timeGetTime>, <f timeSetEvent>, <f timeKillEvent>,
 *   <f midiOutShortMsg>, <f midiOutLongMsg>, and <f OutputDebugStr>.
 *
 * @xref midiOutClose
 ****************************************************************************/
MMRESULT APIENTRY midiOutOpen(LPHMIDIOUT lphMidiOut, UINT uDeviceID,
    DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD dwFlags)
{
    MIDIOPENDESC mo;
    PMIDIDEV     pdev;
    PMIDIDRV     mididrv;
    UINT         port;
    MMRESULT     wRet;

    V_WPOINTER(lphMidiOut, sizeof(HMIDIOUT), MMSYSERR_INVALPARAM);
    if (uDeviceID == MIDI_MAPPER) {
    V_FLAGS(LOWORD(dwFlags), MIDI_O_VALID & ~LOWORD(MIDI_IO_SHARED | MIDI_IO_COOKED), midiOutOpen, MMSYSERR_INVALFLAG);
    } else {
    V_FLAGS(LOWORD(dwFlags), MIDI_O_VALID & ~LOWORD(MIDI_IO_COOKED), midiOutOpen, MMSYSERR_INVALFLAG);
    }
    V_DCALLBACK(dwCallback, HIWORD(dwFlags), MMSYSERR_INVALPARAM);

    *lphMidiOut = NULL;

    ClientUpdatePnpInfo();

    wRet = midiReferenceDriverById(&midioutdrvZ, uDeviceID, &mididrv, &port);
    if (wRet)
    {
        return wRet;
    }

    //
    //  check if the device is appropriate for the current TS session
    //
    if (!(mididrv->fdwDriver & MMDRV_MAPPER) &&
    	lstrcmpW(mididrv->wszSessProtocol, SessionProtocolName))
    {
    	mregDecUsagePtr(mididrv);
        return MMSYSERR_NODRIVER;
    }

#ifdef DO_DEFAULT_MIDI_MAPPER
    /* Default midi mapper :
     *
     * If a midi mapper is installed as a separate DLL then all midi mapper
     * messages are routed to it. If no midi mapper is installed, simply
     * loop through the midi devices looking for a match.
     */
    if ((uDeviceID == MIDI_MAPPER && !mididrv->drvMessage)) {
        UINT    wErr = MMSYSERR_NODRIVER;
        UINT    cMax;

        mregDecUsagePtr(mididrv);
        
        cMax = wTotalMidiOutDevs;

        for (uDeviceID=0; uDeviceID<cMax; uDeviceID++) {
            wErr = midiOutOpen(lphMidiOut, uDeviceID, dwCallback, dwInstance, dwFlags);
            if (wErr == MMSYSERR_NOERROR)
                break;
        }
        return wErr;
    }
#endif // DO_DEFAULT_MIDI_MAPPER

    if (!mididrv->drvMessage)
    {
    	mregDecUsagePtr(mididrv);
        return MMSYSERR_NODRIVER;
    }

    pdev = (PMIDIDEV)NewHandle(TYPE_MIDIOUT, mididrv->cookie, sizeof(MIDIDEV));
    if( pdev == NULL)
    {
    	mregDecUsagePtr(mididrv);
        return MMSYSERR_NOMEM;
    }
    
    ENTER_MM_HANDLE(pdev);
    SetHandleFlag(pdev, MMHANDLE_BUSY);
    ReleaseHandleListResource();

    pdev->mididrv = mididrv;
    pdev->wDevice = port;
    pdev->uDeviceID = uDeviceID;
    pdev->fdwHandle = 0;

    mo.hMidi      = (HMIDI)pdev;
    mo.dwInstance = dwInstance;
    mo.dwCallback = dwCallback;
    mo.dnDevNode  = (DWORD_PTR)pdev->mididrv->cookie;

    wRet = (MMRESULT)((*(mididrv->drvMessage))
                     (pdev->wDevice, MODM_OPEN, (DWORD_PTR)&pdev->dwDrvUser, (DWORD_PTR)(LPMIDIOPENDESC)&mo, dwFlags));

    //  Mark as not busy on successful open...
    if (!wRet)
        ClearHandleFlag(pdev, MMHANDLE_BUSY);
        
    LEAVE_MM_HANDLE(pdev);

    if (wRet)
        FreeHandle((HMIDIOUT)pdev);
    else {
        //  Workaround for Bug#330817
        mregIncUsagePtr(mididrv);
        *lphMidiOut = (HMIDIOUT)pdev;
    }

    mregDecUsagePtr(mididrv);
    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiOutClose | This function closes the specified MIDI
 *   output device.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI output device.
 *  If the function is successful, the handle is no longer
 *   valid after this call.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_STILLPLAYING | There are still buffers in the queue.
 *
 * @comm If there are output buffers that have been sent with
 *   <f midiOutLongMsg> and haven't been returned to the application,
 *   the close operation will fail.  Call <f midiOutReset> to mark all
 *   pending buffers as being done.
 *
 * @xref midiOutOpen midiOutReset
 ****************************************************************************/
MMRESULT APIENTRY midiOutClose(HMIDIOUT hMidiOut)
{
    MMRESULT        wRet;
    PMIDIDRV        pmididrv;
    PMIDIDEV        pDev = (PMIDIDEV)hMidiOut;

    ClientUpdatePnpInfo();
    
    V_HANDLE_ACQ(hMidiOut, TYPE_MIDIOUT, MMSYSERR_INVALHANDLE);
    
    ENTER_MM_HANDLE((HMIDI)hMidiOut);
    ReleaseHandleListResource();
    
    if (IsHandleDeserted(hMidiOut))
    {
        //  This handle has been deserted.  Let's just free it.

        LEAVE_MM_HANDLE((HMIDI)hMidiOut);
        FreeHandle(hMidiOut);
        return MMSYSERR_NOERROR;
    }

    if (IsHandleBusy(hMidiOut))
    {
        //  Not quite invalid, but marked as closed.
    
        LEAVE_MM_HANDLE(hMidiOut);
        return (MMSYSERR_HANDLEBUSY);
    }

    //  Marking handle as 'invalid/closed'.
    SetHandleFlag(hMidiOut, MMHANDLE_BUSY);
    
    pmididrv = pDev->mididrv;
    
    wRet = (MMRESULT)(*pmididrv->drvMessage)(pDev->wDevice, MODM_CLOSE, pDev->dwDrvUser, 0L, 0L);
    
    if (MMSYSERR_NOERROR != wRet)
    {
        //  Error closing, set the flag as valid.
        ClearHandleFlag(hMidiOut, MMHANDLE_BUSY);
    }
    
    LEAVE_MM_HANDLE((HMIDI)hMidiOut);
    
    if (!wRet)
    {
        FreeHandle(hMidiOut);
    	mregDecUsagePtr(pmididrv);
        return wRet;
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiOutPrepareHeader | This function prepares a MIDI
 *   system-exclusive data block for output.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI output
 *   device.
 *
 * @parm LPMIDIHDR | lpMidiOutHdr | Specifies a far pointer to a <t MIDIHDR>
 *   structure that identifies the data block to be prepared.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *
 * @comm The <t MIDIHDR> data structure and the data block pointed to by its
 *   <e MIDIHDR.lpData> field must be allocated with <f GlobalAlloc> using the
 *   GMEM_MOVEABLE and GMEM_SHARE flags and locked with <f GlobalLock>.
 *   Preparing a header that has already been prepared has no effect, and
 *   the function returns zero.
 *
 * @xref midiOutUnprepareHeader
 ****************************************************************************/
MMRESULT APIENTRY midiOutPrepareHeader(HMIDIOUT hMidiOut, LPMIDIHDR lpMidiOutHdr, UINT wSize)
{
    MMRESULT         wRet;
    LPMIDIHDR        lpmh;
    PMIDISTRM        pms;
    PMIDISTRMID      pmsi;
    DWORD            idx;
#ifdef DEBUG
    DWORD            cDrvrs;
#endif
    DWORD            dwSaveFlags;


    V_HEADER(lpMidiOutHdr, wSize, TYPE_MIDIOUT, MMSYSERR_INVALPARAM);

    if (lpMidiOutHdr->dwFlags & MHDR_PREPARED)
        return MMSYSERR_NOERROR;

    lpMidiOutHdr->dwFlags = 0;

    ClientUpdatePnpInfo();

    AcquireHandleListResourceShared();
    
    if (BAD_HANDLE(hMidiOut, TYPE_MIDIOUT) && BAD_HANDLE(hMidiOut, TYPE_MIDISTRM))
    {
        ReleaseHandleListResource();
        return MMSYSERR_INVALHANDLE;
    }
    
    switch(GetHandleType(hMidiOut))
    {
        case TYPE_MIDIOUT:
            dwSaveFlags = lpMidiOutHdr->dwFlags & MHDR_SAVE;
            wRet = midiMessage((HMIDI)hMidiOut, MODM_PREPARE, (DWORD_PTR)lpMidiOutHdr, (DWORD)wSize);
            lpMidiOutHdr->dwFlags &= ~MHDR_SAVE;
            lpMidiOutHdr->dwFlags |= dwSaveFlags;

            if (MMSYSERR_NOTSUPPORTED == wRet)
                return midiPrepareHeader(lpMidiOutHdr, wSize);

            return wRet;

        case TYPE_MIDISTRM:
            ENTER_MM_HANDLE((HMIDI)hMidiOut);
            ReleaseHandleListResource(); 
    
            pms = HtoPT(PMIDISTRM, hMidiOut);

            if (lpMidiOutHdr->dwBufferLength > 65536L)
            {
                LEAVE_MM_HANDLE((HMIDI)hMidiOut);
                return MMSYSERR_INVALPARAM;
            }

            lpmh = (LPMIDIHDR)winmmAlloc(sizeof(MIDIHDR) *
                                                pms->cDrvrs);
            if (NULL == lpmh)
            {
                LEAVE_MM_HANDLE((HMIDI)hMidiOut);
                return MMSYSERR_NOMEM;
            }

            lpMidiOutHdr->dwReserved[MH_SHADOW] = (DWORD_PTR)lpmh;

//                 assert ((HIWORD(lpmh) & 0xFFFE) != (HIWORD(lpMidiOutHdr) & 0xFFFE));

#ifdef DEBUG
            cDrvrs = 0;
#endif
            wRet = MMSYSERR_ERROR;
            for (idx = 0, pmsi = pms->rgIds; idx < pms->cIds; idx++, pmsi++)
                if (pmsi->fdwId & MSI_F_FIRST)
                {
                    *lpmh = *lpMidiOutHdr;

                    lpmh->dwReserved[MH_PARENT] = (DWORD_PTR)lpMidiOutHdr;
                    lpmh->dwReserved[MH_SHADOW] = 0;
                    lpmh->dwFlags =
                        (lpMidiOutHdr->dwFlags & MHDR_MAPPED) | MHDR_SHADOWHDR;


                    dwSaveFlags = lpmh->dwFlags & MHDR_SAVE;
                    wRet = (MMRESULT)midiStreamMessage(pmsi, MODM_PREPARE, (DWORD_PTR)lpmh, (DWORD)sizeof(MIDIHDR));
                    lpmh->dwFlags &= ~MHDR_SAVE;
                    lpmh->dwFlags |= dwSaveFlags;
                    if (MMSYSERR_NOTSUPPORTED == wRet)
                        wRet = midiPrepareHeader(lpmh, sizeof(MIDIHDR));

                    if (MMSYSERR_NOERROR != wRet)
                        break;


                    lpmh++;
#ifdef DEBUG
                    ++cDrvrs;
                    if (cDrvrs > pms->cDrvrs)
                        dprintf1(("!Too many drivers in midiOutPrepareHeader()!!!"));
#endif
                }

            if (MMSYSERR_NOERROR == wRet)
                wRet = midiPrepareHeader(lpMidiOutHdr, wSize);
            else
            {
                for (idx = 0, pmsi = pms->rgIds; idx < pms->cIds; idx++, pmsi++)
                    if (pmsi->fdwId & MSI_F_FIRST)
                    {
                        dwSaveFlags = lpmh->dwFlags & MHDR_SAVE;
                        wRet = (MMRESULT)midiStreamMessage(pmsi, MODM_UNPREPARE, (DWORD_PTR)lpmh, (DWORD)sizeof(MIDIHDR));
                        lpmh->dwFlags &= ~MHDR_SAVE;
                        lpmh->dwFlags |= dwSaveFlags;
                        if (MMSYSERR_NOTSUPPORTED == wRet)
                            wRet = midiUnprepareHeader(lpmh, sizeof(MIDIHDR));
                    }
            }

            LEAVE_MM_HANDLE((HMIDI)hMidiOut);

            return wRet;
            
        default:
            ReleaseHandleListResource(); 
            break;
    }

    return MMSYSERR_INVALHANDLE;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiOutUnprepareHeader | This function cleans up the
 * preparation performed by <f midiOutPrepareHeader>. The
 * <f midiOutUnprepareHeader> function must be called
 * after the device driver fills a data buffer and returns it to the
 * application. You must call this function before freeing the data
 * buffer.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI output
 *   device.
 *
 * @parm LPMIDIHDR | lpMidiOutHdr |  Specifies a pointer to a <t MIDIHDR>
 *   structure identifying the buffer to be cleaned up.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_STILLPLAYING | <p lpMidiOutHdr> is still in the queue.
 *
 * @comm This function is the complementary function to
 * <f midiOutPrepareHeader>.
 * You must call this function before freeing the data buffer with
 * <f GlobalFree>.
 * After passing a buffer to the device driver with <f midiOutLongMsg>, you
 * must wait until the driver is finished with the buffer before calling
 * <f midiOutUnprepareHeader>.
 *
 * Unpreparing a buffer that has not been
 * prepared has no effect, and the function returns zero.
 *
 * @xref midiOutPrepareHeader
 ****************************************************************************/
MMRESULT APIENTRY midiOutUnprepareHeader(HMIDIOUT hMidiOut, LPMIDIHDR lpMidiOutHdr, UINT wSize)
{
    MMRESULT         wRet;
    MMRESULT                 mmrc;
    PMIDISTRM        pms;
    PMIDISTRMID      pmsi;
    DWORD            idx;
    LPMIDIHDR        lpmh;
    DWORD            dwSaveFlags;

    V_HEADER(lpMidiOutHdr, wSize, TYPE_MIDIOUT, MMSYSERR_INVALPARAM);
    
    if (!(lpMidiOutHdr->dwFlags & MHDR_PREPARED))
        return MMSYSERR_NOERROR;

    if(lpMidiOutHdr->dwFlags & MHDR_INQUEUE)
    {
        DebugErr(DBF_WARNING, "midiOutUnprepareHeader: header still in queue\r\n");
        return MIDIERR_STILLPLAYING;
    }
    
    ClientUpdatePnpInfo();
    
    AcquireHandleListResourceShared();
    
    if (BAD_HANDLE(hMidiOut, TYPE_MIDIOUT) && BAD_HANDLE(hMidiOut, TYPE_MIDISTRM))
    {
        ReleaseHandleListResource();
        return MMSYSERR_INVALHANDLE;
    }

    switch(GetHandleType(hMidiOut))
    {
        case TYPE_MIDIOUT:
            dwSaveFlags = lpMidiOutHdr->dwFlags & MHDR_SAVE;
            wRet = midiMessage((HMIDI)hMidiOut, MODM_UNPREPARE, (DWORD_PTR)lpMidiOutHdr, (DWORD)wSize);
            lpMidiOutHdr->dwFlags &= ~MHDR_SAVE;
            lpMidiOutHdr->dwFlags |= dwSaveFlags;

            if (wRet == MMSYSERR_NOTSUPPORTED)
                return midiUnprepareHeader(lpMidiOutHdr, wSize);

            if ((wRet == MMSYSERR_NODRIVER) && (IsHandleDeserted(hMidiOut)))
            {
                //  if the driver for the handle has been removed, succeed
                //  the call.

                wRet = MMSYSERR_NOERROR;
            }

            return wRet;

         case TYPE_MIDISTRM:
            ENTER_MM_HANDLE((HMIDI)hMidiOut);
            ReleaseHandleListResource(); 
    
            pms = HtoPT(PMIDISTRM, hMidiOut);
            wRet = MMSYSERR_NOERROR;
            lpmh = (LPMIDIHDR)lpMidiOutHdr->dwReserved[MH_SHADOW];

//                       assert ((HIWORD(lpmh) & 0xFFFE) != (HIWORD(lpMidiOutHdr) & 0xFFFE));

            for (idx = 0, pmsi = pms->rgIds; idx < pms->cIds; idx++, pmsi++)
                if (pmsi->fdwId & MSI_F_FIRST)
                {
                    dwSaveFlags = lpmh->dwFlags & MHDR_SAVE;
                    mmrc = (MMRESULT)midiStreamMessage(pmsi, MODM_UNPREPARE, (DWORD_PTR)lpmh, (DWORD)sizeof(MIDIHDR));
                    lpmh->dwFlags &= ~MHDR_SAVE;
                    lpmh->dwFlags |= dwSaveFlags;
                    if (MMSYSERR_NOTSUPPORTED == mmrc)
                        mmrc = midiUnprepareHeader(lpmh, sizeof(MIDIHDR));

                    if (MMSYSERR_NOERROR != mmrc)
                        wRet = mmrc;

                    lpmh++;
                }

//                       assert (HIWORD(lpmh) == HIWORD(lpMidiOutHdr->dwReserved[MH_SHADOW]));

            GlobalFree(GlobalHandle((LPMIDIHDR)lpMidiOutHdr->dwReserved[MH_SHADOW]));
            lpMidiOutHdr->dwReserved[MH_SHADOW] = 0;

            mmrc = midiUnprepareHeader(lpMidiOutHdr, wSize);
            if (MMSYSERR_NOERROR != mmrc)
                wRet = mmrc;

            LEAVE_MM_HANDLE((HMIDI)hMidiOut);

            return wRet;
            
        default:
            ReleaseHandleListResource(); 
            break;
     }

     return MMSYSERR_INVALHANDLE;

}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiOutShortMsg | This function sends a short MIDI message to
 *   the specified MIDI output device.  Use this function to send any MIDI
 *   message except for system-exclusive messages.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI output
 *   device.
 *
 * @parm DWORD | dwMsg | Specifies the MIDI message.  The message is packed
 *   into a DWORD with the first byte of the message in the low-order byte.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_NOTREADY | The hardware is busy with other data.
 *
 * @comm This function may not return until the message has been sent to the
 *   output device.
 *
 * @xref midiOutLongMsg
 ****************************************************************************/
MMRESULT APIENTRY midiOutShortMsg(HMIDIOUT hMidiOut, DWORD dwMsg)
{
    MMRESULT    mmr;

    ClientUpdatePnpInfo();

    AcquireHandleListResourceShared();

    if (BAD_HANDLE(hMidiOut, TYPE_MIDIOUT) && BAD_HANDLE(hMidiOut, TYPE_MIDISTRM))
    {
        ReleaseHandleListResource();
        return MMSYSERR_INVALHANDLE;
    }

    switch(GetHandleType(hMidiOut))
    {
    case TYPE_MIDIOUT:
        return (MMRESULT)midiMessage((HMIDI)hMidiOut, MODM_DATA, dwMsg, 0L);

    case TYPE_MIDISTRM:
        ENTER_MM_HANDLE((HMIDI)hMidiOut);
        ReleaseHandleListResource();
        mmr = (MMRESULT)midiStreamMessage(HtoPT(PMIDISTRM, hMidiOut)->rgIds, MODM_DATA, dwMsg, 0L);
        LEAVE_MM_HANDLE((HMIDI)hMidiOut);
        return (mmr);
    }

    ReleaseHandleListResource();
    return MMSYSERR_INVALHANDLE;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiOutLongMsg | This function sends a system-exclusive
 *   MIDI message to the specified MIDI output device.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI output
 *   device.
 *
 * @parm LPMIDIHDR | lpMidiOutHdr | Specifies a far pointer to a <t MIDIHDR>
 *   structure that identifies the MIDI data buffer.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_UNPREPARED | <p lpMidiOutHdr> hasn't been prepared.
 *   @flag MIDIERR_NOTREADY | The hardware is busy with other data.
 *
 * @comm The data buffer must be prepared with <f midiOutPrepareHeader>
 *   before it is passed to <f midiOutLongMsg>.  The <t MIDIHDR> data
 *   structure and the data buffer pointed to by its <e MIDIHDR.lpData>
 *   field must be allocated with <f GlobalAlloc> using the GMEM_MOVEABLE
 *   and GMEM_SHARE flags, and locked with <f GlobalLock>. The MIDI output
 *   device driver determines whether the data is sent synchronously or
 *   asynchronously.
 *
 * @xref midiOutShortMsg midiOutPrepareHeader
 ****************************************************************************/
MMRESULT APIENTRY midiOutLongMsg(HMIDIOUT hMidiOut, LPMIDIHDR lpMidiOutHdr, UINT wSize)
{
    V_HEADER(lpMidiOutHdr, wSize, TYPE_MIDIOUT, MMSYSERR_INVALPARAM);

    if (lpMidiOutHdr->dwFlags & ~MHDR_VALID)
    return MMSYSERR_INVALFLAG;

    if (!(lpMidiOutHdr->dwFlags & MHDR_PREPARED))
    return MIDIERR_UNPREPARED;

    if (lpMidiOutHdr->dwFlags & MHDR_INQUEUE)
    return MIDIERR_STILLPLAYING;

    if (!lpMidiOutHdr->dwBufferLength)
        return MMSYSERR_INVALPARAM;

    lpMidiOutHdr->dwFlags &= ~MHDR_ISSTRM;

    ClientUpdatePnpInfo();

    AcquireHandleListResourceShared();

    if (BAD_HANDLE(hMidiOut, TYPE_MIDIOUT) && BAD_HANDLE(hMidiOut, TYPE_MIDISTRM))
    {
        ReleaseHandleListResource();
        return MMSYSERR_INVALHANDLE;
    }
       
    switch(GetHandleType(hMidiOut))
    {
        case TYPE_MIDIOUT:
         return (MMRESULT)midiMessage((HMIDI)hMidiOut, MODM_LONGDATA, (DWORD_PTR)lpMidiOutHdr, (DWORD)wSize);

        case TYPE_MIDISTRM:
         ReleaseHandleListResource();
         return MMSYSERR_NOTSUPPORTED;
         
        default:
         ReleaseHandleListResource();
         break;
    }

    return MMSYSERR_INVALHANDLE;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiOutReset | This function turns off all notes on all MIDI
 *   channels for the specified MIDI output device. Any pending
 *   system-exclusive output buffers are marked as done and
 *   returned to the application.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI output
 *   device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm To turn off all notes, a note-off message for each note for each
 *   channel is sent. In addition, the sustain controller is turned off for
 *   each channel.
 *
 * @xref midiOutLongMsg midiOutClose
 ****************************************************************************/
MMRESULT APIENTRY midiOutReset(HMIDIOUT hMidiOut)
{
    PMIDISTRM   pms;
    MMRESULT    mmr;

    ClientUpdatePnpInfo();
    
    AcquireHandleListResourceShared();
    
    if (BAD_HANDLE(hMidiOut, TYPE_MIDIOUT) && BAD_HANDLE(hMidiOut, TYPE_MIDISTRM))
    {
        ReleaseHandleListResource();
        return MMSYSERR_INVALHANDLE;
    }

    switch(GetHandleType(hMidiOut))
    {
    case TYPE_MIDIOUT:
        mmr = (MMRESULT)midiMessage((HMIDI)hMidiOut, MODM_RESET, 0, 0);
        break;

    case TYPE_MIDISTRM:
        pms = HtoPT(PMIDISTRM, hMidiOut);
        ReleaseHandleListResource();
        mmr = (MMRESULT)midiStreamBroadcast(pms, MODM_RESET, 0, 0);
        break;

    default:
        ReleaseHandleListResource();
        mmr = MMSYSERR_INVALHANDLE;
        break;
    }

    if ((mmr == MMSYSERR_NODRIVER) && (IsHandleDeserted(hMidiOut)))
    {
        mmr = MMSYSERR_NOERROR;
    }

    return mmr;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiOutCachePatches | This function requests that an internal
 *   MIDI synthesizer device preload a specified set of patches. Some
 *   synthesizers are not capable of keeping all patches loaded simultaneously
 *   and must load data from disk when they receive MIDI program change
 *   messages. Caching patches ensures specified patches are immediately
 *   available.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the opened MIDI output
 *   device. This device must be an internal MIDI synthesizer.
 *
 * @parm UINT | wBank | Specifies which bank of patches should be used.
 *   This parameter should be set to zero to cache the default patch bank.
 *
 * @parm LPWORD | lpPatchArray | Specifies a pointer to a <t PATCHARRAY>
 *   array indicating the patches to be cached or uncached.
 *
 * @parm UINT | wFlags | Specifies options for the cache operation. Only one
 *   of the following flags can be specified:
 *      @flag MIDI_CACHE_ALL | Cache all of the specified patches. If they
 *         can't all be cached, cache none, clear the <t PATCHARRAY> array,
 *         and return MMSYSERR_NOMEM.
 *      @flag MIDI_CACHE_BESTFIT | Cache all of the specified patches.
 *         If all patches can't be cached, cache as many patches as
 *         possible, change the <t PATCHARRAY> array to reflect which
 *         patches were cached, and return MMSYSERR_NOMEM.
 *      @flag MIDI_CACHE_QUERY | Change the <t PATCHARRAY> array to indicate
 *         which patches are currently cached.
 *      @flag MIDI_UNCACHE | Uncache the specified patches and clear the
 *         <t PATCHARRAY> array.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   one of the following error codes:
 *      @flag MMSYSERR_INVALHANDLE | The specified device handle is invalid.
 *      @flag MMSYSERR_NOTSUPPORTED | The specified device does not support
 *          patch caching.
 *      @flag MMSYSERR_NOMEM | The device does not have enough memory to cache
 *          all of the requested patches.
 *
 * @comm The <t PATCHARRAY> data type is defined as:
 *
 *   typedef UINT PATCHARRAY[MIDIPATCHSIZE];
 *
 *   Each element of the array represents one of the 128 patches and
 *   has bits set for
 *   each of the 16 MIDI channels that use that particular patch. The
 *   least-significant bit represents physical channel 0; the
 *   most-significant bit represents physical channel 15 (0x0F). For
 *   example, if patch 0 is used by physical channels 0 and 8, element 0
 *   would be set to 0x0101.
 *
 *   This function only applies to internal MIDI synthesizer devices.
 *   Not all internal synthesizers support patch caching. Use the
 *   MIDICAPS_CACHE flag to test the <e MIDIOUTCAPS.dwSupport> field of the
 *   <t MIDIOUTCAPS> structure filled by <f midiOutGetDevCaps> to see if the
 *   device supports patch caching.
 *
 * @xref midiOutCacheDrumPatches
 ****************************************************************************/
MMRESULT APIENTRY midiOutCachePatches(HMIDIOUT hMidiOut, UINT wBank,
                     LPWORD lpPatchArray, UINT wFlags)
{
    V_WPOINTER(lpPatchArray, sizeof(PATCHARRAY), MMSYSERR_INVALPARAM);
    V_FLAGS(wFlags, MIDI_CACHE_VALID, midiOutCacheDrumPatches, MMSYSERR_INVALFLAG);

    ClientUpdatePnpInfo();

    AcquireHandleListResourceShared();

    if (BAD_HANDLE(hMidiOut, TYPE_MIDIOUT) && BAD_HANDLE(hMidiOut, TYPE_MIDISTRM))
    {
        ReleaseHandleListResource();
        return MMSYSERR_INVALHANDLE;
    }

    switch(GetHandleType(hMidiOut))
    {
    case TYPE_MIDIOUT:
        return (MMRESULT)midiMessage((HMIDI)hMidiOut,
                     MODM_CACHEPATCHES,
                     (DWORD_PTR)lpPatchArray,
                     MAKELONG(wFlags, wBank));

    case TYPE_MIDISTRM:
        ReleaseHandleListResource();
        return (MMRESULT)midiStreamBroadcast((PMIDISTRM)hMidiOut,
                         MODM_CACHEPATCHES,
                         (DWORD_PTR)lpPatchArray,
                         MAKELONG(wFlags, wBank));
                    
    default:
        ReleaseHandleListResource();
        break;     
    }

    return MMSYSERR_INVALHANDLE;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiOutCacheDrumPatches | This function requests that an
 *   internal MIDI synthesizer device preload a specified set of key-based
 *   percussion patches. Some synthesizers are not capable of keeping all
 *   percussion patches loaded simultaneously. Caching patches ensures
 *   specified patches are available.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the opened MIDI output
 *   device. This device should be an internal MIDI synthesizer.
 *
 * @parm UINT | wPatch | Specifies which drum patch number should be used.
 *   This parameter should be set to zero to cache the default drum patch.
 *
 * @parm LPWORD | lpKeyArray | Specifies a pointer to a <t KEYARRAY>
 *   array indicating the key numbers of the specified percussion patches
 *  to be cached or uncached.
 *
 * @parm UINT | wFlags | Specifies options for the cache operation. Only one
 *   of the following flags can be specified:
 *      @flag MIDI_CACHE_ALL | Cache all of the specified patches. If they
 *         can't all be cached, cache none, clear the <t KEYARRAY> array,
 *       and return MMSYSERR_NOMEM.
 *      @flag MIDI_CACHE_BESTFIT | Cache all of the specified patches.
 *         If all patches can't be cached, cache as many patches as
 *         possible, change the <t KEYARRAY> array to reflect which
 *         patches were cached, and return MMSYSERR_NOMEM.
 *      @flag MIDI_CACHE_QUERY | Change the <t KEYARRAY> array to indicate
 *         which patches are currently cached.
 *      @flag MIDI_UNCACHE | Uncache the specified patches and clear the
 *       <t KEYARRAY> array.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   one of the following error codes:
 *      @flag MMSYSERR_INVALHANDLE | The specified device handle is invalid.
 *      @flag MMSYSERR_NOTSUPPORTED | The specified device does not support
 *          patch caching.
 *      @flag MMSYSERR_NOMEM | The device does not have enough memory to cache
 *          all of the requested patches.
 *
 * @comm The <t KEYARRAY> data type is defined as:
 *
 *   typedef UINT KEYARRAY[MIDIPATCHSIZE];
 *
 *   Each element of the array represents one of the 128 key-based percussion
 *   patches and has bits set for
 *   each of the 16 MIDI channels that use that particular patch. The
 *   least-significant bit represents physical channel 0; the
 *   most-significant bit represents physical channel 15. For
 *   example, if the patch on key number 60 is used by physical channels 9
 *   and 15, element 60 would be set to 0x8200.
 *
 *   This function applies only to internal MIDI synthesizer devices.
 *   Not all internal synthesizers support patch caching. Use the
 *   MIDICAPS_CACHE flag to test the <e MIDIOUTCAPS.dwSupport> field of the
 *   <t MIDIOUTCAPS> structure filled by <f midiOutGetDevCaps> to see if the
 *   device supports patch caching.
 *
 * @xref midiOutCachePatches
 ****************************************************************************/
MMRESULT APIENTRY midiOutCacheDrumPatches(HMIDIOUT hMidiOut, UINT wPatch,
                     LPWORD lpKeyArray, UINT wFlags)
{
    V_WPOINTER(lpKeyArray, sizeof(KEYARRAY), MMSYSERR_INVALPARAM);
    V_FLAGS(wFlags, MIDI_CACHE_VALID, midiOutCacheDrumPatches, MMSYSERR_INVALFLAG);

    ClientUpdatePnpInfo();

    AcquireHandleListResourceShared();

    if (BAD_HANDLE(hMidiOut, TYPE_MIDIOUT) && BAD_HANDLE(hMidiOut, TYPE_MIDISTRM))
    {
        ReleaseHandleListResource();
        return MMSYSERR_INVALHANDLE;
    }

    switch(GetHandleType(hMidiOut))
    {
    case TYPE_MIDIOUT:
        return (MMRESULT)midiMessage((HMIDI)hMidiOut,
                     MODM_CACHEDRUMPATCHES,
                     (DWORD_PTR)lpKeyArray,
                     MAKELONG(wFlags, wPatch));

    case TYPE_MIDISTRM:
        ReleaseHandleListResource();
        return (MMRESULT)midiStreamBroadcast((PMIDISTRM)hMidiOut,
                         MODM_CACHEDRUMPATCHES,
                         (DWORD_PTR)lpKeyArray,
                         MAKELONG(wFlags, wPatch));
                    
    default:
        ReleaseHandleListResource();
        break;     
    }

    return MMSYSERR_INVALHANDLE;
}


//--------------------------------------------------------------------------;
//
//  MMRESULT midiOutDesertHandle
//
//  Description:
//      Cleans up the midi out handle and marks it as deserted.
//
//  Arguments:
//      HMIDIOUT hMidiOut:  MIDI out handle.
//
//  Return (MMRESULT):  Error code.
//
//  History:
//      01/25/99    Fwong       Adding Pnp Support.
//
//--------------------------------------------------------------------------;

MMRESULT midiOutDesertHandle
(
    HMIDIOUT    hMidiOut
)
{
    MMRESULT    mmr;
    PMIDIDEV    pDev = (PMIDIDEV)hMidiOut;

    V_HANDLE_ACQ(hMidiOut, TYPE_MIDIOUT, MMSYSERR_INVALHANDLE);

    ENTER_MM_HANDLE((HMIDI)hMidiOut);
    ReleaseHandleListResource();

    if (IsHandleDeserted(hMidiOut))
    {
        //  Handle has already been deserted...
        LEAVE_MM_HANDLE((HMIDI)hMidiOut);
        return(MMSYSERR_NOERROR);
    }

    if (IsHandleBusy(hMidiOut))
    {
        //  Not quite invalid, but marked as closed.
    
        LEAVE_MM_HANDLE(hMidiOut);
        return (MMSYSERR_HANDLEBUSY);
    }

    //  Marking handle as deserted
    SetHandleFlag(hMidiOut, MMHANDLE_DESERTED);

    //  Since the handle was invalidated, we have to send the message ourselves...

    (*(pDev->mididrv->drvMessage))(pDev->wDevice, MODM_RESET, pDev->dwDrvUser, 0L, 0L);
    (*(pDev->mididrv->drvMessage))(pDev->wDevice, MODM_CLOSE, pDev->dwDrvUser, 0L, 0L);

    LEAVE_MM_HANDLE((HMIDI)hMidiOut);

    // ISSUE-2001/01/14-FrankYe Probably don't want to dec usage here,
    //    dec on close instead.
    mregDecUsage(PTtoH(HMD, pDev->mididrv));

    //  Mark handle as deserted, but not freeing.

    return MMSYSERR_NOERROR;
} // midiOutDesertHandle()


/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiInGetNumDevs | This function retrieves the number of MIDI
 *   input devices in the system.
 *
 * @rdesc Returns the number of MIDI input devices present in the system.
 *
 * @xref midiInGetDevCaps
 ****************************************************************************/
UINT APIENTRY midiInGetNumDevs(void)
{
    UINT    cDevs;

    ClientUpdatePnpInfo();

    EnterNumDevs("midiInGetNumDevs");
    cDevs = wTotalMidiInDevs;
    LeaveNumDevs("midiInGetNumDevs");

    return cDevs;
}

/****************************************************************************
 * @doc EXTERNAL MIDI
 *
 * @api MMRESULT | midiInMessage | This function sends messages to the MIDI device
 *   drivers.
 *
 * @parm HMIDIIN | hMidiIn | The handle to the MIDI device.
 *
 * @parm UINT  | msg | The message to send.
 *
 * @parm DWORD | dw1 | Parameter 1.
 *
 * @parm DWORD | dw2 | Parameter 2.
 *
 * @rdesc Returns the value of the message sent.
 ***************************************************************************/
MMRESULT APIENTRY midiInMessage(HMIDIIN hMidiIn, UINT msg, DWORD_PTR dw1, DWORD_PTR dw2)
{
    ClientUpdatePnpInfo();

    AcquireHandleListResourceShared();
    
    if (BAD_HANDLE(hMidiIn, TYPE_MIDIIN))
    {
        ReleaseHandleListResource();
        return midiIDMessage(&midiindrvZ, wTotalMidiInDevs, (UINT_PTR)hMidiIn, msg, dw1, dw2);
    }
    
    return midiMessage((HMIDI)hMidiIn, msg, dw1, dw2);
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiInGetDevCaps | This function queries a specified MIDI input
 *    device to determine its capabilities.
 *
 * @parm UINT | uDeviceID | Identifies the MIDI input device.
 *
 * @parm LPMIDIINCAPS | lpCaps | Specifies a far pointer to a <t MIDIINCAPS>
 *   data structure.  This structure is filled with information about
 *   the capabilities of the device.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIINCAPS> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *
 * @comm Use <f midiInGetNumDevs> to determine the number of MIDI input
 *   devices present in the system.  The device ID specified by <p uDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   The MIDI_MAPPER constant may also be used as a device id. Only
 *   <p wSize> bytes (or less) of information is copied to the location
 *   pointed to by <p lpCaps>.  If <p wSize> is zero, nothing is copied,
 *   and the function returns zero.
 *
 * @xref midiInGetNumDevs
 ****************************************************************************/
MMRESULT APIENTRY midiInGetDevCapsW(UINT_PTR uDeviceID, LPMIDIINCAPSW lpCaps, UINT wSize)
{
    DWORD_PTR       dwParam1, dwParam2;
    MDEVICECAPSEX   mdCaps;
    PCWSTR          DevInterface;
    MMRESULT        mmr;

    if (wSize == 0)
     return MMSYSERR_NOERROR;

    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();

    DevInterface = midiReferenceDevInterfaceById(&midiindrvZ, uDeviceID);
    dwParam2 = (DWORD_PTR)DevInterface;

    if (0 == dwParam2)
    {
        dwParam1 = (DWORD_PTR)lpCaps;
        dwParam2 = (DWORD)wSize;
    }
    else
    {
        mdCaps.cbSize = (DWORD)wSize;
        mdCaps.pCaps  = lpCaps;
        dwParam1      = (DWORD_PTR)&mdCaps;
    }

    AcquireHandleListResourceShared();
    
    if (BAD_HANDLE((HMIDI)uDeviceID, TYPE_MIDIIN))
    {
        ReleaseHandleListResource();
    	mmr = midiIDMessage(&midiindrvZ, wTotalMidiInDevs, uDeviceID, MIDM_GETDEVCAPS, dwParam1, dwParam2);
    }
    else
    {
    	mmr = (MMRESULT)midiMessage((HMIDI)uDeviceID, MIDM_GETDEVCAPS, dwParam1, dwParam2);
    }

    if (DevInterface) wdmDevInterfaceDec(DevInterface);
    return mmr;
}

MMRESULT APIENTRY midiInGetDevCapsA(UINT_PTR uDeviceID, LPMIDIINCAPSA lpCaps, UINT wSize)
{
    MIDIINCAPS2W   wDevCaps2;
    MIDIINCAPS2A   aDevCaps2;
    DWORD_PTR      dwParam1, dwParam2;
    MDEVICECAPSEX  mdCaps;
    PCWSTR         DevInterface;
    MMRESULT       mmRes;
    CHAR           chTmp[ MAXPNAMELEN * sizeof(WCHAR) ];

    if (wSize == 0)
    return MMSYSERR_NOERROR;

    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();

    DevInterface = midiReferenceDevInterfaceById(&midiindrvZ, uDeviceID);
    dwParam2 = (DWORD_PTR)DevInterface;

    memset(&wDevCaps2, 0, sizeof(wDevCaps2));

    if (0 == dwParam2)
    {
        dwParam1 = (DWORD_PTR)&wDevCaps2;
        dwParam2 = (DWORD)sizeof(wDevCaps2);
    }
    else
    {
        mdCaps.cbSize = (DWORD)sizeof(wDevCaps2);
        mdCaps.pCaps  = &wDevCaps2;
        dwParam1      = (DWORD_PTR)&mdCaps;
    }

    AcquireHandleListResourceShared();
    
    if (BAD_HANDLE((HMIDI)uDeviceID, TYPE_MIDIIN))
    {
        ReleaseHandleListResource();
        mmRes = midiIDMessage( &midiindrvZ, wTotalMidiInDevs, uDeviceID,
                               MIDM_GETDEVCAPS, dwParam1, dwParam2);
    }
    else
    {
        mmRes = midiMessage((HMIDI)uDeviceID, MIDM_GETDEVCAPS,
                            (DWORD)dwParam1, (DWORD)dwParam2);
    }

    if (DevInterface) wdmDevInterfaceDec(DevInterface);
    
    //
    // Make sure the call worked before proceeding with the thunk.
    //
    if ( mmRes != MMSYSERR_NOERROR ) {
    return  mmRes;
    }

    aDevCaps2.wMid             = wDevCaps2.wMid;
    aDevCaps2.wPid             = wDevCaps2.wPid;
    aDevCaps2.vDriverVersion   = wDevCaps2.vDriverVersion;
    aDevCaps2.dwSupport        = wDevCaps2.dwSupport;
    aDevCaps2.ManufacturerGuid = wDevCaps2.ManufacturerGuid;
    aDevCaps2.ProductGuid      = wDevCaps2.ProductGuid;
    aDevCaps2.NameGuid         = wDevCaps2.NameGuid;

    // copy and convert unicode to ascii here.
    UnicodeStrToAsciiStr( chTmp, chTmp +  sizeof( chTmp ), wDevCaps2.szPname );
    strcpy( aDevCaps2.szPname, chTmp );

    //
    // now copy the required amount into the callers buffer.
    //
    CopyMemory( lpCaps, &aDevCaps2, min(wSize, sizeof(aDevCaps2)));

    return mmRes;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiInGetErrorText | This function retrieves a textual
 *   description of the error identified by the specified error number.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPTSTR | lpText | Specifies a far pointer to the buffer to be
 *   filled with the textual error description.
 *
 * @parm UINT | wSize | Specifies the length in characters of the buffer
 *   pointed to by <p lpText>.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADERRNUM | Specified error number is out of range.
 *
 * @comm If the textual error description is longer than the specified buffer,
 * the description is truncated.  The returned error string is always
 * null-terminated. If <p wSize> is zero, nothing is copied, and
 * the function returns zero. All error descriptions are
 * less than MAXERRORLENGTH characters long.
 ****************************************************************************/
MMRESULT APIENTRY midiInGetErrorTextW(UINT wError, LPWSTR lpText, UINT wSize)
{
    if(wSize == 0)
    return MMSYSERR_NOERROR;

    V_WPOINTER(lpText, wSize*sizeof(WCHAR), MMSYSERR_INVALPARAM);

    return midiGetErrorTextW(wError, lpText, wSize);
}

MMRESULT APIENTRY midiInGetErrorTextA(UINT wError, LPSTR lpText, UINT wSize)
{
    if(wSize == 0)
    return MMSYSERR_NOERROR;

    V_WPOINTER(lpText, wSize, MMSYSERR_INVALPARAM);

    return midiGetErrorTextA(wError, lpText, wSize);
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiInOpen | This function opens a specified MIDI input device.
 *
 * @parm LPHMIDIIN | lphMidiIn | Specifies a far pointer to an HMIDIIN handle.
 *   This location is filled with a handle identifying the opened MIDI
 *   input device.  Use the handle to identify the device when calling
 *   other MIDI input functions.
 *
 * @parm UINT | uDeviceID | Identifies the MIDI input device to be
 *   opened.
 *
 * @parm DWORD | dwCallback | Specifies the address of a fixed callback
 *   function or a handle to a window called with information
 *   about incoming MIDI messages.
 *
 * @parm DWORD | dwCallbackInstance | Specifies user instance data
 *   passed to the callback function.  This parameter is not
 *   used with window callbacks.
 *
 * @parm DWORD | dwFlags | Specifies a callback flag for opening the device.
 *   @flag CALLBACK_WINDOW | If this flag is specified, <p dwCallback> is
 *      assumed to be a window handle.
 *   @flag CALLBACK_FUNCTION | If this flag is specified, <p dwCallback> is
 *      assumed to be a callback procedure address.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_ALLOCATED | Specified resource is already allocated.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *
 * @comm Use <f midiInGetNumDevs> to determine the number of MIDI input
 *   devices present in the system.  The device ID specified by <p uDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   The MIDI_MAPPER constant may also be used as a device id.
 *
 *   If a window is chosen to receive callback information, the following
 *   messages are sent to the window procedure function to indicate the
 *   progress of MIDI input:  <m MM_MIM_OPEN>, <m MM_MIM_CLOSE>,
 *   <m MM_MIM_DATA>, <m MM_MIM_LONGDATA>, <m MM_MIM_ERROR>,
 *   <m MM_MIM_LONGERROR>.
 *
 *   If a function is chosen to receive callback information, the following
 *   messages are sent to the function to indicate the progress of MIDI
 *   input:  <m MIM_OPEN>, <m MIM_CLOSE>, <m MIM_DATA>, <m MIM_LONGDATA>,
 *   <m MIM_ERROR>, <m MIM_LONGERROR>.  The callback function must reside in
 *   a DLL.  You do not have to use <f MakeProcInstance> to get a
 *   procedure-instance address for the callback function.
 *
 * @cb void CALLBACK | MidiInFunc | <f MidiInFunc> is a placeholder for
 *   the application-supplied function name.  The actual name must be
 *   exported by including it in an EXPORTS statement in the DLL's module
 *   definition file.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input device.
 *
 * @parm UINT | wMsg | Specifies a MIDI input message.
 *
 * @parm DWORD | dwInstance | Specifies the instance data supplied
 *      with <f midiInOpen>.
 *
 * @parm DWORD | dwParam1 | Specifies a parameter for the message.
 *
 * @parm DWORD | dwParam2 | Specifies a parameter for the message.
 *
 * @comm Because the callback is accessed at interrupt time, it must reside
 *   in a DLL, and its code segment must be specified as FIXED in the
 *   module-definition file for the DLL.  Any data that the callback accesses
 *   must be in a FIXED data segment as well. The callback may not make any
 *   system calls except for <f PostMessage>, <f timeGetSystemTime>,
 *   <f timeGetTime>, <f timeSetEvent>, <f timeKillEvent>,
 *   <f midiOutShortMsg>, <f midiOutLongMsg>, and <f OutputDebugStr>.
 *
 * @xref midiInClose
 ****************************************************************************/
MMRESULT APIENTRY midiInOpen(LPHMIDIIN lphMidiIn, UINT uDeviceID,
    DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD dwFlags)
{
    MIDIOPENDESC mo;
    PMIDIDEV     pdev;
    PMIDIDRV     mididrv;
    UINT         port;
    MMRESULT     wRet;

    V_WPOINTER(lphMidiIn, sizeof(HMIDIIN), MMSYSERR_INVALPARAM);
    if (uDeviceID == MIDI_MAPPER) {
    V_FLAGS(LOWORD(dwFlags), MIDI_I_VALID & ~LOWORD(MIDI_IO_COOKED | MIDI_IO_SHARED), midiInOpen, MMSYSERR_INVALFLAG);
    } else {
    V_FLAGS(LOWORD(dwFlags), MIDI_I_VALID & ~LOWORD(MIDI_IO_COOKED) , midiInOpen, MMSYSERR_INVALFLAG);
    }
    V_DCALLBACK(dwCallback, HIWORD(dwFlags), MMSYSERR_INVALPARAM);

    *lphMidiIn = NULL;

    ClientUpdatePnpInfo();

    wRet = midiReferenceDriverById(&midiindrvZ, uDeviceID, &mididrv, &port);
    if (wRet)
    {
        return wRet;
    }

    if (!mididrv->drvMessage)
    {
    	mregDecUsagePtr(mididrv);
    	return MMSYSERR_NODRIVER;
    }

    pdev = (PMIDIDEV)NewHandle(TYPE_MIDIIN, mididrv->cookie, sizeof(MIDIDEV));
    if( pdev == NULL)
    {
    	mregDecUsagePtr(mididrv);
    	return MMSYSERR_NOMEM;
    }

    ENTER_MM_HANDLE(pdev);
    SetHandleFlag(pdev, MMHANDLE_BUSY);
    ReleaseHandleListResource();

    pdev->mididrv = mididrv;
    pdev->wDevice = port;
    pdev->uDeviceID = uDeviceID;
    pdev->fdwHandle = 0;

    mo.hMidi      = (HMIDI)pdev;
    mo.dwCallback = dwCallback;
    mo.dwInstance = dwInstance;
    mo.dnDevNode  = (DWORD_PTR)pdev->mididrv->cookie;

    wRet = (MMRESULT)((*(mididrv->drvMessage))
    (pdev->wDevice, MIDM_OPEN, (DWORD_PTR)&pdev->dwDrvUser, (DWORD_PTR)(LPMIDIOPENDESC)&mo, dwFlags));

    if (!wRet)
        ClearHandleFlag(pdev, MMHANDLE_BUSY);
        
    LEAVE_MM_HANDLE(pdev);

    if (wRet)
        FreeHandle((HMIDIIN)pdev);
    else {
        mregIncUsagePtr(mididrv);
        *lphMidiIn = (HMIDIIN)pdev;
    }

    mregDecUsagePtr(mididrv);
    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiInClose | This function closes the specified MIDI input
 *   device.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input device.
 *  If the function is successful, the handle is no longer
 *   valid after this call.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_STILLPLAYING | There are still buffers in the queue.
 *
 * @comm If there are input buffers that have been sent with
 *   <f midiInAddBuffer> and haven't been returned to the application,
 *   the close operation will fail.  Call <f midiInReset> to mark all
 *   pending buffers as being done.
 *
 * @xref midiInOpen midiInReset
 ****************************************************************************/
MMRESULT APIENTRY midiInClose(HMIDIIN hMidiIn)
{
    MMRESULT         wRet;
    PMIDIDRV         pmididrv;
    PMIDIDEV         pDev = (PMIDIDEV)hMidiIn;

    ClientUpdatePnpInfo();
    
    V_HANDLE_ACQ(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);
    
    ENTER_MM_HANDLE((HMIDI)hMidiIn);
    ReleaseHandleListResource();
    
    if (IsHandleDeserted(hMidiIn))
    {
        //  This handle has been deserted.  Let's just free it.

        LEAVE_MM_HANDLE((HMIDI)hMidiIn);
        FreeHandle(hMidiIn);
        return MMSYSERR_NOERROR;
    }
    
    if (IsHandleBusy(hMidiIn))
    {
        //  Not quite invalid, but marked as closed.
    
        LEAVE_MM_HANDLE(hMidiIn);
        return (MMSYSERR_HANDLEBUSY);
    }

    //  Marking handle as 'invalid/closed'.
    SetHandleFlag(hMidiIn, MMHANDLE_BUSY);
    
    pmididrv = pDev->mididrv;
    
    wRet = (MMRESULT)(*(pmididrv->drvMessage))(pDev->wDevice, MIDM_CLOSE, pDev->dwDrvUser, 0L, 0L);
    
    if (MMSYSERR_NOERROR != wRet)
    {
        ClearHandleFlag(hMidiIn, MMHANDLE_BUSY);
    }
    
    LEAVE_MM_HANDLE((HWAVE)hMidiIn);
    
    if (!wRet)
    {
        FreeHandle(hMidiIn);
    	mregDecUsagePtr(pmididrv);
        return wRet;
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiInPrepareHeader | This function prepares a buffer for
 *   MIDI input.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input
 *   device.
 *
 * @parm LPMIDIHDR | lpMidiInHdr | Specifies a pointer to a <t MIDIHDR>
 *   structure that identifies the buffer to be prepared.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *
 * @comm The <t MIDIHDR> data structure and the data block pointed to by its
 *   <e MIDIHDR.lpData> field must be allocated with <f GlobalAlloc> using the
 *   GMEM_MOVEABLE and GMEM_SHARE flags, and locked with <f GlobalLock>.
 *   Preparing a header that has already been prepared has no effect,
 *   and the function returns zero.
 *
 * @xref midiInUnprepareHeader
 ****************************************************************************/
MMRESULT APIENTRY midiInPrepareHeader(HMIDIIN hMidiIn, LPMIDIHDR lpMidiInHdr, UINT wSize)
{
    MMRESULT         wRet;

    V_HEADER(lpMidiInHdr, wSize, TYPE_MIDIIN, MMSYSERR_INVALPARAM);

    if (lpMidiInHdr->dwFlags & MHDR_PREPARED)
    return MMSYSERR_NOERROR;

    lpMidiInHdr->dwFlags = 0;

    ClientUpdatePnpInfo();
    
    V_HANDLE_ACQ(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);

    wRet = midiMessage((HMIDI)hMidiIn, MIDM_PREPARE, (DWORD_PTR)lpMidiInHdr, (DWORD)wSize);

    if (wRet == MMSYSERR_NOTSUPPORTED)
        return midiPrepareHeader(lpMidiInHdr, wSize);

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiInUnprepareHeader | This function cleans up the
 * preparation performed by <f midiInPrepareHeader>. The
 * <f midiInUnprepareHeader> function must be called
 * after the device driver fills a data buffer and returns it to the
 * application. You must call this function before freeing the data
 * buffer.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input
 *   device.
 *
 * @parm LPMIDIHDR | lpMidiInHdr |  Specifies a pointer to a <t MIDIHDR>
 *   structure identifying the data buffer to be cleaned up.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_STILLPLAYING | <p lpMidiInHdr> is still in the queue.
 *
 * @comm This function is the complementary function to <f midiInPrepareHeader>.
 * You must call this function before freeing the data buffer with
 * <f GlobalFree>.
 * After passing a buffer to the device driver with <f midiInAddBuffer>, you
 * must wait until the driver is finished with the buffer before calling
 * <f midiInUnprepareHeader>.  Unpreparing a buffer that has not been
 *   prepared has no effect, and the function returns zero.
 *
 * @xref midiInPrepareHeader
 ****************************************************************************/
MMRESULT APIENTRY midiInUnprepareHeader(HMIDIIN hMidiIn, LPMIDIHDR lpMidiInHdr, UINT wSize)
{
    MMRESULT         wRet;

    V_HEADER(lpMidiInHdr, wSize, TYPE_MIDIIN, MMSYSERR_INVALPARAM);

    if (!(lpMidiInHdr->dwFlags & MHDR_PREPARED))
    return MMSYSERR_NOERROR;

    if(lpMidiInHdr->dwFlags & MHDR_INQUEUE)
    {
    DebugErr(DBF_WARNING, "midiInUnprepareHeader: header still in queue\r\n");
    return MIDIERR_STILLPLAYING;
    }

    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);
    
    wRet = midiMessage((HMIDI)hMidiIn, MIDM_UNPREPARE, (DWORD_PTR)lpMidiInHdr, (DWORD)wSize);

    if (wRet == MMSYSERR_NOTSUPPORTED)
        return midiUnprepareHeader(lpMidiInHdr, wSize);

    if ((wRet == MMSYSERR_NODRIVER) && (IsHandleDeserted(hMidiIn)))
    {
        //  if the driver for the handle has been removed, succeed the call.

        wRet = MMSYSERR_NOERROR;
    }

    return wRet;
}

/******************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiInAddBuffer | This function sends an input buffer
 *   to a specified opened MIDI input device.  When the buffer is filled,
 *   it is sent back to the application.  Input buffers are
 *   used only for system-exclusive messages.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input device.
 *
 * @parm LPMIDIHDR | lpMidiInHdr | Specifies a far pointer to a <t MIDIHDR>
 *   structure that identifies the buffer.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_UNPREPARED | <p lpMidiInHdr> hasn't been prepared.
 *
 * @comm The data buffer must be prepared with <f midiInPrepareHeader> before
 *   it is passed to <f midiInAddBuffer>.  The <t MIDIHDR> data structure
 *   and the data buffer pointed to by its <e MIDIHDR.lpData> field must be allocated
 *   with <f GlobalAlloc> using the GMEM_MOVEABLE and GMEM_SHARE flags, and
 *   locked with <f GlobalLock>.
 *
 * @xref midiInPrepareHeader
 *****************************************************************************/
MMRESULT APIENTRY midiInAddBuffer(HMIDIIN hMidiIn, LPMIDIHDR lpMidiInHdr, UINT wSize)
{
    V_HEADER(lpMidiInHdr, wSize, TYPE_MIDIIN, MMSYSERR_INVALPARAM);

    if (!(lpMidiInHdr->dwFlags & MHDR_PREPARED))
    {
    DebugErr(DBF_WARNING, "midiInAddBuffer: buffer not prepared\r\n");
    return MIDIERR_UNPREPARED;
    }

    if (lpMidiInHdr->dwFlags & MHDR_INQUEUE)
    {
    DebugErr(DBF_WARNING, "midiInAddBuffer: buffer already in queue\r\n");
    return MIDIERR_STILLPLAYING;
    }

    ClientUpdatePnpInfo();
    
    V_HANDLE_ACQ(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);

    return midiMessage((HMIDI)hMidiIn, MIDM_ADDBUFFER, (DWORD_PTR)lpMidiInHdr, (DWORD)wSize);
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiInStart | This function starts MIDI input on the
 *   specified MIDI input device.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm This function resets the timestamps to zero; timestamp values for
 *   subsequently received messages are relative to the time this
 *   function was called.
 *
 *   All messages other than system-exclusive messages are sent
 *   directly to the client when received. System-exclusive
 *   messages are placed in the buffers supplied by <f midiInAddBuffer>;
 *   if there are no buffers in the queue,
 *   the data is thrown away without notification to the client, and input
 *   continues.
 *
 *   Buffers are returned to the client when full, when a
 *   complete system-exclusive message has been received,
 *   or when <f midiInReset> is
 *   called. The <e MIDIHDR.dwBytesRecorded> field in the header will contain the
 *   actual length of data received.
 *
 *   Calling this function when input is already started has no effect, and
 *   the function returns zero.
 *
 * @xref midiInStop midiInReset
 ****************************************************************************/
MMRESULT APIENTRY midiInStart(HMIDIIN hMidiIn)
{
    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);

    return midiMessage((HMIDI)hMidiIn, MIDM_START, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiInStop | This function terminates MIDI input on the
 *   specified MIDI input device.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm Current status (running status, parsing state, etc.) is maintained
 *   across calls to <f midiInStop> and <f midiInStart>.
 *   If there are any system-exclusive message buffers in the queue,
 *   the current buffer
 *   is marked as done (the <e MIDIHDR.dwBytesRecorded> field in the header will
 *   contain the actual length of data), but any empty buffers in the queue
 *   remain there.  Calling this function when input is not started has no
 *   no effect, and the function returns zero.
 *
 * @xref midiInStart midiInReset
 ****************************************************************************/
MMRESULT APIENTRY midiInStop(HMIDIIN hMidiIn)
{
    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);

    return midiMessage((HMIDI)hMidiIn, MIDM_STOP, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiInReset | This function stops input on a given MIDI
 *  input device and marks all pending input buffers as done.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @xref midiInStart midiInStop midiInAddBuffer midiInClose
 ****************************************************************************/
MMRESULT APIENTRY midiInReset(HMIDIIN hMidiIn)
{
    MMRESULT    mmr;

    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);

    mmr = midiMessage((HMIDI)hMidiIn, MIDM_RESET, 0L, 0L);

    if ((mmr == MMSYSERR_NODRIVER) && (IsHandleDeserted(hMidiIn)))
    {
        mmr = MMSYSERR_NOERROR;
    }

    return mmr;
}


//--------------------------------------------------------------------------;
//
//  MMRESULT midiInDesertHandle
//
//  Description:
//      Cleans up the midi in handle and marks it as deserted.
//
//  Arguments:
//      HMIDIIN hMidiIn:  MIDI in handle.
//
//  Return (MMRESULT):  Error code.
//
//  History:
//      01/25/99    Fwong       Adding Pnp Support.
//
//--------------------------------------------------------------------------;

MMRESULT midiInDesertHandle
(
    HMIDIIN hMidiIn
)
{
    MMRESULT    mmr;
    PMIDIDEV    pDev = (PMIDIDEV)hMidiIn;

    V_HANDLE_ACQ(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);
    
    ENTER_MM_HANDLE((HMIDI)hMidiIn);
    ReleaseHandleListResource();

    if (IsHandleDeserted(hMidiIn))
    {
        LEAVE_MM_HANDLE((HMIDI)hMidiIn);
        return (MMSYSERR_NOERROR);
    }
    
    if (IsHandleBusy(hMidiIn))
    {
        //  Not quite invalid, but marked as closed.
    
        LEAVE_MM_HANDLE(hMidiIn);
        return (MMSYSERR_HANDLEBUSY);
    }

    //  Marking handle as deserted
    SetHandleFlag(hMidiIn, MMHANDLE_DESERTED);
    
    //  Since the handle was invalidated, we have to send the message ourselves...
    
    (*(pDev->mididrv->drvMessage))(pDev->wDevice, MIDM_RESET, pDev->dwDrvUser, 0L, 0L);
    (*(pDev->mididrv->drvMessage))(pDev->wDevice, MIDM_CLOSE, pDev->dwDrvUser, 0L, 0L);

    LEAVE_MM_HANDLE((HWAVE)hMidiIn);
    
    // ISSUE-2001/01/14-FrankYe Probably don't want to dec usage here,
    //    dec on close instead.
    mregDecUsage(PTtoH(HMD, pDev->mididrv));

    return MMSYSERR_NOERROR;
} // midiInDesertHandle()


/*****************************************************************************
 * @doc EXTERNAL MIDI
 *
 * @api MMRESULT | midiInGetID | This function gets the device ID for a
 * MIDI input device.
 *
 * @parm HMIDIIN | hMidiIn     | Specifies the handle to the MIDI input
 * device.
 * @parm PUINT  | lpuDeviceID | Specifies a pointer to the UINT-sized
 * memory location to be filled with the device ID.
 *
 * @rdesc Returns zero if successful. Otherwise, returns
 * an error number. Possible error returns are:
 *
 * @flag MMSYSERR_INVALHANDLE | The <p hMidiIn> parameter specifies an
 * invalid handle.
 *
 ****************************************************************************/
MMRESULT APIENTRY midiInGetID(HMIDIIN hMidiIn, PUINT lpuDeviceID)
{
    V_WPOINTER(lpuDeviceID, sizeof(UINT), MMSYSERR_INVALPARAM);
    V_HANDLE_ACQ(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);

    *lpuDeviceID = ((PMIDIDEV)hMidiIn)->uDeviceID;
    
    ReleaseHandleListResource();
    return MMSYSERR_NOERROR;
}

/*****************************************************************************
 * @doc EXTERNAL MIDI
 *
 * @api MMRESULT | midiOutGetID | This function gets the device ID for a
 * MIDI output device.
 *
 * @parm HMIDIOUT | hMidiOut    | Specifies the handle to the MIDI output
 * device.
 * @parm PUINT  | lpuDeviceID | Specifies a pointer to the UINT-sized
 * memory location to be filled with the device ID.
 *
 * @rdesc Returns MMSYSERR_NOERROR if successful. Otherwise, returns
 * an error number. Possible error returns are:
 *
 * @flag MMSYSERR_INVALHANDLE | The <p hMidiOut> parameter specifies an
 * invalid handle.
 *
 ****************************************************************************/
MMRESULT APIENTRY midiOutGetID(HMIDIOUT hMidiOut, PUINT lpuDeviceID)
{
    V_WPOINTER(lpuDeviceID, sizeof(UINT), MMSYSERR_INVALPARAM);
    V_HANDLE_ACQ(hMidiOut, TYPE_MIDIOUT, MMSYSERR_INVALHANDLE);

    *lpuDeviceID = ((PMIDIDEV)hMidiOut)->uDeviceID;
    
    ReleaseHandleListResource();
    return MMSYSERR_NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\mcisys.c ===
/*****************************Module*Header*********************************\
* Module Name: mcisys.c
*
* Media Control Architecture System Functions
*
* Created: 2/28/90
* Author:  DLL (DavidLe)
* 5/22/91: Ported to Win32 - NigelT
*
* History:
* Mar 92   SteveDav - brought up to Win 3.1 ship level
*
* Copyright (c) 1991-1999 Microsoft Corporation
*
\******************************************************************************/

#define UNICODE

#define _CTYPE_DISABLE_MACROS
#include "winmmi.h"
#include "mci.h"
#include "wchar.h"
#include "ctype.h"

extern   WSZCODE wszOpen[];          // in MCI.C
STATICDT WSZCODE wszMciExtensions[] = L"Mci Extensions";

#define MCI_EXTENSIONS wszMciExtensions

#define MCI_PROFILE_STRING_LENGTH 255

//#define TOLOWER(c) ((c) >= 'A' && (c) <= 'Z' ? (c) + 'a' - 'A' : c)

// The device list is initialized on the first call to mciSendCommand or
// to mciSendString or to mciGetDeviceID or to mciGetErrorString
// We could do it when WINMM is loaded - but that is a bit excessive.
// The user may not need MCI functions.
BOOL MCI_bDeviceListInitialized = FALSE;

// The next device ID to use for a new device
MCIDEVICEID MCI_wNextDeviceID = 1;

// The list of MCI devices.  This list grows and shrinks as needed.
// The first offset MCI_lpDeviceList[0] is a placeholder and is unused
// because device 0 is defined as no device.
LPMCI_DEVICE_NODE FAR * MCI_lpDeviceList = NULL;

// The current size of the list of MCI devices
UINT MCI_wDeviceListSize = 0;

#if 0 // we don't use this (NigelT)
// The internal mci heap used by mciAlloc and mciFree
HANDLE hMciHeap = NULL;
#endif

STATICDT WSZCODE wszAllDeviceName[] = L"all";

STATICDT WSZCODE szUnsignedFormat[] = L"%u";

STATICFN void mciFreeDevice(LPMCI_DEVICE_NODE nodeWorking);


//------------------------------------------------------------------
// Initialize device list
// Called once by mciSendString or mciSendCommand
// Returns TRUE on success
//------------------------------------------------------------------

BOOL mciInitDeviceList(void)
{
    BOOL fReturn=FALSE;

#if 0 // we don't use this (NigelT)
    if ((hMciHeap = HeapCreate(0)) == 0)
    {
        dprintf1(("Mci heap create failed!"));
        return FALSE;
    }
#endif

  try {
    mciEnter("mciInitDeviceList");
    if (!MCI_bDeviceListInitialized) {
        // We have to retest the init flag to be totally thread safe.
        // Otherwise in theory we could end up initializing twice.
        if ((MCI_lpDeviceList = mciAlloc( sizeof (LPMCI_DEVICE_NODE) *
                                         (MCI_INIT_DEVICE_LIST_SIZE + 1))) != NULL)
        {
            MCI_wDeviceListSize = MCI_INIT_DEVICE_LIST_SIZE;
            MCI_bDeviceListInitialized = TRUE;
            fReturn = TRUE;
        } else {
            dprintf1(("MCIInit: could not allocate master MCI device list"));
            fReturn = FALSE;
        }
    }

  } finally {
    mciLeave("mciInitDeviceList");
  }

    return(fReturn);
}

/*
 * @doc EXTERNAL MCI
 * @api MCIDEVICEID | mciGetDeviceIDFromElementID | This function
 * retrieves the MCI device ID corresponding to and element ID
 *
 * @parm DWORD | dwElementID | The element ID
 *
 * @parm LPCTSTR | lpstrType | The type name this element ID belongs to
 *
 * @rdesc Returns the device ID assigned when it was opened and used in the
 * <f mciSendCommand> function.  Returns zero if the device name was not known,
 * if the device was not open, or if there was not enough memory to complete
 * the operation or if lpstrType is NULL.
 *
 */
MCIDEVICEID APIENTRY mciGetDeviceIDFromElementIDA (
    DWORD dwElementID,
    LPCSTR lpstrType)
{
    LPCWSTR lpwstr;
    MCIDEVICEID mr;

    lpwstr = AllocUnicodeStr( (LPSTR)lpstrType );
    if ( lpwstr == NULL ) {
        return (MCIDEVICEID)(UINT_PTR)NULL;
    }

    mr = mciGetDeviceIDFromElementIDW( dwElementID, lpwstr );

    FreeUnicodeStr( (LPWSTR)lpwstr );

    return mr;
}

MCIDEVICEID APIENTRY mciGetDeviceIDFromElementIDW (
    DWORD dwElementID,
    LPCWSTR lpstrType)
{
    MCIDEVICEID wID;
    LPMCI_DEVICE_NODE nodeWorking, FAR *nodeCounter;
    WCHAR strTemp[MCI_MAX_DEVICE_TYPE_LENGTH];

    if (lpstrType == NULL) {
        return 0;
    }

    mciEnter("mciGetDeviceIDFromElementID");

    nodeCounter = &MCI_lpDeviceList[1];

    for (wID = 1; wID < MCI_wNextDeviceID; ++wID)
    {

        if (NULL == (nodeWorking = *nodeCounter++)) {
            continue;
        }

        if (nodeWorking->dwMCIOpenFlags & MCI_OPEN_ELEMENT_ID &&
            nodeWorking->dwElementID == dwElementID) {

            if (LoadStringW( ghInst, nodeWorking->wDeviceType, strTemp,
                             sizeof(strTemp) / sizeof(WCHAR) ) != 0
                && lstrcmpiW( strTemp, lpstrType) == 0) {

                mciLeave("mciGetDeviceIDFromElementID");
                return wID;
            }
        }
    }

    mciLeave("mciGetDeviceIDFromElementID");
    return 0;
}

// Retrieves the device ID corresponding to the name of an opened device
// matching the given task
STATICFN MCIDEVICEID mciGetDeviceIDInternal (
    LPCWSTR lpstrName,
    HANDLE hCurrentTask)
{
    MCIDEVICEID wID;
    LPMCI_DEVICE_NODE nodeWorking, FAR *nodeCounter;

#if DBG
    if (!lpstrName) {
        dprintf(("!! NULL POINTER !!  Internal error"));
        return(0);
    }
#endif

    if ( lstrcmpiW(wszAllDeviceName, lpstrName) == 0)
        return MCI_ALL_DEVICE_ID;

    if (MCI_lpDeviceList == NULL)
        return 0;

// Loop through the MCI device list. Skip any 16-bit devices.

    mciEnter("mciGetDeviceIDInternal");

    nodeCounter = &MCI_lpDeviceList[1];
    for (wID = 1; wID < MCI_wNextDeviceID; ++wID)
    {

        if (NULL == (nodeWorking = *nodeCounter++)) {
            continue;
        }

        // If this device is 16-bit then skip it
        if (nodeWorking->dwMCIFlags & MCINODE_16BIT_DRIVER) {
            continue;
        }

        // If this device does not have a name then skip it
        if (nodeWorking->dwMCIOpenFlags & MCI_OPEN_ELEMENT_ID) {
            continue;
        }

        // If the names match, and the previous device is not being closed
        if ( lstrcmpiW( nodeWorking->lpstrName, lpstrName ) == 0 ) {
            if (ISAUTOCLOSING(nodeWorking))
            {
                // As this auto opened device is being closed we do not match
                // against its name.  The result is that a new auto opened
                // device will be used.  This would be the case if this
                // command was issued momentarily later by which time we
                // would have finished closing the existing device.
            } else {
                // If the device belongs to the current task
                if (nodeWorking->hOpeningTask == hCurrentTask ||
                    nodeWorking->hCreatorTask == hCurrentTask) {
                    // Return this device ID
                    mciLeave("mciGetDeviceIDInternal");
                    return wID;
                }
            }
        }
    }
    mciLeave("mciGetDeviceIDInternal");
    return 0;
}


/*
 * @doc EXTERNAL MCI
 * @api MCIDEVICEID | mciGetDeviceID | This function retrieves the device
 * ID corresponding to the name of an opened device.
 *
 * @parm LPCTSTR | lpstrName | Points to the device name from SYSTEM.INI, or
 * the alias name by which the device is known.
 *
 * @rdesc Returns the device ID assigned when it was opened and used in the
 * <f mciSendCommand> function.  Returns zero if the device name was not known,
 * if the device was not open, or if there was not enough memory to complete
 * the operation.  Each compound device element has a unique device ID.
 * The ID of the "all" device is MCI_ALL_DEVICE_ID
 *
 * @xref MCI_OPEN
 *
 */
MCIDEVICEID mciGetDeviceIDW (
    LPCWSTR lpstrName)
{
    return mciGetDeviceIDInternal (lpstrName, GetCurrentTask());
}

MCIDEVICEID mciGetDeviceIDA (
    LPCSTR lpstrName)
{
    LPCWSTR lpwstr;
    MCIDEVICEID mr;

    lpwstr = AllocUnicodeStr( (LPSTR)lpstrName );
    if ( lpwstr == NULL ) {
        return (MCIDEVICEID)(UINT_PTR)NULL;
    }

    mr = mciGetDeviceIDInternal( lpwstr, GetCurrentTask() );

    FreeUnicodeStr( (LPWSTR)lpwstr );

    return mr;
}

/*
 * @doc EXTERNAL MCI
 * @api HMODULE | mciGetCreatorTask | This function retrieves the creator task
 * corresponding with the device ID passed.
 *
 * @parm MCIDEVICEID | wDeviceID | Specifies the device ID whose creator task is to
 * be returned.
 *
 * @rdesc Returns the creator task responsible for opening the device, else
 * NULL if the device ID passed is invalid.
 *
 */
HTASK APIENTRY mciGetCreatorTask (
    MCIDEVICEID wDeviceID)
{
    HTASK hCreatorTask;

    mciEnter("mciGetCreatorTask");

    if (MCI_VALID_DEVICE_ID(wDeviceID)) {
        hCreatorTask = MCI_lpDeviceList[wDeviceID]->hCreatorTask;
    } else {
        hCreatorTask = NULL;
    }

    mciLeave("mciGetCreatorTask");

    return hCreatorTask;
}


/*
 * @doc INTERNAL MCI
 * @api BOOL FAR | mciDeviceMatch | Match the first string with the second.
 * Any single trailing digit on the first string is ignored.  Each string
 * must have at least one character
 *
 * @parm LPWSTR | lpstrDeviceName | The device name, possibly
 * with trailing digits but no blanks.
 *
 * @parm LPWSTR | lpstrDeviceType | The device type with no trailing digits
 * or blanks
 *
 * @rdesc TRUE if the strings match the above test, FALSE otherwise
 *
 */
STATICFN BOOL     mciDeviceMatch (
    LPCWSTR lpstrDeviceName,
    LPCWSTR lpstrDeviceType)
{
    BOOL bRetVal = TRUE, bAtLeastOne = FALSE;

// Scan until one of the strings ends
    dprintf2(("mciDeviceMatch: %ls Vs %ls",lpstrDeviceName,lpstrDeviceType));
    while (*lpstrDeviceName != '\0' && *lpstrDeviceType != '\0') {
        if (towlower(*lpstrDeviceName++) == towlower(*lpstrDeviceType++)) {
            bAtLeastOne = TRUE;
        } else {
            break;
        }
    }

// If end of device type, scan to the end of device name, trailing digits
// are OK
    if (!bAtLeastOne || *lpstrDeviceType != '\0') {
        return FALSE;
    }

    while (*lpstrDeviceName != '\0')
    {
// No match, but that is OK if a digit trails

        // Is the remainder of the string a digit?  We could check using
        // a simple if test (<0 or >9) but that would run into problems if
        // anyone ever passed a unicode "numeric" string outside the ascii
        // number range.  Using isdigit should be safer if marginally slower.

        if (!isdigit(*lpstrDeviceName)) {

            // No match - a non digit trails
            return FALSE;
        }

        ++lpstrDeviceName;
    }
    return TRUE;
}

/*
 * @doc INTERNAL MCI
 * @api UINT | mciLookUpType | Look up the type given a type name
 *
 * @parm LPCWSTR | lpstrTypeName | The type name to look up.  Trailing
 * digits are ignored.
 *
 * @rdesc The MCI type number (MCI_DEVTYPE_<x>) or 0 if not found
 *
 */
UINT mciLookUpType (
    LPCWSTR lpstrTypeName)
{
    UINT wType;
    WCHAR strType[MCI_MAX_DEVICE_TYPE_LENGTH];

    for (wType = MCI_DEVTYPE_FIRST; wType <= MCI_DEVTYPE_LAST; ++wType)
    {
        if ( LoadStringW( ghInst,
                          wType,
                          strType,
                          sizeof(strType) / sizeof(WCHAR) ) == 0)
        {
            dprintf1(("mciLookUpType:  could not load string for type"));
            continue;
        }

        if (mciDeviceMatch (lpstrTypeName, strType)) {
            return wType;
        }
    }
    return 0;
}

/*
 * @doc INTERNAL MCI
 * @api DWORD | mciSysinfo | Get system information about a device
 *
 * @parm MCIDEVICEID | wDeviceID | Device ID, may be 0
 *
 * @parm DWORD | dwFlags | SYSINFO flags
 *
 * @parm LPMCI_SYSINFO_PARMS | lpSysinfo | SYSINFO parameters
 *
 * @rdesc 0 if successful, otherwise error code
 *
 */
DWORD     mciSysinfo (
    MCIDEVICEID wDeviceID,
    DWORD dwFlags,
    LPMCI_SYSINFO_PARMSW lpSysinfo)
{
    UINT nCounted;
    WCHAR              strBuffer[MCI_PROFILE_STRING_LENGTH];
    LPWSTR             lpstrBuffer = strBuffer, lpstrStart;

    if (dwFlags & MCI_SYSINFO_NAME && lpSysinfo->dwNumber == 0)
        return MCIERR_OUTOFRANGE;

    if (lpSysinfo->lpstrReturn == NULL || lpSysinfo->dwRetSize == 0)
        return MCIERR_PARAM_OVERFLOW;

#ifdef LATER
//    if ((dwFlags & (MCI_SYSINFO_NAME | MCI_SYSINFO_INSTALLNAME))
//        && (dwFlags & MCI_SYSINFO_QUANTITY))
//    Should be invalid to ask for Quantity and any sort of name
#endif
    if (dwFlags & MCI_SYSINFO_NAME && dwFlags & MCI_SYSINFO_QUANTITY)
        return MCIERR_FLAGS_NOT_COMPATIBLE;

    if (dwFlags & MCI_SYSINFO_INSTALLNAME)
    {
        LPMCI_DEVICE_NODE nodeWorking;

        if (wDeviceID == MCI_ALL_DEVICE_ID)
            return MCIERR_CANNOT_USE_ALL;

        mciEnter("mciSysinfo");
        if (!MCI_VALID_DEVICE_ID (wDeviceID)) {
            mciLeave("mciSysinfo");
            return MCIERR_INVALID_DEVICE_NAME;
        }


#if DBG
        if ((nodeWorking = MCI_lpDeviceList[wDeviceID]) == NULL ||
            nodeWorking->lpstrInstallName == NULL)
        {
            dprintf1(("mciSysinfo:  NULL device node or installname"));
            mciLeave("mciSysinfo");
            return MCIERR_INTERNAL;
        }
#else
        nodeWorking = MCI_lpDeviceList[wDeviceID];
#endif


        if ( (DWORD)wcslen( nodeWorking->lpstrInstallName ) >=
               lpSysinfo->dwRetSize )
        {
            mciLeave("mciSysinfo");
            return MCIERR_PARAM_OVERFLOW;
        }

        wcscpy (lpSysinfo->lpstrReturn, nodeWorking->lpstrInstallName);
        mciLeave("mciSysinfo");
        return 0;

    } else if (!(dwFlags & MCI_SYSINFO_OPEN))
    {
        if (wDeviceID != MCI_ALL_DEVICE_ID &&
            lpSysinfo->wDeviceType == 0) {
            return MCIERR_DEVICE_TYPE_REQUIRED;
        }

        if ((dwFlags & (MCI_SYSINFO_QUANTITY | MCI_SYSINFO_NAME)) == 0)
            return MCIERR_MISSING_PARAMETER;

        GetPrivateProfileStringW( MCI_HANDLERS, NULL, wszNull,
                                 lpstrBuffer,
                                 MCI_PROFILE_STRING_LENGTH,
                                 MCIDRIVERS_INI_FILE);
        nCounted = 0;
        while (TRUE)
        {
            if (dwFlags & MCI_SYSINFO_QUANTITY)
            {

                if (*lpstrBuffer == '\0')
                {
                    if ( (lpSysinfo->lpstrReturn == NULL) ||
                         (sizeof(DWORD) > lpSysinfo->dwRetSize))
                        return MCIERR_PARAM_OVERFLOW;

                    *(UNALIGNED DWORD *)lpSysinfo->lpstrReturn = (DWORD)nCounted;
                    return MCI_INTEGER_RETURNED;
                }

                if (wDeviceID == MCI_ALL_DEVICE_ID ||
                    mciLookUpType (lpstrBuffer) == lpSysinfo->wDeviceType)
                    ++nCounted;

                // Skip past the terminating '\0'
                while (*lpstrBuffer++ != '\0') {}

            }
            else if (dwFlags & MCI_SYSINFO_NAME)   // if test is redundant
            {
                if (nCounted == lpSysinfo->dwNumber)
                {
                    /* NOTE:
                     * We know that lpSysinfo->dwNumber > 0
                     * Hence we will have been through the loop at least once
                     * Hence lpstrStart has been set up
                     */
                    if ( (DWORD)wcslen( lpstrStart ) >= lpSysinfo->dwRetSize )
                    {
                        return MCIERR_PARAM_OVERFLOW;
                    }
                    wcscpy (lpSysinfo->lpstrReturn, lpstrStart);
                    return 0L;

                } else if (*lpstrBuffer == '\0')
                    return MCIERR_OUTOFRANGE;
                else
                {
                    lpstrStart = lpstrBuffer;
                    if (wDeviceID == MCI_ALL_DEVICE_ID ||
                        mciLookUpType (lpstrBuffer) == lpSysinfo->wDeviceType)
                        ++nCounted;

                    // Skip past the terminating '\0'
                    while (*lpstrBuffer++ != '\0') {}
                }
            }
        }
    } else
// Process MCI_SYSINFO_OPEN cases
    {
        MCIDEVICEID wID;
        HANDLE hCurrentTask = GetCurrentTask();
        LPMCI_DEVICE_NODE Node;

        if (wDeviceID != MCI_ALL_DEVICE_ID &&
            lpSysinfo->wDeviceType == 0)
            return MCIERR_DEVICE_TYPE_REQUIRED;

        if ((dwFlags & (MCI_SYSINFO_QUANTITY | MCI_SYSINFO_NAME)) == 0)
            return MCIERR_MISSING_PARAMETER;

        nCounted = 0;

        mciEnter("mciSysinfo");

        for (wID = 1; wID < MCI_wNextDeviceID; ++wID)
        {
            if ((Node = MCI_lpDeviceList[wID]) == 0)
                continue;

            if (wDeviceID == MCI_ALL_DEVICE_ID &&
                 Node->hOpeningTask == hCurrentTask) {
                ++nCounted;
            }
            else
            {
                if (Node->wDeviceType == lpSysinfo->wDeviceType &&
                    Node->hOpeningTask == hCurrentTask)
                    ++nCounted;
            }

            if (dwFlags & MCI_SYSINFO_NAME &&
                nCounted == lpSysinfo->dwNumber)
            {
                DWORD dwReturn;
                if ( (DWORD)wcslen( Node->lpstrName ) >= lpSysinfo->dwRetSize )
                {
                    dwReturn = MCIERR_PARAM_OVERFLOW;
                } else {
                    wcscpy (lpSysinfo->lpstrReturn, Node->lpstrName);
                    dwReturn = 0;
                }
                mciLeave("mciSysinfo");
                return dwReturn;
            }
        }

        mciLeave("mciSysinfo");

        if (dwFlags & MCI_SYSINFO_NAME)
        {
            if (lpSysinfo->lpstrReturn != NULL)
                lpSysinfo->lpstrReturn = '\0';
            return MCIERR_OUTOFRANGE;

        } else if (dwFlags & MCI_SYSINFO_QUANTITY &&  // checking for QUANTITY is redundant
                   lpSysinfo->lpstrReturn != NULL &&
                   lpSysinfo->dwRetSize >= 4) {

            *(UNALIGNED DWORD *)lpSysinfo->lpstrReturn = nCounted;
            return MCI_INTEGER_RETURNED;
        }
    }
    return MCIERR_PARAM_OVERFLOW;
}

/*
 * @doc INTERNAL MCI
 * @api MCIDEVICEID | wReserveDeviceID | Copy the given global handle into the
 * first free entry in the MCI device table and return that entry's ID#
 *
 * @parm HANDLE | hNode | Local handle to device description
 *
 * @rdesc The ID value that has been reserved for this device or 0 if
 * there are no more free entries
 *
 */

STATICFN MCIDEVICEID wReserveDeviceID (
    LPMCI_DEVICE_NODE node)
{
    UINT wDeviceID;
    LPMCI_DEVICE_NODE FAR *lpTempList;

    mciEnter("wReserveDeviceID");
// Search for an empty slot
    for (wDeviceID = 1; wDeviceID < MCI_wNextDeviceID; ++wDeviceID)
        if (MCI_lpDeviceList[wDeviceID] == NULL) {
            goto slot_found;
        }
    // No empty slots found so add to end

    if (wDeviceID >= MCI_wDeviceListSize)
    {
        // The list is full (or non existent) so try to grow it
        if ((lpTempList = mciReAlloc (MCI_lpDeviceList,
                    sizeof (LPMCI_DEVICE_NODE) * (MCI_wDeviceListSize + 1 +
                                                  MCI_DEVICE_LIST_GROW_SIZE)))
            == NULL)
        {
            dprintf1(("wReserveDeviceID:  cannot grow device list"));
            mciLeave("wReserveDeviceID");
            return 0;
        }

        MCI_lpDeviceList = lpTempList;
        MCI_wDeviceListSize += MCI_DEVICE_LIST_GROW_SIZE;
    }

    ++MCI_wNextDeviceID;

slot_found:;

    MCI_lpDeviceList[wDeviceID] = node;

    mciLeave("wReserveDeviceID");

    return (MCIDEVICEID)wDeviceID;
}

//
// Allocate space for the given string and assign the name to the given
// device.
// Return FALSE if could not allocate memory
//
STATICFN BOOL NEAR mciAddDeviceName(
    LPMCI_DEVICE_NODE nodeWorking,
    LPCWSTR lpDeviceName)
{
    nodeWorking->lpstrName = (LPWSTR)mciAlloc(
                                BYTE_GIVEN_CHAR( wcslen(lpDeviceName) + 1 ) );

    if (nodeWorking->lpstrName == NULL)
    {
        dprintf1(("mciAddDeviceName:  Out of memory allocating device name"));
        return FALSE;
    }

    // copy device name to mci node and lowercase it

    wcscpy(nodeWorking->lpstrName, (LPWSTR)lpDeviceName);
//!!    mciToLower(nodeWorking->lpstrName);

    return TRUE;
}

/*
 * @doc INTERNAL MCI
 * @api HANDLE | mciAllocateNode | Allocate a new driver entry
 *
 * @parm DWORD | dwFlags | As sent with MCI_OPEN message
 * @parm LPCWSTR | lpDeviceName | The device name
 * @parm LPMCI_DEVICE_NODE * | *lpNewNode | Return pointer location
 *
 * @rdesc The device ID to the new node.  0 on error.
 *
 * @comm Leaves the new node locked
 *
 */
STATICFN MCIDEVICEID NEAR mciAllocateNode (
    DWORD dwFlags,
    LPCWSTR lpDeviceName,
    LPMCI_DEVICE_NODE FAR *lpnodeNew)
{
    LPMCI_DEVICE_NODE   nodeWorking;

    if ((nodeWorking = mciAlloc(sizeof(MCI_DEVICE_NODE))) == NULL)
    {
        dprintf1(("Out of memory in mciAllocateNode"));
        return 0;
    }

/* Fill in the new node */

/* Get a new device ID, if there are none available then bail */
    if ((nodeWorking->wDeviceID = wReserveDeviceID(nodeWorking)) == 0)
    {
        dprintf1(("mciAllocateNode:  Cannot allocate new node"));
        mciFree(nodeWorking);
        return 0;
    }

// Initialize node
    nodeWorking->dwMCIOpenFlags = dwFlags;
    nodeWorking->hCreatorTask = GetCurrentTask ();
    nodeWorking->hOpeningTask = nodeWorking->hCreatorTask;
// The new node is zeroed
//  nodeWorking->fpYieldProc = NULL;
//  nodeWorking->dwMCIFlags  = 0;

    if (dwFlags & MCI_OPEN_ELEMENT_ID)
// No device name, just an element ID
        nodeWorking->dwElementID = PtrToUlong(lpDeviceName);

    else
        if (!mciAddDeviceName (nodeWorking, lpDeviceName))
        {
            mciFree (nodeWorking);
            return 0;
        }

    *lpnodeNew = nodeWorking;
    return nodeWorking->wDeviceID;
}

//
// Reparse the original command parameters
// Returns MCIERR code.  If the reparse fails the original error code
// from the first parsing is returned.
//
STATICFN UINT mciReparseOpen (
    LPMCI_INTERNAL_OPEN_INFO lpOpenInfo,
    UINT wCustomTable,
    UINT wTypeTable,
    LPDWORD lpdwFlags,
    LPMCI_OPEN_PARMSW FAR *lplpOpen,
    MCIDEVICEID wDeviceID)
{
    LPWSTR               lpCommand;
    LPDWORD             lpdwParams = NULL;
    UINT                wErr;
    UINT                wTable = wCustomTable;
    DWORD               dwOldFlags = *lpdwFlags;

     // If the custom table contains no open command
    if (wCustomTable == MCI_TABLE_NOT_PRESENT ||
        (lpCommand = FindCommandInTable (wCustomTable, wszOpen, NULL)) == NULL)
    {
        // Try the type specific table
        lpCommand = FindCommandInTable (wTypeTable, wszOpen, NULL);

        // If it still cannot be parsed
        if (lpCommand == NULL)
            return lpOpenInfo->wParsingError;
        wCustomTable = wTypeTable;
    }

    // A new version of 'open' was found
    // Free previous set of parameters
    mciParserFree (lpOpenInfo->lpstrPointerList);
    *lpdwFlags = 0;

    if ((lpdwParams =
            (LPDWORD)mciAlloc (sizeof(DWORD_PTR) * MCI_MAX_PARAM_SLOTS))
        == NULL)
            return MCIERR_OUT_OF_MEMORY;

    wErr = mciParseParams ( MCI_OPEN ,
                            lpOpenInfo->lpstrParams, lpCommand,
                            lpdwFlags,
                            (LPWSTR)lpdwParams,
                            sizeof(DWORD_PTR) * MCI_MAX_PARAM_SLOTS,
                            &lpOpenInfo->lpstrPointerList, NULL);

    // We don't need this around anymore
    mciUnlockCommandTable (wTable);

    // If there was a parsing error
    if (wErr != 0)
    {
        // Close device down
        mciCloseDevice (wDeviceID, 0L, NULL, FALSE);

        // Make sure this does not get free'd by mciSendString
        lpOpenInfo->lpstrPointerList = NULL;

        mciFree (lpdwParams);
        return wErr;
    }

    if (dwOldFlags & MCI_OPEN_TYPE)
    {
        // Device type was already extracted so add it manually
        ((LPMCI_OPEN_PARMSW)lpdwParams)->lpstrDeviceType
            = (*lplpOpen)->lpstrDeviceType;
        *lpdwFlags |= MCI_OPEN_TYPE;
    }

    if (dwOldFlags & MCI_OPEN_ELEMENT)
    {
        // Element name was already extracted so add it manually
        ((LPMCI_OPEN_PARMSW)lpdwParams)->lpstrElementName
            = (*lplpOpen)->lpstrElementName;
        *lpdwFlags |= MCI_OPEN_ELEMENT;
    }

    if (dwOldFlags & MCI_OPEN_ALIAS)
    {
        // Alias name was already extracted so add it manually
        ((LPMCI_OPEN_PARMSW)lpdwParams)->lpstrAlias
            = (*lplpOpen)->lpstrAlias;
        *lpdwFlags |= MCI_OPEN_ALIAS;
    }

    if (dwOldFlags & MCI_NOTIFY)
        // Notify was already extracted so add it manually
        ((LPMCI_OPEN_PARMSW)lpdwParams)->dwCallback
            = (*lplpOpen)->dwCallback;

    // Replace old parameter list with new list
    *lplpOpen = (LPMCI_OPEN_PARMSW)lpdwParams;

    return 0;
}

//**************************************************************************
// mciFindDriverName
//
// See if lpstrDriverName exists in the profile strings of the [mci]
// section and return the keyname in lpstrDevice and the
// profile string in lpstrProfString
// Returns 0 on success or an error code
//**************************************************************************
STATICFN DWORD mciFindDriverName (
    LPCWSTR lpstrDriverName,
    LPWSTR lpstrDevice,
    LPWSTR lpstrProfString,
    UINT wProfLength)    // this should be a character count
{
    LPWSTR lpstrEnum, lpstrEnumStart;
    UINT wEnumLen = 100;
    DWORD wErr;
    LPWSTR lpstrDriverTemp, lpstrProfTemp;

// Enumerate values, trying until they fit into the buffer
    while (TRUE) {
        if ((lpstrEnum = mciAlloc( BYTE_GIVEN_CHAR(wEnumLen) ) ) == NULL)
            return MCIERR_OUT_OF_MEMORY;

        wErr = GetPrivateProfileStringW( MCI_HANDLERS,
                                        NULL, wszNull,
                                        lpstrEnum,
                                        wEnumLen,
                                        MCIDRIVERS_INI_FILE );

        if (*lpstrEnum == '\0')
        {
            mciFree (lpstrEnum);
            return MCIERR_DEVICE_NOT_INSTALLED;
        }

        if (wErr == wEnumLen - 2)
        {
            wEnumLen *= 2;
            mciFree (lpstrEnum);
        } else
            break;
    }

    lpstrEnumStart = lpstrEnum;
    if ( wcslen(lpstrDriverName) >= MCI_MAX_DEVICE_TYPE_LENGTH ) {
        wErr = MCIERR_DEVICE_LENGTH;
        goto exit_fn;
    }
    wcscpy(lpstrDevice, lpstrDriverName);
//!!    mciToLower (lpstrDevice);

// Walk through each string
    while (TRUE) {
        wErr = GetPrivateProfileStringW( MCI_HANDLERS,
                                        lpstrEnum, wszNull, lpstrProfString,
                                        wProfLength,
                                        MCIDRIVERS_INI_FILE );
        if (*lpstrProfString == '\0')
        {
            dprintf1(("mciFindDriverName: cannot load valid keyname"));
            wErr = MCIERR_CANNOT_LOAD_DRIVER;
            goto exit_fn;
        }
// See if driver pathname matches input
//!!        mciToLower (lpstrProfString);
        lpstrDriverTemp = lpstrDevice;
        lpstrProfTemp = lpstrProfString;
// Find end of file name
        while (*lpstrProfTemp != '\0' && *lpstrProfTemp != ' ')
            ++lpstrProfTemp;
// Find begining of simple file name
        --lpstrProfTemp;
        while (*lpstrProfTemp != '\\' && *lpstrProfTemp != '/' &&
               *lpstrProfTemp != ':')
            if (--lpstrProfTemp < lpstrProfString)
                break;
        ++lpstrProfTemp;
// Compare to input
        while (*lpstrDriverTemp != '\0')
            if (*lpstrDriverTemp++ != *lpstrProfTemp++ ||
                (UINT)(lpstrProfTemp - lpstrProfString) >= wProfLength)
            {
                --lpstrProfTemp;
                break;
            }
// If the input was contained in the profile string and followed by
// a space or a '.' then we've got it!
        if (*lpstrDriverTemp == '\0' &&
            (*lpstrProfTemp == ' ' || *lpstrProfTemp == '.'))
        {
            if (wcslen (lpstrEnum) >= MCI_MAX_DEVICE_TYPE_LENGTH)
            {
                dprintf1(("mciFindDriverName: device name too long"));
                wErr = MCIERR_DEVICE_LENGTH;
                goto exit_fn;
            }
            wcscpy (lpstrDevice, lpstrEnum);
            wErr = 0;
            goto exit_fn;
        }
// Skip to next keyname
        while (*lpstrEnum++ != '\0') {}
// Error if no more left
        if (*lpstrEnum == 0)
        {
            wErr = MCIERR_INVALID_DEVICE_NAME;
            goto exit_fn;
        }
    }

exit_fn:
    mciFree (lpstrEnumStart);
    return wErr;
}

//
// Identifies the driver name to load
// Loads the driver
// Reparses open command if necessary
// Sets a default break key
//
// lpOpenInfo contains various info for reparsing
//
// bDefaultAlias indicates that the alias need not be verified because
// it was internally assigned
//
STATICFN DWORD mciLoadDevice (
    DWORD dwFlags,
    LPMCI_OPEN_PARMSW lpOpen,
    LPMCI_INTERNAL_OPEN_INFO lpOpenInfo,
    BOOL bDefaultAlias)
{
    LPMCI_DEVICE_NODE       nodeWorking;
    HANDLE                  hDriver;
    MCIDEVICEID             wID;
    DWORD                   wErr;
    WCHAR                   strProfileString[MCI_PROFILE_STRING_LENGTH];
    WCHAR                   szDriverParms[128];
    MCI_OPEN_DRIVER_PARMS   DriverOpen;
    HANDLE                  hDrvDriver;
    LPWSTR                  lpstrParams;
    LPCWSTR                 lpstrInstallName, lpstrDeviceName;
    LPWSTR                  lpstrCopy = NULL;
    LPMCI_OPEN_PARMSW       lpOriginalOpenParms = lpOpen;

    /* Open a normal device */

#if DBG
    if (lpOpen && lpOpen->lpstrDeviceType) {
        dprintf2(("mciLoadDevice(%ls)", lpOpen->lpstrDeviceType));
    } else {
        dprintf2(("mciLoadDevice()"));
    }

#endif

    /* Check for the device name in MCIDRIVERS_INI_FILE */
    lpstrInstallName = lpOpen->lpstrDeviceType;
    wErr = GetPrivateProfileStringW( MCI_HANDLERS,
                                    lpstrInstallName,
                                    wszNull,
                                    strProfileString,
                                    MCI_PROFILE_STRING_LENGTH,
                                    MCIDRIVERS_INI_FILE );

    // If device name not found
    if (wErr == 0)
    {
        int nLen = wcslen(lpstrInstallName);
        int index;

        // Try for the device name with a '1' thru a '9' appended to it

        if ((lpstrCopy = (LPWSTR)mciAlloc( BYTE_GIVEN_CHAR(nLen+2)
                /* space for digit too */  ) ) == NULL)
        {
            dprintf1(("mciLoadDevice:  cannot allocate device name copy"));
            return MCIERR_OUT_OF_MEMORY;
        }
        wcscpy( lpstrCopy, lpstrInstallName );

        lpstrCopy[nLen + 1] = '\0';

        for (index = 1; index <= 9; ++index)
        {
            lpstrCopy[nLen] = (WCHAR)('0' + index);
            wErr = GetPrivateProfileStringW(
                        MCI_HANDLERS,
                        lpstrCopy,
                        wszNull,
                        strProfileString,
                        MCI_PROFILE_STRING_LENGTH,
                        MCIDRIVERS_INI_FILE );

            if (wErr != 0) {
            dprintf2(("Loaded driver name %ls >> %ls", lpstrCopy, strProfileString));
                break;
            }
        }

        if (wErr == 0)
        {
            mciFree (lpstrCopy);
            if ((lpstrCopy = (LPWSTR)mciAlloc( BYTE_GIVEN_CHAR( MCI_MAX_DEVICE_TYPE_LENGTH )))
                == NULL)
            {
                dprintf1(("mciLoadDevice:  cannot allocate device name copy"));
                return MCIERR_OUT_OF_MEMORY;
            }
            if ((wErr = mciFindDriverName(
                            lpstrInstallName,
                            lpstrCopy,
                            strProfileString,
                            MCI_PROFILE_STRING_LENGTH )) != 0)
            {
                dprintf1(("mciLoadDevice - invalid device name %ls", lpstrInstallName));
                goto exit_fn;
            }
        }
        lpstrInstallName = lpstrCopy;
    }

    // Break out the device driver pathname and the parameter list

    lpstrParams = strProfileString;

    // Eat characters until blank or null reached
    while (*lpstrParams != ' ' && *lpstrParams != '\0') {
        ++lpstrParams;
    }

    // Terminate driver file name, and separate the driver file name from its
    // parameters.  If there are no parameters, i.e. *lpstrParams=='\0',
    // leave lpstrParams pointing at the null.  Otherwise put a null
    // character to terminate the driver file name and step the pointer to
    // the first character in the parameter string.

    if (*lpstrParams == ' ') { *lpstrParams++ = '\0'; }

    //
    // We have changed from Win 3.1.  Because users cannot write to
    // system.ini the parameters have to be read from Win.Ini
    // section name [dll_name]
    // keyword         alias=parameters
    // If there are any parameters on the line read from [Drivers] use
    // them as a default.  This does preserve compatibility for those
    // applications that write directly to system.ini (and have the
    // privileges to get away with it).
    //
    // LATER: This stuff will be in the registry once the drivers themselves
    // (or it could be the drivers applet) creates a registry mapping.

    GetProfileString(strProfileString, lpstrInstallName, lpstrParams,
                     szDriverParms, sizeof(szDriverParms)/sizeof(WCHAR));
    lpstrParams = szDriverParms;
    dprintf3(("Parameters for device %ls (Driver %ls) >%ls<",
              lpstrInstallName, strProfileString, szDriverParms));

    //Now "strProfileString" is the device driver and "lpstrParams" is
    //the parameter string
    if (dwFlags & (MCI_OPEN_ELEMENT | MCI_OPEN_ELEMENT_ID)) {
        lpstrDeviceName = lpOpen->lpstrElementName;
    } else {
        lpstrDeviceName = lpOpen->lpstrDeviceType;
    }

    if (dwFlags & MCI_OPEN_ALIAS)
    {
        // If the alias is default then we've already checked its uniqueness
        if (!bDefaultAlias
        &&  mciGetDeviceIDInternal (lpOpen->lpstrAlias,
                                    lpOpenInfo->hCallingTask) != 0)
        {
            wErr = MCIERR_DUPLICATE_ALIAS;
            dprintf1(("mciLoadDevice - duplicate alias"));
            goto exit_fn;
        }
        lpstrDeviceName = lpOpen->lpstrAlias;
    }

    wID = mciAllocateNode (dwFlags, lpstrDeviceName, &nodeWorking);

    if (wID == 0)
    {
        dprintf1(("mciLoadDevice - cannot allocate new node, driver not loaded"));
        wErr = MCIERR_CANNOT_LOAD_DRIVER;
        goto exit_fn;
    }

    // Identify the task which initiated the open command
    if (lpOpenInfo->hCallingTask != NULL) {
        nodeWorking->hOpeningTask = lpOpenInfo->hCallingTask;
    } else {
        nodeWorking->hOpeningTask = GetCurrentTask();
    }

    if (nodeWorking->hOpeningTask != nodeWorking->hCreatorTask)
        nodeWorking->dwMCIFlags |= MCINODE_ISAUTOOPENED;

    // Initialize the driver
    DriverOpen.lpstrParams = lpstrParams;
    DriverOpen.wCustomCommandTable = MCI_TABLE_NOT_PRESENT;
    DriverOpen.wType = 0;
    DriverOpen.wDeviceID = wID;


    // Load the driver
    hDrvDriver = DrvOpen (strProfileString, MCI_HANDLERS,
                          (DWORD_PTR)(LPMCI_OPEN_DRIVER_PARMS)&DriverOpen);

    if (hDrvDriver == NULL)
    {
        dprintf1(("mciLoadDevice:  DrvOpen failed"));
        // Assume driver has free'd any custom command table when it failed the open
        mciFreeDevice (nodeWorking);
        wErr = MCIERR_CANNOT_LOAD_DRIVER;
        goto exit_fn;
    }

    lpOpen->wDeviceID = wID;
    //lpOpen->wReserved0 = 0;  Field does not exist in 32bit NT

    hDriver = DrvGetModuleHandle (hDrvDriver);

    nodeWorking->hDrvDriver = hDrvDriver;
    nodeWorking->hDriver = hDriver;

    // Driver provides custom device table and type
    nodeWorking->wCustomCommandTable = DriverOpen.wCustomCommandTable;
    nodeWorking->wDeviceType = DriverOpen.wType;

    // Load driver's type table
    if ((nodeWorking->wCommandTable = mciLoadTableType (DriverOpen.wType))
        == MCI_TABLE_NOT_PRESENT) {
        // Load from a file if necessary
        nodeWorking->wCommandTable =
            mciLoadCommandResource (ghInst, lpOpen->lpstrDeviceType,
                                    DriverOpen.wType);
        dprintf3(("  Command table id: %08XH", nodeWorking->wCommandTable));
    }


    // Record this for 'sysinfo installname'
    if ((nodeWorking->lpstrInstallName =
                  mciAlloc( BYTE_GIVEN_CHAR( wcslen( lpstrInstallName ) + 1 )))
        == NULL)
    {
        mciCloseDevice (wID, 0L, NULL, FALSE);
        dprintf1(("mciLoadDevice - out of memory"));
        wErr = MCIERR_OUT_OF_MEMORY;
        goto exit_fn;
    } else
        wcscpy( nodeWorking->lpstrInstallName, lpstrInstallName );

    // Reparse the input command if no type was known the first time or if
    // there was a custom command table
    // and there were any open command parameters
    if (lpOpenInfo->lpstrParams != NULL)
    {
        if ((wErr = mciReparseOpen (lpOpenInfo,
                                    nodeWorking->wCustomCommandTable,
                                    nodeWorking->wCommandTable,
                                    &dwFlags, &lpOpen, wID)) != 0)
        {
            dprintf1(("mciLoadDevice - error reparsing input command"));
            mciCloseDevice (wID, 0L, NULL, FALSE);
            goto exit_fn;
        }
        // If there is no custom command table but mciSendString had a parsing
        // error then close the device and report the error now
    } else if (lpOpenInfo->wParsingError != 0)
    {
        mciCloseDevice (wID, 0L, NULL, FALSE);
        wErr = lpOpenInfo->wParsingError;
        goto exit_fn;
    }

    /* Send MCI_OPEN_DRIVER command to device */
    wErr = LOWORD(mciSendCommandW(wID, MCI_OPEN_DRIVER,
                                 dwFlags, (DWORD_PTR)lpOpen));

    // If the OPEN failed then close the device (don't send a CLOSE though)
    if (wErr != 0)
        mciCloseDevice (wID, 0L, NULL, FALSE);
    else
        // Set default break key
        mciSetBreakKey (wID, VK_CANCEL, NULL);

    // If we replaced the open parms here then free them
    if (lpOriginalOpenParms != lpOpen && lpOpen != NULL)
        mciFree (lpOpen);

exit_fn:
    if (lpstrCopy != NULL)
        mciFree (lpstrCopy);

    return wErr;
}

/*
 * @doc INTERNAL MCI
 * @api BOOL | mciExtractDeviceType | If the given device name ends with
 * a file extension (.???) then try to get a typename from the
 * [mci extensions] section of WIN.INI
 *
 * @parm LPCWSTR | lpstrDeviceName | The name to get the type from
 *
 * @parm LPWSTR | lpstrDeviceType | The device type, returned to caller.
 *
 * @parm UINT | wBufLen | The length of the output buffer
 *
 * @rdesc TRUE if the type was found, FALSE otherwise
 *
 */
BOOL mciExtractDeviceType (
    LPCWSTR lpstrDeviceName,
    LPWSTR  lpstrDeviceType,
    UINT   wBufLen)
{
    LPCWSTR lpstrExt = lpstrDeviceName;
    int i;

    dprintf2(("mciExtractDeviceType(%ls)", lpstrDeviceName));

#if 0
#ifdef BAD_CODE
//This block cannot be used because it returns FALSE whenever a ! is found.
//Hence if the directory name has a ! ...
//N.B. The ! is used by MCI as a compound device name separator, but that is
//not applicable when going through this routine.

    // Goto end of string
    while (*lpstrExt != '\0')
    {
        // WARNING: This causes problems when the directory name has a !
        // '!' case is handled elsewhere
        if (*lpstrExt++ == '!')
            return FALSE;

        // Pointer has been incremented in the test
    }
#else
    // Goto end of string
    lpstrExt += wcslen(lpstrExt);
#endif
#else

    /*
    ** scan the string looking for a '!' character.  If we find one
    ** replace it with a NULL and see if the string to its left is a
    ** supported device type.  If it is return FALSE, either way replace the
    ** '\0' character with a '!'.
    */
    {
        LPWSTR lpwstr = wcschr(lpstrExt, '!' );

        /*
        ** If we found a '!' and it wasn't the first character in the
        ** the string we might have a compound device name.
        */
        if ( (lpwstr != NULL) && (lpwstr != lpstrExt) ) {

            int     nResult;
            WCHAR   wTmp[33];

            /*
            ** We're not interested in the actual string returned only if
            ** it is present in the list of mci devices.  A return code
            ** of 0 from GetPrivateProfileStringW means we don't have a
            ** compound name.
            */
            *lpwstr = '\0';
            nResult = GetPrivateProfileStringW( MCI_HANDLERS, lpstrExt, wszNull,
                                          wTmp, sizeof(wTmp) / sizeof(WCHAR),
                                          MCIDRIVERS_INI_FILE);
            /*
            ** Restore the original string
            */
            *lpwstr = '!';

            if ( nResult != 0 ) {
                return FALSE;
            }
        }
    }

    // Goto end of string
    lpstrExt += wcslen(lpstrExt);

#endif

    // Must be at least 2 characters in string
    if (lpstrExt - lpstrDeviceName < 2) {
        return FALSE;
    }

    // Now looking at the NULL terminator.  Check the
    // previous characters for a '.'

    for (i=1; i<=32; ++i)
    {
        --lpstrExt;

        // Cannot have path separator here
        if (*lpstrExt == '/' || *lpstrExt == '\\') {
            return FALSE;
        }

        if (*lpstrExt == '.')
        {
            if (1==i) {
            return(FALSE);
            // Would mean that extension is a null string
            }

#if DBG
            if (0 != (GetProfileStringW(MCI_EXTENSIONS, ++lpstrExt,
                                            wszNull, lpstrDeviceType, wBufLen))) {
                dprintf2(("Read extension %ls from section %ls. Driver=%ls", lpstrExt, MCI_EXTENSIONS, lpstrDeviceType));
                return(TRUE);
            } else {
                dprintf2(("Failed to read extension %s from section %s.", lpstrExt, MCI_EXTENSIONS));
                return(FALSE);
            }
#else
            return(0 != (GetProfileStringW(MCI_EXTENSIONS, ++lpstrExt,
                                           wszNull, lpstrDeviceType, wBufLen)));
#endif
        }

        if (lpstrExt == lpstrDeviceName) {
            return FALSE;
            // We have run out of string
        }

    }
    return FALSE;
}

// Copy characters up to cSeparater into output which is allocated
// by this function using mciAlloc.  Return the input pointer pointing
// to the character after cSeparator
// unless the separator is '\0' in which case it points to the end.
//
// Return the allocated pointer
//
// If bMustFind then the output string is created only if the token
// is found and is otherwise NULL.  Else the output string is always created.
//
// cSeparator is ignored inside matching quotes ("abd"), the quotes
// are not coppied and doubled
// quotes inside are compressed to one.  There must be a terminating quote.
// Quotes are treated normally unless the first character is a quote
//
// Function return value is 0 or an MCIERR code.  A missing separator does
// not cause an error return.
UINT mciEatToken (
    LPCWSTR *lplpstrInput,
    WCHAR cSeparater,
    LPWSTR *lplpstrOutput,
    BOOL bMustFind)
{
    LPCWSTR lpstrEnd = *lplpstrInput, lpstrCounter;
    LPWSTR  lpstrOutput;
    UINT wLen;
    BOOL bInQuotes = FALSE, bParseQuotes = TRUE, bQuoted = FALSE;

// Clear output
   *lplpstrOutput = NULL;

// Scan for token or end of string
    while ((*lpstrEnd != cSeparater || bInQuotes) && *lpstrEnd != '\0')
    {
// If quote
        if (*lpstrEnd == '"' && bParseQuotes)
        {
// If inside quotes
            if (bInQuotes)
            {
// If next character is a quote also
                if (*(lpstrEnd + 1) == '"')
// Skip it
                    ++lpstrEnd;
                else
                    bInQuotes = FALSE;
            } else {
                bInQuotes = TRUE;
                bQuoted = TRUE;
            }
        } else if (!bInQuotes)
        {
            if (bQuoted)
                return MCIERR_EXTRA_CHARACTERS;
// A non-quote was read first so treat any quotes as normal characters
            bParseQuotes = FALSE;
        }
        ++lpstrEnd;
    }

    if (bInQuotes)
        return MCIERR_NO_CLOSING_QUOTE;

// Fail if the token was not found and bMustFind is TRUE
    if (*lpstrEnd != cSeparater && bMustFind)
        return 0;

// Length of new string (INCLUDES QUOTES NOT COPIED)
    wLen = (UINT)(lpstrEnd - *lplpstrInput + 1);

    if ((*lplpstrOutput = mciAlloc( BYTE_GIVEN_CHAR( wLen ) )) == NULL)
        return MCIERR_OUT_OF_MEMORY;

// Copy into allocated space
    lpstrCounter = *lplpstrInput;
    lpstrOutput = *lplpstrOutput;
    bInQuotes = FALSE;

    while (lpstrCounter != lpstrEnd)
    {
        if (*lpstrCounter == '"' && bParseQuotes)
        {
            if (bInQuotes)
            {
// If this is a doubled quote
                if (*(lpstrCounter + 1) == '"')
// Copy it
                    *lpstrOutput++ = *lpstrCounter++;
                else
                    bInQuotes = FALSE;
            } else
                bInQuotes = TRUE;
// Skip the quote
            ++lpstrCounter;
        } else
            *lpstrOutput++ = *lpstrCounter++;
    }

    *lpstrOutput = '\0';
    if (*lpstrEnd == '\0')
        *lplpstrInput = lpstrEnd;
    else
        *lplpstrInput = lpstrEnd + 1;

    return 0;
}

// Take the type number from the open parameters and return
// it as a string in lplpstrType which must be free'd with mciFree
// Returns 0 or an MCI error code
UINT mciExtractTypeFromID (
    LPMCI_OPEN_PARMSW lpOpen)
{
    int nSize;
    LPWSTR lpstrType;

    if ((lpstrType = mciAlloc( BYTE_GIVEN_CHAR( MCI_MAX_DEVICE_TYPE_LENGTH ))) == NULL)
        return MCIERR_OUT_OF_MEMORY;

    // Load the type string corresponding to the ID
    if ((nSize = LoadStringW( ghInst,
                              LOWORD (PtrToUlong(lpOpen->lpstrDeviceType)),
                              lpstrType, MCI_MAX_DEVICE_TYPE_LENGTH ) ) == 0) {
        mciFree(lpstrType);
        return MCIERR_EXTENSION_NOT_FOUND;
    }

    // Add ordinal (if any) onto the end of the device type name
    if (HIWORD (lpOpen->lpstrDeviceType) != 0)
    {
        if (nSize > MCI_MAX_DEVICE_TYPE_LENGTH - 11)
        {
            dprintf1(("mciExtractTypeFromID:  type + ordinal too long"));
            mciFree(lpstrType);
            return MCIERR_DEVICE_ORD_LENGTH;
        }

        wsprintfW (lpstrType + nSize, szUnsignedFormat,
                    HIWORD (PtrToUlong(lpOpen->lpstrDeviceType)));
    }
    lpOpen->lpstrDeviceType = lpstrType;
    return 0;
}

/*
 * @doc INTERNAL MCI
 * @func UINT | mciOpenDevice | Open an MCI device for access.
 * Used in processing the MCI_OPEN message.
 *
 * @parm DWORD | dwFlags | Open Flags
 * @parm LPMCI_OPEN_PARMS | lpOpen | Description of device
 * @parm LPMCI_INTERNAL_OPEN_PARMS | lpOpenInfo | Internal device description
 *
 * @rdesc 0 if successful or an error code
 * @flag MCIERR_INVALID_DEVICE_NAME | Name not known
 * @flag MCIERR_DEVICE_OPEN | Device is already open and is not sharable
 *
 * @comm This function does the following:
 * 1) Check to see if device is already open.  If so, increase the use count
 *    and return the device ID
 *
 * Otherwise:
 *
 * 2) Locate the device name in the SYSTEM.INI file and load
 *    the corresponding device driver DLL
 *
 * 3) Allocate and initialize a new device description block
 *
 */
UINT mciOpenDevice (
    DWORD dwStartingFlags,
    LPMCI_OPEN_PARMSW lpOpen,
    LPMCI_INTERNAL_OPEN_INFO lpOpenInfo)
{
    LPWSTR               lpstrNewType = NULL;
    UINT                 wID;
    DWORD                wReturn;
    LPCWSTR              lpstrDeviceName;
    LPWSTR               lpstrNewElement = NULL;
    BOOL                 bFromTypeID = FALSE;
    LPCWSTR              lpstrOriginalType;
    LPCWSTR              lpstrOriginalElement;
    LPCWSTR              lpstrOriginalAlias;
    DWORD                dwFlags = dwStartingFlags;
    BOOL                 bDefaultAlias = FALSE;


// Initialize
    if (lpOpen == NULL) {
        dprintf2(("mciOpenDevice()   NULL parameter block"));
        return MCIERR_NULL_PARAMETER_BLOCK;
    }

    ClientUpdatePnpInfo();

    lpstrOriginalType = lpOpen->lpstrDeviceType;
    lpstrOriginalElement = lpOpen->lpstrElementName;
    lpstrOriginalAlias = lpOpen->lpstrAlias;

    // The type number is given explicitly, convert it to a type name
    if (dwFlags & MCI_OPEN_TYPE_ID) {
        if ((wReturn = mciExtractTypeFromID (lpOpen)) != 0)
            return (UINT)wReturn;
        else
            bFromTypeID = TRUE;
    }

    // The device name is the device type of a simple device or the device
    // element of a compound device

    if (dwFlags & MCI_OPEN_ELEMENT)
        lpstrDeviceName = lpstrOriginalElement;
    else if (dwFlags & MCI_OPEN_TYPE)
        lpstrDeviceName = lpOpen->lpstrDeviceType;
    else
        return MCIERR_MISSING_PARAMETER;

    if (lpstrDeviceName == NULL)
    {
        dprintf1(("mciOpenDevice:  Device name is NULL"));
        return MCIERR_INVALID_DEVICE_NAME;
    }

    // Is the device already open?
    if (dwFlags & MCI_OPEN_ELEMENT_ID)
        wID = mciGetDeviceIDFromElementIDW( PtrToUlong(lpstrDeviceName),
                                            lpOpen->lpstrDeviceType);
    else
        wID = mciGetDeviceIDInternal ((dwFlags & MCI_OPEN_ALIAS ?
                                       lpOpen->lpstrAlias : lpstrDeviceName),
                                       lpOpenInfo->hCallingTask);

    // If the device is open already then return an error
    if (wID != 0)
        return dwFlags & MCI_OPEN_ALIAS ? MCIERR_DUPLICATE_ALIAS :
                                          MCIERR_DEVICE_OPEN;

    // The device is not already open in that task by the name

    // If the type was derived then skip all this crap
    if (bFromTypeID)
        goto load_device;

    // If an element name is given but no type name (only via mciSendCommand)
    if (dwFlags & MCI_OPEN_ELEMENT && !(dwFlags & MCI_OPEN_TYPE))
    {

        // Allocate a piece of memory for resolving the device type
        lpstrNewType = mciAlloc( BYTE_GIVEN_CHAR(MCI_MAX_DEVICE_TYPE_LENGTH) );
        if (lpstrNewType == NULL) {
            return MCIERR_OUT_OF_MEMORY;
        }

        // Try to get the device type from the element name via a file extension
        if (mciExtractDeviceType( lpstrOriginalElement, lpstrNewType,
                                  MCI_MAX_DEVICE_TYPE_LENGTH))
        {
            lpOpen->lpstrDeviceType = lpstrNewType;
            dwFlags |= MCI_OPEN_TYPE;
        } else
        {
            mciFree (lpstrNewType);
            return MCIERR_EXTENSION_NOT_FOUND;
        }
    } else if (dwFlags & MCI_OPEN_TYPE && !(dwFlags & MCI_OPEN_ELEMENT))
    // A type name is given but no element
    {
        // Allocate a piece of memory for resolving the device type
        lpstrNewType = mciAlloc( BYTE_GIVEN_CHAR(MCI_MAX_DEVICE_TYPE_LENGTH) );
        if (lpstrNewType == NULL) {
            return MCIERR_OUT_OF_MEMORY;
        }

        // Try to extract a device type from the given device name via a file extension
        if (mciExtractDeviceType (lpOpen->lpstrDeviceType, lpstrNewType,
                                    MCI_MAX_DEVICE_TYPE_LENGTH))
        {
            // Fix up the type and element names
            dwFlags |= MCI_OPEN_ELEMENT;
            lpOpen->lpstrElementName = lpOpen->lpstrDeviceType;
            lpOpen->lpstrDeviceType = lpstrNewType;
        } else
        // Failed to extract type so...
        // Try to get a compound element name ('!' separator)
        {
            LPCWSTR lpstrTemp = lpOpen->lpstrDeviceType;

            mciFree (lpstrNewType);
            lpstrNewType = NULL;

            if ((wReturn = mciEatToken (&lpstrTemp, '!', &lpstrNewType, TRUE))
                != 0)
                goto cleanup;
            else if (lpstrNewType != NULL)
            {
                if ((wReturn = mciEatToken (&lpstrTemp, '\0',
                                            &lpstrNewElement, TRUE))
                    != 0)
                    goto cleanup;
                else if (lpstrNewElement != NULL &&
                           *lpstrNewElement != '\0')
                {
                    // See if this element name is in use
                    if (!(dwFlags & MCI_OPEN_ALIAS))
                        if (mciGetDeviceIDInternal (lpstrNewElement,
                                                    lpOpenInfo->hCallingTask))
                        {
                            wReturn = MCIERR_DEVICE_OPEN;
                            goto cleanup;
                        }
                    // Swap type and element for new ones
                    lpOpen->lpstrElementName = lpstrNewElement;
                    lpOpen->lpstrDeviceType = lpstrNewType;
                    dwFlags |= MCI_OPEN_ELEMENT;
                }
            }
        }
    } else
        lpstrNewType = NULL;

    // Tack on a default alias if none is given
    if (! (dwFlags & MCI_OPEN_ALIAS))
    {
        LPCWSTR lpstrAlias;

        // If an element name exists then the alias is the element name
        if (dwFlags & MCI_OPEN_ELEMENT)
        {
        // If a device ID was specified then there is no alias
            if (dwFlags & MCI_OPEN_ELEMENT_ID)
                lpstrAlias = NULL;
            else
                lpstrAlias = lpOpen->lpstrElementName;
        // Otherwise the alias is the device type
        } else
            lpstrAlias = lpOpen->lpstrDeviceType;

        if (lpstrAlias != NULL)
        {
            lpOpen->lpstrAlias = lpstrAlias;
            dwFlags |= MCI_OPEN_ALIAS;
            bDefaultAlias = TRUE;
        }
    }

load_device:;
    wReturn = mciLoadDevice (dwFlags, lpOpen, lpOpenInfo, bDefaultAlias);

cleanup:
    if (lpstrNewElement != NULL)
        mciFree (lpstrNewElement);
    if (lpstrNewType != NULL)
        mciFree (lpstrNewType);
    if (bFromTypeID)
        mciFree (lpOpen->lpstrDeviceType);

    // Replace original items
    lpOpen->lpstrDeviceType = lpstrOriginalType;
    lpOpen->lpstrElementName = lpstrOriginalElement;
    lpOpen->lpstrAlias = lpstrOriginalAlias;

    return (UINT)wReturn;
}

STATICFN void mciFreeDevice (LPMCI_DEVICE_NODE nodeWorking)
{
    LPMCI_DEVICE_NODE FAR *lpTempList;
    MCIDEVICEID uID = nodeWorking->wDeviceID;

    mciEnter("mciFreeDevice");

    if (nodeWorking->lpstrName != NULL)
        mciFree (nodeWorking->lpstrName);

    if (nodeWorking->lpstrInstallName != NULL)
        mciFree (nodeWorking->lpstrInstallName);

    mciFree(MCI_lpDeviceList[uID]);

    MCI_lpDeviceList[uID] = NULL;

/* If this was the last device in the list, decrement next ID value */
    if (uID + (MCIDEVICEID)1 == MCI_wNextDeviceID)
    {
        --MCI_wNextDeviceID;

// Try to reclaim any excess free space
        if (MCI_wDeviceListSize - MCI_wNextDeviceID + 1
            > MCI_DEVICE_LIST_GROW_SIZE)
        {
            MCI_wDeviceListSize -= MCI_DEVICE_LIST_GROW_SIZE;

            if ((lpTempList =
                mciReAlloc (MCI_lpDeviceList, sizeof (LPMCI_DEVICE_NODE) *
                                              MCI_wDeviceListSize)) == NULL)
                MCI_wDeviceListSize += MCI_DEVICE_LIST_GROW_SIZE;
            else
                MCI_lpDeviceList = lpTempList;
        }
    }

    mciLeave("mciFreeDevice");
}

typedef struct tagNotificationMsg {
    WPARAM wParam;
    LPARAM lParam;
} NOTIFICATIONMSG;

/*
 * @doc INTERNAL MCI
 * @api void | FilterNotification | Removes notifications for a given node
 *   from our notification window's message queue
 *
 * @parm LPMCI_DEVICE_NODE | nodeWorking | The internal device node
 *
 * @comm This function removes all MM_MCINOTIFY messages from hwndNotify's
 * message queue by removing all notifications for devices that have been
 * closed (i.e. do not belong to us), then putting the others back
 */
void FilterNotification(
LPMCI_DEVICE_NODE nodeWorking)
{
    NOTIFICATIONMSG anotmsg[256];
    UINT   uCurrentMsg;
    MSG    msg;

    /* We can't have the mci critical section on here because this PeekMessage
       will dispatch other messages in the queue */

    uCurrentMsg = 0;
    while (PeekMessage(&msg, hwndNotify, MM_MCINOTIFY, MM_MCINOTIFY, PM_NOYIELD | PM_REMOVE)) {
        if (LOWORD(msg.lParam) != nodeWorking->wDeviceID) {
            anotmsg[uCurrentMsg].wParam = msg.wParam;
            anotmsg[uCurrentMsg].lParam = msg.lParam;
            uCurrentMsg++;
        }
    }
    for (; uCurrentMsg;) {
        uCurrentMsg--;
        PostMessage(hwndNotify, MM_MCINOTIFY, anotmsg[uCurrentMsg].wParam, anotmsg[uCurrentMsg].lParam);
    }
}

/*
 * @doc INTERNAL MCI
 * @api UINT | mciCloseDevice | Close an MCI device.  Used in
 * processing the MCI_CLOSE message.
 *
 * @parm MCIDEVICEID | uID | The ID of the device to close
 * @parm DWORD | dwFlags | Close Flags
 * @parm LPMCI_GENERIC_PARMS | lpClose | Generic parameters
 * @parm BOOL | bCloseDriver | TRUE if the CLOSE command should be sent
 * on to the driver.
 *
 * @rdesc 0 if successful or an error code
 *
 * @comm This function sends an MCI_CLOSE_DEVICE message to the corresponding
 * driver if the use count is zero and then unloads the driver DLL
 *
 */
UINT mciCloseDevice (
    MCIDEVICEID uID,
    DWORD dwFlags,
    LPMCI_GENERIC_PARMS lpGeneric,
    BOOL bCloseDriver)
{
    LPMCI_DEVICE_NODE nodeWorking;
    UINT wErr;
    UINT wTable;

    mciEnter("mciCloseDevice");

    nodeWorking = MCI_lpDeviceList[uID];

    if (nodeWorking == NULL)
    {
        mciLeave("mciCloseDevice");
        dprintf1(("mciCloseDevice:  NULL node from device ID--error if not auto-close"));
        return 0;
    }

    // We should never be closed from the wrong task
#if 0
    WinAssert(nodeWorking->hCreatorTask == GetCurrentTask());
#endif

// If a close is in progress (usually this message comes from a Yield
// after a mciDriverNotify actuated by the active close) then exit
    if (ISCLOSING(nodeWorking)) {
        mciLeave("mciCloseDevice");
        return 0;
    }

    SETISCLOSING(nodeWorking);

    if (bCloseDriver)
    {
        MCI_GENERIC_PARMS   GenericParms;

        mciLeave("mciCloseDevice");
// Make fake generic params if close came internally
        if (lpGeneric == NULL) {
            lpGeneric = &GenericParms;
        }

        wErr = LOWORD(mciSendCommandW(uID, MCI_CLOSE_DRIVER, dwFlags,
                                            (DWORD_PTR)lpGeneric));
        mciEnter("mciCloseDevice");
    }
    else
        wErr = 0;

    wTable = nodeWorking->wCustomCommandTable;

    //
    // Must zero this to allow the table to be freed later by driver
    //
    // We mustn't call mciFreeCommandResource for the custom table
    // because the driver is going to do that when it gets DRV_FREE
    //
    nodeWorking->wCustomCommandTable = 0;

    wTable = nodeWorking->wCommandTable;
    nodeWorking->wCommandTable = 0;

    mciLeave("mciCloseDevice");

    mciFreeCommandResource (wTable);

    //
    // We're closing this node so remove any notifications queued to
    // hwndNotify because these would cause this node to be erroneously
    // closed again
    //

    if (ISAUTOOPENED(nodeWorking)) {
       FilterNotification(nodeWorking);
    }

    DrvClose (nodeWorking->hDrvDriver, 0L, 0L);  // ala CloseDriver

    mciFreeDevice (nodeWorking);

    return wErr;
}

/*
 * @doc INTERNAL MCI DDK
 * @api DWORD | mciGetDriverData | Returns a pointer to the instance
 * data associated with an MCI device
 *
 * @parm MCIDEVICEID | wDeviceID | The MCI device ID
 *
 * @rdesc The driver instance data.  On error, returns 0 but since
 * the driver data might be zero, this cannot be verified by the caller
 * unless the instance data is known to be non-zero (e.g. a pointer)
 *
 * @xref mciSetDriverData
 */
DWORD_PTR mciGetDriverData (
    MCIDEVICEID wDeviceID)
{
    DWORD_PTR   lpDriverData;

    mciEnter("mciGetDriverData");

    if (!MCI_VALID_DEVICE_ID(wDeviceID))
    {
        dprintf1(("mciGetDriverData:  invalid device ID"));
        lpDriverData = 0;
    } else {
        if (NULL == MCI_lpDeviceList[wDeviceID])
        {
            dprintf1(("mciGetDriverData:  NULL node from device ID"));
            lpDriverData = 0;
        } else {
            lpDriverData = MCI_lpDeviceList[wDeviceID]->lpDriverData;
        }
    }

    mciLeave("mciGetDriverData");

    return lpDriverData;
}

/*
 * @doc INTERNAL MCI DDK
 * @api BOOL | mciSetDriverData | Sets the instance
 * data associated with an MCI device
 *
 * @parm MCIDEVICEID | uDeviceID | The MCI device ID
 *
 * @parm DWORD | dwData | Driver data to set
 *
 * @rdesc 0 if the device ID is not known or there is insufficient
 * memory to load the device description.
 *
 */
BOOL mciSetDriverData (
    MCIDEVICEID wDeviceID,
    DWORD_PTR dwData)
{
    BOOL fReturn = TRUE;
    mciEnter("mciSetDriverData");

    if (!MCI_VALID_DEVICE_ID(wDeviceID))
    {
        dprintf1(("mciSetDriverData:  NULL node from device ID"));

        fReturn = FALSE;
    } else {
        MCI_lpDeviceList[wDeviceID]->lpDriverData = dwData;
    }

    mciLeave("mciSetDriverData");

    return fReturn;
}

/*
 * @doc INTERNAL MCI DDK
 * @api UINT | mciDriverYield | Used in a driver's idle loop
 * to yield to Windows
 *
 * @parm MCIDEVICEID | wDeviceID | Device ID that is yielding.
 *
 * @rdesc Non-zero if the driver should abort the operation.
 *
 */
UINT mciDriverYield (
    MCIDEVICEID  wDeviceID)
{
    mciEnter("mciDriverYield");

    if (MCI_VALID_DEVICE_ID(wDeviceID))
    {
        YIELDPROC YieldProc = (MCI_lpDeviceList[wDeviceID])->fpYieldProc;

        if (YieldProc != NULL) {
            DWORD YieldData = (MCI_lpDeviceList[wDeviceID])->dwYieldData;
            mciLeave("mciDriverYield");
            mciCheckOut();
            return (YieldProc)(wDeviceID, YieldData);
        }
    }

    mciLeave("mciDriverYield");

    Yield();
    return 0;
}


/*
 * @doc EXTERNAL MCI
 * @api BOOL | mciSetYieldProc | This function sets the address
 * of a procedure to be called periodically
 * when an MCI device is waiting for a command to complete because the WAIT
 * parameter was specified.
 *
 * @parm MCIDEVICEID | wDeviceID | Specifies the device ID to assign a procedure to.
 *
 * @parm YIELDPROC | fpYieldProc | Specifies the procedure to call
 * when yielding for the given device.  Set to NULL to disable
 * any existing yield proc.
 *
 * @parm DWORD | dwYieldData | Specifies the data sent to the yield procedure
 * when it is called for the given device.
 *
 * @rdesc Returns TRUE if successful. Returns FALSE for an invalid device ID.
 *
 * @comm This call overides any previous yield procedure for this device.
 *
 */
BOOL APIENTRY mciSetYieldProc (
    MCIDEVICEID wDeviceID,
    YIELDPROC fpYieldProc,
    DWORD dwYieldData)
{
    BOOL fReturn = FALSE;

    mciEnter("mciSetYieldProc");

    if (MCI_VALID_DEVICE_ID(wDeviceID))
    {
        LPMCI_DEVICE_NODE node = MCI_lpDeviceList[wDeviceID];

        node->fpYieldProc = fpYieldProc;
        node->dwYieldData = dwYieldData;

        fReturn = TRUE;
    } else
        fReturn = FALSE;

    mciLeave("mciSetYieldProc");

    return fReturn;
}

/*
 * @doc EXTERNAL MCI
 * @api YIELDPROC | mciGetYieldProc | This function gets the address
 * of the callback procedure to be called periodically when an MCI device
 * is completing a command specified with the WAIT flag.
 *
 * @parm UINT | wDeviceID | Specifies the device ID of the MCI device to
 * which the yield procedure is to be retrieved from.
 *
 * @parm LPDWORD | lpdwYieldData | Optionally specifies a buffer to place
 * the yield data passed to the function in.  If the parameter is NULL, it
 * is ignored.
 *
 * @rdesc Returns the current yield proc if any, else returns NULL for an
 * invalid device ID.
 *
 */
YIELDPROC WINAPI mciGetYieldProc (
    UINT wDeviceID,
    LPDWORD lpdwYieldData)
{
    YIELDPROC fpYieldProc;

    mciEnter("mciGetYieldProc");

    if (MCI_VALID_DEVICE_ID(wDeviceID))
    {
        if (lpdwYieldData != NULL) {
            V_WPOINTER(lpdwYieldData, sizeof(DWORD), NULL);
            *lpdwYieldData = MCI_lpDeviceList[wDeviceID]->dwYieldData;
        }
        fpYieldProc =  MCI_lpDeviceList[wDeviceID]->fpYieldProc;
    } else {
        fpYieldProc = NULL;
    }

    mciLeave("mciGetYieldProc");

    return fpYieldProc;
}


/*
 * @doc INTERNAL MCI
 * @api int | mciBreakKeyYieldProc | Procedure called to check a
 * key state for the given device
 *
 * @parm MCIDEVICEID | wDeviceID | Device ID which is yielding
 *
 * @parm DWORD | dwYieldData | Data for this device's yield proc
 *
 * @rdesc Non-zero if the driver should abort the operation. Currently
 * always returns 0.
 *
 */
UINT mciBreakKeyYieldProc (
    MCIDEVICEID wDeviceID,
    DWORD dwYieldData)
{
    HWND hwndCheck = NULL;
    int nVirtKey, nState;
    nVirtKey = dwYieldData;

    UNREFERENCED_PARAMETER(wDeviceID);

    nState = GetAsyncKeyState (nVirtKey);

// Break if key is down or has been down
    if (nState & 1 /* used to be 0x8000*/ )
    {
        MSG msg;
        while (PeekMessage (&msg, hwndCheck, WM_KEYFIRST, WM_KEYLAST,
               PM_REMOVE));
        return MCI_ERROR_VALUE;
    }

    Yield();
    return 0;
}

/*
 * @doc INTERNAL MCI
 * @api UINT FAR | mciSetBreakKey | Set a key which will break a wait loop
 * for a given driver
 *
 * @parm UINT | uDeviceID | The device ID to assign a break key to
 *
 * @parm int | nVirtKey | Virtual key code to trap
 *
 * @parm HWND | hwndTrap | The handle to a window that must be active
 * for the key to be trapped.  If NULL then all windows will be checked
 *
 * @rdesc TRUE if successful, FALSE if invalid device ID
 *
 */
UINT FAR mciSetBreakKey (
    MCIDEVICEID wDeviceID,
    int nVirtKey,
    HWND hwndTrap)
{
    dprintf2(("Setting break key for device %d to %x", wDeviceID, nVirtKey));
    return mciSetYieldProc (wDeviceID, mciBreakKeyYieldProc, nVirtKey);
    // Note: we have no way of passing hwndTrap... will check all windows
    // on this thread of the application
}

/*
 * @doc INTERNAL MCI
 * @api BOOL | mciDriverNotify | Used by a driver to send
 * a notification message
 *
 * @parm HANDLE | hCallback | The window to notify
 *
 * @parm UINT | wDeviceID | The device ID which triggered the callback
 *
 * @parm UINT | wStatus | The status of the callback.  May be one of
 * MCI_NOTIFY_SUCCESSFUL or MCI_NOTIFY_SUPERSEDED or MCI_NOTIFY_ABORTED or
 * MCI_NOTIFY_FAILURE
 *
 * @rdesc returns TRUE if notify was successfully sent, FALSE otherwise.
 *
 * @comm This function is callable at interrupt time
 *
 */
BOOL mciDriverNotify (
    HANDLE hCallback,
    MCIDEVICEID wDeviceID,
    UINT uStatus)
{
    BOOL f;

#if DBG
// IsWindow() is in segment marked PRELOAD for WIN3.0 so OK at interrupt time
    if (hCallback != NULL && !IsWindow(hCallback))
    {
        dprintf1(("mciDriverNotify: invalid window!"));
        return FALSE;
    }
#endif

    f = PostMessage(hCallback, MM_MCINOTIFY, uStatus, wDeviceID);

#if DBG
    if (!f)
        dprintf1(("mciDriverNotify: PostMessage failed!"));
#endif

    return f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\midiemu.c ===
/*****************************************************************************
    midiemu.c

    MIDI support -- routines for stream emulation

    Copyright (c) 1990-1999 Microsoft Corporation

*****************************************************************************/
#define INCL_WINMM
#include "winmmi.h"
#include "muldiv32.h"

#define NUM_NOTES           (128)
#define NUM_CHANNELS        (16)
#define MEMU_CB_NOTEON      (NUM_CHANNELS*NUM_NOTES/2)    // 16 chan * 128 notes (4 bits/note)
#define MAX_NOTES_ON        (0xF)

#define TIMER_OFF           (0)

PMIDIEMU    gpEmuList           = NULL;
UINT        guMIDIInTimer       = 0;
UINT        guMIDITimerID       = TIMER_OFF;
BOOL        gfMinPeriod         = FALSE;
UINT        guMIDIPeriodMin;

STATIC HMIDI FAR PASCAL mseIDtoHMidi(
    PMIDIEMU                pme,
    DWORD                   dwStreamID);

MMRESULT FAR PASCAL mseOpen(
    PDWORD_PTR              lpdwUser,
    LPMIDIOPENDESC          lpmod,
    DWORD                   fdwOpen);

MMRESULT FAR PASCAL mseClose(
    PMIDIEMU                pme);

MMRESULT FAR PASCAL mseProperty(
    PMIDIEMU                pme,
    LPBYTE                  lpbProp,
    DWORD                   fdwProp);

MMRESULT FAR PASCAL mseGetPosition(
    PMIDIEMU                pme,
    LPMMTIME                lpmmt);

MMRESULT FAR PASCAL mseGetVolume(
    PMIDIEMU                pme,
    LPDWORD                 lpdwVolume);

MMRESULT FAR PASCAL mseSetVolume(
    PMIDIEMU                pme,
    DWORD                   dwVolume);

MMRESULT FAR PASCAL mseOutStop(
    PMIDIEMU        pme);

MMRESULT FAR PASCAL mseOutReset(
    PMIDIEMU        pme);

MMRESULT FAR PASCAL mseOutPause(
    PMIDIEMU        pme);

MMRESULT FAR PASCAL mseOutRestart(
    PMIDIEMU        pme,
    DWORD           msTime,
    DWORD           tkTime);

MMRESULT FAR PASCAL mseOutCachePatches(
    PMIDIEMU        pme,
    UINT            uBank,
    LPWORD          pwpa,
    UINT            fuCache);

MMRESULT FAR PASCAL mseOutCacheDrumPatches(
    PMIDIEMU        pme,
    UINT            uPatch,
    LPWORD          pwkya,
    UINT            fuCache);

DWORD FAR PASCAL mseOutBroadcast(
    PMIDIEMU        pme,
    UINT            msg,
    DWORD_PTR       dwParam1,
    DWORD_PTR       dwParam2);

DWORD FAR PASCAL mseTimebase(
    PCLOCK                      pclock);

#ifndef WIN32
#pragma alloc_text(FIXMIDI, mseIDtoHMidi)
#pragma alloc_text(FIXMIDI, mseMessage)
#pragma alloc_text(FIXMIDI, mseOutReset)

#pragma alloc_text(FIXMIDI, midiOutScheduleNextEvent)
#pragma alloc_text(FIXMIDI, midiOutPlayNextPolyEvent)
#pragma alloc_text(FIXMIDI, midiOutDequeueAndCallback)
#pragma alloc_text(FIXMIDI, midiOutTimerTick)
#pragma alloc_text(FIXMIDI, midiOutCallback)
#pragma alloc_text(FIXMIDI, midiOutSetClockRate)
#pragma alloc_text(INIT,midiEmulatorInit)
#pragma alloc_text(FIXMIDI, mseTimebase)
#endif

/****************************************************************************/
/****************************************************************************/

INLINE LONG PDEVLOCK(PMIDIEMU pdev)
{
    LONG lTemp;

    lTemp = InterlockedIncrement(&(pdev->lLockCount));

    EnterCriticalSection(&(pdev->CritSec));

    return lTemp;
}

INLINE LONG PDEVUNLOCK(PMIDIEMU pdev)
{
    LONG lTemp;

    lTemp = InterlockedDecrement(&(pdev->lLockCount));

    LeaveCriticalSection(&(pdev->CritSec));

    return lTemp;
}


/****************************************************************************/
/****************************************************************************/
DWORD FAR PASCAL mseMessage(
    UINT                    msg,
    DWORD_PTR               dwUser,
    DWORD_PTR               dwParam1,
    DWORD_PTR               dwParam2)
{
    MMRESULT                mmr = MMSYSERR_NOERROR;
    PMIDIEMU                pme = (PMIDIEMU)dwUser;


    switch(msg)
    {
        case MODM_OPEN:
            mmr = mseOpen((PDWORD_PTR)dwUser, (LPMIDIOPENDESC)dwParam1, (DWORD)dwParam2);
            break;

        case MODM_CLOSE:
            mmr = mseClose(pme);
            break;

        case MODM_GETVOLUME:
            mmr = mseGetVolume(pme, (LPDWORD)dwParam1);
            break;

        case MODM_SETVOLUME:
            mmr = mseSetVolume(pme, (DWORD)dwParam1);
            break;

        case MODM_PREPARE:
        case MODM_UNPREPARE:
            mmr = MMSYSERR_NOTSUPPORTED;
            break;

        case MODM_DATA:
//#pragma FIXMSG("How to route async short messages to other stream-ids?")

            if (!(dwParam1 & 0x80))
                mmr = MIDIERR_BADOPENMODE;
            else
                mmr = midiOutShortMsg((HMIDIOUT)pme->rIds[0].hMidi, (DWORD)dwParam1);
            break;

        case MODM_RESET:
            mmr = mseOutReset(pme);
            break;

        case MODM_STOP:
            mmr = mseOutStop(pme);
            break;

        case MODM_CACHEPATCHES:
            mmr = mseOutCachePatches(pme, HIWORD(dwParam2), (LPWORD)dwParam1, LOWORD(dwParam2));
            break;

        case MODM_CACHEDRUMPATCHES:
            mmr = mseOutCacheDrumPatches(pme, HIWORD(dwParam2), (LPWORD)dwParam1, LOWORD(dwParam2));
            break;

        case MODM_PAUSE:
            mmr = mseOutPause(pme);
            break;

        case MODM_RESTART:
            mmr = mseOutRestart(pme, (DWORD)dwParam1, (DWORD)dwParam2);
            break;

        case MODM_STRMDATA:
            mmr = mseOutSend(pme, (LPMIDIHDR)dwParam1, (UINT)dwParam2);
            break;

        case MODM_PROPERTIES:
            mmr = mseProperty(pme, (LPBYTE)dwParam1, (DWORD)dwParam2);
            break;

        case MODM_GETPOS:
            mmr = mseGetPosition(pme, (LPMMTIME)dwParam1);
            break;

        default:
            if ((msg < DRVM_IOCTL) ||
                (msg >= DRVM_IOCTL_LAST) && (msg < DRVM_MAPPER))
            {
                dprintf1(("Unknown message [%04X] in MIDI emulator", (WORD)msg));
                mmr = MMSYSERR_NOTSUPPORTED;
            }
            else
                mmr = mseOutBroadcast(pme, msg, dwParam1, dwParam2);
    }

    return mmr;
}

MMRESULT FAR PASCAL mseOpen(
    PDWORD_PTR              lpdwUser,
    LPMIDIOPENDESC          lpmod,
    DWORD                   fdwOpen)
{
    MMRESULT                mmrc        = MMSYSERR_NOERROR;
    DWORD                   cbHandle;
    PMIDIEMU                pme         = NULL;
    UINT                    idx;

    mmrc = MMSYSERR_NOMEM;
    cbHandle = sizeof(MIDIEMU) + lpmod->cIds * ELESIZE(MIDIEMU, rIds[0]);
    if (cbHandle >= 65536L)
    {
        dprintf1(("mSEO: cbHandle >= 64K!"));
        goto mseOpen_Cleanup;
    }

    if (NULL == (pme = (PMIDIEMU)winmmAlloc(cbHandle)))
    {
        dprintf1(("mSEO: !winmmAlloc(cbHandle)"));
        goto mseOpen_Cleanup;
    }

    if (NULL == (pme->rbNoteOn = winmmAlloc(MEMU_CB_NOTEON)))
    {
        dprintf1(("mSEO: !GlobalAlloc(MEMU_CB_NOTEON"));
        goto mseOpen_Cleanup;
    }

    pme->fdwDev |= MDV_F_LOCKED;

    pme->hStream        = (HMIDISTRM)lpmod->hMidi;
    pme->dwTimeDiv      = DEFAULT_TIMEDIV;
    pme->dwTempo        = DEFAULT_TEMPO;
    pme->dwCallback     = lpmod->dwCallback;
    pme->dwFlags        = fdwOpen;
    pme->dwInstance     = lpmod->dwInstance;
    pme->dwPolyMsgState = PM_STATE_PAUSED;
    pme->chMidi         = (UINT)lpmod->cIds;
    pme->dwSavedState   = PM_STATE_STOPPED;
    pme->tkPlayed       = 0;
    pme->lLockCount     = -1;
    pme->dwSignature    = MSE_SIGNATURE;

    for (idx = 0; idx < pme->chMidi; idx++)
    {
        pme->rIds[idx].dwStreamID = lpmod->rgIds[idx].dwStreamID;

        mmrc = midiOutOpen((LPHMIDIOUT)&pme->rIds[idx].hMidi,
                           lpmod->rgIds[idx].uDeviceID,
                           (DWORD_PTR)midiOutCallback,
                           0L,
                           CALLBACK_FUNCTION);
        if (MMSYSERR_NOERROR != mmrc)
            goto mseOpen_Cleanup;
    }

    if (!mmInitializeCriticalSection(&pme->CritSec)) {
	mmrc = MMSYSERR_NOMEM;
	goto mseOpen_Cleanup;
    }

    clockInit(&pme->clock, 0, 0, mseTimebase);
    dprintf2(("midiOutOpen: midiOutSetClockRate()"));
    midiOutSetClockRate(pme, 0);


mseOpen_Cleanup:
    if (MMSYSERR_NOERROR != mmrc)
    {
        if (pme)
        {
            if (pme->rbNoteOn)
            {
                winmmFree(pme->rbNoteOn);
            }

            DeleteCriticalSection(&pme->CritSec);

            pme->dwSignature = 0L;

            for (idx = 0; idx < pme->chMidi; idx++)
                if (NULL != pme->rIds[idx].hMidi)
                    midiOutClose((HMIDIOUT)pme->rIds[idx].hMidi);
            winmmFree(pme);
        }
    }
    else
    {
        pme->pNext = gpEmuList;
        gpEmuList = pme;

        *lpdwUser = (DWORD_PTR)pme;
    }

    return mmrc;
}

MMRESULT FAR PASCAL mseClose(
    PMIDIEMU                pme)

{
    UINT                    idx;
    MMRESULT                mmrc;
    PMIDIEMU                pmePrev;
    PMIDIEMU                pmeCurr;

#ifdef DEBUG
{
    dprintf2(("cEvents %lu", pme->cEvents));

    for (idx = 0; idx < MEM_MAX_LATENESS; idx++)
        dprintf2(("%5u: %u", idx, pme->auLateness[idx]));
}
#endif

    if ((PM_STATE_STOPPED != pme->dwPolyMsgState &&
             PM_STATE_PAUSED  != pme->dwPolyMsgState &&
             PM_STATE_EMPTY   != pme->dwPolyMsgState))
    {
        dprintf1(("mseClose: Started playing again since close query!!!"));

        mseOutStop(pme);
    }

    midiOutAllNotesOff(pme);

    for (idx = 0; idx < pme->chMidi; idx++)
    {
        mmrc = midiOutClose((HMIDIOUT)pme->rIds[idx].hMidi);
        if (MMSYSERR_NOERROR != mmrc)
        {
            dprintf1(( "mseClose: HMIDI %04X returned %u for close", pme->rIds[idx].hMidi, mmrc));
        }
    }

    winmmFree(pme->rbNoteOn);

    pmePrev = NULL;
    pmeCurr = gpEmuList;

    while (pmeCurr)
    {
        if (pmeCurr == pme)
            break;

        pmePrev = pmeCurr;
        pmeCurr = pmeCurr->pNext;
    }

    if (pmeCurr)
    {
        if (pmePrev)
            pmePrev->pNext = pmeCurr->pNext;
        else
            gpEmuList = pmeCurr->pNext;
    }

    //
    //  Make sure that we don't have the critical section before
    //  we try to delete it.  Otherwise we will leak critical section
    //  handles in the kernel.
    //
    while ( pme->lLockCount >= 0 )
    {
        PDEVUNLOCK( pme );
    }

    DeleteCriticalSection(&pme->CritSec);

    pme->dwSignature = 0L;

    winmmFree(pme);

    return MMSYSERR_NOERROR;
}

STATIC HMIDI FAR PASCAL mseIDtoHMidi(
    PMIDIEMU                pme,
    DWORD                   dwStreamID)
{
    UINT                    idx;
    PMIDIEMUSID             pmesi;

    for (idx = 0, pmesi = pme->rIds; idx < pme->chMidi; idx++, pmesi++)
        if (pmesi->dwStreamID == dwStreamID)
            return pmesi->hMidi;

    return NULL;
}

MMRESULT FAR PASCAL mseProperty(
    PMIDIEMU                pme,
    LPBYTE                  lppropdata,
    DWORD                   fdwProp)
{
    PMIDISTRM               pms;

    pms = (PMIDISTRM)(pme->hStream);

    if ((!(fdwProp&MIDIPROP_SET)) && (!(fdwProp&MIDIPROP_GET)))
        return MMSYSERR_INVALPARAM;

    V_RPOINTER(lppropdata, sizeof(DWORD), MMSYSERR_INVALPARAM);

    if (fdwProp & MIDIPROP_SET)
    {
        V_RPOINTER(lppropdata, (UINT)(*(LPDWORD)(lppropdata)), MMSYSERR_INVALPARAM);
    }
    else
    {
        V_WPOINTER(lppropdata, (UINT)(*(LPDWORD)(lppropdata)), MMSYSERR_INVALPARAM);
    }

    switch(fdwProp & MIDIPROP_PROPVAL)
    {
        case MIDIPROP_TIMEDIV:
            if (((LPMIDIPROPTIMEDIV)lppropdata)->cbStruct < sizeof(MIDIPROPTIMEDIV))
                return MMSYSERR_INVALPARAM;

            if (fdwProp & MIDIPROP_GET)
            {
                ((LPMIDIPROPTIMEDIV)lppropdata)->dwTimeDiv = pme->dwTimeDiv;
                return MMSYSERR_NOERROR;
            }

            if (PM_STATE_STOPPED != pme->dwPolyMsgState &&
                    PM_STATE_PAUSED != pme->dwPolyMsgState)
                return MMSYSERR_INVALPARAM;

            pme->dwTimeDiv = ((LPMIDIPROPTIMEDIV)lppropdata)->dwTimeDiv;
            dprintf1(( "dwTimeDiv %08lX", pme->dwTimeDiv));
            midiOutSetClockRate(pme, 0);

            return MMSYSERR_NOERROR;

        case MIDIPROP_TEMPO:
            if (((LPMIDIPROPTEMPO)lppropdata)->cbStruct < sizeof(MIDIPROPTEMPO))
                return MMSYSERR_INVALPARAM;

            if (fdwProp & MIDIPROP_GET)
            {
                ((LPMIDIPROPTEMPO)lppropdata)->dwTempo = pme->dwTempo;
                return MMSYSERR_NOERROR;
            }

            pme->dwTempo = ((LPMIDIPROPTEMPO)lppropdata)->dwTempo;
            midiOutSetClockRate(pme, pme->tkPlayed);

            return MMSYSERR_NOERROR;

        default:
            return MMSYSERR_INVALPARAM;
    }
}

MMRESULT FAR PASCAL mseGetPosition(
    PMIDIEMU                pme,
    LPMMTIME                pmmt)
{
    DWORD                   tkTime;
    DWORD                   dw10Min;
    DWORD                   dw10MinCycle;
    DWORD                   dw1Min;
    DWORD                   dwDropMe;

    //
    // Figure out position in stream based on emulation.
    //

    //
    // Validate wType parameter and change it if needed.
    //
    if (pmmt->wType != TIME_TICKS && pmmt->wType != TIME_MS)
    {
            if (pme->dwTimeDiv & IS_SMPTE)
            {
                if (pmmt->wType != TIME_SMPTE)
                {
                    pmmt->wType = TIME_MS;
                }
            }
            else
            {
                if (pmmt->wType != TIME_MIDI)
                {
                    pmmt->wType = TIME_MS;
                }
            }
    }

    switch(pmmt->wType)
    {
        case TIME_TICKS:
            //
            // We interpret samples to be straight MIDI ticks.
            //
            tkTime = (DWORD)clockTime(&pme->clock);
            pmmt->u.ticks = (((TICKS)tkTime) < 0) ? 0 : tkTime;

            break;

        case TIME_MIDI:
            //
            // Song position pointer is number of 1/16th notes we've
            // played which we can get from number of ticks played and
            // number of 1/4 notes per tick.
            //
            tkTime = (DWORD)clockTime(&pme->clock);
            if (((TICKS)tkTime) < 0)
                tkTime = 0;

            pmmt->u.midi.songptrpos =
                muldiv32(
                    tkTime,
                    4,
                    TICKS_PER_QN(pme->dwTimeDiv));

            break;


        case TIME_SMPTE:

            tkTime = (DWORD)clockTime(&pme->clock);
            if (((TICKS)tkTime) < 0)
                tkTime = 0;

            pmmt->u.smpte.fps = (BYTE)(-SMPTE_FORMAT(pme->dwTimeDiv));

            //
            // If this has managed to get set to something bizarre, just
            // do normal 30 nondrop.
            //
            if ((pmmt->u.smpte.fps != SMPTE_24) &&
                (pmmt->u.smpte.fps != SMPTE_25) &&
                (pmmt->u.smpte.fps != SMPTE_30DROP) &&
                (pmmt->u.smpte.fps != SMPTE_30))
            {
                pmmt->u.smpte.fps = SMPTE_30;
            }

            switch(pmmt->u.smpte.fps)
            {
                case SMPTE_24:
                    pmmt->u.smpte.frame = (BYTE)(tkTime%24);
                    tkTime /= 24;
                    break;

                case SMPTE_25:
                    pmmt->u.smpte.frame = (BYTE)(tkTime%25);
                    tkTime /= 25;
                    break;

                case SMPTE_30DROP:
                    //
                    // Calculate drop-frame stuff.
                    //
                    // We add 2 frames per 1-minute interval except
                    // on every 10th minute.
                    //
                    dw10Min      = tkTime/S30D_FRAMES_PER_10MIN;
                    dw10MinCycle = tkTime%S30D_FRAMES_PER_10MIN;
                    dw1Min       = (dw10MinCycle < 2
                        ? 0 :
                        (dw10MinCycle-2)/S30D_FRAMES_PER_MIN);
                    dwDropMe     = 18*dw10Min + 2*dw1Min;

                    tkTime      += dwDropMe;

                    //
                    // !!! Falling through to 30-nondrop case !!!
                    //

                case SMPTE_30:
                    pmmt->u.smpte.frame = (BYTE)(tkTime%30);
                    tkTime /= 30;
                    break;
            }
            pmmt->u.smpte.sec   = (BYTE)(tkTime%60);
            tkTime /= 60;
            pmmt->u.smpte.min   = (BYTE)(tkTime%60);
            tkTime /= 60;
            pmmt->u.smpte.hour  = (BYTE)(tkTime);

            break;

        case TIME_MS:
            //
            // Use msTotal + ms since time parms last updated; this
            // takes starvation/paused time into account.
            //
            pmmt->u.ms =
                    clockMsTime(&pme->clock);

            break;

        default:
            dprintf1(( "midiOutGetPosition: unexpected wType!!!"));
            return MMSYSERR_INVALPARAM;
    }

    return MMSYSERR_NOERROR;
}

MMRESULT FAR PASCAL mseGetVolume(
    PMIDIEMU                pme,
    LPDWORD                 lpdwVolume)
{
    MMRESULT                mmr = MMSYSERR_NOTSUPPORTED;
    UINT                    idx;

    // Walk the device list underneath us until someone knows the volume
    //
    for (idx = 0; idx < pme->chMidi; ++idx)
        if (MMSYSERR_NOERROR ==
            (midiOutGetVolume((HMIDIOUT)pme->rIds[idx].hMidi, lpdwVolume)))
        {
            mmr = MMSYSERR_NOERROR;
            break;
        }

    return mmr;
}

MMRESULT FAR PASCAL mseSetVolume(
    PMIDIEMU                pme,
    DWORD                   dwVolume)
{
    MMRESULT                mmr = MMSYSERR_NOERROR;
    MMRESULT                mmr2;
    UINT                    idx;

    // Try to set everyone's volume
    //
    for (idx = 0; idx < pme->chMidi; ++idx)
        if (MMSYSERR_NOERROR !=
            (mmr2 = midiOutSetVolume((HMIDIOUT)pme->rIds[idx].hMidi, dwVolume)))
            mmr = mmr2;

    return mmr;

}

MMRESULT FAR PASCAL mseOutReset(
    PMIDIEMU        pme)
{
    LPMIDIHDR       lpmh;
    LPMIDIHDR       lpmhWork;
    UINT            idx;
    MSG             msg;

    // If we have anything posted to mmtask to be cleaned up, process
    // it first
    //
    while (pme->cPostedBuffers)
    {
        Sleep(0);
    }

    //
    //  If we're running the timer, interrupt and force a reschedule
    //  of all remaining channels.
    //
    if (guMIDITimerID != TIMER_OFF)
    {
        dprintf2(( "mOR: About to take %u", guMIDITimerID));
        if (MMSYSERR_NOERROR != timeKillEvent(guMIDITimerID))
        {
            dprintf1(( "timeKillEvent() failed in midiOutPolyMsg"));
        }
        else
        {
            guMIDITimerID = TIMER_OFF;
        }

        midiOutTimerTick(
                     guMIDITimerID,                          // ID of our timer
                     0,                                      // wMsg is unused
                     timeGetTime(),                          // dwUser unused
                     0L,                                     // dw1 unused
                     0L);                                    // dw2 unused
        dprintf2(( "mOR: mOTT"));

        if (gfMinPeriod)
        {
            gfMinPeriod = FALSE;
            timeEndPeriod(guMIDIPeriodMin);
        }
    }

    //
    //  Kill anything queued for midiOutPolyMsg. This will ensure that
    //  sending will stop after the current buffer.
    //
    PDEVLOCK( pme );
    lpmh = pme->lpmhFront;
    pme->lpmhFront = NULL;
    pme->lpmhRear  = NULL;
    pme->dwPolyMsgState = PM_STATE_EMPTY;

    while (lpmh)
    {
        lpmh->dwFlags &= ~MHDR_INQUEUE;
        lpmh->dwFlags |= MHDR_DONE;
        lpmhWork = lpmh->lpNext;

        dprintf2(( "mOR: Next buffer to nuke %08lx", lpmhWork));

        midiOutNukePMBuffer(pme, lpmh);

        lpmh = lpmhWork;
    }

    //
    //  Check to see if our pme structure is still valid.   Someone
    //  might have called midiStreamClose in their callback and we
    //  don't want to touch it after it's closed and freed.  This
    //  is what the MidiPlyr sample application does.
    //
    try
    {
        if (MSE_SIGNATURE != pme->dwSignature)  // must have been freed
            return MMSYSERR_NOERROR;

        PDEVUNLOCK( pme );  // keep it in try for extra protection
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        return MMSYSERR_NOERROR;
    }

    //
    // We've just reset the stream; restart the tick clock at 0 and invalidate
    // the time division to force the time stuff to be reset when the next
    // polymsg comes in.
    //
    dprintf2(( "midiOutReset: clockInit()/ midiOutSetClockRate()"));
    clockInit(&pme->clock, 0, 0, mseTimebase);
    midiOutSetClockRate(pme, 0);

    pme->tkPlayed = 0;

    // Have a reset party on all the drivers under us
    //
    for (idx = 0; idx < pme->chMidi; idx++)
        midiOutReset((HMIDIOUT)pme->rIds[idx].hMidi);

    pme->dwPolyMsgState = PM_STATE_PAUSED;

    return MMSYSERR_NOERROR;
}

MMRESULT FAR PASCAL mseOutStop(
    PMIDIEMU        pme)
{
    LPMIDIHDR       lpmh;
    LPMIDIHDR       lpmhWork;
    MSG             msg;
    BOOL            fSetEvent = FALSE;

    // If we have anything posted to mmtask to be cleaned up, process
    // it first
    //
    while (pme->cPostedBuffers)
    {
        Sleep(0);
    }

    //
    //  If we're running the timer, interrupt and force a reschedule
    //  of all remaining channels.
    //
    if (guMIDITimerID != TIMER_OFF)
    {
        dprintf2(( "mOS: About to take %u", guMIDITimerID));
        if (MMSYSERR_NOERROR != timeKillEvent(guMIDITimerID))
        {
            dprintf1(( "timeKillEvent() failed in midiOutPolyMsg"));
        }
        else
        {
            guMIDITimerID = TIMER_OFF;
        }

        dprintf2(( "mOS: take -- About to mOTT"));

        midiOutTimerTick(
                     guMIDITimerID,                              // ID of our timer
                     0,                                      // wMsg is unused
                     timeGetTime(),                          // dwUser unused
                     0L,                                     // dw1 unused
                     0L);                                    // dw2 unused

        dprintf2(( "mOS: mOTT"));

        if (gfMinPeriod)
        {
            gfMinPeriod = FALSE;
            timeEndPeriod(guMIDIPeriodMin);
        }
    }

    //
    //  Kill anything queued for midiOutPolyMsg. This will ensure that
    //  sending will stop after the current buffer.
    //
    PDEVLOCK( pme );
    lpmh = pme->lpmhFront;
    pme->lpmhFront = NULL;
    pme->lpmhRear  = NULL;
    pme->dwPolyMsgState = PM_STATE_EMPTY;

    while (lpmh)
    {
        lpmh->dwFlags &= ~MHDR_INQUEUE;
        lpmh->dwFlags |= MHDR_DONE;
        lpmhWork = lpmh->lpNext;

        dprintf2(( "mOS: Next buffer to nuke %08lx", lpmhWork));

        midiOutNukePMBuffer(pme, lpmh);

        lpmh = lpmhWork;
    }

    //
    //  Check to see if our pme structure is still valid.   Someone
    //  might have called midiStreamClose in their callback and we
    //  don't want to touch it after it's closed and freed.  This
    //  is what the MidiPlyr sample application does.
    //
    try
    {
        if (MSE_SIGNATURE != pme->dwSignature)  // must have been freed
            return MMSYSERR_NOERROR;

        PDEVUNLOCK( pme );  // keep it in try for extra protection
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        return MMSYSERR_NOERROR;
    }

    //
    // We've just reset the stream; restart the tick clock at 0 and invalidate
    // the time division to force the time stuff to be reset when the next
    // polymsg comes in.
    //

    dprintf2(( "midiOutStop: clockInit()/ midiOutSetClockRate()"));
    clockInit(&pme->clock, 0, 0, mseTimebase);
    midiOutSetClockRate(pme, 0);

    pme->tkPlayed = 0;

    //
    //  In case someone queues up headers during the stop
    //  operation we want to make sure that all they have to
    //  do is restart the stream to get started again.
    //
    mseOutPause(pme);

    //midiOutAllNotesOff(pme);

    //pme->dwPolyMsgState = PM_STATE_STOPPED;

    return MMSYSERR_NOERROR;
}

MMRESULT FAR PASCAL mseOutPause(
    PMIDIEMU        pme)
{
    //
    // Emulating on this handle - do the pause ourselves.
    //
    if (pme->dwPolyMsgState == PM_STATE_PAUSED)
        return MMSYSERR_NOERROR;

    pme->dwSavedState   = pme->dwPolyMsgState;
    pme->dwPolyMsgState = PM_STATE_PAUSED;

    clockPause(&pme->clock, CLK_TK_NOW);

    midiOutAllNotesOff(pme);

    return MMSYSERR_NOERROR;
}

MMRESULT FAR PASCAL mseOutRestart(
    PMIDIEMU        pme,
    DWORD           msTime,
    DWORD           tkTime)
{
    //
    // Emulating on this handle - do the pause ourselves.
    //
    if (pme->dwPolyMsgState != PM_STATE_PAUSED)
        return MMSYSERR_NOERROR;

    pme->dwPolyMsgState = pme->dwSavedState;

    clockRestart(&pme->clock, tkTime, msTime);

    dprintf2(( "restart: state->%lu", pme->dwPolyMsgState));

    midiOutTimerTick(
            guMIDITimerID,               // ID of our timer
            0,                           // wMsg is unused
            timeGetTime(),
            0L,                          // dw1 unused
            0L);                         // dw2 unused

    return MMSYSERR_NOERROR;
}

/*****************************************************************************
 * @doc INTERNAL  MIDI
 *
 * @api void | midiEmulatorInit | This function is called at init time to
 *   allow MMSYSTEM to initialize anything it needs to for the polymsg
 *   emulators. Right now, all we do is find the minimum period of the
 *   timeGetTime clock.
 *
 * @rdesc Currently always returns MMSYSERR_NOERROR.
 ****************************************************************************/

#ifdef DEBUG
STATIC SZCODE aszInit[] = "midiEmulatorInit: Using clock res of %lums.";
#endif

void NEAR PASCAL midiEmulatorInit
(
    void
)
{
    TIMECAPS        tc;

    if (MMSYSERR_NOERROR != timeGetDevCaps(&tc, sizeof(tc)))
    {
        dprintf1(( "***            MMSYSTEM IS HORKED             ***"));
        dprintf1(( "*** timeGetDevCaps failed in midiEmulatorInit ***"));

        return;
    }

    //
    // Select the larger of the period we would like to have or
    // the minimum period the timer supports.
    //
    guMIDIPeriodMin = max(MIN_PERIOD, tc.wPeriodMin);

//    guMIDIPeriodMin = MIN_PERIOD;

#ifdef DEBUG
    dprintf2(( aszInit, (DWORD)guMIDIPeriodMin));
#endif
}

/*****************************************************************************
 * @doc EXTERNAL MIDI M4
 *
 * @api UINT | mseOutSend | Plays or queues a buffer of
 * MIDI data to a MIDI output device.
 *
 * @parm PMIDIEMU | pme | Specifies the stream instance the data should
 * go to.
 *
 * @parm LPMIDIHDR | lpMidiOutHdr | Specifies a far pointer to a <t MIDIHDR>
 *   structure that identifies the MIDI data buffer.
 *
 * @parm UINT | cbMidiHdr | Specifies the size of the <t MIDIHDR> structure.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise,
 * it returns an error number. Possible error values include the following:
 *
 *  @flag MMSYSERR_INVALHANDLE | The specified device handle is invalid.
 *  @flag MMSYSERR_INVALPARAM | The value of <p lpMidiOutHdr> is invalid.
 *  @flag MIDIERR_UNPREPARED | The output buffer header <p lpMidiOutHdr> has
 *  not been prepared.
 *  @flag MIDIERR_STILLPLAYING | <p lpMidiOutHdr> is still playing or
 *  queued from a previous call to <f midiOutPolyMsg>.
 *
 * @comm The polymessage buffer contains one or more MIDI messages. Entries in the
 * buffer can be of the following three types:
 *
 * @flag Short Message | Is two DWORDs. One contains time data, the other
 * contains message content. Time information is the time to wait between the
 * previous event and the event being described. Time units are based on the
 * time-division header in the MIDI file.
 *
 * Message content for short messages occupy the 24 least-significant bits of
 * the DWORD; the high-order byte contains a zero.
 *
 * @flag System Message | Is a multiple of two DWORDs. The first DWORD contains
 * time information that specifies the amount of time to wait between the
 * previous event and the event being described. Time units are based on the
 * time-division header in the MIDI file.
 *
 * The second DWORD contains the length of the system-message data (SysEx) in
 * the 24 least-significant bits of the DWORD; the high-order bit contains
 * a one.
 *
 * Remaining DWORDs in the system message contain SysEx data.
 *
 * @flag End-of-Buffer | Is two DWORDs, each with the value -1. This entry
 * indicates the end of data in the poly-message buffer. This message is not passed
 * to MIDI devices.
 *
 * @comm This function cannot be called at interrupt time.
 *
 * @xref <f midiOutLongMsg> <f midiOutPrepareHeader>
 ****************************************************************************/

#define ERROR_EXIT(x)                   \
{                                       \
    uRet = (x);                        \
    goto CLEANUP;                      \
}

#define SKIP_BYTES(x,s)                 \
{                                       \
    if (dwLength < (x))                 \
    {                                   \
        dprintf1(( "!midiOutPolyMsg: ran off end of polymsg buffer in parse!\r\n%ls\r\nOffset %lu", (LPSTR)(s), (DWORD)(((LPBYTE)lpdwBuffer) - lpMidiHdr->lpData))); \
        uRet = MMSYSERR_INVALPARAM;    \
        goto CLEANUP;                  \
    }                                   \
    ((LPBYTE)lpdwBuffer) += (x);       \
    dwLength -= (x);                   \
}

MMRESULT FAR PASCAL mseOutSend(
    PMIDIEMU        pme,
    LPMIDIHDR       lpMidiHdr,
    UINT            cbMidiHdr)
{
    UINT            uRet = MMSYSERR_NOERROR;
    UINT            idx;
    LPDWORD         lpdwBuffer;
    DWORD           dwLength;
    LPMIDIHDR       lpmhWork;
    LPMIDIHDREXT    lpExt;
    BOOL            fQueueWasEmpty;
    BYTE            bEvent;
    DWORD           dwParm;
    DWORD           dwStreamID;
    HMIDIOUT        hmo;
    DWORD_PTR       dwBase;
    UINT            cNewHeaders;

    dprintf2(( "mseOutSend pme %04X lpmh %08lX", (UINT_PTR)pme, (DWORD_PTR)lpMidiHdr));

    dwBase = lpMidiHdr->reserved;

    if ((lpExt = winmmAlloc(sizeof(MIDIHDREXT))) == NULL)
    {
        dprintf1(( "midiOutPolyMsg: No room for shadow"));
        ERROR_EXIT(MMSYSERR_NOMEM);
    }

    //
    //  This needs to be done ASAP in case we error out.
    //
    lpMidiHdr->reserved = (DWORD_PTR)(lpExt);
    lpMidiHdr->dwReserved[MH_BUFIDX] = 0;

    lpExt->nHeaders = 0;
    lpExt->lpmidihdr = (LPMIDIHDR)(lpExt+1);

    //
    //  Parse the poly msg buffer and see if there are any long msgs.
    //  If there are, allocate MIDIHDR's for them on the end of the
    //  main MIDIHDR extension and fill them in and prepare them.
    //
    lpdwBuffer = (LPDWORD)lpMidiHdr->lpData;
    dwLength = lpMidiHdr->dwBytesRecorded;

    while (dwLength)
    {
        //
        //  Skip over the delta time stamp
        //
        SKIP_BYTES(sizeof(DWORD), "d-time");
        dwStreamID = *lpdwBuffer;
        SKIP_BYTES(sizeof(DWORD), "stream-id");

        //
        // Extract the event type and parameter and skip the event DWORD
        //
        bEvent = MEVT_EVENTTYPE(*lpdwBuffer) & (BYTE)~(MEVT_F_CALLBACK >> 24);
        dwParm = MEVT_EVENTPARM(*lpdwBuffer);
        SKIP_BYTES(sizeof(DWORD), "event");

        if (bEvent == MEVT_LONGMSG)
        {
            LPMIDIHDREXT    lpExtRealloc;

            if (dwParm > dwLength)
            {
                dprintf1(( "parse: I don't like stuff that sucks!"));
                ERROR_EXIT(MMSYSERR_INVALPARAM);
            }

            cNewHeaders = 1;
            if (dwStreamID == (DWORD)-1L)
                cNewHeaders = pme->chMidi;

            lpExt->nHeaders += cNewHeaders;

            if ((lpExtRealloc = (LPMIDIHDREXT)HeapReAlloc(hHeap,
                                HEAP_ZERO_MEMORY, lpExt,
                                sizeof(MIDIHDREXT)+sizeof(MIDIHDR)*lpExt->nHeaders))
                                     == NULL)
            {
                lpExt->nHeaders -= cNewHeaders;
                ERROR_EXIT(MMSYSERR_NOMEM);
            }

            lpExt = lpExtRealloc;
            lpMidiHdr->reserved = (DWORD_PTR)(lpExt);

            lpmhWork = ((LPMIDIHDR)(lpExt+1)) + lpExt->nHeaders - cNewHeaders;

            while (cNewHeaders--)
            {
                lpmhWork->lpData          = (LPSTR)lpdwBuffer;
                lpmhWork->dwBufferLength  = dwParm;
                lpmhWork->dwBytesRecorded = 0;
                lpmhWork->dwUser          = 0;
                lpmhWork->dwFlags         =
                    (lpMidiHdr->dwFlags & MHDR_MAPPED) | MHDR_SHADOWHDR;

                if (dwStreamID == (DWORD)-1L)
                    lpmhWork->dwReserved[MH_STREAM] = cNewHeaders;
                else
                    lpmhWork->dwReserved[MH_STREAM] = dwStreamID;

                lpmhWork->dwReserved[MH_STRMPME] = (DWORD_PTR)pme;
                ++lpmhWork;
            }
            dwParm = (dwParm+3)&~3;
            SKIP_BYTES(dwParm, "longmsg parm");
        }
        else
        {
            //
            // Skip any additional paramters for other length-class messages
            //
            if (bEvent & (MEVT_F_LONG >> 24))
            {
                dwParm  = (dwParm+3)&~3;
//                    dprintf1(( "Length [%lu] rounded [%lu]", dwParm, (dwParm+3)&~3));
                SKIP_BYTES(dwParm, "generic long event data");
            }
        }
    }

    // Now prepare any headers we allocated
    //
    lpmhWork = (LPMIDIHDR)(lpExt+1);
    for (idx = 0; idx < lpExt->nHeaders; idx++, lpmhWork++)
    {
        hmo = (HMIDIOUT)mseIDtoHMidi(pme, (DWORD)lpmhWork->dwReserved[MH_STREAM]);
        if (NULL != hmo)
        {
            if ((uRet = midiOutPrepareHeader(hmo,
                                         lpmhWork,
                                         sizeof(MIDIHDR))) != MMSYSERR_NOERROR)
            {
                dprintf1(( "parse: pre-prepare of embedded long msg failed! (%lu)", (DWORD)uRet));
                ERROR_EXIT(uRet);
            }
        }
    }

    //
    //  Reset lpExt->lpmidihdr to the next header to play
    //
    lpExt->lpmidihdr = (LPMIDIHDR)(lpExt+1);

    //
    //  Prepare to update handle information to contain this header
    //
    PDEVLOCK( pme );

    //
    //  Shove the block in the queue, noting if it was empty
    //

    fQueueWasEmpty = FALSE;
    if (pme->lpmhRear == NULL)
    {
        fQueueWasEmpty = TRUE;
        pme->lpmhRear = pme->lpmhFront = lpMidiHdr;
    }
    else
    {
        pme->lpmhRear->lpNext = lpMidiHdr;
        pme->lpmhRear = lpMidiHdr;
    }

    lpMidiHdr->lpNext = NULL;
    lpMidiHdr->dwFlags |= MHDR_INQUEUE;

    PDEVUNLOCK( pme );

    if (pme->dwPolyMsgState == PM_STATE_PAUSED)
    {
        if (fQueueWasEmpty)
            pme->dwSavedState = PM_STATE_READY;
    }
    else
    {
        if (fQueueWasEmpty)
        {
            // We want to schedule this now. If the there's no timer
            // or we can kill the current one, send. If we can't kill the
            // pending timer, it's in the process of being scheduled anyway
            //
            if (guMIDITimerID == TIMER_OFF ||
                MMSYSERR_NOERROR == timeKillEvent(guMIDITimerID))
            {
                guMIDITimerID = TIMER_OFF;
                pme->dwPolyMsgState = PM_STATE_READY;

                dprintf2(( "mseSend take -- about to mot"));

                midiOutTimerTick(
                             guMIDITimerID,    // ID of our timer
                             0,                // wMsg is unused
                             timeGetTime(),    // dwUser unused
                             0L,               // dw1 unused
                             0L);              // dw2 unused

                dprintf2(( "mseSend mot"));
            }
        }
    }


CLEANUP:
    if (uRet != MMSYSERR_NOERROR)
    {
        if (lpExt != NULL)
        {
            lpMidiHdr = (LPMIDIHDR)(lpExt+1);
            while (lpExt->nHeaders--)
            {
                hmo = (HMIDIOUT)mseIDtoHMidi(pme, (DWORD)lpMidiHdr->dwReserved[MH_STREAM]);
#ifdef DEBUG
                if (NULL == hmo)
                    dprintf1(( "stream-id disappeared during cleanup!!!"));
#endif
                midiOutUnprepareHeader(hmo, lpMidiHdr++, sizeof(MIDIHDR));
            }

            winmmFree(lpExt);
        }
    }

    return uRet;

} /* midiOutPolyMsg() */

/**  void FAR PASCAL midiOutSetClockRate(PMIDIEMU pme, TICKS tkWhen)
 *
 *  DESCRIPTION:
 *
 *      This function is called whenever the clock rate for the stream
 *      needs to be changed.
 *
 *  ARGUMENTS:
 *      (PMIDIEMU pme, TICKS tkWhen)
 *
 *      pme indicates the handle to change the clock rate of.
 *
 *      tkWhen is the absolute tick time at which the time change occurs.
 *
 ** jfg */


void FAR PASCAL midiOutSetClockRate(
    PMIDIEMU        pme,
    TICKS           tkWhen)
{
    DWORD           dwNum;
    DWORD           dwDenom;


    if (pme->dwTimeDiv&IS_SMPTE)
    {
        switch(-SMPTE_FORMAT(pme->dwTimeDiv))
        {
            case SMPTE_24:
            dwNum = 24L;
            dwDenom = 1L;
            break;

            case SMPTE_25:
            dwNum = 25L;
            dwDenom = 1L;
            break;

            case SMPTE_30DROP:
            case SMPTE_30:
            //
            // Actual frame rate for 30 fps (color television) is
            // 29.97 fps.
            //
            dwNum = 2997L;
            dwDenom = 100L;
            break;

            default:
            dprintf1(( "Invalid SMPTE frames/sec in midiOutSetClockRate! (using 30)"));
            dwNum = 2997L;
            dwDenom = 100L;
            break;
        }

        dwNum   *= (DWORD)TICKS_PER_FRAME(pme->dwTimeDiv);
        dwDenom *= 1000L;
    }
    else
    {
        dwNum   = 1000L * TICKS_PER_QN(pme->dwTimeDiv);
        dwDenom = pme->dwTempo;
    }

    clockSetRate(&pme->clock, tkWhen, dwNum, dwDenom);
}

/** BOOL NEAR PASCAL midiOutScheduleNextEvent(PMIDIEMU pme)
 *
 *  DESCRIPTION:
 *
 *      Determine when (in ticks defined for this device) the next event
 *      is due.
 *
 *  ARGUMENTS:
 *      (PMIDIEMU pme)
 *
 *  RETURN (BOOL):
 *
 *      TRUE if there was an event in this buffer to schedule.
 *
 *  NOTES:
 *
 *      Just calculate how many ticks till next event and store in the
 *      device struct.
 *
 *      This function does NOT schedule across buffers; caller must
 *      link to next buffer if needed.
 *
 ** jfg */

BOOL NEAR PASCAL midiOutScheduleNextEvent(
    PMIDIEMU        pme)
{
    LPMIDIHDR       lpmhdr;
    LPBYTE          lpb;
    DWORD           tkDelta;

    if ((lpmhdr = pme->lpmhFront) == NULL ||
         lpmhdr->dwReserved[MH_BUFIDX] == lpmhdr->dwBytesRecorded)
    {
        pme->dwPolyMsgState = PM_STATE_EMPTY;
        return FALSE;
    }

    lpb = (LPBYTE)lpmhdr->lpData;
    tkDelta = *(LPDWORD)(lpb+lpmhdr->dwReserved[MH_BUFIDX]);

    pme->tkNextEventDue = pme->tkPlayed + tkDelta;
    pme->dwPolyMsgState = PM_STATE_READY;

    return TRUE;
} /* ScheduleNextEvent() */


/** void NEAR PASCAL midiOutPlayNextPolyEvent(PMIDIEMU pme)
 *
 *  DESCRIPTION:
 *
 *      Play the next event if there is one. Current buffer must
 *      be pointing at an event (*NOT* end-of-buffer).
 *
 *      - Plays all events which are due
 *
 *      - Schedules next event
 *
 *  ARGUMENTS:
 *      (PMIDIEMU pme)
 *
 *  NOTES:
 *
 *      First, play the event. If it's a short msg, just do it.
 *      If it's a SysEx, pull the appropriate (already prepared)
 *      header from the extension block and send it. Mark the state
 *      of the device as blocked so nothing else will be played
 *      until the SysEx is done.
 *
 *      Update dwReserved[MH_BUFIDX] to point at the next event.
 *
 *      Determine the next event and schedule it, crossing to the
 *      next buffer if needed. If the next event is already due
 *      (i.e. had a delta-time of zero), stick around and send that,
 *      too.
 *
 *
 *
 ** jfg */

void NEAR PASCAL midiOutPlayNextPolyEvent(
    PMIDIEMU        pme
#ifdef DEBUG
   ,DWORD           dwStartTime
#endif
)
{
    LPBYTE          lpb;
    LPMIDIHDR       lpmhdr;
    DWORD           dwMsg;
    LPMIDIHDREXT    lpExt;
    MMRESULT        mmrError;
    DWORD           tkDelta;
    BYTE            bEvent;
    DWORD           dwOffset;
    DWORD           dwStreamID;
    HMIDIOUT        hmo;
    UINT            cToSend;

#if 0
    if (NULL != pme->lpmhFront)
    {
        lpb = (LPBYTE)(pme->lpmhFront->lpData);
        _asm
        {
            mov     ax, word ptr lpb
            mov     dx, word ptr lpb+2
            int     3
        }
    }
#endif

    while (pme->dwPolyMsgState == PM_STATE_READY)
    {
        for(;;)
        {
            lpmhdr = pme->lpmhFront;
            if (!lpmhdr)
                return;

            // Make sure next buffer contains valid data and skip if it
            // doesn't
            //
            if (midiOutScheduleNextEvent(pme))
                break;

            // That buffer is done or empty
            //
            midiOutDequeueAndCallback(pme);
        }

        lpb = lpmhdr->lpData;
        tkDelta = *(LPDWORD)(lpb+lpmhdr->dwReserved[MH_BUFIDX]);

//        dprintf2(( "dwReserved[MH_BUFIDX] %lu tkDelta %lu", lpmhdr->dwReserved[0], tkDelta));

        pme->tkNextEventDue = pme->tkPlayed + tkDelta;
        if (pme->tkNextEventDue > pme->tkTime)
        {
            return;
        }

        //
        // There is an event pending and it's due; send it and update pointers
        //
        dwOffset = (DWORD)lpmhdr->dwReserved[MH_BUFIDX];

        pme->tkPlayed += tkDelta;

        // Skip tkDelta and stream-id
        //

        lpmhdr->dwReserved[MH_BUFIDX] += sizeof(DWORD);
        dwStreamID = *(LPDWORD)(lpb+lpmhdr->dwReserved[MH_BUFIDX]);
        lpmhdr->dwReserved[MH_BUFIDX] += sizeof(DWORD);

        // Will be NULL if dwStreamID == -1 (all IDs)
        //
        hmo = (HMIDIOUT)mseIDtoHMidi(pme, dwStreamID);

        //
        // Extract event type and parms and update past event
        //
        dwMsg  = *(LPDWORD)(lpb+lpmhdr->dwReserved[MH_BUFIDX]);
        bEvent = MEVT_EVENTTYPE(dwMsg);
        dwMsg  = MEVT_EVENTPARM(dwMsg);

        lpmhdr->dwReserved[MH_BUFIDX] += sizeof(DWORD);

        if (hmo && (bEvent & (MEVT_F_CALLBACK >> 24)))
        {
            lpmhdr->dwOffset = dwOffset;
            DriverCallback(
            pme->dwCallback,
            HIWORD(pme->dwFlags),
            (HDRVR)pme->hStream,
            MM_MOM_POSITIONCB,
            pme->dwInstance,
            (DWORD_PTR)lpmhdr,
            0L);

        }

        bEvent &= ~(MEVT_F_CALLBACK >> 24);

        switch(bEvent)
        {
            case MEVT_SHORTMSG:
            {
                BYTE    bEventType;
                BYTE    bNote;
                BYTE    bVelocity;
                LPBYTE  pbEntry = pme->rbNoteOn;

                if (NULL == hmo)
                {
                    dprintf1(( "Event skipped - not ours"));
                    break;
                }

                //
                // If we're sending a note on or note off, track note-on
                // count.
                //
                bEventType = (BYTE)(dwMsg&0xFF);

                if (!(bEventType & 0x80))
                {
                    bEventType = pme->bRunningStatus;
                    bNote     = (BYTE)(dwMsg&0xFF);
                    bVelocity = (BYTE)((dwMsg >> 8)&0xFF);

                    // ALWAYS expand running status - individual dev's can't
                    // track running status of entire stream.
                    //
                    dwMsg = (dwMsg << 8) | (DWORD)(bEventType);
                }
                else
                {
                    pme->bRunningStatus = bEventType;
                    bNote     = (BYTE)((dwMsg >> 8)&0xFF);
                    bVelocity = (BYTE)((dwMsg >> 16)&0xFF);
                }

                if ((bEventType&0xF0) == MIDI_NOTEON ||
                    (bEventType&0xF0) == MIDI_NOTEOFF)
                {
                    BYTE bChannel = (bEventType & 0x0F);
                    UINT cbOffset = (bChannel * NUM_NOTES + bNote) / 2;

                    //
                    // Note-on with a velocity of 0 == note off
                    //
                    if ((bEventType&0xF0) == MIDI_NOTEOFF || bVelocity == 0)
                    {
                        if (bNote&0x01)  // odd
                        {
                            if ((*(pbEntry + cbOffset)&0xF0) != 0)
                                *(pbEntry + cbOffset) -= 0x10;
                        }
                        else //even
                        {
                            if ((*(pbEntry + cbOffset)&0xF) != 0)
                                *(pbEntry + cbOffset) -= 0x01;
                        }
                    }
                    else
                    {
                        if (bNote&0x01)  // odd
                        {
                            if ((*(pbEntry + cbOffset)&0xF0) != 0xF0)
                                *(pbEntry + cbOffset) += 0x10;
                        }
                        else //even
                        {
                            if ((*(pbEntry + cbOffset)&0xF) != 0xF)
                                *(pbEntry + cbOffset) += 0x01;
                        }
                    }

                }

                mmrError = midiOutShortMsg(hmo, dwMsg);
                if (MMSYSERR_NOERROR != mmrError)
                {
                    dprintf(("Short msg returned %08lX!!!", (DWORD)mmrError));
                }
            }
            break;

            case MEVT_TEMPO:
                pme->dwTempo = dwMsg;
                dprintf1(( "dwTempo %lu", pme->dwTempo));
                midiOutSetClockRate((PMIDIEMU)pme, pme->tkPlayed);
            break;

            case MEVT_LONGMSG:
                //
                //  Advance lpmhdr past the message; the header is already
                //  prepared with the proper address and length, so we set
                //  the polymsg header so that it points at the next message
                //  when this long msg completes.
                //
                //  Keep low 24 bits of dwMsg (SysEx length, byte aligned),
                //  round to next DWORD (buffer must be padded to match this),
                //  and skip past dwMsg and the SysEx buffer.
                //
                dwMsg = (dwMsg+3)&~3;

                lpmhdr->dwReserved[MH_BUFIDX] += dwMsg;


                cToSend = 1;
                if (dwStreamID == (DWORD)-1L)
                    cToSend = pme->chMidi;

                lpExt = (LPMIDIHDREXT)lpmhdr->reserved;

                pme->cSentLongMsgs = 0;
                pme->dwPolyMsgState = PM_STATE_BLOCKED;
                pme->fdwDev |= MDV_F_SENDING;

                while (cToSend--)
                {
                    lpmhdr = lpExt->lpmidihdr;
                    ++lpExt->lpmidihdr;

                    hmo = (HMIDIOUT)mseIDtoHMidi(pme,
                                                 (DWORD)lpmhdr->dwReserved[MH_STREAM]);


                    if (hmo) 
                        mmrError = midiOutLongMsg(hmo, lpmhdr, sizeof(MIDIHDR));
                    else
                        dprintf1(( "mseIDtoHMidi() failed and returned a NULL" ));


                    if ((hmo) && (MMSYSERR_NOERROR == mmrError))
                        ++pme->cSentLongMsgs;
                    else
                        dprintf1(( "MODM_LONGDATA returned %u in emulator!",
                                 (UINT)mmrError));
                }

                if (0 == pme->cSentLongMsgs)
                    pme->dwPolyMsgState = PM_STATE_READY;
                pme->fdwDev &= ~MDV_F_SENDING;

            break;

            default:
            //
            // If we didn't understand a length-class message, skip it.
            //
                if (bEvent&(MEVT_F_LONG >> 24))
                {
                    dwMsg = (dwMsg+3)&~3;
                    lpmhdr->dwReserved[MH_BUFIDX] += dwMsg;
                }
            break;
        }

        //
        // Find the next schedulable polyMsg
        //
        while (!midiOutScheduleNextEvent(pme))
        {
            midiOutDequeueAndCallback(pme);
            if (pme->lpmhFront == NULL)
                break;
        }
    }
}

/** void NEAR PASCAL midiOutDequeueAndCallback(PMIDIEMU pme)
 *
 *  DESCRIPTION:
 *
 *      The current polymsg buffer has finished. Pull it off the queue
 *      and do a callback.
 *
 *  ARGUMENTS:
 *      (PMIDIEMU pme)
 *
 *  NOTES:
 *
 ** jfg */

void NEAR PASCAL midiOutDequeueAndCallback(
    PMIDIEMU        pme)
{
    LPMIDIHDR       lpmidihdr;
    BOOL            fPosted;

        dprintf2(( "DQ"));
    //
    //  A polymsg buffer has finished. Pull it off the queue and
    //  call back the app.
    //
    if ((lpmidihdr = pme->lpmhFront) == NULL)
        return;

    if ((pme->lpmhFront = lpmidihdr->lpNext) == NULL)
    {
        dprintf2(( "DQ/CB -- last buffer"));
        pme->lpmhRear = NULL;
    }

    //
    // Can't be at interrupt callback time to unprepare possible
    // embedded long messages in this thing. The notify window's
    // wndproc will call midiOutNukePMBuffer to clean up.
    //
    dprintf2(( "!DQ/CB %08lX", (DWORD_PTR)lpmidihdr));

    ++pme->cPostedBuffers;
    fPosted = PostMessage(
                hwndNotify,
                MM_POLYMSGBUFRDONE,
                (WPARAM)pme,
                (DWORD_PTR)lpmidihdr);

    WinAssert(fPosted);

    if (!fPosted)
    {
        GetLastError();
        --pme->cPostedBuffers;
    }
}

void FAR PASCAL midiOutNukePMBuffer(
    PMIDIEMU        pme,
    LPMIDIHDR       lpmh)
{
    LPMIDIHDREXT    lpExt;
    LPMIDIHDR       lpmhWork;
    MMRESULT        mmrc;
    HMIDIOUT        hmo;

    dprintf2(( "Nuke %08lX", (DWORD_PTR)lpmh));

    //
    // Unprepare internal stuff and do user callback
    //
    lpExt    = (LPMIDIHDREXT)(lpmh->reserved);
    lpmhWork = (LPMIDIHDR)(lpExt+1);

    while (lpExt->nHeaders--)
    {
        if ((lpmhWork->dwFlags&MHDR_PREPARED) &&
           (!(lpmhWork->dwFlags&MHDR_INQUEUE)))
        {
            hmo = (HMIDIOUT)mseIDtoHMidi(pme, (DWORD)lpmhWork->dwReserved[MH_STREAM]);
            mmrc = midiOutUnprepareHeader(hmo, lpmhWork, sizeof(*lpmhWork));
#ifdef DEBUG
            if (MMSYSERR_NOERROR != mmrc)
            {
                dprintf1(( "midiOutNukePMBuffer: Could not unprepare! (%lu)", (DWORD)mmrc));
            }
#endif
        }
        else
        {
            dprintf1(( "midiOutNukePMBuffer: Emulation header flags bogus!!!"));
        }

        lpmhWork++;
    }

    winmmFree(lpExt);
    lpmh->reserved = 0L;

    lpmh->dwFlags &= ~MHDR_INQUEUE;
    lpmh->dwFlags |= MHDR_DONE;

//    dprintf2(( "Nuke: callback"));

    DriverCallback(
            pme->dwCallback,
            HIWORD(pme->dwFlags),
            (HDRVR)pme->hStream,
            MM_MOM_DONE,
            pme->dwInstance,
            (DWORD_PTR)lpmh,
            0L);
}



/*****************************************************************************
 *
 * @doc INTERNAL MIDI
 *
 * @api void | midiOutTimerTick |
 *  This function handles the timing of polymsg out buffers. One timer instance
 *  is shared by all polymsg out streams. When <f midiOutPolyMsg> is called
 *  and the timer is not running, or <f midiOutTimerTick> finished processing,
 *  the timer is set to go off based on the time until the event with the
 *  shortest time remaining of all events. All timers are one-shot timers.
 *
 * @parm UINT | uTimerID |
 *  The timer ID of the timer that fired.
 *
 * @parm UINT | wMsg |
 *  Unused.
 *
 * @parm DWORD | dwUser |
 *  User instance data for the timer callback (unused).
 *
 * @parm DWORD | dwParam1 |
 *  Unused.
 *
 * @parm DWORD | dwParam2 |
 *  Unused.
 *
 * @comm Determine elapsed microseconds using <f timeGetTime>.
 *
 *  Traverse the list of output handles. Update the tick clock for each handle. If there are
 *  events to do on that handle, start them.
 *
 *  Determine the next event due on any stream. Start another one-shot timer
 *  to call <f midiOutTimerTick> when this interval has expired.
 *
 *****************************************************************************/

STATIC UINT uTimesIn = 0;

void CALLBACK midiOutTimerTick(
    UINT        uTimerID,
    UINT        wMsg,
    DWORD_PTR   dwUser,
    DWORD_PTR   dw1,
    DWORD_PTR   dw2)
{
    PMIDIEMU    pme;
    DWORD       msNextEventMin = (DWORD)-1L;
    DWORD       msNextEvent;
    UINT        uDelay;
#ifdef DEBUG
    DWORD       dwNow = timeGetTime();
#endif

    if (guMIDIInTimer)
    {
        dprintf2(( "midiOutTimerTick() re-entered (%u)", guMIDIInTimer));
        return;
    }

    guMIDIInTimer++;

#ifdef DEBUG
    {
        DWORD dwDelta = dwNow - (DWORD)dwUser;
        if (dwDelta > 1)
            dprintf2(( "Timer event delivered %lu ms late", dwDelta));
    }
#endif

    for (pme = gpEmuList; pme; pme = pme->pNext)
    {
        pme->tkTime = clockTime(&pme->clock);

        //
        // Play all events on this pdev that are due
        //
        if (pme->dwPolyMsgState == PM_STATE_READY)
        {
            //
            //  Lock starts at -1.  When incrementing the lock
            //  if we are the only one with the lock the count
            //  will be 0, otherwise it will be some non-zero
            //  value determined by InterlockedIncrement.
            //
            if (PDEVLOCK( pme ) == 0)

                midiOutPlayNextPolyEvent(pme
#ifdef DEBUG
                                         ,dwNow
#endif
                                         );

            PDEVUNLOCK( pme );
        }

        //
        // If there's still data to play on this stream, figure out when
        // it'll be due so we can schedule the next nearest event.
        //
        if (pme->dwPolyMsgState != PM_STATE_EMPTY)
        {
            //            dprintf1(( "tkNextEventDue %lu pdev->tkTime %lu", pme->tkNextEventDue, pme->tkTime));
            if (pme->tkNextEventDue <= pme->tkTime)
            {
                //
                // This can happen if we send a long embedded SysEx and the
                // next event is scheduled a short time away (comes due before
                // SysEx finishes). In this case, we want the timer to fire
                // again ASAP.
                //
                msNextEvent = 0;
            }
            else
            {
                msNextEvent =
                       clockOffsetTo(&pme->clock, pme->tkNextEventDue);
            }

            if (msNextEvent < msNextEventMin)
            {
                msNextEventMin = msNextEvent;
            }
        }
        else
        {
            dprintf1(( "dwPolyMsgState == PM_STATE_EMPTY"));
        }
    }

    if (0 == msNextEventMin)
    {
        dprintf1(( "midiEmu: Next event due now!!!"));
    }

    --guMIDIInTimer;

    //
    // Schedule the next event. In no case schedule an event less than
    // guMIDIPeriodMin away (no point in coming back w/ no time elapsed).
    //
    if (msNextEventMin != (DWORD)-1L)
    {
        uDelay = max(guMIDIPeriodMin, (UINT)msNextEventMin);

//        dprintf1(("PM Resched %u ms (ID=%u)", uDelay, guMIDITimerID));

        if (!gfMinPeriod)
        {
            timeBeginPeriod(guMIDIPeriodMin);
            gfMinPeriod = TRUE;
        }

#ifdef DEBUG
        guMIDITimerID = timeSetEvent(uDelay, guMIDIPeriodMin, midiOutTimerTick, timeGetTime()+uDelay, TIME_ONESHOT | TIME_KILL_SYNCHRONOUS);
#else
        guMIDITimerID = timeSetEvent(uDelay, guMIDIPeriodMin, midiOutTimerTick, uDelay, TIME_ONESHOT | TIME_KILL_SYNCHRONOUS);
#endif

            dprintf2(( "mOTT tse(%u) = %u", guMIDIPeriodMin, guMIDITimerID));

            if (guMIDITimerID == TIMER_OFF)
                dprintf1(( "timeSetEvent(%u) failed in midiOutTimerTick!!!", uDelay));
        }
        else
        {
            dprintf1(( "Stop in the name of all that which does not suck!"));
            guMIDITimerID = TIMER_OFF;
            if (gfMinPeriod)
            {
                dprintf1(( "timeEndPeriod"));
                gfMinPeriod = FALSE;
                timeEndPeriod(guMIDIPeriodMin);
            }
        }

#ifdef DEBUG
    {
        DWORD dwDelta = timeGetTime() - dwNow;
        if (dwDelta > 1)
            dprintf2(( "Spent %lu ms in midiOutTimerTick", dwDelta));
    }
#endif
} /* TimerTick() */


/*****************************************************************************
 *
 * @doc INTERNAL MIDI
 *
 * @api void | midiOutCallback |
 *  This function is called by the midi output driver whenever an event
 *  completes. It filters long message completions when we are emulating
 *  polymsg out.
 *
 * @parm HMIDIOUT | hMidiOut |
 *  Handle of the device which completed something.
 *
 * @parm UINT | wMsg |
 *  Specifies the event which completed.
 *
 * @parm DWORD | dwInstance |
 *  User instance data for the callback.
 *
 * @parm DWORD | dwParam1 |
 *  Message specific parameter.
 *
 * @parm DWORD | dwParam2 |
 *  Message specific parameter.
 *
 * @comm
 *
 *  If this is a completion for a long message buffer on a stream we are
 *  emulating polymsg out for, mark the stream as ready to play.
 *
 *****************************************************************************/

void CALLBACK midiOutCallback(
    HMIDIOUT    hMidiOut,
    WORD        wMsg,
    DWORD_PTR   dwInstance,
    DWORD_PTR   dwParam1,
    DWORD_PTR   dwParam2)
{
    PMIDIEMU    pme;
    LPMIDIHDR   lpmh;

    if (MM_MOM_DONE != wMsg)
        return;

    lpmh = (LPMIDIHDR)dwParam1;
    pme = (PMIDIEMU)lpmh->dwReserved[MH_STRMPME];

#ifdef DEBUG
    if (lpmh->dwFlags & MHDR_ISSTRM)
        dprintf1(( "Uh-oh, got stream header back from 3.1 driver???"));
#endif

    if (MM_MOM_DONE == wMsg)
    {
        if (0 == --pme->cSentLongMsgs &&
            !(pme->fdwDev & MDV_F_SENDING))
            pme->dwPolyMsgState = PM_STATE_READY;
    }

}

/*****************************************************************************
 * @doc INTERNAL  MIDI
 *
 * @api void | midiOutAllNotesOff | This function turns off all notes
 *   by using the map kept in polymsg emulation. It only works if we're
 *   opened with MIDI_IO_COOKED and are emulating on that device.
 *
 * @parm PMIDIEMU | pme | The device to turn off notes on.
 *
 * @xref midiOutPause midiOutStop
 ****************************************************************************/
void NEAR PASCAL midiOutAllNotesOff(
    PMIDIEMU        pme)
{
    UINT            uChannel;
    UINT            uNote;
    BYTE            bCount;
    DWORD           dwMsg;
    UINT            idx;
    LPBYTE          pbEntry = pme->rbNoteOn;

    for (uChannel=0; uChannel < NUM_CHANNELS; uChannel++)
    {
        // Turn off any sustained notes so the note off won't be ignored
        //
        dwMsg = ((DWORD)MIDI_CONTROLCHANGE) |
            ((DWORD)uChannel)|
            (((DWORD)MIDI_SUSTAIN)<<8);

        for (idx = 0; idx < pme->chMidi; idx++)
            midiOutShortMsg((HMIDIOUT)pme->rIds[idx].hMidi, dwMsg);

        for (uNote=0; uNote < NUM_NOTES; uNote++)
        {
            if (uNote&0x01)  // odd
            {
                bCount = (*(pbEntry + (uChannel * NUM_NOTES + uNote)/2) & 0xF0)>>4;
            }
            else  // even
            {
                bCount = *(pbEntry + (uChannel * NUM_NOTES + uNote)/2) & 0xF;
            }

            if (bCount != 0)
            {
                //
                // Message is Note off on this channel and note
                // with a turn off velocity of 127
                //
                dwMsg =
                    ((DWORD)MIDI_NOTEOFF)|
                    ((DWORD)uChannel)|
                    ((DWORD)(uNote<<8))|
                    0x007F0000L;

                dprintf1(( "mOANO: dwMsg %08lX count %u", dwMsg, (UINT)bCount));

                while (bCount--)
                {
                    for (idx = 0; idx < pme->chMidi; idx++)
                        midiOutShortMsg((HMIDIOUT)pme->rIds[idx].hMidi, dwMsg);
                }
            }
        }
    }
}


MMRESULT FAR PASCAL mseOutCachePatches(
    PMIDIEMU        pme,
    UINT            uBank,
    LPWORD          pwpa,
    UINT            fuCache)
{
    UINT            cmesi;
    PMIDIEMUSID     pmesi;
    MMRESULT        mmrc;
    MMRESULT        mmrc2;

    cmesi = pme->chMidi;
    pmesi = pme->rIds;

    mmrc2 = MMSYSERR_NOERROR;
    while (cmesi--)
    {
        mmrc = midiOutCachePatches((HMIDIOUT)pmesi->hMidi, uBank, pwpa, fuCache);
        if (MMSYSERR_NOERROR != mmrc && MMSYSERR_NOTSUPPORTED != mmrc)
            mmrc2 = mmrc;
    }

    return mmrc2;
}


MMRESULT FAR PASCAL mseOutCacheDrumPatches(
    PMIDIEMU        pme,
    UINT            uPatch,
    LPWORD          pwkya,
    UINT            fuCache)
{
    UINT            cmesi;
    PMIDIEMUSID     pmesi;
    MMRESULT        mmrc;
    MMRESULT        mmrc2;

    cmesi = pme->chMidi;
    pmesi = pme->rIds;

    mmrc2 = MMSYSERR_NOERROR;
    while (cmesi--)
    {
        mmrc = midiOutCacheDrumPatches((HMIDIOUT)pmesi->hMidi, uPatch, pwkya, fuCache);
        if (MMSYSERR_NOERROR != mmrc && MMSYSERR_NOTSUPPORTED != mmrc)
            mmrc2 = mmrc;
    }

    return mmrc2;
}

DWORD FAR PASCAL mseOutBroadcast(
    PMIDIEMU        pme,
    UINT            msg,
    DWORD_PTR       dwParam1,
    DWORD_PTR       dwParam2)
{
    UINT            idx;
    DWORD           dwRet;
    DWORD           dwRetImmed;

    dwRet = 0;
    for (idx = 0; idx < pme->chMidi; idx++)
    {
        dwRetImmed = midiOutMessage((HMIDIOUT)pme->rIds[idx].hMidi, msg, dwParam1, dwParam2);
        if (dwRetImmed)
            dwRet = dwRetImmed;
    }

    return dwRet;
}

DWORD FAR PASCAL mseTimebase(
    PCLOCK                      pclock)
{
    return timeGetTime();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\midistrm.c ===
/*******************************************************************************
*
* Module Name: midistrm.c
*
* MIDI Streams implementation
*
* Created: 9 Feb 1995   SteveDav
*
* Copyright (c) 1995-1999 Microsoft Corporation
*
\******************************************************************************/
#include "winmmi.h"

/*
 * MIDI Streaming API Port: For the time being, the assumption
 * is that the devices are static.  This code was designed to
 * be PnP friendly, with devices coming and going.  The
 * validation of devices will be commented out for now, but in
 * the future when NT is a more dynamic OS, the validation will
 * need to be added back.
 *
 */

extern BOOL CreatehwndNotify(VOID);

CRITICAL_SECTION midiStrmHdrCritSec;


WINMMAPI MMRESULT WINAPI midiDisconnect (
    HMIDI    hmi,
    HMIDIOUT hmo,
    LPVOID   lpv)
{
    dprintf2(("midiDisconnect(%08X,%08X,%08X)", hmi, hmo, lpv));
    return midiInSetThru (hmi, hmo, FALSE);
}

WINMMAPI MMRESULT WINAPI midiConnect (
    HMIDI    hmi,
    HMIDIOUT hmo,
    LPVOID   lpv)
{
    dprintf2(("midiConnect(%08X,%08X,%08X)", hmi, hmo, lpv));
    return midiInSetThru (hmi, hmo, TRUE);
}

/*+ midiInSetThru
 *
 *  Establish a thruing midiOut handle for a midiIn device.  This is
 *  done by first calling the driver to let the driver do the thruing,
 *  if the driver returns UNSUPPORTED a single thruing handle can
 *  be established by simulation in DriverCallback
 *
 *-====================================================================*/

MMRESULT midiInSetThru (
    HMIDI    hmi,
    HMIDIOUT hmo,
    BOOL     bAdd)
{
    MMRESULT mmr = MMSYSERR_ERROR; // this value should never get returned....
    UINT     uType;

    dprintf2(("midiInSetThru(%X,%X,%d)", hmi, hmo, bAdd));

    AcquireHandleListResourceShared();

    // allow first handle to be either midi in or midi out
    // (so that we can send DRVM_ADD_THRU messages to dummy
    // output drivers.)
    //
    // we simulate thruing only for input handles though...
    //
    if (BAD_HANDLE(hmi, TYPE_MIDIIN) && BAD_HANDLE(hmi, TYPE_MIDIOUT))
    {
        ReleaseHandleListResource();
        return MMSYSERR_INVALHANDLE;
    }

    uType = GetHandleType(hmi);
    if (bAdd)
    {
        if (BAD_HANDLE(hmo, TYPE_MIDIOUT))
        {
            ReleaseHandleListResource();
            return (MMSYSERR_INVALHANDLE);
        }

        //      !!! Devices are static on NT for now.
        //
        //if (!mregQueryValidHandle(HtoPT(PMIDIDEV, hmo)->hmd))
        //    return MMSYSERR_NODRIVER;
        mmr = (MMRESULT)midiMessage ((HMIDI)hmi, DRVM_ADD_THRU, (DWORD_PTR)(UINT_PTR)hmo, 0l);
        if (mmr == MMSYSERR_NOTSUPPORTED && uType == TYPE_MIDIIN)
        {
            // dont allow more than one handle to be added
            //
            if (HtoPT(PMIDIDEV, hmi)->pmThru)
                mmr = MIDIERR_NOTREADY;
            else
            {
                // add the handle.
                //
                HtoPT(PMIDIDEV, hmi)->pmThru = HtoPT(PMIDIDEV, hmo);
                mmr = MMSYSERR_NOERROR;
            }
        }
    }
    else
    {
            mmr = (MMRESULT)midiMessage ((HMIDI)hmi, DRVM_REMOVE_THRU, (DWORD_PTR)(UINT_PTR)hmo, 0l);
            if (mmr == MMSYSERR_NOTSUPPORTED && uType == TYPE_MIDIIN)
                mmr = MMSYSERR_NOERROR;

            if ( ! hmo || (PMIDIDEV)hmo == HtoPT(PMIDIDEV, hmi)->pmThru)
                HtoPT(PMIDIDEV, hmi)->pmThru = NULL;
            else
                mmr = MMSYSERR_INVALPARAM;
    }

    return mmr;
}


WINMMAPI MMRESULT WINAPI midiStreamOpen(
    LPHMIDISTRM     phms,
    LPUINT          puDeviceID,
    DWORD           cMidi,
    DWORD_PTR       dwCallback,
    DWORD_PTR       dwInstance,
    DWORD           fdwOpen)
{
    PMIDISTRM       pms             = NULL;
    PMIDISTRMID     pmsi;
    PMIDISTRMID     pmsiSave;
    MIDIOPENDESC*   pmod            = NULL;
    DWORD           cbHandle;
    DWORD           idx;
    MIDIOUTCAPS     moc;
    MMRESULT        mmrc            = MMSYSERR_NOERROR;
    MMRESULT        mmrc2;
    UINT            msg;

    V_WPOINTER((LPVOID)phms, sizeof(HMIDISTRM), MMSYSERR_INVALPARAM);
    V_DCALLBACK(dwCallback, HIWORD(fdwOpen), MMSYSERR_INVALPARAM);

    *phms = NULL;

    // Allocate both the handle and the OPENDESC structure.
    //
    // NOTE: Using cMidi-1 because rgIds is defined as having 1 element
    //
    cbHandle = sizeof(MIDISTRM) + cMidi * ELESIZE(MIDISTRM, rgIds[0]);
    if ((0 == cMidi) || (cbHandle >= 0x00010000L))
        return MMSYSERR_INVALPARAM;

    pms = HtoPT(PMIDISTRM, NewHandle(TYPE_MIDISTRM, NULL, (UINT)cbHandle));
    if (NULL == pms)
    {
        dprintf1(("mSO: NewHandle() failed!"));
        return MMSYSERR_NOMEM;
    }

    //  Implicitly acquired with NewHandle()...
    ReleaseHandleListResource();

    pmod = (MIDIOPENDESC*)LocalAlloc(LPTR,
           (UINT)(sizeof(MIDIOPENDESC) + (cMidi-1) * ELESIZE(MIDIOPENDESC, rgIds[0])));
    if (NULL == pmod)
    {
        dprintf1(("mSO: !LocalAlloc(MIDIOPENDESC)"));
        mmrc = MMSYSERR_NOMEM;
        goto midiStreamOpen_Cleanup;
    }

    pms->fdwOpen = fdwOpen;
    pms->dwCallback = dwCallback;
    pms->dwInstance = dwInstance;
    pms->cIds = cMidi;


    // Scan through the given device ID's. Determine if the underlying
    // driver supports stream directly. If so, then get it's HMD and uDeviceID,
    // etc. Else flag this as an emulator ID.
    //
    pmsi = pms->rgIds;
    for (idx = 0; idx < cMidi; idx++, pmsi++)
    {
        dprintf1(("mSO: pmsi->fdwId %08lX", (DWORD)pmsi->fdwId));

        mmrc = midiOutGetDevCaps(puDeviceID[idx], &moc, sizeof(moc));
        if (MMSYSERR_NOERROR != mmrc)
        {
            puDeviceID[idx] = (UINT)MIDISTRM_ERROR;
            goto midiStreamOpen_Cleanup;
        }

        if (moc.dwSupport & MIDICAPS_STREAM)
        {
            // Find the driver supporting the device ID.  Note that mregFindDevice implicitly
            // adds a referance (usage) to the driver (i.e. the hmd).
            dprintf1(("mSO: Dev %u MIDICAPS_STREAM! dwSupport %08lX", (UINT)idx, moc.dwSupport));
            mmrc = mregFindDevice(puDeviceID[idx], TYPE_MIDIOUT, &pmsi->hmd, &pmsi->uDevice);
            if (MMSYSERR_NOERROR != mmrc)
            {
                dprintf(("mregFindDevice barfed %u", (UINT)mmrc));
                puDeviceID[idx] = (UINT)MIDISTRM_ERROR;
                goto midiStreamOpen_Cleanup;
            }
            else
            {
                dprintf1(("mregFindDevice: hmd %04X", (UINT_PTR)pmsi->hmd));
            }
        }
        else
        {
            dprintf1(("mSO: Dev %u emulated.", (UINT)idx));

            pmsi->fdwId |= MSI_F_EMULATOR;
            pmsi->hmd = NULL;
            pmsi->uDevice = puDeviceID[idx];
        }
    }

    // At this point, the puDeviceID array's elements contain either device    |
    // IDs or the error value MIDISTRM_ERROR.  Also the pmsi array elements
    // corresponding to device IDs supporting MIDICAPS_STREAM will have a
    // non-NULL pmsi->hmd with a reference count (usage) on it.  pmsi->uDevice
    // will be a driver-relative device ID.  Other pmsi elements will have a
    // NULL pmsi->hmd and pmsi->fdwId will have MSI_F_EMULATOR set.
    // pmsi->uDevice will be a midiOut device ID (not a driver relative ID).

    // Scan through the list again, but this time actually open the devices.
    //
    pmod->hMidi = PTtoH(HMIDI, pms);
    pmod->dwCallback = (DWORD_PTR)midiOutStreamCallback;
    pmod->dwInstance = 0;

    msg = MODM_OPEN;
    pms->cDrvrs = 0;
    for(;;)
    {
    	//
    	// Set pmsiSave to identify the first unopened device. Break loop
    	// if all are opened.
    	//
        pmsiSave = NULL;
        pmsi = pms->rgIds;
        for (idx = 0; idx < cMidi; idx++, pmsi++)
        {
            if (!(pmsi->fdwId & MSI_F_OPENED))
            {
                pmsiSave = pmsi;
                break;
            }
        }

        if (NULL == pmsiSave)
            break;

        //
        // Group together all IDs implemented by the same driver
        //
        pmod->cIds = 0;
        for(; idx < cMidi; idx++, pmsi++)
        {
            if (pmsi->hmd == pmsiSave->hmd)
            {
                pmod->rgIds[pmod->cIds].uDeviceID = pmsi->uDevice;
                pmod->rgIds[pmod->cIds++].dwStreamID = idx;
            }
        }

        pmsiSave->fdwId |= MSI_F_FIRST;

        //
        // Open the driver
        //
        if (!(pmsiSave->fdwId & MSI_F_EMULATOR))
        {
            pmsiSave->drvMessage = HtoPT(PMMDRV, pmsiSave->hmd)->drvMessage;
//          pmsiSave->dnDevNode  = pmod->dnDevNode = mregQueryDevNode(pmsiSave->hmd);

            mmrc = (MMRESULT)((*pmsiSave->drvMessage)(
                    0,
                    msg,
                    (DWORD_PTR)(LPDWORD)&pmsiSave->dwDrvUser,
                    (DWORD_PTR)(LPMIDIOPENDESC)pmod,
                    CALLBACK_FUNCTION|MIDI_IO_COOKED));

            if (MMSYSERR_NOERROR == mmrc)
            {
                mregIncUsage(pmsiSave->hmd);
            }
        }
        else
        {
            mmrc = (MMRESULT)mseMessage(msg,
                                    (DWORD_PTR)(LPDWORD)&pmsiSave->dwDrvUser,
                                    (DWORD_PTR)(LPMIDIOPENDESC)pmod,
                                    CALLBACK_FUNCTION);
        }

        if (MMSYSERR_NOERROR != mmrc)
        {
            idx = (DWORD)(pmsiSave - pms->rgIds);
            puDeviceID[idx] = (UINT)MIDISTRM_ERROR;
            goto midiStreamOpen_Cleanup;
        }

        //
        // Now flag all IDs implemented by the same driver as MSI_F_OPENED
        //

        ++pms->cDrvrs;
        pmsi = pms->rgIds;
        for (idx = 0; idx < cMidi; idx++, pmsi++)
        {
            if (pmsi->hmd == pmsiSave->hmd)
            {
                pmsi->fdwId |= MSI_F_OPENED;
                if (!(pmsiSave->fdwId & MSI_F_EMULATOR))
                {
                    if (mmInitializeCriticalSection(&pmsi->CritSec))
                    {
                        pmsi->fdwId |= MSI_F_INITIALIZEDCRITICALSECTION;
                    } else {
                        mmrc = MMSYSERR_NOMEM;
                    }
                }
            }
        }
    }


    if (MMSYSERR_NOERROR == mmrc && !CreatehwndNotify())
    {
        dprintf(("Cannot create hwndNotify for async messages!"));
        mmrc = MMSYSERR_ERROR;
    }

    dprintf2(("midiStreamOpen: HMIDISTRM %04X", (WORD)pms));

midiStreamOpen_Cleanup:
    if (NULL != pmod) LocalFree((HLOCAL)pmod);

    //
    // If there was an error, close any drivers we opened and free resources
    // associated with them.  Note do not free pms yet here, as we need it in
    // additional cleanup further below.
    //
    if (MMSYSERR_NOERROR != mmrc)
    {
        if (NULL != pms)
        {
            msg = MODM_CLOSE;

            pmsi = pms->rgIds;
            for (idx = 0; idx < pms->cIds; idx++, pmsi++)
            {
                if ((pmsi->fdwId & (MSI_F_OPENED|MSI_F_FIRST)) == (MSI_F_OPENED|MSI_F_FIRST))
                {
                    mmrc2 = (MMRESULT)midiStreamMessage(pmsi, msg, 0L, 0L);

                    if (MMSYSERR_NOERROR == mmrc2 &&
                        !(pmsi->fdwId & MSI_F_EMULATOR))
                    {
                        if (pmsi->fdwId & MSI_F_INITIALIZEDCRITICALSECTION) {
                            DeleteCriticalSection(&pmsi->CritSec);
                            pmsi->fdwId &= ~MSI_F_INITIALIZEDCRITICALSECTION;
                        }
                        mregDecUsage(pmsi->hmd);
                    }
                    else
                    {
                        dprintf1(("midiStreamOpen_Cleanup: Close returned %u", mmrc2));
                    }
                }
            }

        }
    }
    else
    {
        *phms = PTtoH(HMIDISTRM, pms);

        msg = MM_MOM_OPEN;
        DriverCallback(pms->dwCallback,
                   HIWORD(pms->fdwOpen),
                   (HDRVR)PTtoH(HMIDISTRM, pms),
                   msg,
                   pms->dwInstance,
                   0,
                   0);
    }

    //
    // Now release driver references added by mregFindDevice.  Those that are
    // actually still in use have had an extra reference added and thus will
    // still have a reference count on them even after the release done here.
    //
    if (pms)
    {
    	pmsi = pms->rgIds;
    	for (pmsi = pms->rgIds, idx = 0;
    	     idx < pms->cIds;
    	     idx++, pmsi++)
    	{
    	    if (pmsi->hmd) mregDecUsage(pmsi->hmd);
    	}
    }

    //
    // Free pms if there was an error
    //
    if ((MMSYSERR_NOERROR != mmrc) && (pms)) FreeHandle((PTtoH(HMIDI, pms)));

    return mmrc;
}

WINMMAPI MMRESULT WINAPI midiStreamClose(
    HMIDISTRM       hms)
{
    PMIDISTRM       pms;
    PMIDISTRMID     pmsi;
    DWORD           idx;
    MMRESULT        mmrc;

    V_HANDLE(hms, TYPE_MIDISTRM, MMSYSERR_INVALHANDLE);

    dprintf1(("midiStreamClose(%04X)", (WORD)hms));

    pms = HtoPT(PMIDISTRM, hms);

    pmsi = pms->rgIds;
    for (idx = 0; idx < pms->cIds; idx++, pmsi++)
    {
        if ((pmsi->fdwId & (MSI_F_OPENED|MSI_F_FIRST)) == (MSI_F_OPENED|MSI_F_FIRST))
        {
            mmrc = (MMRESULT)midiStreamMessage(pmsi, MODM_CLOSE, 0L, 0L);

            if (MMSYSERR_NOERROR == mmrc &&
                !(pmsi->fdwId & MSI_F_EMULATOR))
            {
                WinAssert(pmsi->fdwId & MSI_F_INITIALIZEDCRITICALSECTION);
                DeleteCriticalSection(&pmsi->CritSec);
                pmsi->fdwId &= ~MSI_F_INITIALIZEDCRITICALSECTION;
                mregDecUsage(pmsi->hmd);
            }
            else
            {
                dprintf1(("midiStreamClose: Close returned %u", mmrc));
            }
        }
    }

    dprintf1(("DriverCallback(%04X)", (WORD)hms));
    DriverCallback(pms->dwCallback,
           HIWORD(pms->fdwOpen),
           (HDRVR)hms,
           MM_MOM_CLOSE,
           pms->dwInstance,
           0,
           0);

    dprintf1(("FreeHandle(%04X)", (WORD)hms));
    FreeHandle(hms);

    return MMSYSERR_NOERROR;
}


/****************************************************************************
 * @doc EXTERNAL MIDI M5
 *
 * @func MMRESULT | midiStreamProperty | Sets or retrieves properties
 *  of a MIDI data stream associated with a MIDI input or output device.
 *
 * @parm HMIDI | hm | Specifies the handle of the MIDI device that the
 *  property is associated with.
 *
 * @parm LPBYTE | lppropdata | Specifies a pointer to the property data.
 *
 * @parm DWORD | dwProperty | Contains flags that specify the action
 *  to perform and identify the appropriate property of the MIDI data stream.
 *  <f midiStreamProperty> requires setting two flags in each use. One flag
 *  (either MIDIPROP_GET or MIDIPROP_SET) specifies an action. The other
 *  identifies a specific property to examine or edit.
 *
 *  @flag MIDIPROP_SET | Set the given property.
 *  @flag MIDIPROP_GET | Retrieve the current setting of the given property.
 *  @flag MIDIPROP_TIMEDIV | Time division property.
 *   This property is valid for both input and output devices. <p lppropdata>
 *   points to a <t MIDIPROPTIMEDIV> structure. This property can be set only
 *   when the device is stopped.
 *
 *  @flag MIDIPROP_TEMPO | Tempo property.
 *   This property is valid for both input and output devices. <p lppropdata>
 *   points to a <t MIDIPROPTEMPO> structure. The current tempo value can be
 *   retrieved at any time. This function can set the tempo for input devices.
 *   Output devices set the tempo by inserting PMSG_TEMPO events into the
 *   MIDI data.
 *
 *  @flag MIDIPROP_CBTIMEOUT | Timeout value property.
 *   This property specifies the timeout value for loading buffers when a
 *   MIDI device is in MIDI_IO_COOKED and MIDI_IO_RAW modes. The current
 *   timeout value sets the maximum number of milliseconds that a buffer will
 *   be held once any data is placed in it. If this timeout expires, the
 *   buffer will be returned to the application even though it might not be
 *   completely full. <p lppropdata> points to a <t MIDIPROPCBTIMEOUT> structure.
 *
 * @comm These properties are the default properties defined by MMSYSTEM.
 *   Driver writers may implement and document their own properties.
 *
 * @rdesc The return value is one of the following values:
 *  @flag MMSYSERR_INVALPARAM | The given handle or flags are invalid.
 *  @flag MIDIERR_BADOPENMODE | The given handle is not open in MIDI_IO_COOKED
 *   or MIDI_IO_RAW mode.
 *
 ***************************************************************************/
MMRESULT WINAPI midiStreamProperty(
    HMIDISTRM   hms,
    LPBYTE      lppropdata,
    DWORD       dwProperty)
{
    MMRESULT mmrc;

    V_HANDLE(hms, TYPE_MIDISTRM, MMSYSERR_INVALHANDLE);

    if ((!(dwProperty&MIDIPROP_SET)) && (!(dwProperty&MIDIPROP_GET)))
        return MMSYSERR_INVALPARAM;

    V_RPOINTER(lppropdata, sizeof(DWORD), MMSYSERR_INVALPARAM);

    if (dwProperty&MIDIPROP_SET)
    {
        V_RPOINTER(lppropdata, (UINT)(*(LPDWORD)(lppropdata)), MMSYSERR_INVALPARAM);
    }
    else
    {
        V_WPOINTER(lppropdata, (UINT)(*(LPDWORD)(lppropdata)), MMSYSERR_INVALPARAM);
    }

    mmrc = (MMRESULT)midiStreamBroadcast(HtoPT(PMIDISTRM, hms),
                                         MODM_PROPERTIES,
                                         (DWORD_PTR)lppropdata,
                                         dwProperty);

    return mmrc;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiOutGetPosition | Retrieves the current
 *   playback position of the specified MIDI output device.
 *
 * @parm HMIDIOUT | hmo | Specifies a handle to the MIDI output device.
 *
 * @parm LPMMTIME | pmmt | Specifies a far pointer to an <t MMTIME>
 *   structure.
 *
 * @parm UINT | cbmmt | Specifies the size of the <t MMTIME> structure.
 *
 * @rdesc Returns zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm Before calling <f midiOutGetPosition>, set the <e MMTIME.wType> field
 *   of <t MMTIME> to indicate the time format that you desire. After
 *   calling <f midiOutGetPosition>, check the <e MMTIME.wType> field
 *   to determine if the desired time format is supported. If the desired
 *   format is not supported, <e MMTIME.wType> will specify an alternative
 *   format.
 *
 *  The position is set to zero when the device is opened, reset, or
 *  stopped.
 ****************************************************************************/
MMRESULT WINAPI midiStreamPosition(
    HMIDISTRM       hms,
    LPMMTIME        pmmt,
    UINT            cbmmt)
{
    MMRESULT mmrc;

    V_HANDLE(hms, TYPE_MIDISTRM, MMSYSERR_INVALHANDLE);
    V_WPOINTER(pmmt, cbmmt, MMSYSERR_INVALPARAM);

    mmrc = (MMRESULT)midiStreamMessage(HtoPT(PMIDISTRM, hms)->rgIds,
                                       MODM_GETPOS,
                                       (DWORD_PTR)pmmt,
                                       (DWORD)cbmmt);

    return mmrc;
}


/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiStreamStop | Turns off all notes on all MIDI
 *   channels for the specified MIDI output device. Any pending
 *   system-exclusive or polymessage output buffers are marked as done and
 *   returned to the application. While <f midiOutReset> turns off all notes,
 *   <f midiStreamStop> turns off only those notes that have been turned on
 *   by a MIDI note-on message.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI output
 *   device.
 *
 * @rdesc Returns zero if the function is successful.  Otherwise, it returns
 *   an error number.  Possible error values are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_BADOPENMODE | Specified device handle is not opened in
 *     MIDI_IO_COOKED mode.
 *
 * @comm To turn off all notes, a note-off message for each note for each
 *   channel is sent. In addition, the sustain controller is turned off for
 *   each channel.
 *
 * @xref midiOutLongMsg midiOutClose midiOutReset
 ****************************************************************************/
MMRESULT WINAPI midiStreamStop(HMIDISTRM hms)
{
    PMIDISTRM               pms;
    MMRESULT                mmrc;

    V_HANDLE(hms, TYPE_MIDISTRM, MMSYSERR_INVALHANDLE);

    pms = HtoPT(PMIDISTRM, hms);

    mmrc = (MMRESULT)midiStreamBroadcast(pms, MODM_STOP, 0, 0);

    return mmrc;
}


/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiStreamPause | Pauses playback on a specified
 *   MIDI output device. The current playback position is saved. Use
 *   <f midiStreamRestart> to resume playback from the current playback position.
 *   This call is only valid for handles opened in MIDI_IO_COOKED mode.
 *
 * @parm HMIDIOUT | hmo | Specifies a handle to the MIDI output
 *   device.
 *
 * @rdesc Returns zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_INVALPARAM | Specified device was not opened with
 *     the MIDI_IO_COOKED flag.
 *
 * @comm Calling this function when the output is already paused has no
 *   effect, and the function returns zero.
 *
 * @xref midiStreamRestart
 ****************************************************************************/
MMRESULT WINAPI midiStreamPause(
    HMIDISTRM       hms)
{
    MMRESULT mmrc;

    V_HANDLE(hms, TYPE_MIDISTRM, MMSYSERR_INVALHANDLE);

    mmrc = (MMRESULT)midiStreamBroadcast(HtoPT(PMIDISTRM, hms), MODM_PAUSE, 0, 0);

    return mmrc;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api MMRESULT | midiStreamRestart | Restarts a paused MIDI
 *   output device.
 *
 * @parm HMIDIOUT | hmo | Specifies a handle to the MIDI output
 *   device.
 *
 * @rdesc Returns zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_INVALPARAM | Specified device was not opened with
 *     the MIDI_IO_COOKED flag.
 *
 * @comm Calling this function when the output is not paused has no
 *   effect, and the function returns zero.
 *
 * @xref midiOutPause
 ****************************************************************************/
MMRESULT WINAPI midiStreamRestart(
    HMIDISTRM       hms)
{
    MMRESULT        mmrc;
    MMTIME          mmt;
    DWORD           tkTime;
    DWORD           msTime;
    PMIDISTRM       pms;
    PMIDISTRMID     pmsi;
    DWORD           idx;


    V_HANDLE(hms, TYPE_MIDISTRM, MMSYSERR_INVALHANDLE);

    tkTime = 0;
    pms = HtoPT(PMIDISTRM, hms);

    for (idx = 0, pmsi = pms->rgIds; idx < pms->cIds; idx++, pmsi++)
        if (pmsi->fdwId & MSI_F_FIRST)
        {
            mmt.wType = TIME_TICKS;

            mmrc = (MMRESULT)midiStreamMessage(pmsi,
                                               MODM_GETPOS,
                                               (DWORD_PTR)&mmt,
                                               sizeof(mmt));

            if (mmrc)
            {
                dprintf(("midiOutRestart: Device %u returned %u", idx, mmrc));
                return mmrc;
            }

            if (mmt.wType == TIME_TICKS)
            {
                if (mmt.u.ticks > tkTime)
                    tkTime = mmt.u.ticks;
            }
            else
            {
                dprintf(("midiOutRestart: Device %u does not support ticks", idx));
                return MIDIERR_NOTREADY;
            }
        }

    // Fudge time to allow device setup
    //
    msTime = timeGetTime();
    dprintf(("midiOutRestart: Tick %lu  timeGetTime %lu", tkTime, msTime));
    mmrc = (MMRESULT)midiStreamBroadcast(pms,
                                         MODM_RESTART,
                                         msTime,
                                         tkTime);

    return mmrc;
}


MMRESULT WINAPI midiStreamOut(
    HMIDISTRM       hMidiStrm,
    LPMIDIHDR       lpMidiHdr,
    UINT            cbMidiHdr)
{
    PMIDISTRMID     pmsi;
    PMIDISTRM       pms;
    UINT            idx;
    UINT            cSent;
    LPMIDIHDR       lpmhWork;
    BOOL            fCallback;
    MMRESULT        mmrc;

    dprintf2(( "midiStreamOut(%04X, %08lX, %08lX)", (UINT_PTR)hMidiStrm, (DWORD_PTR)lpMidiHdr, lpMidiHdr->dwBytesRecorded));

    V_HANDLE(hMidiStrm, TYPE_MIDISTRM, MMSYSERR_INVALHANDLE);
    V_HEADER(lpMidiHdr, cbMidiHdr, TYPE_MIDIOUT, MMSYSERR_INVALPARAM);

    pms = HtoPT(PMIDISTRM, hMidiStrm);

    for (pmsi = pms->rgIds, idx = 0; idx < pms->cIds; idx++, pmsi++)
        if ( (!(pmsi->fdwId & MSI_F_EMULATOR)) && (!(pmsi->hmd)) )
            return MMSYSERR_NODRIVER;

    if (!(lpMidiHdr->dwFlags&MHDR_PREPARED))
    {
        dprintf1(( "midiOutPolyMsg: !MHDR_PREPARED"));
        return MIDIERR_UNPREPARED;
    }

    if (lpMidiHdr->dwFlags&MHDR_INQUEUE)
    {
        dprintf1(( "midiOutPolyMsg: Still playing!"));
        return MIDIERR_STILLPLAYING;
    }

    if (lpMidiHdr->dwBytesRecorded > lpMidiHdr->dwBufferLength ||
        (lpMidiHdr->dwBytesRecorded & 3))
    {
        dprintf1(( "Bytes recorded too long or not DWORD aligned."));
        return MMSYSERR_INVALPARAM;
    }

    //
    // Polymsg buffers are limited to 64k in order that we (and the driver)
    // not have to do huge pointer manipulation.
    // Length must also be DWORD aligned.
    //
    if ((lpMidiHdr->dwBufferLength > 65535L) ||
            (lpMidiHdr->dwBufferLength&3))
    {
        dprintf1(( "midiOutPolyMsg: Buffer > 64k or not DWORD aligned"));
        return MMSYSERR_INVALPARAM;
    }

    EnterCriticalSection(&midiStrmHdrCritSec);

    LeaveCriticalSection(&midiStrmHdrCritSec);

    lpMidiHdr->dwReserved[MH_REFCNT] = 0;
    lpMidiHdr->dwFlags |= (MHDR_SENDING|MHDR_INQUEUE|MHDR_ISSTRM);

    lpmhWork = (LPMIDIHDR)lpMidiHdr->dwReserved[MH_SHADOW];

    pmsi = pms->rgIds;
    for (idx = 0, cSent = 0; idx < pms->cIds; idx++, pmsi++)
    {
       if (pmsi->fdwId & MSI_F_FIRST)
       {
           lpmhWork->dwBytesRecorded = lpMidiHdr->dwBytesRecorded;
           lpmhWork->dwFlags |= MHDR_ISSTRM;

           mmrc = (MMRESULT)midiStreamMessage(pmsi, MODM_STRMDATA, (DWORD_PTR)lpmhWork, sizeof(*lpmhWork));

           if (mmrc == MMSYSERR_NOERROR)
               ++lpMidiHdr->dwReserved[MH_REFCNT], ++cSent;

           lpmhWork++;
       }
    }

    fCallback = FALSE;

    EnterCriticalSection(&midiStrmHdrCritSec);

    lpMidiHdr->dwFlags &= ~MHDR_SENDING;
    if (cSent && 0 == lpMidiHdr->dwReserved[MH_REFCNT])
    {
        fCallback = TRUE;
    }

    LeaveCriticalSection(&midiStrmHdrCritSec);

    if (fCallback)
    {
        lpMidiHdr->dwFlags &= ~MHDR_INQUEUE;
        lpMidiHdr->dwFlags |= MHDR_DONE;
        DriverCallback(pms->dwCallback,
                   HIWORD(pms->fdwOpen),
                       (HDRVR)hMidiStrm,
                   MM_MOM_DONE,
                   pms->dwInstance,
                   (DWORD_PTR)lpMidiHdr,
                   0);
    }

    if (!cSent)
    {
        lpMidiHdr->dwFlags &= ~MHDR_INQUEUE;
        return mmrc;
    }
    else
        return MMSYSERR_NOERROR;
}


DWORD FAR PASCAL midiStreamMessage(PMIDISTRMID pmsi, UINT msg, DWORD_PTR dwP1, DWORD_PTR dwP2)
{
    MMRESULT mrc;

    if (!(pmsi->fdwId & MSI_F_EMULATOR))
    {
        EnterCriticalSection(&pmsi->CritSec);

        mrc = (*(pmsi->drvMessage))
                      (0, msg, pmsi->dwDrvUser, dwP1, dwP2);

        try
        {
            LeaveCriticalSection(&pmsi->CritSec);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {

        }
        return mrc;
    }
    else
    {
        mrc = mseMessage(msg, pmsi->dwDrvUser, dwP1, dwP2);
    }

    return mrc;
}

DWORD FAR PASCAL midiStreamBroadcast(
    PMIDISTRM   pms,
    UINT        msg,
    DWORD_PTR   dwP1,
    DWORD_PTR   dwP2)
{
    DWORD       idx;
    DWORD       mmrc;
    DWORD       mmrcRet;
    PMIDISTRMID pmsi;

    ENTER_MM_HANDLE((HMIDI)pms);

    mmrcRet = MMSYSERR_NOERROR;

    pmsi = pms->rgIds;

    for (idx = pms->cIds; idx; idx--, pmsi++)
    {
        if (pmsi->fdwId & MSI_F_FIRST)
        {
            mmrc = midiStreamMessage(pmsi, msg, dwP1, dwP2);
            if (MMSYSERR_NOERROR != mmrc)
                mmrcRet = mmrc;
        }
    }

    LEAVE_MM_HANDLE((HMIDI)pms);
    return mmrcRet;
}

void CALLBACK midiOutStreamCallback(
    HMIDISTRM               hMidiOut,
    WORD                    wMsg,
    DWORD_PTR               dwInstance,
    DWORD_PTR               dwParam1,
    DWORD_PTR               dwParam2)
{
    PMIDISTRM               pms         = HtoPT(PMIDISTRM, hMidiOut);
    LPMIDIHDR               lpmh        = (LPMIDIHDR)dwParam1;

    if (MM_MOM_POSITIONCB == wMsg)
    {
        LPMIDIHDR lpmh2 = (LPMIDIHDR)lpmh->dwReserved[MH_PARENT];
        lpmh2->dwOffset = lpmh->dwOffset;

        DriverCallback(pms->dwCallback,
                   HIWORD(pms->fdwOpen),
                   (HDRVR)hMidiOut,
                   MM_MOM_POSITIONCB,
                   pms->dwInstance,
                   (DWORD_PTR)lpmh2,
                   0);
        return;
    }
    else if (MM_MOM_DONE != wMsg)
        return;

#ifdef DEBUG
    {
        DWORD dwDelta = timeGetTime() - (DWORD)lpmh->dwReserved[7];
        if (dwDelta > 1)
            dprintf1(("Took %lu ms to deliver callback!", dwDelta));
    }
#endif

    lpmh = (LPMIDIHDR)lpmh->dwReserved[MH_PARENT];

    dprintf2(("mOSCB PMS %04X HDR %08lX", (UINT_PTR)pms, (DWORD_PTR)lpmh));

    EnterCriticalSection(&midiStrmHdrCritSec);

    --lpmh->dwReserved[MH_REFCNT];

    if (0 == lpmh->dwReserved[MH_REFCNT] && (!(lpmh->dwFlags & MHDR_SENDING)))
    {
        lpmh->dwFlags &= ~MHDR_INQUEUE;
        lpmh->dwFlags |= MHDR_DONE;

        LeaveCriticalSection(&midiStrmHdrCritSec);

#ifdef DEBUG
        lpmh->dwReserved[7] = timeGetTime();
#endif
        DriverCallback(pms->dwCallback,
                       HIWORD(pms->fdwOpen),
                       (HDRVR)hMidiOut,
                       MM_MOM_DONE,
                       pms->dwInstance,
                       (DWORD_PTR)lpmh,
                       0);

    }
    else
    {
        LeaveCriticalSection(&midiStrmHdrCritSec);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\mixer.h ===
/******************************Module*Header*******************************\
* Module Name: mixer.h
*
* Internal header file for mixer.c
*
*
* Created: 27-10-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993-2001 Microsoft Corporation
\**************************************************************************/
#define UNICODE
#ifndef WIN32
#define WIN32
#endif

#include <stdlib.h>
#include <windows.h>
#include "mmsystem.h"            // pick up the internal one
#include "mmsysp.h"            // pick up the internal one
#include "mmddk.h"
#define NONEWWAVE
#include <mmreg.h>
#undef NONEWWAVE

//
//  Avoid including msacm.h - in any case this define should be in mmreg.h
//
#ifndef DRVM_MAPPER_STATUS
#define DRVM_MAPPER_STATUS              (0x2000)
#endif

#ifndef WIDM_MAPPER_STATUS
#define WIDM_MAPPER_STATUS              (DRVM_MAPPER_STATUS + 0)
#define WAVEIN_MAPPER_STATUS_DEVICE     0
#define WAVEIN_MAPPER_STATUS_MAPPED     1
#endif

#ifndef WODM_MAPPER_STATUS
#define WODM_MAPPER_STATUS              (DRVM_MAPPER_STATUS + 0)
#define WAVEOUT_MAPPER_STATUS_DEVICE    0
#define WAVEOUT_MAPPER_STATUS_MAPPED    1
#endif

#define MMDDKINC
#include "winmmi.h"

#define MIXMGR_ENTER EnterCriticalSection(&HandleListCritSec)
#define MIXMGR_LEAVE LeaveCriticalSection(&HandleListCritSec)

//typedef struct
//{
//    HDRVR               hdrvr;      // handle to the module
//    DRIVERMSGPROC       drvMessage; // pointer to entry point
//    BYTE                bNumDevs;   // number of devices supported
//    BYTE                bUsage;     // usage count (number of handles open)
//    DWORD               cookie;     // cookie used for WDM devices.
//    CRITICAL_SECTION    MixerCritSec; // Serialize use of mixer
//    WCHAR               wszDrvEntry[64]; // driver filename
//} MIXERDRV, *PMIXERDRV;

typedef struct tMIXERDEV
{
    UINT                uHandleType;    // for parameter validation

    struct tMIXERDEV   *pmxdevNext;     /* How quaint, a linked list... */
    PMIXERDRV           pmxdrv;
    UINT                wDevice;
    DWORD_PTR           dwDrvUser;
    UINT                uDeviceID;

    DWORD               fdwSupport;     // from the driver's mixercaps
    DWORD               cDestinations;  // from the driver's mixercaps

    DWORD_PTR           dwCallback;     // client's callback and inst data
    DWORD_PTR           dwInstance;

    DWORD               fdwOpen;        /* The open flags the caller used */
    DWORD               fdwHandle;
} MIXERDEV, *PMIXERDEV;

/* -------------------------------------------------------------------------
** internal function prototypes
** -------------------------------------------------------------------------
*/
BOOL CALLBACK MixerCallbackFunc(
    HMIXER hmx,
    UINT uMsg,
    DWORD_PTR dwInstance,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2
);


MMRESULT mixerReferenceDriverById(
    IN UINT uId,
    OUT PMIXERDRV *ppdrv OPTIONAL,
    OUT UINT *pport OPTIONAL
);

DWORD NEAR PASCAL IMixerMessageHandle(
    HMIXER hmx,
    UINT uMsg,
    DWORD_PTR dwP1,
    DWORD_PTR dwP2
);

DWORD NEAR PASCAL IMixerMessageId(
    UINT uDeviceID,
    UINT uMsg,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2
);

void
ConvertMIXERLINEWToMIXERLINEA(
    PMIXERLINEA pmxlA,
    PMIXERLINEW pmxlW
);

MMRESULT IMixerGetID(
    HMIXEROBJ hmxobj,
    PUINT puMxId,
    LPMIXERLINE pmxl,
    DWORD fdwId
);


/* -------------------------------------------------------------------------
** Loading and initialization functions
** -------------------------------------------------------------------------
*/
BOOL mmDrvInstallMixer(
    HDRVR           hdrvr,
    DRIVERMSGPROC   drvMessage,
    UINT            wFlags,
    LPCTSTR         tszDrvEntry
);

BOOL IMixerUnloadDrivers(
    HDRVR hdrvrSelf
);

HDRVR mmDrvOpenMixer(
    LPTSTR szAlias
);

BOOL IMixerLoadDrivers(
    void
);

/* -------------------------------------------------------------------------
** Make sizeof return the number of chars when applied to a character array
** which may be unicoded.
** -------------------------------------------------------------------------
*/
#ifdef UNICODE
    #define SIZEOF(x)   (sizeof(x)/sizeof(WCHAR))
#else
    #define SIZEOF(x)   sizeof(x)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\mixer.c ===
//==========================================================================;
//
//  mixer.c
//
//  Copyright (c) 1992-2001 Microsoft Corporation
//
//  Description:
//
//
//  History:
//       6/27/93    cjp     [curtisp]
//
//==========================================================================;
#define  UNICODE
#include "winmmi.h"
#include "mixer.h"  // This file drags in a ton of stuff to support the mixers



PMIXERDEV   gpMixerDevHeader = NULL;    /* A LL of open devices */
UINT        guTotalMixerDevs;           // total mixer devices

//
//  mixer device driver list--add one to accomodate the MIXER_MAPPER. note
//  that even if we are not compiling with mapper support we need to add
//  one because other code relies on it (for other device mappers).
//
MIXERDRV mixerdrvZ;

char    gszMxdMessage[]     = "mxdMessage";
TCHAR   gszMixer[]          = TEXT("mixer");

#ifdef MIXER_MAPPER
TCHAR   gszMixerMapper[]    = TEXT("mixermapper");
#endif

#ifdef MIXER_MAPPER
#define MMDRVI_MAPPER        0x8000     // install this driver as the mapper
#endif

//#define MMDRVI_MIXER         0x0006
#define MMDRVI_HDRV          0x4000     // hdrvr is an installable driver
#define MMDRVI_REMOVE        0x2000     // remove the driver

//--------------------------------------------------------------------------;
//
//  BOOL MixerCallbackFunc
//
//  Description:
//
//      NOTE! we document that a mixer must NEVER call this function at
//      interrupt time! we don't want to fix our code or data segments.
//
//  Arguments:
//      HMIXER hmx:
//
//      UINT uMsg:
//
//      DWORD dwInstance:
//
//      DWORD dwParam1:
//
//      DWORD dwParam2:
//
//  Return (BOOL):
//
//  History:
//      07/21/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL CALLBACK MixerCallbackFunc(
    HMIXER                  hmx,
    UINT                    uMsg,
    DWORD_PTR               dwInstance,
    DWORD_PTR               dwParam1,
    DWORD_PTR               dwParam2
)
{
    PMIXERDEV           pmxdev;

    //
    //  step through all open handles and do callbacks to the appropriate
    //  clients...
    //

    //
    // Serialize access to hande list - only necessary for Win32
    //
    MIXMGR_ENTER;

    for (pmxdev = gpMixerDevHeader; pmxdev; pmxdev = pmxdev->pmxdevNext)
    {
        //
        //  same device? (could also use hmx->uDeviceID)
        //
        if (pmxdev->uDeviceID != dwInstance)
            continue;

        DriverCallback(pmxdev->dwCallback,
                        (HIWORD(pmxdev->fdwOpen) | DCB_NOSWITCH),

                        GetWOWHandle((HANDLE)pmxdev)
                            ? (HANDLE)(UINT_PTR)GetWOWHandle((HANDLE)pmxdev)
                            : (HANDLE)pmxdev,

                        uMsg,
                        pmxdev->dwInstance,
                        dwParam1,
                        dwParam2);
    }

    MIXMGR_LEAVE;

    return (TRUE);
} // MixerCallbackFunc()


//--------------------------------------------------------------------------;
//
//  MMRESULT mixerReferenceDriveryById
//
//  Description:
//      This function maps a logical id to a device driver and physical id.
//
//  Arguments:
//      IN UINT uId: The logical id to be mapped.
//
//      OUT PMIXERDRV* OPTIONAL ppmixerdrv: Pointer to the MIXERDRV structure
//         describing describing the driver supporing the id.
//
//      OUT UINT* OPTIONAL pport: The driverj-relative device number.  If the
//         caller supplies this buffer then it must also supply ppmixerdrv.
//
//  Return (MMRESULT):
//      The return value is zero if successful, MMSYSERR_BADDEVICEID if the id
//      is out of range.
//
//  Comments:
//      If the caller specifies ppmixerdrv then this function increments the
//      mixerdrv's usage before returning.  The caller must ensure the usage
//      is eventually decremented.
//
//  History:
//      03/17/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT mixerReferenceDriverById(
    IN UINT id,
    OUT PMIXERDRV *ppdrv OPTIONAL,
    OUT UINT *pport OPTIONAL
)
{
    PMIXERDRV pdrv;
    MMRESULT mmr;

    // Should not be called asking for port but not mixerdrv
    WinAssert(!(pport && !ppdrv));
    
    EnterNumDevs("mixerReferenceDriverById");
    
#ifdef MIXER_MAPPER
    if (MIXER_MAPPER == id)
    {
    	id = 0;
    	for (pdrv = mixerdrvZ.Next; pdrv != &mixerdrvZ; pdrv = pdrv->Next)
	{
	    if (pdrv->fdwDriver & MMDRV_MAPPER) break;
	}
    }
    else
#endif
    {
    	for (pdrv = mixerdrvZ.Next; pdrv != &mixerdrvZ; pdrv = pdrv->Next)
	{
	    if (pdrv->fdwDriver & MMDRV_MAPPER) continue;
	    if (pdrv->NumDevs > id) break;
	    id -= pdrv->NumDevs;
	}
    }

    if (pdrv != &mixerdrvZ)
    {
    	if (ppdrv)
    	{
    	    mregIncUsagePtr(pdrv);
    	    *ppdrv = pdrv;
    	    if (pport) *pport = id;
    	}
    	mmr = MMSYSERR_NOERROR;
    } else {
    	mmr = MMSYSERR_BADDEVICEID;
    }

    LeaveNumDevs("mixerReferenceDriverById");

    return mmr;
;
} // IMixerMapId()


PCWSTR mixerReferenceDevInterfaceById(UINT_PTR id)
{
    PMIXERDRV pdrv;
    PCWSTR DevInterface;
    
    if (ValidateHandle((HANDLE)id, TYPE_MIXER))
    {
    	DevInterface = ((PMIXERDEV)id)->pmxdrv->cookie;
    	if (DevInterface) wdmDevInterfaceInc(DevInterface);
    	return DevInterface;
    }
    
    if (!mixerReferenceDriverById((UINT)id, &pdrv, NULL))
    {
    	DevInterface = pdrv->cookie;
    	if (DevInterface) wdmDevInterfaceInc(DevInterface);
    	mregDecUsagePtr(pdrv);
    	return DevInterface;
    }

    return NULL;
}

//--------------------------------------------------------------------------;
//
//  DWORD IMixerMessageHandle
//
//  Description:
//
//
//  Arguments:
//      HMIXER hmx:
//
//      UINT uMsg:
//
//      DWORD dwP1:
//
//      DWORD dwP2:
//
//  Return (DWORD):
//
//  History:
//      03/17/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

DWORD NEAR PASCAL IMixerMessageHandle(
    HMIXER          hmx,
    UINT            uMsg,
    DWORD_PTR       dwP1,
    DWORD_PTR       dwP2
)
{
    PMIXERDEV   pmxd;
    DWORD       dwRc;

    pmxd = (PMIXERDEV)hmx;

    ENTER_MM_HANDLE(hmx);
    ReleaseHandleListResource();
    
    //  Is handle deserted?
    if (IsHandleDeserted(hmx))
    {
        LEAVE_MM_HANDLE(hmx);
        return (MMSYSERR_NODRIVER);
    }

    if (IsHandleBusy(hmx))
    {
        LEAVE_MM_HANDLE(hmx);
        return (MMSYSERR_HANDLEBUSY);
    }

    EnterCriticalSection(&pmxd->pmxdrv->MixerCritSec);
    
    if (BAD_HANDLE(hmx, TYPE_MIXER))
    {
        //  Do we still need to check for this?
    
	    WinAssert(!"Bad Handle within IMixerMessageHandle");
        dwRc = MMSYSERR_INVALHANDLE;
    }
    else
    {
        dwRc = ((*(pmxd->pmxdrv->drvMessage))
                (pmxd->wDevice, uMsg, pmxd->dwDrvUser, dwP1, dwP2));
    }

    LeaveCriticalSection(&pmxd->pmxdrv->MixerCritSec);
    LEAVE_MM_HANDLE(hmx);

    return dwRc;
} // IMixerMessageHandle()


//--------------------------------------------------------------------------;
//
//  DWORD IMixerMessageId
//
//  Description:
//
//
//  Arguments:
//      PMIXERDRV pmxdrv:
//
//      UINT uTotalNumDevs:
//
//      UINT uDeviceID:
//
//      UINT uMsg:
//
//      DWORD dwParam1:
//
//      DWORD dwParam2:
//
//  Return (DWORD):
//
//  History:
//      03/17/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

extern void lstrncpyW (LPWSTR pszTarget, LPCWSTR pszSource, size_t cch);

DWORD NEAR PASCAL IMixerMessageId(
    UINT            uDeviceID,
    UINT            uMsg,
    DWORD_PTR       dwParam1,
    DWORD_PTR       dwParam2
)
{
    PMIXERDRV   pmxdrv;
    UINT        port;
    DWORD       dwRc;
    HMIXER      hmx;
    PMIXERDEV   pmxdev;
    MMRESULT    mmr;

    mmr = mixerReferenceDriverById(uDeviceID, &pmxdrv, &port);

    if (mmr)
    {
        return mmr;
    }

    if (mregHandleInternalMessages(pmxdrv, TYPE_MIXER, port, uMsg, dwParam1, dwParam2, &mmr))
    {
    	mregDecUsagePtr(pmxdrv);
        return mmr;
    }

    mregDecUsagePtr(pmxdrv);

    dwRc = mixerOpen(&hmx, uDeviceID, 0L, 0L, MIXER_OBJECTF_MIXER);
    
    // Should we go through IMixerMessageHandle???
    if (MMSYSERR_NOERROR == dwRc)
    {
        pmxdev = (PMIXERDEV)hmx;
        pmxdrv = pmxdev->pmxdrv;

        if (!pmxdrv->drvMessage)
        {
            dwRc = MMSYSERR_NODRIVER;
        }
        else
        {
            EnterCriticalSection( &pmxdrv->MixerCritSec);

            dwRc = ((*(pmxdrv->drvMessage))
                    (port, uMsg, pmxdev->dwDrvUser, dwParam1, dwParam2));

            LeaveCriticalSection( &pmxdrv->MixerCritSec);
        }

        mixerClose(hmx);
    }

    return dwRc;

} // IMixerMessageId()


//==========================================================================;
//
//
//
//
//==========================================================================;

/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK API
 *
 *  @api UINT | mixerGetNumDevs | The <f mixerGetNumDevs> function retrieves
 *      the number of audio mixer devices present in the system.
 *
 *  @rdesc Returns the number of audio mixer devices present in the system.
 *      If no audio mixer devices are available, zero is returned.
 *
 *  @xref <f mixerGetDevCaps>, <f mixerOpen>
 *
 **/

UINT APIENTRY mixerGetNumDevs(
    void
)
{
    UINT cDevs;

    ClientUpdatePnpInfo();

    EnterNumDevs("mixerGetNumDevs");
    cDevs = guTotalMixerDevs;
    LeaveNumDevs("mixerGetNumDevs");

    return cDevs;
} // mixerGetNumDevs()


/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK STRUCTURE
 *
 *  @types MIXERCAPS | The <t MIXERCAPS> structure describes the capabilities
 *      of a mixer device.
 *
 *  @field WORD | wMid | Specifies a manufacturer identifier for the mixer
 *      device driver. Manufacturer identifiers are defined in Appendix B,
 *      <lq>Manufacturer ID and Product ID Lists.<rq>
 *
 *  @field WORD | wPid | Specifies a product identifier for the mixer device
 *      driver. Product identifiers are defined in Appendix B,
 *      <lq>Manufacturer ID and Product ID Lists.<rq>
 *
 *  @field MMVERSION | vDriverVersion | Specifies the version number of the
 *      mixer device driver. The high-order byte is the major version
 *      number, and the low-order byte is the minor version number.
 *
 *  @field char | szPname[MAXPNAMELEN] | Specifies the name of the product.
 *      If the mixer device driver supports multiple cards, this string must
 *      uniquely and easily identify (potentially to a user) this specific
 *      card. For example, szPname = <lq>Sound Card Mixer, I/O address 200<rq>
 *      would uniquely identify (to the user) this particular card as a
 *      Sound Card Mixer for the physical card based at I/O address 200. If
 *      only one device is installed, it is recommended that only the base
 *      name be returned. For example, szPname should be <lq>Sound Card Mixer<rq>
 *      if only one device is present.
 *
 *  @field DWORD | fdwSupport | Specifies various support information for
 *      the mixer device driver. No extended support bits are currently
 *      defined.
 *
 *  @field DWORD | cDestinations | The number of audio mixer line destinations
 *      available through the mixer. All mixer devices must support at least
 *      one destination line, so this member can never be zero. Destination
 *      indexes used in the <e MIXERLINE.dwDestination> member of the
 *      <t MIXERLINE> structure range from zero to the value specified in the
 *      <e MIXERCAPS.cDestinations> member minus one.
 *
 *  @tagname tMIXERCAPS
 *
 *  @othertype MIXERCAPS FAR * | LPMIXERCAPS | A pointer to a <t MIXERCAPS>
 *      structure.
 *
 *  @othertype MIXERCAPS * | PMIXERCAPS | A pointer to a <t MIXERCAPS>
 *      structure.
 *
 *  @xref <f mixerGetDevCaps>, <f mixerOpen>, <f mixerGetLineInfo>
 *
 **/

/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK API
 *
 *  @api MMRESULT | mixerGetDevCaps | The <f mixerGetDevCaps> function
 *      queries a specified audio mixer device to determine its capabilities.
 *
 *  @parm UINT | uMxId | Identifies the audio mixer device with either
 *      an audio mixer device identifier or a handle to an opened audio mixer
 *      device.
 *
 *  @parm LPMIXERCAPS | pmxcaps | Pointer to a <t MIXERCAPS> structure that
 *      receives information about the capabilities of the device.
 *
 *  @parm UINT | cbmxcaps | Specifies the size, in bytes, of the <t MIXERCAPS>
 *      structure.
 *
 *  @rdesc The return value is zero if the function is successful. Otherwise,
 *      it returns a non-zero error number. Possible error returns include
 *      the following:
 *
 *      @flag <c MMSYSERR_BADDEVICEID> | The specified device identifier is
 *      out of range.
 *
 *      @flag <c MMSYSERR_INVALHANDLE> | The audio mixer device handle passed
 *      is invalid.
 *
 *      @flag <c MMSYSERR_INVALPARAM> | One or more arguments passed is
 *      invalid.
 *
 *  @comm Use the <f mixerGetNumDevs> function to determine the number of
 *      audio mixer devices present in the system. The device identifier
 *      specified by <p uMxId> varies from zero to one less than the number
 *      of mixer devices present.
 *
 *      Only <p cbmxcaps> bytes (or less) of information is copied to the
 *      location pointed to by <p pmxcaps>. If <p cbmxcaps> is zero, nothing
 *      is copied, and the function returns success.
 *
 *      This function also accepts an audio mixer device handle returned by
 *      the <f mixerOpen> function as the <p uMxId> argument. The calling
 *      application should cast the <c HMIXER> handle to a UINT.
 *
 *  @xref <f mixerGetNumDevs>, <t MIXERCAPS>, <f mixerOpen>
 *
 **/

MMRESULT APIENTRY mixerGetDevCapsA(
    UINT_PTR                uMxId,
    LPMIXERCAPSA            pmxcapsA,
    UINT                    cbmxcaps
)
{
    MIXERCAPS2W    mxcaps2W;
    MIXERCAPS2A    mxcaps2A;
    MMRESULT       mmr;

    if (0 == cbmxcaps)
        return (MMSYSERR_NOERROR);

    V_WPOINTER(pmxcapsA, cbmxcaps, MMSYSERR_INVALPARAM);

    memset(&mxcaps2W, 0, sizeof(mxcaps2W));

    mmr = mixerGetDevCaps(uMxId, (LPMIXERCAPSW)&mxcaps2W, sizeof(mxcaps2W));

    if (mmr != MMSYSERR_NOERROR) {
        return mmr;
    }

    //
    //  Copy the structure back as cleanly as possible.  This would
    //  Be a little easier if all the strings were at the end of structures.
    //  Things would be a LOT more sensible if they could ONLY ask for the
    //  whole structure (then we could copy the result direct to the
    //  caller's memory).
    //
    //  Because of all this it's easiest to get the whole UNICODE structure,
    //  massage it into an ASCII stucture then (for the 0.001% of such apps)
    //  copy back the part they actually asked for.  The definition of the
    //  API means that, far from these apps going faster, everyone goes slow.
    //

    Iwcstombs(mxcaps2A.szPname, mxcaps2W.szPname, MAXPNAMELEN);
    mxcaps2A.wMid = mxcaps2W.wMid;
    mxcaps2A.wPid = mxcaps2W.wPid;
    mxcaps2A.vDriverVersion = mxcaps2W.vDriverVersion;
    mxcaps2A.fdwSupport = mxcaps2W.fdwSupport;
    mxcaps2A.cDestinations = mxcaps2W.cDestinations;
    mxcaps2A.ManufacturerGuid = mxcaps2W.ManufacturerGuid;
    mxcaps2A.ProductGuid      = mxcaps2W.ProductGuid;
    mxcaps2A.NameGuid      = mxcaps2W.NameGuid;

    CopyMemory((PVOID)pmxcapsA, &mxcaps2A, min(sizeof(mxcaps2A), cbmxcaps));

    return mmr;

} // mixerGetDevCapsA()

MMRESULT APIENTRY mixerGetDevCaps(
    UINT_PTR                uMxId,
    LPMIXERCAPS             pmxcaps,
    UINT                    cbmxcaps
)
{
    DWORD_PTR       dwParam1, dwParam2;
    MDEVICECAPSEX   mdCaps;
    PCWSTR          DevInterface;
    MMRESULT        mmr;

    if (0 == cbmxcaps)
        return (MMSYSERR_NOERROR);

    V_WPOINTER(pmxcaps, cbmxcaps, MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();

    DevInterface = mixerReferenceDevInterfaceById(uMxId);
    dwParam2 = (DWORD_PTR)DevInterface;
    
    if (0 == dwParam2)
    {
        dwParam1 = (DWORD_PTR)pmxcaps;
        dwParam2 = (DWORD)cbmxcaps;
    }
    else
    {
        mdCaps.cbSize = (DWORD)cbmxcaps;
        mdCaps.pCaps  = pmxcaps;
        dwParam1      = (DWORD_PTR)&mdCaps;
    }

    AcquireHandleListResourceShared();

    if ((uMxId >= guTotalMixerDevs) && !BAD_HANDLE((HMIXER)uMxId, TYPE_MIXER))
    {
       mmr = (MMRESULT)IMixerMessageHandle((HMIXER)uMxId,
                                           MXDM_GETDEVCAPS,
                                           dwParam1,
                                           dwParam2);
    }
    else
    {
        ReleaseHandleListResource();
        mmr = (MMRESULT)IMixerMessageId((UINT)uMxId,
                                       MXDM_GETDEVCAPS,
                                       (DWORD_PTR)dwParam1,
                                       (DWORD_PTR)dwParam2);
    }

    if (DevInterface) wdmDevInterfaceDec(DevInterface);

    return (mmr);

} // mixerGetDevCaps()



/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK API
 *
 *  @api MMRESULT | mixerGetID | The <f mixerGetID> function gets the device
 *      identifier for an audio mixer device that corresponds to audio mixer
 *      object handle <p hmxobj>.
 *
 *  @parm <c HMIXEROBJ> | hmxobj | Identifies the audio mixer object handle
 *      to map to an audio mixer device identifier.
 *
 *  @parm UINT FAR * | puMxId | Points to a UINT-sized variable that will
 *      receive the audio mixer device identifier. If no mixer device is
 *      available for the <p hmxobj> object, then '-1' is placed in this
 *      location (an error code of <c MMSYSERR_NODRIVER> is also returned).
 *
 *  @parm DWORD | fdwId | Specifies flags for how to map the audio mixer
 *      object <p hmxobj>.
 *
 *      @flag <c MIXER_OBJECTF_MIXER> | Specifies that <p hmxobj> is an audio
 *      mixer device identifier in the range of zero to one less than the
 *      number of devices returned by <f mixerGetNumDevs>. This flag is
 *      optional.
 *
 *      @flag <c MIXER_OBJECTF_HMIXER> | Specifies that <p hmxobj> is a mixer
 *      device handle returned by <f mixerOpen>. This flag is optional.
 *
 *      @flag <c MIXER_OBJECTF_WAVEOUT> | Specifies that <p hmxobj> is a
 *      waveform output device identifier in the range of zero to one less
 *      than the number of devices returned by <f waveOutGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HWAVEOUT> | Specifies that <p hmxobj> is a
 *      waveform output handle returned by <f waveOutOpen>.
 *
 *      @flag <c MIXER_OBJECTF_WAVEIN> | Specifies that <p hmxobj> is a
 *      waveform input device identifier in the range of zero to one less
 *      than the number of devices returned by <f waveInGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HWAVEIN> | Specifies that <p hmxobj> is a
 *      waveform input handle returned by <f midiInOpen>.
 *
 *      @flag <c MIXER_OBJECTF_MIDIOUT> | Specifies that <p hmxobj> is a MIDI
 *      output device identifier in the range of zero to one less than the
 *      number of devices returned by <f midiOutGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HMIDIOUT> | Specifies that <p hmxobj> is a
 *      MIDI output handle returned by <f midiOutOpen>.
 *
 *      @flag <c MIXER_OBJECTF_MIDIIN> | Specifies that <p hmxobj> is a MIDI
 *      input device identifier in the range of zero to one less than the
 *      number of devices returned by <f midiInGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HMIDIIN> | Specifies that <p hmxobj> is a MIDI
 *      input handle returned by <f midiInOpen>.
 *
 *      @flag <c MIXER_OBJECTF_AUX> | Specifies that <p hmxobj> is an
 *      auxiliary device identifier in the range of zero to one less than the
 *      number of devices returned by <f auxGetNumDevs>.
 *
 *  @rdesc The return value is zero if the function is successful. Otherwise,
 *      it returns a non-zero error number. Possible error returns include
 *      the following:
 *
 *      @flag <c MMSYSERR_BADDEVICEID> | The <p hmxobj> argument specifies an
 *      invalid device identifier.
 *
 *      @flag <c MMSYSERR_INVALHANDLE> | The <p hmxobj> argument specifies an
 *      invalid handle.
 *
 *      @flag <c MMSYSERR_INVALFLAG> | One or more flags are invalid.
 *
 *      @flag <c MMSYSERR_INVALPARAM> | One or more arguments passed is
 *      invalid.
 *
 *      @flag <c MMSYSERR_NODRIVER> | No audio mixer device is available for
 *      the object specified by <p hmxobj>. Note that the location referenced
 *      by <p puMxId> will also contain the value '-1'.
 *
 *  @comm Use the <f mixerGetID> function to determine what audio mixer
 *      device (if any) is responsible for performing mixing functions on a
 *      media device. For example, an application can use <f mixerGetID> to
 *      get the mixer device identifier responsible for setting the volume
 *      on a waveform output handle. Or the application may want to display
 *      a peak meter for waveform input device.
 *
 *  @xref <f mixerGetNumDevs>, <f mixerGetDevCaps>, <f mixerOpen>
 *
 **/
MMRESULT APIENTRY mixerGetID(
    HMIXEROBJ               hmxobj,
    UINT FAR               *puMxId,
    DWORD                   fdwId
)
{
    ClientUpdatePnpInfo();

    return IMixerGetID( hmxobj, (PUINT)puMxId, NULL, fdwId );
} // mixerGetID()

//--------------------------------------------------------------------------;
//
//  MMRESULT IMixerGetID
//
//  Description:
//
//
//  Arguments:
//      HMIXEROBJ hmxobj:
//
//      UINT FAR *puMxId:
//
//      DWORD fdwId:
//
//  Return (MMRESULT):
//
//  History:
//      06/27/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT IMixerGetID(
    HMIXEROBJ           hmxobj,
    PUINT               puMxId,
    LPMIXERLINE         pmxl,
    DWORD               fdwId
)
{
    MMRESULT        mmr;
    MIXERLINE       mxl;
    UINT            u;

    V_DFLAGS(fdwId, MIXER_GETIDF_VALID, IMixerGetID, MMSYSERR_INVALFLAG);
    V_WPOINTER(puMxId, sizeof(UINT), MMSYSERR_INVALPARAM);


    //
    //  set to '-1' which would be the mixer mapper (if there was one)
    //  this way we will definitely fail any calls made on this id if
    //  this function fails and the caller doesn't check his return value.
    //
    *puMxId = (UINT)-1;


    //
    //
    //
    switch (MIXER_OBJECTF_TYPEMASK & fdwId)
    {
        case MIXER_OBJECTF_MIXER:
        case MIXER_OBJECTF_HMIXER:
        {
            mmr = (fdwId & MIXER_OBJECTF_HANDLE) ? MMSYSERR_INVALHANDLE : MMSYSERR_BADDEVICEID;
            
            if ((UINT_PTR)hmxobj >= guTotalMixerDevs)
            {
                V_HANDLE_ACQ(hmxobj, TYPE_MIXER, mmr);
                *puMxId = ((PMIXERDEV)hmxobj)->uDeviceID;
                ReleaseHandleListResource();
            } else {
            	*puMxId = PtrToUint(hmxobj);
            }
            return (MMSYSERR_NOERROR);
        }
        
        case MIXER_OBJECTF_HWAVEOUT:
        {
            UINT        uId;
            DWORD       dwId;

            mmr = waveOutGetID((HWAVEOUT)hmxobj, &uId);
            if (MMSYSERR_NOERROR != mmr)
            {
                return (MMSYSERR_INVALHANDLE);
            }

            if (WAVE_MAPPER == uId)
            {
                mmr = (MMRESULT)waveOutMessage((HWAVEOUT)hmxobj,
                                               WODM_MAPPER_STATUS,
                                               WAVEOUT_MAPPER_STATUS_DEVICE,
                                               (DWORD_PTR)(LPVOID)&dwId);

                if (MMSYSERR_NOERROR == mmr)
                {
                    uId = (UINT)dwId;
                }
            }

            hmxobj = (HMIXEROBJ)(UINT_PTR)uId;
        }

        case MIXER_OBJECTF_WAVEOUT:
        {
            WAVEOUTCAPS     woc;

            mmr = waveOutGetDevCaps((UINT_PTR)hmxobj, &woc, sizeof(woc));
            if (MMSYSERR_NOERROR != mmr)
                return (MMSYSERR_BADDEVICEID);

            woc.szPname[SIZEOF(woc.szPname) - 1] = '\0';

            mxl.Target.dwType         = MIXERLINE_TARGETTYPE_WAVEOUT;
            mxl.Target.dwDeviceID     = PtrToUlong(hmxobj);
            mxl.Target.wMid           = woc.wMid;
            mxl.Target.wPid           = woc.wPid;
            mxl.Target.vDriverVersion = woc.vDriverVersion;
            lstrcpy(mxl.Target.szPname, woc.szPname);
            break;
        }


        case MIXER_OBJECTF_HWAVEIN:
        {
            UINT        uId;
            DWORD       dwId;

            mmr = waveInGetID((HWAVEIN)hmxobj, &uId);
            if (MMSYSERR_NOERROR != mmr)
            {
                return (MMSYSERR_INVALHANDLE);
            }

            if (WAVE_MAPPER == uId)
            {
                mmr = (MMRESULT)waveInMessage((HWAVEIN)hmxobj,
                                              WIDM_MAPPER_STATUS,
                                              WAVEIN_MAPPER_STATUS_DEVICE,
                                              (DWORD_PTR)(LPVOID)&dwId);

                if (MMSYSERR_NOERROR == mmr)
                {
                    uId = (UINT)dwId;
                }
            }

            hmxobj = (HMIXEROBJ)(UINT_PTR)uId;
        }

        case MIXER_OBJECTF_WAVEIN:
        {
            WAVEINCAPS      wic;

            mmr = waveInGetDevCaps((UINT_PTR)hmxobj, &wic, sizeof(wic));
            if (MMSYSERR_NOERROR != mmr)
                return (MMSYSERR_BADDEVICEID);

            wic.szPname[SIZEOF(wic.szPname) - 1] = '\0';

            mxl.Target.dwType         = MIXERLINE_TARGETTYPE_WAVEIN;
            mxl.Target.dwDeviceID     = PtrToUlong(hmxobj);
            mxl.Target.wMid           = wic.wMid;
            mxl.Target.wPid           = wic.wPid;
            mxl.Target.vDriverVersion = wic.vDriverVersion;
            lstrcpy(mxl.Target.szPname, wic.szPname);
            break;
        }


        case MIXER_OBJECTF_HMIDIOUT:
            mmr = midiOutGetID((HMIDIOUT)hmxobj, (UINT FAR *)&hmxobj);
            if (MMSYSERR_NOERROR != mmr)
                return (MMSYSERR_INVALHANDLE);

        case MIXER_OBJECTF_MIDIOUT:
        {
            MIDIOUTCAPS     moc;

            mmr = midiOutGetDevCaps((UINT_PTR)hmxobj, &moc, sizeof(moc));
            if (MMSYSERR_NOERROR != mmr)
                return (MMSYSERR_BADDEVICEID);

            moc.szPname[SIZEOF(moc.szPname) - 1] = '\0';

            mxl.Target.dwType         = MIXERLINE_TARGETTYPE_MIDIOUT;
            mxl.Target.dwDeviceID     = PtrToUlong(hmxobj);
            mxl.Target.wMid           = moc.wMid;
            mxl.Target.wPid           = moc.wPid;
            mxl.Target.vDriverVersion = moc.vDriverVersion;
            lstrcpy(mxl.Target.szPname, moc.szPname);
            break;
        }


        case MIXER_OBJECTF_HMIDIIN:
            mmr = midiInGetID((HMIDIIN)hmxobj, (UINT FAR *)&hmxobj);
            if (MMSYSERR_NOERROR != mmr)
                return (MMSYSERR_INVALHANDLE);

        case MIXER_OBJECTF_MIDIIN:
        {
            MIDIINCAPS      mic;

            mmr = midiInGetDevCaps((UINT_PTR)hmxobj, &mic, sizeof(mic));
            if (MMSYSERR_NOERROR != mmr)
                return (MMSYSERR_BADDEVICEID);

            mic.szPname[SIZEOF(mic.szPname) - 1] = '\0';

            mxl.Target.dwType         = MIXERLINE_TARGETTYPE_MIDIIN;
            mxl.Target.dwDeviceID     = PtrToUlong(hmxobj);
            mxl.Target.wMid           = mic.wMid;
            mxl.Target.wPid           = mic.wPid;
            mxl.Target.vDriverVersion = mic.vDriverVersion;
            lstrcpy(mxl.Target.szPname, mic.szPname);
            break;
        }


        case MIXER_OBJECTF_AUX:
        {
            AUXCAPS         ac;

            mmr = auxGetDevCaps((UINT_PTR)hmxobj, &ac, sizeof(ac));
            if (MMSYSERR_NOERROR != mmr)
                return (MMSYSERR_BADDEVICEID);

            ac.szPname[SIZEOF(ac.szPname) - 1] = '\0';

            mxl.Target.dwType         = MIXERLINE_TARGETTYPE_AUX;
            mxl.Target.dwDeviceID     = PtrToUlong(hmxobj);
            mxl.Target.wMid           = ac.wMid;
            mxl.Target.wPid           = ac.wPid;
            mxl.Target.vDriverVersion = ac.vDriverVersion;
            lstrcpy(mxl.Target.szPname, ac.szPname);
            break;
        }

        default:
            DebugErr1(DBF_ERROR,
                      "mixerGetID: unknown mixer object flag (%.08lXh).",
                      MIXER_OBJECTF_TYPEMASK & fdwId);
            return (MMSYSERR_INVALFLAG);
    }


    //
    //
    //
    //
    mxl.cbStruct        = sizeof(mxl);
    mxl.dwDestination   = (DWORD)-1L;
    mxl.dwSource        = (DWORD)-1L;
    mxl.dwLineID        = (DWORD)-1L;
    mxl.fdwLine         = 0;
    mxl.dwUser          = 0;
    mxl.dwComponentType = (DWORD)-1L;
    mxl.cChannels       = 0;
    mxl.cConnections    = 0;
    mxl.cControls       = 0;
    mxl.szShortName[0]  = '\0';
    mxl.szName[0]       = '\0';


    for (u = 0; u < guTotalMixerDevs; u++)
    {
        mmr = (MMRESULT)IMixerMessageId(u,
                                        MXDM_GETLINEINFO,
                                        (DWORD_PTR)(LPVOID)&mxl,
                                        MIXER_GETLINEINFOF_TARGETTYPE);

        if (MMSYSERR_NOERROR == mmr)
        {
            *puMxId = u;

            if (NULL != pmxl)
            {
                DWORD       cbStruct;

                cbStruct = pmxl->cbStruct;

                CopyMemory(pmxl, &mxl, (UINT)cbStruct);

                pmxl->cbStruct = cbStruct;
            }

            return (mmr);
        }
    }

    return (MMSYSERR_NODRIVER);
} // IMixerGetID()


/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK API
 *
 *  @api MMRESULT | mixerOpen | The <f mixerOpen> function opens a specified
 *      audio mixer device for use. An application must open a mixer device
 *      if it wishes to receive notifications of mixer line and control
 *      changes. This function also ensures that the device will not be
 *      removed until the application closes the handle.
 *
 *  @parm LPHMIXER | phmx | Points to a variable that will receive a handle
 *      that identifies the opened audio mixer device. Use this handle to
 *      identify the device when calling other audio mixer functions. This
 *      argument may not be NULL. If an application wishes to query for
 *      audio mixer support on a media device, the <f mixerGetID> function
 *      may be used.
 *
 *  @parm UINT | uMxId | Identifies the audio mixer device to open. Use a
 *      valid device identifier or any <c HMIXEROBJ> (see <f mixerGetID> for
 *      a description of mixer object handles). Note that there is currently
 *      no 'mapper' for audio mixer devices, so a mixer device identifier of
 *      '-1' is not valid.
 *
 *  @parm DWORD | dwCallback | Specifies a handle to a window called when the
 *      state of an audio mixer line and/or control associated with the
 *      device being opened is changed. Specify zero for this argument
 *      if no callback mechanism is to be used.
 *
 *  @parm DWORD | dwInstance | This parameter is currently not used and
 *      should be set to zero.
 *
 *  @parm DWORD | fdwOpen | Specifies flags for opening the device.
 *
 *      @flag CALLBACK_WINDOW | If this flag is specified, <p dwCallback> is
 *      assumed to be a window handle.
 *
 *      @flag <c MIXER_OBJECTF_MIXER> | Specifies that <p uMxId> is an audio
 *      mixer device identifier in the range of zero to one less than the
 *      number of devices returned by <f mixerGetNumDevs>. This flag is
 *      optional.
 *
 *      @flag <c MIXER_OBJECTF_HMIXER> | Specifies that <p uMxId> is a mixer
 *      device handle returned by <f mixerOpen>. This flag is optional.
 *
 *      @flag <c MIXER_OBJECTF_WAVEOUT> | Specifies that <p uMxId> is a
 *      waveform output device identifier in the range of zero to one less
 *      than the number of devices returned by <f waveOutGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HWAVEOUT> | Specifies that <p uMxId> is a
 *      waveform output handle returned by <f waveOutOpen>.
 *
 *      @flag <c MIXER_OBJECTF_WAVEIN> | Specifies that <p uMxId> is a
 *      waveform input device identifier in the range of zero to one less
 *      than the number of devices returned by <f waveInGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HWAVEIN> | Specifies that <p uMxId> is a
 *      waveform input handle returned by <f midiInOpen>.
 *
 *      @flag <c MIXER_OBJECTF_MIDIOUT> | Specifies that <p uMxId> is a MIDI
 *      output device identifier in the range of zero to one less than the
 *      number of devices returned by <f midiOutGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HMIDIOUT> | Specifies that <p uMxId> is a
 *      MIDI output handle returned by <f midiOutOpen>.
 *
 *      @flag <c MIXER_OBJECTF_MIDIIN> | Specifies that <p uMxId> is a MIDI
 *      input device identifier in the range of zero to one less than the
 *      number of devices returned by <f midiInGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HMIDIIN> | Specifies that <p uMxId> is a MIDI
 *      input handle returned by <f midiInOpen>.
 *
 *      @flag <c MIXER_OBJECTF_AUX> | Specifies that <p uMxId> is an
 *      auxiliary device identifier in the range of zero to one less than the
 *      number of devices returned by <f auxGetNumDevs>.
 *
 *  @rdesc The return value is zero if the function is successful. Otherwise,
 *      it returns a non-zero error number. Possible error returns include
 *      the following:
 *
 *      @flag <c MMSYSERR_BADDEVICEID> | The <p uMxId> argument specifies an
 *      invalid device identifier.
 *
 *      @flag <c MMSYSERR_INVALHANDLE> | The <p uMxId> argument specifies an
 *      invalid handle.
 *
 *      @flag <c MMSYSERR_INVALFLAG> | One or more flags are invalid.
 *
 *      @flag <c MMSYSERR_INVALPARAM> | One or more arguments passed is
 *      invalid.
 *
 *      @flag <c MMSYSERR_NODRIVER> | No audio mixer device is available for
 *      the object specified by <p uMxId>. Note that the location referenced
 *      by <p uMxId> will also contain the value '-1'.
 *
 *      @flag <c MMSYSERR_ALLOCATED> | The specified resource is already
 *      allocated by the maximum number of clients possible.
 *
 *      @flag <c MMSYSERR_NOMEM> | Unable to allocate resources.
 *
 *  @comm Use the <f mixerGetNumDevs> function to determine the number of
 *      audio mixer devices present in the system. The device identifier
 *      specified by <p uMxId> varies from zero to one less than the number
 *      of devices present.
 *
 *      If a window is chosen to receive callback information, the following
 *      messages are sent to the window procedure function to indicate when
 *      a line or control state changes: <m MM_MIXM_LINE_CHANGE>,
 *      <m MM_MIXM_CONTROL_CHANGE>. <p wParam> is the handle to the mixer
 *      device. <p lParam> is the line identifier for <m MM_MIXM_LINE_CHANGE>
 *      or the control identifier for <m MM_MIXM_CONTROL_CHANGE> that
 *      changed state.
 *
 *  @xref <f mixerClose>, <f mixerGetNumDevs>, <f mixerGetID>,
 *      <f mixerGetLineInfo>
 *
 **/

MMRESULT APIENTRY mixerOpen(
    LPHMIXER                phmx,
    UINT                    uMxId,
    DWORD_PTR               dwCallback,
    DWORD_PTR               dwInstance,
    DWORD                   fdwOpen
)
{
    MMRESULT        mmr;
    PMIXERDRV       pmxdrv;
    UINT            port;
    PMIXERDEV       pmxdev;
    PMIXERDEV       pmxdevRunList;
    MIXEROPENDESC   mxod;
    DWORD_PTR       dwDrvUser;

    //
    //
    //
    V_WPOINTER(phmx, sizeof(HMIXER), MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();

    *phmx = NULL;

    //
    //  Don't allow callback functions - they're not useful and they
    //  cause headaches.   Specifically for Windows NT the only way
    //  to cause an asynchronous callback to 16-bit land from a 32-bit DLL
    //  is to cause an interrupt but we don't want to require mixer stuff
    //  to be locked down to allow for this.
    //

    if ((fdwOpen & CALLBACK_TYPEMASK) == CALLBACK_FUNCTION)
    {
        DebugErr(DBF_ERROR, "mixerOpen: CALLBACK_FUNCTION is not supported");
        return MMSYSERR_INVALFLAG;
    }

    V_DCALLBACK(dwCallback, HIWORD(fdwOpen & CALLBACK_TYPEMASK), MMSYSERR_INVALPARAM);
    V_DFLAGS(fdwOpen, MIXER_OPENF_VALID, mixerOpen, MMSYSERR_INVALFLAG);

    mmr = IMixerGetID((HMIXEROBJ)(UINT_PTR)uMxId, &uMxId, NULL, (MIXER_OBJECTF_TYPEMASK & fdwOpen));
    if (MMSYSERR_NOERROR != mmr)
        return (mmr);


    //
    //
    //
    //
    mmr = mixerReferenceDriverById(uMxId, &pmxdrv, &port);
    if (mmr)
    {
        return mmr;
    }

#ifdef MIXER_MAPPER
    //
    //  Default Mixer Mapper:
    //
    //  If a mixer mapper is installed as a separate DLL then all mixer
    //  mapper messages are routed to it. If no mixer mapper is installed,
    //  simply loop through the mixer devices looking for a match.
    //
    if ((MIXER_MAPPER == uMxId) && (NULL == pmxdrv->drvMessage))
    {
        for (uMxId = 0; uMxId < guTotalMixerDevs; uMxId++)
        {
            // try to open it
            if (MMSYSERR_NOERROR == mmr)
                break;

        }

        mregDecUsagePtr(pmxdrv);
        return (mmr);
    }
#endif


    //
    // Get some memory for the dev structure
    //
    pmxdev = (PMIXERDEV)NewHandle(TYPE_MIXER, pmxdrv->cookie, sizeof(MIXERDEV));
    if (NULL == pmxdev)
    {
    	mregDecUsagePtr(pmxdrv);
        return (MMSYSERR_NOMEM);
    }

    ENTER_MM_HANDLE(pmxdev);
    SetHandleFlag(pmxdev, MMHANDLE_BUSY);
    ReleaseHandleListResource();

    //
    //  initialize our open instance struct for the client
    //
    pmxdev->uHandleType = TYPE_MIXER;
    pmxdev->pmxdrv      = pmxdrv;
    pmxdev->wDevice     = port;
    pmxdev->uDeviceID   = uMxId;
    pmxdev->fdwHandle   = 0;

    //
    //  save the client's callback info
    //
    pmxdev->dwCallback  = dwCallback;
    pmxdev->dwInstance  = dwInstance;
    pmxdev->fdwOpen     = fdwOpen;

    MIXMGR_ENTER;

    //
    // Check to see if we already have this device open
    //
    for (pmxdevRunList = gpMixerDevHeader; pmxdevRunList; pmxdevRunList = pmxdevRunList->pmxdevNext)
    {
    	if (pmxdevRunList->pmxdrv != pmxdrv) continue;
    	if (pmxdevRunList->wDevice != port) continue;
    	break;
    }
         
    //
    // Have we found a match?
    //
    if (NULL != pmxdevRunList)
    {
        //
        // Set the driver's dwUser to the value we got before.
        //
        pmxdev->dwDrvUser = pmxdevRunList->dwDrvUser;

        //
        // We have a match, add the caller to the devlist chain (next in
        // line AFTER the one we just found).
        //
        pmxdev->pmxdevNext = pmxdevRunList->pmxdevNext;
        pmxdevRunList->pmxdevNext = pmxdev;

        ClearHandleFlag(pmxdev, MMHANDLE_BUSY);

        MIXMGR_LEAVE;
        LEAVE_MM_HANDLE(pmxdev);

        //
        // Tell the caller the good news
        //
        *phmx = (HMIXER)pmxdev;

        //
        // All done.  Note we don't dec usage on pmxdrv.
        //
        return (MMSYSERR_NOERROR);
    }
    
    //
    // If we get here, no one has the device currently open.  Let's
    // go open it, then.
    //

    //
    // Load up our local MIXEROPENDESC struct
    //

    mxod.hmx         = (HMIXER)pmxdev;
    mxod.pReserved0  = (LPVOID)NULL;
    mxod.dwCallback  = (DWORD_PTR)MixerCallbackFunc;
    mxod.dwInstance  = (DWORD_PTR)uMxId;
    mxod.dnDevNode   = (DWORD_PTR)pmxdev->pmxdrv->cookie;
    
    EnterCriticalSection(&pmxdrv->MixerCritSec);
    
    mmr = (MMRESULT)((*(pmxdrv->drvMessage))(port,
                                             MXDM_OPEN,
                                             (DWORD_PTR)(LPDWORD)&dwDrvUser,
                                             (DWORD_PTR)(LPVOID)&mxod,
                                             CALLBACK_FUNCTION));
                                        
    LeaveCriticalSection(&pmxdrv->MixerCritSec);

    if (MMSYSERR_NOERROR != mmr)
    {
        //  Should we do this after the MIXMGR_LEAVE???
        LEAVE_MM_HANDLE(pmxdev);
        MIXMGR_LEAVE;
        FreeHandle((HMIXER)pmxdev);
    }
    else
    {
        MIXERCAPS       mxcaps;
        DWORD_PTR       dwParam1, dwParam2;
        MDEVICECAPSEX   mdCaps;

        mregIncUsagePtr(pmxdrv);

        dwParam2 = (DWORD_PTR)pmxdev->pmxdrv->cookie;

        if (0 == dwParam2)
        {
            dwParam1 = (DWORD_PTR)&mxcaps;
            dwParam2 = (DWORD)sizeof(mxcaps);
        }
        else
        {
            mdCaps.cbSize = (DWORD)sizeof(mxcaps);
            mdCaps.pCaps  = &mxcaps;
            dwParam1      = (DWORD_PTR)&mdCaps;
        }

        //  Calling manually since we don't have the HandleList resource...
        EnterCriticalSection(&pmxdrv->MixerCritSec);
        (*(pmxdrv->drvMessage))(port, MXDM_GETDEVCAPS, dwDrvUser, dwParam1, dwParam2);
        LeaveCriticalSection(&pmxdrv->MixerCritSec);

        //
        //  cache some stuff for parameter validation
        //
        pmxdev->fdwSupport    = mxcaps.fdwSupport;
        pmxdev->cDestinations = mxcaps.cDestinations;
        pmxdev->dwDrvUser = dwDrvUser;
        *phmx = (HMIXER)pmxdev;

        //
        // Put this new device into the devlist chain.
        //

        pmxdev->pmxdevNext = gpMixerDevHeader;
        gpMixerDevHeader = pmxdev;
        
        ClearHandleFlag(pmxdev, MMHANDLE_BUSY);
        LEAVE_MM_HANDLE(pmxdev);
        MIXMGR_LEAVE;
    }
    
    mregDecUsagePtr(pmxdrv);

    return (mmr);

} // mixerOpen()


/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK API
 *
 *  @api MMRESULT | mixerClose | The <f mixerClose> function closes the
 *      specified audio mixer device. An application must close all mixer
 *      handles before exiting (or when the application is finished using
 *      the device).
 *
 *  @parm <c HMIXER> | hmx | Specifies a handle to the audio mixer device.
 *      This handle must have been returned successfully by <f mixerOpen>. If
 *      <f mixerClose> is successful, <p hmx> is no longer valid.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag <c MMSYSERR_INVALHANDLE> | Specified device handle is invalid.
 *
 *  @xref <f mixerOpen>
 *
 **/

MMRESULT APIENTRY mixerClose(
    HMIXER                  hmx
)
{
    MMRESULT    mmr;
    PMIXERDEV   pmxdev;
    PMIXERDRV   pmxdrv;
    BOOL        closemixerdriver;

    ClientUpdatePnpInfo();
    
    V_HANDLE_ACQ(hmx, TYPE_MIXER, MMSYSERR_INVALHANDLE);

    ENTER_MM_HANDLE(hmx);
    ReleaseHandleListResource();
    
    if (IsHandleDeserted(hmx))
    {
        //  This handle has been deserted.  Let's just free it.

        LEAVE_MM_HANDLE(hmx);
        FreeHandle(hmx);
        return MMSYSERR_NOERROR;
    }

    //
    //  remove the mixer handle from the linked list
    //
    //  BUGBUG:  We're removing the driver from the list BEFORE we know if 
    //  the close is successful (for the last handle).
    //

    MIXMGR_ENTER;

    pmxdev = (PMIXERDEV)hmx;
    pmxdrv = pmxdev->pmxdrv;

    if (pmxdev == gpMixerDevHeader)
    {
        gpMixerDevHeader = pmxdev->pmxdevNext;
    }
    else
    {
        PMIXERDEV   pmxdevT;
            
        for (pmxdevT = gpMixerDevHeader;
            pmxdevT && (pmxdevT->pmxdevNext != pmxdev);
            pmxdevT = pmxdevT->pmxdevNext)
            ;

        if (NULL == pmxdevT)
        {
            DebugErr1(DBF_ERROR,
                    "mixerClose: invalid mixer handle (%.04Xh).",
                    hmx);

            MIXMGR_LEAVE;
            LEAVE_MM_HANDLE(hmx);

            return (MMSYSERR_INVALHANDLE);
        }

        pmxdevT->pmxdevNext = pmxdev->pmxdevNext;
    }

    //
    // see if this is the last handle on this open instance
    //
    closemixerdriver = TRUE;
    if (gpMixerDevHeader)
    {
        PMIXERDEV pmxdevT;
        for (pmxdevT = gpMixerDevHeader; pmxdevT; pmxdevT = pmxdevT->pmxdevNext)
        {
    	    if (pmxdevT->pmxdrv != pmxdev->pmxdrv) continue;
    	    if (pmxdevT->wDevice != pmxdev->wDevice) continue;
    	    closemixerdriver = FALSE;
    	    break;
        }
    }

    MIXMGR_LEAVE;

    //  handle should be marked as "busy" even if we don't send the driver
    //  message.
    SetHandleFlag(hmx, MMHANDLE_BUSY);

    //
    //  if last open instance, then close it
    //
    mmr = MMSYSERR_NOERROR;
        
    if (closemixerdriver)
    {
        EnterCriticalSection(&pmxdrv->MixerCritSec);
        mmr = (MMRESULT)(*(pmxdrv->drvMessage))(pmxdev->wDevice, MXDM_CLOSE, pmxdev->dwDrvUser, 0L, 0L);
        LeaveCriticalSection(&pmxdrv->MixerCritSec);

        if (MMSYSERR_NOERROR != mmr)
        {
            //  Should we put the handle back in the list???
            ClearHandleFlag(hmx, MMHANDLE_BUSY);
        }
    }

    LEAVE_MM_HANDLE(hmx);
    mregDecUsagePtr(pmxdev->pmxdrv);
        
    if (MMSYSERR_NOERROR == mmr)
    {
        //
        //  we're done with the memory block. now free the memory and return.
        //
        FreeHandle(hmx);
    }

    return (mmr);
} // mixerClose()


/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK API
 *
 *  @api DWORD | mixerMessage | The <f mixerMessage> function sends a user
 *      defined audio mixer driver message directly to a mixer driver.
 *
 *  @parm <c HMIXER> | hmx | Specifies a handle to an open instance of a
 *      mixer device. This handle is returned by <f mixerOpen>.
 *
 *  @parm UINT | uMsg | Specifies the user defined mixer driver message to
 *      send to the mixer driver. This message must be above or equal to
 *      the <m MXDM_USER> message.
 *
 *  @parm DWORD | dwParam1 | Contains the first argument associated with the
 *      message being sent.
 *
 *  @parm DWORD | dwParam2 | Contains the second argument associated with the
 *      message being sent.
 *
 *  @rdesc The return value is specific to the user defined mixer driver
 *      message <p uMsg> sent. However, the following return values are
 *      possible:
 *
 *      @flag <c MMSYSERR_INVALHANDLE> | Specified device handle is invalid.
 *
 *      @flag <c MMSYSERR_INVALPARAM> | <p uMsg> is not in the <m MXDM_USER>
 *      range.
 *
 *      @flag <c MMSYSERR_NOTSUPPORTED> | The mixer device did not process
 *      the message.
 *
 *  @comm The <f mixerMessage> function is provided to allow audio mixer
 *      driver specific messages to be sent to a mixer device. The messages
 *      that may be sent through this function must be above or equal to the
 *      <m MXDM_USER> message.
 *
 *      User defined messages must only be sent to a mixer driver that
 *      specifically supports the messages. The caller should verify that
 *      the mixer driver is in fact the correct driver by getting the
 *      mixer capabilities and checking the <e MIXERCAPS.wMid>,
 *      <e MIXERCAPS.wPid>, <e MIXERCAPS.vDriverVersion> and
 *      <e MIXERCAPS.szPname> members of the <t MIXERCAPS> structure.
 *
 *      It is important for an application to verify all members specified
 *      above due to many driver writers releasing drivers with improper
 *      or unregistered manufacturer and product identifiers.
 *
 *      Never send user defined messages to an unknown audio mixer driver.
 *
 *  @xref <f mixerOpen>, <f mixerGetDevCaps>
 *
 **/

DWORD APIENTRY mixerMessage(
    HMIXER                  hmx,
    UINT                    uMsg,
    DWORD_PTR               dwParam1,
    DWORD_PTR               dwParam2
)
{
    DWORD       dw;

    ClientUpdatePnpInfo();

    AcquireHandleListResourceShared();

    if (BAD_HANDLE(hmx, TYPE_MIXER))
    {
        ReleaseHandleListResource();
        return IMixerMessageId (PtrToUint(hmx), uMsg, dwParam1, dwParam2);
    }

    //
    //  don't allow any non-user range messages through this API
    //
    if (MXDM_USER > uMsg)
    {
        DebugErr1(DBF_ERROR, "mixerMessage: message must be in MXDM_USER range--what's this (%u)?", uMsg);
        ReleaseHandleListResource();
        return (MMSYSERR_INVALPARAM);
    }


    dw = IMixerMessageHandle(hmx, uMsg, dwParam1, dwParam2);

    return (dw);

} // mixerMessage()


//--------------------------------------------------------------------------;
//
//  BOOL IMixerIsValidComponentType
//
//  Description:
//
//
//  Arguments:
//      DWORD dwComponentType:
//
//      UINT uSrcDst:
//
//  Return (BOOL):
//
//  History:
//      10/06/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL IMixerIsValidComponentType
(
    DWORD           dwComponentType,
    DWORD           fdwLine
)
{

    if (0 == (MIXERLINE_LINEF_SOURCE & fdwLine))
    {
        if (dwComponentType > MIXERLINE_COMPONENTTYPE_DST_LAST)
            return (FALSE);

        return (TRUE);
    }
    else
    {
        if (dwComponentType < MIXERLINE_COMPONENTTYPE_SRC_FIRST)
            return (FALSE);

        if (dwComponentType > MIXERLINE_COMPONENTTYPE_SRC_LAST)
            return (FALSE);

        return (TRUE);
    }

} // IMixerIsValidComponentType()



/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK STRUCTURE
 *
 *  @types MIXERLINE | The <t MIXERLINE> structure describes the state
 *      and metrics of an audio mixer device line.
 *
 *  @syntaxex
 *      typedef struct tMIXERLINE
 *      {
 *          DWORD       cbStruct;
 *          DWORD       dwDestination;
 *          DWORD       dwSource;
 *          DWORD       dwLineID;
 *          DWORD       fdwLine;
 *          DWORD       dwUser;
 *          DWORD       dwComponentType;
 *          DWORD       cChannels;
 *          DWORD       cConnections;
 *          DWORD       cControls;
 *          char        szShortName[MIXER_SHORT_NAME_CHARS];
 *          char        szName[MIXER_LONG_NAME_CHARS];
 *          struct
 *          {
 *              DWORD       dwType;
 *              DWORD       dwDeviceID;
 *              WORD        wMid;
 *              WORD        wPid;
 *              MMVERSION   vDriverVersion;
 *              char        szPname[MAXPNAMELEN];
 *          } Target;
 *      } MIXERLINE;
 *
 *  @field DWORD | cbStruct | Specifies the size, in bytes, of the
 *      <t MIXERLINE> structure. This member must be initialized before
 *      calling the <f mixerGetLineInfo> function. The size specified in this
 *      member must be large enough to contain the base <t MIXERLINE>
 *      structure. When the <f mixerGetLineInfo> function returns, this
 *      member contains the actual size of the information returned. The
 *      returned information will never exceed the requested size.
 *
 *  @field DWORD | dwDestination | Specifies the destination line index.
 *      This member ranges from zero to one less than the value specified
 *      in the <e MIXERCAPS.cDestinations> member of the <t MIXERCAPS>
 *      structure retrieved by the <f mixerGetDevCaps> function. When the
 *      <f mixerGetLineInfo> function is called with the
 *      <c MIXER_GETLINEINFOF_DESTINATION> flag specified, the details for
 *      the destination line are returned. Note that the
 *      <e MIXERLINE.dwSource> member must be set to zero in this case. When
 *      called with the <c MIXER_GETLINEINFOF_SOURCE> flag specified, the
 *      details for the source given by the <e MIXERLINE.dwSource> member
 *      associated with the <e MIXERLINE.dwDestination> member are returned.
 *
 *  @field DWORD | dwSource | Specifies the source line index for the source
 *      line associated with the <e MIXERLINE.dwDestination> member. That
 *      is, this member specifies the nth source line associated with the
 *      specified destination line. This member is not used for destination
 *      lines and must be set to zero when <c MIXER_GETLINEINFOF_DESTINATION>
 *      is specified for <f mixerGetLineInfo>. When the
 *      <c MIXER_GETLINEINFOF_SOURCE> flag is specified, this member ranges
 *      from zero to one less than the value specified in the
 *      <e MIXERLINE.cConnections> of the <t MIXERLINE> structure for the
 *      destination line given in the <e MIXERLINE.dwDestination> member.
 *
 *  @field DWORD | dwLineID | Specifies an audio mixer defined identifier
 *      that uniquely refers to the line described by the <t MIXERLINE>
 *      structure. This identifier is unique only to a single mixer device
 *      and may be of any format that the mixer device wishes. An application
 *      should only use this identifier as an abstract handle. No two
 *      lines for a single mixer device will have the same line identifier
 *      under any circumstances.
 *
 *  @field DWORD | fdwLine | Specifies status and support flags for the
 *      audio mixer line. This member is always returned to the application
 *      and requires no initialization.
 *
 *      @flag <c MIXERLINE_LINEF_SOURCE> | Specifies that this audio mixer
 *      line is a source line associated with a single destination line. If
 *      this flag is not set, then this line is a destination line associated
 *      with zero or more source lines.
 *
 *      @flag <c MIXERLINE_LINEF_DISCONNECTED> | Specifies that this audio
 *      mixer line is disconnected. A disconnected line's associated controls
 *      can still be modified but the changes will have no effect until the
 *      line becomes connected. An application may want to modify its
 *      behavior if a mixer line is disconnected.
 *
 *      @flag <c MIXERLINE_LINEF_ACTIVE> | Specifies that this audio mixer
 *      line is active. An active line specifies that a signal is (probably)
 *      passing through the line. For example, if a waveform output device
 *      is not in use by an application, then the line associated with that
 *      device would not be active (the <c MIXERLINE_LINEF_ACTIVE> flag would
 *      not be set). If the waveform output device is opened, then the
 *      the line is considered active and the <c MIXERLINE_LINEF_ACTIVE> flag
 *      will be set. Note that a 'paused' or 'starved' waveform output device
 *      is still considered active. In other words, if the waveform output
 *      device is opened by an application regardless of whether data is
 *      being played, the associated line is considered active. If a line
 *      cannot be strictly defined as 'active' verses 'inactive', then the
 *      audio mixer device will always set the <c MIXERLINE_LINEF_ACTIVE>
 *      flag. An example of where this information can be used by an
 *      application is displaying a 'peak meter.' Peak meters are polled
 *      meters. An application may want to disable its polling timer while
 *      the line is inactive to improve system performance. Note that the
 *      <c MIXERLINE_LINEF_ACTIVE> flag is also affected by the status of
 *      the mixer line's mute control. Muted mixer lines are never active.
 *
 *  @field DWORD | dwUser | Specifies 32-bits of audio mixer device defined
 *      instance data for the line. This member is intended for custom
 *      audio mixer applications designed specifically for the mixer device
 *      returning this information. An application that is not specifically
 *      tailored to understand this member should simply ignore this data.
 *
 *  @field DWORD | dwComponentType | Specifies the component type for this
 *      line. An application may use this information to display tailored
 *      graphics or search for a particular component. If an application
 *      does not know about a component type, then this member should be
 *      ignored. Currently, this member may be one of the following values:
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_DST_UNDEFINED> | Specifies that the
 *      line is a destination that cannot be defined by one of the standard
 *      component types. An audio mixer device is required to use this
 *      component type for line component types that have not been defined
 *      by Microsoft.
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_DST_DIGITAL> | Specifies that the
 *      line is a digital destination (for example, digital input to a DAT
 *      or CD Audio Disc).
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_DST_LINE> | Specifies that the line
 *      is a line level destination (for example, line level input from
 *      a CD Audio Disc) that will be the final recording source for the
 *      ADC. Most audio cards for the PC provide some sort of gain for the
 *      recording source line, so the mixer device will use the
 *      <c MIXERLINE_COMPONENTTYPE_DST_WAVEIN> type.
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_DST_MONITOR> | Specifies that the
 *      line is a destination used for a monitor.
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_DST_SPEAKERS> | Specifies that the
 *      line is an adjustable (gain and/or attenuation) destination intended
 *      to drive speakers. This is the normal component type for the audio
 *      output of most audio cards for the PC.
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_DST_HEADPHONES> | Specifies that the
 *      line is an adjustable (gain and/or attenuation) destination intended
 *      to driver headphones. Most audio cards use the same destination
 *      line for speakers and headphones--in which case the mixer device
 *      will simply use the <c MIXERLINE_COMPONENTTYPE_DST_SPEAKERS> type.
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_DST_TELEPHONE> | Specifies that the
 *      line is a destination that will be routed to the telephone line.
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_DST_WAVEIN> | Specifies that the
 *      line is a destination that will be the final recording source for the
 *      waveform input (ADC). This line will normally provide some sort of
 *      gain or attenuation. This is the normal component type for the
 *      recording line of most audio cards for the PC.
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_DST_VOICEIN> | Specifies that the
 *      line is a destination that will be the final recording source for
 *      voice input. This component type is exactly like
 *      <c MIXERLINE_COMPONENTTYPE_DST_WAVEIN> but is intended specifically
 *      for settings used during voice recording/recognition. This line
 *      is entirely optional for a mixer device to support--many mixer
 *      devices may only provide <c MIXERLINE_COMPONENTTYPE_DST_WAVEIN>.
 *
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_SRC_UNDEFINED> | Specifies that the
 *      line is a source that cannot be defined by one of the standard
 *      component types. An audio mixer device is required to use this
 *      component type for line component types that have not been defined
 *      by Microsoft.
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_SRC_DIGITAL> | Specifies that the
 *      line is a digital source (for example, digital output from a DAT or
 *      CD Audio Disc).
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_SRC_LINE> | Specifies that the line
 *      is a line level source (for example, line level input from
 *      an external stereo) that will be used as a, perhaps, optional source
 *      for recording. Most audio cards for the PC provide some sort of gain
 *      for the recording source line, so the mixer device will use the
 *      <c MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY> type.
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE> | Specifies that the
 *      line is a microphone recording source. Most audio cards for the
 *      PC provide at least two types of recording sources: an auxiliary
 *      line and microphone input. A microphone line normally provides
 *      some sort of gain. Audio cards that use a single input for use
 *      with a microphone or auxiliary line should use the
 *      <c MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE> component type.
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER> | Specifies that
 *      the line is a source originating from the output of an internal
 *      synthesizer. Most audio cards for the PC provide some sort of
 *      MIDI synthesizer (for example, an Ad Lib compatible or OPL/3 FM
 *      synthesizer).
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC> | Specifies that
 *      the line is a source originating from the output of an internal audio
 *      compact disc. This component type is provided for those audio cards
 *      that provide a source line solely intended to be connected to an
 *      audio compact disc (or CD-ROM playing a Redbook Audio CD).
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_SRC_TELEPHONE> | Specifies that the
 *      line is a source originating from an incoming telephone line.
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_SRC_PCSPEAKER> | Specifies that the
 *      line is a source originating from the PC speaker. Several audio cards
 *      for the PC provide the ability to mix what would normally be played
 *      on the internal speaker with the output of an audio card. The
 *      ability to use this output as a source for recording has also been
 *      exploited by some audio cards.
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT> | Specifies that the
 *      line is a source originating from the waveform output (DAC). Most
 *      cards for the PC provide this component type as a source to the
 *      <c MIXERLINE_COMPONENTTYPE_DST_SPEAKERS> destination. Some cards will
 *      also allow this source to be routed to the
 *      <c MIXERLINE_COMPONENTTYPE_DST_WAVEIN> destination.
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY> | Specifies that the
 *      line is a source originating from the auxiliary line. This line type
 *      is intended as a source with gain or attenuation that can be routed
 *      to the <c MIXERLINE_COMPONENTTYPE_DST_SPEAKERS> destination and/or
 *      recorded from through the <c MIXERLINE_COMPONENTTYPE_DST_WAVEIN>
 *      destination.
 *
 *      @flag <c MIXERLINE_COMPONENTTYPE_SRC_ANALOG> | Specifies that the
 *      line is a source originating from one or more lines. This line type
 *      is intended for audio mixers that can mix multiple lines into a
 *      single source for that can be routed to the
 *      <c MIXERLINE_COMPONENTTYPE_DST_SPEAKERS> destination and/or
 *      recorded from through the <c MIXERLINE_COMPONENTTYPE_DST_WAVEIN>
 *      destination.
 *
 *  @field DWORD | cChannels | Specifies the maximum number of separate
 *      channels that can be manipulated independantly for the line. Most
 *      of the modern audio cards for the PC are stereo devices, so this
 *      member will be two. Channel one is assumed to be the left channel;
 *      channel two is assumed to be the right channel. Note that a
 *      multi-channel line may have one or more uniform controls (controls
 *      that affect all channels of a line uniformly) associated with it.
 *      An example of a uniform control is a Mute that mutes all channels
 *      of a line simultaneously. A line must have at least one channel--
 *      this member will never be zero.
 *
 *  @field DWORD | cConnections | Specifies the number of connections that
 *      are associated with the line. Currently, this member is used only
 *      for destination lines and specifies the number of source lines
 *      that are associated with it. This number may be zero. For source
 *      lines, this member is always zero.
 *
 *  @field DWORD | cControls | Specifies the number of controls associated
 *      with the line. This value may be zero. If no controls are associated
 *      with the line, then the line is probably (but not always) just a
 *      source that may be selected in a MUX or Mixer but allows no
 *      manipulation of the signal. For example, a digital source may have
 *      this attribute.
 *
 *  @field char | szShortName[<c MIXER_SHORT_NAME_CHARS>] | Specifies a short
 *      string that describes the <e MIXERLINE.dwLineID> audio mixer line.
 *      This description is appropriate for using as a displayable label for
 *      the line that can fit in small spaces.
 *
 *  @field char | szName[<c MIXER_LONG_NAME_CHARS>] | Specifies a string
 *      that describes the <e MIXERLINE.dwLineID> audio mixer line. This
 *      description is appropriate for using as a displayable description
 *      for the line that is not limited by screen space.
 *
 *  @field struct | Target | Contains the target media information.
 *
 *  @field2 DWORD | dwType | Specifies the target media device type
 *      associated with the audio mixer line described in the <t MIXERLINE>
 *      structure. An application must ignore target information for media
 *      device types that it does not understand. Currently, this member may
 *      be one of the following:
 *
 *      @flag <c MIXERLINE_TARGETTYPE_UNDEFINED> | Specifies that the line
 *      described by this <t MIXERLINE> structure is not strictly bound
 *      to a defined media type. All remaining <e MIXERLINE.Target> structure
 *      members of the <t MIXERLINE> structure should be ignored. Note that
 *      an application may not use the <c MIXERLINE_TARGETTYPE_UNDEFINED>
 *      target type when calling the <f mixerGetLineInfo> function with the
 *      <c MIXER_GETLINEINFOF_TARGETTYPE> flag.
 *
 *      @flag <c MIXERLINE_TARGETTYPE_WAVEOUT> | Specifies that the line
 *      described by this <t MIXERLINE> structure is strictly bound to
 *      the waveform output device detailed in the remaining members of
 *      the <e MIXERLINE.Target> structure member of the <t MIXERLINE>
 *      structure.
 *
 *      @flag <c MIXERLINE_TARGETTYPE_WAVEIN> | Specifies that the line
 *      described by this <t MIXERLINE> structure is strictly bound to
 *      the waveform input device detailed in the remaining members of
 *      the <e MIXERLINE.Target> structure member of the <t MIXERLINE>
 *      structure.
 *
 *      @flag <c MIXERLINE_TARGETTYPE_MIDIOUT> | Specifies that the line
 *      described by this <t MIXERLINE> structure is strictly bound to
 *      the MIDI output device detailed in the remaining members of
 *      the <e MIXERLINE.Target> structure member of the <t MIXERLINE>
 *      structure.
 *
 *      @flag <c MIXERLINE_TARGETTYPE_MIDIIN> | Specifies that the line
 *      described by this <t MIXERLINE> structure is strictly bound to
 *      the MIDI input device detailed in the remaining members of
 *      the <e MIXERLINE.Target> structure member of the <t MIXERLINE>
 *      structure.
 *
 *      @flag <c MIXERLINE_TARGETTYPE_AUX> | Specifies that the line
 *      described by this <t MIXERLINE> structure is strictly bound to
 *      the auxiliary device detailed in the remaining members of
 *      the <e MIXERLINE.Target> structure member of the <t MIXERLINE>
 *      structure.
 *
 *  @field2 DWORD | dwDeviceID | In the case of the
 *      <e MIXERLINE.dwType> member being a target type other than
 *      <c MIXERLINE_TARGETTYPE_UNDEFINED>, this member is the current device
 *      identifier of the target media device. This identifier is identical
 *      to the current media device index of the associated media device.
 *      Note that when calling the <f mixerGetLineInfo> function with
 *      the <c MIXER_GETLINEINFOF_TARGETTYPE> flag, this member is ignored on
 *      input and will be returned to the caller by the audio mixer manager.
 *
 *  @field2 WORD | wMid | In the case of the <e MIXERLINE.dwType>
 *      member being a target type other than <c MIXERLINE_TARGETTYPE_UNDEFINED>,
 *      this member is the manufacturer identifier of the target media device.
 *      This identifier is identical to the wMid member of the associated
 *      media device capabilities structure.
 *
 *  @field WORD | wPid | In the case of the <e MIXERLINE.dwType>
 *      member being a target type other than <c MIXERLINE_TARGETTYPE_UNDEFINED>,
 *      this member is the product identifier of the target media device.
 *      This identifier is identical to the wPid member of the associated
 *      media device capabilities structure.
 *
 *  @field2 MMVERSION | vDriverVersion | In the case of the
 *      <e MIXERLINE.dwType> member being a target type other than
 *      <c MIXERLINE_TARGETTYPE_UNDEFINED>, this member is the driver version
 *      of the target media device. This version is identical to the
 *      vDriverVersion member of the associated media device capabilities
 *      structure.
 *
 *  @field char | szPname[MAXPNAMELEN] | In the case of the
 *      <e MIXERLINE.dwType> member being a target type other than
 *      <c MIXERLINE_TARGETTYPE_UNDEFINED>, this member is the product
 *      name of the target media device. This name is identical to the
 *      szPname member of the associated media device capabilities structure.
 *
 *  @tagname tMIXERLINE
 *
 *  @othertype MIXERLINE FAR * | LPMIXERLINE | A pointer to a <t MIXERLINE>
 *      structure.
 *
 *  @othertype MIXERLINE * | PMIXERLINE | A pointer to a <t MIXERLINE>
 *      structure.
 *
 *  @xref <f mixerGetLineInfo>, <f mixerGetDevCaps>
 *
 **/

/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK API
 *
 *  @api MMRESULT | mixerGetLineInfo | The <f mixerGetLineInfo> function
 *      retrieves information about a specified audio mixer devices 'line'.
 *
 *  @parm <c HMIXEROBJ> | hmxobj | Specifies a handle to the audio mixer
 *      device object to get line information from.
 *
 *  @parm LPMIXERLINE | pmxl | Points to a <t MIXERLINE> structure. This
 *      structure is filled with information about the mixer line for the
 *      audio mixer device. See the comments for each query flag passed
 *      through <p fdwInfo> for details on what members of the <t MIXERLINE>
 *      structure must be initialized before calling <f mixerGetLineInfo>.
 *      Note that in all cases, <e MIXERLINE.cbStruct> must be initialized
 *      to be the size, in bytes, of the <t MIXERLINE> structure.
 *
 *  @parm DWORD | fdwInfo | Specifies flags for getting information on a
 *      mixer line.
 *
 *      @flag <c MIXER_GETLINEINFOF_DESTINATION> | If this flag is specified,
 *      <p pmxl> is to receive information on the destination line
 *      specified by the <e MIXERLINE.dwDestination> member of the
 *      <t MIXERLINE> structure. This index ranges from zero to one less
 *      than <e MIXERCAPS.cDestinations> of the <t MIXERCAPS> structure.
 *      All remaining structure members except <e MIXERLINE.cbStruct> require
 *      no further initialization.
 *
 *      @flag <c MIXER_GETLINEINFOF_SOURCE> | If this flag is specified,
 *      <p pmxl> is to receive information on the source line specified by
 *      the <e MIXERLINE.dwDestination> and <e MIXERLINE.dwSource> members
 *      of the <t MIXERLINE> structure. The index specified by
 *      <e MIXERLINE.dwDestination> ranges from zero to one less than
 *      <e MIXERCAPS.cDestinations> of the <t MIXERCAPS> structure. The
 *      index specified by for <e MIXERLINE.dwSource> ranges from
 *      zero to one less than the <e MIXERLINE.cConnections> member of the
 *      <t MIXERLINE> structure returned for the <e MIXERLINE.dwDestination>
 *      line. All remaining structure members except <e MIXERLINE.cbStruct>
 *      require no further initialization.
 *
 *      @flag <c MIXER_GETLINEINFOF_LINEID> | If this flag is specified,
 *      <p pmxl> is to receive information on the line specified by the
 *      <e MIXERLINE.dwLineID> member of the <t MIXERLINE> structure. This
 *      is usually used to retrieve updated information on a line's state.
 *      All remaining structure members except <e MIXERLINE.cbStruct> require
 *      no further initialization.
 *
 *      @flag <c MIXER_GETLINEINFOF_COMPONENTTYPE> | If this flag is
 *      specified, <p pmxl> is to receive information on the first line of
 *      the type specified in the <e MIXERLINE.dwComponentType> member of the
 *      <t MIXERLINE> structure. This is used to retrieve information
 *      on a line that is of a specific component type (for example, an
 *      application could specify <c MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE>
 *      to retrieve information on the first Microphone input associated
 *      with the specified <p hmxobj>). All remaining structure members
 *      except <e MIXERLINE.cbStruct> require no further initialization.
 *
 *      @flag <c MIXER_GETLINEINFOF_TARGETTYPE> | If this flag is specified,
 *      <p pmxl> is to receive information on the line that is for the
 *      <e MIXERLINE.dwType> of the <t MIXERLINE> structure. This is
 *      used to retrieve information on a line that handles the target
 *      type (<c MIXERLINE_TARGETTYPE_WAVEOUT> for example). An application
 *      must initialize <e MIXERLINE.dwType>, <e MIXERLINE.wMid>,
 *      <e MIXERLINE.wPid>, <e MIXERLINE.vDriverVersion> and
 *      <e MIXERLINE.szPname> of the <t MIXERLINE> structure before
 *      calling <f mixerGetLineInfo>. All of these values can be retrieved
 *      from the device capabilities structures for all media devices. All
 *      remaining structure members except <e MIXERLINE.cbStruct> require
 *      no further initialization.
 *
 *      @flag <c MIXER_OBJECTF_MIXER> | Specifies that <p hmxobj> is an audio
 *      mixer device identifier in the range of zero to one less than the
 *      number of devices returned by <f mixerGetNumDevs>. This flag is
 *      optional.
 *
 *      @flag <c MIXER_OBJECTF_HMIXER> | Specifies that <p hmxobj> is a mixer
 *      device handle returned by <f mixerOpen>. This flag is optional.
 *
 *      @flag <c MIXER_OBJECTF_WAVEOUT> | Specifies that <p hmxobj> is a
 *      waveform output device identifier in the range of zero to one less
 *      than the number of devices returned by <f waveOutGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HWAVEOUT> | Specifies that <p hmxobj> is a
 *      waveform output handle returned by <f waveOutOpen>.
 *
 *      @flag <c MIXER_OBJECTF_WAVEIN> | Specifies that <p hmxobj> is a
 *      waveform input device identifier in the range of zero to one less
 *      than the number of devices returned by <f waveInGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HWAVEIN> | Specifies that <p hmxobj> is a
 *      waveform input handle returned by <f midiInOpen>.
 *
 *      @flag <c MIXER_OBJECTF_MIDIOUT> | Specifies that <p hmxobj> is a MIDI
 *      output device identifier in the range of zero to one less than the
 *      number of devices returned by <f midiOutGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HMIDIOUT> | Specifies that <p hmxobj> is a
 *      MIDI output handle returned by <f midiOutOpen>.
 *
 *      @flag <c MIXER_OBJECTF_MIDIIN> | Specifies that <p hmxobj> is a MIDI
 *      input device identifier in the range of zero to one less than the
 *      number of devices returned by <f midiInGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HMIDIIN> | Specifies that <p hmxobj> is a MIDI
 *      input handle returned by <f midiInOpen>.
 *
 *      @flag <c MIXER_OBJECTF_AUX> | Specifies that <p hmxobj> is an
 *      auxiliary device identifier in the range of zero to one less than the
 *      number of devices returned by <f auxGetNumDevs>.
 *
 *  @rdesc The return value is zero if the function is successful. Otherwise,
 *      it returns a non-zero error number. Possible error returns include
 *      the following:
 *
 *      @flag <c MMSYSERR_BADDEVICEID> | The <p hmxobj> argument specifies an
 *      invalid device identifier.
 *
 *      @flag <c MMSYSERR_INVALHANDLE> | The <p hmxobj> argument specifies an
 *      invalid handle.
 *
 *      @flag <c MMSYSERR_INVALFLAG> | One or more flags are invalid.
 *
 *      @flag <c MMSYSERR_INVALPARAM> | One or more arguments passed is
 *      invalid.
 *
 *      @flag <c MMSYSERR_NODRIVER> | No audio mixer device is available for
 *      the object specified by <p hmxobj>.
 *
 *      @flag <c MIXERR_INVALLINE> | The audio mixer device line reference is
 *      invalid.
 *
 *  @xref <t MIXERLINE>, <f mixerOpen>, <f mixerGetDevCaps>, <t MIXERCAPS>,
 *      <f mixerGetLineControls>
 *
 **/

MMRESULT APIENTRY mixerGetLineInfoA(
    HMIXEROBJ               hmxobj,
    LPMIXERLINEA            pmxlA,
    DWORD                   fdwInfo
)
{
    MIXERLINEW              mxlW;
    MMRESULT                mmr;

    //
    //  Validate the mixer line info pointer
    //

    V_WPOINTER(pmxlA, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (pmxlA->cbStruct < sizeof(MIXERLINEA)) {
        return MMSYSERR_INVALPARAM;
    }
    V_WPOINTER(pmxlA, pmxlA->cbStruct, MMSYSERR_INVALPARAM);

    //
    //  Call the UNICODE version to get the full set of data
    //

    CopyMemory((PVOID)&mxlW, (PVOID)pmxlA, FIELD_OFFSET(MIXERLINE, cChannels));
    mxlW.cbStruct = sizeof(mxlW);

    //
    //  If target stuff wanted we must set the target data
    //

    if ((fdwInfo & MIXER_GETLINEINFOF_QUERYMASK) ==
        MIXER_GETLINEINFOF_TARGETTYPE) {
        CopyMemory((PVOID)&mxlW.Target.dwType, (PVOID)&pmxlA->Target.dwType,
                   FIELD_OFFSET(MIXERLINE, Target.szPname[0]) -
                   FIELD_OFFSET(MIXERLINE, Target.dwType));

        Imbstowcs(mxlW.Target.szPname, pmxlA->Target.szPname, MAXPNAMELEN);
    }

    //
    //  Set the relevant values
    //

    mmr = mixerGetLineInfo(hmxobj, &mxlW, fdwInfo);

    if (mmr != MMSYSERR_NOERROR) {
        return mmr;
    }

    //
    //  Massage the return data to ASCII
    //

    ConvertMIXERLINEWToMIXERLINEA(pmxlA, &mxlW);

    return mmr;
} // mixerGetLineInfoA()

MMRESULT APIENTRY mixerGetLineInfo(
    HMIXEROBJ               hmxobj,
    LPMIXERLINE             pmxl,
    DWORD                   fdwInfo
)
{
    DWORD               fdwMxObjType;
    MMRESULT            mmr;
    PMIXERDEV           pmxdev;
//  UINT                cb;
    UINT                uMxId;
    BOOL                fSourceLine, fResource;

    V_DFLAGS(fdwInfo, MIXER_GETLINEINFOF_VALID, mixerGetLineInfo, MMSYSERR_INVALFLAG);
    V_WPOINTER(pmxl, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(MIXERLINE) > pmxl->cbStruct)
    {
        DebugErr1(DBF_ERROR, "mixerGetLineInfo: structure size too small or cbStruct not initialized (%lu).", pmxl->cbStruct);
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pmxl, pmxl->cbStruct, MMSYSERR_INVALPARAM);


    ClientUpdatePnpInfo();

    //
    //
    //
    fSourceLine = FALSE;
    switch (fdwInfo & MIXER_GETLINEINFOF_QUERYMASK)
    {
        case MIXER_GETLINEINFOF_DESTINATION:
            pmxl->dwSource        = (DWORD)-1L;
            pmxl->dwLineID        = (DWORD)-1L;
            pmxl->dwComponentType = (DWORD)-1L;
            break;

        case MIXER_GETLINEINFOF_SOURCE:
            fSourceLine = TRUE;
            pmxl->dwLineID        = (DWORD)-1L;
            pmxl->dwComponentType = (DWORD)-1L;
            break;

        case MIXER_GETLINEINFOF_LINEID:
            pmxl->dwSource        = (DWORD)-1L;
            pmxl->dwDestination   = (DWORD)-1L;
            pmxl->dwComponentType = (DWORD)-1L;
            break;

        case MIXER_GETLINEINFOF_COMPONENTTYPE:
            pmxl->dwSource        = (DWORD)-1L;
            pmxl->dwDestination   = (DWORD)-1L;
            pmxl->dwLineID        = (DWORD)-1L;

            if (!IMixerIsValidComponentType(pmxl->dwComponentType, 0) &&
                !IMixerIsValidComponentType(pmxl->dwComponentType, MIXERLINE_LINEF_SOURCE))
            {
                DebugErr1(DBF_ERROR, "mixerGetLineInfo: invalid dwComponentType (%lu).", pmxl->dwComponentType);
                return (MMSYSERR_INVALPARAM);
            }
            break;

        case MIXER_GETLINEINFOF_TARGETTYPE:
            pmxl->dwSource        = (DWORD)-1L;
            pmxl->dwDestination   = (DWORD)-1L;
            pmxl->dwLineID        = (DWORD)-1L;
            pmxl->dwComponentType = (DWORD)-1L;

            if (MIXERLINE_TARGETTYPE_AUX < pmxl->Target.dwType)
            {
                DebugErr1(DBF_ERROR, "mixerGetLineInfo: invalid Target.dwType (%lu).", pmxl->Target.dwType);
                return (MMSYSERR_INVALPARAM);
            }
            break;

        default:
            DebugErr1(DBF_ERROR, "mixerGetLineInfo: invalid query flag (%.08lXh).",
                        fdwInfo & MIXER_GETLINEINFOF_QUERYMASK);
            return (MMSYSERR_INVALFLAG);
    }



    //
    //
    //
    fdwMxObjType = (MIXER_OBJECTF_TYPEMASK & fdwInfo);

    fResource = FALSE;

    AcquireHandleListResourceShared();
    
    //  Checking for the type of mixer object.  If it is a non-mixer type
    //  calling IMixerMesssageID (called by IMixerGetID) with the shared
    //  resource will deadlock.
    if ((MIXER_OBJECTF_MIXER  == fdwMxObjType) ||
        (MIXER_OBJECTF_HMIXER == fdwMxObjType))
    {
        if (BAD_HANDLE(hmxobj, TYPE_MIXER))
        {
            ReleaseHandleListResource();
        }
        else
        {
            fResource = TRUE;
        }
    }
    else
    {
        ReleaseHandleListResource();
    }
    
    mmr = IMixerGetID(hmxobj, &uMxId, pmxl, fdwMxObjType);
    if (MMSYSERR_NOERROR != mmr)
    {
        dprintf(( "!IMixerGetLineInfo: IMixerGetID() failed!" ));
        if (fResource)
            ReleaseHandleListResource();
        return (mmr);
    }

    if ((MIXER_OBJECTF_MIXER  == fdwMxObjType) ||
        (MIXER_OBJECTF_HMIXER == fdwMxObjType))
    {
        //
        //  if a mixer device id was passed, then null hmx so we use the
        //  correct message sender below
        //
        if ((UINT_PTR)hmxobj == uMxId)
            hmxobj = NULL;
    }
    else
    {
        return (MMSYSERR_NOERROR);
    }


    //
    //  clear all fields before calling driver
    //
    if (NULL != hmxobj)
    {
        //
        //
        //
        pmxdev = (PMIXERDEV)hmxobj;
#if 0
        if (pmxdev->cDestinations <= pmxl->dwDestination)
        {
            ReleaseHandleListResource();
            DebugErr1(DBF_ERROR, "mixerGetLineInfo: invalid destination index (%lu).", pmxl->dwDestination);
            return (MMSYSERR_INVALPARAM);
        }
#endif

        mmr = (MMRESULT)IMixerMessageHandle((HMIXER)hmxobj,
                                            MXDM_GETLINEINFO,
                                            (DWORD_PTR)(LPVOID)pmxl,
                                            fdwInfo);
    }
    else
    {
#pragma message("----IMixerGetLineInfo: dwDestination not validated for ID's!!")
        mmr = (MMRESULT)IMixerMessageId(uMxId,
                                        MXDM_GETLINEINFO,
                                        (DWORD_PTR)(LPVOID)pmxl,
                                        fdwInfo);
    }

    if (MMSYSERR_NOERROR != mmr)
        return (mmr);

#pragma message("----IMixerGetLineInfo: should validate mixer driver didn't hose us!")


    //
    //  validate the driver's returned stuff...
    //
    //
    if (sizeof(MIXERLINE) != pmxl->cbStruct)
    {
        DebugErr1(DBF_ERROR, "mixerGetLineInfo: buggy driver returned invalid cbStruct (%lu).", pmxl->cbStruct);
        pmxl->cbStruct = sizeof(MIXERLINE);
    }

    if ((DWORD)-1L == pmxl->dwDestination)
    {
        DebugErr(DBF_ERROR, "mixerGetLineInfo: buggy driver failed to init dwDestination member.");
    }
    if (fSourceLine)
    {
        if (0 == (MIXERLINE_LINEF_SOURCE & pmxl->fdwLine))
        {
            DebugErr(DBF_ERROR, "mixerGetLineInfo: buggy driver failed to set MIXERLINE_LINEF_SOURCE.");
            pmxl->fdwLine |= MIXERLINE_LINEF_SOURCE;
        }

        if ((DWORD)-1L == pmxl->dwSource)
        {
            DebugErr(DBF_ERROR, "mixerGetLineInfo: buggy driver failed to init dwSource member.");
        }
    }
    if ((DWORD)-1L == pmxl->dwLineID)
    {
        DebugErr(DBF_ERROR, "mixerGetLineInfo: buggy driver failed to init dwLineID member.");
    }
    if (pmxl->fdwLine & ~0x80008001L)
    {
        DebugErr1(DBF_ERROR, "mixerGetLineInfo: buggy driver set reserved line flags (%.08lXh)!", pmxl->fdwLine);
        pmxl->fdwLine &= 0x80008001L;
    }
    if (!IMixerIsValidComponentType(pmxl->dwComponentType, pmxl->fdwLine))
    {
        DebugErr1(DBF_ERROR, "mixerGetLineInfo: buggy driver returned invalid dwComponentType (%.08lXh).", pmxl->dwComponentType);
        pmxl->dwComponentType = MIXERLINE_TARGETTYPE_UNDEFINED;
    }
    if (0 == pmxl->cChannels)
    {
        DebugErr(DBF_ERROR, "mixerGetLineInfo: buggy driver returned zero channels?!?");
        pmxl->cChannels = 1;
    }
    if (fSourceLine)
    {
        if (0 != pmxl->cConnections)
        {
            DebugErr(DBF_ERROR, "mixerGetLineInfo: buggy driver returned non-zero connections on source?!?");
            pmxl->cConnections = 0;
        }
    }

    pmxl->szShortName[SIZEOF(pmxl->szShortName) - 1] = '\0';
    pmxl->szName[SIZEOF(pmxl->szName) - 1] = '\0';


    //
    // Does this really need to be done if TARGETTYPE was requested?
    //


    //
    //
    //
    if (MIXERLINE_TARGETTYPE_UNDEFINED != pmxl->Target.dwType)
    {
        UINT        u;

        pmxl->Target.dwDeviceID = (DWORD)-1L;


        //
        //  we have a wMid, wPid and szPname (supposedly) of type dwType
        //  so let's go find it...
        //
        switch (pmxl->Target.dwType)
        {
            case MIXERLINE_TARGETTYPE_WAVEOUT:
                u = waveOutGetNumDevs();
                while (u--)
                {
                    WAVEOUTCAPS     woc;

                    mmr = waveOutGetDevCaps(u, &woc, sizeof(woc));
                    if (MMSYSERR_NOERROR != mmr)
                        continue;

                    woc.szPname[SIZEOF(woc.szPname) - 1] = '\0';

                    if (woc.wMid != pmxl->Target.wMid)
                        continue;

                    if (woc.wPid != pmxl->Target.wPid)
                        continue;

                    if (woc.vDriverVersion != pmxl->Target.vDriverVersion)
                        continue;

                    if (lstrcmp(woc.szPname, pmxl->Target.szPname))
                        continue;

                    pmxl->Target.dwDeviceID = u;
                    break;
                }
                break;

            case MIXERLINE_TARGETTYPE_WAVEIN:
                u = waveInGetNumDevs();
                while (u--)
                {
                    WAVEINCAPS      wic;

                    mmr = waveInGetDevCaps(u, &wic, sizeof(wic));
                    if (MMSYSERR_NOERROR != mmr)
                        continue;

                    wic.szPname[SIZEOF(wic.szPname) - 1] = '\0';

                    if (wic.wMid != pmxl->Target.wMid)
                        continue;

                    if (wic.wPid != pmxl->Target.wPid)
                        continue;

                    if (wic.vDriverVersion != pmxl->Target.vDriverVersion)
                        continue;

                    if (lstrcmp(wic.szPname, pmxl->Target.szPname))
                        continue;

                    pmxl->Target.dwDeviceID = u;
                    break;
                }
                break;

            case MIXERLINE_TARGETTYPE_MIDIOUT:
                u = midiOutGetNumDevs();
                while (u--)
                {
                    MIDIOUTCAPS     moc;

                    mmr = midiOutGetDevCaps(u, &moc, sizeof(moc));
                    if (MMSYSERR_NOERROR != mmr)
                        continue;

                    moc.szPname[SIZEOF(moc.szPname) - 1] = '\0';

                    if (moc.wMid != pmxl->Target.wMid)
                        continue;

                    if (moc.wPid != pmxl->Target.wPid)
                        continue;

                    if (moc.vDriverVersion != pmxl->Target.vDriverVersion)
                        continue;

                    if (lstrcmp(moc.szPname, pmxl->Target.szPname))
                        continue;

                    pmxl->Target.dwDeviceID = u;
                    break;
                }
                break;

            case MIXERLINE_TARGETTYPE_MIDIIN:
                u = midiInGetNumDevs();
                while (u--)
                {
                    MIDIINCAPS      mic;

                    mmr = midiInGetDevCaps(u, &mic, sizeof(mic));
                    if (MMSYSERR_NOERROR != mmr)
                        continue;

                    mic.szPname[SIZEOF(mic.szPname) - 1] = '\0';

                    if (mic.wMid != pmxl->Target.wMid)
                        continue;

                    if (mic.wPid != pmxl->Target.wPid)
                        continue;

                    if (mic.vDriverVersion != pmxl->Target.vDriverVersion)
                        continue;

                    if (lstrcmp(mic.szPname, pmxl->Target.szPname))
                        continue;

                    pmxl->Target.dwDeviceID = u;
                    break;
                }
                break;

            case MIXERLINE_TARGETTYPE_AUX:
                u = auxGetNumDevs();
                while (u--)
                {
                    AUXCAPS     ac;

                    mmr = auxGetDevCaps(u, &ac, sizeof(ac));
                    if (MMSYSERR_NOERROR != mmr)
                        continue;

                    ac.szPname[SIZEOF(ac.szPname) - 1] = '\0';

                    if (ac.wMid != pmxl->Target.wMid)
                        continue;

                    if (ac.wPid != pmxl->Target.wPid)
                        continue;

                    if (ac.vDriverVersion != pmxl->Target.vDriverVersion)
                        continue;

                    if (lstrcmp(ac.szPname, pmxl->Target.szPname))
                        continue;

                    pmxl->Target.dwDeviceID = u;
                    break;
                }
                break;

            default:
                pmxl->Target.dwType = MIXERLINE_TARGETTYPE_UNDEFINED;
                break;
        }
    }


    return (mmr);

} // mixerGetLineInfo()


//
//  Abstract converting the complex mixerline structure
//
void ConvertMIXERLINEWToMIXERLINEA(
    PMIXERLINEA         pmxlA,
    PMIXERLINEW         pmxlW
)
{
    //
    //  Don't copy cbStruct
    //

    CopyMemory((PVOID)((PBYTE)pmxlA + sizeof(DWORD)),
               (PVOID)((PBYTE)pmxlW + sizeof(DWORD)),
               FIELD_OFFSET(MIXERLINEA, szShortName[0]) - sizeof(DWORD));

    Iwcstombs(pmxlA->szShortName, pmxlW->szShortName,
             sizeof(pmxlA->szShortName));
    Iwcstombs(pmxlA->szName, pmxlW->szName,
             sizeof(pmxlA->szName));

    CopyMemory((PVOID)&pmxlA->Target, (PVOID)&pmxlW->Target,
               FIELD_OFFSET(MIXERLINEA, Target.szPname[0]) -
               FIELD_OFFSET(MIXERLINEA, Target.dwType));

    Iwcstombs(pmxlA->Target.szPname, pmxlW->Target.szPname,
             sizeof(pmxlA->Target.szPname));
}


/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK STRUCTURE
 *
 *  @types MIXERCONTROL | The <t MIXERCONTROL> structure describes the state
 *      and metrics of a single control for an audio mixer line.
 *
 *  @syntaxex
 *      typedef struct tMIXERCONTROL
 *      {
 *          DWORD           cbStruct;
 *          DWORD           dwControlID;
 *          DWORD           dwControlType;
 *          DWORD           fdwControl;
 *          DWORD           cMultipleItems;
 *          char            szShortName[MIXER_SHORT_NAME_CHARS];
 *          char            szName[MIXER_LONG_NAME_CHARS];
 *          union
 *          {
 *              struct
 *              {
 *                  LONG    lMinimum;
 *                  LONG    lMaximum;
 *              };
 *              struct
 *              {
 *                  DWORD   dwMinimum;
 *                  DWORD   dwMaximum;
 *              };
 *              DWORD       dwReserved[6];
 *          } Bounds;
 *          union
 *          {
 *              DWORD       cSteps;
 *              DWORD       cbCustomData;
 *              DWORD       dwReserved[6];
 *          } Metrics;
 *      } MIXERCONTROL;
 *
 *  @field DWORD | cbStruct | Specifies the size, in bytes, of the
 *      <t MIXERCONTROL> structure. Since the <t MIXERCONTROL> structure
 *      is only passed as a receiving buffer referenced and described by
 *      the <t MIXERLINECONTROLS> structure passed to the
 *      <f mixerGetLineControls> function, it is not necessary for the
 *      calling application to initialize this member (or any other members
 *      of this structure). When the <f mixerGetLineControls> function
 *      returns, this member contains the actual size of the information
 *      returned by the mixer device. The returned information will never
 *      exceed the requested size and will never be smaller than the
 *      base <t MIXERCONTROL> structure.
 *
 *  @field DWORD | dwControlID | Specifies an audio mixer defined identifier
 *      that uniquely refers to the control described by the <t MIXERCONTROL>
 *      structure. This identifier is unique only to a single mixer device
 *      and may be of any format that the mixer device wishes. An application
 *      should only use this identifier as an abstract handle. No two
 *      controls for a single mixer device will have the same control
 *      identifier under any circumstances.
 *
 *  @field DWORD | dwControlType | Specifies the control type for this
 *      control. An application must use this information to display the
 *      appropriate control for input from the user. An application may
 *      also wish to display tailored graphics based on the control type or
 *      search for a particular control type on a specific line. If an
 *      application does not know about a control type, then this control
 *      must be ignored. There are currently seven different control type
 *      classifications.
 *
 *      The control type class <cl MIXERCONTROL_CT_CLASS_CUSTOM> consists of
 *      the following standard control types.
 *
 *      <c MIXERCONTROL_CONTROLTYPE_CUSTOM><nl>
 *
 *      The control type class <cl MIXERCONTROL_CT_CLASS_METER> consists of
 *      the following standard control types.
 *
 *      <c MIXERCONTROL_CONTROLTYPE_BOOLEANMETER><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_SIGNEDMETER><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_PEAKMETER><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_UNSIGNEDMETER><nl>
 *
 *      The control type class <cl MIXERCONTROL_CT_CLASS_SWITCH> consists of
 *      the following standard control types.
 *
 *      <c MIXERCONTROL_CONTROLTYPE_BUTTON><nl>
 *
 *      <c MIXERCONTROL_CONTROLTYPE_BOOLEAN><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_ONOFF><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MUTE><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MONO><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_LOUDNESS><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_STEREOENH><nl>
 *
 *      The control type class <cl MIXERCONTROL_CT_CLASS_NUMBER> consists of
 *      the following standard control types.
 *
 *      <c MIXERCONTROL_CONTROLTYPE_SIGNED><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_DECIBELS><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_UNSIGNED><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_PERCENT><nl>
 *
 *      The control type class <cl MIXERCONTROL_CT_CLASS_SLIDER> consists of
 *      the following standard control types.
 *
 *      <c MIXERCONTROL_CONTROLTYPE_SLIDER><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_PAN><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_QSOUNDPAN><nl>
 *
 *      The control type class <cl MIXERCONTROL_CT_CLASS_FADER> consists of
 *      the following standard control types.
 *
 *      <c MIXERCONTROL_CONTROLTYPE_FADER><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_VOLUME><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_BASS><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_TREBLE><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_EQUALIZER><nl>
 *
 *      The control type class <cl MIXERCONTROL_CT_CLASS_TIME> consists of
 *      the following standard control types.
 *
 *      <c MIXERCONTROL_CONTROLTYPE_MICROTIME><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MILLITIME><nl>
 *
 *      The control type class <cl MIXERCONTROL_CT_CLASS_LIST> consists of
 *      the following standard control types.
 *
 *      <c MIXERCONTROL_CONTROLTYPE_SINGLESELECT><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MUX><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MIXER><nl>
 *
 *  @field DWORD | fdwControl | Specifies status and support flags for the
 *      audio mixer line control.
 *
 *      @flag <c MIXERCONTROL_CONTROLF_UNIFORM> | Specifies that the control
 *      acts on all channels of a multi-channel line in a uniform fashion.
 *      For example, a Mute control that mutes both channels of a stereo
 *      line would set this flag. Most MUX and Mixer controls will also
 *      specify the <c MIXERCONTROL_CONTROLF_UNIFORM> flag.
 *
 *      @flag <c MIXERCONTROL_CONTROLF_MULTIPLE> | Specifies that the control
 *      has two or more settings per channel. An example of a control
 *      that requires the multiple flag is an equalizer--each frequency
 *      band can be set to different values. Note that an equalizer that
 *      affects both channels of a stereo line in a uniform fashion will
 *      also set the <c MIXERCONTROL_CONTROLF_UNIFORM> flag.
 *
 *      @flag <c MIXERCONTROL_CONTROLF_DISABLED> | Specifies that the control
 *      is disabled (perhaps due to other settings for the mixer hardware)
 *      and cannot be used. An application can read current settings from
 *      a disabled control, but cannot apply settings.
 *
 *  @field DWORD | cMultipleItems | Specifies the number of items per
 *      channel that a <c MIXERCONTROL_CONTROLF_MULTIPLE> control contains.
 *      This number will always be two or greater for multiple item
 *      controls. If the control is not a multiple item control, this
 *      member will be zero and should be ignored.
 *
 *  @field char | szShortName[<c MIXER_SHORT_NAME_CHARS>] | Specifies a short
 *      string that describes the <e MIXERCONTROL.dwControlID> audio mixer
 *      line control. This description is appropriate for using as a
 *      displayable label for the control that can fit in small spaces.
 *
 *  @field char | szName[<c MIXER_LONG_NAME_CHARS>] | Specifies a string
 *      that describes the <e MIXERCONTROL.dwControlID> audio mixer line
 *      control. This description is appropriate for using as a displayable
 *      description for the control that is not limited by screen space.
 *
 *  @field union | Bounds | Contains the union of boundary types.
 *
 *  @field2 DWORD | dwMinimum | Specifies the minimum unsigned value
 *      for a control that has an unsigned boundary nature. Refer to the
 *      description for each control type to determine if this member is
 *      appropriate for the control. This member overlaps with the
 *      <e MIXERCONTROL.lMinimum> member and cannot be used in
 *      conjunction with that member.
 *
 *  @field2 DWORD | dwMaximum | Specifies the maximum unsigned value
 *      for a control that has an unsigned boundary nature. Refer to the
 *      description for each control type to determine if this member is
 *      appropriate for the control. This member overlaps with the
 *      <e MIXERCONTROL.lMaximum> member and cannot be used in
 *      conjunction with that member.
 *
 *  @field2 DWORD | lMinimum | Specifies the minimum signed value
 *      for a control that has a signed boundary nature. Refer to the
 *      description for each control type to determine if this member is
 *      appropriate for the control. This member overlaps with the
 *      <e MIXERCONTROL.dwMinimum> member and cannot be used in
 *      conjunction with that member.
 *
 *  @field2 DWORD | lMaximum | Specifies the maximum signed value
 *      for a control that has a signed boundary nature. Refer to the
 *      description for each control type to determine if this member is
 *      appropriate for the control. This member overlaps with the
 *      <e MIXERCONTROL.dwMaximum> member and cannot be used in
 *      conjunction with that member.
 *
 *  @field union | Metrics | Contains the union of boundary metrics.
 *
 *  @field2 DWORD | cSteps | Specifies the number of discrete
 *      ranges within the specified <e MIXERCONTROL.Bounds> for a control.
 *      Refer to the description for each control type to determine if this
 *      member is appropriate for the control. This member overlaps with the
 *      other members of the <e MIXERCONTROL.Metrics> structure member and
 *      cannot be used in conjunction with those members.
 *
 *  @field2 DWORD | cbCustomData | Specifies the size, in bytes,
 *      required to hold the state of a custom control type. This member
 *      is only appropriate for the <c MIXERCONTROL_CONTROLTYPE_CUSTOM>
 *      control type. See the description for custom control types for more
 *      information on the use of this member.
 *
 *  @tagname tMIXERCONTROL
 *
 *  @othertype MIXERCONTROL FAR * | LPMIXERCONTROL | A pointer to a
 *      <t MIXERCONTROL> structure.
 *
 *  @othertype MIXERCONTROL * | PMIXERCONTROL | A pointer to a
 *      <t MIXERCONTROL> structure.
 *
 *  @xref <t MIXERLINECONTROLS>, <f mixerGetLineControls>, <f mixerGetLineInfo>,
 *      <f mixerGetControlDetails>, <f mixerSetControlDetails>,
 *      <t MIXERCONTROLDETAILS>
 *
 **/

/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK STRUCTURE
 *
 *  @types MIXERLINECONTROLS | The <t MIXERLINECONTROLS> structure references
 *      what controls to retrieve information on from an audio mixer line.
 *
 *  @field DWORD | cbStruct | Specifies the size, in bytes, of the
 *      <t MIXERLINECONTROLS> structure. This member must be initialized
 *      before calling the <f mixerGetLineControls> function. The size
 *      specified in this member must be large enough to contain the base
 *      <t MIXERLINECONTROLS> structure. When the <f mixerGetLineControls>
 *      function returns, this member contains the actual size of the
 *      information returned. The returned information will never exceed
 *      the requested size and will never be smaller than the base
 *      <t MIXERLINECONTROLS> structure.
 *
 *  @field DWORD | dwLineID | Specifies the line identifier to retrieve
 *      one or all controls for. This member is not used if the
 *      <c MIXER_GETLINECONTROLSF_ONEBYID> flag is specified for the
 *      <f mixerGetLineControls> function--but the mixer device will return
 *      this member in this case. The <e MIXERLINECONTROLS.dwControlID>
 *      and <e MIXERLINECONTROLS.dwControlType> members are not used when
 *      <c MIXER_GETLINECONTROLSF_ALL> is specified.
 *
 *  @field DWORD | dwControlID | Specifies the control identifier of the
 *      control desired. This member is used with the
 *      <c MIXER_GETLINECONTROLSF_ONEBYID> flag for <f mixerGetLineControls>
 *      to retrieve the control information of the specified control.
 *      Note that the <e MIXERLINECONTROLS.dwLineID> member of the
 *      <t MIXERLINECONTROLS> structure will be returned by the mixer device
 *      and is not required as an input parameter. This member overlaps with
 *      the <e MIXERLINECONTROLS.dwControlType> member and cannot be used in
 *      conjunction with the <c MIXER_GETLINECONTROLSF_ONEBYTYPE> query type.
 *
 *  @field DWORD | dwControlType | Specifies the control type of the
 *      control desired. This member is used with the
 *      <c MIXER_GETLINECONTROLSF_ONEBYTYPE> flag for <f mixerGetLineControls>
 *      to retrieve the first control of the specified type on the line
 *      specified by the <e MIXERLINECONTROLS.dwLineID> member of the
 *      <t MIXERLINECONTROLS> structure. This member overlaps with the
 *      <e MIXERLINECONTROLS.dwControlID> member and cannot be used in
 *      conjunction with the <c MIXER_GETLINECONTROLSF_ONEBYID> query type.
 *
 *  @field DWORD | cControls | Specifies the number of <t MIXERCONTROL>
 *      structure elements to retrieve. This member must be initialized by
 *      the application before calling the <f mixerGetLineControls> function.
 *      This member may only be one (if <c MIXER_GETLINECONTROLSF_ONEBYID> or
 *      <c MIXER_GETLINECONTROLSF_ONEBYTYPE> is specified) or the value
 *      returned in the <e MIXERLINE.cControls> member of the <t MIXERLINE>
 *      structure returned for a line. This member cannot be zero. If a
 *      line specifies that it has no controls, then <f mixerGetLineControls>
 *      should not be called.
 *
 *  @field DWORD | cbmxctrl | Specifies the size, in bytes, of a single
 *      <t MIXERCONTROL> structure. This must be at least large enough
 *      to hold the base <t MIXERCONTROL> structure. The total size, in
 *      bytes, required for the buffer pointed to by <e MIXERLINECONTROLS.pamxctrl>
 *      member is the product of the <e MIXERLINECONTROLS.cbmxctrl> and
 *      <e MIXERLINECONTROLS.cControls> members of the <t MIXERLINECONTROLS>
 *      structure.
 *
 *  @field LPMIXERCONTROL | pamxctrl | Points to one or more <t MIXERCONTROL>
 *      structures to receive the details on the requested audio mixer line
 *      controls. This member may never be NULL and must be initialized before
 *      calling the <f mixerGetLineControls> function. Each element of the
 *      array of controls must be at least large enough to hold a base
 *      <t MIXERCONTROL> structure. The <e MIXERLINECONTROLS.cbmxctrl> member
 *      must specify the size, in bytes, of each element in this array. No
 *      initialization of the buffer pointed to by this member needs to be
 *      initialized by the application. All members will be filled in by
 *      the mixer device (including the <e MIXERCONTROL.cbStruct> member
 *      of each <t MIXERCONTROL> structure) upon returning successfully to
 *      the application.
 *
 *  @tagname tMIXERLINECONTROLS
 *
 *  @othertype MIXERLINECONTROLS FAR * | LPMIXERLINECONTROLS | A pointer to a
 *      <t MIXERLINECONTROLS> structure.
 *
 *  @othertype MIXERLINECONTROLS * | PMIXERLINECONTROLS | A pointer to a
 *      <t MIXERLINECONTROLS> structure.
 *
 *  @xref <t MIXERCONTROL>, <f mixerGetLineControls>, <f mixerGetLineInfo>,
 *      <f mixerGetControlDetails>, <f mixerSetControlDetails>
 *
 **/

/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK API
 *
 *  @api MMRESULT | mixerGetLineControls | The <f mixerGetLineControls>
 *      function is used to retrieve one or more controls associated with
 *      an audio mixer device line.
 *
 *  @parm <c HMIXEROBJ> | hmxobj | Specifies a handle to the audio mixer
 *      device object to get line control information from.
 *
 *  @parm LPMIXERLINECONTROLS | pmxlc | Points to a <t MIXERLINECONTROLS>
 *      structure. This structure is used to reference one or more
 *      <t MIXERCONTROL> structures to be filled with information about the
 *      controls associated with a mixer line.
 *      See the comments for each query flag passed through <p fdwControls>
 *      for details on what members of the <t MIXERLINECONTROLS> structure
 *      that must be initialized. Note that in all cases, the
 *      <e MIXERLINECONTROLS.cbStruct> member of the <t MIXERLINECONTROLS>
 *      structure must be initialized to be the size, in bytes, of the
 *      <t MIXERLINECONTROLS> structure.
 *
 *  @parm DWORD | fdwControls | Specifies flags for getting information on
 *      one or more control associated with a mixer line.
 *
 *      @flag <c MIXER_GETLINECONTROLSF_ALL> | If this flag is specified,
 *      <p pmxlc> references a list of <t MIXERCONTROL> structures that
 *      will receive information on all controls associated with the
 *      line identified by the <e MIXERLINECONTROLS.dwLineID> member of
 *      the <t MIXERLINECONTROLS> structure. <e MIXERLINECONTROLS.cControls>
 *      must be initialized to the number of controls associated with the
 *      line. This number is retrieved from the <e MIXERLINE.cControls>
 *      member of the <t MIXERLINE> structure returned by the
 *      <f mixerGetLineInfo> function. <e MIXERLINECONTROLS.cbmxctrl> must
 *      be initialized to the size, in bytes, of a single <t MIXERCONTROL>
 *      structure. <e MIXERLINECONTROLS.pamxctrl> must point to
 *      the first <t MIXERCONTROL> structure to be filled in. Both the
 *      <e MIXERLINECONTROLS.dwControlID> and <e MIXERLINECONTROLS.dwControlType>
 *      members are ignored for this query.
 *
 *      @flag <c MIXER_GETLINECONTROLSF_ONEBYID> | If this flag is specified,
 *      <p pmxlc> references a single <t MIXERCONTROL> structure that
 *      will receive information on the control identified by the
 *      <e MIXERLINECONTROLS.dwControlID> member of the <t MIXERLINECONTROLS>
 *      structure. <e MIXERLINECONTROLS.cControls> must be initialized to one.
 *      <e MIXERLINECONTROLS.cbmxctrl> must be initialized to the size, in
 *      bytes, of a single <t MIXERCONTROL> structure.
 *      <e MIXERLINECONTROLS.pamxctrl> must point to a <t MIXERCONTROL>
 *      structure to be filled in. Both the <e MIXERLINECONTROLS.dwLineID>
 *      and <e MIXERLINECONTROLS.dwControlType> members are ignored for this
 *      query. This query is usually used to refresh a control after
 *      receiving a <m MM_MIXM_CONTROL_CHANGE> control change notification
 *      message by the user-specified callback (see <f mixerOpen>).
 *
 *      @flag <c MIXER_GETLINECONTROLSF_ONEBYTYPE> | If this flag is specified,
 *      <p pmxlc> references a single <t MIXERCONTROL> structure that
 *      will receive information on the fist control associated with the
 *      line identified by <e MIXERLINECONTROLS.dwLineID> of the type
 *      specified in the <e MIXERLINECONTROLS.dwControlType> member of the
 *      <t MIXERLINECONTROLS> structure.
 *       <e MIXERLINECONTROLS.cControls> must be
 *      initialized to one. <e MIXERLINECONTROLS.cbmxctrl> must be initialized
 *      to the size, in bytes, of a single <t MIXERCONTROL> structure.
 *      <e MIXERLINECONTROLS.pamxctrl> must point to a <t MIXERCONTROL>
 *      structure to be filled in. The <e MIXERLINECONTROLS.dwControlID>
 *      member is ignored for this query. This query can be used by an
 *      application to get information on single control associated with
 *      a line. For example, an application may only want to use a peak
 *      meter from a waveform output line.
 *
 *      @flag <c MIXER_OBJECTF_MIXER> | Specifies that <p hmxobj> is an audio
 *      mixer device identifier in the range of zero to one less than the
 *      number of devices returned by <f mixerGetNumDevs>. This flag is
 *      optional.
 *
 *      @flag <c MIXER_OBJECTF_HMIXER> | Specifies that <p hmxobj> is a mixer
 *      device handle returned by <f mixerOpen>. This flag is optional.
 *
 *      @flag <c MIXER_OBJECTF_WAVEOUT> | Specifies that <p hmxobj> is a
 *      waveform output device identifier in the range of zero to one less
 *      than the number of devices returned by <f waveOutGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HWAVEOUT> | Specifies that <p hmxobj> is a
 *      waveform output handle returned by <f waveOutOpen>.
 *
 *      @flag <c MIXER_OBJECTF_WAVEIN> | Specifies that <p hmxobj> is a
 *      waveform input device identifier in the range of zero to one less
 *      than the number of devices returned by <f waveInGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HWAVEIN> | Specifies that <p hmxobj> is a
 *      waveform input handle returned by <f midiInOpen>.
 *
 *      @flag <c MIXER_OBJECTF_MIDIOUT> | Specifies that <p hmxobj> is a MIDI
 *      output device identifier in the range of zero to one less than the
 *      number of devices returned by <f midiOutGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HMIDIOUT> | Specifies that <p hmxobj> is a
 *      MIDI output handle returned by <f midiOutOpen>.
 *
 *      @flag <c MIXER_OBJECTF_MIDIIN> | Specifies that <p hmxobj> is a MIDI
 *      input device identifier in the range of zero to one less than the
 *      number of devices returned by <f midiInGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HMIDIIN> | Specifies that <p hmxobj> is a MIDI
 *      input handle returned by <f midiInOpen>.
 *
 *      @flag <c MIXER_OBJECTF_AUX> | Specifies that <p hmxobj> is an
 *      auxiliary device identifier in the range of zero to one less than the
 *      number of devices returned by <f auxGetNumDevs>.
 *
 *  @rdesc The return value is zero if the function is successful. Otherwise,
 *      it returns a non-zero error number. Possible error returns include
 *      the following:
 *
 *      @flag <c MMSYSERR_BADDEVICEID> | The <p hmxobj> argument specifies an
 *      invalid device identifier.
 *
 *      @flag <c MMSYSERR_INVALHANDLE> | The <p hmxobj> argument specifies an
 *      invalid handle.
 *
 *      @flag <c MMSYSERR_INVALFLAG> | One or more flags are invalid.
 *
 *      @flag <c MMSYSERR_INVALPARAM> | One or more arguments passed is
 *      invalid.
 *
 *      @flag <c MMSYSERR_NODRIVER> | No audio mixer device is available for
 *      the object specified by <p hmxobj>.
 *
 *      @flag <c MIXERR_INVALLINE> | The audio mixer device line reference is
 *      invalid.
 *
 *      @flag <c MIXERR_INVALCONTROL> | The control reference is invalid.
 *
 *  @xref <t MIXERLINECONTROLS>, <t MIXERCONTROL>, <f mixerGetLineInfo>,
 *      <f mixerOpen>, <f mixerGetControlDetails>, <f mixerSetControlDetails>
 *
 **/

MMRESULT APIENTRY mixerGetLineControlsA(
    HMIXEROBJ               hmxobj,
    LPMIXERLINECONTROLSA    pmxlcA,
    DWORD                   fdwControls
)
{
    MIXERLINECONTROLSW      mxlcW;
    MMRESULT                mmr;
    DWORD                   cControls;

    V_WPOINTER(pmxlcA, sizeof(DWORD), MMSYSERR_INVALPARAM);
    V_WPOINTER(pmxlcA, (UINT)pmxlcA->cbStruct, MMSYSERR_INVALPARAM);
    if (sizeof(MIXERLINECONTROLSA) > pmxlcA->cbStruct) {
        DebugErr1(DBF_ERROR, "mixerGetLineControls: structure size too small or cbStruct not initialized (%lu).", pmxlcA->cbStruct);
        return (MMSYSERR_INVALPARAM);
    }

    //
    //  Set up a MIXERCONTROLW structure and allocate space for the
    //  returned data
    //

    CopyMemory((PVOID)&mxlcW, (PVOID)pmxlcA,
               FIELD_OFFSET(MIXERLINECONTROLSA, pamxctrl));
    mxlcW.cbmxctrl = mxlcW.cbmxctrl + sizeof(MIXERCONTROLW) -
                                          sizeof(MIXERCONTROLA);

    //
    //  Work out how many controls (what a mess - why isn't the count
    //  ALWAYS required)!
    //

    switch (MIXER_GETLINECONTROLSF_QUERYMASK & fdwControls)
    {
        case MIXER_GETLINECONTROLSF_ONEBYID:
        case MIXER_GETLINECONTROLSF_ONEBYTYPE:
            cControls = 1;
            break;

        default:
            cControls = mxlcW.cControls;
            break;
    }

    if (cControls != 0) {
        mxlcW.pamxctrl = (LPMIXERCONTROLW)
                             LocalAlloc(LPTR, cControls * mxlcW.cbmxctrl);

        if (mxlcW.pamxctrl == NULL) {
            return MMSYSERR_NOMEM;
        }

    } else {
        mxlcW.pamxctrl = NULL;
    }

    //
    //  Call the real function
    //

    mmr = mixerGetLineControls(hmxobj, &mxlcW, fdwControls);

    if (mmr != MMSYSERR_NOERROR) {
        if (mxlcW.pamxctrl != NULL) {
            LocalFree((HLOCAL)mxlcW.pamxctrl);
        }
        return mmr;
    }

    //
    //  The INPUT line id can be changed !!
    //

    pmxlcA->dwLineID = mxlcW.dwLineID;

    //
    //  The control id can be changed !!
    //

    pmxlcA->dwControlID = mxlcW.dwControlID;


    //
    //  Copy and massage the data back for the application
    //

    {
        UINT i;
        LPMIXERCONTROLA pamxctrlA;
        LPMIXERCONTROLW pamxctrlW;

        for (i = 0, pamxctrlA = pmxlcA->pamxctrl, pamxctrlW = mxlcW.pamxctrl;
             i < cControls;
             i++,
             *(LPBYTE *)&pamxctrlA += pmxlcA->cbmxctrl,
             *(LPBYTE *)&pamxctrlW += mxlcW.cbmxctrl
             ) {


             CopyMemory((PVOID)pamxctrlA,
                        (PVOID)pamxctrlW,
                        FIELD_OFFSET(MIXERCONTROLA, szShortName[0]));

             /*
             **  Set the size
             */

             pamxctrlA->cbStruct = sizeof(MIXERCONTROLA);

             Iwcstombs(pamxctrlA->szShortName,
                      pamxctrlW->szShortName,
                      sizeof(pamxctrlA->szShortName));
             Iwcstombs(pamxctrlA->szName,
                      pamxctrlW->szName,
                      sizeof(pamxctrlA->szName));

             CopyMemory((PVOID)((PBYTE)pamxctrlA +
                             FIELD_OFFSET(MIXERCONTROLA, Bounds.lMinimum)),
                        (PVOID)((PBYTE)pamxctrlW +
                             FIELD_OFFSET(MIXERCONTROLW, Bounds.lMinimum)),
                        sizeof(MIXERCONTROLW) -
                             FIELD_OFFSET(MIXERCONTROLW, Bounds.lMinimum));

        }
    }

    if (mxlcW.pamxctrl != NULL) {
        LocalFree((HLOCAL)mxlcW.pamxctrl);
    }
    return mmr;

} // mixerGetLineControlsA()

MMRESULT APIENTRY mixerGetLineControls(
    HMIXEROBJ               hmxobj,
    LPMIXERLINECONTROLS     pmxlc,
    DWORD                   fdwControls
)
{
    DWORD               fdwMxObjType;
    UINT                uMxId;
    BOOL                fResource;
    MMRESULT            mmr;

    V_DFLAGS(fdwControls, MIXER_GETLINECONTROLSF_VALID, mixerGetLineControls, MMSYSERR_INVALFLAG);
    V_WPOINTER(pmxlc, sizeof(DWORD), MMSYSERR_INVALPARAM);

    //
    //  the structure header for MIXERLINECONTROLS must be at least the
    //  minimum size
    //
    if (sizeof(MIXERLINECONTROLS) > pmxlc->cbStruct)
    {
        DebugErr1(DBF_ERROR, "mixerGetLineControls: structure size too small or cbStruct not initialized (%lu).", pmxlc->cbStruct);
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pmxlc, pmxlc->cbStruct, MMSYSERR_INVALPARAM);

    if (sizeof(MIXERCONTROL) > pmxlc->cbmxctrl)
    {
        DebugErr1(DBF_ERROR, "mixerGetLineControls: structure size too small or cbmxctrl not initialized (%lu).", pmxlc->cbmxctrl);
        return (MMSYSERR_INVALPARAM);
    }


    ClientUpdatePnpInfo();

    //
    //
    //
    switch (MIXER_GETLINECONTROLSF_QUERYMASK & fdwControls)
    {
        case MIXER_GETLINECONTROLSF_ALL:
            if (0 == pmxlc->cControls)
            {
                DebugErr(DBF_ERROR, "mixerGetLineControls: cControls cannot be zero.");
                return (MMSYSERR_INVALPARAM);
            }


            pmxlc->dwControlID  = (DWORD)-1L;
            break;

        case MIXER_GETLINECONTROLSF_ONEBYID:
            pmxlc->dwLineID     = (DWORD)-1L;

            // -- fall through --

        case MIXER_GETLINECONTROLSF_ONEBYTYPE:
            pmxlc->cControls    = (DWORD)1;
            break;

        default:
            DebugErr1(DBF_ERROR, "mixerGetLineControls: invalid query flags (%.08lXh).",
                        MIXER_GETLINECONTROLSF_QUERYMASK & fdwControls);
            return (MMSYSERR_INVALFLAG);
    }

    V_WPOINTER(pmxlc->pamxctrl, pmxlc->cControls * pmxlc->cbmxctrl, MMSYSERR_INVALPARAM);


    //
    //
    //
    fdwMxObjType = (MIXER_OBJECTF_TYPEMASK & fdwControls);

    fResource = FALSE;

    AcquireHandleListResourceShared();
    
    //  Checking for the type of mixer object.  If it is a non-mixer type
    //  calling IMixerMesssageID (called by IMixerGetID) with the shared
    //  resource will deadlock.
    if ((MIXER_OBJECTF_MIXER  == fdwMxObjType) ||
        (MIXER_OBJECTF_HMIXER == fdwMxObjType))
    {
        if (BAD_HANDLE(hmxobj, TYPE_MIXER))
        {
            ReleaseHandleListResource();
        }
        else
        {
            fResource = TRUE;
        }
    }
    else
    {
        ReleaseHandleListResource();
    }
    
    mmr = IMixerGetID(hmxobj, &uMxId, NULL, fdwMxObjType);
    if (MMSYSERR_NOERROR != mmr)
    {
        if (fResource)
            ReleaseHandleListResource();
        return (mmr);
    }

    if ((MIXER_OBJECTF_MIXER  == fdwMxObjType) ||
        (MIXER_OBJECTF_HMIXER == fdwMxObjType))
    {
        //
        //  if a mixer device id was passed, then null hmx so we use the
        //  correct message sender below
        //
        if ((UINT_PTR)hmxobj == uMxId)
            hmxobj = NULL;
    }
    else
    {
        hmxobj = NULL;
    }



    //
    //
    //
    //
    if (NULL != hmxobj)
    {
        mmr = (MMRESULT)IMixerMessageHandle((HMIXER)hmxobj,
                                            MXDM_GETLINECONTROLS,
                                            (DWORD_PTR)pmxlc,
                                            fdwControls);
    }
    else
    {
        mmr = (MMRESULT)IMixerMessageId(uMxId,
                                        MXDM_GETLINECONTROLS,
                                        (DWORD_PTR)pmxlc,
                                        fdwControls);
    }

    return (mmr);
} // mixerGetLineControls()


/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK STRUCTURE
 *
 *  @types MIXERCONTROLDETAILS_LISTTEXT | The <t MIXERCONTROLDETAILS_LISTTEXT>
 *      structure is used to get list text, label text, and/or band range
 *      information for multiple item controls. This structure is only used
 *      in conjunction with the <c MIXER_GETCONTROLDETAILSF_LISTTEXT> flag
 *      on the <f mixerGetControlDetails> function.
 *
 *  @field DWORD | dwParam1 | Specifies the first 32 bit control type
 *      specific value. Refer to the description of the multiple item control
 *      type for information on what this value represents for the given
 *      control.
 *
 *  @field DWORD | dwParam1 | Specifies the second 32 bit control type
 *      specific value. Refer to the description of the multiple item control
 *      type for information on what this value represents for the given
 *      control.
 *
 *  @field char | szName[<c MIXER_LONG_NAME_CHARS>] | Specifies a name that
 *      describes a single item in a multiple item control. This text can
 *      be used as a label or item text depending on the specific control
 *      type.
 *
 *  @comm The following standard control types use the
 *      <t MIXERCONTROLDETAILS_LISTTEXT> structure for getting the item text
 *      descriptions on multiple item controls:
 *
 *      <c MIXERCONTROL_CONTROLTYPE_EQUALIZER><nl>
 *
 *      <c MIXERCONTROL_CONTROLTYPE_SINGLESELECT><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MUX><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MIXER><nl>
 *
 *  @tagname tMIXERCONTROLDETAILS_LISTTEXT
 *
 *  @othertype MIXERCONTROLDETAILS_LISTTEXT FAR * | LPMIXERCONTROLDETAILS_LISTTEXT |
 *      A pointer to a <t MIXERCONTROLDETAILS_LISTTEXT> structure.
 *
 *  @othertype MIXERCONTROLDETAILS_LISTTEXT * | PMIXERCONTROLDETAILS_LISTTEXT |
 *      A pointer to a <t MIXERCONTROLDETAILS_LISTTEXT> structure.
 *
 *  @xref <t MIXERCONTROLDETAILS_UNSIGNED>, <t MIXERCONTROLDETAILS_SIGNED>,
 *      <t MIXERCONTROLDETAILS_BOOLEAN>, <f mixerGetControlDetails>,
 *      <f mixerSetControlDetails>, <t MIXERCONTROL>
 *
 **/

/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK STRUCTURE
 *
 *  @types MIXERCONTROLDETAILS_BOOLEAN | The <t MIXERCONTROLDETAILS_BOOLEAN>
 *      structure is used to get and set Boolean type control details for
 *      an audio mixer control. Refer to the control type description for
 *      the desired control to determine what details structure to use.
 *
 *  @field LONG | fValue | Specifies the Boolean value for a single item
 *      or channel. This value is assumed to zero for a 'FALSE' state (for
 *      example, off or disabled). This value is assumed to be non-zero
 *      for a 'TRUE' state (for example, on or enabled).
 *
 *  @comm The following standard control types use the
 *      <t MIXERCONTROLDETAILS_BOOLEAN> structure for getting and setting
 *      details:
 *
 *      <c MIXERCONTROL_CONTROLTYPE_BOOLEANMETER><nl>
 *
 *      <c MIXERCONTROL_CONTROLTYPE_BUTTON><nl>
 *
 *      <c MIXERCONTROL_CONTROLTYPE_BOOLEAN><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_ONOFF><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MUTE><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MONO><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_LOUDNESS><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_STEREOENH><nl>
 *
 *      <c MIXERCONTROL_CONTROLTYPE_SINGLESELECT><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MUX><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MIXER><nl>
 *
 *  @tagname tMIXERCONTROLDETAILS_BOOLEAN
 *
 *  @othertype MIXERCONTROLDETAILS_BOOLEAN FAR * | LPMIXERCONTROLDETAILS_BOOLEAN |
 *      A pointer to a <t MIXERCONTROLDETAILS_BOOLEAN> structure.
 *
 *  @othertype MIXERCONTROLDETAILS_BOOLEAN * | PMIXERCONTROLDETAILS_BOOLEAN |
 *      A pointer to a <t MIXERCONTROLDETAILS_BOOLEAN> structure.
 *
 *  @xref <t MIXERCONTROLDETAILS_UNSIGNED>, <t MIXERCONTROLDETAILS_SIGNED>,
 *      <t MIXERCONTROLDETAILS_LISTTEXT>, <f mixerGetControlDetails>,
 *      <f mixerSetControlDetails>, <t MIXERCONTROL>
 *
 **/

/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK STRUCTURE
 *
 *  @types MIXERCONTROLDETAILS_SIGNED | The <t MIXERCONTROLDETAILS_SIGNED>
 *      structure is used to get and set signed type control details for
 *      an audio mixer control. Refer to the control type description for
 *      the desired control to determine what details structure to use.
 *
 *  @field LONG | lValue | Specifies a signed integer value for a single
 *      item or channel. This value must be inclusively within the bounds
 *      given in the <e MIXERCONTROL.Bounds> structure member of the
 *      <t MIXERCONTROL> structure for signed integer controls.
 *
 *  @comm The following standard control types use the
 *      <t MIXERCONTROLDETAILS_SIGNED> structure for getting and setting
 *      details:
 *
 *      <c MIXERCONTROL_CONTROLTYPE_SIGNEDMETER><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_PEAKMETER><nl>
 *
 *      <c MIXERCONTROL_CONTROLTYPE_SIGNED><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_DECIBELS><nl>
 *
 *      <c MIXERCONTROL_CONTROLTYPE_SLIDER><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_PAN><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_QSOUNDPAN><nl>
 *
 *  @tagname tMIXERCONTROLDETAILS_SIGNED
 *
 *  @othertype MIXERCONTROLDETAILS_SIGNED FAR * | LPMIXERCONTROLDETAILS_SIGNED |
 *      A pointer to a <t MIXERCONTROLDETAILS_SIGNED> structure.
 *
 *  @othertype MIXERCONTROLDETAILS_SIGNED * | PMIXERCONTROLDETAILS_SIGNED |
 *      A pointer to a <t MIXERCONTROLDETAILS_SIGNED> structure.
 *
 *  @xref <t MIXERCONTROLDETAILS_UNSIGNED>, <t MIXERCONTROLDETAILS_BOOLEAN>,
 *      <t MIXERCONTROLDETAILS_LISTTEXT>, <f mixerGetControlDetails>,
 *      <f mixerSetControlDetails>, <t MIXERCONTROL>
 *
 **/

/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK STRUCTURE
 *
 *  @types MIXERCONTROLDETAILS_UNSIGNED | The <t MIXERCONTROLDETAILS_UNSIGNED>
 *      structure is used to get and set unsigned type control details for
 *      an audio mixer control. Refer to the control type description for
 *      the desired control to determine what details structure to use.
 *
 *  @field DWORD | dwValue | Specifies an unsigned integer value for a single
 *      item or channel. This value must be inclusively within the bounds
 *      given in the <e MIXERCONTROL.Bounds> structure member of the
 *      <t MIXERCONTROL> structure for unsigned integer controls.
 *
 *  @comm The following standard control types use the
 *      <t MIXERCONTROLDETAILS_UNSIGNED> structure for getting and setting
 *      details:
 *
 *      <c MIXERCONTROL_CONTROLTYPE_UNSIGNEDMETER><nl>
 *
 *      <c MIXERCONTROL_CONTROLTYPE_UNSIGNED><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_PERCENT><nl>
 *
 *      <c MIXERCONTROL_CONTROLTYPE_FADER><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_VOLUME><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_BASS><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_TREBLE><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_EQUALIZER><nl>
 *
 *      <c MIXERCONTROL_CONTROLTYPE_MICROTIME><nl>
 *      <c MIXERCONTROL_CONTROLTYPE_MILLITIME><nl>
 *
 *  @tagname tMIXERCONTROLDETAILS_UNSIGNED
 *
 *  @othertype MIXERCONTROLDETAILS_UNSIGNED FAR * | LPMIXERCONTROLDETAILS_UNSIGNED |
 *      A pointer to a <t MIXERCONTROLDETAILS_UNSIGNED> structure.
 *
 *  @othertype MIXERCONTROLDETAILS_UNSIGNED * | PMIXERCONTROLDETAILS_UNSIGNED |
 *      A pointer to a <t MIXERCONTROLDETAILS_UNSIGNED> structure.
 *
 *  @xref <t MIXERCONTROLDETAILS_SIGNED>, <t MIXERCONTROLDETAILS_BOOLEAN>,
 *      <t MIXERCONTROLDETAILS_LISTTEXT>, <f mixerGetControlDetails>,
 *      <f mixerSetControlDetails>, <t MIXERCONTROL>
 *
 **/


/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK STRUCTURE
 *
 *  @types MIXERCONTROLDETAILS | The <t MIXERCONTROLDETAILS> structure
 *      references control detail structures to retrieve or set state
 *      information of an audio mixer control. All members of this structure
 *      must be initialized before calling the <f mixerGetControlDetails>
 *      and <f mixerSetControlDetails> functions.
 *
 *  @field DWORD | cbStruct | Specifies the size, in bytes, of the
 *      <t MIXERCONTROLDETAILS> structure. This member must be initialized
 *      before calling the <f mixerGetControlDetails> and
 *      <f mixerSetControlDetails> functions. The size specified in this
 *      member must be large enough to contain the base
 *      <t MIXERCONTROLDETAILS> structure. When the <f mixerGetControlDetails>
 *      function returns, this member contains the actual size of the
 *      information returned. The returned information will never exceed
 *      the requested size and will never be smaller than the base
 *      <t MIXERCONTROLDETAILS> structure.
 *
 *  @field DWORD | dwControlID | Specifies the control identifier to get or
 *      set details on. This member must always be initialized before calling
 *      the <f mixerGetControlDetails> and <f mixerSetControlDetails>
 *      functions.
 *
 *  @field DWORD | cChannels | Specifies the number of channels to get or
 *      set details for. This member can be one of the following values for a
 *      control.
 *
 *      1. If the details for the control are expected on all channels for
 *      a line, then this member must be equal the <e MIXERLINE.cChannels>
 *      member of the <t MIXERLINE> structure.
 *
 *      2. If the control is a <c MIXERCONTROL_CONTROLF_UNIFORM> control, then
 *      this member must be set to one.
 *
 *      3. If the control is not uniform, but the application wishes to
 *      get and set all channels as if they were uniform, then this member
 *      should be set to one.
 *
 *      4. If the control is a <c MIXERCONTROL_CONTROLTYPE_CUSTOM> control,
 *      then this member must be zero.
 *
 *      An application is not allowed to specify any value that comes
 *      between one and the number of channels for the line. For example,
 *      specifying two or three for a four channel line is not valid.
 *      This member can never be zero for non-custom control types.
 *
 *  @field DWORD | cMultipleItems | Specifies the number of multiple items
 *      per channel to get or set details for. This member can be one of
 *      the following values for a control.
 *
 *      1. If the control is not a <c MIXERCONTROL_CONTROLF_MULTIPLE> control,
 *      then this member must be zero.
 *
 *      2. If the control is a <c MIXERCONTROL_CONTROLF_MULTIPLE> control,
 *      then this member must be equal to the <e MIXERCONTROL.cMultipleItems>
 *      member of the <t MIXERCONTROL> structure.
 *
 *      3. If the control is a <c MIXERCONTROL_CONTROLTYPE_CUSTOM> control,
 *      then this member must be zero unless the
 *      <c MIXER_SETCONTROLDETAILSF_CUSTOM> flag is specified for the
 *      <f mixerSetControlDetails> function. In this case, the
 *      <e MIXERCONTROLDETAILS.cMultipleItems> member overlaps with the
 *      <e MIXERCONTROLDETAILS.hwndOwner> member and is therefore the value
 *      of the window handle.
 *
 *      An application is not allowed to specify any value other than the
 *      value specified in the <e MIXERCONTROL.cMultipleItems> member of
 *      the <t MIXERCONTROL> structure for a <c MIXERCONTROL_CONTROLF_MULTIPLE>
 *      control.
 *
 *  @field DWORD | cbDetails | Specifies the size, in bytes, of a single
 *      details structure. This size must be the exact size of the correct
 *      details structure. There are currently four different details
 *      structures:
 *
 *          @flag <t MIXERCONTROLDETAILS_UNSIGNED> | Defines an unsigned
 *          value for a mixer line control.
 *
 *          @flag <t MIXERCONTROLDETAILS_SIGNED> | Defines an signed
 *          value for a mixer line control.
 *
 *          @flag <t MIXERCONTROLDETAILS_BOOLEAN> | Defines a Boolean
 *          value for a mixer line control.
 *
 *          @flag <t MIXERCONTROLDETAILS_LISTTEXT> | Defines a list text
 *          buffer for a mixer line control.
 *
 *      Refer to the description of the control type for information on what
 *      details structure is appropriate for a specific control.
 *
 *      If the control is a <c MIXERCONTROL_CONTROLTYPE_CUSTOM> control,
 *      then this member must be equal to the <e MIXERCONTROL.cbCustomData>
 *      member of the <t MIXERCONTROL> structure.
 *
 *  @field LPVOID | paDetails | Points to an array of one or more details
 *      structures to get or set details for the specified control in. The
 *      required size for this buffer is computed as follows:
 *
 *      1. For controls that are not <c MIXERCONTROL_CONTROLF_MULTIPLE> types,
 *      the size of this buffer is the product of the
 *      <e MIXERCONTROLDETAILS.cChannels> and <e MIXERCONTROLDETAILS.cbDetails>
 *      members of the <t MIXERCONTROLDETAILS> structure.
 *
 *      2. For controls that are <c MIXERCONTROL_CONTROLF_MULTIPLE> types,
 *      the size of this buffer is the product of the
 *      <e MIXERCONTROLDETAILS.cChannels>, <e MIXERCONTROLDETAILS.cMultipleItems>
 *      and <e MIXERCONTROLDETAILS.cbDetails> members of the
 *      <t MIXERCONTROLDETAILS> structure.
 *
 *      The layout of the details elements in this array are as follows:
 *
 *      1. For controls that are not <c MIXERCONTROL_CONTROLF_MULTIPLE> types,
 *      each element index is equivalent to the zero based channel that it
 *      affects. That is, <e MIXERCONTROLDETAILS.paDetails>[0] is for the
 *      left channel, <e MIXERCONTROLDETAILS.paDetails>[1] is for the
 *      right channel.
 *
 *      2. For controls that are <c MIXERCONTROL_CONTROLF_MULTIPLE> types,
 *      the array can be thought of as a two dimensional array that is
 *      'channel major'. That is, all multiple items for the left channel
 *      are given, then all multiple items for the right channel, etc.
 *
 *      If the control is a <c MIXERCONTROL_CONTROLTYPE_CUSTOM> control,
 *      then this member must point to a buffer that is at least large
 *      enough to hold the size, in bytes, specified by the
 *      <e MIXERCONTROL.cbCustomData> member of the <t MIXERCONTROL>
 *      structure.
 *
 *  @tagname tMIXERCONTROLDETAILS
 *
 *  @othertype MIXERCONTROLDETAILS FAR * | LPMIXERCONTROLDETAILS | A pointer
 *      to a <t MIXERCONTROLDETAILS> structure.
 *
 *  @othertype MIXERCONTROLDETAILS * | PMIXERCONTROLDETAILS | A pointer
 *      to a <t MIXERCONTROLDETAILS> structure.
 *
 *  @ex So the following example shows how to address a single item in a
 *      multiple item control for using the <t MIXERCONTROLDETAILS_SIGNED>
 *      details structure. |
 *      {
 *          MIXERCONTROLDETAILS         mxcd;
 *          PMIXERCONTROLDETAILS_SIGNED pamxcd_s;
 *          PMIXERCONTROLDETAILS_SIGNED pmxcd_s;
 *
 *          //
 *          //  'mxcd' is assumed to be a valid MIXERCONTROLDETAILS
 *          //  structure.
 *          //
 *          //  'channel' is assumed to be a valid channel ranging from zero
 *          //  to one less than the number of channels available for the
 *          //  signed control.
 *          //
 *          //  'item' is assumed to be a valid item index ranging from zero
 *          //  to one less than the number of 'multiple items' stored in
 *          //  the variable called 'cMultipleItems'.
 *          //
 *          pamxcd_s = (PMIXERCONTROLDETAILS_SIGNED)mxcd.paDetails;
 *          pmxcd_s  = &pamxcd_s[(channel * cMultipleItems) + item];
 *      }
 *
 *  @xref <f mixerGetLineControls>, <f mixerGetControlDetails>,
 *      <f mixerSetControlDetails>, <t MIXERCONTROL>
 *
 **/

/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK API
 *
 *  @api MMRESULT | mixerGetControlDetails | The <f mixerGetControlDetails>
 *      function is used to retrieve details on a single control associated
 *      with an audio mixer device line.
 *
 *  @parm <c HMIXEROBJ> | hmxobj | Specifies a handle to the audio mixer
 *      device object to get control details for.
 *
 *  @parm LPMIXERCONTROLDETAILS | pmxcd | Points to a <t MIXERCONTROLDETAILS>
 *      structure. This structure is used to reference control detail
 *      structures to be filled with state information about the control.
 *      See the comments for each query flag passed through <p fdwDetails>
 *      for details on what members of the <t MIXERCONTROLDETAILS> structure
 *      must be initialized before calling the <f mixerGetControlDetails>
 *      function. Note that in all cases, the <e MIXERCONTROLDETAILS.cbStruct>
 *      member of the <t MIXERCONTROLDETAILS> structure must be initialized
 *      to be the size, in bytes, of the <t MIXERCONTROLDETAILS> structure.
 *
 *  @parm DWORD | fdwDetails | Specifies flags for getting details on
 *      a control.
 *
 *      @flag <c MIXER_GETCONTROLDETAILSF_VALUE> | If this flag is specified,
 *      the application is interested in getting the current value(s) for a
 *      control. The <e MIXERCONTROLDETAILS.paDetails> member of the
 *      <t MIXERCONTROLDETAILS> points to one or more details structures of
 *      the correct type for the control type. Refer to the description of the
 *      <t MIXERCONTROLDETAILS> structure for information on what each member
 *      of this structure must be initialized before calling the
 *      <f mixerGetControlDetails> function.
 *
 *      @flag <c MIXER_GETCONTROLDETAILSF_LISTTEXT> | If this flag is specified,
 *      the <e MIXERCONTROLDETAILS.paDetails> member of the <t MIXERCONTROLDETAILS>
 *      structure points to one or more <t MIXERCONTROLDETAILS_LISTTEXT>
 *      structures to receive text labels for multiple item controls. Note
 *      that an application must get all list text items for a multiple item
 *      control at once. Refer to the description of the <t MIXERCONTROLDETAILS>
 *      structure for information on what each member of this structure must
 *      be initialized before calling the <f mixerGetControlDetails> function.
 *      This flag cannot be used with <c MIXERCONTROL_CONTROLTYPE_CUSTOM>
 *      controls.
 *
 *      @flag <c MIXER_OBJECTF_MIXER> | Specifies that <p hmxobj> is an audio
 *      mixer device identifier in the range of zero to one less than the
 *      number of devices returned by <f mixerGetNumDevs>. This flag is
 *      optional.
 *
 *      @flag <c MIXER_OBJECTF_HMIXER> | Specifies that <p hmxobj> is a mixer
 *      device handle returned by <f mixerOpen>. This flag is optional.
 *
 *      @flag <c MIXER_OBJECTF_WAVEOUT> | Specifies that <p hmxobj> is a
 *      waveform output device identifier in the range of zero to one less
 *      than the number of devices returned by <f waveOutGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HWAVEOUT> | Specifies that <p hmxobj> is a
 *      waveform output handle returned by <f waveOutOpen>.
 *
 *      @flag <c MIXER_OBJECTF_WAVEIN> | Specifies that <p hmxobj> is a
 *      waveform input device identifier in the range of zero to one less
 *      than the number of devices returned by <f waveInGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HWAVEIN> | Specifies that <p hmxobj> is a
 *      waveform input handle returned by <f midiInOpen>.
 *
 *      @flag <c MIXER_OBJECTF_MIDIOUT> | Specifies that <p hmxobj> is a MIDI
 *      output device identifier in the range of zero to one less than the
 *      number of devices returned by <f midiOutGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HMIDIOUT> | Specifies that <p hmxobj> is a
 *      MIDI output handle returned by <f midiOutOpen>.
 *
 *      @flag <c MIXER_OBJECTF_MIDIIN> | Specifies that <p hmxobj> is a MIDI
 *      input device identifier in the range of zero to one less than the
 *      number of devices returned by <f midiInGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HMIDIIN> | Specifies that <p hmxobj> is a MIDI
 *      input handle returned by <f midiInOpen>.
 *
 *      @flag <c MIXER_OBJECTF_AUX> | Specifies that <p hmxobj> is an
 *      auxiliary device identifier in the range of zero to one less than the
 *      number of devices returned by <f auxGetNumDevs>.
 *
 *  @rdesc The return value is zero if the function is successful. Otherwise,
 *      it returns a non-zero error number. Possible error returns include
 *      the following:
 *
 *      @flag <c MMSYSERR_BADDEVICEID> | The <p hmxobj> argument specifies an
 *      invalid device identifier.
 *
 *      @flag <c MMSYSERR_INVALHANDLE> | The <p hmxobj> argument specifies an
 *      invalid handle.
 *
 *      @flag <c MMSYSERR_INVALFLAG> | One or more flags are invalid.
 *
 *      @flag <c MMSYSERR_INVALPARAM> | One or more arguments passed is
 *      invalid.
 *
 *      @flag <c MMSYSERR_NODRIVER> | No audio mixer device is available for
 *      the object specified by <p hmxobj>.
 *
 *      @flag <c MIXERR_INVALCONTROL> | The control reference is invalid.
 *
 *  @xref <t MIXERCONTROLDETAILS>, <t MIXERCONTROL>, <f mixerGetLineControls>,
 *      <f mixerOpen>, <f mixerSetControlDetails>
 *
 **/

MMRESULT APIENTRY mixerGetControlDetailsA(
    HMIXEROBJ               hmxobj,
    LPMIXERCONTROLDETAILS   pmxcd,
    DWORD                   fdwDetails
)
{
    MIXERCONTROLDETAILS mxcd;
    MMRESULT mmr;
    int cDetails;

    //
    //  Everything is OK unless it's MIXER_GETCONTROLDETAILSF_LISTTEXT
    //

    if ((MIXER_GETCONTROLDETAILSF_QUERYMASK & fdwDetails) !=
        MIXER_GETCONTROLDETAILSF_LISTTEXT) {
        return mixerGetControlDetails(hmxobj, pmxcd, fdwDetails);
    }

    V_WPOINTER(pmxcd, sizeof(DWORD), MMSYSERR_INVALPARAM);

    //
    //  the structure header for MIXERCONTROLDETAILS must be at least the
    //  minimum size
    //
    if (sizeof(MIXERCONTROLDETAILS) > pmxcd->cbStruct)
    {
        DebugErr1(DBF_ERROR, "mixerGetControlDetails: structure size too small or cbStruct not initialized (%lu).", pmxcd->cbStruct);
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pmxcd, pmxcd->cbStruct, MMSYSERR_INVALPARAM);

    if (sizeof(MIXERCONTROLDETAILS_LISTTEXTA) < pmxcd->cbDetails) {
        DebugErr1(DBF_ERROR, "mixerGetControlDetails: structure size too small or cbDetails not initialized for _LISTTEXT (%lu).", pmxcd->cbDetails);
        return (MMSYSERR_INVALPARAM);
    }

    //
    //  Allocate space for the return structure.
    //

    mxcd = *pmxcd;
    cDetails = pmxcd->cChannels * pmxcd->cMultipleItems;

    mxcd.paDetails =
        (PVOID)LocalAlloc(LPTR, cDetails *
                                sizeof(MIXERCONTROLDETAILS_LISTTEXTW));

    mxcd.cbDetails = sizeof(MIXERCONTROLDETAILS_LISTTEXTW);

    if (mxcd.paDetails == NULL) {
        return MMSYSERR_NOMEM;
    }


    //
    //  Call the UNICODE version
    //

    mmr = mixerGetControlDetails(hmxobj, &mxcd, fdwDetails);

    if (mmr != MMSYSERR_NOERROR) {
        LocalFree((HLOCAL)(mxcd.paDetails));
        return mmr;
    }

    //
    //  Copy the return data back
    //

    {
        int i;
        PMIXERCONTROLDETAILS_LISTTEXTW pDetailsW;
        PMIXERCONTROLDETAILS_LISTTEXTA pDetailsA;

        for (i = 0,
             pDetailsW = (PMIXERCONTROLDETAILS_LISTTEXTW)mxcd.paDetails,
             pDetailsA = (PMIXERCONTROLDETAILS_LISTTEXTA)pmxcd->paDetails;

             i < cDetails;

             i++,
             pDetailsW++,
             *(LPBYTE *)&pDetailsA += pmxcd->cbDetails)
        {
            pDetailsA->dwParam1 = pDetailsW->dwParam1;
            pDetailsA->dwParam2 = pDetailsW->dwParam2;
            Iwcstombs(pDetailsA->szName, pDetailsW->szName,
                      sizeof(pDetailsA->szName));
        }
    }

    LocalFree((HLOCAL)mxcd.paDetails);

    return mmr;

} // mixerGetControlDetailsA()

MMRESULT APIENTRY mixerGetControlDetails(
    HMIXEROBJ               hmxobj,
    LPMIXERCONTROLDETAILS   pmxcd,
    DWORD                   fdwDetails
)
{
    DWORD               fdwMxObjType;
    MMRESULT            mmr;
    UINT                uMxId;
    UINT                cDetails;
    BOOL                fResource;

    V_DFLAGS(fdwDetails, MIXER_GETCONTROLDETAILSF_VALID, mixerGetControlDetails, MMSYSERR_INVALFLAG);
    V_WPOINTER(pmxcd, sizeof(DWORD), MMSYSERR_INVALPARAM);

    //
    //  the structure header for MIXERCONTROLDETAILS must be at least the
    //  minimum size
    //
    if (sizeof(MIXERCONTROLDETAILS) > pmxcd->cbStruct)
    {
        DebugErr1(DBF_ERROR, "mixerGetControlDetails: structure size too small or cbStruct not initialized (%lu).", pmxcd->cbStruct);
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pmxcd, pmxcd->cbStruct, MMSYSERR_INVALPARAM);


    switch (MIXER_GETCONTROLDETAILSF_QUERYMASK & fdwDetails)
    {
        case MIXER_GETCONTROLDETAILSF_VALUE:
            //
            //  if both cChannels and cMultipleItems are zero, it is a
            //  custom control
            //
            if ((0 == pmxcd->cChannels) && (0 == pmxcd->cMultipleItems))
            {
                if (0 == pmxcd->cbDetails)
                {
                    DebugErr(DBF_ERROR, "mixerGetControlDetails: cbDetails cannot be zero.");
                    return (MMSYSERR_INVALPARAM);
                }

                V_WPOINTER(pmxcd->paDetails, pmxcd->cbDetails, MMSYSERR_INVALPARAM);

            }
            else
            {
                if (0 == pmxcd->cChannels)
                {
                    DebugErr(DBF_ERROR, "mixerGetControlDetails: cChannels for _VALUE cannot be zero.");
                    return (MMSYSERR_INVALPARAM);
                }


                if (pmxcd->cbDetails < sizeof(MIXERCONTROLDETAILS_SIGNED))
                {
                    DebugErr1(DBF_ERROR, "mixerGetControlDetails: structure size too small or cbDetails not initialized (%lu).", pmxcd->cbDetails);
                    return (MMSYSERR_INVALPARAM);
                }

                //
                //
                //
                cDetails = (UINT)pmxcd->cChannels;
                if (0 != pmxcd->cMultipleItems)
                {
                    cDetails *= (UINT)pmxcd->cMultipleItems;
                }

                V_WPOINTER(pmxcd->paDetails, cDetails * pmxcd->cbDetails, MMSYSERR_INVALPARAM);
            }
            break;

        case MIXER_GETCONTROLDETAILSF_LISTTEXT:
            if (0 == pmxcd->cChannels)
            {
                DebugErr(DBF_ERROR, "mixerGetControlDetails: cChannels for _LISTTEXT cannot be zero.");
                return (MMSYSERR_INVALPARAM);
            }

            if (2 > pmxcd->cMultipleItems)
            {
                DebugErr(DBF_ERROR, "mixerGetControlDetails: cMultipleItems for _LISTTEXT must be 2 or greater.");
                return (MMSYSERR_INVALPARAM);
            }

            if (pmxcd->cbDetails < sizeof(MIXERCONTROLDETAILS_LISTTEXT))
            {
                DebugErr1(DBF_ERROR, "mixerGetControlDetails: structure size too small or cbDetails not initialized (%lu).", pmxcd->cbDetails);
                return (MMSYSERR_INVALPARAM);
            }

            cDetails = (UINT)pmxcd->cChannels * (UINT)pmxcd->cMultipleItems;
            V_WPOINTER(pmxcd->paDetails, cDetails * pmxcd->cbDetails, MMSYSERR_INVALPARAM);
            break;

        default:
            DebugErr1(DBF_ERROR, "mixerGetControlDetails: invalid query flags (%.08lXh).",
                        MIXER_GETCONTROLDETAILSF_QUERYMASK & fdwDetails);
            return (MMSYSERR_INVALFLAG);
    }



    ClientUpdatePnpInfo();

    //
    //
    //
    fdwMxObjType = (MIXER_OBJECTF_TYPEMASK & fdwDetails);

    fResource = FALSE;

    AcquireHandleListResourceShared();
    
    //  Checking for the type of mixer object.  If it is a non-mixer type
    //  calling IMixerMesssageID (called by IMixerGetID) with the shared
    //  resource will deadlock.
    if ((MIXER_OBJECTF_MIXER  == fdwMxObjType) ||
        (MIXER_OBJECTF_HMIXER == fdwMxObjType))
    {
        if (BAD_HANDLE(hmxobj, TYPE_MIXER))
        {
            ReleaseHandleListResource();
        }
        else
        {
            fResource = TRUE;
        }
    }
    else
    {
        ReleaseHandleListResource();
    }
    
    mmr = IMixerGetID(hmxobj, &uMxId, NULL, fdwMxObjType);
    if (MMSYSERR_NOERROR != mmr)
    {
        if (fResource)
            ReleaseHandleListResource();
        return (mmr);
    }

    if ((MIXER_OBJECTF_MIXER  == fdwMxObjType) ||
        (MIXER_OBJECTF_HMIXER == fdwMxObjType))
    {
        //
        //  if a mixer device id was passed, then null hmx so we use the
        //  correct message sender below
        //
        if ((UINT_PTR)hmxobj == uMxId)
            hmxobj = NULL;
    }
    else
    {
        hmxobj = NULL;
    }

    //
    //
    //
    //
    if (NULL != hmxobj)
    {
        mmr = (MMRESULT)IMixerMessageHandle((HMIXER)hmxobj,
                                            MXDM_GETCONTROLDETAILS,
                                            (DWORD_PTR)pmxcd,
                                            fdwDetails);
    }
    else
    {
        mmr = (MMRESULT)IMixerMessageId(uMxId,
                                        MXDM_GETCONTROLDETAILS,
                                        (DWORD_PTR)pmxcd,
                                        fdwDetails);
    }

    return (mmr);
} // mixerGetControlDetails()


/*--------------------------------------------------------------------------;
 *
 *  @doc EXTERNAL MIXER SDK API
 *
 *  @api MMRESULT | mixerSetControlDetails | The <f mixerSetControlDetails>
 *      function is used to set details on a single control associated
 *      with an audio mixer device line.
 *
 *  @parm <c HMIXEROBJ> | hmxobj | Specifies a handle to the audio mixer
 *      device object to set control details for.
 *
 *  @parm LPMIXERCONTROLDETAILS | pmxcd | Points to a <t MIXERCONTROLDETAILS>
 *      structure. This structure is used to reference control detail
 *      structures to that contain the desired state for the control.
 *      See the description for the <t MIXERCONTROLDETAILS> structure
 *      to determine what members of this structure must be initialized
 *      before calling the <f mixerSetControlDetails> function. Note that
 *      in all cases, the <e MIXERCONTROLDETAILS.cbStruct> member of the
 *      <t MIXERCONTROLDETAILS> structure must be initialized
 *      to be the size, in bytes, of the <t MIXERCONTROLDETAILS> structure.
 *
 *  @parm DWORD | fdwDetails | Specifies flags for setting details for
 *      a control.
 *
 *      @flag <c MIXER_SETCONTROLDETAILSF_VALUE> | If this flag is specified,
 *      the application is interested in setting the current value(s) for a
 *      control. The <e MIXERCONTROLDETAILS.paDetails> member of the
 *      <t MIXERCONTROLDETAILS> points to one or more details structures of
 *      the correct type for the control type. Refer to the description of the
 *      <t MIXERCONTROLDETAILS> structure for information on what each member
 *      of this structure must be initialized before calling the
 *      <f mixerSetControlDetails> function.
 *
 *      @flag <c MIXER_SETCONTROLDETAILSF_CUSTOM> | If this flag is specified,
 *      the application is asking the mixer device to display a custom
 *      dialog for the specified custom mixer control. The handle for the
 *      owning window is specified in the <e MIXERCONTROLDETAILS.hwndOwner>
 *      member (this handle may, validly, be NULL). The mixer device will
 *      gather the required information from the user and return the data
 *      in the specified buffer. This data may then be saved by the
 *      application and later set back to the same state using the
 *      <c MIXER_SETCONTROLDETAILSF_VALUE> flag. If an application only
 *      needs to get the current state of a custom mixer control without
 *      displaying a dialog, then the <f mixerGetControlDetails> function
 *      can be used with the <c MIXER_GETCONTROLDETAILSF_VALUE> flag.
 *
 *      @flag <c MIXER_OBJECTF_MIXER> | Specifies that <p hmxobj> is an audio
 *      mixer device identifier in the range of zero to one less than the
 *      number of devices returned by <f mixerGetNumDevs>. This flag is
 *      optional.
 *
 *      @flag <c MIXER_OBJECTF_HMIXER> | Specifies that <p hmxobj> is a mixer
 *      device handle returned by <f mixerOpen>. This flag is optional.
 *
 *      @flag <c MIXER_OBJECTF_WAVEOUT> | Specifies that <p hmxobj> is a
 *      waveform output device identifier in the range of zero to one less
 *      than the number of devices returned by <f waveOutGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HWAVEOUT> | Specifies that <p hmxobj> is a
 *      waveform output handle returned by <f waveOutOpen>.
 *
 *      @flag <c MIXER_OBJECTF_WAVEIN> | Specifies that <p hmxobj> is a
 *      waveform input device identifier in the range of zero to one less
 *      than the number of devices returned by <f waveInGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HWAVEIN> | Specifies that <p hmxobj> is a
 *      waveform input handle returned by <f midiInOpen>.
 *
 *      @flag <c MIXER_OBJECTF_MIDIOUT> | Specifies that <p hmxobj> is a MIDI
 *      output device identifier in the range of zero to one less than the
 *      number of devices returned by <f midiOutGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HMIDIOUT> | Specifies that <p hmxobj> is a
 *      MIDI output handle returned by <f midiOutOpen>.
 *
 *      @flag <c MIXER_OBJECTF_MIDIIN> | Specifies that <p hmxobj> is a MIDI
 *      input device identifier in the range of zero to one less than the
 *      number of devices returned by <f midiInGetNumDevs>.
 *
 *      @flag <c MIXER_OBJECTF_HMIDIIN> | Specifies that <p hmxobj> is a MIDI
 *      input handle returned by <f midiInOpen>.
 *
 *      @flag <c MIXER_OBJECTF_AUX> | Specifies that <p hmxobj> is an
 *      auxiliary device identifier in the range of zero to one less than the
 *      number of devices returned by <f auxGetNumDevs>.
 *
 *  @rdesc The return value is zero if the function is successful. Otherwise,
 *      it returns a non-zero error number. Possible error returns include
 *      the following:
 *
 *      @flag <c MMSYSERR_BADDEVICEID> | The <p hmxobj> argument specifies an
 *      invalid device identifier.
 *
 *      @flag <c MMSYSERR_INVALHANDLE> | The <p hmxobj> argument specifies an
 *      invalid handle.
 *
 *      @flag <c MMSYSERR_INVALFLAG> | One or more flags are invalid.
 *
 *      @flag <c MMSYSERR_INVALPARAM> | One or more arguments passed is
 *      invalid.
 *
 *      @flag <c MMSYSERR_NODRIVER> | No audio mixer device is available for
 *      the object specified by <p hmxobj>.
 *
 *      @flag <c MIXERR_INVALCONTROL> | The control reference is invalid.
 *
 *  @xref <t MIXERCONTROLDETAILS>, <t MIXERCONTROL>, <f mixerGetLineControls>,
 *      <f mixerOpen>, <f mixerGetControlDetails>
 *
 **/

MMRESULT APIENTRY mixerSetControlDetails(
    HMIXEROBJ               hmxobj,
    LPMIXERCONTROLDETAILS   pmxcd,
    DWORD                   fdwDetails
)
{
    DWORD               fdwMxObjType;
    MMRESULT            mmr;
    UINT                uMxId;
    UINT                cDetails;
    BOOL                fResource;

    V_DFLAGS(fdwDetails, MIXER_SETCONTROLDETAILSF_VALID, mixerSetControlDetails, MMSYSERR_INVALFLAG);
    V_WPOINTER(pmxcd, sizeof(DWORD), MMSYSERR_INVALPARAM);

    //
    //  the structure header for MIXERCONTROLDETAILS must be at least the
    //  minimum size
    //
    if (sizeof(MIXERCONTROLDETAILS) > pmxcd->cbStruct)
    {
        DebugErr1(DBF_ERROR, "mixerSetControlDetails: structure size too small or cbStruct not initialized (%lu).", pmxcd->cbStruct);
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pmxcd, pmxcd->cbStruct, MMSYSERR_INVALPARAM);



    switch (MIXER_SETCONTROLDETAILSF_QUERYMASK & fdwDetails)
    {
        case MIXER_SETCONTROLDETAILSF_VALUE:
            //
            //  cChannels is zero for custom controls
            //
            if (0 == pmxcd->cChannels)
            {
                if (0 == pmxcd->cbDetails)
                {
                    DebugErr(DBF_ERROR, "mixerSetControlDetails: cbDetails cannot be zero.");
                    return (MMSYSERR_INVALPARAM);
                }

                V_WPOINTER(pmxcd->paDetails, pmxcd->cbDetails, MMSYSERR_INVALPARAM);

                //
                //
                //
                if (0 != pmxcd->cMultipleItems)
                {
                    DebugErr(DBF_ERROR, "mixerSetControlDetails: cMultipleItems must be zero for custom controls.");
                    return (MMSYSERR_INVALPARAM);
                }
            }
            else
            {
                if (pmxcd->cbDetails < sizeof(MIXERCONTROLDETAILS_SIGNED))
                {
                    DebugErr1(DBF_ERROR, "mixerSetControlDetails: structure size too small or cbDetails not initialized (%lu).", pmxcd->cbDetails);
                    return (MMSYSERR_INVALPARAM);
                }

                cDetails = (UINT)pmxcd->cChannels;

                //
                //
                //
                if (0 != pmxcd->cMultipleItems)
                {
                    cDetails *= (UINT)(pmxcd->cMultipleItems);
                }

                V_WPOINTER(pmxcd->paDetails, cDetails * pmxcd->cbDetails, MMSYSERR_INVALPARAM);
            }
            break;

        case MIXER_SETCONTROLDETAILSF_CUSTOM:
            if (0 == pmxcd->cbDetails)
            {
                DebugErr(DBF_ERROR, "mixerSetControlDetails: cbDetails cannot be zero for custom controls.");
                return (MMSYSERR_INVALPARAM);
            }

            if (0 != pmxcd->cChannels)
            {
                DebugErr(DBF_ERROR, "mixerSetControlDetails: cChannels must be zero for custom controls.");
                return (MMSYSERR_INVALPARAM);
            }

            V_WPOINTER(pmxcd->paDetails, pmxcd->cbDetails, MMSYSERR_INVALPARAM);

            //
            //
            //
            if ((NULL != pmxcd->hwndOwner) && !IsWindow(pmxcd->hwndOwner))
            {
                DebugErr1(DBF_ERROR, "mixerSetControlDetails: hwndOwner must be a valid window handle (%.04Xh).", pmxcd->hwndOwner);
                return (MMSYSERR_INVALHANDLE);
            }
            break;

        default:
            DebugErr1(DBF_ERROR, "mixerSetControlDetails: invalid query flags (%.08lXh).",
                        MIXER_SETCONTROLDETAILSF_QUERYMASK & fdwDetails);
            return (MMSYSERR_INVALFLAG);
    }


    ClientUpdatePnpInfo();

    //
    //
    //
    fdwMxObjType = (MIXER_OBJECTF_TYPEMASK & fdwDetails);

    fResource = FALSE;

    AcquireHandleListResourceShared();
    
    //  Checking for the type of mixer object.  If it is a non-mixer type
    //  calling IMixerMesssageID (called by IMixerGetID) with the shared
    //  resource will deadlock.
    if ((MIXER_OBJECTF_MIXER  == fdwMxObjType) ||
        (MIXER_OBJECTF_HMIXER == fdwMxObjType))
    {
        if (BAD_HANDLE(hmxobj, TYPE_MIXER))
        {
            ReleaseHandleListResource();
        }
        else
        {
            fResource = TRUE;
        }
    }
    else
    {
        ReleaseHandleListResource();
    }
    
    mmr = IMixerGetID(hmxobj, &uMxId, NULL, fdwMxObjType);
    if (MMSYSERR_NOERROR != mmr)
    {
        if (fResource)
            ReleaseHandleListResource();
        return (mmr);
    }

    if ((MIXER_OBJECTF_MIXER  == fdwMxObjType) ||
        (MIXER_OBJECTF_HMIXER == fdwMxObjType))
    {
        //
        //  if a mixer device id was passed, then null hmx so we use the
        //  correct message sender below
        //
        if ((UINT_PTR)hmxobj == uMxId)
            hmxobj = NULL;
    }
    else
    {
        hmxobj = NULL;
    }

    //
    //
    //
    //
    if (NULL != hmxobj)
    {
        mmr = (MMRESULT)IMixerMessageHandle((HMIXER)hmxobj,
                                            MXDM_SETCONTROLDETAILS,
                                            (DWORD_PTR)pmxcd,
                                            fdwDetails);
    }
    else
    {
        mmr = (MMRESULT)IMixerMessageId(uMxId,
                                        MXDM_SETCONTROLDETAILS,
                                        (DWORD_PTR)pmxcd,
                                        fdwDetails);
    }

    return (mmr);
} // mixerSetControlDetails()


//--------------------------------------------------------------------------;
//
//  MMRESULT mixerDesertHandle
//
//  Description:
//      Cleans up the mixer handle and marks it as deserted.
//
//  Arguments:
//      HMIXER hmx:  Mixer handle.
//
//  Return (MMRESULT):  Error code.
//
//  History:
//      01/25/99    Fwong       Adding Pnp Support.
//
//--------------------------------------------------------------------------;

MMRESULT mixerDesertHandle
(
    HMIXER  hmx
)
{
    MMRESULT    mmr;
    PMIXERDEV   pmxdev;
    PMIXERDEV   pmxdevT;
    PMIXERDRV   pmxdrv;
    BOOL        fClose;

    V_HANDLE_ACQ(hmx, TYPE_MIXER, MMSYSERR_INVALHANDLE);

    ENTER_MM_HANDLE(hmx);
    ReleaseHandleListResource();

    if (IsHandleDeserted(hmx))
    {
        //  Handle has already been deserted...
        LEAVE_MM_HANDLE(hmx);
        return (MMSYSERR_NOERROR);
    }

    //  Marking handle as deserted
    SetHandleFlag(hmx, MMHANDLE_DESERTED);

    //
    //  remove the mixer handle from the linked list
    //

    MIXMGR_ENTER;

    pmxdev = (PMIXERDEV)hmx;
    pmxdrv = pmxdev->pmxdrv;

    if (pmxdev == gpMixerDevHeader)
    {
        gpMixerDevHeader = pmxdev->pmxdevNext;
    }
    else
    {
        for (pmxdevT = gpMixerDevHeader;
             pmxdevT && (pmxdevT->pmxdevNext != pmxdev);
             pmxdevT = pmxdevT->pmxdevNext)
            ;

        if (NULL == pmxdevT)
        {
            DebugErr1(DBF_ERROR,
                      "mixerDesertHandle: invalid mixer handle (%.04Xh).",
                      hmx);

            MIXMGR_LEAVE;
            LEAVE_MM_HANDLE(hmx);

            return (MMSYSERR_INVALHANDLE);
        }

        pmxdevT->pmxdevNext = pmxdev->pmxdevNext;
    }

    //
    // see if this is the last handle on this open instance
    //
    fClose = TRUE;
    if (gpMixerDevHeader)
    {
	    PMIXERDEV   pmxdevT2;
        for (pmxdevT2 = gpMixerDevHeader; pmxdevT2; pmxdevT2 = pmxdevT2->pmxdevNext)
        {
            if (pmxdevT2->pmxdrv != pmxdev->pmxdrv) continue;
            if (pmxdevT2->wDevice != pmxdev->wDevice) continue;
    	    fClose = FALSE;
    	    break;
        }
    }

    MIXMGR_LEAVE;

    if (fClose)
    {
        EnterCriticalSection(&pmxdev->pmxdrv->MixerCritSec);
        mmr = (*(pmxdrv->drvMessage))(pmxdev->wDevice, MXDM_CLOSE, pmxdev->dwDrvUser, 0L, 0L);
        LeaveCriticalSection(&pmxdev->pmxdrv->MixerCritSec);
        
        if (MMSYSERR_NOERROR != mmr)
        {
            //  Close message failed.
            //  Should we put the handle back in the list???
            LEAVE_MM_HANDLE(hmx);
            return mmr;
        }
    }

    LEAVE_MM_HANDLE(hmx);
    
    mregDecUsage(PTtoH(HMD, pmxdev->pmxdrv));

    return MMSYSERR_NOERROR;
} // mixerDesertHandle()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\mmio.c ===
/* Copyright (c) 1991-1999 Microsoft Corporation */
/*-------------------------------------------------------------------*\
 *
 * mmio.c
 *
 * Basic MMIO functions.
 *
\*-------------------------------------------------------------------*/

/*--------------------------------------------------------------------*/
/* Revision history:
 * LaurieGr: Jan 92 Ported from win16.  Source tree fork, not common code.
 * StephenE: Apr 92 Enabled UNICODE.
 */
/*--------------------------------------------------------------------*/


/*--------------------------------------------------------------------*/
/* Implementation notes:
 *
 * An HMMIO is in fact a PMMIO i.e. a pointer to a MMIOINFO.
 * This causes the code to be littered with casts.
 * Whoever exported MMIOINFO should learn about encapsulation and
 * all that stuff.  sigh.
 *
 * The "current disk offset" is the disk offset (i.e. the location
 * in the disk file) that the next MMIOM_READ or MMIOM_WRITE will
 * read from or write to.  The I/O procedure maintains the
 * <lDiskOffset> field of the file's MMIO structure so that
 * <lDiskOffset> is equal to the current disk offset.
 *
 * The "current buffered offset" is the disk offset that the next
 * mmioRead() or mmioWrite() call would read from or write to.
 * The current buffered offset is defined as
 *
 *  <lBufOffset> + (<pchNext> - <pchBuffer>)
 *
 * since <lBufOffset> is the disk offset of the start of the buffer
 * and <pchNext> corresponds to the current buffered offset.
 *
 * If the file is unbuffered, then <pchBuffer>, <pchNext>,
 * <pchEndRead> and <pchEndWrite> will always be NULL, and
 * <lBufOffset> will always be considered the "current buffered
 * offset", i.e. mmioRead() and mmioWrite() will read/write
 * at this offset.
 *
 *
 * Except right at the beginning of mmioOpen(), the MMIO_ALLOCBUF
 * flag is set if and only if the pchBuffer field points to a block
 * of global memory that MMIO has allocated.
 */
/*--------------------------------------------------------------------*/

#include "winmmi.h"
#include "mmioi.h"


/*--------------------------------------------------------------------*\
 * Local function prototypes
\*--------------------------------------------------------------------*/
static void NEAR PASCAL SetIOProc( LPCWSTR szFileName, LPMMIOINFO lpmmio);
static LPMMIOPROC NEAR PASCAL RemoveIOProc(FOURCC fccIOProc, HANDLE htask);
static LONG NEAR PASCAL mmioDiskIO(PMMIO pmmio, UINT uMsg, LPSTR pch, LONG cch);
static UINT NEAR PASCAL mmioExpandMemFile(PMMIO pmmio, LONG lExpand);
static LPMMIOPROC mmioInternalInstallIOProc( FOURCC fccIOProc,
                                             LPMMIOPROC pIOProc,
                                             DWORD dwFlags);

/*--------------------------------------------------------------------*/
/* The I/O procedure map is a linked list of IOProcMapEntry structures.
 * The head of the list, <gIOProcMapHead> is a pointer node to the last
 * entry registered.  The first few elements of the list are the predefined
 * global IO procedures below -- these all have <hTask> equal to NULL so
 * that no task can unregister them.
 *
 */

typedef struct IOProcMapEntryTag
{
        FOURCC          fccIOProc;      // ID of installed I/O procedure
        LPMMIOPROC      pIOProc;        // I/O procedure address
        HANDLE          hTask;          // task that called mmioRegisterIOProc()
        struct IOProcMapEntryTag *pNext;  // pointer to next IOProc entry
} IOProcMapEntry, *pIOProcMapEntry;

// MMIOPROC is defined in the public MMSYSTEM.H
// typedef LONG (APIENTRY MMIOPROC)(LPSTR lpmmioinfo, UINT uMsg, LONG lParam1, LONG lParam2);

MMIOPROC mmioDOSIOProc, mmioMEMIOProc; // standard I/O procedures

static IOProcMapEntry gIOProcMaps[] = {
    { FOURCC_DOS, mmioDOSIOProc, NULL,  &gIOProcMaps[1] },
    { FOURCC_MEM, mmioMEMIOProc, NULL,  NULL }
};

//
// Global head of list
//

static pIOProcMapEntry gIOProcMapHead = gIOProcMaps;

#ifdef DUMPIOPROCLIST
/* debug dump of ioproclist */
static void DumpIOProcList(void)
{  pIOProcMapEntry pph;

   dprintf(("gIOProcMapHead= %8x\n",gIOProcMapHead ));
   for (pph = gIOProcMapHead;pph ;pph=pph->pNext)
   {  dprintf(( "fourcc=%c%c%c%c pioproc=%8x hTask=%8x\n"
             , pph->fccIOProc/16777216
             , (pph->fccIOProc/65536)%256
             , (pph->fccIOProc/256)%256
             , (pph->fccIOProc)%256
             , pph->pIOProc
             , pph->hTask
             ));
   }
} /* DumpIOProcList */
#endif


/* Call the IOProc in the info structure and return the result.
   Take due account of whether it is a 16 or 32 bit IOProc.
*/
static LRESULT IOProc(LPMMIOINFO lpmmioinfo, UINT uMsg, LPARAM lParam1, LPARAM lParam2)
{
    /*  just pass the call on */
    return ((LPMMIOPROC)(lpmmioinfo->pIOProc)) ((LPSTR)lpmmioinfo, uMsg, lParam1, lParam2);
} /* IOProc */

/*--------------------------------------------------------------------*/
/* @doc INTERNAL

@func   LPMMIOPROC | FindIOProc | This function locates the IOProcMapEntry
    for a previously installed IO procedure .
*/
/*--------------------------------------------------------------------*/
static pIOProcMapEntry
                  FindIOProc(FOURCC fccIOProc, HANDLE htask)
{
    IOProcMapEntry *pEnt;       // an entry in linked list

    /* walk through the linked list, first looking for an entry with
     * identifier <fccIOProc> that was added by the current task, then
     * looking for global entries.
     */

    for (pEnt = gIOProcMapHead; pEnt; pEnt = pEnt->pNext)
        if ((pEnt->fccIOProc == fccIOProc) && (pEnt->hTask == htask))
            return pEnt;

    for (pEnt = gIOProcMapHead; pEnt; pEnt = pEnt->pNext)
        if ( (pEnt->fccIOProc == fccIOProc)
                                           // ?? && (pEnt->hTask ==NULL)  ??
           )
            return pEnt;

    return NULL;
}

/*--------------------------------------------------------------------*/
/* @doc INTERNAL

@func   LPMMIOPROC | RemoveIOProc | This function removes previously installed
    IO procedure.
*/
/*--------------------------------------------------------------------*/
static LPMMIOPROC PASCAL NEAR
                  RemoveIOProc(FOURCC fccIOProc, HANDLE htask)
{
    IOProcMapEntry *pEnt;       // an entry in linked list
    IOProcMapEntry *pEntPrev;   // the entry before <pEnt>

    /* walk through the linked list, looking for an entry with
     * identifier <fccIOProc> that was added by the current task
     */
    for ( pEntPrev = NULL, pEnt = gIOProcMapHead
        ; pEnt
        ; pEntPrev = pEnt, pEnt = pEnt->pNext
        )
        if ((pEnt->fccIOProc == fccIOProc) && (pEnt->hTask == htask)) {
            LPMMIOPROC  pIOProc;

            pIOProc = pEnt->pIOProc;
            if (pEntPrev)
                pEntPrev->pNext = pEnt->pNext;
            else
                gIOProcMapHead = pEnt->pNext;
            FreeHandle((HMMIO) pEnt);
            return pIOProc;
        }
    return NULL;
}

/*--------------------------------------------------------------------*/
/* @doc INTERNAL

@func   void | SetIOProc | This function sets the physical IO procedure
    based on either the file name or the parameters within the
    <p lpmmioinfo> structure passed.

@parm   LPCWSTR | szFilename | Specifies a pointer to a string
containing the filename of the file to open. If no I/O procedure is

@parm   LPMMIOINFO | lpmmioinfo | Specifies a pointer to an
    <t MMIOINFO> structure containing extra parameters used by
    <f SetIOProc> in determining the IO procedure to use.  The
    <e MMIOINFO.pIOProc> element is set to the procedure found.

@rdesc  Nothing.
*/
/*--------------------------------------------------------------------*/
static void NEAR PASCAL
            SetIOProc( LPCWSTR szFileName, LPMMIOINFO lpmmio)
{
    IOProcMapEntry *pEnt;       // the entry in linked list

    /* If the IOProc is not given, see if the file name implies that
     * <szFileName> is either a RIFF compound file or some kind of
     * other registered storage system -- look for the last CFSEPCHAR in
     * the name, e.g. '+' in "foo.bnd+bar.hlp+blorg.dib", and figure
     * that the IOProc ID is the extension of the compound file name,
     * e.g. the extension of "foo.bnd+bar.hlp", i.e. 'HLP '.
     *
     * Alternatively, if <szFileName> is NULL, then assume that
     * <lpmmio->adwInfo[0]> is a DOS file handle.
    */
    if (lpmmio->pIOProc == NULL)
    {
        if (lpmmio->fccIOProc == 0)
        {
            if (szFileName != NULL)
            {
                LPWSTR   pch;

                /* see if <szFileName> contains CFSEPCHAR */
                if ((pch = wcsrchr(szFileName, CFSEPCHAR)) != 0)
                {
                    /* find the extension that precedes CFSEPCHAR,
                     * e.g. "hlp" in "foo.bnd+bar.hlp+blorg.dib"
                    */
                    while (  (pch > szFileName)
                          && (*pch != '.')
                          && (*pch != ':')
                          && (*pch != '\\')
                          )
                        pch--;
                    if (*pch == '.')
                    {
                        WCHAR    aszFour[sizeof(FOURCC)+1];
                        int i;

                        for (i = 0, pch++; i < sizeof(FOURCC); i++)
                            if (*pch == CFSEPCHAR)
                                aszFour[i] = (WCHAR)0;
                            else
                                aszFour[i] = *pch++;
                        aszFour[sizeof(FOURCC)] = (WCHAR)0;
                        lpmmio->fccIOProc
                                 = mmioStringToFOURCCW(aszFour, MMIO_TOUPPER);
                    }
                }
            }
            /* if the caller didn't specify an IOProc, and the code above
             * didn't determine an IOProc ID, then the default is the DOS
             * IOProc.
            */
            if (lpmmio->fccIOProc == 0)
                lpmmio->fccIOProc = FOURCC_DOS;
        }

        /* unless an IOProc address is specified explicitly, look up the
         * IOProc in the global IOProc ID-to-address table -- the default
         * is 'DOS' since we'll assume that custom storage system I/O
         * procedures would have been installed
        */
        pEnt = FindIOProc( lpmmio->fccIOProc
                         ,   lpmmio->htask
                           ? lpmmio->htask
                           : GetCurrentTask()
                         );
        if (pEnt && pEnt->pIOProc) {
            lpmmio->pIOProc = pEnt -> pIOProc;
        }
        else {
            lpmmio->pIOProc = mmioDOSIOProc;
            lpmmio->dwReserved1 = 0;
        }
    }
}


/*--------------------------------------------------------------------*/
/* @doc INTERNAL

@func   void | mmioCleanupIOProcs | removes from the linked list entries
    installed with the given task handle

@parm   HANDLE | hTask | Specifies the task to clean up for

@rdesc  Nothing.

@comm  This will only be called to clean up a WOW task.
*/
/*--------------------------------------------------------------------*/
void mmioCleanupIOProcs(HANDLE hTask)
{
     IOProcMapEntry *pEnt;
     IOProcMapEntry *pEntPrev;

     for (pEntPrev = NULL, pEnt = gIOProcMapHead; pEnt;) {

        if (pEnt->hTask == hTask) {
            dprintf1(("MMIOPROC handle (%04X) not closed.", pEnt));
            if (pEntPrev) {
                pEntPrev->pNext = pEnt->pNext;
                FreeHandle((HMMIO)pEnt);
                pEnt = pEntPrev->pNext;
            } else {
                gIOProcMapHead = pEnt->pNext;
                FreeHandle((HMMIO)pEnt);
                pEnt = gIOProcMapHead;
            }
        } else {
            pEntPrev = pEnt;
            pEnt = pEnt->pNext;
        }
     }
}



/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    UINT | mmioRename | This function renames the specified file.

@parm   LPCTSTR | szFilename | Specifies a pointer to a string
containing the filename of the file to rename.

@parm   LPCTSTR | szNewFileName | Specifies a pointer to a string
containing the new filename.

@parm   LPMMIOINFO | lpmmioinfo | Specifies a pointer to an
    <t MMIOINFO> structure containing extra parameters used by
    <f mmioRename>.

    If <p lpmmioinfo> is not NULL, all unused fields of the
    <t MMIOINFO> structure it references must be set to zero, including the
    reserved fields.

@parm   DWORD | dwRenameFlags | Specifies option flags for the rename
    operation.  This should be set to zero.

@rdesc  The return value is zero if the file was renamed.  Otherwise, the
return value is an error code returned from <f mmioRename> or from the I/O
procedure.
*/
/*--------------------------------------------------------------------*/
UINT APIENTRY
     mmioRenameW( LPCWSTR        szFileName
                , LPCWSTR        szNewFileName
                , LPCMMIOINFO    lpmmioinfo
                , DWORD          fdwRename
                )
{
    MMIOINFO    mmioinfo;

    ZeroMemory( &mmioinfo, sizeof( MMIOINFO ) );

    V_RPOINTER0(lpmmioinfo, sizeof(MMIOINFO), MMSYSERR_INVALPARAM);
    if (lpmmioinfo) {
        V_CALLBACK0((FARPROC)lpmmioinfo->pIOProc, MMSYSERR_INVALPARAM);
        mmioinfo = *lpmmioinfo;
    }

    SetIOProc(szFileName, &mmioinfo);

    if ( (mmioinfo.dwFlags & MMIO_UNICODEPROC )
      || (mmioinfo.pIOProc == mmioDOSIOProc )     // or the DOS file IO Proc
      || (mmioinfo.pIOProc == mmioMEMIOProc ) ) { // or a memory file IO Proc

        /*------------------------------------------------------------*\
         * We have an unicode IO Proc so use the given file names
         * without any conversion.
        \*------------------------------------------------------------*/
        return (UINT)IOProc( &mmioinfo, MMIOM_RENAME,
                       (LPARAM)szFileName, (LPARAM)szNewFileName );
    } else {

        UINT    uiRc;
        LPSTR   pAsciiFileName;      // Ascii version of szFileName
        LPSTR   pAsciiNewFileName;   // Ascii version of szNewFileName

        /*------------------------------------------------------------*\
         * We have an ascii IO Proc so convert the given file names
         * into ascii.
        \*------------------------------------------------------------*/
        pAsciiFileName = AllocAsciiStr( szFileName );
        if ( pAsciiFileName == (LPSTR)NULL ) {
            return MMIOERR_OUTOFMEMORY;
        }

        pAsciiNewFileName = AllocAsciiStr( szNewFileName );
        if ( pAsciiNewFileName == (LPSTR)NULL ) {
            FreeAsciiStr( pAsciiFileName );
            return MMIOERR_OUTOFMEMORY;
        }

        uiRc = (UINT)IOProc( &mmioinfo,
                       MMIOM_RENAME,
                       (LPARAM)pAsciiFileName,
                       (LPARAM)pAsciiNewFileName );

        FreeAsciiStr( pAsciiFileName );
        FreeAsciiStr( pAsciiNewFileName );

        return uiRc;
    }

}

UINT APIENTRY
     mmioRenameA( LPCSTR        szFileName
                , LPCSTR        szNewFileName
                , LPCMMIOINFO   lpmmioinfo
                , DWORD         fdwRename
                )
{
    MMIOINFO    mmioinfo;
    LPWSTR      pUnicodeFileName;
    LPWSTR      pUnicodeNewFileName;
    UINT        uiRc;

    ZeroMemory( &mmioinfo, sizeof( MMIOINFO ) );

    V_RPOINTER0(lpmmioinfo, sizeof(MMIOINFO), MMSYSERR_INVALPARAM);
    if (lpmmioinfo) {
        V_CALLBACK0((FARPROC)lpmmioinfo->pIOProc, MMSYSERR_INVALPARAM);
        mmioinfo = *lpmmioinfo;
    }

    /*----------------------------------------------------------------*\
     * SetIOProc only works with unicode strings, therefore we always
     * have to convert szFileName to unicode, so:
     * Allocate some storage to hold the unicode version of szFileName.
     * Do the acsii to unicode conversion .
     * Call SetIOProc
    \*----------------------------------------------------------------*/
    pUnicodeFileName = AllocUnicodeStr( szFileName );
    if ( pUnicodeFileName == (LPWSTR)NULL ) {
        return MMIOERR_OUTOFMEMORY;
    }
    SetIOProc( pUnicodeFileName, &mmioinfo );

    if ( (mmioinfo.dwFlags & MMIO_UNICODEPROC )
      || (mmioinfo.pIOProc == mmioDOSIOProc )     // or the DOS file IO Proc
      || (mmioinfo.pIOProc == mmioMEMIOProc ) ) { // or a memory file IO Proc

        /*------------------------------------------------------------*\
         * We have a unicode IO Proc, this means that we have to
         * convert szNewFileName to unicode too.
        \*------------------------------------------------------------*/
        pUnicodeNewFileName = AllocUnicodeStr( szNewFileName );
        if ( pUnicodeNewFileName == (LPWSTR)NULL ) {
            FreeUnicodeStr( pUnicodeFileName );
            return MMIOERR_OUTOFMEMORY;
        }

        uiRc = (UINT)IOProc( &mmioinfo,
                       MMIOM_RENAME,
                       (LPARAM)pUnicodeFileName,
                       (LPARAM)pUnicodeNewFileName );

        FreeUnicodeStr( pUnicodeNewFileName );

    } else {

        /*------------------------------------------------------------*\
         * We have an ascii IO Proc so use the given file names
         * without any conversion.
        \*------------------------------------------------------------*/
        uiRc = (UINT)IOProc( &mmioinfo, MMIOM_RENAME,
                       (LPARAM)szFileName, (LPARAM)szNewFileName);
    }

    FreeUnicodeStr( pUnicodeFileName );
    return uiRc;
}

/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    HMMIO | mmioOpen | This function opens a file for unbuffered
    or buffered I/O. The file can be a DOS file, a memory file, or an
    element of a custom storage system.

@parm   LPTSTR | szFilename | Specifies a pointer to a string
containing the filename of the file to open. If no I/O procedure is
specified to open the file, then the filename determines how the file
is opened, as follows:

    -- If the filename does not contain "+", then it is assumed
    to be the name of a DOS file.

    -- If the filename is of the form "foo.ext+bar", then the
    extension "EXT " is assumed to identify an installed I/O procedure
    which is called to perform I/O on the file (see <f mmioInstallIOProc>).

    -- If the filename is NULL and no I/O procedure is given, then
    <e MMIOINFO.adwInfo[0]> is assumed to be the DOS file handle
    of a currently open file.

    The filename should not be longer than 128 bytes, including the
    terminating NULL.

    When opening a memory file, set <p szFilename> to NULL.

@parm   LPMMIOINFO | lpmmioinfo | Specifies a pointer to an
    <t MMIOINFO> structure containing extra parameters used by
    <f mmioOpen>. Unless you are opening a memory file, specifying the
    size of a buffer for buffered I/O, or specifying an uninstalled I/O
    procedure to open a file, this parameter should be NULL.

    If <p lpmmioinfo> is not NULL, all unused fields of the
    <t MMIOINFO> structure it references must be set to zero, including the
    reserved fields.

@parm   DWORD | dwOpenFlags | Specifies option flags for the open
    operation. The MMIO_READ, MMIO_WRITE, and MMIO_READWRITE flags are
    mutually exclusive--only one should be specified. The MMIO_COMPAT,
    MMIO_EXCLUSIVE, MMIO_DENYWRITE, MMIO_DENYREAD, and MMIO_DENYNONE flags
    are DOS file-sharing flags, and can only be used after the DOS
    command SHARE has been executed.

    @flag   MMIO_READ | Opens the file for reading only.  This is the
        default, if MMIO_WRITE and MMIO_READWRITE are not specified.

    @flag   MMIO_WRITE | Opens the file for writing.  You should not
        read from a file opened in this mode.

    @flag   MMIO_READWRITE | Opens the file for both reading and writing.

    @flag   MMIO_CREATE | Creates a new file.
        If the file already exists, it is truncated to zero length.
        For memory files, MMIO_CREATE indicates the end of the file
        is initially at the start of the buffer.

    @flag   MMIO_DELETE | Deletes a file. If this flag is specified,
        <p szFilename> should not be NULL. The return
        value will be TRUE (cast to HMMIO) if the file was deleted
        successfully, FALSE otherwise.  Do not call <f mmioClose>
        for a file that has been deleted.  If this flag is specified,
        all other file opening flags are ignored.

    @flag   MMIO_PARSE | Creates a fully qualified filename from the path
        specified in <p szFileName>. The fully qualified filename is
        placed back into <p szFileName>. The return value
        will be TRUE (cast to HMMIO) if the qualification was
        successful, FALSE otherwise. The file is not opened, and the function
        does not return a valid MMIO file handle, so do not attempt to
        close the file. If this flag is specified, all other file
        opening flags are ignored.

    @flag   MMIO_EXIST | Determines whether the specified file exists
        and creates a fully qualified filename from the path
        specified in <p szFileName>. The fully qualified filename is
        placed back into <p szFileName>. The return value
        will be TRUE (cast to HMMIO) if the qualification was
        successful and the file exists, FALSE otherwise. The file is
        not opened, and the function does not return a valid MMIO file
        handle, so do not attempt to close the file.

    @flag   MMIO_ALLOCBUF | Opens a file for buffered I/O.
        To allocate a buffer larger or smaller than the default
        buffer size (8K), set the <e MMIOINFO.cchBuffer> field of the
        <t MMIOINFO> structure to the desired buffer size. If
        <e MMIOINFO.cchBuffer> is zero, then the default buffer size
        is used. If you are providing your own I/O buffer, then the
        MMIO_ALLOCBUF flag should not be used.

    @flag   MMIO_COMPAT | Opens the file with compatibility mode,
        allowing any process on a given machine to open the file
        any number of times.  <f mmioOpen> fails if the file has
        been opened with any of the other sharing modes.

    @flag   MMIO_EXCLUSIVE | Opens the file with exclusive mode,
        denying other processes both read and write access to the file.
        <f mmioOpen> fails if the file has been opened in any other
        mode for read or write access, even by the current process.

    @flag   MMIO_DENYWRITE | Opens the file and denies other
        processes write access to the file.  <f mmioOpen> fails
        if the file has been opened in compatibility or for write
        access by any other process.

    @flag   MMIO_DENYREAD | Opens the file and denies other
        processes read access to the file.  <f mmioOpen> fails if the
        file has been opened in compatibility mode or for read access
        by any other process.

    @flag   MMIO_DENYNONE | Opens the file without denying other
        processes read or write access to the file.  <f mmioOpen>
        fails if the file has been opened in compatibility mode
        by any other process.

    @flag   MMIO_GETTEMP | Creates a temporary filename, optionally
        using the parameters passed in <p szFileName> to determine
        the temporary name. For example, you can specify "C:F" to
        create a temporary file residing on drive C, starting with
        letter "F". The resulting filename is placed in the buffer
        pointed to by <p szFileName>.  The return value will be TRUE
        (cast to HMMIO) if the temporary filename was created successfully,
        FALSE otherwise. The file is
        not opened, and the function does not return a valid MMIO file
        handle, so do not attempt to close the file.
        This flag overrides all other flags.

@rdesc  The return value is a handle to the opened file. This handle
    is not a DOS file handle--do not use it with any file I/O functions
    other than MMIO functions.

    If the file cannot be opened, the return value is NULL.  If
    <p lpmmioinfo> is not NULL, then its <e MMIOINFO.wErrorRet> field
    will contain extended error information returned by the I/O
    procedure.

@comm   If <p lpmmioinfo> references an <t MMIOINFO> structure, set
up the fields as described below. All unused fields must be set to
zero, including reserved fields.

-- To request that a file be opened with an installed I/O
procedure, set the <e MMIOINFO.fccIOProc> field
to the four-character code of the I/O procedure,
and set the <e MMIOINFO.pIOProc> field to NULL.

-- To request that a file be opened with an uninstalled I/O procedure,
set the <e MMIOINFO.pIOProc> field to
point to the I/O procedure, and set <e MMIOINFO.fccIOProc> to NULL.

-- To request that <f mmioOpen> determine which I/O procedure to use
to open the file based on the filename contained in <p szFilename>,
set both <e MMIOINFO.fccIOProc> and <e MMIOINFO.pIOProc> to NULL.
This is the default behavior if no <t MMIOINFO> structure is specified.

-- To open a memory file using an internally allocated and managed
buffer, set the <e MMIOINFO.pchBuffer> field to NULL,
<e MMIOINFO.fccIOProc> to FOURCC_MEM,
<e MMIOINFO.cchBuffer> to the initial size of the buffer, and
<e MMIOINFO.adwInfo[0]> to the incremental expansion size of the
buffer. This memory file will automatically be expanded in increments of
<e MMIOINFO.adwInfo[0]> bytes when necessary. Specify the MMIO_CREATE
flag for the <p dwOpenFlags> parameter to initially set the end of
the file to be the beginning of the buffer.

-- To open a memory file using a caller-supplied buffer, set
the <e MMIOINFO.pchBuffer> field to point to the memory buffer,
<e MMIOINFO.fccIOProc> to FOURCC_MEM,
<e MMIOINFO.cchBuffer> to the size of the buffer, and
<e MMIOINFO.adwInfo[0]> to the incremental expansion size of the
buffer. The expansion size in <e MMIOINFO.adwInfo[0]> should only
be non-zero if <e MMIOINFO.pchBuffer> is a pointer obtained by calling
<f GlobalAlloc> and <f GlobalLock>, since <f GlobalReAlloc> will be called to
expand the buffer.  In particular, if <e MMIOINFO.pchBuffer> points to a
local or global array, a block of memory in the local heap, or a block
of memory allocated by <f GlobalDosAlloc>, <e MMIOINFO.adwInfo[0]> must
be zero.
Specify the MMIO_CREATE flag for the <p dwOpenFlags> parameter to
initially set the end of the file to be the beginning of the buffer;
otherwise, the entire block of memory will be considered readable.

-- To use a currently open DOS file handle with MMIO, set the
<e MMIOINFO.fccIOProc> field to FOURCC_DOS,
<e MMIOINFO.pchBuffer> to NULL, and <e MMIOINFO.adwInfo[0]> to the
DOS file handle.  Note that offsets within the file will be relative to
the beginning of the file, and will not depend on the DOS file position
at the time <f mmioOpen> is called; the initial MMIO offset will be the same
as the DOS offset when <f mmioOpen> is called.
Later, to close the MMIO file handle without closing the DOS
file handle, pass the MMIO_FHOPEN flag to <f mmioClose>.

You must call <f mmioClose> to close a file opened with <f mmioOpen>.
Open files are not automatically closed when an application exits.

@xref   mmioClose
*/

/* these are the changes to mmioOpen() to support compound files... */

/* @doc CFDOC

@api    HMMIO | mmioOpen | ...The file can be a DOS file, a memory file,
    an element of a RIFF compound file...

@parm   LPTSTR | szFilename | ...

    -- If <p szFilename> is of the form "foo+bar", then <f mmioOpen>
    opens the compound file element named "bar" that is stored inside
    the RIFF compound file named "foo".

    -- If <p szFilename> is of the form "foo.ext+bar", then the
    extension "ext" is assumed to identify the installed I/O procedure
    (see <f mmioInstallIOProc>).  The extension "bnd", and any extensions
    that have not been installed, are assumed to refer to a RIFF compound
    file.

@parm   LPMMIOINFO | lpmmioinfo | ...

@parm   DWORD | dwOpenFlags | ...

@rdesc  ...

@comm   ...

    The following I/O procedure identifiers (type FOURCC) are predefined:

    ...

    FOURCC_BND: <p szFilename> is assumed to be the name of
    a RIFF compound file element, and <p adwInfo[0]> should
    contain the HMMCF of the compound file.  Alternatively,
    <p szFilename> can include the name of the compound file
    (e.g. "foo.bnd+bar.dib" as described above), and <p adwInfo[0]>
    should be NULL, to automatically open the compound file.

    ...

    The easy way to open an element of a RIFF compound file: just
    include the name of the compound file in <p szFilename> preceded
    by a "+" as described above.  For example, opening
    "c:\data\bar.bnd+blorg.dib" opens the compound file element
    named "blorg.dib" in the compound file "c:\data\bar.bnd".
    <p lpmmioinfo> can be null in this case -- set <p dwOpenFlags>
    as described above.  You can use this same method to open an
    element of a custom storage system, if the file extension of the
    compound file ("bnd" in the above example) corresponds to an
    installed I/O procedure -- see <f mmioInstallIOProc> for details.

    To open an element of a RIFF compound file that was opened using
    <f mmioCFAccess> or <f mmioCFOpen>: set <p szFilename>
    to be the name of the compound file element; set <p fccIOProc>
    to FOURCC_BND; set <p adwInfo[0]> to the HMMCF of the open compound
    file; set <p dwOpenFlags> and <p cchBuffer> as described above;
    set all other fields of <p lpmmioinfo> to zero.

    ...
*/
/*--------------------------------------------------------------------*/
HMMIO APIENTRY
      mmioOpenW( LPWSTR szFileName, LPMMIOINFO lpmmioinfo, DWORD dwOpenFlags )
{
    PMMIO       pmmio;      // MMIO status block
    LPSTR       hpBuffer;
    UINT        w;          // an MMRESULT or a LRESULT from an IOPROC

    V_FLAGS(dwOpenFlags, MMIO_OPEN_VALID, mmioOpen, NULL);
    V_WPOINTER0(lpmmioinfo, sizeof(MMIOINFO), NULL);

    if (lpmmioinfo) {
        lpmmioinfo->wErrorRet = 0;
        V_CALLBACK0((FARPROC)lpmmioinfo->pIOProc, NULL);
    }

    /* allocate MMIO status information block */
    if ( (pmmio = (PMMIO)(NewHandle(TYPE_MMIO, NULL, sizeof(MMIOINFO)))) == NULL)
    {
        if (lpmmioinfo) {
            lpmmioinfo->wErrorRet = MMIOERR_OUTOFMEMORY;
        }
        return NULL;
    }

    //  Implicitly acquired by NewHandle()
    ReleaseHandleListResource();

    /*----------------------------------------------------------------*\
     * NewHandle does not zero the allocated storage so we had better do
     * it now.
    \*----------------------------------------------------------------*/
    ZeroMemory( pmmio, sizeof(MMIOINFO) );

    /* if user supplied <lpmmioinfo>, copy it to <pmmio> */
    if (lpmmioinfo != NULL) {
        *pmmio = *lpmmioinfo;
    }

    /* <dwOpenFlags> always takes precedence over contents of <pmmio> */
    pmmio->dwFlags = dwOpenFlags;
    pmmio->hmmio = ((HMMIO)pmmio);

    /* MMIO_ALLOCBUF in the flags means that the user wants a buffer
     * allocated for buffered I/O, but after this point it means that
     * a buffer *was* allocated, so turn off the flag until the buffer
     * is actually allocated (which is done by mmioSetBuffer() below)
     */
    if (pmmio->dwFlags & MMIO_ALLOCBUF)
    {
        /* if a buffer size is not specified, use the default */
        if (pmmio->cchBuffer == 0) {
            pmmio->cchBuffer = MMIO_DEFAULTBUFFER;
        }
        pmmio->dwFlags &= ~MMIO_ALLOCBUF;
    }

    /* Set the pIOProc function as determined by the file name or the
     * parameters in the pmmio structure.
     */
    SetIOProc(szFileName, pmmio);

    /* The pmmio structure hasn't been set up for buffering, so we must
     * explicitly make sure that pchBuffer is NULL.
     */
    hpBuffer = pmmio->pchBuffer;
    pmmio->pchBuffer = NULL;

    /* set up buffered I/O however the user requested it */
    w = mmioSetBuffer(((HMMIO)pmmio), hpBuffer, pmmio->cchBuffer, 0);
    if (w)
    {
        if (lpmmioinfo) {
            lpmmioinfo->wErrorRet = w;
        }
        FreeHandle(((HMMIO)pmmio));
        return NULL;
    }

    if ( (pmmio->dwFlags & MMIO_UNICODEPROC)    // a Unicode IO Proc
      || (pmmio->pIOProc == mmioDOSIOProc )     // or the DOS file IO Proc
      || (pmmio->pIOProc == mmioMEMIOProc ) ) { // or a memory file IO Proc

        /* let the I/O procedure open/delete/qualify the file */
        w = (UINT)IOProc( pmmio, MMIOM_OPEN, (LPARAM)szFileName, 0L );

    } else {

        if (NULL == szFileName) {

            w = (UINT)IOProc( pmmio,
                        MMIOM_OPEN,
                        (LPARAM)NULL,
                        0L );

        } else {
            LPSTR   lpAsciiFileName;  // ascii version of szFileName

            /*------------------------------------------------------------*\
            * We have an ascii IO Proc so convert the given file name
            * into ascii.
            \*------------------------------------------------------------*/
            lpAsciiFileName = AllocAsciiStr( szFileName );
            if ( lpAsciiFileName == (LPSTR)NULL ) {
                if (lpmmioinfo) {
                    lpmmioinfo->wErrorRet = MMIOERR_OUTOFMEMORY;
                }
                FreeHandle( (HMMIO)pmmio );
                return NULL;
            }

            /*------------------------------------------------------------*\
            * Call the IO proc and then free the allocated unicode
            * filename storage.
            \*------------------------------------------------------------*/
            w = (UINT)IOProc( pmmio,
                        MMIOM_OPEN,
                        (LPARAM)lpAsciiFileName,
                        0L );

            FreeAsciiStr( lpAsciiFileName );
        }
    }

    /* If this is non-zero, return it to the user */
    if (w != 0)
    {
        if (lpmmioinfo != NULL) {
            lpmmioinfo->wErrorRet = w;
        }
        FreeHandle(((HMMIO)pmmio));
        return NULL;
    }

    if (pmmio->dwFlags & (MMIO_DELETE| MMIO_PARSE| MMIO_EXIST| MMIO_GETTEMP))
    {
        /* if the file is being deleted/parsed/name gotten, exit
         * QUICKLY because the file handle (or whatever) in <pmmio>
         * is not valid.
         */
        mmioSetBuffer(((HMMIO)pmmio), NULL, 0L, 0);
        FreeHandle(((HMMIO)pmmio));
        return (HMMIO) TRUE;
    }

    /* the initial "current buffered offset" will be equal to the initial
     * "current disk offset"
     */
    pmmio->lBufOffset = pmmio->lDiskOffset;

    return ((HMMIO)pmmio);
}

HMMIO APIENTRY
      mmioOpenA( LPSTR szFileName, LPMMIOINFO lpmmioinfo, DWORD dwOpenFlags )
{
    PMMIO       pmmio;          // MMIO status block
    LPSTR       hpBuffer;
    UINT        w;              // an MMRESULT or a LRESULT from an IOPROC
    LPWSTR      lpUnicodeName;  // Unicode version of szFileName
    WCHAR       UnicodeBuffer[ MAX_PATH ];


    V_FLAGS(dwOpenFlags, MMIO_OPEN_VALID, mmioOpen, NULL);
    V_WPOINTER0(lpmmioinfo, sizeof(MMIOINFO), NULL);

    if (lpmmioinfo) {
        lpmmioinfo->wErrorRet = 0;
        V_CALLBACK0((FARPROC)lpmmioinfo->pIOProc, NULL);
    }

    /*----------------------------------------------------------------*\
     * Don't convert szFilename if it does not point to anything
    \*----------------------------------------------------------------*/
    if ( szFileName != (LPSTR)NULL ) {

        /*----------------------------------------------------------------*\
         * Convert the Ascii szFileName to Unicode
        \*----------------------------------------------------------------*/
        AsciiStrToUnicodeStr( (PBYTE)UnicodeBuffer,
                              (PBYTE)UnicodeBuffer + (MAX_PATH * sizeof(WCHAR)),
                              szFileName );
        lpUnicodeName = UnicodeBuffer;

    } else {
        lpUnicodeName = (LPWSTR)NULL;
    }


    /* allocate MMIO status information block */
    if ( (pmmio = (PMMIO)(NewHandle(TYPE_MMIO, NULL, sizeof(MMIOINFO)))) == NULL)
    {
        if (lpmmioinfo) {
            lpmmioinfo->wErrorRet = MMIOERR_OUTOFMEMORY;
        }
        return NULL;
    }
    
    //  Implicitly acquired by NewHandle()
    ReleaseHandleListResource();

    /*----------------------------------------------------------------*\
     * NewHandle does not zero the allocated storage so we had better do
     * it now.
    \*----------------------------------------------------------------*/
    ZeroMemory( pmmio, sizeof(MMIOINFO) );

    /* if user supplied <lpmmioinfo>, copy it to <pmmio> */
    if (lpmmioinfo != NULL) {
        *pmmio = *lpmmioinfo;
    }

    /* <dwOpenFlags> always takes precedence over contents of <pmmio> */
    pmmio->dwFlags = dwOpenFlags;
    pmmio->hmmio = ((HMMIO)pmmio);

    /* MMIO_ALLOCBUF in the flags means that the user wants a buffer
     * allocated for buffered I/O, but after this point it means that
     * a buffer *was* allocated, so turn off the flag until the buffer
     * is actually allocated (which is done by mmioSetBuffer() below)
     */
    if (pmmio->dwFlags & MMIO_ALLOCBUF)
    {
        /* if a buffer size is not specified, use the default */
        if (pmmio->cchBuffer == 0) {
            pmmio->cchBuffer = MMIO_DEFAULTBUFFER;
        }
        pmmio->dwFlags &= ~MMIO_ALLOCBUF;
    }

    /* Set the pIOProc function as determined by the file name or the
     * parameters in the pmmio structure.
     */
    SetIOProc( lpUnicodeName, pmmio );

    /* The pmmio structure hasn't been set up for buffering, so we must
     * explicitly make sure that pchBuffer is NULL.
     */
    hpBuffer = pmmio->pchBuffer;
    pmmio->pchBuffer = NULL;

    /* set up buffered I/O however the user requested it */
    w = mmioSetBuffer(((HMMIO)pmmio), hpBuffer, pmmio->cchBuffer, 0);
    if (w)
    {
        if (lpmmioinfo) {
            lpmmioinfo->wErrorRet = w;
        }
        FreeHandle(((HMMIO)pmmio));
        return NULL;
    }

    if ( (pmmio->dwFlags & MMIO_UNICODEPROC)        // a Unicode IO Proc
        || (pmmio->pIOProc == mmioDOSIOProc)        // or the DOS file IO Proc
        || (pmmio->pIOProc == mmioMEMIOProc) ) {    // or a memory file IO Proc

        /* let the I/O procedure open/delete/qualify the file */
        w = (UINT)IOProc( pmmio, MMIOM_OPEN,
                    (LPARAM)lpUnicodeName, 0L );

        /*------------------------------------------------------------*\
         * If we have a DOS IO proc and the user specified the
         * parse option and we did not get any errors from the IO proc
         * call we convert the returned parsed path string from Unicode
         * back into Ansi and copy this value into szFileName.
        \*------------------------------------------------------------*/
        if ( w == 0
          && (pmmio->pIOProc == mmioDOSIOProc)
          && ((dwOpenFlags & MMIO_PARSE) || (dwOpenFlags & MMIO_GETTEMP)) ) {

              BYTE   ansiPath[ MAX_PATH ];

              UnicodeStrToAsciiStr( ansiPath,
                                    ansiPath + MAX_PATH,
                                    lpUnicodeName );
              strcpy( (LPSTR)szFileName, (LPCSTR)ansiPath );
        }

    } else {

        w = (UINT)IOProc( pmmio, MMIOM_OPEN, (LPARAM)szFileName, 0L );

    }

    /* If this is non-zero, return it to the user */
    if (w != 0)
    {
        if (lpmmioinfo != NULL) {
            lpmmioinfo->wErrorRet = w;
        }
        FreeHandle(((HMMIO)pmmio));
        return NULL;
    }

    if (pmmio->dwFlags & (MMIO_DELETE| MMIO_PARSE| MMIO_EXIST| MMIO_GETTEMP))
    {
        /* if the file is being deleted/parsed/name gotten, exit
         * QUICKLY because the file handle (or whatever) in <pmmio>
         * is not valid.
         */
        mmioSetBuffer(((HMMIO)pmmio), NULL, 0L, 0);
        FreeHandle(((HMMIO)pmmio));
        return (HMMIO) TRUE;
    }

    /* the initial "current buffered offset" will be equal to the initial
     * "current disk offset"
     */
    pmmio->lBufOffset = pmmio->lDiskOffset;

    return ((HMMIO)pmmio);
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    MMRESULT | mmioClose | This function closes a file opened with
    <f mmioOpen>.

@parm   HMMIO | hmmio | Specifies the file handle of the file to
    close.

@parm   UINT | uFlags | Specifies options for the close operation.

    @flag   MMIO_FHOPEN | If the file was opened by passing the DOS
        file handle of an already-opened file to <f mmioOpen>, then
        using this flag tells <f mmioClose> to close the MMIO file
        handle, but not the DOS file handle.  (This is done by the
        I/O Proc).

@rdesc  The return value is zero if the function is successful.
    Otherwise, the return value is an error code, either from
    <f mmioFlush> or from the I/O procedure. The error code can be
    one of the following codes:

    @flag MMIOERR_CANNOTWRITE | The contents of the buffer could
    not be written to disk.

    @flag MMIOERR_CANNOTCLOSE | There was a DOS file system error when
    the I/O Proc attempted to close the DOS file.

@xref   mmioOpen mmioFlush
*/
/*--------------------------------------------------------------------*/
MMRESULT APIENTRY
        mmioClose(HMMIO hmmio, UINT uFlags)
{
    UINT w;                /* either an LRESULT from an IOProc or an MMRESULT */

    V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);

    if ((w = mmioFlush(hmmio, 0)) != 0)
        return w;

    w = (UINT)IOProc( (PMMIO)hmmio, MMIOM_CLOSE, (LPARAM)(DWORD) uFlags, (LPARAM) 0);
    if (w != 0) return w;

    /* free the buffer if necessary */
    mmioSetBuffer(hmmio, NULL, 0L, 0);

        FreeHandle(hmmio);

    return 0;
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    LRESULT | mmioRead | This function reads a specified number of
    bytes from a file opened with <f mmioOpen>.

@parm   HMMIO | hmmio | Specifies the file handle of the file to be
    read.

@parm   LPSTR | pch | Specifies a pointer to a buffer to contain
    the data read from the file.

@parm   LONG | cch | Specifies the number of bytes to read from the
    file.

@rdesc  The return value is the number of bytes actually read. If the
    end of the file has been reached and no more bytes can be read, the
    return value is zero. If there is an error reading from the file, the
    return value is -1.

@comm  On 16 bit windows pch is a huge pointer.  On 32 bit windows there is no
    distinction between huge pointers and long pointers.

@xref   mmioWrite
*/
/*--------------------------------------------------------------------*/
LONG APIENTRY
mmioRead(HMMIO hmmio, LPSTR pch, LONG cch)
{
    LONG        lTotalBytesRead = 0L;   // total no. bytes read
    LONG        lBytes;         // no. bytes that can be read
    PMMIO       pmmio=(PMMIO)hmmio; //local copy hmmio - avoid casting, simplify debug

    V_HANDLE(hmmio, TYPE_MMIO, -1);
    V_WPOINTER(pch, cch, -1);

    for(;;)
    {
        /* calculate the number of bytes that can be read */
        lBytes = (LONG)(pmmio->pchEndRead - pmmio->pchNext);

        /* can only read at most <cch> bytes from buffer */
        if (lBytes > cch)
            lBytes = cch;

        if (lBytes > 0)
        {
            /* this is where some performance improvements can
             * be made, especially for small reads...?
             */
            CopyMemory(pch, pmmio->pchNext, lBytes);
            pmmio->pchNext += lBytes;
            pch += lBytes;
            cch -= lBytes;
            lTotalBytesRead += lBytes;
        }

        /* cannot do MMIOM_READ from memory files */
        if (pmmio->fccIOProc == FOURCC_MEM)
            return lTotalBytesRead;

        if (cch == 0)           // no more to read?
            return lTotalBytesRead;

        /* we need to read beyond this buffer; if we have at least
         * another bufferful to read, just call the I/O procedure
         */
        if (cch > pmmio->cchBuffer)
            break;

        /* read the next bufferful and loop around */
        if (mmioAdvance(hmmio, NULL, MMIO_READ) != 0)
            return -1;

        /* if mmioAdvance() couldn't read any more data, we must be
         * at the end of the file
         */
        if (pmmio->pchNext == pmmio->pchEndRead)
            return lTotalBytesRead;
    }

    /* flush and empty the I/O buffer and manipulate <lBufOffset>
     * directly to change the current file position
     */
    if (mmioFlush(hmmio, MMIO_EMPTYBUF) != 0)
        return -1;

    /* call the I/O procedure to do the rest of the reading */
    lBytes = mmioDiskIO(pmmio, MMIOM_READ, pch, cch);
    pmmio->lBufOffset = pmmio->lDiskOffset;

    return (lBytes == -1L) ? -1L : lTotalBytesRead + lBytes;
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    LRESULT | mmioWrite | This function writes a specified number of
    bytes to a file opened with <f mmioOpen>.

@parm   HMMIO | hmmio | Specifies the file handle of the file.

@parm   LPSTR | pch | Specifies a pointer to the buffer to be
    written to the file.

@parm   LONG | cch | Specifies the number of bytes to write to the
    file.

@rdesc  The return value is the number of bytes actually written. If
    there is an error writing to the file, the return value is -1.

@comm   The current file position is incremented by the number of
    bytes written.   On 16 bit windows pch is a huge pointer.
    On 32 bit windows there is no distinction between huge pointers
    and long pointers.

@xref   mmioRead
*/
/*--------------------------------------------------------------------*/
LONG APIENTRY
mmioWrite(HMMIO hmmio, LPCSTR pch, LONG cch)
{
    LONG        lTotalBytesWritten = 0L; // total no. bytes written
    LONG        lBytes;         // no. bytes that can be written
    // "pch" is LPCSTR which is correct, but
    // we pass it to a polymorphic routine
    // which needs LPSTR.

    V_HANDLE(hmmio, TYPE_MMIO, -1);
    V_RPOINTER(pch, cch, -1);

    for(;;)
    {
        /* calculate the number of bytes that can be written */
        lBytes = (LONG)(((PMMIO)hmmio)->pchEndWrite - ((PMMIO)hmmio)->pchNext);

        if ((cch > lBytes) && (((PMMIO)hmmio)->fccIOProc == FOURCC_MEM))
        {
            /* this is a memory file -- expand it */
            if (mmioExpandMemFile(((PMMIO)hmmio), cch - lBytes) != 0)
                return -1;  // cannot expand
            lBytes = (LONG)(((PMMIO)hmmio)->pchEndWrite - ((PMMIO)hmmio)->pchNext);
        }

        /* can only write at most <cch> bytes into the buffer */
        if (lBytes > cch)
            lBytes = cch;

        /* this is where some performance improvements can
         * be made, especially for small writes... should
         * special-case cases when segment boundaries are
         * not crossed (or maybe hmemcpy() should do that)
         */
        if (lBytes > 0)
        {
            CopyMemory(((PMMIO)hmmio)->pchNext, pch, lBytes);
            ((PMMIO)hmmio)->dwFlags |= MMIO_DIRTY;
            ((PMMIO)hmmio)->pchNext += lBytes;
            pch += lBytes;
            cch -= lBytes;
            lTotalBytesWritten += lBytes;
        }

        /* validate <pchEndRead>, i.e. re-enforce the invariant that
         * <pchEndRead> points past the last valid byte in the buffer
         */
        if (((PMMIO)hmmio)->pchEndRead < ((PMMIO)hmmio)->pchNext)
            ((PMMIO)hmmio)->pchEndRead = ((PMMIO)hmmio)->pchNext;

        if (cch == 0)           // no more to write?
            return lTotalBytesWritten;

        /* we need to read beyond this buffer; if we have at least
         * another bufferful to read, just call the I/O procedure
         */
        if (cch > ((PMMIO)hmmio)->cchBuffer)
            break;

        /* write this buffer (if needed) and read the next
         * bufferful (if needed)
         */
        if (mmioAdvance(hmmio, NULL, MMIO_WRITE) != 0)
            return -1;
    }

    /* we should never need to do MMIOM_WRITE with memory files */

    /* flush and empty the I/O buffer and manipulate <lBufOffset>
     * directly to change the current file position
     */
    if (mmioFlush(hmmio, MMIO_EMPTYBUF) != 0)
        return -1;

    /* call the I/O procedure to do the rest of the writing
     * mmioDiskIO is a polymorphic routine, hence we need to cast
     * our LPCSTR input pointer to LPSTR.
     */
    lBytes = mmioDiskIO(((PMMIO)hmmio), MMIOM_WRITE, (LPSTR)pch, cch);
    ((PMMIO)hmmio)->lBufOffset = ((PMMIO)hmmio)->lDiskOffset;

    return (lBytes == -1L) ? -1L : lTotalBytesWritten + lBytes;
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    LRESULT | mmioSeek | This function changes the current file
    position in a file opened with <f mmioOpen>. The current file
    position is the location in the file where data is read or written.

@parm   HMMIO | hmmio | Specifies the file handle of the file to seek
    in.

@parm   LONG | lOffset | Specifies an offset to change the file position.

@parm   int | iOrigin | Specifies how the offset specified by
    <p lOffset> is interpreted. Contains one of the following flags:

    @flag   SEEK_SET | Seeks to <p lOffset> bytes from the beginning
        of the file.

    @flag   SEEK_CUR | Seeks to <p lOffset> bytes from the current
        file position.

    @flag   SEEK_END | Seeks to <p lOffset> bytes from the end
        of the file.

@rdesc  The return value is the new file position in bytes, relative
    to the beginning of the file. If there is an error, the return value
    is -1.

@comm   Seeking to an invalid location in the file, such as past the
    end of the file, may cause <f mmioSeek> to not return an error,
    but may cause subsequent I/O operations on the file to fail.

    To locate the end of a file, call <f mmioSeek> with <p lOffset>
    set to zero and <p iOrigin> set to SEEK_END.
*/
/*--------------------------------------------------------------------*/
LONG APIENTRY
mmioSeek(HMMIO hmmio, LONG lOffset, int iOrigin)
{
    LONG        lCurOffset; // disk offset of <pchNext>
    LONG        lEndBufOffset;  // disk offset of end of buffer
    LONG        lNewOffset; // new disk offset

    V_HANDLE(hmmio, TYPE_MMIO, -1);

    /* careful! all this buffer pointer manipulation is fine, but keep
     * in mind that buffering may be disabled (in which case <pchEndRead>
     * and <pchBuffer> will both be NULL, so the buffer will appear to
     * be zero bytes in size)
     */

    /* <((PMMIO)hmmio)->lBufOffset> is the disk offset of the start of the
     * start of the buffer; determine <lCurOffset>, the offset of <pchNext>,
     * and <lEndBufOffset>, the offset of the end of the valid part
     * of the buffer
     */
    lCurOffset = (LONG)(((PMMIO)hmmio)->lBufOffset +
        (((PMMIO)hmmio)->pchNext - ((PMMIO)hmmio)->pchBuffer));
    lEndBufOffset = (LONG)(((PMMIO)hmmio)->lBufOffset +
        (((PMMIO)hmmio)->pchEndRead - ((PMMIO)hmmio)->pchBuffer));

    /* determine <lNewOffset>, the offset to seek to */
    switch (iOrigin)
    {
    case SEEK_SET:      // seek relative to start of file

        lNewOffset = lOffset;
        break;

    case SEEK_CUR:      // seek relative to current location

        lNewOffset = lCurOffset + lOffset;
        break;

    case SEEK_END:      // seek relative to end of file

        if (((PMMIO)hmmio)->fccIOProc == FOURCC_MEM)
            lNewOffset = lEndBufOffset - lOffset;
        else
        {
            LONG    lEndFileOffset;

            /* find out where the end of the file is */
            lEndFileOffset
                 = (LONG)IOProc( (PMMIO)hmmio, MMIOM_SEEK, (LPARAM) 0, (LPARAM) SEEK_END);
            if (lEndFileOffset == -1)
                return -1;
            /* Check that we don't have buffered data not yet written */

            if (lEndBufOffset > lEndFileOffset) {
                lEndFileOffset = lEndBufOffset;
            }

            lNewOffset = lEndFileOffset - lOffset;
        }
        break;
    default: lNewOffset = 0;
        {
          dprintf(( "Invalid seek type %d\n",iOrigin));
          WinAssert(FALSE);
        }
    }

    if ( (lNewOffset >= ((PMMIO)hmmio)->lBufOffset)
       && (lNewOffset <= lEndBufOffset)
       )
    {
        /* seeking within the valid part of the buffer
         * (possibly including seeking to <lEndBufOffset>)
         */
        ((PMMIO)hmmio)->pchNext = ((PMMIO)hmmio)->pchBuffer +
            (lNewOffset - ((PMMIO)hmmio)->lBufOffset);
    }
    else
    {
        /* seeking outside the buffer */
        if (((PMMIO)hmmio)->fccIOProc == FOURCC_MEM)
            return -1;  // can't seek outside mem. file buffer
        if (mmioFlush(hmmio, 0) != 0)
            return -1;

        /* the current "buffered file position" (same as <lDiskOffset>
         * for unbuffered files) equals <lBufOffset> +
         * (<pchNext> - <pchBuffer>); we'll move the current buffered
         * file position (and empty the buffer, since it becomes
         * invalid when <lBufOffset> changes) as follows...
         */
        ((PMMIO)hmmio)->lBufOffset = lNewOffset;
        ((PMMIO)hmmio)->pchNext
            = ((PMMIO)hmmio)->pchEndRead
            = ((PMMIO)hmmio)->pchBuffer;

        /* don't need to actually seek right now, since the next
         * MMIOM_READ or MMIOM_WRITE will have to seek anyway
         */
    }

    return lNewOffset;
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    MMRESULT | mmioGetInfo | This function retrieves information
    about a file opened with <f mmioOpen>. This information allows the
    caller to directly access the I/O buffer, if the file is opened
    for buffered I/O.

@parm   HMMIO | hmmio | Specifies the file handle of the file.

@parm   LPMMIOINFO | lpmmioinfo | Specifies a pointer to a
    caller-allocated <t MMIOINFO> structure that <f mmioGetInfo>
    fills with information about the file. See the <t MMIOINFO> structure
    and the <f mmioOpen> function for information about the fields in
    this structure.

@parm   UINT | uFlags | Is not used and should be set to zero.

@rdesc  The return value is zero if the function is successful.

@comm   To directly access the I/O buffer of a file opened for
    buffered I/O, use the following fields of the <t MMIOINFO> structure
    filled by <f mmioGetInfo>:

    -- The <e MMIOINFO.pchNext> field points to the next byte in the
    buffer that can be read or written. When you read or write, increment
    <e MMIOINFO.pchNext> by the number of bytes read or written.

    -- The <e MMIOINFO.pchEndRead> field points to one byte past the
    last valid byte in the buffer that can be read.

    -- The <e MMIOINFO.pchEndWrite> field points to one byte past the
    last location in the buffer that can be written.

    Once you read or write to the buffer and modify
    <e MMIOINFO.pchNext>, do not call any MMIO function except
    <f mmioAdvance> until you call <f mmioSetInfo>. Call <f mmioSetInfo>
    when you are finished directly accessing the buffer.

    When you reach the end of the buffer specified by
    <e MMIOINFO.pchEndRead> or <e MMIOINFO.pchEndWrite>, call
    <f mmioAdvance> to fill the buffer from the disk, or write
    the buffer to the disk. The <f mmioAdvance> function
    will update the <e MMIOINFO.pchNext>, <e MMIOINFO.pchEndRead>, and
    <e MMIOINFO.pchEndWrite> fields in the <t MMIOINFO> structure for the
    file.

    Before calling <f mmioAdvance> or <f mmioSetInfo> to flush a
    buffer to disk, set the MMIO_DIRTY flag in the <e MMIOINFO.dwFlags>
    field of the <t MMIOINFO> structure for the file. Otherwise, the
    buffer will not get written to disk.

    Do not decrement <e MMIOINFO.pchNext> or modify any fields in the
    <t MMIOINFO> structure other than <e MMIOINFO.pchNext> and
    <e MMIOINFO.dwFlags>. Do not set any flags in <e MMIOINFO.dwFlags>
    except MMIO_DIRTY.

@xref   mmioSetInfo MMIOINFO
*/
/*--------------------------------------------------------------------*/
MMRESULT APIENTRY
mmioGetInfo(HMMIO hmmio, LPMMIOINFO lpmmioinfo, UINT uFlags)
{
    V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);
    V_WPOINTER(lpmmioinfo, sizeof(MMIOINFO), MMSYSERR_INVALPARAM);

    *lpmmioinfo = *((PMMIO)hmmio);

    return 0;
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    MMRESULT | mmioSetInfo | This function updates the information
    retrieved by <f mmioGetInfo> about a file opened with <f mmioOpen>.
    Use this function to terminate direct buffer access of a file opened
    for buffered I/O.

@parm   HMMIO | hmmio | Specifies the file handle of the file.

@parm   LPMMIOINFO | lpmmioinfo | Specifies a pointer to an
    <t MMIOINFO> structure filled with information with
    <f mmioGetInfo>.

@parm   UINT | uFlags | Is not used and should be set to zero.

@rdesc  The return value is zero if the function is successful.

@comm   If you have written to the file I/O buffer, set the
    MMIO_DIRTY flag in the <e MMIOINFO.dwFlags> field of the <t MMIOINFO>
    structure before calling <f mmioSetInfo> to terminate direct buffer
    access. Otherwise, the buffer will not get flushed to disk.

@xref   mmioGetInfo MMIOINFO
*/
/*--------------------------------------------------------------------*/
MMRESULT APIENTRY
mmioSetInfo(HMMIO hmmio, LPCMMIOINFO lpmmioinfo, UINT fuInfo)
{
    V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);
    V_RPOINTER(lpmmioinfo, sizeof(MMIOINFO), MMSYSERR_INVALPARAM);
    V_RPOINTER0( lpmmioinfo->pchBuffer
               , lpmmioinfo->cchBuffer
               , MMSYSERR_INVALPARAM
               );
    V_CALLBACK((FARPROC)lpmmioinfo->pIOProc, MMSYSERR_INVALPARAM);

    /* copy the relevant information from <lpmmioinfo> back into <hmmio> */
    *((PMMIO)hmmio) = *lpmmioinfo;

    /* validate <pchEndRead>, i.e. re-enforce the invariant that
     * <pchEndRead> points past the last valid byte in the buffer
     */
    if (((PMMIO)hmmio)->pchEndRead < ((PMMIO)hmmio)->pchNext)
        ((PMMIO)hmmio)->pchEndRead = ((PMMIO)hmmio)->pchNext;

    return 0;
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    MMRESULT | mmioSetBuffer | This function enables or disables
    buffered I/O, or changes the buffer or buffer size for a file opened
    with <f mmioOpen>.

@parm   HMMIO | hmmio | Specifies the file handle of the file.

@parm   LPSTR | pchBuffer | Specifies a pointer to a
    caller-supplied buffer to use for buffered I/O. If NULL,
    <f mmioSetBuffer> allocates an internal buffer for buffered I/O.

@parm   LONG | cchBuffer | Specifies the size of the caller-supplied
    buffer, or the size of the buffer for <f mmioSetBuffer> to allocate.

@parm   UINT | fuInfo | Is not used and should be set to zero.

@rdesc  The return value is zero if the function is successful.
    Otherwise, the return value specifies an error code. If an error
    occurs, the file handle remains valid. The error code can be one
    of the following codes:

    @flag MMIOERR_CANNOTWRITE | The contents of the old buffer could
    not be written to disk, so the operation was aborted.

    @flag MMIOERR_OUTOFMEMORY | The new buffer could not be allocated,
    probably due to a lack of available memory.

@comm   To enable buffering using an internal buffer, set
    <p pchBuffer> to NULL and <p cchBuffer> to the desired buffer size.

    To supply your own buffer, set <p pchBuffer> to point to the buffer,
    and set <p cchBuffer> to the size of the buffer.

    To disable buffered I/O, set <p pchBuffer> to NULL and
    <p cchBuffer> to zero.

    If buffered I/O is already enabled using an internal buffer, you
    can reallocate the buffer to a different size by setting
    <p pchBuffer> to NULL and <p cchBuffer> to the new buffer size. The
    contents of the buffer may be changed after resizing.
 */
/*--------------------------------------------------------------------*/
MMRESULT APIENTRY
         mmioSetBuffer( HMMIO hmmio
                      , LPSTR pchBuffer
                      , LONG cchBuffer
                      , UINT uFlags
                      )
{
    MMRESULT mmr;
    HANDLE hMem;

    V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);
    // Validate the buffer - for READ/WRITE as appropriate
    if (((PMMIO)hmmio)->dwFlags & MMIO_WRITE) {
	V_WPOINTER0(pchBuffer, cchBuffer, MMSYSERR_INVALPARAM);
    } else {
	V_RPOINTER0(pchBuffer, cchBuffer, MMSYSERR_INVALPARAM);
    }

    if ((((PMMIO)hmmio)->dwFlags & MMIO_ALLOCBUF) &&
        (pchBuffer == NULL) && (cchBuffer > 0))
    {
        /* grow or shrink buffer in-place */
        LPSTR       pch;
        LONG        lDeltaNext;
        LONG        lDeltaEndRead;

        /* Since the ALLOCBUF flag is set, we must have a buffer */

        /* write the buffer to disk, but don't empty it */
        if ((mmr = mmioFlush(hmmio, 0)) != 0)
            return mmr;

        for(;;)
        {
            /* remember where <pchNext> and <pchEndRead> are
             * in the buffer
             */
            lDeltaNext = (LONG)(((PMMIO)hmmio)->pchNext - ((PMMIO)hmmio)->pchBuffer);
            lDeltaEndRead
                    = (LONG)(((PMMIO)hmmio)->pchEndRead - ((PMMIO)hmmio)->pchBuffer);

            if (cchBuffer >= lDeltaNext)
                break;

            /* caller wants to truncate the part of the buffer
             * that contains <pchNext> -- handle this by
             * emptying the buffer, recalculating <lDeltaNext>
             * and <lDeltaEndRead>, and continuing below
             */
            if ((mmr = mmioFlush(hmmio, MMIO_EMPTYBUF)) != 0)
                return mmr;
        }

        /* reallocate buffer */
	{
	HANDLE hTemp;

        hTemp =  GlobalHandle( ((PMMIO)hmmio)->pchBuffer );

        GlobalUnlock( hTemp );
        hMem = GlobalReAlloc( hTemp
                            , cchBuffer
                            , GMEM_MOVEABLE
                            );
        pch = GlobalLock(hMem);
	dprintf2(("mmioSetBuffer reallocated ptr %8x, handle %8x, to ptr %8x (handle %8x)\n",
		((PMMIO)hmmio)->pchBuffer, hTemp, pch, hMem));

	}

        /* If we cannot allocate the new buffer, exit with no
         *   harm done.
         */
        if (pch == NULL)
            return MMIOERR_OUTOFMEMORY; // out of memory

        /* transfer pointers to new buffer */
        ((PMMIO)hmmio)->cchBuffer = cchBuffer;
        ((PMMIO)hmmio)->pchBuffer = pch;
        ((PMMIO)hmmio)->pchNext = pch + lDeltaNext;
        ((PMMIO)hmmio)->pchEndRead = pch + lDeltaEndRead;

        /* <pchEndWrite> always points to the end of the buf. */
        ((PMMIO)hmmio)->pchEndWrite = ((PMMIO)hmmio)->pchBuffer + cchBuffer;

        /* check if the reallocation truncated valid data */
        if (lDeltaEndRead > cchBuffer)
            ((PMMIO)hmmio)->pchEndRead = ((PMMIO)hmmio)->pchEndWrite;

        return 0;
    }

    /* write the buffer to disk and stop using the buffer */
    if ((mmr = mmioFlush(hmmio, MMIO_EMPTYBUF)) != 0)
        return mmr;

    if (((PMMIO)hmmio)->dwFlags & MMIO_ALLOCBUF)
    {
        hMem = GlobalHandle( ((PMMIO)hmmio)->pchBuffer);
        GlobalUnlock( hMem );
        GlobalFree( hMem );
        ((PMMIO)hmmio)->dwFlags &= ~MMIO_ALLOCBUF;
    }

    /* Initially, no error. */
    mmr = 0;

    if ((pchBuffer == NULL) && (cchBuffer > 0))
    {
        hMem = GlobalAlloc(GMEM_MOVEABLE, cchBuffer);
        if (hMem)
            pchBuffer = GlobalLock(hMem);
        //else pchBuffer = NULL;

        /* If there is an error, change the file to be un-buffered
         * and return an error code.  The file is still valid.
         * (Just for a little extra security.)
         */
        if (pchBuffer == NULL)
        {   mmr = MMIOERR_OUTOFMEMORY;
            cchBuffer = 0L;
        }
        else
          ((PMMIO)hmmio)->dwFlags |= MMIO_ALLOCBUF;
    }

    /* invariant: <pchEndRead> points past the end of the "valid" portion
     * of the buffer, and <pchEndWrite> points past the last byte that
     * can be written into; <pchNext> points to the next byte to read
     * or write; <lBufOffset> is the current disk offset of the start
     * of the buffer, and it will not change
     */
    ((PMMIO)hmmio)->pchBuffer = pchBuffer;
    ((PMMIO)hmmio)->cchBuffer = cchBuffer;
    ((PMMIO)hmmio)->pchNext
                     = ((PMMIO)hmmio)->pchEndRead = ((PMMIO)hmmio)->pchBuffer;
    ((PMMIO)hmmio)->pchEndWrite = ((PMMIO)hmmio)->pchBuffer + cchBuffer;

    return mmr;
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    MMRESULT | mmioFlush | This function writes the I/O buffer of a
    file to disk, if the I/O buffer has been written to.

@parm   HMMIO | hmmio | Specifies the file handle of a file opened
    with <f mmioOpen>.

@parm   UINT | uFlags | Is not used and should be set to zero.

@rdesc  The return value is zero if the function is successful.
    Otherwise, the return value specifies an error code. The error
    code can be one of the following codes:

    @flag MMIOERR_CANNOTWRITE | The contents of the buffer could
    not be written to disk.

@comm   Closing a file with <f mmioClose> will automatically flush
    its buffer.

    If there is insufficient disk space to write the
    buffer, <f mmioFlush> will fail, even if the preceding <f mmioWrite>
    calls were successful.
*/
/*--------------------------------------------------------------------*/
MMRESULT APIENTRY
    mmioFlush(HMMIO hmmio, UINT uFlags)
{
    LONG        lBytesAsk;      // no. bytes to write
    LONG        lBytesWritten;      // no. bytes actually written

    V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);

    if (  ( ((PMMIO)hmmio)->fccIOProc
          == FOURCC_MEM
          )
       || ( ((PMMIO)hmmio)->pchBuffer == NULL )
       )
        return 0;       // cannot flush memory files

    /* if the file is unbuffered then the dirty flag should not be set */
    if (((PMMIO)hmmio)->dwFlags & MMIO_DIRTY)
    {
        /* figure out how many bytes need to be flushed */
        lBytesAsk = (LONG)(((PMMIO)hmmio)->pchEndRead - ((PMMIO)hmmio)->pchBuffer);

        /* write the buffer to disk */
        lBytesWritten = mmioDiskIO(((PMMIO)hmmio), MMIOM_WRITEFLUSH,
            ((PMMIO)hmmio)->pchBuffer, lBytesAsk);
        if (lBytesWritten != lBytesAsk)
            return MMIOERR_CANNOTWRITE;
        ((PMMIO)hmmio)->dwFlags &= ~MMIO_DIRTY; // buffer is clean now
    }

    if (uFlags & MMIO_EMPTYBUF)
    {
        /* empty the I/O buffer, and update <lBufOffset> to reflect
         * what the current file position is
         */
        ((PMMIO)hmmio)->lBufOffset
                    += (LONG)((((PMMIO)hmmio)->pchNext - ((PMMIO)hmmio)->pchBuffer));
        ((PMMIO)hmmio)->pchNext
                    = ((PMMIO)hmmio)->pchEndRead = ((PMMIO)hmmio)->pchBuffer;
    }

    return 0;
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    MMRESULT | mmioAdvance | This function advances the I/O buffer of
    a file set up for direct I/O buffer access with <f mmioGetInfo>. If
    the file is opened for reading, the I/O buffer is filled from the
    disk.  If the file is opened for writing and the MMIO_DIRTY flag is
    set in the <e MMIOINFO.dwFlags> field of the <t MMIOINFO> structure,
    the buffer is written to disk.  The <e MMIOINFO.pchNext>,
    <e MMIOINFO.pchEndRead>, and <e MMIOINFO.pchEndWrite> fields of the
    <t MMIOINFO> structure are updated to reflect the new state of
    the I/O buffer.

@parm   HMMIO | hmmio | Specifies the file handle for a file opened
    with <f mmioOpen>.

@parm   LPMMIOINFO | lpmmioinfo | Optionally specifies a pointer to the
    <t MMIOINFO> structure obtained with <f mmioGetInfo>, which is used to
    set the current file information, then updated after the buffer is
    advanced.

@parm   UINT | uFlags | Specifies options for the operation.
    Contains exactly one of the following two flags:

    @flag   MMIO_READ | The buffer is filled from the file.

    @flag   MMIO_WRITE | The buffer is written to the file.

@rdesc  The return value is zero if the operation is successful.
    Otherwise, the return value specifies an error code. The error
    code can be one of the following codes:

    @flag MMIOERR_CANNOTWRITE | The contents of the buffer could
    not be written to disk.

    @flag MMIOERR_CANNOTREAD | An error occurred while re-filling
    the buffer.

    @flag MMIOERR_UNBUFFERED | The specified file is not opened
    for buffered I/O.

    @flag MMIOERR_CANNOTEXPAND | The specified memory file cannot
    be expanded, probably because the <e MMIOINFO.adwInfo[0]> field
    was set to zero in the initial call to <f mmioOpen>.

    @flag MMIOERR_OUTOFMEMORY | There was not enough memory to expand
    a memory file for further writing.


@comm   If the specified file is opened for writing or for both
    reading and writing, the I/O buffer will be flushed to disk before
    the next buffer is read. If the I/O buffer cannot be written to disk
    because the disk is full, then <f mmioAdvance> will return
    MMIOERR_CANNOTWRITE.

    If the specified file is only open for writing, the MMIO_WRITE
    flag must be specified.

    If you have written to the I/O buffer, you must set the MMIO_DIRTY
    flag in the <e MMIOINFO.dwFlags> field of the <t MMIOINFO> structure
    before calling <f mmioAdvance>. Otherwise, the buffer will not be
    written to disk.

    If the end of file is reached, <f mmioAdvance> will still return
    success, even though no more data can be read.  Thus, to check for
    the end of the file, it is necessary to see if the
    <e MMIOINFO.pchNext> and <e MMIOINFO.pchEndRead> fields of the
    <t MMIOINFO> structure are equal after calling <f mmioAdvance>.

@xref   mmioGetInfo MMIOINFO
*/
/*--------------------------------------------------------------------*/
MMRESULT APIENTRY
         mmioAdvance(HMMIO hmmio, LPMMIOINFO lpmmioinfo, UINT uFlags)
{
    LONG        lBytesRead;     // bytes actually read
    UINT        w;

    V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);
    if (((PMMIO)hmmio)->pchBuffer == NULL)
        return MMIOERR_UNBUFFERED;
    if (lpmmioinfo != NULL) {
        V_WPOINTER(lpmmioinfo, sizeof(MMIOINFO), MMSYSERR_INVALPARAM);
        mmioSetInfo(hmmio, lpmmioinfo, 0);
    }

    if (((PMMIO)hmmio)->fccIOProc == FOURCC_MEM)
    {
        /* this is a memory file:
         *   -- if the caller is reading, cannot advance
         *   -- if the caller is writing, then advance by expanding
         *      the buffer (if possible) if the there is less than
         *  <adwInfo[0]> bytes left in the buffer
         */
        if (!(uFlags & MMIO_WRITE))
            return MMIOERR_CANNOTREAD;
        if ( (DWORD)(((PMMIO)hmmio)->pchEndWrite - ((PMMIO)hmmio)->pchNext)
           >= ((PMMIO)hmmio)->adwInfo[0]
           )
            return MMIOERR_CANNOTEXPAND;
        if ((w = mmioExpandMemFile(((PMMIO)hmmio), 1L)) != 0)
            return w;   // out of memory, or whatever
        goto GETINFO_AND_EXIT;
    }

    /* empty the I/O buffer, which will effectively advance the
     * buffer by (<pchNext> - <pchBuffer>) bytes
     */
    if ((w = mmioFlush(hmmio, MMIO_EMPTYBUF)) != 0)
        return w;

    /* if MMIO_WRITE bit is not set in uFlags, fill the buffer  */
    if (!(uFlags & MMIO_WRITE))
    {
        /* read the next bufferful from the file */
        lBytesRead = mmioDiskIO(((PMMIO)hmmio), MMIOM_READ,
            ((PMMIO)hmmio)->pchBuffer, ((PMMIO)hmmio)->cchBuffer);
        if (lBytesRead == -1)
            return MMIOERR_CANNOTREAD;

        /* reading zero bytes should not be treated as an error
         * condition -- e.g. open a new file R+W and call
         * mmioAdvance(), and MMIOM_READ will return zero bytes
         * because the file started off empty
         */
        ((PMMIO)hmmio)->pchEndRead += lBytesRead;
    }

GETINFO_AND_EXIT:

    /* copy <hmmio> back to <lpmmioinfo> if <lpmmioinfo> is provided */
    if (lpmmioinfo != NULL)
        mmioGetInfo(hmmio, lpmmioinfo, 0);

    return 0;
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    FOURCC | mmioStringToFOURCC | This function converts a
    null-terminated string to a four-character code.

@parm   LPCTSTR | sz | Specifies a pointer to a null-terminated
    string to a four-character code.

@parm   UINT | uFlags | Specifies options for the conversion:

    @flag   MMIO_TOUPPER | Converts all characters to uppercase.

@rdesc  The return value is the four character code created from the
    given string.

@comm   This function does not check to see if the string referenced
    by <p sz> follows any conventions regarding which characters to
    include in a four-character code.  The string is
    simply copied to a four-character code and padded with blanks or
    truncated to four characters if required.

@xref   mmioFOURCC
*/
/*--------------------------------------------------------------------*/
FOURCC APIENTRY
       mmioStringToFOURCCW( LPCWSTR sz, UINT uFlags )
{

    FOURCC  fcc;
    PBYTE   pByte;  // ascii version of szFileName
    ULONG   cbDst;  // character count of szFileName

//    V_STRING(sz, -1, 0);

    /*------------------------------------------------------------*\
     * Convert the given unicode string into ascii and then call
     * the ascii version of mmioStringToFOURCCW
    \*------------------------------------------------------------*/
    cbDst = (wcslen( sz ) * sizeof(WCHAR)) + sizeof(WCHAR);
    pByte = HeapAlloc( hHeap, 0, cbDst );
    if ( pByte == (PBYTE)NULL ) {
        return (FOURCC)(DWORD_PTR)NULL;
    }
    UnicodeStrToAsciiStr( pByte, pByte + cbDst, sz );

    fcc = mmioStringToFOURCCA( (LPSTR)pByte, uFlags );

    HeapFree( hHeap, 0, pByte );
    return (FOURCC)fcc;
}

FOURCC APIENTRY
       mmioStringToFOURCCA( LPCSTR sz, UINT uFlags )
{
    FOURCC      fcc;
    LPSTR       pch = (LPSTR) &fcc;
    int         i;

    V_STRING(sz, (DWORD)-1, 0);

    for (i = sizeof(FOURCC) - 1; i >= 0; i--)
    {
        if (!*sz)
            *pch = ' ';   /* and don't increment sz beyond the terminating NULL! */
        else {
            *pch = *sz;
            if (uFlags & MMIO_TOUPPER)

//#ifdef DBCS // we don't allow DBCS string. This is enough for us.
                *pch = (char)(WORD)PtrToUlong(AnsiUpper((LPSTR)(DWORD_PTR)((ULONG)*pch & 0xff)));
//#else
//                *pch = (char)(WORD)(LONG)AnsiUpper((LPSTR)(LONG)*pch);
//#endif

            sz++;
        }
        pch++;
    }

    return fcc;
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    LPMMIOPROC | mmioInstallIOProc | This function installs or
    removes a custom I/O procedure. It will also locate an installed I/O
    procedure, given its corresponding four-character code.

@parm   FOURCC | fccIOProc | Specifies a four-character code
    identifying the I/O procedure to install, remove, or locate. All
    characters in this four-character code should be uppercase characters.

@parm   LPMMIOPROC | pIOProc | Specifies the address of the I/O
    procedure to install. To remove or locate an I/O procedure, set this
    parameter to NULL.

@parm   DWORD | dwFlags | Specifies one of the following flags
    indicating whether the I/O procedure is being installed, removed, or
    located:

    @flag   MMIO_INSTALLPROC | Installs the specified I/O procedure.

    @flag   MMIO_GLOBALPROC | This flag is a modifier to the install flag,
        and indicates the I/O procedure should be installed for global
        use.  This flag is ignored on removal or find.

    @flag   MMIO_REMOVEPROC | Removes the specified I/O procedure.

    @flag   MMIO_FINDPROC | Searches for the specified I/O procedure.

@rdesc  The return value is the address of the I/O procedure
    installed, removed, or located. If there is an error, the return value
    is NULL.

@comm   If the I/O procedure resides in the application, use
    <f MakeProcInstance> for compatibility with 16 bit windows
    to get a procedure-instance address and specify
    this address for <p pIOProc>. You don't need to get a procedure-instance
    address if the I/O procedure resides in a DLL.

@cb LONG FAR PASCAL | IOProc | <f IOProc> is a placeholder for the
    application-supplied function name. The actual name must be exported
    by including it in a EXPORTS statement in the application's
    module-definitions file.

    @parm   LPSTR | lpmmioinfo | Specifies a pointer to an
        <t MMIOINFO> structure containing information about the open
        file.  The I/O procedure must maintain the <e MMIOINFO.lDiskOffset>
        field in this structure to indicate the file offset to the
        next read or write location. The I/O procedure can use the
        <e MMIOINFO.adwInfo[]> field to store state information. The
        I/O procedure should not modify any other fields of the
        <t MMIOINFO> structure.


    @parm   UINT | wMsg | Specifies a message indicating the
        requested I/O operation. Messages that can be received include
        <m MMIOM_OPEN>, <m MMIOM_CLOSE>, <m MMIOM_READ>, <m MMIOM_WRITE>,
        and <m MMIOM_SEEK>.

    @parm   LONG | lParam1 | Specifies a parameter for the message.

    @parm   LONG | lParam2 | Specifies a parameter for the message.

@rdesc  The return value depends on the message specified by
    <p wMsg>. If the I/O procedure does not recognize a message, it should
    return zero.

@comm   The four-character code specified by the
    <e MMIOINFO.fccIOProc> field in the <t MMIOINFO> structure
    associated with a file identifies a filename extension for a custom
    storage system. When an application calls <f mmioOpen> with a
    filename such as "foo.xyz!bar", the I/O procedure associated with the
    four-character code "XYZ " is called to open the "bar" element of the
    file "foo.xyz".

    The <f mmioInstallIOProc> function maintains a separate list of
    installed I/O procedures for each Windows application. Therefore,
    different applications can use the same I/O procedure identifier for
    different I/O procedures without conflict.  Installing an I/O procedure
    globally however enables any process to use the procedure.

    If an application calls <f mmioInstallIOProc> more than once to
    register the same I/O procedure, then it must call
    <f mmioInstallIOProc> to remove the procedure once for each time it
    installed the procedure.

    <f mmioInstallIOProc> will not prevent an application from
    installing two different I/O procedures with the same identifier, or
    installing an I/O procedure with one of the predefined identifiers
    ("DOS ", "MEM "). The most recently installed procedure
    takes precedence, and the most recently installed procedure is the
    first one to get removed.

    When searching for a specified I/O procedure, local procedures are
    searched first, then global procedures.

@xref   mmioOpen
 */

/*--------------------------------------------------------------------*/
LPMMIOPROC APIENTRY
mmioInstallIOProcW(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags)
{
    V_FLAGS(dwFlags, MMIO_VALIDPROC, mmioInstallIOProc, NULL);

    dwFlags |= MMIO_UNICODEPROC;
    return mmioInternalInstallIOProc( fccIOProc, pIOProc, dwFlags);
}

LPMMIOPROC APIENTRY
mmioInstallIOProcA(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags)
{

    V_FLAGS(dwFlags, MMIO_VALIDPROC, mmioInstallIOProc, NULL);

    dwFlags &= ~MMIO_UNICODEPROC;
    return mmioInternalInstallIOProc( fccIOProc, pIOProc, dwFlags);
}


static LPMMIOPROC mmioInternalInstallIOProc(
                     FOURCC      fccIOProc,   // I/O Proc 4 char id
                     LPMMIOPROC  pIOProc,     // pointer to any I/O proc to install
                     DWORD       dwFlags      // flags from caller
                     )
{
    IOProcMapEntry  *pEnt;          // an entry in linked list
    HANDLE          hTaskCurrent;   // current Windows task handle

#ifdef DUMPIOPROCLIST
// dprintf(("initial I/O proc list\n"));
// DumpIOProcList();
#endif

    if (fccIOProc == 0L)
        return NULL;

    hTaskCurrent = GetCurrentTask();

    if (dwFlags & MMIO_INSTALLPROC)
    {
        /* install I/O procedure -- always add at the beginning of
         * the list, so it overrides any other I/O procedures
         * with the same identifier installed by the same task
         */
        V_CALLBACK((FARPROC)pIOProc, NULL);
        if ((pEnt = (IOProcMapEntry NEAR *)
            NewHandle(TYPE_MMIO, NULL, sizeof(IOProcMapEntry))) == NULL)
                return NULL;        // out of memory
        //  Implicitly acquired by NewHandle()
        ReleaseHandleListResource();
        pEnt->fccIOProc = fccIOProc;
        pEnt->pIOProc = pIOProc;
        pEnt->hTask = hTaskCurrent;
        pEnt->pNext = gIOProcMapHead;
        gIOProcMapHead = pEnt;

#ifdef DUMPIOPROCLIST
// dprintf(("I/O proc list after addition"));
// DumpIOProcList();
#endif

        return pIOProc;
    }

    if (!pIOProc)
        if (dwFlags & MMIO_REMOVEPROC)
            return RemoveIOProc(fccIOProc, hTaskCurrent);
        else if (dwFlags & MMIO_FINDPROC)
        {   
            pEnt = FindIOProc(fccIOProc, hTaskCurrent);
            return ( pEnt==NULL
                   ? NULL
                   : pEnt->pIOProc
                   );
        }
    return NULL;        // couldn't find requested I/O procedure
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    LRESULT | mmioSendMessage | This function sends a message to the
    I/O procedure associated with the specified file.

@parm   HMMIO | hmmio | Specifies the file handle for a file opened
    with <f mmioOpen>.

@parm   UINT | wMsg | Specifies the message to send to the I/O procedure.

@parm   LONG | lParam1 | Specifies a parameter for the message.

@parm   LONG | lParam2 | Specifies a parameter for the message.

@rdesc  The return value depends on the message. If the I/O procedure
    does not recognize the message, the return value is zero.

@comm   Use this function to send custom user-defined messages. Do
    not use it to send the <m MMIOM_OPEN>, <m MMIOM_CLOSE>,
    <m MMIOM_READ>, <m MMIOM_WRITE>, <m MMIOM_WRITEFLUSH>, or
    <m MMIOM_SEEK> messages. Define
    custom messages to be greater than or equal to the MMIOM_USER constant.

@xref   mmioInstallIOProc
*/
/*--------------------------------------------------------------------*/
LRESULT APIENTRY
mmioSendMessage(HMMIO hmmio, UINT uMsg, LPARAM lParam1, LPARAM lParam2)
{
    V_HANDLE(hmmio, TYPE_MMIO, (LRESULT)0);
    return IOProc( (PMMIO)hmmio, uMsg, lParam1, lParam2);
}


/*--------------------------------------------------------------------*/
/* @doc INTERNAL

@api    LONG | mmioDiskIO | Perform an unbuffered read or write.
    Do not assume where the current disk offset <p lDiskOffset> will be.

@parm   PMMIO | pmmio | The open file handle returned by <f mmioOpen>.

@parm   UINT | wMsg | MMIOM_READ if <f mmioDiskIO> should read from the disk,
    or MMIOM_WRITE if <f mmioDiskIO> should write to the disk,
    or MMIOM_WRITEFLUSH if <f mmioDiskIO> should flush all pending I/O.

@parm   LPSTR | pch | The buffer to read into or write from.

@parm   LONG | cch | The number of bytes to read or write.

    <f mmioDiskIO> changes the disk offset to be <p lBufOffset>
    and then performs an MMIOM_READ or MMIOM_WRITE operation as
    specified by <p wMsg>, <p pch>, and <p cch>.

    Note that if the I/O buffer is not empty at this point, this
    function may not do what you expect.

    Do not call this function for memory files.
*/
/*--------------------------------------------------------------------*/
static LONG NEAR PASCAL
mmioDiskIO(PMMIO pmmio, UINT uMsg, LPSTR pch, LONG cch)
{
    if (pmmio->lDiskOffset != pmmio->lBufOffset)
    {
        if (IOProc( pmmio
                  , MMIOM_SEEK
                  , (LONG) pmmio->lBufOffset
                  , (LONG) SEEK_SET
                  )
           == -1
           )
            return -1;
    }

    return (LONG)IOProc( pmmio, uMsg, (LPARAM) pch, (LPARAM) cch);
}


/*--------------------------------------------------------------------*/
/* @doc INTERNAL

@api    UINT | mmioExpandMemFile | Assuming that <p pmmio> is a memory file,
    expand it by <p lExpand> bytes or <p adwInfo[0]> bytes, whichever
    is larger.  Do not disturb the contents of the buffer or change
    the current file position.

@parm   PMMIO | pmmio | The open file handle returned by <f mmioOpen>.

@parm   LONG | lExpand | The minimum number of bytes to expand the buffer by.

@rdesc  If the function succeeds, zero is returned.  If the function fails,
    an error code is returned.  In particular, MMIOERR_OUTOFMEMORY is
    returned if memory reallocation failed.

@comm   Only call this function for memory files.
*/
/*--------------------------------------------------------------------*/
static UINT NEAR PASCAL
mmioExpandMemFile(PMMIO pmmio, LONG lExpand)
{
    MMIOMEMINFO *   pInfo = (MMIOMEMINFO *) pmmio->adwInfo;
    DWORD       dwFlagsTemp;
    UINT        w;

    /* make sure buffer can be expanded */
    /* Note: we used to check ALLOC_BUF here, we don't now. */
    if (pInfo->lExpand == 0)
        return MMIOERR_CANNOTEXPAND;    // cannot grow file

    /* how much should the buffer be expanded by? */
    if (lExpand < pInfo->lExpand)
        lExpand = pInfo->lExpand;

    dwFlagsTemp = pmmio->dwFlags;
    pmmio->dwFlags |= MMIO_ALLOCBUF;
    w = mmioSetBuffer(((HMMIO)pmmio), NULL,
                     pmmio->cchBuffer + lExpand, 0);
    pmmio->dwFlags = dwFlagsTemp;
    return w;
}


/*--------------------------------------------------------------------*/
/* @doc INTERNAL

@api    LRESULT | mmioDOSIOProc | The 'DOS' I/O procedure, which handles I/O
    on ordinary DOS files.

@parm   LPSTR | lpmmioinfo | A pointer to an MMIOINFO block that
    contains information about the open file.

@parm   UINT | uMsg | The message that the I/O procedure is being
    asked to execute.

@parm   LONG | lParam1 | Specifies additional message information.

@parm   LONG | lParam2 | Specifies additional message information.

@rdesc  Return value depends on <p wMsg>.
*/
/*--------------------------------------------------------------------*/
LRESULT
     mmioDOSIOProc(LPSTR lpmmioStr, UINT uMsg, LPARAM lParam1, LPARAM lParam2)
{
    PMMIO       pmmio  = (PMMIO)lpmmioStr;              // only in DLL!
    MMIODOSINFO *pInfo = (MMIODOSINFO *)pmmio->adwInfo;
    LONG        lResult;
    LPWSTR      szFilePart;
    WCHAR       szPath[ MAX_PATH ];

    switch (uMsg) {

    case MMIOM_OPEN:
        /*
         * The extra info parameter optionally contains a
         * sequence number to pass.
         */
        if ( pmmio->dwFlags & MMIO_GETTEMP )
        {
            V_RPOINTER((LPSTR)lParam1, 4, (LRESULT) MMSYSERR_INVALPARAM);

            if ( GetTempPathW( MAX_PATH, szPath ) == 0 ) {
                wcscpy( szPath, (LPCWSTR)L"." );
            }

            return GetTempFileNameW( szPath, (LPCWSTR)L"sje",
                                    (WORD)pmmio->adwInfo[0], (LPWSTR)lParam1 )
                   ? (LRESULT)0
                   : (LRESULT)MMIOERR_FILENOTFOUND;
        }


        /*------------------------------------------------------------*\
         * <lParam1> is either a file name or NULL; if it is
         * NULL, then <adwInfo[0]>, which is actually <pInfo->fh>,
         * should already contain an open DOS file handle.
         *
         * Does lParam1 point to a file name ?
         *
         * if so then either:
         *
         *  delete the file,
         *  check the existance of the file,
         *  parse the file name, or
         *  open the file name
         *
        \*------------------------------------------------------------*/
        if ( lParam1 != 0 ) {

            if ( pmmio->dwFlags & MMIO_DELETE ) {

                return DeleteFileW( (LPWSTR)lParam1 )
                       ? (LRESULT)0
                       : (LRESULT)MMIOERR_FILENOTFOUND;
            }

            if ( pmmio->dwFlags & MMIO_EXIST ) {
                if ( !(pmmio->dwFlags & MMIO_CREATE) ) {
#ifdef LATER
      I think this should be using SearchPath (with lpszPath==lParam1)
      as the definition of MMIO_EXIST states that a fully qualified
      filename is returned.  OR tweak the flags to turn MMIO_PARSE ON
      and execute the next section.
#endif
                    if ( GetFileAttributesW( (LPWSTR)lParam1 ) == -1 ) {
                        return (LRESULT)MMIOERR_FILENOTFOUND;
                    }
                    return (LRESULT)0;
                }
            }

            if ( pmmio->dwFlags & MMIO_PARSE ) {

                if ( GetFullPathNameW((LPWSTR)lParam1,
                                  MAX_PATH,
                                  szPath,
                                  &szFilePart ) == 0 ) {

                    return (LRESULT)MMIOERR_FILENOTFOUND;
                }
                wcscpy( (LPWSTR)lParam1, szPath );
                return (LRESULT) 0;
            }

            {
                DWORD   dwAccess        = 0;
                DWORD   dwSharedMode    = 0;
                DWORD   dwCreate        = 0;
                DWORD   dwFlags         = FILE_ATTRIBUTE_NORMAL;

                /*----------------------------------------------------*\
                 * Look at the access flags
                \*----------------------------------------------------*/
                if ( pmmio->dwFlags & MMIO_WRITE ) {
                    dwAccess = GENERIC_WRITE;
                } else {
                    dwAccess = GENERIC_READ;
                }

                if ( pmmio->dwFlags & MMIO_READWRITE ) {
                    dwAccess |= (GENERIC_WRITE | GENERIC_READ);
                }

                /*----------------------------------------------------*\
                 * Set dwSharedMode from the share flags
                \*----------------------------------------------------*/

                {   /* owing to some crappy design in WIN3.1, the share flags are
                    *  exclusive  = 10
                    *  deny write = 20
                    *  deny read  = 30
                    *  deny none  = 40
                    *  so deny read looks like exclusive + deny write.  Sigh.
                    *  00 is taken as being DENYNONE (probably correct)
                    *  So is 50, 60 and 70 (which is probably bogus).
                    *  As we need to support the DOS flags for WOW, we need this
                    *  code somewhere, so might as well leave the flag definitions
                    *  as they are.  First pull out all the share mode bits.
                    */
                    DWORD dwShare = MMIO_DENYWRITE | MMIO_DENYREAD
                                  | MMIO_DENYNONE | MMIO_EXCLUSIVE;
                    dwShare &= pmmio->dwFlags;

                    switch (dwShare)
                    {   case MMIO_DENYWRITE:
                           dwSharedMode = FILE_SHARE_READ;
                        break;
                        case MMIO_DENYREAD:
                           dwSharedMode = FILE_SHARE_WRITE;
                        break;
                        case MMIO_EXCLUSIVE:
                           dwSharedMode = 0;
                        break;
                        case MMIO_DENYNONE:
                        default:
                           dwSharedMode = FILE_SHARE_WRITE | FILE_SHARE_READ;
                        break;
#ifdef later
   Generate an error for invalid flags?
#endif
                    }
                }

                /*----------------------------------------------------*\
                 * Look at the create flags
                \*----------------------------------------------------*/
                if ( (pmmio->dwFlags) & MMIO_CREATE) {
                    UINT    cch  = sizeof(szPath)/sizeof(szPath[0]);
                    LPWSTR  pstr = (LPWSTR)lParam1;
                
                    dwCreate = CREATE_ALWAYS;
                    
                    lstrcpynW( szPath, pstr, cch );
                    szPath[cch-1] = TEXT('\0');
                    if (lstrlenW(pstr) > lstrlenW(szPath))
                    {
                        //  Filename was truncated.
                        return (LRESULT)MMIOERR_INVALIDFILE;
                    }
                } else {
                    dwCreate = OPEN_EXISTING;
                    if ( SearchPathW( NULL, (LPWSTR)lParam1,
                                      NULL,
                                      (MAX_PATH - 1),
                                      szPath, &szFilePart ) == 0 ) {

                        return (LRESULT)MMIOERR_FILENOTFOUND;
                    }
                }

                pInfo->fh = (int)(DWORD_PTR)CreateFileW( szPath,
                                              dwAccess,
                                              dwSharedMode,
                                              NULL,
                                              dwCreate,
                                              dwFlags | FILE_FLAG_SEQUENTIAL_SCAN,
                                              NULL );

                if ( pInfo->fh == (int)-1 ) {
                    return (LRESULT)MMIOERR_FILENOTFOUND;
                }

                if ( pmmio->dwFlags & MMIO_EXIST ) {
                    CloseHandle( (HANDLE)(UINT_PTR)pInfo->fh );
                    return (LRESULT)0;
                }

            }

        }
        /* check the current file offset */
        pmmio->lDiskOffset = _llseek(pInfo->fh, 0L, SEEK_CUR);
        return (LRESULT)0;

    case MMIOM_CLOSE:
        /* MMIO_FHOPEN flag means keep the DOS file handle open */
        if (  !((DWORD)lParam1 & MMIO_FHOPEN)
           && (_lclose(pInfo->fh) == HFILE_ERROR) ) {

            return (LRESULT) MMIOERR_CANNOTCLOSE;
        }
        return (LRESULT) 0;

    case MMIOM_READ:
        lResult = _lread(pInfo->fh, (LPVOID)lParam1, (LONG)lParam2);
        if (lResult != -1L) {
            pmmio->lDiskOffset += lResult;
        }
        return (LRESULT) lResult;

    case MMIOM_WRITE:
    case MMIOM_WRITEFLUSH:

        lResult = _lwrite(pInfo->fh, (LPVOID)lParam1, (LONG)lParam2);
        if (lResult != -1L) {
            pmmio->lDiskOffset += lResult;
        }

#ifdef DOSCANFLUSH
        if (uMsg == MMIOM_WRITEFLUSH)
        {
            /* Issue hardware flush command */
        }
#endif
        return (LRESULT) lResult;

    case MMIOM_SEEK:
        lResult = _llseek(pInfo->fh, (LONG)lParam1, (int)(LONG)lParam2);
        if (lResult != -1L) {
            pmmio->lDiskOffset = lResult;
        }
        return (LRESULT) lResult;

    case MMIOM_RENAME:
        if (!MoveFileW((LPWSTR)lParam1, (LPWSTR)lParam2)) {
            return (LRESULT) MMIOERR_FILENOTFOUND;
            /* ??? There are other errors too? e.g. target exists? */
        }
        break;

    }

    return (LRESULT) 0;
}


/*--------------------------------------------------------------------*/
/* @doc INTERNAL

@api    LRESULT | mmioMEMIOProc | The 'MEM' I/O procedure, which handles I/O
    on memory files.

@parm   LPSTR | lpmmioinfo | A pointer to an MMIOINFO block that
    contains information about the open file.

@parm   UINT | uMsg | The message that the I/O procedure is being
    asked to execute.

@parm   LONG | lParam1 | Specifies additional message information.

@parm   LONG | lParam2 | Specifies additional message information.

@rdesc  Return value depends on <p uMsg>.
*/
/*--------------------------------------------------------------------*/
LRESULT
      mmioMEMIOProc(LPSTR lpmmioStr, UINT uMsg, LPARAM lParam1, LPARAM lParam2)
{
    PMMIO       pmmio = (PMMIO) lpmmioStr; // only in DLL!

    switch (uMsg)
    {

        case MMIOM_OPEN:

        if ( pmmio->dwFlags
           & ~(MMIO_CREATE
              | MMIO_READWRITE
              | MMIO_WRITE
              | MMIO_EXCLUSIVE
              | MMIO_DENYWRITE
              | MMIO_DENYREAD
              | MMIO_DENYNONE
              | MMIO_ALLOCBUF
              )
           )
            return (LRESULT) MMSYSERR_INVALFLAG;

        /* all the data in the buffer is valid */
        if (!(pmmio->dwFlags & MMIO_CREATE))
            pmmio->pchEndRead = pmmio->pchEndWrite;
        return (LRESULT) 0;

    case MMIOM_CLOSE:

        /* nothing special to do on close */
        return (LRESULT) 0;

    case MMIOM_READ:
    case MMIOM_WRITE:
    case MMIOM_WRITEFLUSH:
    case MMIOM_SEEK:
                return (LRESULT) -1;
    }

    return (LRESULT) 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\mmiocf.h ===
// Copyright (c) 1992 Microsoft Corporation
/* mmiocf.h
 *
 * Multimedia File I/O Library.
 *
 * This include file contains declarations required for compound file support.
 *
 */

/* Revision history:
   LaurieGr: Jan 92 Ported from win16.  Source tree fork, not common code.
*/

#ifndef MMIOCF_H
#define MMIOCF_H

typedef HANDLE HMMCF;           // a handle to an open RIFF compound file

typedef struct _MMCFINFO        // structure for representing CTOC header info.
{
        DWORD           dwHeaderSize;   // size of CTOC header (w/o entries)
        DWORD           dwEntriesTotal; // no. of entries in table of contents
        DWORD           dwEntriesDeleted; // no. of entries ref. to. del. ent.
        DWORD           dwEntriesUnused; // no. of entries that are not used
        DWORD           dwBytesTotal;   // total bytes of CGRP contents
        DWORD           dwBytesDeleted; // total bytes of deleted CGRP elements
        DWORD           dwHeaderFlags;  // flags
        WORD            wEntrySize;     // size of each <CTOC-table-entry>
        WORD            wNameSize;      // size of each <achName> field
        WORD            wExHdrFields;   // number of "extra header fields"
        WORD            wExEntFields;   // number of "extra entry fields"
} MMCFINFO, FAR *LPMMCFINFO;

typedef struct _MMCTOCENTRY     // structure for representing CTOC entry info.
{
        DWORD           dwOffset;       // offset of element inside CGRP chunk
        DWORD           dwSize;         // size of element inside CGRP chunk
        DWORD           dwMedType;      // media element type of CF element
        DWORD           dwMedUsage;     // media element usage information
        DWORD           dwCompressTech; // media element compression technique
        DWORD           dwUncompressBytes; // size after decompression
        DWORD           adwExEntField[1]; // extra CTOC table entry fields
} MMCTOCENTRY, FAR *LPMMCTOCENTRY;

/* <dwFlags> field of MMIOINFO structure -- many same as OpenFile() flags */
#define MMIO_CTOCFIRST  0x00020000      // mmioCFOpen(): put CTOC before CGRP

/* flags for other functions */
#define MMIO_FINDFIRST          0x0010  // mmioCFFindEntry(): find first entry
#define MMIO_FINDNEXT           0x0020  // mmioCFFindEntry(): find next entry
#define MMIO_FINDUNUSED         0x0040  // mmioCFFindEntry(): find unused entry
#define MMIO_FINDDELETED        0x0080  // mmioCFFindEntry(): find deleted entry

/* message numbers for MMIOPROC */
#define MMIOM_GETCF             10      // get HMMCF of CF element
#define MMIOM_GETCFENTRY        11      // get ptr. to CTOC table entry

/* four character codes used to identify standard built-in I/O procedures */
#define FOURCC_BND      mmioFOURCC('B', 'N', 'D', ' ')

/* <dwHeaderFlags> field of MMCFINFO structure */
#define CTOC_HF_SEQUENTIAL      0x00000001 // CF elements in same order as CTOC
#define CTOC_HF_MEDSUBTYPE      0x00000002 // <dwMedUsage> is a med. el. subtype

/* CTOC table entry flags */
#define CTOC_EF_DELETED         0x01    // CF element is deleted
#define CTOC_EF_UNUSED          0x02    // CTOC entry is unused

/* CF I/O prototypes */
HMMCF FAR PASCAL mmioCFOpen(LPWSTR szFileName, DWORD dwFlags);
HMMCF FAR PASCAL mmioCFAccess(HMMIO hmmio, LPMMCFINFO lpmmcfinfo,
        DWORD dwFlags);
MMRESULT FAR PASCAL mmioCFClose(HMMCF hmmcf, UINT uFlags);
DWORD FAR PASCAL mmioCFGetInfo(HMMCF hmmcf, LPMMCFINFO lpmmcfinfo, DWORD cb);
DWORD FAR PASCAL mmioCFSetInfo(HMMCF hmmcf, LPMMCFINFO lpmmcfinfo, DWORD cb);
LPMMCTOCENTRY FAR PASCAL mmioCFFindEntry(HMMCF hmmcf, LPWSTR szName,
        UINT uFlags, LONG lParam);

#endif // MMIOCF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\mmioi.h ===
// Copyright (c) 1991-1992 Microsoft Corporation
/* mmioi.h
 *
 * Definitions that are internal to the MMIO library, i.e. shared by MMIO*.C
 */


/* Revision history:
 * LaurieGr: Jan 92 Ported from win16.  Source tree fork, not common code.
 * StephenE: Apr 92 added unicode to ascii conversion function prototypes.
 */

#include "mmiocf.h"

#include "mmiocf.h"
typedef MMIOINFO *PMMIO;                // (Win32)

typedef struct _MMIODOSINFO             // How DOS IOProc uses MMIO.adwInfo[]
{
        int             fh;             // DOS file handle
} MMIODOSINFO;

typedef struct _MMIOMEMINFO             // How MEM IOProc uses MMIO.adwInfo[]
{
        LONG            lExpand;        // increment to expand mem. files by
} MMIOMEMINFO;

typedef struct _MMIOBNDINFO             // How BND IOProc uses MMIO.adwInfo[]
{
        HMMCF           hmmcf;          // which compound file owns this element
        WORD            wPad;           // make adwInfo[0] equals <hmmcf>
        LPMMCTOCENTRY   pEntry;         // pointer to CTOC table entry
} MMIOBNDINFO;

typedef struct _MMCF
{
        HMMIO           hmmio;          // open file that contains CTOC and CGRP
        LPMMCFINFO      pHeader;        // ptr. to beginning of CTOC
        WORD            cbHeader;       // size of CTOC header
        HPSTR           pEntries;       // ptr. to first CTOC table entry
        HANDLE          hmmcfNext;      // next CF in list
        HANDLE          hmmcfPrev;      // previous CF in list
        HANDLE          hTask;          // handle to task that owns this
        LONG            lUsage;         // usage count
        WORD            wFlags;         // random flags
        LONG            lTotalExpand;   // how much CF expanded (to fix RIFF())

        /* information about each entry */
        WORD            wEntrySize;     // size of each <CTOC-table-entry>
        WORD            wEntFlagsOffset; // offset of <bEntryFlags> in an entry
        WORD            wEntNameOffset; // offset of <achName> in an entry

        /* offsets of parts of compound file (relative to start of file) */
        LONG            lStartCTOC;     // offset of start of CTOC chunk (or -1)
        LONG            lEndCTOC;       // offset of end of CTOC chunk (or -1)
        LONG            lStartCGRP;     // offset of start of CGRP chunk (or -1)
        DWORD           lStartCGRPData; // offset of data part of CGRP chunk
        LONG            lEndCGRP;       // offset of end of CGRP chunk (or -1)
        LONG            lEndFile;       // offset of end of CGRP chunk (or -1)
} MMCF, NEAR *PMMCF;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\mmiomisc.c ===
/* Copyright (c) 1991-1992 Microsoft Corporation */
/* mmiomisc.c
 *
 * Miscellaneous utility functions.
 *
 *      AsciiStrToUnicodeStr    Convert ASCII string Unicode
 *      CopyLPWSTRA             Convert Unicode string to ASCII
 *
 * See also WinCom, which defines:
 *
 *      lstrncpy        copy a string (up to n characters)
 *      lstrncat        concatenate strings (up to n characters)
 *      lstrncmp        compare strings (up to n characters)
 *      lmemcpy         copy a memory block
 *      hmemcpy         copy a huge memory block
 *      HPSTR           the type "char huge *"
 *      SEEK_SET/CUR/END constants used for seeking
 */


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "winmmi.h"
#include "mmioi.h"

/*--------------------------------------------------------------------*\
 * Function prototypes
\*--------------------------------------------------------------------*/
// extern int wcslen(LPCWSTR pwsz);

/**************************************************************************\
* AllocUnicodeStr
*
*
* Returns a UNICODE version of the given ASCII source string, or NULL if
* no storage is available.
* Users must call FreeUnicodeStr to free the allocated storage.
*
* 28-Apr-1992   StephenE    Created
\**************************************************************************/
LPWSTR AllocUnicodeStr( LPCSTR lpSourceStr )
{
    PBYTE   pByte;      // Ascii version of szFileName
    ULONG   cbDst;      // Length of lpSourceStr as a byte count

    cbDst = (strlen( lpSourceStr ) * sizeof(WCHAR)) + sizeof(WCHAR);

    pByte = HeapAlloc( hHeap, 0, cbDst );
    if ( pByte == (PBYTE)NULL ) {
        return (LPWSTR)NULL;
    }

    AsciiStrToUnicodeStr( pByte, pByte + cbDst, lpSourceStr );

    return (LPWSTR)pByte;
}
BOOL FreeUnicodeStr( LPWSTR lpStr )
{
    return HeapFree( hHeap, 0, (PBYTE)lpStr );
}

/**************************************************************************\
* AllocAsciiStr
*
*
* Returns a ASCII version of the given UNICODE source string, or NULL if
* no storage is available.
* Users must call FreeAsciiStr to free the allocated storage.
*
* 28-Apr-1992   StrphenE    Created
\**************************************************************************/
LPSTR AllocAsciiStr( LPCWSTR lpSourceStr )
{

    PBYTE   pByte;      // Ascii version of szFileName
    ULONG   cbDst;      // Length of lpSourceStr as a byte count

    cbDst = (wcslen( lpSourceStr ) * sizeof(WCHAR)) + sizeof(WCHAR);

    pByte = HeapAlloc( hHeap, 0, cbDst );
    if ( pByte == (PBYTE)NULL ) {
        return (LPSTR)NULL;
    }

    UnicodeStrToAsciiStr( pByte, pByte + cbDst, lpSourceStr );

    return (LPSTR)pByte;
}
BOOL FreeAsciiStr( LPSTR lpStr )
{
    return HeapFree( hHeap, 0, (PBYTE)lpStr );
}



/**************************************************************************\
* AsciiStrToUnicodeStr
*
* Translate ANSI 'psrc' to UNICODE 'pdst' without destination going beyond
* 'pmax'
*
* Return DWORD-aligned ptr beyond end of pdst, 0 if failed.
*
* 27-Aug-1991  IanJa     Created
\**************************************************************************/
PBYTE AsciiStrToUnicodeStr( PBYTE pdst, PBYTE pmax, LPCSTR psrc )
{
    int     cbSrc;
    ULONG   cbDst;

    cbSrc = strlen( psrc ) + sizeof(CHAR);

    /*
     * The destination UNICODE string will never be more than twice the
     * length of the ANSI source string.  (It may sometimes be less, but
     * it's not worth computing it exactly now).
     */
    if ((pdst + (cbSrc * sizeof(WCHAR))) <= pmax) {
        /*
         * RtlMultiByteToUnicodeN() returns the exact number of
         * destination bytes.
         */
        RtlMultiByteToUnicodeN( (LPWSTR)pdst,           // Unicode str
                                (ULONG)(pmax - pdst),   // max len of pdst
                                &cbDst,                 // bytes in unicode str
                                (PCHAR)psrc,            // Source string
                                cbSrc                   // bytes in source str
                              );

        return pdst + ((cbDst + 3) & ~3);
    }
    return 0;
}

/**************************************************************************\
* UnicodeStrToAsciiStr
*
* Translate UNICODE 'psrc' to ANSI 'pdst' without destination going beyond
* 'pmax'
*
* Return DWORD-aligned ptr beyond end of pdst, 0 if failed.
*
* 27-Aug-1991  IanJa     Created
\**************************************************************************/
PBYTE UnicodeStrToAsciiStr( PBYTE pdst, PBYTE pmax, LPCWSTR psrc)
{
    int     cbSrc;
    ULONG   cbDst;

    cbSrc = (wcslen(psrc) * sizeof(WCHAR)) + sizeof(WCHAR);

    /*
     * The destination ANSI string will never be longer than the UNICODE
     * source string (in bytes).  It is normally closer to half the length,
     * but due to the possibility of pre-composed characters, the upper
     * bound of the ANSI length is the UNICODE length (in bytes).
     */

    if ((pdst + cbSrc ) <= pmax) {
        /*
         * RtlUnicodeToMultiByteN() returns the exact number of
         * destination bytes.
         */
        RtlUnicodeToMultiByteN( (LPSTR)pdst,  // ansi string
                                (ULONG)(pmax - pdst),   // max len of pdst
                                &cbDst,       // bytes copied
                                (LPWSTR)psrc,
                                cbSrc);

        return pdst + ((cbDst + 3) & ~3);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\mmwnd.c ===
/******************************************************************************

   Copyright (c) 1985-1998 Microsoft Corporation

   Title:   mmwnd.c - contains the window procedure for the WINMM 'global'
                      window

                      the global window is used by sndPlaySound and MCI for
                      reciving notification messages.

   Version: 1.00

   Date:    04-Sep-1990

   Author:  ToddLa

   Changes: SteveDav Jan 92   Ported to NT

*****************************************************************************/

#include "winmmi.h"
#include "mci.h"

// WINMMI.H includes WINDOWS.H which will eventually include WINMM.H

//#ifdef DBG
//    #include "netname.h"
//#endif // DBG

#define CLASS_NAME MAKEINTATOM(43)   // 42 clashes with 16-bit mmsystem

DWORD mciWindowThreadId;

STATICFN LRESULT mmWndProc(HWND hwnd, MMMESSAGE msg, WPARAM wParam, LPARAM lParam);
STATICFN BOOL	WaitForWaitMsg(void);


typedef struct SentMsg {
    LRESULT Result;
    MMMESSAGE msg;
    WPARAM  wParam;
    LPARAM  lParam;
    UINT    SendingThread;
} SENTMSG, * PSENTMSG;

/*
**  Client notification stuff
*/

HWND             hwndNotify = NULL;

/*
**  Server notification stuff
*/

PGLOBALMCI       base;
CRITICAL_SECTION mciGlobalCritSec;
HANDLE           hEvent;

/***************************************************************************/

STATICDT BOOL classcreated = FALSE;

STATICFN BOOL PASCAL FAR CreateMMClass(
    void)
{
    WNDCLASS cls;

    if (classcreated) {
        return(TRUE);
    }

    ZeroMemory(&cls, sizeof(WNDCLASS));

    cls.hCursor        = NULL;
    cls.hIcon          = LoadIcon(ghInst, MAKEINTRESOURCE(IDI_MCIHWND));
    cls.lpszMenuName   = NULL;
    cls.lpszClassName  = CLASS_NAME;
    cls.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
    cls.hInstance      = ghInst;
    cls.style          = CS_GLOBALCLASS;
    cls.lpfnWndProc    = mmWndProc;
    cls.cbWndExtra     = 0;
    cls.cbClsExtra     = 0;

    classcreated = RegisterClass(&cls);
    return classcreated;
}


STATICDT CHAR mciWndName[] = "MCI command handling window";

//
//
//
BOOL mciGlobalInit(
    void)
{
    return TRUE;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif
//
//
//
STATICFN DWORD mciwnd2(LPVOID lpParams)
{
    UINT    msg;
    LPCWSTR lszSound;
    DWORD   wFlags;
    DWORD   n;
    WCHAR   soundname[MAX_PATH];

    while (TRUE) {

        LockMCIGlobal;
        if (!base->msg) {

#ifdef LATER
    This still needs to be tidied up.  The intention is to have a
    list of sounds that should be played.  This will also make it
    easier to STOP all sound playing by clearing out the list.
#endif
            // We have no work to do; reset the event and wait for
            // more work to be posted.  By setting the event within
            // the lock we are safe from timing windows.

            ResetMCIEvent(hEvent);
            UnlockMCIGlobal;
            dprintf2(("MCIWND2 thread waiting for next event..."));
            n = WaitForSingleObject(hEvent, WAIT_FOREVER);

#if DBG
            if ((DWORD)-1 == n) {
                n = GetLastError();
                dprintf2(("Error %d waiting on event in worker thread", n));
            }
#endif
            LockMCIGlobal;
    	}

        msg = base->msg;
        wFlags = base->dwFlags;
        lszSound = base->lszSound;

        base->msg=0;
        if (wFlags & SND_FILENAME) {
            // Have to copy the file name
            wcscpy(soundname, base->szSound);
            lszSound = soundname;
            dprintf3(("Copying the soundfile name to a local variable: %ls", lszSound));
        } else {
            dprintf3(("Playing a system sound"));
        }

        UnlockMCIGlobal;

        PlaySoundW(lszSound, NULL, (wFlags & ~SND_ASYNC)); // Play sync
    }

#if DBG
    dprintf(("MCIWND2 thread ending...!!"));
#endif
    return(0);
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif

/***************************************************************************
 *
 * @doc     INTERNAL    WINMM
 *
 * @api     void | WndTerminate | called when WINMM is terminating
 *
 ***************************************************************************/

STATICFN void NEAR PASCAL WndTerminate(
    void)
{
    dprintf1(("hwndNotify terminating"));
    if (hwndNotify)
    {
        dprintf1(("sending Close\n"));
        SendMessage(hwndNotify, WM_CLOSE, 0, 0L);
        UnregisterClass(CLASS_NAME, ghInst);
    }
}

/***************************************************************************
 *
 * @doc     INTERNAL    WINMM
 *
 * @api     LRESULT | mmWndProc | The Window procedure for the WINMM window
 *
 * @comm    mmWndProc calls DefWindowProc for all messages except:
 *
 *          MM_MCINOTIFY:       calls MciNotify()        in MCI.C
 *          MM_WOM_DONE:        calls WaveOutNotify()    in PLAYWAV.C
 *
 * @xref    sndPlaySound
 *
 ***************************************************************************/

STATICFN LRESULT mmWndProc(
    HWND    hwnd,
    MMMESSAGE msg,
    WPARAM  wParam,
    LPARAM  lParam)
{

#if DBG
    dprintf4(("MMWNDPROC: Msg %5x  Hwnd=%8x\r\n     wParam=%8x  lParam=%8x", msg, hwnd, wParam, lParam));
#endif
    switch (msg)
    {
        case WM_CREATE:
            hwndNotify = hwnd;
            break;

        case MM_MCINOTIFY:
            MciNotify((DWORD)wParam, (LONG)lParam);
            break;

#define NODELAY
#ifdef NODELAY
        case MM_WOM_DONE:

            /*
                The sound started with sndPlaySound has completed
                so we should call the cleanup routine. On NT we do NOT
                delay as the wave really has finished playing.
            */

            dprintf2(("Received MM_WOM_DONE, calling WaveOutNotify"));
            WaveOutNotify(0,0);

            break;
#else
/*
   SOUND_DELAY is the number of ms to delay before closing the wave device
   after the buffer is done.
*/

#define SOUND_DELAY 300
        case WM_TIMER:
            KillTimer(hwnd, (UINT)wParam);
            WaveOutNotify(0,0);
            break;

        case MM_WOM_DONE:

            /*
                The sound started with sndPlaySound has completed
                so we should call the cleanup routine. We delay
                this call for several hundred milliseconds because
                some sound drivers have a nasty characteristic - they
                will notify before the final DMA transfer is complete
                because the app. supplied buffer is no longer required.
                This means that they may have to spin inside a close
                request until the dma transfer completes. This hangs
                the system for hundreds of milliseconds.

            */

            dprintf2(("Received MM_WOM_DONE, setting timer delay"));

            SetTimer(hwndNotify, 1, SOUND_DELAY, NULL);
            break;
#endif

    	case MM_SND_ABORT:  /* Do not need to do anything */
    		break;

        case MM_SND_PLAY:
	{
	    // There is a critical section problem as we have one global, and
	    // sounds being played on separate threads.
	    MSG abortmsg;
	    if (SND_ALIAS_ID == (wParam & SND_ALIAS_ID)) {
	    return((LRESULT)PlaySound((LPCSTR)lParam, NULL, (DWORD)wParam & ~SND_ASYNC));
	    }
	    if (!PeekMessage(&abortmsg, hwnd, MM_SND_ABORT, MM_SND_ABORT, PM_NOREMOVE)) {
	        // There is no pending synchronous sound
	        return (LRESULT)(LONG)sndMessage((LPWSTR)lParam, (UINT)wParam);
	    }
	    // We must free the sound definition.  Note that this does not close
	    // the critical section as we may be past this check point when the
	    // synchronous sound causes the abort message to be posted.  But it
	    // will prevent spurious code being run.  It is perfectly valid for
	    // an asynchronous sound to be after the abort message, which is
	    // why the message is not removed at this point.
	    dprintf3(("Aborting sound..."));
	    if (!(wParam & SND_MEMORY)) {
		LocalFree((HANDLE)lParam);
	    }
	    break;
	}

	case MM_SND_SEND:
            ((PSENTMSG)wParam)->Result =
		mmWndProc(NULL, ((PSENTMSG)wParam)->msg,
		                  ((PSENTMSG)wParam)->wParam,
		                  ((PSENTMSG)wParam)->lParam);
	    PostThreadMessage(((PSENTMSG)wParam)->SendingThread, MCIWAITMSG, 0, 0);
	    break;

	case MM_POLYMSGBUFRDONE:
		--(((PMIDIEMU)wParam)->cPostedBuffers);
		midiOutNukePMBuffer((PMIDIEMU)wParam, (LPMIDIHDR)lParam);
		return (0L);

        case MM_MCISYSTEM_STRING:
            // In MCI.C
            return (LRESULT)mciRelaySystemString ((LPMCI_SYSTEM_MESSAGE)lParam);

        default:
            return DefWindowProc(hwnd, msg, wParam,lParam);
    }

    return (LRESULT)0L;
}

void mciwindow(HANDLE hEvent);


/*
**  Initialize all the bits for creating sound.  For non-server apps this
**  means initializing our hwnd.  For the server we set up a thread et
*/
BOOL InitAsyncSound(VOID)
{
    if (!WinmmRunningInServer) {
        return CreatehwndNotify();
    } else {

        LockMCIGlobal;

        if (base == NULL) {
            HANDLE hThread;
            PGLOBALMCI pBase;

            /*
            **  We need a thread, an event (we already have the crit sec) and
            **  some memory
            */


            pBase = mciAlloc(sizeof(GLOBALMCI));

            if (pBase == NULL) {
                UnlockMCIGlobal;
                return FALSE;
            }

            hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
            if (hEvent == NULL) {
                mciFree((PVOID)pBase);
                UnlockMCIGlobal;
                return FALSE;
            }

            /*
            **  We have to create a thread by a special method inside the
            **  server and register it with CSR
            */

            if (!CreateServerPlayingThread((PVOID)mciwnd2)) {
                mciFree((PVOID)pBase);
                CloseHandle(hEvent);
                hEvent = NULL;
                UnlockMCIGlobal;
                return FALSE;
            }

            base = pBase;

        }

        UnlockMCIGlobal;

        return base != NULL;
    }
}

BOOL CreatehwndNotify(VOID)
{
    HANDLE hWindowThread;
    BOOL   ReturnCode;
    HANDLE hEventForCreate;

    mciEnter("CreatehwndNotify");

    if (hwndNotify != NULL) {
        mciLeave("CreatehwndNotify");
        return TRUE;
    }

    if (!CreateMMClass()) {
        dprintf1(("Failed to create the MCI global window class, rc=%d", GetLastError()));
        mciLeave("CreatehwndNotify");
        return FALSE;
    } else {
        dprintf4(("Created global window class"));
    }

    // We create our new thread then suspend ourselves until the new
    // thread has called CreateWindow.  We are then triggered to run
    // and passed the results of the CreateWindow call.  NOTE:  Any
    // messages that arrive for this thread that are not destined for
    // a specific window will be DISCARDED until the one message we
    // are waiting for arrives.  We could create an event and wait
    // for that event to be triggered.  This was slightly quicker to
    // code and involves less creation/destruction of resources.

    hEventForCreate = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (hEventForCreate != NULL) {
        hWindowThread = CreateThread(NULL,  // attributes
                               0,           // same stack size as thread 1
                               (LPTHREAD_START_ROUTINE)mciwindow,
                               (LPVOID) hEventForCreate,
                               0,  // Thread runs immediately
                               &mciWindowThreadId
                               );
        CloseHandle(hWindowThread);

        if (!hWindowThread) {
            dprintf1(("Failed to create window thread. Error: %XH", GetLastError()));

        } else {
            dprintf3(("Window thread is %x", mciWindowThreadId));

        	WaitForSingleObject(hEventForCreate, INFINITE);

        	dprintf3(("hwndNotify now %x", hwndNotify));
        }
        CloseHandle(hEventForCreate);
    }
    ReturnCode = hwndNotify != NULL;
    mciLeave("CreatehwndNotify");

    return ReturnCode;
}

void mciwindow(
    HANDLE hEvent)

{
    BOOL fResult = TRUE;

    //
    //  Higher priority so we hear the sound at once!
    //  This seems to work better than calling SetThreadPriority
    //  on the handle just after creation (?).

    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);

    if (!(hwndNotify = CreateWindowEx(0, CLASS_NAME, mciWndName, WS_OVERLAPPED,
           0, 0, 0, 0, NULL, NULL, ghInst, NULL))) {
        dprintf1(("Failed to create the MCI global window, rc=%d", GetLastError()));
        UnregisterClass(CLASS_NAME, ghInst);
        fResult = FALSE;
    }

    //
    // Let our creator thread know we are up and running
    //
    SetEvent(hEvent);

    if (fResult) {
        MSG msg;
        HWND hwndTemp;

        while (GetMessage(&msg, NULL, 0, 0)) {


            /*
             *   If the message is for a window dispatch it
             */
            dprintf3(("mciwindow - Msg %5x hwnd %8x (%8x %8x)", msg.message, msg.hwnd, msg.wParam, msg.lParam));
            if (msg.hwnd != NULL) {
                DispatchMessage(&msg);
            }
    	}

        hwndTemp = hwndNotify;
        hwndNotify = NULL;    // Clear the global before destroying the window
        DestroyWindow(hwndTemp);
    }

    ExitThread(0);
}

#if 0   //LATER - not currently used

//
// Routine to SEND (synchronous) a message to another thread.  Currently
// the standard API allows you to send a message to a window, or post to
// a thread.  There are circumstances when it would be helpful to send
// to a thread.
//

STATICFN LRESULT SendThreadMessage(
    UINT    tid,
    MMMESSAGE msg,
    WPARAM  wParam,
    LPARAM  lParam)
{

    SENTMSG smsg;
    smsg.msg = msg;
    smsg.wParam = wParam;
    smsg.lParam = lParam;
    smsg.SendingThread = GetCurrentThreadId();
    PostThreadMessage(tid, MM_SND_SEND, (WPARAM)&smsg, 0);
    WaitForWaitMsg();
    return(smsg.Result);
}
#endif

/*********************************************************************\
* WaitForWaitMsg:                                                     *
*                                                                     *
* This routine waits until a specific message is returned to this     *
* thread.  While waiting NO posted messages are processed, but sent   *
* messages will be handled within GetMessage.  The routine is used    *
* to synchronise two threads of execution, and to implement a         *
* synchronous PostMessage operation between threads.                  *
*                                                                     *
\*********************************************************************/

STATICFN BOOL	WaitForWaitMsg() {
    for (;;) {
    	MSG msg;
        /*
         *   Retrieve our particular message
    	 */
    	GetMessage(&msg, NULL, MCIWAITMSG, MCIWAITMSG);

        /*
    	 *   If the message is for a window dispatch it
    	 */
        WinAssert(msg.hwnd == NULL);
#if 0
    	if (msg.hwnd != NULL) {      // This should not be executed.
    		DispatchMessage(&msg);   // MCIWAITMSG is not sent to a window
    	} else
#endif
    	    /*
    	     *   MCIWAITMSG is the signal message
    	     */
    		if (msg.message == MCIWAITMSG) {
    			break;
    		}
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\mmwow32.c ===
/******************************Module*Header*******************************\
* Module Name: mmwow32.c
*
* This file thunks for the Multi-Media functions.
*
* Created:  1-Jul-1993
* Author: Stephen Estrop [StephenE]
*
* Copyright (c) 1993-1999 Microsoft Corporation
\**************************************************************************/

#define NO_GDI

#ifndef WIN32
#define WIN32
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "winmmi.h"

#define _INC_ALL_WOWSTUFF
#include "mmwow32.h"
#include "mmwowcb.h"

// #define TELL_THE_TRUTH
#define MIN_TIME_PERIOD_WE_RETURN   1

#if DBG
/*
** ----------------------------------------------------------------
** Debugging, Profiling and Tracing variables.
** ----------------------------------------------------------------
*/

int TraceAux     = 0;
int TraceJoy     = 0;
int TraceTime    = 0;
int TraceMix     = 0;
int TraceWaveOut = 0;
int TraceWaveIn  = 0;
int TraceMidiOut = 0;
int TraceMidiIn  = 0;
int DebugLevel   = 0;
int AllocWaveCount;
int AllocMidiCount;

#endif

#ifndef _WIN64

PCALLBACK_DATA      pCallBackData;  // A 32 bit ptr to the 16 bit callback data
CRITICAL_SECTION    mmCriticalSection;
TIMECAPS            g_TimeCaps32;

LPCALL_ICA_HW_INTERRUPT GenerateInterrupt;
LPGETVDMPOINTER         GetVDMPointer;
LPWOWHANDLE32           lpWOWHandle32;
LPWOWHANDLE16           lpWOWHandle16;

DWORD
NotifyCallbackData(
    UINT uDevID,
    UINT uMsg,
    DWORD dwInstance,
    DWORD dwParam1,
    VPCALLBACK_DATA parg16
    );

BOOL APIENTRY
WOW32ResolveMultiMediaHandle(
    UINT uHandleType,
    UINT uMappingDirection,
    WORD wHandle16_In,
    LPWORD lpwHandle16_Out,
    DWORD dwHandle32_In,
    LPDWORD lpdwHandle32_Out
    );

/*
** Constants for use with WOW32ResolveMultiMediaHandle
*/

#define WOW32_DIR_16IN_32OUT        0x0001
#define WOW32_DIR_32IN_16OUT        0x0002


#define WOW32_WAVEIN_HANDLE         0x0003
#define WOW32_WAVEOUT_HANDLE        0x0004
#define WOW32_MIDIOUT_HANDLE        0x0005
#define WOW32_MIDIIN_HANDLE         0x0006

/*
** Constans for auxOutMessage, waveInMessage, waveOutMessage, midiInMessage
** and midiOutMessage.
*/
#define DRV_BUFFER_LOW      (DRV_USER - 0x1000)     // 0x3000
#define DRV_BUFFER_USER     (DRV_USER - 0x0800)     // 0x3800
#define DRV_BUFFER_HIGH     (DRV_USER - 0x0001)     // 0x3FFF


/******************************Public*Routine******************************\
* NotifyCallbackData
*
* This function is called by the 16 bit mmsystem.dll to notify us of the
* address of the callback data structure.  The callback data structure
* has been paged locked so that it can be accessed at interrupt time, this
* also means that we can safely keep a 32 bit pointer to the data.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
NotifyCallbackData(
    UINT uDevID,
    UINT uMsg,
    DWORD dwInstance,
    DWORD dwParam1,
    VPCALLBACK_DATA parg16
    )
{
    HMODULE     hModNTVDM;


    if ( parg16 ) {

        InitializeCriticalSection( &mmCriticalSection );

        hModNTVDM = GetModuleHandleW( (LPCWSTR)L"NTVDM.EXE" );
        if ( hModNTVDM ) {

            *(FARPROC *)&GenerateInterrupt =
                        GetProcAddress( hModNTVDM, "call_ica_hw_interrupt" );
        }

        timeGetDevCaps( &g_TimeCaps32, sizeof(g_TimeCaps32) );

#if !defined(i386)

        /*
        ** Although the Risc PC's support a uPeriodMin of 1ms, WOW does not
        ** seem capable of delivering interrupts at that rate on non
        ** intel platforms.
        */

        g_TimeCaps32.wPeriodMin = 10;
#endif

    }
    else {
        DeleteCriticalSection( &mmCriticalSection );
    }


    dprintf1(( "Notified of callback address %X", parg16 ));
    pCallBackData = GETVDMPTR( parg16 );

    return 0L;
}


/******************************Public*Routine******************************\
* wod32Message
*
* Thunks WODM_Xxxx messages
*
* The dwInstance field is used to save the 32 bit version of the decives
* handle.  So for example a WODM_PAUSE message can be thunked thus.
*      case WODM_PAUSE:
*          return waveOutPause( (HWAVEOUT)dwInstance );
*
*
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD WINAPI
wod32Message(
    UINT uDeviceID,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    )
{

#if DBG
    static MSG_NAME name_map[] = {
        WODM_GETNUMDEVS,        "WODM_GETNUMDEVS",
        WODM_GETDEVCAPS,        "WODM_GETDEVCAPS",
        WODM_OPEN,              "WODM_OPEN",
        WODM_CLOSE,             "WODM_CLOSE",
        WODM_PREPARE,           "WODM_PREPARE",
        WODM_UNPREPARE,         "WODM_UNPREPARE",
        WODM_WRITE,             "WODM_WRITE",
        WODM_PAUSE,             "WODM_PAUSE",
        WODM_RESTART,           "WODM_RESTART",
        WODM_RESET,             "WODM_RESET",
        WODM_GETPOS,            "WODM_GETPOS",
        WODM_GETPITCH,          "WODM_GETPITCH",
        WODM_SETPITCH,          "WODM_SETPITCH",
        WODM_GETVOLUME,         "WODM_GETVOLUME",
        WODM_SETVOLUME,         "WODM_SETVOLUME",
        WODM_GETPLAYBACKRATE,   "WODM_GETPLAYBACKRATE",
        WODM_SETPLAYBACKRATE,   "WODM_SETPLAYBACKRATE",
        WODM_BREAKLOOP,         "WODM_BREAKLOOP",
        WODM_BUSY,              "WODM_BUSY",
        WODM_MAPPER_STATUS,     "WODM_MAPPER_STATUS"
    };
    int      i;
    int      n;
#endif

    static  DWORD               dwNumWaveOutDevs;
            DWORD               dwRet = MMSYSERR_NOTSUPPORTED;
            DWORD               dwTmp;
            DWORD UNALIGNED     *lpdwTmp;
            WAVEOUTCAPSA        woCaps;
            MMTIME              mmTime32;

#if DBG
    for( i = 0, n = sizeof(name_map) / sizeof(name_map[0]); i < n; i++ ) {
        if ( name_map[i].uMsg == uMessage ) {
            break;
        }
    }
    if ( i != n ) {
        trace_waveout(( "wod32Message( 0x%X, %s, 0x%X, 0x%X, 0x%X)",
                        uDeviceID, name_map[i].lpstrName, dwInstance,
                        dwParam1, dwParam2 ));
    }
    else {
        trace_waveout(( "wod32Message( 0x%X, 0x%X, 0x%X, 0x%X, 0x%X)",
                        uDeviceID, uMessage, dwInstance,
                        dwParam1, dwParam2 ));
    }
#endif

    /*
    ** Make sure that we are consistent with the WAVE_MAPPER
    */
    if ( LOWORD(uDeviceID) == 0xFFFF ) {
        uDeviceID = (UINT)-1;
    }

    switch ( uMessage ) {

    case WODM_GETNUMDEVS:
        dwRet = waveOutGetNumDevs();
        break;


    case WODM_OPEN:
        dwRet = ThunkCommonWaveOpen( WAVE_OUT_DEVICE, uDeviceID, dwParam1,
                                     dwParam2, dwInstance );
        break;


    case WODM_CLOSE:
        dwRet = waveOutClose( (HWAVEOUT)dwInstance );
        break;


    case WODM_BREAKLOOP:
    case WODM_PAUSE:
    case WODM_RESET:
    case WODM_RESTART:
        dwRet = waveOutMessage( (HWAVEOUT)dwInstance, uMessage, 0L, 0L );
        break;


    case WODM_GETDEVCAPS:
       // Handle
       // Vadimb

        if ( 0 == dwInstance ) {
           dwRet = waveOutGetDevCapsA(uDeviceID, &woCaps, sizeof(woCaps));
        }
        else {
           dwRet = waveOutMessage((HWAVEOUT)dwInstance,
                                  uMessage,
                                  (DWORD)&woCaps,
                                  sizeof(woCaps));
        }

        if ( dwRet == MMSYSERR_NOERROR ) {
            CopyWaveOutCaps( (LPWAVEOUTCAPS16)GETVDMPTR( dwParam1 ),
                             &woCaps, dwParam2 );
        }
        break;


    case WODM_GETVOLUME:
        /*
        ** An application might try to get the volume using either
        ** the device ID (waveOutGetVolume) or a handle to the device
        ** waveOutMessage( WODM_GETVOLUME...), if the later is the case
        ** we must also call waveOutMessage as the device ID will not
        ** necessarily be valid.  Same applies for waveOutSetVolume below.
        */
        if ( dwInstance == 0 ) {
            dwRet = waveOutGetVolume( (HWAVEOUT)uDeviceID, &dwTmp );
        }
        else {
            dwRet = waveOutMessage( (HWAVEOUT)dwInstance, uMessage,
                                    (DWORD)&dwTmp, 0L );
        }
        lpdwTmp = GETVDMPTR( dwParam1 );
        *lpdwTmp = dwTmp;
        break;



    case WODM_GETPITCH:
    case WODM_GETPLAYBACKRATE:
        dwRet = waveOutMessage( (HWAVEOUT)dwInstance, uMessage,
                                (DWORD)&dwTmp, 0L );
        lpdwTmp = GETVDMPTR( dwParam1 );
        *lpdwTmp = dwTmp;
        break;


    case WODM_GETPOS:
        GetMMTime( (LPMMTIME16)GETVDMPTR( dwParam1 ), &mmTime32 );
        dwRet = waveOutGetPosition( (HWAVEOUT)dwInstance, &mmTime32,
                                    sizeof(mmTime32) );
        if ( dwRet == MMSYSERR_NOERROR ) {
            PutMMTime( (LPMMTIME16)GETVDMPTR( dwParam1 ), &mmTime32 );
        }
        break;


    case WODM_UNPREPARE:
        dwRet =  ThunkCommonWaveUnprepareHeader( (HWAVE)dwInstance, dwParam1,
                                                 WAVE_OUT_DEVICE );
        break;


    case WODM_PREPARE:
        dwRet =  ThunkCommonWavePrepareHeader( (HWAVE)dwInstance, dwParam1,
                                               WAVE_OUT_DEVICE );
        break;


    case WODM_SETVOLUME:
        /*
        ** An application might try to set the volume using either
        ** the device ID (waveOutSetVolume) or a handle to the device
        ** waveOutMessage( WODM_SETVOLUME...), if the later is the case
        ** we must also call waveOutMessage as the device ID will not
        ** necessarily be valid.  Same applies for waveOutGetVolume above.
        */
        if ( dwInstance == 0 ) {
            dwRet = waveOutSetVolume( (HWAVEOUT)uDeviceID, dwParam1 );
        }
        else {
            dwRet = waveOutMessage( (HWAVEOUT)dwInstance, uMessage,
                                    dwParam1, dwParam2 );
        }
        break;


    case WODM_SETPITCH:
    case WODM_SETPLAYBACKRATE:
        dwRet = waveOutMessage( (HWAVEOUT)dwInstance, uMessage, dwParam1, 0L );
        break;


    case WODM_WRITE:
        dwRet =  ThunkCommonWaveReadWrite( WAVE_OUT_DEVICE, dwParam1,
                                           dwParam2, dwInstance );
        break;


    case WODM_MAPPER_STATUS:
        {
            WAVEFORMATEX    waveFmtEx;

            switch ( dwParam1 ) {

            case WAVEOUT_MAPPER_STATUS_DEVICE:
            case WAVEOUT_MAPPER_STATUS_MAPPED:
                dwRet = waveOutMessage( (HWAVEOUT)dwInstance, uMessage,
                                        dwParam1, (DWORD)&dwTmp );
                lpdwTmp = GETVDMPTR( dwParam2 );
                *lpdwTmp = dwTmp;
                break;

            case WAVEOUT_MAPPER_STATUS_FORMAT:
                dwRet = waveOutMessage( (HWAVEOUT)dwInstance, uMessage,
                                        dwParam1, (DWORD)&waveFmtEx );

                CopyMemory( (LPVOID)GETVDMPTR( dwParam2 ),
                            (LPVOID)&waveFmtEx, sizeof(WAVEFORMATEX) );
                break;

            default:
                dwRet = MMSYSERR_NOTSUPPORTED;
            }
        }
        break;


    default:
        if ( uMessage >= DRV_BUFFER_LOW && uMessage <= DRV_BUFFER_HIGH ) {
            lpdwTmp = GETVDMPTR( dwParam1 );
        }
        else {
            lpdwTmp = (LPDWORD)dwParam1;
        }
        dwRet = waveOutMessage( (HWAVEOUT)dwInstance, uMessage,
                                (DWORD)lpdwTmp, dwParam2 );
        break;

    }

    trace_waveout(( "-> 0x%X", dwRet ));
    return dwRet;
}




/******************************Public*Routine******************************\
* wid32Message
*
* Thunks WIDM_Xxxx messages
*
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD WINAPI
wid32Message(
    UINT uDeviceID,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    )
{
#if DBG
    static MSG_NAME name_map[] = {
        WIDM_GETNUMDEVS,    "WIDM_GETNUMDEVS",
        WIDM_GETDEVCAPS,    "WIDM_GETDEVCAPS",
        WIDM_OPEN,          "WIDM_OPEN",
        WIDM_CLOSE,         "WIDM_CLOSE",
        WIDM_PREPARE,       "WIDM_PREPARE",
        WIDM_UNPREPARE,     "WIDM_UNPREPARE",
        WIDM_ADDBUFFER,     "WIDM_ADDBUFFER",
        WIDM_START,         "WIDM_START",
        WIDM_STOP,          "WIDM_STOP",
        WIDM_RESET,         "WIDM_RESET",
        WIDM_GETPOS,        "WIDM_GETPOS",
        WIDM_MAPPER_STATUS, "WIDM_MAPPER_STATUS"
    };
    int      i;
    int      n;
#endif

    static  DWORD               dwNumWaveInDevs;
            DWORD               dwRet = MMSYSERR_NOTSUPPORTED;
            WAVEINCAPSA         wiCaps;
            MMTIME              mmTime32;
            DWORD               dwTmp;
            DWORD UNALIGNED     *lpdwTmp;

#if DBG
    for( i = 0, n = sizeof(name_map) / sizeof(name_map[0]); i < n; i++ ) {
        if ( name_map[i].uMsg == uMessage ) {
            break;
        }
    }
    if ( i != n ) {
        trace_wavein(( "wid32Message( 0x%X, %s, 0x%X, 0x%X, 0x%X)",
                       uDeviceID, name_map[i].lpstrName, dwInstance,
                       dwParam1, dwParam2 ));
    }
    else {
        trace_wavein(( "wid32Message( 0x%X, 0x%X, 0x%X, 0x%X, 0x%X)",
                       uDeviceID, uMessage, dwInstance,
                       dwParam1, dwParam2 ));
    }
#endif

    /*
    ** Make sure that we are consistent with the WAVE_MAPPER
    */
    if ( LOWORD(uDeviceID) == 0xFFFF ) {
        uDeviceID = (UINT)-1;
    }

    switch ( uMessage ) {

    case WIDM_GETNUMDEVS:
        dwRet =  waveInGetNumDevs();
        break;


    case WIDM_GETDEVCAPS:
       // Handle
       // VadimB

        if (0 == dwInstance) {
           dwRet = waveInGetDevCapsA(uDeviceID, &wiCaps, sizeof(wiCaps));
        }
        else {
           dwRet = waveInMessage((HWAVEIN)dwInstance,
                                  uMessage,
                                  (DWORD)&wiCaps,
                                  sizeof(wiCaps));
        }

        if ( dwRet == MMSYSERR_NOERROR ) {
            CopyWaveInCaps( (LPWAVEINCAPS16)GETVDMPTR( dwParam1 ),
                            &wiCaps, dwParam2 );
        }
        break;


    case WIDM_OPEN:
        dwRet =  ThunkCommonWaveOpen( WAVE_IN_DEVICE, uDeviceID, dwParam1,
                                      dwParam2, dwInstance );
        break;


    case WIDM_UNPREPARE:
        dwRet =  ThunkCommonWaveUnprepareHeader( (HWAVE)dwInstance, dwParam1,
                                                 WAVE_IN_DEVICE );
        break;


    case WIDM_PREPARE:
        dwRet =  ThunkCommonWavePrepareHeader( (HWAVE)dwInstance, dwParam1,
                                               WAVE_IN_DEVICE );
        break;


    case WIDM_ADDBUFFER:
        dwRet =  ThunkCommonWaveReadWrite( WAVE_IN_DEVICE, dwParam1,
                                           dwParam2, dwInstance );
        break;


    case WIDM_CLOSE:
        dwRet = waveInClose( (HWAVEIN)dwInstance );
        break;


    case WIDM_START:
    case WIDM_STOP:
    case WIDM_RESET:
        dwRet = waveInMessage( (HWAVEIN)dwInstance, uMessage, 0L, 0L );
        break;


    case WIDM_GETPOS:
        GetMMTime( (LPMMTIME16)GETVDMPTR( dwParam1 ), &mmTime32 );
        dwRet = waveInGetPosition( (HWAVEIN)dwInstance, &mmTime32,
                                   sizeof(mmTime32) );
        if ( dwRet == MMSYSERR_NOERROR ) {
            PutMMTime( (LPMMTIME16)GETVDMPTR( dwParam1 ), &mmTime32 );
        }
        break;


    case WIDM_MAPPER_STATUS:
        {
            WAVEFORMATEX    waveFmtEx;

            switch ( dwParam1 ) {

            case WAVEIN_MAPPER_STATUS_DEVICE:
            case WAVEIN_MAPPER_STATUS_MAPPED:
                dwRet = waveInMessage( (HWAVEIN)dwInstance, uMessage,
                                        dwParam1, (DWORD)&dwTmp );
                lpdwTmp = GETVDMPTR( dwParam2 );
                *lpdwTmp = dwTmp;
                break;

            case WAVEIN_MAPPER_STATUS_FORMAT:
                dwRet = waveInMessage( (HWAVEIN)dwInstance, uMessage,
                                       dwParam1, (DWORD)&waveFmtEx );

                CopyMemory( (LPVOID)GETVDMPTR( dwParam2 ),
                            (LPVOID)&waveFmtEx, sizeof(WAVEFORMATEX) );
                break;

            default:
                dwRet = MMSYSERR_NOTSUPPORTED;
            }
        }
        break;


    default:
        if ( uMessage >= DRV_BUFFER_LOW && uMessage <= DRV_BUFFER_HIGH ) {
            lpdwTmp = GETVDMPTR( dwParam1 );
        }
        else {
            lpdwTmp = (LPDWORD)dwParam1;
        }
        dwRet = waveInMessage( (HWAVEIN)dwInstance, uMessage,
                               (DWORD)lpdwTmp, dwParam2 );

    }

    trace_wavein(( "-> 0x%X", dwRet ));
    return dwRet;
}


/*****************************Private*Routine******************************\
* ThunkCommonWaveOpen
*
* Thunks all wave device opens
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
ThunkCommonWaveOpen(
    int iWhich,
    UINT uDeviceID,
    DWORD dwParam1,
    DWORD dwParam2,
    DWORD dwInstance
    )
{

    /*
    ** dwParam1 is a 16:16 pointer to a WAVEOPENDESC16 structure.
    ** dwParam2 specifies any option flags used when opening the device.
    */

    LPWAVEOPENDESC16        lpOpenDesc16;
    WAVEFORMATEX UNALIGNED  *lpFormat16;
    DWORD                   dwRet;
    WAVEFORMAT              wf[4];
    WAVEFORMATEX            *lpFormat32;

    lpOpenDesc16 = GETVDMPTR( dwParam1 );
    lpFormat16 = GETVDMPTR( lpOpenDesc16->lpFormat );

    /*
    ** Thunk the wave format structure.  If the wave format tag is PCM
    ** we just copy the structure as is.  If the wave format size
    ** is less than or equal to sizeof(wf) again just copy the
    ** structure as is, otherwise we allocate a new structure and then
    ** copy 16 bit wave format into it.
    */
    switch ( lpFormat16->wFormatTag ) {

    case WAVE_FORMAT_PCM:
        CopyMemory( (LPVOID)&wf[0], (LPVOID)lpFormat16, sizeof(PCMWAVEFORMAT) );
        lpFormat32 = (WAVEFORMATEX *)&wf[0];
        break;

    default:
        if ( sizeof(WAVEFORMATEX) + lpFormat16->cbSize > sizeof(wf) ) {

            lpFormat32 = winmmAlloc( sizeof(WAVEFORMATEX) + lpFormat16->cbSize );

            if (lpFormat32 == NULL) {
                return MMSYSERR_NOMEM;
            }
        }
        else {

            lpFormat32 = (WAVEFORMATEX *)&wf[0];
        }

        CopyMemory( (LPVOID)lpFormat32, (LPVOID)lpFormat16,
                    sizeof(WAVEFORMATEX) + lpFormat16->cbSize );
        break;

    }


    /*
    ** If the app is only querying the device we don't have to do very
    ** much, just pass the mapped format to waveOutOpen.
    */
    if ( dwParam2 & WAVE_FORMAT_QUERY ) {

        if ( iWhich == WAVE_OUT_DEVICE ) {
            dwRet = waveOutOpen( NULL, uDeviceID, lpFormat32,
                                 lpOpenDesc16->dwCallback,
                                 lpOpenDesc16->dwInstance, dwParam2 );
        }
        else {
            dwRet = waveInOpen( NULL, uDeviceID, lpFormat32,
                                lpOpenDesc16->dwCallback,
                                lpOpenDesc16->dwInstance, dwParam2 );
        }
    }
    else {

        HWAVE           Hand32;
        PINSTANCEDATA   pInstanceData;

        /*
        ** Create InstanceData block to be used by our callback routine.
        **
        ** NOTE: Although we malloc it here we don't free it.
        ** This is not a mistake - it must not be freed before the
        ** callback routine has used it - so it does the freeing.
        **
        ** If the malloc fails we bomb down to the bottom,
        ** set dwRet to MMSYSERR_NOMEM and exit gracefully.
        **
        ** We always have a callback functions.  This is to ensure that
        ** the WAVEHDR structure keeps getting copied back from
        ** 32 bit space to 16 bit, as it contains flags which
        ** applications are liable to keep checking.
        */
        pInstanceData = winmmAlloc(sizeof(INSTANCEDATA) );
        if ( pInstanceData != NULL ) {

            DWORD dwNewFlags = CALLBACK_FUNCTION;

            dprintf2(( "WaveCommonOpen: Allocated instance buffer at 0x%8X",
                       pInstanceData ));
            dprintf2(( "16 bit callback = 0x%X", lpOpenDesc16->dwCallback ));

            pInstanceData->Hand16 = lpOpenDesc16->hWave;
            pInstanceData->dwCallback = lpOpenDesc16->dwCallback;
            pInstanceData->dwCallbackInstance = lpOpenDesc16->dwInstance;
            pInstanceData->dwFlags = dwParam2;

            dwNewFlags |= (dwParam2 & WAVE_ALLOWSYNC);

            if ( iWhich == WAVE_OUT_DEVICE ) {
                dwRet = waveOutOpen( (LPHWAVEOUT)&Hand32, uDeviceID, lpFormat32,
                                     (DWORD)W32CommonDeviceCB,
                                     (DWORD)pInstanceData, dwNewFlags );
            }
            else {
                dwRet = waveInOpen( (LPHWAVEIN)&Hand32, uDeviceID, lpFormat32,
                                    (DWORD)W32CommonDeviceCB,
                                    (DWORD)pInstanceData, dwNewFlags );
            }
            /*
            ** If the call returns success save a copy of the 32 bit handle
            ** otherwise free the memory we malloc'd earlier, as the
            ** callback that would have freed it will never get callled.
            */
            if ( dwRet == MMSYSERR_NOERROR ) {

                DWORD UNALIGNED *lpDw;

                lpDw = GETVDMPTR( dwInstance );
                *lpDw = (DWORD)Hand32;
                SetWOWHandle( Hand32, lpOpenDesc16->hWave );

                trace_waveout(( "Handle -> %x", Hand32 ));
            }
            else {

                dprintf2(( "WaveCommonOpen: Freeing instance buffer at %8X "
                           "because open failed", pInstanceData ));
                winmmFree( pInstanceData );
            }
        }
        else {

            dwRet = MMSYSERR_NOMEM;
        }
    }

    /*
    ** Free the wave format structure if one was allocated.
    */
    if (lpFormat32 != (WAVEFORMATEX *)&wf[0] ) {
        winmmFree( lpFormat32 );
    }

    return dwRet;
}

/*****************************Private*Routine******************************\
* ThunkCommonWaveReadWrite
*
* Thunks all wave reads and writes.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
ThunkCommonWaveReadWrite(
    int iWhich,
    DWORD dwParam1,
    DWORD dwParam2,
    DWORD dwInstance
    )
{
    UINT                ul;
    PWAVEHDR32          p32WaveHdr;
    WAVEHDR16 UNALIGNED   *lp16;


    /*
    ** Get a pointer to the shadow WAVEHDR buffer.
    */
    lp16 = GETVDMPTR( dwParam1 );
    p32WaveHdr = (PWAVEHDR32)lp16->reserved;

    /*
    ** Make sure that the wave headers are consistent.
    */
    p32WaveHdr->Wavehdr.lpData = GETVDMPTR( (PWAVEHDR32)lp16->lpData );
    p32WaveHdr->pWavehdr32 = lp16;

    CopyMemory( (LPVOID)&p32WaveHdr->Wavehdr.dwBufferLength,
                (LPVOID)&lp16->dwBufferLength,
                (sizeof(WAVEHDR) - sizeof(LPSTR) - sizeof(DWORD)) );

    /*
    ** Call either waveInAddBuffer or waveOutWrite as determined by
    ** iWhich.
    */
    if ( iWhich == WAVE_OUT_DEVICE ) {

        ul = waveOutWrite( (HWAVEOUT)dwInstance,
                           &p32WaveHdr->Wavehdr, sizeof(WAVEHDR) );
    }
    else {

        ul = waveInAddBuffer( (HWAVEIN)dwInstance,
                              &p32WaveHdr->Wavehdr, sizeof(WAVEHDR) );
    }

    /*
    ** If the call worked reflect any change in the wave header back into
    ** the header that the application gave use.
    */
    if ( ul == MMSYSERR_NOERROR ) {
        PutWaveHdr16( lp16, &p32WaveHdr->Wavehdr );
    }

    return ul;
}

/*****************************Private*Routine******************************\
* ThunkCommonWavePrepareHeader
*
* This function sets up the following structure...
*
*
*       +-------------+       +-------------+
*  0:32 | pWavehdr32  |------>| Original    |
*       +-------------+       | header      |
* 16:16 | pWavehdr16  |------>| passed by   |
*       +-------------+<--+   | the 16 bit  |
*       | New 32 bit  |   |   |             |
*       | header thats|   |   |             |
*       | used instead|   |   |             |
*       | of the one  |   |   +-------------+
*       | passed to by|   +---| reserved    |
*       | application.|       +-------------+
*       |             |
*       +-------------+
*
*  ... and then calls waveXxxPrepareHeader as determioned by iWhich.
*
* Used by:
*          waveOutPrepareHdr
*          waveInPrepareHdr
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
DWORD
ThunkCommonWavePrepareHeader(
    HWAVE hWave,
    DWORD dwParam1,
    int iWhich
    )
{

    PWAVEHDR32          p32WaveHdr;
    DWORD               ul;
    WAVEHDR16 UNALIGNED   *lp16;


    lp16 = GETVDMPTR( dwParam1 );

    /*
    ** Allocate some storage for the new wave header structure.
    ** On debug builds we keep track of the number of wave headers allocated
    ** and freed.
    */
    p32WaveHdr = (PWAVEHDR32)winmmAlloc( sizeof(WAVEHDR32) );
    if ( p32WaveHdr != NULL ) {

#if DBG
        AllocWaveCount++;
        dprintf2(( "WH>> 0x%X (%d)", p32WaveHdr, AllocWaveCount ));
#endif

        /*
        ** Copy the header given to us by the application into the newly
        ** allocated header.  Note that GetWaveHdr returns a 0:32 pointer
        ** to the applications 16 bit header, which we save for later use.
        */
        p32WaveHdr->pWavehdr16 = (PWAVEHDR16)dwParam1;
        p32WaveHdr->pWavehdr32 = GetWaveHdr16( dwParam1,
                                               &p32WaveHdr->Wavehdr );

        /*
        ** Prepare the real header
        */
        if ( iWhich == WAVE_OUT_DEVICE ) {
            ul = waveOutPrepareHeader( (HWAVEOUT)hWave,
                                       &p32WaveHdr->Wavehdr,
                                       sizeof(WAVEHDR) );
        }
        else {
            ul = waveInPrepareHeader( (HWAVEIN)hWave,
                                      &p32WaveHdr->Wavehdr,
                                      sizeof(WAVEHDR) );
        }

        if ( ul == MMSYSERR_NOERROR ) {

            /*
            ** Copy back the prepared header so that any changed fields are
            ** updated.
            */
            PutWaveHdr16( lp16, &p32WaveHdr->Wavehdr );

            /*
            ** Save a back pointer to the newly allocated header in the
            ** reserved field.
            */
            lp16->reserved = (DWORD)p32WaveHdr;
        }
        else {

            /*
            ** Some error happened, anyway the wave header is now trash so
            ** free the allocated storage etc.
            */
            winmmFree( p32WaveHdr );
#if DBG
            AllocWaveCount--;
            dprintf2(( "WH<< 0x%X (%d)", p32WaveHdr, AllocWaveCount ));
#endif
        }
    }
    else {
        dprintf2(( "Could not allocate shadow wave header!!" ));
        ul = MMSYSERR_NOMEM;
    }
    return ul;
}


/*****************************Private*Routine******************************\
* ThunkCommonWaveUnprepareHeader
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
DWORD
ThunkCommonWaveUnprepareHeader(
    HWAVE hWave,
    DWORD dwParam1,
    int iWhich
    )
{
    DWORD               ul;
    PWAVEHDR32          p32WaveHdr;
    WAVEHDR16 UNALIGNED   *lp16;
    BOOL                fDoneBitSet;

    lp16 = (WAVEHDR16 UNALIGNED *)GETVDMPTR( dwParam1 );
    p32WaveHdr = (PWAVEHDR32)lp16->reserved;

    /*
    ** The DK Stowaway app clears the done bit before calling
    ** waveOutUnprepareHeader and depends on the done bit being cleared when
    ** this api returns.
    **
    ** So when we copy the 32 bit flags back we make sure that the done
    ** is left in the same state that we found it
    */
    fDoneBitSet = (lp16->dwFlags & WHDR_DONE);

    /*
    ** Now call waveXxxUnprepare header with the shadow buffer as determined
    ** by iWhich.
    */
    if ( iWhich == WAVE_OUT_DEVICE ) {
        ul = waveOutUnprepareHeader( (HWAVEOUT)hWave,
                                     &p32WaveHdr->Wavehdr, sizeof(WAVEHDR) );
    }
    else {
        ul = waveInUnprepareHeader( (HWAVEIN)hWave,
                                    &p32WaveHdr->Wavehdr, sizeof(WAVEHDR) );
    }


    /*
    ** Reflect any changes made by waveOutUnprepareHeader back into the
    ** the buffer that the application gave us.
    */
    if ( ul == MMSYSERR_NOERROR ) {

        PutWaveHdr16( lp16, &p32WaveHdr->Wavehdr );

        /*
        ** Make sure that we leave the done bit in the same state that we
        ** found it.
        */
        if (fDoneBitSet) {
            lp16->dwFlags |= WHDR_DONE;
        }
        else {
            lp16->dwFlags &= ~WHDR_DONE;
        }

        /*
        ** If everything worked OK we should free the shadow wave header
        ** here.
        */
#if DBG
        AllocWaveCount--;
        dprintf2(( "WH<< 0x%X (%d)", p32WaveHdr, AllocWaveCount ));
#endif
        winmmFree( p32WaveHdr );
    }

    return ul;

}


/*****************************Private*Routine******************************\
* CopyWaveOutCaps
*
* Copies 32 bit wave out caps info into the passed 16bit storage.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
void
CopyWaveOutCaps(
    LPWAVEOUTCAPS16 lpCaps16,
    LPWAVEOUTCAPSA lpCaps32,
    DWORD dwSize
    )
{
    WAVEOUTCAPS16 Caps16;

    Caps16.wMid = lpCaps32->wMid;
    Caps16.wPid = lpCaps32->wPid;

    Caps16.vDriverVersion = LOWORD( lpCaps32->vDriverVersion );
    CopyMemory( Caps16.szPname, lpCaps32->szPname, MAXPNAMELEN );
    Caps16.dwFormats = lpCaps32->dwFormats;
    Caps16.wChannels = lpCaps32->wChannels;
    Caps16.dwSupport = lpCaps32->dwSupport;

    CopyMemory( (LPVOID)lpCaps16, (LPVOID)&Caps16, (UINT)dwSize );
}



/*****************************Private*Routine******************************\
* CopyWaveInCaps
*
* Copies 32 bit wave in caps info into the passed 16bit storage.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
void
CopyWaveInCaps(
    LPWAVEINCAPS16 lpCaps16,
    LPWAVEINCAPSA lpCaps32,
    DWORD dwSize
    )
{
    WAVEINCAPS16 Caps16;

    Caps16.wMid = lpCaps32->wMid;
    Caps16.wPid = lpCaps32->wPid;

    Caps16.vDriverVersion = LOWORD( lpCaps32->vDriverVersion );
    CopyMemory( Caps16.szPname, lpCaps32->szPname, MAXPNAMELEN );
    Caps16.dwFormats = lpCaps32->dwFormats;
    Caps16.wChannels = lpCaps32->wChannels;

    CopyMemory( (LPVOID)lpCaps16, (LPVOID)&Caps16, (UINT)dwSize );
}


/******************************Public*Routine******************************\
* GetWaveHdr16
*
* Thunks a WAVEHDR structure from 16 bit to 32 bit space.
*
* Used by:
*          waveOutWrite
*          waveInAddBuffer
*
* Returns a 32 bit pointer to the 16 bit wave header.  This wave header
* should have been locked down by wave(In|Out)PrepareHeader.  Therefore,
* it is to store this pointer for use during the WOM_DONE callback message.
*
* With the WAVEHDR and MIDIHDR structs I am assured by Robin that the ->lpNext
* field is only used by the driver, and is therefore in 32 bit space. It
* therefore doesn't matter what gets passed back and forth (I hope !).
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
PWAVEHDR16
GetWaveHdr16(
    DWORD vpwhdr,
    LPWAVEHDR lpwhdr
    )
{
    register PWAVEHDR16 pwhdr16;

    pwhdr16 = GETVDMPTR(vpwhdr);
    if ( pwhdr16 == NULL ) {
        dprintf1(( "getwavehdr16 GETVDMPTR returned an invalid pointer" ));
        return NULL;
    }

    CopyMemory( (LPVOID)lpwhdr, (LPVOID)pwhdr16, sizeof(*lpwhdr) );
    lpwhdr->lpData = GETVDMPTR( pwhdr16->lpData );

    return pwhdr16;
}

/******************************Public*Routine******************************\
* PutWaveHdr16
*
* Thunks a WAVEHDR structure from 32 bit back to 16 bit space.
*
* Used by:
*          waveOutPrepareHeader
*          waveOutUnprepareHeader
*          waveOutWrite
*          waveInPrepareHeader
*          waveInUnprepareHeader
*          waveInAddBuffer
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
void
PutWaveHdr16(
    WAVEHDR16 UNALIGNED *pwhdr16,
    LPWAVEHDR lpwhdr
    )
{
    LPSTR   lpDataSave     = pwhdr16->lpData;
    DWORD   dwReservedSave = pwhdr16->reserved;

    CopyMemory( (LPVOID)pwhdr16, (LPVOID)lpwhdr, sizeof(WAVEHDR) );

    pwhdr16->lpData   = lpDataSave;
    pwhdr16->reserved = dwReservedSave;

}


/******************************Public*Routine******************************\
* mod32Message
*
* Thunks all midi out apis.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD WINAPI
mod32Message(
    UINT uDeviceID,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    )
{
#if DBG
    static MSG_NAME name_map[] = {
        MODM_GETNUMDEVS,        "MODM_GETNUMDEVS",
        MODM_GETDEVCAPS,        "MODM_GETDEVCAPS",
        MODM_OPEN,              "MODM_OPEN",
        MODM_CLOSE,             "MODM_CLOSE",
        MODM_PREPARE,           "MODM_PREPARE",
        MODM_UNPREPARE,         "MODM_UNPREPARE",
        MODM_DATA,              "MODM_DATA",
        MODM_RESET,             "MODM_RESET",
        MODM_LONGDATA,          "MODM_LONGDATA",
        MODM_GETVOLUME,         "MODM_GETVOLUME",
        MODM_SETVOLUME,         "MODM_SETVOLUME" ,
        MODM_CACHEDRUMPATCHES,  "MODM_CACHEDRUMPATCHES",
        MODM_CACHEPATCHES,      "MODM_CACHEPATCHES"
    };
    int      i;
    int      n;
#endif

    static  DWORD               dwNumMidiOutDevs;
            DWORD               dwRet = MMSYSERR_NOTSUPPORTED;
            DWORD               dwTmp = 0;
            DWORD UNALIGNED     *lpdwTmp;
            MIDIOUTCAPSA        moCaps;

#if DBG
    for( i = 0, n = sizeof(name_map) / sizeof(name_map[0]); i < n; i++ ) {
        if ( name_map[i].uMsg == uMessage ) {
            break;
        }
    }
    if ( i != n ) {
        trace_midiout(( "mod32Message( 0x%X, %s, 0x%X, 0x%X, 0x%X)",
                        uDeviceID, name_map[i].lpstrName, dwInstance,
                        dwParam1, dwParam2 ));
    }
    else {
        trace_midiout(( "mod32Message( 0x%X, 0x%X, 0x%X, 0x%X, 0x%X)",
                        uDeviceID, uMessage, dwInstance,
                        dwParam1, dwParam2 ));
    }
#endif

    if ( LOWORD(uDeviceID) == 0xFFFF ) {
        uDeviceID = (UINT)-1;
    }

    switch ( uMessage ) {

    case MODM_GETNUMDEVS:
        dwRet = midiOutGetNumDevs();
        break;

    case MODM_GETDEVCAPS:
       //
       // this api also might take a valid handle in uDeviceID
       // per Win95 behavior
       // VadimB
        if (0 == dwInstance) {
           dwRet = midiOutGetDevCapsA( uDeviceID, &moCaps, sizeof(moCaps));
        }
        else {
           dwRet = midiOutMessage((HMIDIOUT)dwInstance,
                                  uMessage,
                                  (DWORD)&moCaps,
                                  sizeof(moCaps));
        }

        if ( dwRet == MMSYSERR_NOERROR ) {
            CopyMidiOutCaps( (LPMIDIOUTCAPS16)GETVDMPTR( dwParam1 ),
                              &moCaps, dwParam2 );
        }
        break;

    case MODM_OPEN:
        dwRet =  ThunkCommonMidiOpen( MIDI_OUT_DEVICE, uDeviceID, dwParam1,
                                      dwParam2, dwInstance );
        break;

    case MODM_LONGDATA:
        dwRet =  ThunkCommonMidiReadWrite( MIDI_OUT_DEVICE, dwParam1,
                                           dwParam2, dwInstance );
        break;

    case MODM_PREPARE:
        dwRet =  ThunkCommonMidiPrepareHeader( (HMIDI)dwInstance, dwParam1,
                                               MIDI_OUT_DEVICE );
        break;

    case MODM_UNPREPARE:
        dwRet =  ThunkCommonMidiUnprepareHeader( (HMIDI)dwInstance, dwParam1,
                                                 MIDI_OUT_DEVICE );
        break;

    case MODM_DATA:
        dwRet = midiOutShortMsg( (HMIDIOUT)dwInstance, dwParam1 );
        break;

    case MODM_CLOSE:
        dwRet = midiOutClose( (HMIDIOUT)dwInstance );
        break;

    case MODM_RESET:
        dwRet = midiOutMessage( (HMIDIOUT)dwInstance, uMessage,
                                dwParam1, dwParam2 );
        break;

    case MODM_SETVOLUME:
        /*
        ** An application might try to set the volume using either
        ** the device ID (midiOutSetVolume) or a handle to the device
        ** midiOutMessage( MODM_SETVOLUME...), if the later is the case
        ** we must also call midiOutMessage as the device ID will not
        ** necessarily be valid.  Same applies for midiOutGetVolume below.
        */
        if ( dwInstance == 0 ) {
            dwRet = midiOutSetVolume( (HMIDIOUT)uDeviceID, dwParam1 );
        }
        else {
            dwRet = midiOutMessage( (HMIDIOUT)dwInstance, uMessage,
                                    dwParam1, dwParam2 );
        }
        break;

    case MODM_GETVOLUME:
        if ( dwInstance == 0 ) {
            dwRet = midiOutGetVolume( (HMIDIOUT)uDeviceID, &dwTmp );
        }
        else {
            dwRet = midiOutMessage( (HMIDIOUT)dwInstance, uMessage,
                                    (DWORD)&dwTmp, dwParam2 );
        }
        lpdwTmp = GETVDMPTR( dwParam1 );
        *lpdwTmp = dwTmp;
        break;

    case MODM_CACHEPATCHES:
    case MODM_CACHEDRUMPATCHES:
        {
            LPWORD    lpCache;

            lpCache = winmmAlloc( MIDIPATCHSIZE * sizeof(WORD) );
            if ( lpCache != NULL ) {

                lpdwTmp = GETVDMPTR( dwParam1 );
                CopyMemory( (LPVOID)lpCache, (LPVOID)lpdwTmp,
                            MIDIPATCHSIZE * sizeof(WORD) );

                dwRet = midiOutMessage( (HMIDIOUT)dwInstance, uMessage,
                                        (DWORD)lpCache, dwParam2 );
                winmmFree( lpCache );
            }
            else {
                dwRet = MMSYSERR_NOMEM;
            }
        }
        break;

    default:
        if ( uMessage >= DRV_BUFFER_LOW && uMessage <= DRV_BUFFER_HIGH ) {
            lpdwTmp = GETVDMPTR( dwParam1 );
        }
        else {
            lpdwTmp = (LPDWORD)dwParam1;
        }
        dwRet = midiOutMessage( (HMIDIOUT)dwInstance, uMessage,
                               (DWORD)lpdwTmp, dwParam2 );
    }

    trace_midiout(( "-> 0x%X", dwRet ));
    return dwRet;
}


/******************************Public*Routine******************************\
* mid32Message
*
* Thunks all midi in apis.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD WINAPI
mid32Message(
    UINT uDeviceID,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    )
{
#if DBG
    static MSG_NAME name_map[] = {
        MIDM_GETNUMDEVS,        "MIDM_GETNUMDEVS",
        MIDM_GETDEVCAPS,        "MIDM_GETDEVCAPS",
        MIDM_OPEN,              "MIDM_OPEN",
        MIDM_ADDBUFFER,         "MIDM_ADDBUFFER",
        MIDM_CLOSE,             "MIDM_CLOSE",
        MIDM_PREPARE,           "MIDM_PREPARE",
        MIDM_UNPREPARE,         "MIDM_UNPREPARE",
        MIDM_RESET,             "MIDM_RESET",
        MIDM_START,             "MIDM_START",
        MIDM_STOP,              "MIDM_STOP",
    };
    int      i;
    int      n;
#endif

    static  DWORD               dwNumMidiInDevs;
            DWORD               dwRet = MMSYSERR_NOTSUPPORTED;
            MIDIINCAPSA         miCaps;
            DWORD UNALIGNED     *lpdwTmp;

#if DBG
    for( i = 0, n = sizeof(name_map) / sizeof(name_map[0]); i < n; i++ ) {
        if ( name_map[i].uMsg == uMessage ) {
            break;
        }
    }
    if ( i != n ) {
        trace_midiin(( "mid32Message( 0x%X, %s, 0x%X, 0x%X, 0x%X)",
                        uDeviceID, name_map[i].lpstrName, dwInstance,
                        dwParam1, dwParam2 ));
    }
    else {
        trace_midiin(( "mid32Message( 0x%X, 0x%X, 0x%X, 0x%X, 0x%X)",
                        uDeviceID, uMessage, dwInstance,
                        dwParam1, dwParam2 ));
    }
#endif

    if ( LOWORD(uDeviceID) == 0xFFFF ) {
        uDeviceID = (UINT)-1;
    }

    switch ( uMessage ) {

    case MIDM_GETNUMDEVS:
        dwRet = midiInGetNumDevs();
        break;

    case MIDM_GETDEVCAPS:
       // Handle
       // VadimB
        if (0 == dwInstance) {
           dwRet = midiInGetDevCapsA( uDeviceID, &miCaps, sizeof(miCaps));
        }
        else {
           dwRet = midiInMessage((HMIDIIN)dwInstance,
                                 uMessage,
                                 (DWORD)&miCaps,
                                 sizeof(miCaps));
        }

        if ( dwRet == MMSYSERR_NOERROR ) {
            CopyMidiInCaps( (LPMIDIINCAPS16)GETVDMPTR( dwParam1 ),
                            &miCaps, dwParam2 );
        }
        break;

    case MIDM_OPEN:
        dwRet =  ThunkCommonMidiOpen( MIDI_IN_DEVICE, uDeviceID, dwParam1,
                                      dwParam2, dwInstance );
        break;

    case MIDM_ADDBUFFER:
        dwRet =  ThunkCommonMidiReadWrite( MIDI_IN_DEVICE, dwParam1,
                                           dwParam2, dwInstance );
        break;

    case MIDM_PREPARE:
        dwRet =  ThunkCommonMidiPrepareHeader( (HMIDI)dwInstance, dwParam1,
                                               MIDI_IN_DEVICE );
        break;

    case MIDM_UNPREPARE:
        dwRet =  ThunkCommonMidiUnprepareHeader( (HMIDI)dwInstance, dwParam1,
                                                 MIDI_IN_DEVICE );
        break;

    case MIDM_CLOSE:
        dwRet = midiInClose( (HMIDIIN)dwInstance );
        break;

    case MIDM_START:
    case MIDM_STOP:
    case MIDM_RESET:
        dwRet = midiInMessage( (HMIDIIN)dwInstance, uMessage,
                               dwParam1, dwParam2 );
        break;

    default:
        if ( uMessage >= DRV_BUFFER_LOW && uMessage <= DRV_BUFFER_HIGH ) {
            lpdwTmp = GETVDMPTR( dwParam1 );
        }
        else {
            lpdwTmp = (LPDWORD)dwParam1;
        }
        dwRet = midiInMessage( (HMIDIIN)dwInstance, uMessage,
                               (DWORD)lpdwTmp, dwParam2 );
    }

    trace_midiin(( "-> 0x%X", dwRet ));
    return dwRet;
}

/*****************************Private*Routine******************************\
* ThunkCommonMidiOpen
*
* Thunks all midi open requests.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
ThunkCommonMidiOpen(
    int iWhich,
    UINT uDeviceID,
    DWORD dwParam1,
    DWORD dwParam2,
    DWORD dwInstance
    )
{

    /*
    ** dwParam1 is a 16:16 pointer to a MIDIOPENDESC16 structure.
    ** dwParam2 specifies any option flags used when opening the device.
    */

    LPMIDIOPENDESC16    lpOpenDesc16;
    DWORD               dwRet;
    HMIDI               Hand32;
    PINSTANCEDATA       pInstanceData;


    lpOpenDesc16 = GETVDMPTR( dwParam1 );

    /*
    ** Create InstanceData block to be used by our callback routine.
    **
    ** NOTE: Although we malloc it here we don't free it.
    ** This is not a mistake - it must not be freed before the
    ** callback routine has used it - so it does the freeing.
    **
    ** If the malloc fails we bomb down to the bottom,
    ** set dwRet to MMSYSERR_NOMEM and exit gracefully.
    **
    ** We always have a callback functions.  This is to ensure that
    ** the MIDIHDR structure keeps getting copied back from
    ** 32 bit space to 16 bit, as it contains flags which
    ** applications are liable to keep checking.
    */
    pInstanceData = winmmAlloc(sizeof(INSTANCEDATA) );
    if ( pInstanceData != NULL ) {

        DWORD dwNewFlags = CALLBACK_FUNCTION;

        dprintf2(( "MidiCommonOpen: Allocated instance buffer at 0x%8X",
                   pInstanceData ));
        dprintf2(( "16 bit callback = 0x%X", lpOpenDesc16->dwCallback ));

        pInstanceData->Hand16 = lpOpenDesc16->hMidi;
        pInstanceData->dwCallback = lpOpenDesc16->dwCallback;
        pInstanceData->dwCallbackInstance = lpOpenDesc16->dwInstance;
        pInstanceData->dwFlags = dwParam2;


        if ( iWhich == MIDI_OUT_DEVICE ) {
            dwRet = midiOutOpen( (LPHMIDIOUT)&Hand32, uDeviceID,
                                 (DWORD)W32CommonDeviceCB,
                                 (DWORD)pInstanceData, dwNewFlags );
        }
        else {
            dwRet = midiInOpen( (LPHMIDIIN)&Hand32, uDeviceID,
                                (DWORD)W32CommonDeviceCB,
                                (DWORD)pInstanceData, dwNewFlags );
        }
        /*
        ** If the call returns success save a copy of the 32 bit handle
        ** otherwise free the memory we malloc'd earlier, as the
        ** callback that would have freed it will never get callled.
        */
        if ( dwRet == MMSYSERR_NOERROR ) {

            DWORD UNALIGNED *lpDw;

            lpDw = GETVDMPTR( dwInstance );
            *lpDw = (DWORD)Hand32;
            SetWOWHandle( Hand32, lpOpenDesc16->hMidi );

#if DBG
            if ( iWhich == MIDI_OUT_DEVICE ) {
                trace_midiout(( "Handle -> %x", Hand32 ));
            }
            else {
                trace_midiout(( "Handle -> %x", Hand32 ));
            }
#endif

        }
        else {

            dprintf2(( "MidiCommonOpen: Freeing instance buffer at %8X "
                       "because open failed", pInstanceData ));
            winmmFree( pInstanceData );
        }
    }
    else {

        dwRet = MMSYSERR_NOMEM;
    }

    return dwRet;
}


/*****************************Private*Routine******************************\
* ThunkCommonMidiReadWrite
*
* Thunks all midi read/write requests.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
ThunkCommonMidiReadWrite(
    int iWhich,
    DWORD dwParam1,
    DWORD dwParam2,
    DWORD dwInstance
    )
{
    UINT                ul;
    PMIDIHDR32          p32MidiHdr;
    MIDIHDR UNALIGNED   *lp16;


    /*
    ** Get a pointer to the shadow MIDIHDR buffer.
    */
    lp16 = GETVDMPTR( dwParam1 );
    p32MidiHdr = (PMIDIHDR32)lp16->reserved;

    /*
    ** Make sure that the midi headers are consistent.
    */
    CopyMemory( (LPVOID)&p32MidiHdr->Midihdr.dwBufferLength,
                (LPVOID)&lp16->dwBufferLength,
                (sizeof(MIDIHDR) - sizeof(LPSTR) - sizeof(DWORD)) );
    p32MidiHdr->Midihdr.reserved = p32MidiHdr->reserved;

    /*
    ** Call either midiInAddBuffer or midiOutWrite as determined by
    ** iWhich.
    */
    if ( iWhich == MIDI_OUT_DEVICE ) {

        ul = midiOutLongMsg( (HMIDIOUT)dwInstance,
                             &p32MidiHdr->Midihdr, sizeof(MIDIHDR) );
    }
    else {

        ul = midiInAddBuffer( (HMIDIIN)dwInstance,
                              &p32MidiHdr->Midihdr, sizeof(MIDIHDR) );
    }

    /*
    ** If the call worked reflect any change in the midi header back into
    ** the header that the application gave use.
    */
    if ( ul == MMSYSERR_NOERROR ) {
        PutMidiHdr16( lp16, &p32MidiHdr->Midihdr );
    }

    return ul;
}

/*****************************Private*Routine******************************\
* ThunkCommonMidiPrepareHeader
*
* This function sets up the following structure...
*
*
*       +-------------+       +-------------+
*  0:32 | pMidihdr32  |------>| Original    |
*       +-------------+       | header      |
* 16:16 | pMidihdr16  |------>| passed by   |
*       +-------------+<--+   | the 16 bit  |
*       | New 32 bit  |   |   |             |
*       | header thats|   |   |             |
*       | used instead|   |   |             |
*       | of the one  |   |   +-------------+
*       | passed to by|   +---| reserved    |
*       | application.|       +-------------+
*       |             |
*       +-------------+
*
*  ... and then calls midiXxxPrepareHeader as determioned by iWhich.
*
* Used by:
*          midiOutPrepareHdr
*          midiInPrepareHdr
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
DWORD
ThunkCommonMidiPrepareHeader(
    HMIDI hMidi,
    DWORD dwParam1,
    int iWhich
    )
{

    PMIDIHDR32          p32MidiHdr;
    DWORD               ul;
    MIDIHDR UNALIGNED   *lp16;


    lp16 = GETVDMPTR( dwParam1 );

    /*
    ** Allocate some storage for the new midi header structure.
    ** On debug builds we keep track of the number of midi headers allocated
    ** and freed.
    */
    p32MidiHdr = (PMIDIHDR32)winmmAlloc( sizeof(MIDIHDR32) );
    if ( p32MidiHdr != NULL ) {

#if DBG
        AllocMidiCount++;
        dprintf2(( "MH>> 0x%X (%d)", p32MidiHdr, AllocMidiCount ));
#endif

        /*
        ** Copy the header given to us by the application into the newly
        ** allocated header.  Note that GetMidiHdr returns a 0:32 pointer
        ** to the applications 16 bit header, which we save for later use.
        */
        p32MidiHdr->pMidihdr16 = (PMIDIHDR16)dwParam1;
        p32MidiHdr->pMidihdr32 = GetMidiHdr16( dwParam1,
                                               &p32MidiHdr->Midihdr );

        /*
        ** Prepare the real header
        */
        if ( iWhich == MIDI_OUT_DEVICE ) {
            ul = midiOutPrepareHeader( (HMIDIOUT)hMidi,
                                       &p32MidiHdr->Midihdr,
                                       sizeof(MIDIHDR) );
        }
        else {
            ul = midiInPrepareHeader( (HMIDIIN)hMidi,
                                      &p32MidiHdr->Midihdr,
                                      sizeof(MIDIHDR) );
        }

        if ( ul == MMSYSERR_NOERROR ) {

            /*
            ** Save a copy of the reserved field, MidiMap uses it.
            */
            p32MidiHdr->reserved = p32MidiHdr->Midihdr.reserved;

            /*
            ** Copy back the prepared header so that any changed fields are
            ** updated.
            */
            PutMidiHdr16( lp16, &p32MidiHdr->Midihdr );

            /*
            ** Save a back pointer to the newly allocated header in the
            ** reserved field.
            */
            lp16->reserved = (DWORD)p32MidiHdr;
        }
        else {

            /*
            ** Some error happened, anyway the midi header is now trash so
            ** free the allocated storage etc.
            */
            winmmFree( p32MidiHdr );
#if DBG
            AllocMidiCount--;
            dprintf2(( "MH<< 0x%X (%d)", p32MidiHdr, AllocMidiCount ));
#endif
        }
    }
    else {
        dprintf2(( "Could not allocate shadow midi header!!" ));
        ul = MMSYSERR_NOMEM;
    }
    return ul;
}


/*****************************Private*Routine******************************\
* ThunkCommonMidiUnprepareHeader
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
DWORD
ThunkCommonMidiUnprepareHeader(
    HMIDI hMidi,
    DWORD dwParam1,
    int iWhich
    )
{
    DWORD               ul;
    PMIDIHDR32          p32MidiHdr;
    MIDIHDR UNALIGNED   *lp16;

    lp16 = (MIDIHDR UNALIGNED *)GETVDMPTR( dwParam1 );
    p32MidiHdr = (PMIDIHDR32)lp16->reserved;
    p32MidiHdr->Midihdr.reserved = p32MidiHdr->reserved;

    /*
    ** Now call midiXxxUnprepare header with the shadow buffer as determined
    ** by iWhich.
    */
    if ( iWhich == MIDI_OUT_DEVICE ) {
        ul = midiOutUnprepareHeader( (HMIDIOUT)hMidi,
                                     &p32MidiHdr->Midihdr, sizeof(MIDIHDR) );
    }
    else {
        ul = midiInUnprepareHeader( (HMIDIIN)hMidi,
                                    &p32MidiHdr->Midihdr, sizeof(MIDIHDR) );
    }


    /*
    ** Reflect any changes made by midiOutUnprepareHeader back into the
    ** the buffer that the application gave us.
    */
    if ( ul == MMSYSERR_NOERROR ) {

        PutMidiHdr16( lp16, &p32MidiHdr->Midihdr );

        /*
        ** If everything worked OK we should free the shadow midi header
        ** here.
        */
#if DBG
        AllocMidiCount--;
        dprintf2(( "MH<< 0x%X (%d)", p32MidiHdr, AllocMidiCount ));
#endif
        winmmFree( p32MidiHdr );
    }

    return ul;

}


/*****************************Private*Routine******************************\
* CopyMidiOutCaps
*
* Copies 32 bit midi out caps info into the passed 16bit storage.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
void
CopyMidiOutCaps(
    LPMIDIOUTCAPS16 lpCaps16,
    LPMIDIOUTCAPSA lpCaps32,
    DWORD dwSize
    )
{
    MIDIOUTCAPS16  Caps16;

    Caps16.wMid = lpCaps32->wMid;
    Caps16.wPid = lpCaps32->wPid;

    CopyMemory( Caps16.szPname, lpCaps32->szPname, MAXPNAMELEN );

    Caps16.vDriverVersion    = LOWORD( lpCaps32->vDriverVersion );
    Caps16.wTechnology       = lpCaps32->wTechnology;
    Caps16.wVoices           = lpCaps32->wVoices;
    Caps16.wNotes            = lpCaps32->wNotes;
    Caps16.wChannelMask      = lpCaps32->wChannelMask;
    Caps16.dwSupport         = lpCaps32->dwSupport;

    CopyMemory( (LPVOID)lpCaps16, (LPVOID)&Caps16, (UINT)dwSize );
}



/*****************************Private*Routine******************************\
* CopyMidiInCaps
*
* Copies 32 bit midi in caps info into the passed 16bit storage.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
void
CopyMidiInCaps(
    LPMIDIINCAPS16 lpCaps16,
    LPMIDIINCAPSA lpCaps32,
    DWORD dwSize
    )
{
    MIDIINCAPS16 Caps16;

    Caps16.wMid = lpCaps32->wMid;
    Caps16.wPid = lpCaps32->wPid;
    Caps16.vDriverVersion = LOWORD( lpCaps32->vDriverVersion );
    CopyMemory( Caps16.szPname, lpCaps32->szPname, MAXPNAMELEN );

    CopyMemory( (LPVOID)lpCaps16, (LPVOID)&Caps16, (UINT)dwSize );
}


/******************************Public*Routine******************************\
* GetMidiHdr16
*
* Thunks a MIDIHDR structure from 16 bit to 32 bit space.
*
* Used by:
*          midiOutLongMsg
*          midiInAddBuffer
*
* Returns a 32 bit pointer to the 16 bit midi header.  This midi header
* should have been locked down by midi(In|Out)PrepareHeader.  Therefore,
* it is to store this pointer for use during the WOM_DONE callback message.
*
* With the MIDIHDR and MIDIHDR structs I am assured by Robin that the ->lpNext
* field is only used by the driver, and is therefore in 32 bit space. It
* therefore doesn't matter what gets passed back and forth (I hope !).
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
PMIDIHDR16
GetMidiHdr16(
    DWORD vpmhdr,
    LPMIDIHDR lpmhdr
    )
{
    register PMIDIHDR16 pmhdr16;

    pmhdr16 = GETVDMPTR(vpmhdr);
    if ( pmhdr16 == NULL ) {
        dprintf1(( "getmidihdr16 GETVDMPTR returned an invalid pointer" ));
        return NULL;
    }

    CopyMemory( (LPVOID)lpmhdr, (LPVOID)pmhdr16, sizeof(*lpmhdr) );
    lpmhdr->lpData = GETVDMPTR( pmhdr16->lpData );

    return pmhdr16;
}


/******************************Public*Routine******************************\
* PutMidiHdr16
*
* Thunks a MIDIHDR structure from 32 bit back to 16 bit space.
*
* Used by:
*          midiOutPrepareHeader
*          midiOutUnprepareHeader
*          midiOutLongMsg
*          midiInPrepareHeader
*          midiInUnprepareHeader
*          midiInAddBuffer
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
void
PutMidiHdr16(
    MIDIHDR UNALIGNED *pmhdr16,
    LPMIDIHDR lpmhdr
    )
{
    LPSTR   lpDataSave     = pmhdr16->lpData;
    DWORD   dwReservedSave = pmhdr16->reserved;

    CopyMemory( (LPVOID)pmhdr16, (LPVOID)lpmhdr, sizeof(MIDIHDR) );

    pmhdr16->lpData   = lpDataSave;
    pmhdr16->reserved = dwReservedSave;
}


/*****************************Private*Routine******************************\
* PutMMTime
*
* Puts an MMTIME structure from 32 bit storage into 16 bit storage
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
void
PutMMTime(
    LPMMTIME16 lpTime16,
    LPMMTIME lpTime32
    )
{
    lpTime16->wType = LOWORD(lpTime32->wType);

    switch ( lpTime32->wType ) {
    case TIME_MS:
        lpTime16->u.ms = lpTime32->u.ms;
        break;

    case TIME_SAMPLES:
        lpTime16->u.sample = lpTime32->u.sample;
        break;

    case TIME_BYTES:
        lpTime16->u.cb = lpTime32->u.cb;
        break;

    case TIME_SMPTE:
        lpTime16->u.smpte.hour  = lpTime32->u.smpte.hour;
        lpTime16->u.smpte.min   = lpTime32->u.smpte.min;
        lpTime16->u.smpte.sec   = lpTime32->u.smpte.sec;
        lpTime16->u.smpte.frame = lpTime32->u.smpte.frame;
        lpTime16->u.smpte.fps   = lpTime32->u.smpte.fps;
        lpTime16->u.smpte.dummy = lpTime32->u.smpte.dummy;
        break;

    case TIME_MIDI:
        lpTime16->u.midi.songptrpos = lpTime32->u.midi.songptrpos;
        break;
    }
}


/*****************************Private*Routine******************************\
* GetMMTime
*
* Gets an MMTIME structure from 16 bit storage into 32 bit storage
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
void
GetMMTime(
    LPMMTIME16 lpTime16,
    LPMMTIME lpTime32
    )
{

    lpTime32->wType = lpTime16->wType;

    switch ( lpTime32->wType ) {
    case TIME_MS:
        lpTime32->u.ms = lpTime16->u.ms;
        break;

    case TIME_SAMPLES:
        lpTime32->u.sample = lpTime16->u.sample;
        break;

    case TIME_BYTES:
        lpTime32->u.cb = lpTime16->u.cb;
        break;

    case TIME_SMPTE:
        lpTime32->u.smpte.hour  = lpTime16->u.smpte.hour;
        lpTime32->u.smpte.min   = lpTime16->u.smpte.min;
        lpTime32->u.smpte.sec   = lpTime16->u.smpte.sec;
        lpTime32->u.smpte.frame = lpTime16->u.smpte.frame;
        lpTime32->u.smpte.fps   = lpTime16->u.smpte.fps;
        lpTime32->u.smpte.dummy = lpTime16->u.smpte.dummy;
        break;

    case TIME_MIDI:
        lpTime32->u.midi.songptrpos = lpTime16->u.midi.songptrpos;
        break;
    }
}


/******************************Public*Routine******************************\
* W32CommonDeviceCB
*
* This routine is the callback which is ALWAYS called by wave and midi
* functions.  This is done to ensure that the XXXXHDR structure keeps
* getting copied back from 32 bit space to 16 bit, as it contains flags
* which the application is liable to keep checking.
*
* The way this whole business works is that the wave/midi data stays in 16
* bit space, but the XXXXHDR is copied to the 32 bit side, with the
* address of the data thunked accordingly so that Robin's device driver
* can still get at the data but we don't have the performance penalty of
* copying it back and forth all the time, not least because it is liable
* to be rather large...
*
* It also handles the tidying up of memory which is reserved to store
* the XXXXHDR, and the instance data (HWND/Callback address; instance
* data; flags) which the xxxxOpen calls pass to this routine, enabling
* it to forward messages or call callback as required.
*
* This routine handles all the messages that get sent from Robin's
* driver, and in fact thunks them back to the correct 16 bit form.  In
* theory there should be no MM_ format messages from the 16 bit side, so
* I can zap 'em out of WMSG16.  However the 32 bit side should thunk the
* mesages correctly and forward them to the 16 bit side and thence to
* the app.
*
* For the MM_WIM_DATA and MM_WOM_DONE message dwParam1 points to the
* following data struture.
*
*    P32HDR  is a 32 bit pointer to the original 16 bit header
*    P16HDR  is a 16 bit far pointer to the original 16 bit header
*
*    If we need to refernece the original header we must do via the
*    P32HDR pointer.
*
*                   +---------+
*                   | P32HDR  +----->+---------+
*                   +---------+      | 16 bit  |
*                   | P16HDR  +----->|         |    This is the original
*    dwParam1 ----->+---------+      |  Wave   |    wave header passed to
*                   | 32 bit  |      | Header  |    us by the Win 16 app.
*    This is the 32 |         |      |         |
*    bit wave       |  Wave   |      +---------+
*    header that we | Header  |
*    thunked at     |         |
*    earlier.       +---------+
*
*
* We must ensure that the 32 bit structure is completely hidden from the
* 16 bit application, ie. the 16 bit app only see's the wave header that it
* passed to us earlier.
*
*
* NOTE: dwParam2 is junk
*
*
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
VOID
W32CommonDeviceCB(
    HANDLE handle,
    UINT uMsg,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    )
{
    PWAVEHDR32      pWavehdr32;
    PMIDIHDR32      pMidiThunkHdr;
    PINSTANCEDATA   pInstanceData;
    HANDLE16        Hand16;

    pInstanceData = (PINSTANCEDATA)dwInstance;
    WinAssert( pInstanceData );

    switch (uMsg) {

        /* ------------------------------------------------------------
        ** MIDI INPUT MESSAGES
        ** ------------------------------------------------------------
        */

    case MM_MIM_LONGDATA:
        /*
        ** This message is sent to a window when an input buffer has been
        ** filled with MIDI system-exclusive data and is being returned to
        ** the application.
        */

    case MM_MIM_LONGERROR:
        /*
        ** This message is sent to a window when an invalid MIDI
        ** system-exclusive message is received.
        */
        pMidiThunkHdr = CONTAINING_RECORD(dwParam1, MIDIHDR32, Midihdr);
        WinAssert( pMidiThunkHdr );
        COPY_MIDIINHDR16_FLAGS( pMidiThunkHdr->pMidihdr32, pMidiThunkHdr->Midihdr );
        dwParam1 = (DWORD)pMidiThunkHdr->pMidihdr16;


    case MM_MIM_DATA:
        /*
        ** This message is sent to a window when a MIDI message is
        ** received by a MIDI input device.
        */

    case MM_MIM_ERROR:
        /*
        ** This message is sent to a window when an invalid MIDI message
        ** is received.
        */

    case MM_MIM_OPEN:
        /*
        ** This message is sent to a window when a MIDI input device is opened.
        ** We process this message the same way as MM_MIM_CLOSE (see below)
        */

    case MM_MIM_CLOSE:
        /*
        ** This message is sent to a window when a MIDI input device is
        ** closed. The device handle is no longer valid once this message
        ** has been sent.
        */
        Hand16 = pInstanceData->Hand16;
        break;



        /* ------------------------------------------------------------
        ** MIDI OUTPUT MESSAGES
        ** ------------------------------------------------------------
        */

    case MM_MOM_DONE:
        /*
        ** This message is sent to a window when the specified
        ** system-exclusive buffer has been played and is being returned to
        ** the application.
        */
        pMidiThunkHdr = CONTAINING_RECORD(dwParam1, MIDIHDR32, Midihdr);
        WinAssert( pMidiThunkHdr );
        COPY_MIDIOUTHDR16_FLAGS( pMidiThunkHdr->pMidihdr32, pMidiThunkHdr->Midihdr );
        dwParam1 = (DWORD)pMidiThunkHdr->pMidihdr16;

    case MM_MOM_OPEN:
        /*
        ** This message is sent to a window when a MIDI output device is opened.
        ** We process this message the same way as MM_MOM_CLOSE (see below)
        */

    case MM_MOM_CLOSE:
        /*
        ** This message is sent to a window when a MIDI output device is
        ** closed. The device handle is no longer valid once this message
        ** has been sent.
        */
        Hand16 = pInstanceData->Hand16;
        break;



        /* ------------------------------------------------------------
        ** WAVE INPUT MESSAGES
        ** ------------------------------------------------------------
        */

    case MM_WIM_DATA:
        /*
        ** This message is sent to a window when waveform data is present
        ** in the input buffer and the buffer is being returned to the
        ** application.  The message can be sent either when the buffer
        ** is full, or after the waveInReset function is called.
        */
        pWavehdr32 = (PWAVEHDR32)( (PBYTE)dwParam1 - (sizeof(PWAVEHDR16) * 2));
        WinAssert( pWavehdr32 );
        COPY_WAVEINHDR16_FLAGS( pWavehdr32->pWavehdr32, pWavehdr32->Wavehdr );
        dwParam1 = (DWORD)pWavehdr32->pWavehdr16;

    case MM_WIM_OPEN:
        /*
        ** This message is sent to a window when a waveform input
        ** device is opened.
        **
        ** We process this message the same way as MM_WIM_CLOSE (see below)
        */

    case MM_WIM_CLOSE:
        /*
        ** This message is sent to a window when a waveform input device is
        ** closed.  The device handle is no longer valid once the message has
        ** been sent.
        */
        Hand16 = pInstanceData->Hand16;
        break;



        /* ------------------------------------------------------------
        ** WAVE OUTPUT MESSAGES
        ** ------------------------------------------------------------
        */

    case MM_WOM_DONE:
        /*
        ** This message is sent to a window when the specified output
        ** buffer is being returned to the application. Buffers are returned
        ** to the application when they have been played, or as the result of
        ** a call to waveOutReset.
        */
        pWavehdr32 = (PWAVEHDR32)( (PBYTE)dwParam1 - (sizeof(PWAVEHDR16) * 2));
        WinAssert( pWavehdr32 );
        COPY_WAVEOUTHDR16_FLAGS( pWavehdr32->pWavehdr32, pWavehdr32->Wavehdr );
        dwParam1 = (DWORD)pWavehdr32->pWavehdr16;

    case MM_WOM_OPEN:
        /*
        ** This message is sent to a window when a waveform output device
        ** is opened.
        **
        ** We process this message the same way as MM_WOM_CLOSE (see below)
        */

    case MM_WOM_CLOSE:
        /*
        ** This message is sent to a window when a waveform output device
        ** is closed.  The device handle is no longer valid once the
        ** message has been sent.
        */
        Hand16 = pInstanceData->Hand16;
        break;

#if DBG
    default:
        dprintf(( "Unknown message received in CallBack function " ));
        return;
#endif

    }


    /*
    ** Now make the CallBack, or PostMessage call depending
    ** on the flags passed to original (wave|midi)(In|Out)Open call.
    */
    pInstanceData = (PINSTANCEDATA)dwInstance;
    WinAssert( pInstanceData );

    switch (pInstanceData->dwFlags & CALLBACK_TYPEMASK)  {

    case CALLBACK_WINDOW:
        dprintf3(( "WINDOW callback identified" ));
        PostMessage( HWND32( LOWORD(pInstanceData->dwCallback) ),
                     uMsg, Hand16, dwParam1 );
        break;


    case CALLBACK_TASK:
    case CALLBACK_FUNCTION: {

        DWORD   dwFlags;

        if ( (pInstanceData->dwFlags & CALLBACK_TYPEMASK) == CALLBACK_TASK ) {
            dprintf3(( "TASK callback identified" ));
            dwFlags = DCB_TASK;
        }
        else {
            dprintf3(( "FUNCTION callback identified" ));
            dwFlags = DCB_FUNCTION;
        }

        WOW32DriverCallback( pInstanceData->dwCallback,
                             dwFlags,
                             Hand16,
                             LOWORD( uMsg ),
                             pInstanceData->dwCallbackInstance,
                             dwParam1,
                             dwParam2 );

        }
        break;
    }

    /*
    ** Now, free up any storage that was allocated during the waveOutOpen
    ** and waveInOpen.  This should only be freed during the MM_WOM_CLOSE or
    ** MM_WIM_CLOSE message.
    */
    switch (uMsg) {

    case MM_MIM_CLOSE:
    case MM_MOM_CLOSE:
    case MM_WIM_CLOSE:
    case MM_WOM_CLOSE:
        dprintf2(( "W32CommonDeviceOpen: Freeing device open buffer at %X",
                    pInstanceData ));
        dprintf2(( "Alloc Midi count = %d", AllocMidiCount ));
        dprintf2(( "Alloc Wave count = %d", AllocWaveCount ));
        winmmFree( pInstanceData );
        break;
    }
}


/******************************Public*Routine******************************\
* WOW32DriverCallback
*
* Callback stub, which invokes the "real" 16 bit callback.
* The parameters to this function must be in the format that the 16 bit
* code expects,  i.e. all handles must be 16 bit handles, all addresses must
* be 16:16 ones.
*
*
* It is possible that this function will have been called with the
* DCB_WINDOW set in which case the 16 bit interrupt handler will call
* PostMessage.  Howver, it is much more efficient if PostMessage is called
* from the 32 bit side.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL WOW32DriverCallback( DWORD dwCallback, DWORD dwFlags, WORD wID, WORD wMsg,
                          DWORD dwUser, DWORD dw1, DWORD dw2 )
{

    PCALLBACK_ARGS      pArgs;
    WORD                tempSendCount;


    /*
    ** If this is window callback post the message here and let WOW
    ** take care of it.
    */
    if ( (dwFlags & DCB_TYPEMASK) == DCB_WINDOW ) {
        return PostMessage( HWND32( LOWORD(dwCallback) ), wMsg, wID, dw1 );
    }

    /*
    ** Now we put the parameters into the global callback data array
    ** and increment the wSendCount field.  Then we simulate
    ** an interrupt to the 16 bit code.
    **
    ** If tempSendCount == wRecvCount then we have filled the callback buffer.
    ** We throw this interrupt away, but still simulate an interrupt to the
    ** 16 bit side in an attempt to get it procesing the interrupt still in
    ** the buffer.
    */
    EnterCriticalSection( &mmCriticalSection );

    tempSendCount = ((pCallBackData->wSendCount + 1) % CALLBACK_ARGS_SIZE);

    if (tempSendCount != pCallBackData->wRecvCount) {

        pArgs = &pCallBackData->args[ pCallBackData->wSendCount ];

        pArgs->dwFlags        = dwFlags;
        pArgs->dwFunctionAddr = dwCallback;
        pArgs->wHandle        = wID;
        pArgs->wMessage       = wMsg;
        pArgs->dwInstance     = dwUser;
        pArgs->dwParam1       = dw1;
        pArgs->dwParam2       = dw2;

        /*
        ** Increment the send count.  Use of the % operator above makes
        ** sure that we wrap around to the begining of the array correctly.
        */
        pCallBackData->wSendCount = tempSendCount;

    }

    dprintf4(( "Send count = %d, Receive count = %d",
               pCallBackData->wSendCount, pCallBackData->wRecvCount ));
    LeaveCriticalSection( &mmCriticalSection );


    /*
    ** Dispatch the interrupt to the 16 bit code.
    */
    dprintf4(( "Dispatching HW interrupt callback" ));

    if (!IsNEC_98) {
        GenerateInterrupt( MULTIMEDIA_ICA, MULTIMEDIA_LINE, 1 );
    } else {
        GenerateInterrupt( MULTIMEDIA_ICA, MULTIMEDIA_LINE_98, 1 );
    }

    /*
    ** Dummy return code, used to keep api consistent with Win31 and Win NT.
    */
    return TRUE;
}


/******************************Public*Routine******************************\
* aux32Message
*
* Thunk the aux apis.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD WINAPI
aux32Message(
    UINT uDeviceID,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    )
{
#if DBG
    static MSG_NAME name_map[] = {
        AUXDM_GETNUMDEVS,        "AUXDM_GETNUMDEVS",
        AUXDM_GETDEVCAPS,        "AUXDM_GETDEVCAPS",
        AUXDM_GETVOLUME,         "AUXDM_GETVOLUME",
        AUXDM_SETVOLUME,         "AUXDM_SETVOLUME",
    };
    int      i;
    int      n;
#endif

    static  DWORD               dwNumAuxDevs;
            DWORD               dwRet = MMSYSERR_NOTSUPPORTED;
            DWORD               dwTmp;
            DWORD UNALIGNED     *lpdwTmp;
            AUXCAPSA            aoCaps;

#if DBG
    for( i = 0, n = sizeof(name_map) / sizeof(name_map[0]); i < n; i++ ) {
        if ( name_map[i].uMsg == uMessage ) {
            break;
        }
    }
    if ( i != n ) {
        trace_aux(( "aux32Message( 0x%X, %s, 0x%X, 0x%X, 0x%X)",
                    uDeviceID, name_map[i].lpstrName, dwInstance,
                    dwParam1, dwParam2 ));
    }
    else {
        trace_aux(( "aux32Message( 0x%X, 0x%X, 0x%X, 0x%X, 0x%X)",
                     uDeviceID, uMessage, dwInstance,
                     dwParam1, dwParam2 ));
    }
#endif

    if ( LOWORD(uDeviceID) == 0xFFFF ) {
        uDeviceID = (UINT)-1;
    }

    dprintf2(( "aux32Message (0x%x)", uMessage ));
    switch ( uMessage ) {

    case AUXDM_GETNUMDEVS:
        dwRet = auxGetNumDevs();
        break;

    case AUXDM_GETDEVCAPS:
        dwRet = auxGetDevCapsA( uDeviceID, &aoCaps, sizeof(aoCaps) );
        if ( dwRet == MMSYSERR_NOERROR ) {
            CopyAuxCaps( (LPAUXCAPS16)GETVDMPTR( dwParam1 ),
                         &aoCaps, dwParam2 );
        }
        break;

    case AUXDM_GETVOLUME:
        dwRet = auxGetVolume( uDeviceID, &dwTmp );
        lpdwTmp = GETVDMPTR( dwParam1 );
        *lpdwTmp = dwTmp;
        break;

    case AUXDM_SETVOLUME:
        dwRet = auxSetVolume( uDeviceID, dwParam1 );
        break;

    default:
        if ( uMessage >= DRV_BUFFER_LOW && uMessage <= DRV_BUFFER_HIGH ) {
            lpdwTmp = GETVDMPTR( dwParam1 );
        }
        else {
            lpdwTmp = (LPDWORD)dwParam1;
        }
        dwRet = auxOutMessage( uDeviceID, uMessage,
                               (DWORD)lpdwTmp, dwParam2 );
    }

    trace_aux(( "-> 0x%X", dwRet ));

    return dwRet;
}


/*****************************Private*Routine******************************\
* CopyAuxCaps
*
* Copies 32 bit aux out caps info into the passed 16bit storage.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
void
CopyAuxCaps(
    LPAUXCAPS16 lpCaps16,
    LPAUXCAPSA lpCaps32,
    DWORD dwSize
    )
{
    AUXCAPS16 Caps16;

    Caps16.wMid = lpCaps32->wMid;
    Caps16.wPid = lpCaps32->wPid;

    Caps16.vDriverVersion = LOWORD( lpCaps32->vDriverVersion );
    CopyMemory( Caps16.szPname, lpCaps32->szPname, MAXPNAMELEN );
    Caps16.wTechnology = lpCaps32->wTechnology;
    Caps16.dwSupport = lpCaps32->dwSupport;

    CopyMemory( (LPVOID)lpCaps16, (LPVOID)&Caps16, (UINT)dwSize );
}

/******************************Public*Routine******************************\
* tid32Message
*
* Thunk the timer apis
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD WINAPI
tid32Message(
    UINT uDevId,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    )
{
#if DBG
    static MSG_NAME name_map[] = {
        TDD_SETTIMEREVENT,  "timeSetEvent",
        TDD_KILLTIMEREVENT, "timeKillEvent",
        TDD_GETSYSTEMTIME,  "timeGetTime",
        TDD_GETDEVCAPS,     "timeGetDevCaps",
        TDD_BEGINMINPERIOD, "timeBeginPeriod",
        TDD_ENDMINPERIOD,   "timeEndPeriod",
    };
    int      i;
    int      n;
#endif

    DWORD               dwRet = TIMERR_NOCANDO;
    LPTIMECAPS16        lp16TimeCaps;
    LPTIMEREVENT16      lp16TimeEvent;

#if DBG
    for( i = 0, n = sizeof(name_map) / sizeof(name_map[0]); i < n; i++ ) {
        if ( name_map[i].uMsg == uMessage ) {
            break;
        }
    }
    if ( i != n ) {
        trace_time(( "tid32Message( %s, 0x%X, 0x%X)",
                     name_map[i].lpstrName, dwParam1, dwParam2 ));
    }
    else {
        trace_time(( "tid32Message( 0x%X, 0x%X, 0x%X)",
                     uMessage,  dwParam1, dwParam2 ));
    }
#endif


    switch (uMessage) {

    case TDD_SETTIMEREVENT:

        lp16TimeEvent = (LPTIMEREVENT16)GETVDMPTR( dwParam1);

        trace_time(( "tid32Message: timeSetEvent(%#X, %#X, %#X, %#X)",
                     lp16TimeEvent->wDelay, lp16TimeEvent->wResolution,
                     lp16TimeEvent->lpFunction, lp16TimeEvent->wFlags ));

        /*
        **  The only difference for WOW is that WOW32DriverCallback is
        **  called for the callback rather than DriverCallback.  The
        **  last parameter to timeSetEventInternal makes this happen.
        */

        dwRet = timeSetEventInternal( max( lp16TimeEvent->wDelay,
                                           g_TimeCaps32.wPeriodMin ),
                                      lp16TimeEvent->wResolution,
                                      (LPTIMECALLBACK)lp16TimeEvent->lpFunction,
                                      (DWORD)lp16TimeEvent->dwUser,
                                      lp16TimeEvent->wFlags & TIME_PERIODIC,
                                      TRUE);

        dprintf4(( "timeSetEvent: 32 bit time ID %8X", dwRet ));
        break;

    case TDD_KILLTIMEREVENT:
        dwRet = timeKillEvent( dwParam1 );
        {
            /*
            ** Purge the callback queue of any messages were
            ** generated with this timer id.
            */

            int nIndex;

            EnterCriticalSection( &mmCriticalSection );

            for ( nIndex = 0; nIndex < CALLBACK_ARGS_SIZE; nIndex++ ) {

                if ( pCallBackData->args[ nIndex ].wHandle == LOWORD(dwParam1) &&
                     pCallBackData->args[ nIndex ].wMessage == 0 ) {

                    pCallBackData->args[ nIndex ].dwFunctionAddr = 0L;
                }
            }

            LeaveCriticalSection( &mmCriticalSection );
        }
        break;

    case TDD_GETSYSTEMTIME:
        dwRet = timeGetTime();
        break;

    case TDD_GETDEVCAPS:
        dwRet = 0;

        lp16TimeCaps = GETVDMPTR( dwParam1 );

        /*
        ** Under NT, the minimum time period is about 15ms.
        ** But Win3.1 on a 386 always returns 1ms.  Encarta doesn't even
        ** bother testing the CD-ROM's speed if the minimum period
        ** is > 2ms, it just assumes it is too slow.  So here we lie
        ** to WOW apps and always tell them 1ms just like Win3.1.
        **      John Vert (jvert) 17-Jun-1993
        */
#ifdef TELL_THE_TRUTH
        lp16TimeCaps->wPeriodMin = g_TimeCaps32.wPeriodMin;
#else
        lp16TimeCaps->wPeriodMin = MIN_TIME_PERIOD_WE_RETURN;
#endif

        /*
        ** In windows 3.1 the wPeriodMax value is 0xFFFF which is the
        ** max value you can store in a word.  In windows NT the
        ** wPeriodMax is 0xF4240 (1000 seconds).
        **
        ** If we just cast the 32 bit value down to a 16bit value we
        ** end up with 0x4240 which very small compared to real 32 bit
        ** value.
        **
        ** Therefore I will take the minimum of wPeriodMax and 0xFFFF
        ** that way will should remain consistent with Win 3.1 if
        ** wPeriodMax is greater than 0xFFFF.
        */
        lp16TimeCaps->wPeriodMax = (WORD)min(0xFFFF, g_TimeCaps32.wPeriodMax);
        break;

    case TDD_ENDMINPERIOD:
        dwParam1 = max(dwParam1, g_TimeCaps32.wPeriodMin);
        dwRet = timeEndPeriod( dwParam1 );
        break;

    case TDD_BEGINMINPERIOD:
        dwParam1 = max(dwParam1, g_TimeCaps32.wPeriodMin);
        dwRet = timeBeginPeriod( dwParam1 );
        break;

    }

    trace_time(( "-> 0x%X", dwRet ));

    return dwRet;
}


/******************************Public*Routine******************************\
* joy32Message
*
* Thunk the joystick apis
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD WINAPI
joy32Message(
    UINT uID,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    )
{
#if DBG
    static MSG_NAME name_map[] = {
        JDD_GETDEVCAPS,     "joyGetDevCaps",
        JDD_GETPOS,         "joyGetPos",
//        JDD_SETCALIBRATION, "joySetCalibration",
        JDD_GETNUMDEVS,     "joyGetNumDevs"
    };
    int      i;
    int      n;
#endif

    UINT                wXbase;
    UINT                wXdelta;
    UINT                wYbase;
    UINT                wYdelta;
    UINT                wZbase;
    UINT                wZdelta;

    WORD UNALIGNED      *lpw;

    DWORD               dwRet = TIMERR_NOCANDO;
    JOYCAPSA            JoyCaps32;
    JOYINFO             JoyInfo32;
    LPJOYCAPS16         lp16JoyCaps;
    LPJOYINFO16         lp16JoyInfo;

#if DBG
    for( i = 0, n = sizeof(name_map) / sizeof(name_map[0]); i < n; i++ ) {
        if ( name_map[i].uMsg == uMessage ) {
            break;
        }
    }
    if ( i != n ) {
        trace_joy(( "joy32Message( %s, 0x%X, 0x%X)",
                    name_map[i].lpstrName, dwParam1, dwParam2 ));
    }
    else {
        trace_joy(( "joy32Message( 0x%X, 0x%X, 0x%X)",
                    uMessage,  dwParam1, dwParam2 ));
    }
#endif


    switch (uMessage) {


    case JDD_GETDEVCAPS:
        dwRet = joyGetDevCapsA( uID, &JoyCaps32, sizeof(JoyCaps32) );

        if ( dwRet == 0 ) {

            JOYCAPS16   JoyCaps16;

            lp16JoyCaps = GETVDMPTR( dwParam1 );

            JoyCaps16.wMid = JoyCaps32.wMid;
            JoyCaps16.wPid = JoyCaps32.wPid;

            CopyMemory( JoyCaps16.szPname, JoyCaps32.szPname, MAXPNAMELEN );

            JoyCaps16.wXmin = LOWORD( JoyCaps32.wXmin );
            JoyCaps16.wXmax = LOWORD( JoyCaps32.wXmax );

            JoyCaps16.wYmin = LOWORD( JoyCaps32.wYmin );
            JoyCaps16.wYmax = LOWORD( JoyCaps32.wYmax );

            JoyCaps16.wZmin = LOWORD( JoyCaps32.wZmin );
            JoyCaps16.wZmax = LOWORD( JoyCaps32.wZmax );

            JoyCaps16.wNumButtons = LOWORD( JoyCaps32.wNumButtons );

            JoyCaps16.wPeriodMin = LOWORD( JoyCaps32.wPeriodMin );
            JoyCaps16.wPeriodMax = LOWORD( JoyCaps32.wPeriodMax );

            CopyMemory( (LPVOID)lp16JoyCaps, (LPVOID)&JoyCaps16, (UINT)dwParam2 );
        }
        break;

    case JDD_GETNUMDEVS:
        dwRet = joyGetNumDevs();
        break;

    case JDD_GETPOS:
        dwRet = joyGetPos( uID, &JoyInfo32 );
        if ( dwRet == MMSYSERR_NOERROR ) {

            lp16JoyInfo = GETVDMPTR( dwParam1 );

            lp16JoyInfo->wXpos = LOWORD( JoyInfo32.wXpos );
            lp16JoyInfo->wYpos = LOWORD( JoyInfo32.wYpos );
            lp16JoyInfo->wZpos = LOWORD( JoyInfo32.wZpos );
            lp16JoyInfo->wButtons = LOWORD( JoyInfo32.wButtons );

        }
        break;
    }

    trace_joy(( "-> 0x%X", dwRet ));

    return dwRet;
}


/******************************Public*Routine******************************\
* mxd32Message
*
* 32 bit thunk function.  On NT all the 16 bit mixer apis get routed to
* here.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD CALLBACK
mxd32Message(
    UINT uId,
    UINT uMsg,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    )
{

#if DBG
    static MSG_NAME name_map[] = {
        MXDM_INIT,              "mixerInit",
        MXDM_GETNUMDEVS,        "mixerGetNumDevs",
        MXDM_GETDEVCAPS,        "mixerGetDevCaps",
        MXDM_OPEN,              "mixerOpen",
        MXDM_GETLINEINFO,       "mixerGetLineInfo",
        MXDM_GETLINECONTROLS,   "mixerGetLineControls",
        MXDM_GETCONTROLDETAILS, "mixerGetControlsDetails",
        MXDM_SETCONTROLDETAILS, "mixerSetControlsDetails"
    };
    int      i;
    int      n;
#endif


    DWORD                   dwRet = MMSYSERR_NOTSUPPORTED;
    DWORD                   fdwOpen;
    LPVOID                  lpOldAddress;
    LPMIXERCONTROLDETAILS   pmxcd;
    LPMIXERLINECONTROLSA    pmxlc;
    MIXERCONTROLDETAILS     mxcdA;
    HMIXEROBJ               hmixobj;
    MIXERCAPSA              caps32;
    MIXERCAPS16             caps16;
    LPMIXERCAPS16           lpcaps16;
    MIXERLINEA              line32;
    LPMIXERLINE16           lpline16;
    LPMIXEROPENDESC16       lpmxod16;
    HMIXER UNALIGNED        *phmx;
    HMIXER                  hmx;


#if DBG
    for( i = 0, n = sizeof(name_map) / sizeof(name_map[0]); i < n; i++ ) {
        if ( name_map[i].uMsg == uMsg ) {
            break;
        }
    }
    if ( i != n ) {
        trace_mix(( "mxd32Message( %s, 0x%X, 0x%X, 0x%X)",
                    name_map[i].lpstrName, dwInstance, dwParam1, dwParam2 ));
    }
    else {
        trace_mix(( "mxd32Message( 0x%X, 0x%X, 0x%X, 0x%X)",
                    uMsg, dwInstance, dwParam1, dwParam2 ));
    }
#endif


    if ( dwInstance == 0L ) {
        hmixobj = (HMIXEROBJ)uId;
    }
    else {
        hmixobj = (HMIXEROBJ)dwInstance;
    }

    switch ( uMsg ) {

    case MXDM_INIT:
        dwRet = 0;
        break;

    case MXDM_GETNUMDEVS:
        dwRet = mixerGetNumDevs();
        break;

    case MXDM_CLOSE:
        dwRet = mixerClose( (HMIXER)dwInstance );
        break;

    case MXDM_GETDEVCAPS:
        dwRet = mixerGetDevCapsA( uId, &caps32, sizeof(caps32) );
        if ( dwRet == MMSYSERR_NOERROR ) {

            lpcaps16 = GETVDMPTR( dwParam1 );

            caps16.wMid = caps32.wMid;
            caps16.wPid = caps32.wPid;

            caps16.vDriverVersion = LOWORD( caps32.vDriverVersion );
            CopyMemory( caps16.szPname, caps32.szPname, MAXPNAMELEN );
            caps16.fdwSupport = caps32.fdwSupport;
            caps16.cDestinations = caps32.cDestinations;

            CopyMemory( (LPVOID)lpcaps16, (LPVOID)&caps16, (UINT)dwParam2 );

        }
        break;

    case MXDM_OPEN:
        lpmxod16 = GETVDMPTR( dwParam1 );

        /*
        ** fdwOpen has already mapped all device handles into device ID's on
        ** the 16 bit side.  Therefore mangle the flags to reflect this.
        */
        fdwOpen = (DWORD)lpmxod16->pReserved0;

        if ( ( fdwOpen & CALLBACK_TYPEMASK ) == CALLBACK_WINDOW ) {

            lpmxod16->dwCallback = (DWORD)HWND32(LOWORD(lpmxod16->dwCallback));

        }
        else if ( ( fdwOpen & CALLBACK_TYPEMASK ) == CALLBACK_TASK ) {

            lpmxod16->dwCallback = GetCurrentThreadId();
        }

        dwRet = mixerOpen( &hmx, dwParam2, lpmxod16->dwCallback,
                           lpmxod16->dwInstance, fdwOpen );

        if ( dwRet == MMSYSERR_NOERROR ) {
            SetWOWHandle( hmx, lpmxod16->hmx );

            phmx = GETVDMPTR( dwInstance );
            *phmx = hmx;
        }
        break;

    case MXDM_GETLINEINFO:
        lpline16 = GETVDMPTR( dwParam1 );

        GetLineInfo( lpline16, &line32 );

        dwRet = mixerGetLineInfoA( hmixobj, &line32, dwParam2 );
        if ( dwRet == MMSYSERR_NOERROR ) {

            PutLineInfo( lpline16, &line32 );
        }
        break;

    case MXDM_GETLINECONTROLS:
        pmxlc = (LPMIXERLINECONTROLSA)GETVDMPTR( dwParam1 );
        lpOldAddress = pmxlc->pamxctrl;
        pmxlc->pamxctrl = GETVDMPTR( lpOldAddress );

        dwRet = mixerGetLineControlsA(hmixobj, pmxlc, dwParam2);

        pmxlc->pamxctrl = lpOldAddress;
        break;

    /*
    **  CAREFUL !!!
    **
    **  The ONLY reason we don't copy the details themselves is because
    **  somewhere down the line (usually in the IO subsystem) they're
    **  copied anyway
    */

    case MXDM_GETCONTROLDETAILS:
        pmxcd = (LPMIXERCONTROLDETAILS)GETVDMPTR( dwParam1 );
        CopyMemory(&mxcdA, pmxcd, sizeof(mxcdA));
        mxcdA.paDetails = GETVDMPTR( pmxcd->paDetails );

        dwRet = mixerGetControlDetailsA(hmixobj, &mxcdA, dwParam2);

        break;

    case MXDM_SETCONTROLDETAILS:
        pmxcd = (LPMIXERCONTROLDETAILS)GETVDMPTR( dwParam1 );
        CopyMemory(&mxcdA, pmxcd, sizeof(mxcdA));
        mxcdA.paDetails = GETVDMPTR( pmxcd->paDetails );

        dwRet = mixerSetControlDetails( hmixobj, &mxcdA, dwParam2 );
        break;

    default:
        dprintf3(( "Unkown mixer message 0x%X", uMsg ));
        dwRet = mixerMessage( (HMIXER)hmixobj, uMsg, dwParam1, dwParam2 );
        break;

    }

    dprintf3(( "-> 0x%X", dwRet ));
    return dwRet;
}

/*****************************Private*Routine******************************\
* GetLineInfo
*
* Copies fields from the 16 bit line info structure to the 32 bit line info
* structure.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
void
GetLineInfo(
    LPMIXERLINE16 lpline16,
    LPMIXERLINEA lpline32
    )
{
    CopyMemory( lpline32, (LPVOID)lpline16, FIELD_OFFSET(MIXERLINEA, Target.vDriverVersion ) );
    lpline32->Target.vDriverVersion = (DWORD)lpline16->Target.vDriverVersion;
    CopyMemory( lpline32->Target.szPname, lpline16->Target.szPname, MAXPNAMELEN );
    lpline32->cbStruct += sizeof(UINT) - sizeof(WORD);
}


/*****************************Private*Routine******************************\
* PutLineInfo
*
* Copies fields from the 32 bit line info structure to the 16 bit line info
* structure.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
void
PutLineInfo(
    LPMIXERLINE16 lpline16,
    LPMIXERLINEA lpline32
    )
{
    CopyMemory( (LPVOID)lpline16, lpline32, FIELD_OFFSET(MIXERLINEA, Target.vDriverVersion ) );
    lpline16->Target.vDriverVersion = (WORD)lpline32->Target.vDriverVersion;
    CopyMemory( lpline16->Target.szPname, lpline32->Target.szPname, MAXPNAMELEN );
    lpline16->cbStruct -= sizeof(UINT) - sizeof(WORD);
}



/******************************Public*Routine******************************\
* WOW32ResolveMultiMediaHandle
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
BOOL APIENTRY
WOW32ResolveMultiMediaHandle(
    UINT uHandleType,
    UINT uMappingDirection,
    WORD wHandle16_In,
    LPWORD lpwHandle16_Out,
    DWORD dwHandle32_In,
    LPDWORD lpdwHandle32_Out
    )
{
    BOOL    fReturn = FALSE;
    DWORD   dwHandle32;
    WORD    wHandle16;
    HANDLE  h;

    /*
    ** Protect ourself from being given a duff pointer.
    */
    try {
        if ( uMappingDirection == WOW32_DIR_16IN_32OUT ) {

            dwHandle32 = 0L;

            if ( wHandle16_In != 0 ) {

                switch ( uHandleType ) {

                case WOW32_WAVEIN_HANDLE:
                case WOW32_WAVEOUT_HANDLE:
                case WOW32_MIDIOUT_HANDLE:
                case WOW32_MIDIIN_HANDLE:
                    EnterCriticalSection(&HandleListCritSec);
                    h = GetHandleFirst();

                    while ( h )  {

                        if ( GetWOWHandle(h) == wHandle16_In ) {
                            dwHandle32 = (DWORD)h;
                            break;
                        }
                        h = GetHandleNext(h);
                    }
                    LeaveCriticalSection(&HandleListCritSec);

                    break;
                }

                *lpdwHandle32_Out = dwHandle32;
                if ( dwHandle32 ) {
                    fReturn = TRUE;
                }
            }

        }
        else if ( uMappingDirection == WOW32_DIR_32IN_16OUT ) {

            switch ( uHandleType ) {

            case WOW32_WAVEIN_HANDLE:
            case WOW32_WAVEOUT_HANDLE:
            case WOW32_MIDIOUT_HANDLE:
            case WOW32_MIDIIN_HANDLE:
                wHandle16 = (WORD)GetWOWHandle(dwHandle32_In);
                break;
            }

            *lpwHandle16_Out = wHandle16;
            if ( wHandle16 ) {
                fReturn = TRUE;
            }
        }
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {

        fReturn = FALSE;
    }

    return fReturn;
}

#endif // _WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\mmioriff.c ===
/* Copyright (c) 1991-1995 Microsoft Corporation */
/* mmioriff.c
 *
 * MMIO RIFF functions.
 */

/* Revision history:
   LaurieGr: Jan 92 Ported from win16.  Source tree fork, not common code.
*/

#define VALIDATE_PARMS
#include "winmmi.h"
#include "mmioi.h"

static  BYTE bPad;

/* @doc EXTERNAL

@api    MMRESULT | mmioDescend | This function descends into a chunk of a
    RIFF file opened with <f mmioOpen>. It can also search for a given
    chunk.

@parm   HMMIO | hmmio | Specifies the file handle of an open RIFF file.

@parm   LPMMCKINFO | lpck | Specifies a pointer to a
    caller-supplied  <t MMCKINFO> structure that <f mmioDescend> fills
    with the following information:

    -- The <e MMCKINFO.ckid> field is the chunk ID of the chunk.

    -- The <e MMCKINFO.cksize> field is the size of the data portion
    of the chunk. The data size includes the form type or list type (if
    any), but does not include the 8-byte chunk header or the pad byte at
    the end of the data (if any).

    -- The <e MMCKINFO.fccType> field is the form type if
    <e MMCKINFO.ckid> is "RIFF", or the list type if
    <e MMCKINFO.ckid> is "LIST". Otherwise, it is NULL.

    -- The <e MMCKINFO.dwDataOffset> field is the file offset of the
    beginning of the data portion of the chunk. If the chunk is a
    "RIFF" chunk or a "LIST" chunk, then <e MMCKINFO.dwDataOffset>
    is the offset of the form type or list type.

    -- The <e MMCKINFO.dwFlags> contains other information about the chunk.
    Currently, this information is not used and is set to zero.

    If the MMIO_FINDCHUNK, MMIO_FINDRIFF, or MMIO_FINDLIST flag is
    specified for <p uFlags>, then the <t MMCKINFO> structure is also
    used to pass parameters to <f mmioDescend>:

    -- The <e MMCKINFO.ckid> field specifies the four-character code
    of the chunk ID, form type, or list type to search for.

@parm   LPMMCKINFO | lpckParent | Specifies a pointer to an
    optional caller-supplied <t MMCKINFO> structure identifying
    the parent of the chunk being searched for.
    A parent of a chunk is the enclosing chunk--only "RIFF" and "LIST"
    chunks can be parents.  If <p lpckParent> is not NULL, then
    <f mmioDescend> assumes the <t MMCKINFO> structure it refers to
    was filled when <f mmioDescend> was called to descend into the parent
    chunk, and <f mmioDescend> will only search for a chunk within the
    parent chunk. Set <p lpckParent> to NULL if no parent chunk is
    being specified.

@parm   UINT | uFlags | Specifies search options. Contains up to one
    of the following flags. If no flags are specified,
    <f mmioDescend> descends into the chunk beginning at the current file
    position.

    @flag   MMIO_FINDCHUNK | Searches for a chunk with the specified chunk ID.

    @flag   MMIO_FINDRIFF | Searches for a chunk with chunk ID "RIFF"
        and with the specified form type.

    @flag   MMIO_FINDLIST | Searches for a chunk with chunk ID "LIST"
        and with the specified form type.

@rdesc  The return value is zero if the function is successful.
    Otherwise, the return value specifies an error code. If the end of
    the file (or the end of the parent chunk, if given) is reached before
    the desired chunk is found, the return value is
    MMIOERR_CHUNKNOTFOUND.
    Other error return values are possible, for instance MMIOERR_CANNOTSEEK.

@comm   A RIFF chunk consists of a four-byte chunk ID (type FOURCC),
    followed by a four-byte chunk size (type DWORD), followed
    by the data portion of the chunk, followed by a null pad byte if
    the size of the data portion is odd. If the chunk ID is "RIFF" or
    "LIST", the first four bytes of the data portion of the chunk are
    a form type or list type (type FOURCC).

    If <f mmioDescend> is used to search for a chunk, the file
    position should be at the beginning of a
    chunk before calling <f mmioDescend>. The search begins at the
    current file position and continues to the end of the file. If a
    parent chunk is specified, the file position should be somewhere
    within the parent chunk before calling <f mmioDescend>. In this case,
    the search begins at the current file position and continues to the
    end of the parent chunk.

    If <f mmioDescend> is unsuccessful in searching for a chunk, the
    current file position is undefined. If <f mmioDescend> is
    successful, the current file position is changed. If the chunk
    is a "RIFF" or "LIST" chunk, the new file position
    will be just after the form type or list type (12 bytes from the
    beginning of the chunk). For other chunks, the new file position will be
    the start of the data portion of the chunk (8 bytes from the
    beginning of the chunk).

    For efficient RIFF file I/O, use buffered I/O.

    @xref   mmioAscend MMCKINFO
*/
MMRESULT APIENTRY
   mmioDescend(HMMIO hmmio, LPMMCKINFO lpck, LPCMMCKINFO lpckParent, UINT uFlags)
{
    FOURCC      ckidFind;   // chunk ID to find (or NULL)
    FOURCC      fccTypeFind;    // form/list type to find (or NULL)

#ifdef VALIDATE_PARMS
    V_FLAGS(uFlags, MMIO_DESCEND_VALID, mmioDescend, MMSYSERR_INVALFLAG);
    V_WPOINTER(lpck, sizeof(MMCKINFO), MMSYSERR_INVALPARAM);
    V_RPOINTER0(lpckParent, sizeof(MMCKINFO), MMSYSERR_INVALPARAM);
#endif
    /* figure out what chunk id and form/list type to search for */
    if (uFlags & MMIO_FINDCHUNK)
        ckidFind = lpck->ckid, fccTypeFind = 0;
    else
    if (uFlags & MMIO_FINDRIFF)
        ckidFind = FOURCC_RIFF, fccTypeFind = lpck->fccType;
    else
    if (uFlags & MMIO_FINDLIST)
        ckidFind = FOURCC_LIST, fccTypeFind = lpck->fccType;
    else
        ckidFind = fccTypeFind = 0;

    lpck->dwFlags = 0L;

    if (hmmio == NULL) return MMIOERR_OUTOFMEMORY;

    for(;;)
    {
        MMRESULT  mmr;

        /* read the chunk header */
        if (mmioRead(hmmio, (LPSTR) lpck, 2 * sizeof(DWORD)) !=
            2 * sizeof(DWORD))
            return MMIOERR_CHUNKNOTFOUND;

        /* store the offset of the data part of the chunk */
        if ((lpck->dwDataOffset = mmioSeek(hmmio, 0L, SEEK_CUR)) == -1)
            return MMIOERR_CANNOTSEEK;

        /* see if the chunk is within the parent chunk (if given) */
        if ((lpckParent != NULL) &&
            (lpck->dwDataOffset - 8L >=
             lpckParent->dwDataOffset + lpckParent->cksize))
            return MMIOERR_CHUNKNOTFOUND;

        /* if the chunk if a 'RIFF' or 'LIST' chunk, read the
         * form type or list type
         */
        if ((lpck->ckid == FOURCC_RIFF) || (lpck->ckid == FOURCC_LIST))
        {
            if (!hmmio)
                return MMIOERR_CHUNKNOTFOUND;

            if (mmioRead(hmmio, (LPSTR) &lpck->fccType,
                     sizeof(DWORD)) != sizeof(DWORD))
                return MMIOERR_CHUNKNOTFOUND;
        }
        else
            lpck->fccType = 0;

        /* if this is the chunk we're looking for, stop looking */
        if ( ((ckidFind == 0) || (ckidFind == lpck->ckid)) &&
             ((fccTypeFind == 0) || (fccTypeFind == lpck->fccType)) )
            break;

        /* ascend out of the chunk and try again */
        if ((mmr = mmioAscend(hmmio, lpck, 0)) != 0)
            return mmr;
    }

    return 0;
}


/* @doc EXTERNAL MMIO_RIFF

@api    MMRESULT | mmioAscend | This function ascends out of a chunk in a
    RIFF file descended into with <f mmioDescend> or created with
    <f mmioCreateChunk>.

@parm   HMMIO | hmmio | Specifies the file handle of an open RIFF file.

@parm   LPMMCKINFO | lpck | Specifies a pointer to a
    caller-supplied <t MMCKINFO> structure previously filled by
    <f mmioDescend> or <f mmioCreateChunk>.

@parm   UINT | uFlags | Is not used and should be set to zero.

@rdesc  The return value is zero if the function is successful.
    Otherwise, the return value specifies an error code. The error
    code can be one of the following codes:

    @flag MMIOERR_CANNOTWRITE | The contents of the buffer could
    not be written to disk.

    @flag MMIOERR_CANNOTSEEK | There was an error while seeking to
    the end of the chunk.

@comm   If the chunk was descended into using <f mmioDescend>, then
    <f mmioAscend> seeks to the location following the end of the
    chunk (past the extra pad byte, if any).

    If the chunk was created and descended into using
    <f mmioCreateChunk>, or if the MMIO_DIRTY flag is set in the
    <e MMCKINFO.dwFlags> field of the <t MMCKINFO> structure
    referenced by <p lpck>, then the current file position
    is assumed to be the end of the data portion of the chunk.
    If the chunk size is not the same as the value stored
    in the <e MMCKINFO.cksize> field when <f mmioCreateChunk>
    was called, then <f mmioAscend> corrects the chunk
    size in the file before ascending from the chunk. If the chunk
    size is odd, <f mmioAscend> writes a null pad byte at the end of the
    chunk. After ascending from the chunk, the current file position is
    the location following the end of the chunk (past the extra pad byte,
    if any).

@xref   mmioDescend mmioCreateChunk MMCKINFO
*/
MMRESULT APIENTRY
mmioAscend(HMMIO hmmio, LPMMCKINFO lpck, UINT uFlags)
{
    LONG lSeekPos;
#ifdef VALIDATE_PARMS
    V_FLAGS(uFlags, 0, mmioAscend, MMSYSERR_INVALFLAG);
    V_WPOINTER(lpck, sizeof(MMCKINFO), MMSYSERR_INVALPARAM);
#endif

    if (lpck->dwFlags & MMIO_DIRTY)
    {
        /* <lpck> refers to a chunk created by mmioCreateChunk();
         * check that the chunk size that was written when
         * mmioCreateChunk() was called is the real chunk size;
         * if not, fix it
         */
        LONG        lOffset;    // current offset in file
        LONG        lActualSize;    // actual size of chunk data

        if (hmmio == NULL) return MMIOERR_OUTOFMEMORY;

        if ((lOffset = mmioSeek(hmmio, 0L, SEEK_CUR)) == -1)
            return MMIOERR_CANNOTSEEK;
        if ((lActualSize = lOffset - lpck->dwDataOffset) < 0)
            return MMIOERR_CANNOTWRITE;

        if (LOWORD(lActualSize) & 1)
        {    
            if (hmmio == NULL) 
                return MMIOERR_CANNOTWRITE;

            /* chunk size is odd -- write a null pad byte */
            if (mmioWrite(hmmio, (LPSTR) &bPad, sizeof(bPad))
                    != sizeof(bPad))
                return MMIOERR_CANNOTWRITE;

        }

        if (lpck->cksize == (DWORD)lActualSize)
            return 0;

        /* fix the chunk header */
        lpck->cksize = lActualSize;
        if (mmioSeek(hmmio, lpck->dwDataOffset
                - sizeof(DWORD), SEEK_SET) == -1)
            return MMIOERR_CANNOTSEEK;
        if (mmioWrite(hmmio, (LPSTR) &lpck->cksize,
                sizeof(DWORD)) != sizeof(DWORD))
            return MMIOERR_CANNOTWRITE;
    }

    // make sure that when we seek, we will be ADVANCING.  otherwise
    // we could get stuck in a loop trying to descend/ascend and never
    // going forward through the file
    //
    lSeekPos = lpck->dwDataOffset + lpck->cksize + (lpck->cksize & 1);
    if ((LONG)lpck->dwDataOffset < 0 || lSeekPos < (LONG)lpck->dwDataOffset)
        return MMIOERR_INVALIDFILE;

    /* seek to the end of the chunk, past the null pad byte
     * (which is only there if chunk size is odd)
     */
    if (mmioSeek(hmmio, lSeekPos, SEEK_SET) == -1)
        return MMIOERR_CANNOTSEEK;

    return 0;
}


/* @doc EXTERNAL MMIO_RIFF

@api    MMRESULT | mmioCreateChunk | This function creates a chunk in a
    RIFF file opened with <f mmioOpen>. The new chunk is created at the
    current file position. After the new chunk is created, the current
    file position is the beginning of the data portion of the new chunk.

@parm   HMMIO | hmmio | Specifies the file handle of an open RIFF
    file.

@parm   LPMMCKINFO | lpck | Specifies a pointer to a caller-supplied
    <t MMCKINFO> structure containing information about the chunk to be
    created. The <t MMCKINFO> structure should be set up as follows:

    -- The <e MMCKINFO.ckid> field specifies the chunk ID of the
    chunk. If <p uFlags> includes MMIO_CREATERIFF or MMIO_CREATELIST,
    this field will be filled by <f mmioCreateChunk>.

    -- The <e MMCKINFO.cksize> field specifies the size of the data
    portion of the chunk, including the form type or list type (if any).
    If this value is not correct when <f mmioAscend> is called to mark
    the end of the chunk, them <f mmioAscend> will correct the chunk
    size.

    -- The <e MMCKINFO.fccType> field specifies the form type or list
    type if the chunk is a "RIFF" or "LIST" chunk. If the chunk is not a
    "RIFF" or "LIST" chunk, this field need not be filled in.

    -- The <e MMCKINFO.dwDataOffset> field need not be filled in. The
    <f mmioCreateChunk> function will fill this field with the file
    offset of the data portion of the chunk.

    -- The <e MMCKINFO.dwFlags> field need not be filled in. The
    <f mmioCreateChunk> function will set the MMIO_DIRTY flag in
    <e MMCKINFO.dwFlags>.

@parm   UINT | uFlags | Specifies flags to optionally create either a
    "RIFF" chunk or a "LIST" chunk. Can contain one of the following
    flags:

    @flag   MMIO_CREATERIFF | Creates a "RIFF" chunk.

    @flag   MMIO_CREATELIST | Creates a "LIST" chunk.

@rdesc  The return value is zero if the function is successful.
    Otherwise, the return value specifies an error code. The error
    code can be one of the following codes:

    @flag MMIOERR_CANNOTWRITE | Unable to write the chunk header.

    @flag MMIOERR_CANNOTSEEK | Uanble to determine offset of data
    portion of the chunk.

@comm   This function cannot insert a chunk into the middle of a
    file. If a chunk is created anywhere but the end of a file,
    <f mmioCreateChunk> will overwrite existing information in the file.
*/
MMRESULT APIENTRY
mmioCreateChunk(HMMIO hmmio, LPMMCKINFO lpck, UINT uFlags)
{
    int     iBytes;         // bytes to write
    LONG        lOffset;    // current offset in file

#ifdef VALIDATE_PARMS
    V_FLAGS(uFlags, MMIO_CREATE_VALID, mmioCreateChunk, MMSYSERR_INVALFLAG);
    V_WPOINTER(lpck, sizeof(MMCKINFO), MMSYSERR_INVALPARAM);
#endif

    /* store the offset of the data part of the chunk */
    if ((lOffset = mmioSeek(hmmio, 0L, SEEK_CUR)) == -1)
        return MMIOERR_CANNOTSEEK;
    lpck->dwDataOffset = lOffset + 2 * sizeof(DWORD);

    /* figure out if a form/list type needs to be written */
    if (uFlags & MMIO_CREATERIFF)
        lpck->ckid = FOURCC_RIFF, iBytes = 3 * sizeof(DWORD);
    else
    if (uFlags & MMIO_CREATELIST)
        lpck->ckid = FOURCC_LIST, iBytes = 3 * sizeof(DWORD);
    else
        iBytes = 2 * sizeof(DWORD);

    if (hmmio == NULL) return MMIOERR_CANNOTWRITE;

    /* write the chunk header */
    if (mmioWrite(hmmio, (LPSTR) lpck, (LONG) iBytes) != (LONG) iBytes)
        return MMIOERR_CANNOTWRITE;

    lpck->dwFlags = MMIO_DIRTY;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\mmwow32.h ===
/******************************Module*Header*******************************\
* Module Name: mmwow32.h
*
* This file types, function declarations and macro for the 32 bit MM thunks
*
* Created:  1-Jul-1993
* Author: Stephen Estrop [StephenE]
*
* Copyright (c) 1993-1996 Microsoft Corporation
\**************************************************************************/
#include <wownt32.h>

#ifdef _INC_ALL_WOWSTUFF

/****************************************************************************\
**
** 16 bit structures
**
\****************************************************************************/
#pragma pack(1)
typedef WORD    HANDLE16;
typedef WORD    MMVER16;      // major (high byte), minor (low byte)

// waveform input and output device open information structure
typedef struct waveopendesc16_tag {
    HANDLE16       hWave;             // handle (16 bit)
    LPWAVEFORMAT   lpFormat;          // format of wave data (16:16 ptr)
    DWORD          dwCallback;        // callback
    DWORD          dwInstance;        // app's private instance information
} WAVEOPENDESC16;
typedef WAVEOPENDESC16 UNALIGNED *LPWAVEOPENDESC16;


typedef struct _WAVEHDR16 {           /* whd16 */
    LPSTR   lpData;
    DWORD   dwBufferLength;
    DWORD   dwBytesRecorded;
    DWORD   dwUser;
    DWORD   dwFlags;
    DWORD   dwLoops;
    struct _WAVEHDR16 far *lpNext;
    DWORD   reserved;
} WAVEHDR16;
typedef WAVEHDR16 UNALIGNED *PWAVEHDR16;

typedef struct _WAVEOCUTCAPS16 {
    WORD    wMid;
    WORD    wPid;
    MMVER16 vDriverVersion;
    char    szPname[MAXPNAMELEN];
    DWORD   dwFormats;
    WORD    wChannels;
    DWORD   dwSupport;
} WAVEOUTCAPS16;
typedef WAVEOUTCAPS16 UNALIGNED *LPWAVEOUTCAPS16;

typedef struct _WAVEINCAPS16 {            /* wic16 */
    WORD    wMid;
    WORD    wPid;
    MMVER16 vDriverVersion;
    char    szPname[MAXPNAMELEN];
    DWORD   dwFormats;
    WORD    wChannels;
} WAVEINCAPS16;
typedef WAVEINCAPS16 UNALIGNED *LPWAVEINCAPS16;


typedef struct midiopendesc16_tag {
    HANDLE16       hMidi;             /* handle */
    DWORD          dwCallback;        /* callback */
    DWORD          dwInstance;        /* app's private instance information */
} MIDIOPENDESC16;
typedef MIDIOPENDESC16 UNALIGNED *LPMIDIOPENDESC16;

typedef struct _MIDIHDR16 {               /* mhdr16 */
    LPSTR   lpData;
    DWORD   dwBufferLength;
    DWORD   dwBytesRecorded;
    DWORD   dwUser;
    DWORD   dwFlags;
    struct  _MIDIHDR16 far *lpNext;
    DWORD   reserved;
} MIDIHDR16;
typedef MIDIHDR16 UNALIGNED *PMIDIHDR16;

typedef struct _MIDIOUTCAPS16 {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    MMVER16 vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    WORD    wTechnology;           /* type of device */
    WORD    wVoices;               /* # of voices (internal synth only) */
    WORD    wNotes;                /* max # of notes (internal synth only) */
    WORD    wChannelMask;          /* channels used (internal synth only) */
    DWORD   dwSupport;             /* functionality supported by driver */
} MIDIOUTCAPS16;
typedef MIDIOUTCAPS16 UNALIGNED *LPMIDIOUTCAPS16;

typedef struct _MIDINCAPS16 {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    MMVER16 vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
} MIDIINCAPS16;
typedef MIDIINCAPS16 UNALIGNED *LPMIDIINCAPS16;


typedef struct _MMTIME16 {                /* mmt16 */
    WORD    wType;
    union {
        DWORD   ms;
        DWORD   sample;
        DWORD   cb;
        struct {
            BYTE    hour;
            BYTE    min;
            BYTE    sec;
            BYTE    frame;
            BYTE    fps;
            BYTE    dummy;
        } smpte;
        struct {
            DWORD   songptrpos;
        } midi;
    } u;
} MMTIME16;
typedef MMTIME16 UNALIGNED *LPMMTIME16;

typedef struct timerevent16_tag {
    WORD                wDelay;         /* delay required */
    WORD                wResolution;    /* resolution required */
    LPTIMECALLBACK      lpFunction;     /* ptr to callback function */
    DWORD               dwUser;         /* user DWORD */
    WORD                wFlags;         /* defines how to program event */
} TIMEREVENT16;
typedef TIMEREVENT16 UNALIGNED *LPTIMEREVENT16;

typedef struct timecaps16_tag {
    WORD    wPeriodMin;     /* minimum period supported  */
    WORD    wPeriodMax;     /* maximum period supported  */
} TIMECAPS16;
typedef TIMECAPS16 UNALIGNED *LPTIMECAPS16;


typedef struct _AUXCAPS16 {
    WORD    wMid;
    WORD    wPid;
    MMVER16 vDriverVersion;
    char    szPname[MAXPNAMELEN];
    WORD    wTechnology;
    DWORD   dwSupport;
} AUXCAPS16;
typedef AUXCAPS16 UNALIGNED *LPAUXCAPS16;

typedef struct _JOYCAPS16 {
    WORD    wMid;
    WORD    wPid;
    MMVER16 vDriverVersion;
    char    szPname[MAXPNAMELEN];
    WORD    wXmin;
    WORD    wXmax;
    WORD    wYmin;
    WORD    wYmax;
    WORD    wZmin;
    WORD    wZmax;
    WORD    wNumButtons;
    WORD    wPeriodMin;
    WORD    wPeriodMax;
} JOYCAPS16;
typedef JOYCAPS16 UNALIGNED *LPJOYCAPS16;


typedef struct _JOYINFO16 {
    WORD    wXpos;
    WORD    wYpos;
    WORD    wZpos;
    WORD    wButtons;
} JOYINFO16;
typedef JOYINFO16 UNALIGNED *LPJOYINFO16;

#pragma pack()



/****************************************************************************\
**
** 32 bit structures
**
\****************************************************************************/
typedef struct _INSTANCEDATA {
    DWORD     dwCallback;          //Callback function or window handle
    DWORD     dwCallbackInstance;  //Instance data for callback function (only)
    DWORD     dwFlags;             //Flags
    HANDLE16  Hand16;
} INSTANCEDATA, *PINSTANCEDATA;

typedef struct _WAVEHDR32 {
    PWAVEHDR16 pWavehdr32;         //32 bit address to 16 bit WAVEHDR
    PWAVEHDR16 pWavehdr16;         //16 bit address to 16 bit WAVEHDR
    WAVEHDR    Wavehdr;            //32 bit address to 32 bit WAVEHDR
} WAVEHDR32, *PWAVEHDR32;


typedef struct _MIDIHDR32 {
    DWORD      reserved;           //Saved value of reserved.
    PMIDIHDR16 pMidihdr32;         //32 bit address to 16 bit MIDIHDR
    PMIDIHDR16 pMidihdr16;         //16 bit address to 16 bit MIDIHDR
    MIDIHDR    Midihdr;            //32 bit address to 32 bit MIDIHDR
} MIDIHDR32, *PMIDIHDR32;



/****************************************************************************\
** Function prototypes
**
**
\****************************************************************************/

BOOL
WINAPI LibMain(
    HINSTANCE hInst,
    DWORD dwReason,
    LPVOID lpReserved
    );

DWORD
WINAPI wod32Message(
    UINT uDeviceID,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    );

DWORD
WINAPI wid32Message(
    UINT uDeviceID,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    );

DWORD
WINAPI mod32Message(
    UINT uDeviceID,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    );

DWORD
WINAPI mid32Message(
    UINT uDeviceID,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    );

DWORD
WINAPI aux32Message(
    UINT uDeviceID,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    );

void
CopyAuxCaps(
    LPAUXCAPS16 lpCaps16,
    LPAUXCAPS lpCaps32,
    DWORD dwSize
    );

DWORD WINAPI
tid32Message(
    UINT uDevId,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    );

VOID
W32CommonDeviceCB(
    HANDLE handle,
    UINT uMsg,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    );

PWAVEHDR16
GetWaveHdr16(
    DWORD vpwhdr,
    LPWAVEHDR lpwhdr
    );

void
PutWaveHdr16(
    WAVEHDR16 UNALIGNED *pwhdr16,
    LPWAVEHDR lpwhdr
    );

BOOL
WOW32DriverCallback(
    DWORD dwCallback,
    DWORD dwFlags,
    WORD wID,
    WORD wMsg,
    DWORD dwUser,
    DWORD dw1,
    DWORD dw2
    );

void
CopyWaveOutCaps(
    LPWAVEOUTCAPS16 lpCaps16,
    LPWAVEOUTCAPS   lpCaps32,
    DWORD dwSize
    );

void
CopyWaveInCaps(
    LPWAVEINCAPS16 lpCaps16,
    LPWAVEINCAPS lpCaps32,
    DWORD dwSize
    );

void
CopyMidiOutCaps(
    LPMIDIOUTCAPS16 lpCaps16,
    LPMIDIOUTCAPS lpCaps32,
    DWORD dwSize
    );

void
CopyMidiInCaps(
    LPMIDIINCAPS16 lpCaps16,
    LPMIDIINCAPS lpCaps32,
    DWORD dwSize
    );

void
GetMMTime(
    LPMMTIME16 lpTime16,
    LPMMTIME lpTime32
    );

void
PutMMTime(
    LPMMTIME16 lpTime16,
    LPMMTIME lpTime32
    );


#define WAVE_OUT_DEVICE 1
#define WAVE_IN_DEVICE  0
DWORD
ThunkCommonWaveOpen(
    int iWhich,
    UINT uDeviceID,
    DWORD dwParam1,
    DWORD dwParam2,
    DWORD dwUSer
    );

DWORD
ThunkCommonWaveReadWrite(
    int iWhich,
    DWORD dwParam1,
    DWORD dwParam2,
    DWORD dwInstance
    );

DWORD
ThunkCommonWavePrepareHeader(
    HWAVE hWave,
    DWORD dwParam1,
    int iWhich
    );

DWORD
ThunkCommonWaveUnprepareHeader(
    HWAVE hWave,
    DWORD dwParam1,
    int iWhich
    );

#define MIDI_OUT_DEVICE 1
#define MIDI_IN_DEVICE  0
DWORD
ThunkCommonMidiOpen(
    int iWhich,
    UINT uDeviceID,
    DWORD dwParam1,
    DWORD dwParam2,
    DWORD dwInstance
    );

DWORD
ThunkCommonMidiReadWrite(
    int iWhich,
    DWORD dwParam1,
    DWORD dwParam2,
    DWORD dwInstance
    );

DWORD
ThunkCommonMidiPrepareHeader(
    HMIDI hWave,
    DWORD dwParam1,
    int iWhich
    );

DWORD
ThunkCommonMidiUnprepareHeader(
    HMIDI hWave,
    DWORD dwParam1,
    int iWhich
    );

PMIDIHDR16
GetMidiHdr16(
    DWORD vpmhdr,
    LPMIDIHDR lpmhdr
    );

void
PutMidiHdr16(
    MIDIHDR UNALIGNED *pmhdr16,
    LPMIDIHDR lpmhdr
    );

DWORD WINAPI
joy32Message(
    UINT uID,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    );


/* -------------------------------------------------------------------------
** MCI Stuff
** -------------------------------------------------------------------------
*/
#define THUNK_MCI_SENDCOMMAND                0x0001
#define THUNK_MCI_SENDSTRING                 0x0002
#define THUNK_MCI_GETDEVICEID                0x0003
#define THUNK_MCI_GETDEVIDFROMELEMID         0x0004
#define THUNK_MCI_GETERRORSTRING             0x0005
#define THUNK_MCI_EXECUTE                    0x0006
#define THUNK_MCI_SETYIELDPROC               0x0007
#define THUNK_MCI_GETYIELDPROC               0x0008
#define THUNK_MCI_GETCREATORTASK             0x0009
#define THUNK_TIMEGETTIME                    0x000A
#define THUNK_APP_EXIT                       0x000B
#define THUNK_MCI_ALLOCATE_NODE              0x000C
#define THUNK_MCI_FREE_NODE                  0x000D

DWORD WINAPI
mci32Message(
    DWORD dwApi,
    DWORD dwF1,
    DWORD dwF2,
    DWORD dwF3,
    DWORD dwF4
    );

DWORD
WMM32mciSendCommand(
    DWORD dwF1,
    DWORD dwF2,
    DWORD dwF3,
    DWORD dwF4
    );

DWORD
WMM32mciSendString(
    DWORD dwF1,
    DWORD dwF2,
    DWORD dwF3,
    DWORD dwF4
    );

DWORD
WMM32mciGetDeviceID(
    DWORD dwF1
    );

DWORD
WMM32mciGetErrorString(
    DWORD dwF1,
    DWORD dwF2,
    DWORD dwF3
    );

DWORD
WMM32mciExecute(
    DWORD dwF1
    );

DWORD
WMM32mciGetDeviceIDFromElementID(
    DWORD dwF1,
    DWORD dwF2
    );

DWORD
WMM32mciGetCreatorTask(
    DWORD dwF1
    );

DWORD
WMM32mciSetYieldProc(
    DWORD dwF1,
    DWORD dwF2,
    DWORD dwF3
    );

UINT
WMM32mciYieldProc(
    MCIDEVICEID wDeviceID,
    DWORD dwYieldData
    );

DWORD
WMM32mciGetYieldProc(
    DWORD dwF1,
    DWORD dwF2
    );

DWORD
WMM32mciAllocateNode(
    DWORD dwF1,            // dwOpenFlags
    DWORD dwF2             // lpszDeviceName
    );

DWORD
WMM32mciFreeNode(
    DWORD dwF2
    );

#endif


#if defined (_INC_WOW_CONVERSIONS) || defined (_INC_ALL_WOWSTUFF)
/****************************************************************************\
** Other stuff
**
**
\****************************************************************************/
typedef VOID    (APIENTRY *LPCALL_ICA_HW_INTERRUPT)( int, BYTE line, int count );
typedef LPVOID  (APIENTRY *LPGETVDMPOINTER)( DWORD Address, DWORD dwBytes, BOOL fProtectMode );
typedef HANDLE  (APIENTRY *LPWOWHANDLE32)(WORD, WOW_HANDLE_TYPE);
typedef WORD    (APIENTRY *LPWOWHANDLE16)(HANDLE, WOW_HANDLE_TYPE);

#define GETVDMPTR( p ) (LPVOID)((*GetVDMPointer)( (DWORD)(p), 0L, TRUE ))

extern LPCALL_ICA_HW_INTERRUPT GenerateInterrupt;
extern LPGETVDMPOINTER         GetVDMPointer;
extern LPWOWHANDLE32           lpWOWHandle32;
extern LPWOWHANDLE16           lpWOWHandle16;

/* -------------------------------------------------------------------------
** Conversions
** -------------------------------------------------------------------------
*/
typedef HANDLE  HAND32;
typedef WORD    HAND16;
typedef WORD    HWND16;
typedef WORD    HDC16;
typedef WORD    HTASK16;
typedef short   INT16;
typedef WORD    HPAL16;

#define GETHTASK16(h32)            ((HAND16)(INT)(h32))

#define HWND32(h16)                ((HWND)(*lpWOWHandle32)( h16, WOW_TYPE_HWND ))
#define GETHWND16(h32)             ((*lpWOWHandle16)( h32, WOW_TYPE_HWND ))

#define HDC32(hdc16)               ((HDC)(*lpWOWHandle32)( hdc16, WOW_TYPE_HDC ))
#define GETHDC16(hdc32)            ((*lpWOWHandle16)( hdc32, WOW_TYPE_HDC ))

#define HPALETTE32(hobj16)         ((HPALETTE)(*lpWOWHandle32)( hobj16, WOW_TYPE_HPALETTE ))
#define GETHPALETTE16(hobj32)      ((*lpWOWHandle16)( hobj32, WOW_TYPE_HPALETTE ))
#endif



#ifdef _INC_ALL_WOWSTUFF
/* -------------------------------------------------------------------------
** Messages
** -------------------------------------------------------------------------
*/
#ifndef DRVM_INIT
#define DRVM_INIT             100
#define WODM_INIT             DRVM_INIT
#define WIDM_INIT             DRVM_INIT
#define MODM_INIT             DRVM_INIT
#define MIDM_INIT             DRVM_INIT
#define AUXDM_INIT            DRVM_INIT
#endif

#ifndef MAX_TIMER_EVENTS
#define MAX_TIMER_EVENTS 16
#endif

#ifndef TDD_APPEXIT
#define TDD_APPEXIT    DRV_RESERVED+24
#endif

/**********************************************************************\
*
*   The following macros are used to set or clear the done bit in a
*   16 bit wave|midi header structure.
*
\**********************************************************************/
#define COPY_WAVEOUTHDR16_FLAGS( x, y )             \
{                                                   \
    PWAVEHDR16  pWavHdr;                            \
    DWORD       dw;                                 \
                                                    \
    pWavHdr = (x);                                  \
    dw      = (y).dwFlags;                          \
    pWavHdr->dwFlags = dw;                          \
}


#define COPY_MIDIOUTHDR16_FLAGS( x, y )             \
{                                                   \
    PMIDIHDR16  pMidHdr;                            \
    DWORD       dw;                                 \
                                                    \
    pMidHdr = (x);                                  \
    dw      = (y).dwFlags;                          \
    pMidHdr->dwFlags = dw;                          \
}

#define COPY_WAVEINHDR16_FLAGS( x, y )              \
{                                                   \
    PWAVEHDR16  pWavHdr;                            \
    DWORD       dw;                                 \
                                                    \
    pWavHdr = (x);                                  \
    dw      = (y).dwFlags;                          \
    pWavHdr->dwFlags = dw;                          \
    dw   = (y).dwBytesRecorded;                     \
    pWavHdr->dwBytesRecorded = dw;                  \
}


#define COPY_MIDIINHDR16_FLAGS( x, y )              \
{                                                   \
    PMIDIHDR16  pMidHdr;                            \
    DWORD       dw;                                 \
                                                    \
    pMidHdr = (x);                                  \
    dw      = (y).dwFlags;                          \
    pMidHdr->dwFlags = dw;                          \
    dw   = (y).dwBytesRecorded;                     \
    pMidHdr->dwBytesRecorded = dw;                  \
}



/* -------------------------------------------------------------------------
** Define 16-bit mixer stuff
** -------------------------------------------------------------------------
*/

#pragma pack(1)
typedef struct tMIXERCAPS16
{
    WORD            wMid;                   // manufacturer id
    WORD            wPid;                   // product id
    WORD            vDriverVersion;         // version of the driver
    char            szPname[MAXPNAMELEN];   // product name
    DWORD           fdwSupport;             // misc. support bits
    DWORD           cDestinations;          // count of destinations
} MIXERCAPS16;
typedef MIXERCAPS16  UNALIGNED *LPMIXERCAPS16;

typedef struct tMIXERLINE16
{
    DWORD       cbStruct;               // size of MIXERLINE structure
    DWORD       dwDestination;          // zero based destination index
    DWORD       dwSource;               // zero based source index (if source)
    DWORD       dwLineID;               // unique line id for mixer device
    DWORD       fdwLine;                // state/information about line
    DWORD       dwUser;                 // driver specific information
    DWORD       dwComponentType;        // component type line connects to
    DWORD       cChannels;              // number of channels line supports
    DWORD       cConnections;           // number of connections [possible]
    DWORD       cControls;              // number of controls at this line
    char        szShortName[MIXER_SHORT_NAME_CHARS];
    char        szName[MIXER_LONG_NAME_CHARS];
    struct
    {
        DWORD       dwType;                 // MIXERLINE_TARGETTYPE_xxxx
        DWORD       dwDeviceID;             // target device ID of device type
        WORD        wMid;                   // of target device
        WORD        wPid;                   //      "
        WORD        vDriverVersion;         //      "
        char        szPname[MAXPNAMELEN];   //      "
    } Target;
} MIXERLINE16;
typedef MIXERLINE16  UNALIGNED *LPMIXERLINE16;

typedef struct tMIXEROPENDESC16
{
    WORD            hmx;            // handle that will be used
    LPVOID          pReserved0;     // reserved--driver should ignore
    DWORD           dwCallback;     // callback
    DWORD           dwInstance;     // app's private instance information

} MIXEROPENDESC16;
typedef MIXEROPENDESC16 UNALIGNED *LPMIXEROPENDESC16;
#pragma pack()


DWORD CALLBACK
mxd32Message(
    UINT uId,
    UINT uMsg,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    );

void
GetLineInfo(
    LPMIXERLINE16 lpline16,
    LPMIXERLINEA lpline32
    );

void
PutLineInfo(
    LPMIXERLINE16 lpline16,
    LPMIXERLINEA lpline32
    );


/*
** ----------------------------------------------------------------
** General Debugging code
** ----------------------------------------------------------------
*/

#undef dprintf
#undef dprintf1
#undef dprintf2
#undef dprintf3
#undef dprintf4
#undef dprintf5

#if DBG

typedef struct tagMSG_NAME {
    UINT    uMsg;
    LPSTR   lpstrName;
} MSG_NAME;

extern int TraceAux;
extern int TraceJoy;
extern int TraceMidiIn;
extern int TraceMidiOut;
extern int TraceTime;
extern int TraceMix;
extern int TraceWaveOut;
extern int TraceWaveIn;
extern int DebugLevel;


VOID FAR DbgOutput( LPSTR lpstrFormatStr, ... );

#define dprintf( _x_ )                        winmmDbgOut _x_
#define dprintf1( _x_ ) if (DebugLevel >= 1) {winmmDbgOut _x_ ;} else
#define dprintf2( _x_ ) if (DebugLevel >= 2) {winmmDbgOut _x_ ;} else
#define dprintf3( _x_ ) if (DebugLevel >= 3) {winmmDbgOut _x_ ;} else
#define dprintf4( _x_ ) if (DebugLevel >= 4) {winmmDbgOut _x_ ;} else
#define dprintf5( _x_ ) if (DebugLevel >= 5) {winmmDbgOut _x_ ;} else

#define trace_waveout( _x_ ) if (TraceWaveOut)  {winmmDbgOut _x_ ;} else
#define trace_wavein( _x_ )  if (TraceWaveIn)   {winmmDbgOut _x_ ;} else
#define trace_mix( _x_ )     if (TraceMix)      {winmmDbgOut _x_ ;} else
#define trace_midiout( _x_ ) if (TraceMidiOut)  {winmmDbgOut _x_ ;} else
#define trace_midiin( _x_ )  if (TraceMidiIn)   {winmmDbgOut _x_ ;} else
#define trace_aux( _x_ )     if (TraceAux)      {winmmDbgOut _x_ ;} else
#define trace_joy( _x_ )     if (TraceJoy)      {winmmDbgOut _x_ ;} else
#define trace_time( _x_ )    if (TraceTime)     {winmmDbgOut _x_ ;} else

#else

#define dprintf( _x_ )
#define dprintf1( _x_ )
#define dprintf2( _x_ )
#define dprintf3( _x_ )
#define dprintf4( _x_ )
#define dprintf5( _x_ )

#define trace_waveout( _x_ )
#define trace_wavein( _x_ )
#define trace_mix( _x_ )
#define trace_midiout( _x_ )
#define trace_midiin( _x_ )
#define trace_time( _x_ )
#define trace_aux( _x_ )
#define trace_joy( _x_ )

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\mmwowcb.h ===
// Copyright (c) 1993-1997 Microsoft Corporation
/* --------------------------------------------------------------------
** Module       : wowmmcb.h
**
** Description  : Interrupt callback stuff for Multi-Media.
**
** History:     : Created 09-Nov-1992 by StephenE
**
** --------------------------------------------------------------------
*/
#ifndef WOWMMCB_H
#define WOWMMCB_H

/*
** This header file will go through both 16 bit and 32 bit compilers.
** In 16 bit land UNALIGNED is not required, on 32 bit land UNALIGNED
** would have been #defined by the time this file was #included because
** this file is always included after wow32.h.  This means the following
** #define is always a no-op with 16 bit compilers and ignored with
** 32 bit compilers.
*/
#ifndef UNALIGNED
#define UNALIGNED
#endif


/* --------------------------------------------------------------------
**  Hardware Interrupts:
**
**  IRQ:     Interrupt: ICA: Line: Description:
**  -------------------------------------------------------------------
**  IRQ0     0x08       0    0     Timer Tick every 18.2 times per second.
**  IRQ1     0x09       0    1     Keyboard service required.
**  IRQ2     0x0A       0    2     INT from slave 8259A.
**  IRQ8     0x70       1    0         Real time clock service.
**  IRQ9     0x71       1    1         Software redirected to IRQ2.
**  IRQ10    0x72       1    2         Reserved.
**  IRQ11    0x73       1    3         Reserved.
**  IRQ12    0x74       1    4         Reserved.
**  IRQ13    0x75       1    5         Numeric co-processor
**  IRQ14    0x76       1    6         Fixed disk controller
**  IRQ15    0x77       1    7         Reserved.
**  IRQ3     0x0B       0    3     Com2 service request.
**  IRQ4     0x0C       0    4     Com1 service request.
**  IRQ5     0x0D       0    5     Data request from LPT2:
**  IRQ6     0x0E       0    6     Floppy disk service required.
**  IRQ7     0x0F       0    7     Data request from LPT1:
**
** --------------------------------------------------------------------
*/

#define MULTIMEDIA_LINE         2
#define MULTIMEDIA_LINE_98      4
#define MULTIMEDIA_ICA          1
#define MULTIMEDIA_INTERRUPT    0x72
#define MULTIMEDIA_INTERRUPT_98 0x14

#define CALLBACK_ARGS_SIZE      16

typedef struct _CALLBACK_ARGS {   /* cbargs */
    DWORD       dwFlags;        // Flags to identify the type of callback.
    DWORD       dwFunctionAddr; // 16:16 address of the function to be called
    WORD        wHandle;        // The handle or ID of the device
    WORD        wMessage;       // The message to be passed to function
    DWORD       dwInstance;     // User data
    DWORD       dwParam1;       // Device data 1
    DWORD       dwParam2;       // Device data 2
} CALLBACK_ARGS;

typedef struct _CALLBACK_DATA {   /* cbdata */
    WORD            wRecvCount;    // The number of interrupts received
    WORD            wSendCount;    // The number of interrupts sent
    CALLBACK_ARGS   args[CALLBACK_ARGS_SIZE];  // Interrupt arguments
    WORD            wIntsCount;    // The number of interrupts received
} CALLBACK_DATA;

typedef CALLBACK_DATA FAR *VPCALLBACK_DATA;         // 16:16 pointer type
typedef CALLBACK_ARGS FAR *VPCALLBACK_ARGS;         // 16:16 pointer type

typedef CALLBACK_DATA UNALIGNED *PCALLBACK_DATA;    //  0:32 pointer type
typedef CALLBACK_ARGS UNALIGNED *PCALLBACK_ARGS;    //  0:32 pointer type

VOID FAR PASCAL Notify_Callback_Data( VPCALLBACK_DATA vpCallbackData );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\muldiv32.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1996 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  muldiv32.h
//
//  Description:
//      math routines for 32 bit signed and unsiged numbers.
//
//      MulDiv32(a,b,c) = (a * b) / c         (round down, signed)
//
//      MulDivRD(a,b,c) = (a * b) / c         (round down, unsigned)
//      MulDivRN(a,b,c) = (a * b + c/2) / c   (round nearest, unsigned)
//      MulDivRU(a,b,c) = (a * b + c-1) / c   (round up, unsigned)
//
//==========================================================================;

#ifndef _INC_MULDIV32
#define _INC_MULDIV32


#ifndef INLINE
#define INLINE __inline
#endif


#ifdef WIN32

    //----------------------------------------------------------------------;
    //
    //  Win 32
    //
    //----------------------------------------------------------------------;

    #ifdef _X86_
    
        //
        //  Use 32-bit x86 assembly.
        //

        #pragma warning(disable:4035 4704)

        INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     imul    ebx              //  imul ebx
            _asm     idiv    ecx              //  idiv ecx
            _asm	 shld	 edx, eax, 16     //  shld edx, eax, 16

        } // MulDiv32()

        INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     mov     ebx,ecx          //  mov  ebx,ecx
            _asm     shr     ebx,1            //  sar  ebx,1
            _asm     add     eax,ebx          //  add  eax,ebx
            _asm     adc     edx,0            //  adc  edx,0
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDiv32()

        INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     mov     ebx,ecx          //  mov  ebx,ecx
            _asm     dec     ebx              //  dec  ebx
            _asm     add     eax,ebx          //  add  eax,ebx
            _asm     adc     edx,0            //  adc  edx,0
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDivRU32()

        INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDivRD32()

        #pragma warning(default:4035 4704)


    #else

        //
        //  Use C9 __int64 support for Daytona RISC platforms.
        //

        INLINE LONG MulDiv32( LONG a, LONG b, LONG c )
        {
            return (LONG)( Int32x32To64(a,b) / c );
        }


        INLINE DWORD MulDivRD( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( UInt32x32To64(a,b) / c );
        }


        INLINE DWORD MulDivRN( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( (UInt32x32To64(a,b)+c/2) / c );
        }


        INLINE DWORD MulDivRU( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( (UInt32x32To64(a,b)+c-1) / c );
        }

    #endif


#else

    //----------------------------------------------------------------------;
    //
    //  Win 16
    //
    //----------------------------------------------------------------------;

    #pragma warning(disable:4035 4704)

    //
    //  Compile for 16-bit - we can use x86 with proper opcode prefixes
    //	    to get 32-bit instructions.
    //

    INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    imul    bx              //  imul ebx
        _asm _emit 0x66 _asm    idiv    cx              //  idiv ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDiv32()

    INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    mov     bx,cx           //  mov  ebx,ecx
        _asm _emit 0x66 _asm    shr     bx,1            //  sar  ebx,1
        _asm _emit 0x66 _asm    add     ax,bx           //  add  eax,ebx
        _asm _emit 0x66 _asm    adc     dx,0            //  adc  edx,0
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDiv32()

    INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    mov     bx,cx           //  mov  ebx,ecx
        _asm _emit 0x66 _asm    dec     bx              //  dec  ebx
        _asm _emit 0x66 _asm    add     ax,bx           //  add  eax,ebx
        _asm _emit 0x66 _asm    adc     dx,0            //  adc  edx,0
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDivRU32()


    INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDivRD32()

    #pragma warning(default:4035 4704)

#endif


//
//  some code references these by other names.
//
#define muldiv32    MulDiv32
#define muldivrn32  MulDivRN
#define muldivrd32  MulDivRD
#define muldivru32  MulDivRU

#endif  // _INC_MULDIV32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\mmwowmci.h ===
/******************************Module*Header*******************************\
* Module Name:
*
*
*
*
* Created: dd-mm-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/


typedef struct _RECT16 {        /* rc16 */
    SHORT   left;
    SHORT   top;
    SHORT   right;
    SHORT   bottom;
} RECT16;
typedef RECT16 UNALIGNED *PRECT16;

typedef struct _MCI_ANIM_OPEN_PARMS16 {
    DWORD   dwCallback;
    WORD    wDeviceID;
    WORD    wReserved0;
    LPCSTR  lpstrDeviceType;
    LPCSTR  lpstrElementName;
    LPCSTR  lpstrAlias;
    DWORD   dwStyle;
    HWND16  hWndParent;    // Keeps consistent, and is equivalent anyway
    WORD    wReserved1;
} MCI_ANIM_OPEN_PARMS16;
typedef MCI_ANIM_OPEN_PARMS16 UNALIGNED *PMCI_ANIM_OPEN_PARMS16;
typedef LPVOID  LPMCI_ANIM_OPEN_PARMS16;

typedef struct _MCI_ANIM_PLAY_PARMS16 {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
} MCI_ANIM_PLAY_PARMS16;
typedef MCI_ANIM_PLAY_PARMS16 UNALIGNED *PMCI_ANIM_PLAY_PARMS16;
typedef LPVOID  LPMCA_ANIM_PLAY_PARMS16;

typedef struct _MCI_ANIM_RECT_PARMS16 {
    DWORD   dwCallback;
    RECT16  rc;
} MCI_ANIM_RECT_PARMS16;
typedef MCI_ANIM_RECT_PARMS16 UNALIGNED *PMCI_ANIM_RECT_PARMS16;
typedef LPVOID  LPMCI_ANIM_RECT_PARMS16;

typedef struct _MCI_ANIM_STEP_PARMS16 {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_ANIM_STEP_PARMS16;
typedef MCI_ANIM_STEP_PARMS16 UNALIGNED *PMCI_ANIM_STEP_PARMS16;
typedef LPVOID  LPMCI_ANIM_STEP_PARMS16;

typedef struct _MCI_ANIM_UPDATE_PARMS16 {
    DWORD   dwCalback;
    RECT16  rc;
    HDC16   hDC;
} MCI_ANIM_UPDATE_PARMS16;
typedef MCI_ANIM_UPDATE_PARMS16 UNALIGNED *PMCI_ANIM_UPDATE_PARMS16;
typedef LPVOID  LPMCI_ANIM_UPDATE_PARMS16;

typedef struct _MCI_ANIM_WINDOW_PARMS16 {
    DWORD   dwCallabck;
    HWND16  hWnd;
    WORD    wReserved1;
    WORD    nCmdShow;
    WORD    wReserved2;
    LPCSTR  lpstrText;
} MCI_ANIM_WINDOW_PARMS16;
typedef MCI_ANIM_WINDOW_PARMS16 UNALIGNED *PMCI_ANIM_WINDOW_PARMS16;
typedef LPVOID  LPMCI_ANIM_WINDOW_PARMS16;

typedef struct _MCI_BREAK_PARMS16 {
    DWORD  dwCallback;
    INT16  nVirtKey;
    WORD   wReserved0;
    HWND16 hwndBreak;
    WORD   wReserved1;
} MCI_BREAK_PARMS16;
typedef MCI_BREAK_PARMS16 UNALIGNED *PMCI_BREAK_PARMS16;
typedef LPVOID  LPMCI_BREAK_PARMS16;

typedef struct _MCI_GENERIC_PARMS16 {
    DWORD   dwCallback;
} MCI_GENERIC_PARMS16;
typedef MCI_GENERIC_PARMS16 UNALIGNED *PMCI_GENERIC_PARMS16;
typedef LPVOID  LPMCI_GENERIC_PARMS16;

typedef struct _MCI_GETDEVCAPS_PARMS16 {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
} MCI_GETDEVCAPS_PARMS16;
typedef MCI_GETDEVCAPS_PARMS16 UNALIGNED *PMCI_GETDEVCAPS_PARMS16;
typedef LPVOID  LPMCI_GETDEVCAPS_PARMS16;

typedef struct _MCI_INFO_PARMS16 {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
} MCI_INFO_PARMS16;
typedef MCI_INFO_PARMS16 UNALIGNED *PMCI_INFO_PARMS16;
typedef LPVOID  LPMCI_INFO_PARMS16;

typedef struct _MCI_LOAD_PARMS16 {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
} MCI_LOAD_PARMS16;
typedef MCI_LOAD_PARMS16 UNALIGNED *PMCI_LOAD_PARMS16;
typedef LPVOID  LPMCI_LOAD_PARMS16;

typedef struct _MCI_OPEN_PARMS16 {
    DWORD   dwCallback;
    WORD    wDeviceID;
    WORD    wReserved0;
    LPCSTR  lpstrDeviceType;
    LPCSTR  lpstrElementName;
    LPCSTR  lpstrAlias;
} MCI_OPEN_PARMS16;
typedef MCI_OPEN_PARMS16 UNALIGNED *PMCI_OPEN_PARMS16;
typedef LPVOID  LPMCI_OPEN_PARMS16;

typedef struct _MCI_OVLY_LOAD_PARMS16 {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
    RECT16  rc;
} MCI_OVLY_LOAD_PARMS16;
typedef MCI_OVLY_LOAD_PARMS16 UNALIGNED *PMCI_OVLY_LOAD_PARMS16;
typedef LPVOID  LPMCI_OVLY_LOAD_PARMS16;

typedef struct _MCI_OVLY_OPEN_PARMS16 {
    DWORD   dwCallabck;
    WORD    wDeviceID;
    WORD    wReserved0;
    LPCSTR  lpstrDeviceType;
    LPCSTR  lpstrElementName;
    LPCSTR  lpstrAlias;
    DWORD   dwStyle;
    HWND16  hWndParent;  // The book is wrong
    WORD    wReserved1;
} MCI_OVLY_OPEN_PARMS16;
typedef MCI_OVLY_OPEN_PARMS16 UNALIGNED *PMCI_OVLY_OPEN_PARMS16;
typedef LPVOID  LPMCI_OVLY_OPEN_PARMS16;

typedef struct _MCI_OVLY_RECT_PARMS16 {
    DWORD   dwCallback;
    RECT16  rc;
} MCI_OVLY_RECT_PARMS16;
typedef MCI_OVLY_RECT_PARMS16 UNALIGNED *PMCI_OVLY_RECT_PARMS16;
typedef LPVOID  LPMCI_OVLY_RECT_PARMS16;

typedef struct _MCI_OVLY_SAVE_PARMS16 {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
    RECT16  rc;
} MCI_OVLY_SAVE_PARMS16;
typedef MCI_OVLY_SAVE_PARMS16 UNALIGNED *PMCI_OVLY_SAVE_PARMS16;
typedef LPVOID  LPMCI_OVLY_SAVE_PARMS16;

typedef struct _MCI_OVLY_WINDOW_PARMS16 {
    DWORD   dwCallabck;
    HWND16  hWnd;
    WORD    wReserved1;
    WORD    nCmdShow;
    WORD    wReserved2;
    LPCSTR  lpstrText;
} MCI_OVLY_WINDOW_PARMS16;
typedef MCI_OVLY_WINDOW_PARMS16 UNALIGNED *PMCI_OVLY_WINDOW_PARMS16;
typedef LPVOID  LPMCI_OVLY_WINDOW_PARMS16;

typedef struct _MCI_PLAY_PARMS16 {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_PLAY_PARMS16;
typedef MCI_PLAY_PARMS16 UNALIGNED *PMCI_PLAY_PARMS16;
typedef LPVOID  LPMCI_PLAY_PARMS16;

typedef struct _MCI_RECORD_PARMS16 {
    DWORD   dwCallabck;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_RECORD_PARMS16;
typedef MCI_RECORD_PARMS16 UNALIGNED *PMCI_RECORD_PARMS16;
typedef LPVOID  LPMCI_RECORD_PARMS16;

typedef struct _MCI_SAVE_PARMS16 {
    DWORD   dwCallback;
    LPCSTR  lpfilename;   // MMSYSTEM.H differs from the book
} MCI_SAVE_PARMS16;
typedef MCI_SAVE_PARMS16 UNALIGNED *PMCI_SAVE_PARMS16;
typedef LPVOID  LPMCI_SAVE_PARMS16;

typedef struct _MCI_SEEK_PARMS16 {
    DWORD   dwCallback;
    DWORD   dwTo;
} MCI_SEEK_PARMS16;
typedef MCI_SEEK_PARMS16 UNALIGNED *PMCI_SEEK_PARMS16;
typedef LPVOID  LPMCI_SEEK_PARMS16;

typedef struct _MCI_SEQ_SET_PARMS16 {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    DWORD   dwTempo;
    DWORD   dwPort;
    DWORD   dwSlave;
    DWORD   dwMaster;
    DWORD   dwOffset;
} MCI_SEQ_SET_PARMS16;
typedef MCI_SEQ_SET_PARMS16 UNALIGNED *PMCI_SEQ_SET_PARMS16;
typedef LPVOID  LPMCI_SEQ_SET_PARMS16;

typedef struct _MCI_SET_PARMS16 {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
} MCI_SET_PARMS16;
typedef MCI_SET_PARMS16 UNALIGNED *PMCI_SET_PARMS16;
typedef LPVOID  LPMCI_SET_PARMS16;

typedef struct _MCI_SOUND_PARMS16 {
    DWORD   dwCallback;
    LPCSTR  lpstrSoundName;
} MCI_SOUND_PARMS16;
typedef MCI_SOUND_PARMS16 UNALIGNED *PMCI_SOUND_PARMS16;
typedef LPVOID  LPMCI_SOUND_PARMS16;

typedef struct _MCI_STATUS_PARMS16 {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
    DWORD   dwTrack;
} MCI_STATUS_PARMS16;
typedef MCI_STATUS_PARMS16 UNALIGNED *PMCI_STATUS_PARMS16;
typedef LPVOID  LPMCI_STATUS_PARMS16;

typedef struct _MCI_SYSINFO_PARMS16 {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwNumber;
    WORD    wDeviceType;
    WORD    wReserved0;
} MCI_SYSINFO_PARMS16;
typedef MCI_SYSINFO_PARMS16 UNALIGNED *PMCI_SYSINFO_PARMS16;
typedef LPVOID  LPMCI_SYSINFO_PARMS16;

typedef struct _MCI_VD_ESCAPE_PARMS16 {
    DWORD   dwCallback;
    LPCSTR  lpstrCommand;
} MCI_VD_ESCAPE_PARMS16;
typedef MCI_VD_ESCAPE_PARMS16 UNALIGNED *PMCI_VD_ESCAPE_PARMS16;
typedef LPVOID  LPMCI_VD_ESCAPE_PARMS16;

typedef struct _MCI_VD_PLAY_PARMS16 {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
} MCI_VD_PLAY_PARMS16;
typedef MCI_VD_PLAY_PARMS16 UNALIGNED *PMCI_VD_PLAY_PARMS16;
typedef LPVOID  LPMCI_VD_PLAY_PARMS16;

typedef struct _MCI_VD_STEP_PARMS16 {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_VD_STEP_PARMS16;
typedef MCI_VD_STEP_PARMS16 UNALIGNED *PMCI_VD_STEP_PARMS16;
typedef LPVOID  LPMCI_VD_STEP_PARMS16;

typedef struct _MCI_VD_DELETE_PARMS16 {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_VD_DELETE_PARMS16;
typedef MCI_VD_DELETE_PARMS16 UNALIGNED *PMCI_VD_DELETE_PARMS16;
typedef LPVOID  LPMCI_VD_DELETE_PARMS16;

typedef struct _MCI_WAVE_OPEN_PARMS16 {
    DWORD   dwCallback;
    WORD    wDeviceID;
    WORD    wReserved0;
    LPCSTR  lpstrDeviceType;
    LPCSTR  lpstrElementName;
    LPCSTR  lpstrAlias;
    DWORD   dwBufferSeconds;
} MCI_WAVE_OPEN_PARMS16;
typedef MCI_WAVE_OPEN_PARMS16 UNALIGNED *PMCI_WAVE_OPEN_PARMS16;
typedef LPVOID  LPMCI_WAVE_OPEN_PARMS16;

typedef struct _MCI_WAVE_SET_PARMS16 {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    WORD    wInput;
    WORD    wReserved0;
    WORD    wOutput;
    WORD    wReserved1;
    WORD    wFormatTag;
    WORD    wReserved2;
    WORD    nChannels;
    WORD    wReserved3;
    DWORD   nSamplesPerSecond;
    DWORD   nAvgBytesPerSec;
    WORD    nBlockAlign;
    WORD    wReserved4;
    WORD    wBitsPerSample;
    WORD    wReserved5;
} MCI_WAVE_SET_PARMS16;
typedef MCI_WAVE_SET_PARMS16 UNALIGNED *PMCI_WAVE_SET_PARMS16;
typedef LPVOID  LPMCI_WAVE_SET_PARMS16;

typedef struct {
    DWORD   dwCallback;
    DWORD   dwItem;
    DWORD   dwValue;
    DWORD   dwOver;
    LPSTR   lpstrAlgorithm;
    LPSTR   lpstrQuality;
    DWORD   dwSourceNumber;
} MCI_DGV_SETVIDEO_PARMS16;
typedef MCI_DGV_SETVIDEO_PARMS16 UNALIGNED *PMCI_DGV_SETVIDEO_PARMS16;

#ifdef i386
#define GETWORD(pb)     (*((PWORD)pb)++)
#define GETDWORD(pb)    (*((PDWORD)pb)++)
#define FETCHWORD(s)    ((WORD)(s))
#define FETCHDWORD(s)   ((DWORD)(s))
#define STOREWORD(d,s)  (WORD)d=(WORD)s
#define STOREDWORD(d,s) (DWORD)d=(DWORD)s
#else
#define GETWORD(pb)   (*((UNALIGNED WORD *)pb)++)
#define GETDWORD(pb)  (*((UNALIGNED DWORD *)pb)++)
#define FETCHWORD(s)  (*(UNALIGNED WORD *)&(s))
#define FETCHDWORD(s) (*(UNALIGNED DWORD *)&(s))
#define STOREWORD(d,s)  *(UNALIGNED WORD *)&(d)=(WORD)s
#define STOREDWORD(d,s) *(UNALIGNED DWORD *)&(d)=(DWORD)s
#endif

#define FETCHSHORT(s)   ((SHORT)(FETCHWORD(s)))
#define FETCHLONG(s)    ((LONG)(FETCHDWORD(s)))
#define STORESHORT(d,s) STOREWORD(d,s)
#define STORELONG(d,s)  STOREDWORD(d,s)

#define CHAR32(b)       ((CHAR)(b))
#define BYTE32(b)       ((BYTE)(b))
#define INT32(i)        ((INT)(INT16)(i))
#define UINT32(i)       ((unsigned int)(i))
#define BOOL32(f)       ((BOOL)(f))
#define WORD32(w)       ((WORD)(w))
#define LONG32(l)       FETCHLONG(l)
#define DWORD32(dw)     FETCHDWORD(dw)

#define MMGETOPTPTR(vp,cb,p)  {p=NULL; if (HIWORD(FETCHDWORD(vp))) p = GETVDMPTR(vp);}


DWORD
ThunkMciCommand16(
    MCIDEVICEID DeviceID,
    UINT OrigCommand,
    DWORD OrigFlags,
    PMCI_GENERIC_PARMS16 lp16OrigParms,
    PDWORD pNewParms,
    LPWSTR *lplpCommand,
    PUINT puTable
    );

VOID
ThunkGenericParms(
    PDWORD pOrigFlags,
    PMCI_GENERIC_PARMS16 lp16GenParmsOrig,
    PMCI_GENERIC_PARMS lp32GenParmsOrig
    );

DWORD
ThunkOpenCmd(
    PDWORD pOrigFlags,
    PMCI_OPEN_PARMS16 lp16OpenParms,
    PMCI_OPEN_PARMS p32OpenParms
    );

DWORD
ThunkSetCmd(
    MCIDEVICEID DeviceID,
    PDWORD pOrigFlags,
    PMCI_SET_PARMS16 lpSetParms16,
    PMCI_SET_PARMS lpSetParms32
    );

DWORD
ThunkSetVideoCmd(
    PDWORD pOrigFlags,
    PMCI_DGV_SETVIDEO_PARMS16 lpSetParms16,
    LPMCI_DGV_SETVIDEO_PARMS lpSetParms32
    );

DWORD
ThunkSysInfoCmd(
    PMCI_SYSINFO_PARMS16 lpSysInfo16,
    PMCI_SYSINFO_PARMS lpSysInfo32
    );

DWORD
ThunkBreakCmd(
    PDWORD pOrigFlags,
    PMCI_BREAK_PARMS16 lpBreak16,
    PMCI_BREAK_PARMS lpBreak32
    );

DWORD
ThunkWindowCmd(
    MCIDEVICEID DeviceID,
    PDWORD pOrigFlags,
    PMCI_ANIM_WINDOW_PARMS16 lpAniParms16,
    PMCI_ANIM_WINDOW_PARMS lpAniParms32
    );

int
ThunkCommandViaTable(
    LPWSTR lpCommand,
    DWORD dwFlags,
    DWORD UNALIGNED *pdwOrig16,
    LPBYTE pNewParms
    );

int
UnThunkMciCommand16(
    MCIDEVICEID devID,
    UINT OrigCommand,
    DWORD OrigFlags,
    PMCI_GENERIC_PARMS16 lp16GenericParms,
    PDWORD NewParms,
    LPWSTR lpCommand,
    UINT uTable
    );

VOID
UnThunkOpenCmd(
    PMCI_OPEN_PARMS16 lpOpeParms16,
    PMCI_OPEN_PARMS lpOpenParms32
    );

#if DBG
VOID
UnThunkSysInfoCmd(
    DWORD OrigFlags,
    PMCI_SYSINFO_PARMS NewParms
    );
#endif

VOID
UnThunkStatusCmd(
    MCIDEVICEID devID,
    DWORD OrigFlags,
    DWORD UNALIGNED *pdwOrig16,
    DWORD NewParms
    );

int
UnThunkCommandViaTable(
    LPWSTR lpCommand,
    DWORD UNALIGNED *pdwOrig16,
    DWORD pNewParms,
    BOOL fReturnValNotThunked
    );


/* -------------------------------------------------------------------------
** Compatability functions.
** -------------------------------------------------------------------------
*/
BOOL APIENTRY mciExecute(
    LPCSTR lpstrCommand
    );

/* -----------------------------------------------------------------------
 *
 * MCI Command Thunks Debugging Functions and Macros
 *
 * ----------------------------------------------------------------------- */
typedef struct {
    UINT    uMsg;
    LPSTR   lpstMsgName;
} MCI_MESSAGE_NAMES;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\mmwowmci.c ===
/******************************Module*Header*******************************\
* Module Name:  mmwowmci.c
*
*  Thunks for the mci api's.
*
*
* Created: 28-09-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993-1998 Microsoft Corporation
\**************************************************************************/
#include "winmmi.h"
#include "mci.h"
#include <digitalv.h>
#include <stdlib.h>

#include "mixer.h"

#define _INC_ALL_WOWSTUFF
#include "mmwow32.h"
#include "mmwowmci.h"
#include "mmwowcb.h"

extern void
WOWAppExit(
    HANDLE hTask
    );

STATICFN void mciFreeDevice(LPMCI_DEVICE_NODE nodeWorking);
STATICFN MCIDEVICEID NEAR mciAllocateNode (
    DWORD dwFlags,
    LPCWSTR lpDeviceName,
    LPMCI_DEVICE_NODE FAR *lpnodeNew);

#ifndef _WIN64

/******************************Public*Routine******************************\
* mci32Message
*
* Entry point for all the mci thunks.
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD WINAPI
mci32Message(
    DWORD dwApi,
    DWORD dwF1,
    DWORD dwF2,
    DWORD dwF3,
    DWORD dwF4
    )
{

    DWORD   dwRet;

    switch ( dwApi ) {

    case THUNK_MCI_SENDCOMMAND:
        dwRet = WMM32mciSendCommand( dwF1, dwF2, dwF3, dwF4 );
        break;

    case THUNK_MCI_SENDSTRING:
        dwRet = WMM32mciSendString( dwF1, dwF2, dwF3, dwF4 );
        break;

    case THUNK_MCI_GETDEVICEID:
        dwRet = WMM32mciGetDeviceID( dwF1 );
        break;

    case THUNK_MCI_GETDEVIDFROMELEMID:
        dwRet = WMM32mciGetDeviceIDFromElementID( dwF1, dwF2 );
        break;

    case THUNK_MCI_GETERRORSTRING:
        dwRet = WMM32mciGetErrorString( dwF1, dwF2, dwF3 );
        break;

    case THUNK_MCI_SETYIELDPROC:
        dwRet = WMM32mciSetYieldProc( dwF1, dwF2, dwF3 );
        break;

    case THUNK_MCI_GETYIELDPROC:
        dwRet = WMM32mciGetYieldProc( dwF1, dwF2 );
        break;

    case THUNK_MCI_GETCREATORTASK:
        dwRet = WMM32mciGetCreatorTask( dwF1 );
        break;

    case THUNK_APP_EXIT:
        /*
        ** Now tidy up the other stuff.
        */
        dwRet = 0; //Keep the compiler happy
        WOWAppExit( (HANDLE)GetCurrentThreadId() );
        break;

    case THUNK_MCI_ALLOCATE_NODE:
        dwRet = WMM32mciAllocateNode( dwF1, dwF2 );
        break;

    case THUNK_MCI_FREE_NODE:
        dwRet = WMM32mciFreeNode( dwF1 );
        break;

    }

    return dwRet;
}


/**********************************************************************\
* WMM32mciSendCommand
*
*
* This function sends a command message to the specified MCI device.
*
\**********************************************************************/
DWORD
WMM32mciSendCommand(
    DWORD dwF1,
    DWORD dwF2,
    DWORD dwF3,
    DWORD dwF4
    )
{
    PMCI_GENERIC_PARMS16 lp16OrigParms;
    DWORD       ul;
    DWORD       NewParms[MCI_MAX_PARAM_SLOTS];
    LPWSTR      lpCommand;
    UINT        uTable;


    if ( dwF2 == DRV_CONFIGURE ) {

        typedef struct {
            DWORD   dwDCISize;
            LPCSTR  lpszDCISectionName;
            LPCSTR  lpszDCIAliasName;
        } DRVCONFIGINFO16;
        typedef DRVCONFIGINFO16 UNALIGNED *LPDRVCONFIGINFO16;

        LPDRVCONFIGINFO16   lpdrvConf;

        lpdrvConf = GETVDMPTR(dwF4);

        if (lpdrvConf && (lpdrvConf->dwDCISize == sizeof(DRVCONFIGINFO16))) {

            DRVCONFIGINFO drvConf;
            LPCSTR lpStr1 = lpdrvConf->lpszDCISectionName;
            LPCSTR lpStr2 = lpdrvConf->lpszDCIAliasName;

            drvConf.dwDCISize = sizeof(drvConf);
            drvConf.lpszDCISectionName = AllocUnicodeStr( GETVDMPTR(lpStr1) );

            if (NULL == drvConf.lpszDCISectionName) {
                return MCIERR_OUT_OF_MEMORY;
            }

            drvConf.lpszDCIAliasName = AllocUnicodeStr( GETVDMPTR(lpStr2) );

            if (NULL == lpdrvConf->lpszDCIAliasName) {

                FreeUnicodeStr((LPWSTR)drvConf.lpszDCISectionName);
                return MCIERR_OUT_OF_MEMORY;
            }

            ul = mciSendCommandW( dwF1, dwF2, (DWORD)HWND32(LOWORD(dwF3)),
                                  (DWORD)(LPVOID)&drvConf );

            FreeUnicodeStr( (LPWSTR)drvConf.lpszDCIAliasName );
            FreeUnicodeStr( (LPWSTR)drvConf.lpszDCISectionName );

            return ul;

        }

        return DRVCNF_CANCEL;
    }


    /*
    ** lparam (dwF4) is a 16:16 pointer.  This Requires parameter
    ** translation and probably memory copying, similar to the WM message
    ** thunks.  A whole thunk/unthunk table should be created.
    **
    ** Shouldn't these be FETCHDWORD, FETCHWORD macros?
    ** else MIPS problems ensue
    */
    lpCommand = NULL;
    uTable    = 0;
    lp16OrigParms = GETVDMPTR( dwF4 );

    try {

        ul = ThunkMciCommand16( (MCIDEVICEID)INT32( dwF1 ), (UINT)dwF2,
                                dwF3, lp16OrigParms, NewParms,
                                &lpCommand, &uTable );

        /*
        ** OK so far ?  If not don't bother calling into winmm.
        */
        if ( ul == 0 ) {

            dprintf3(( "About to call mciSendCommand." ));
            ul = (DWORD)mciSendCommandA( (MCIDEVICEID)INT32( dwF1 ),
                                         (UINT)dwF2, dwF3, (DWORD)NewParms );
            dprintf3(( "return code-> %ld", ul ));

            /*
            ** We have to special case the MCI_CLOSE command.  MCI_CLOSE usually
            ** causes the device to become unloaded.  This means that lpCommand
            ** now points to invalid memory.  We can fix this by setting
            ** lpCommand to NULL.
            */
            if ( dwF2 == MCI_CLOSE ) {
                lpCommand = NULL;
            }

            UnThunkMciCommand16( (MCIDEVICEID)INT32( dwF1 ), UINT32( dwF2 ),
                                 DWORD32( dwF3 ), lp16OrigParms,
                                 NewParms, lpCommand, uTable );
            /*
            ** Print a blank line so that I can distinguish the commands on the
            ** debugger.  This is only necessary if the debug level is >= 3.
            */
            dprintf3(( " " ));
#if DBG
            if ( DebugLevel >= 6 ) DebugBreak();
#endif

        }

    } except( GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION
                                        ? EXCEPTION_EXECUTE_HANDLER
                                        : EXCEPTION_CONTINUE_SEARCH ) {

        dprintf(( "UNKOWN access violation processing 0x%X command",
                  UINT32(dwF2) ));

    }

    return ul;
}

/**********************************************************************\
*
* WMM32mciSendString
*
* This function sends a command string to an MCI device. The device that the
* command is sent to is specified in the command string.
*
\**********************************************************************/
DWORD
WMM32mciSendString(
    DWORD dwF1,
    DWORD dwF2,
    DWORD dwF3,
    DWORD dwF4
    )
{

    //
    // The use of volatile here is to bypass a bug with the intel
    // compiler.
    //
#   define   MAX_MCI_CMD_LEN  256

    volatile ULONG              ul = MMSYSERR_INVALPARAM;
             PSZ                pszCommand;
             PSZ                pszReturnString = NULL;
             UINT               uSize;
             CHAR               szCopyCmd[MAX_MCI_CMD_LEN];


    /*
    ** Test against a NULL pointer for the command name.
    */
    pszCommand = GETVDMPTR(dwF1);
    if ( pszCommand ) {

#       define MAP_INTEGER     0
#       define MAP_HWND        1
#       define MAP_HPALETTE    2

        int     MapReturn = MAP_INTEGER;
        WORD    wMappedHandle;
        char    *psz;

        /*
        ** make a copy of the command string and then force it to
        ** all lower case.  Then scan the string looking for the word
        ** "status".  If we find it scan the string again looking for the
        ** word "handle", if we find it scan the the string again looking
        ** for palette or window.  Then set a flag to remind us to convert
        ** the handle back from 32 to 16 bits.
        */
        strncpy( szCopyCmd, pszCommand, MAX_MCI_CMD_LEN );
        szCopyCmd[ MAX_MCI_CMD_LEN - 1 ] = '\0';
        CharLowerBuff( szCopyCmd, MAX_MCI_CMD_LEN );

        /*
        ** Skip past any white space ie. " \t\r\n"
        ** If the next 6 characters after any white space are not
        ** "status" don't bother with any other tests.
        */
        psz = szCopyCmd + strspn( szCopyCmd, " \t\r\n" );
        if ( strncmp( psz, "status", 6 ) == 0 ) {

            if ( strstr( psz, "handle" ) ) {

                if ( strstr( psz, "window" ) ) {
                    MapReturn = MAP_HWND;
                }
                else if ( strstr( psz, "palette" ) ) {
                    MapReturn = MAP_HPALETTE;
                }
            }
        }

        /*
        ** Test against a zero length string and a NULL pointer
        */
        uSize = (UINT)dwF3;
        if( uSize != 0 ) {

            MMGETOPTPTR(dwF2, uSize, pszReturnString);

            if ( pszReturnString == NULL ) {
                uSize = 0;
            }
        }

        dprintf3(( "wow32: mciSendString -> %s", pszCommand ));

        ul = (DWORD)mciSendStringA( pszCommand, pszReturnString, uSize,
                                    HWND32(LOWORD(dwF4)) );

#if DBG
        if ( pszReturnString && *pszReturnString ) {
            dprintf3(( "wow32: mciSendString return -> %s", pszReturnString ));
        }
#endif

        if ( pszReturnString && *pszReturnString ) {

            switch ( MapReturn ) {

            case MAP_HWND:
                MapReturn = atoi( pszReturnString );
                wMappedHandle = (WORD)GETHWND16( (HWND)MapReturn );
                wsprintf( pszReturnString, "%d", wMappedHandle );
                dprintf2(( "Mapped 32 bit Window %s to 16 bit  %u",
                            pszReturnString,
                            wMappedHandle ));
                break;

            case MAP_HPALETTE:
                MapReturn = atoi( pszReturnString );
                dprintf2(( "Mapped 32 bit palette %s", pszReturnString ));
                wMappedHandle = (WORD)GETHPALETTE16( (HPALETTE)MapReturn );
                wsprintf( pszReturnString, "%d", wMappedHandle );
                dprintf2(( "Mapped 32 bit Palette %s to 16 bit  %u",
                            pszReturnString,
                            wMappedHandle ));
                break;
            }
        }

    }

    return ul;

#   undef MAP_INTEGER
#   undef MAP_HWND
#   undef MAP_HPALETTE
#   undef MAX_MCI_CMD_LEN
}

/**********************************************************************\
*
* WMM32mciGetDeviceID
*
* This assumes that the string is incoming, and the ID is returned in the WORD.
*
* This function retrieves the device ID corresponding to the name of an
* open MCI device.
*
\**********************************************************************/
DWORD
WMM32mciGetDeviceID(
    DWORD dwF1
    )
{
    DWORD ul = 0L;
    PSZ pszName;


    /*
    ** Test against a NULL pointer for the device name.
    */
    pszName = GETVDMPTR(dwF1);
    if ( pszName ) {

        ul = mciGetDeviceIDA( pszName );
    }

    return ul;
}

/**********************************************************************\
*
* WMM32mciGetErrorString
*
* This function returns a textual description of the specified MCI error.
*
\**********************************************************************/
DWORD
WMM32mciGetErrorString(
    DWORD dwF1,
    DWORD dwF2,
    DWORD dwF3
    )
{
    PSZ pszBuffer;
    DWORD ul = 0;


    /*
    ** Test against a zero length string and a NULL pointer
    */
    MMGETOPTPTR( dwF2, dwF3, pszBuffer);
    if ( pszBuffer ) {

        ul = (DWORD)mciGetErrorStringA( dwF1, pszBuffer, (UINT)dwF3 );
    }

    return ul;
}

#if 0
/**********************************************************************\
*
* WMM32mciExecute
*
* This function is a simplified version of the mciSendString function. It does
* not take a buffer for return information, and it displays a message box when
* errors occur.
*
* THIS FUNCTION SHOULD NOT BE USED - IT IS RETAINED ONLY FOR BACKWARD
* COMPATABILITY WITH WIN 3.0 APPS - USE mciSendString INSTEAD...
*
\**********************************************************************/
DWORD
WMM32mciExecute(
    DWORD dwF1
    )
{
    DWORD ul = 0;
    PSZ pszCommand;


    /*
    ** Test against a NULL pointer for the command string.
    */
    pszCommand = GETVDMPTR(dwF1);
    if ( pszCommand ) {

        ul = (DWORD)mciExecute( pszCommand );
    }

    return ul;
}
#endif

/**********************************************************************\
*
* WMM32mciGetDeviceIDFromElementID
*
* This function - um, yes, well...
*
* It appears in the headers but not in the book...
*
\**********************************************************************/
DWORD
WMM32mciGetDeviceIDFromElementID(
    DWORD dwF1,
    DWORD dwF2
    )
{
    ULONG ul = 0;
    PSZ pszDeviceID;


    /*
    ** Test against a NULL pointer for the device name.
    */
    pszDeviceID = GETVDMPTR(dwF2);
    if ( pszDeviceID ) {

        ul = (DWORD)mciGetDeviceIDFromElementIDA( dwF1, pszDeviceID );

    }
    return ul;
}

/**********************************************************************\
*
* WMM32mciGetCreatorTask
*
* This function - um again. Ditto for book and headers also.
*
\**********************************************************************/
DWORD
WMM32mciGetCreatorTask(
    DWORD dwF1
    )
{
    ULONG ul;

    ul = GETHTASK16( mciGetCreatorTask( (MCIDEVICEID)INT32(dwF1) ));

    return ul;
}


/**********************************************************************\
*
* WMM32mciSetYieldProc
*
*
\**********************************************************************/
DWORD
WMM32mciSetYieldProc(
    DWORD dwF1,
    DWORD dwF2,
    DWORD dwF3
    )
{
    ULONG              ul;
    YIELDPROC          YieldProc32;
    INSTANCEDATA      *lpYieldProcInfo;
    DWORD              dwYieldData = 0;

    /*
    ** We may have already set a YieldProc for this device ID.  If so we
    ** have to free the INSTANCEDATA structure here.  mciGetYieldProc
    ** returns NULL is no YieldProc was specified.
    */
    YieldProc32 = (YIELDPROC)mciGetYieldProc( (MCIDEVICEID)INT32(dwF1),
                                               &dwYieldData );

    if ( (YieldProc32 == WMM32mciYieldProc) && (dwYieldData != 0) ) {
        winmmFree( (INSTANCEDATA *)dwYieldData );
    }

    if ( dwF2 == 0 ) {
        YieldProc32 = NULL;
        dwYieldData = 0;
    }
    else {
        /*
        ** Allocate some storage for a INSTANCEDATA structure and save
        ** the passed 16 bit parameters.  This storage get freed when the
        ** application calls mciSetYieldProc with a NULL YieldProc.
        */
        lpYieldProcInfo = winmmAlloc( sizeof(INSTANCEDATA) );
        if ( lpYieldProcInfo == NULL ) {
            ul = (ULONG)MMSYSERR_NOMEM;
            goto exit_app;
        }

        dwYieldData = (DWORD)lpYieldProcInfo;
        YieldProc32 = WMM32mciYieldProc;

        lpYieldProcInfo->dwCallback         = dwF2;
        lpYieldProcInfo->dwCallbackInstance = dwF3;
    }

    ul = (DWORD)mciSetYieldProc( (MCIDEVICEID)INT32(dwF1),
                                 YieldProc32, dwYieldData );
    /*
    ** If the call failed free the storage here.
    */
    if ( ul == FALSE ) {
        winmmFree( (INSTANCEDATA *)dwYieldData );
    }

exit_app:
    return ul;
}


/**********************************************************************\
*
* WMM32mciYieldProc
*
* Here we call the real 16 bit YieldProc.  This function assumes that
* we yield on the wow thread.  If this is not the case we get instant
* death inside CallBack16.
*
* 12th Jan 1993 - The bad news is that the mci yield proc is NOT always
* called back on the thread that set it.  This means that we cannot callback
* into the 16bit code because the calling thread does not have a 16bit
* stack.
*
\**********************************************************************/
UINT
WMM32mciYieldProc(
    MCIDEVICEID wDeviceID,
    DWORD dwYieldData
    )
{
    wDeviceID   = (MCIDEVICEID)0;
    dwYieldData = 0;
    return 0;
}


/**********************************************************************\
*
* WMM32mciGetYieldProc
*
*
\**********************************************************************/
DWORD
WMM32mciGetYieldProc(
    DWORD dwF1,
    DWORD dwF2
    )
{
    ULONG ul = 0;
    YIELDPROC YieldProc32;
    DWORD dwYieldData = 0;
    DWORD UNALIGNED *pdw1;

    /*
    ** Get the address of the 32 bit yield proc.
    */
    YieldProc32 = (YIELDPROC)mciGetYieldProc( (MCIDEVICEID)INT32(dwF1),
                                              &dwYieldData );

    /*
    ** Did we set it ?  If so it must point to WMM32mciYieldProc.
    */
    if ( ((YieldProc32 == WMM32mciYieldProc) && (dwYieldData != 0)) ) {

        ul = ((INSTANCEDATA *)dwYieldData)->dwCallback;

        pdw1 = GETVDMPTR( dwF2 );
        *pdw1 = ((INSTANCEDATA *)dwYieldData)->dwCallbackInstance;
    }

    return ul;
}



/**********************************************************************\
*
* WMM32mciAllocateNode
*
*
\**********************************************************************/
DWORD
WMM32mciAllocateNode(
    DWORD dwF1,            // dwOpenFlags
    DWORD dwF2             // lpszDeviceName
    )
{
    LPMCI_DEVICE_NODE lpNode32;
    LPWSTR lpDeviceName32;
    ULONG ul = 0;

    // Thunk 16-bit params and allocate a 32-bit device node 
    if ((lpDeviceName32 = AllocUnicodeStr(GETVDMPTR(dwF2))) != NULL) {
        if ((ul = mciAllocateNode(dwF1, lpDeviceName32, &lpNode32)) != 0) {
            // Mark this device as 16-bit
            lpNode32->dwMCIFlags |= MCINODE_16BIT_DRIVER;
        }
        FreeUnicodeStr(lpDeviceName32);
    }
    return ul;
}

/**********************************************************************\
*
* WMM32mciFreeNode
*
*
\**********************************************************************/
DWORD
WMM32mciFreeNode(
    DWORD dwF2
    )
{
    LPMCI_DEVICE_NODE lpNode32;

    if ((lpNode32 = MCI_lpDeviceList[dwF2]) != NULL) {
        mciFreeDevice(lpNode32);
    }

    return 0;
}

#if DBG

MCI_MESSAGE_NAMES  mciMessageNames[32] = {
    { MCI_OPEN,         "MCI_OPEN" },
    { MCI_CLOSE,        "MCI_CLOSE" },
    { MCI_ESCAPE,       "MCI_ESCAPE" },
    { MCI_PLAY,         "MCI_PLAY" },
    { MCI_SEEK,         "MCI_SEEK" },
    { MCI_STOP,         "MCI_STOP" },
    { MCI_PAUSE,        "MCI_PAUSE" },
    { MCI_INFO,         "MCI_INFO" },
    { MCI_GETDEVCAPS,   "MCI_GETDEVCAPS" },
    { MCI_SPIN,         "MCI_SPIN" },
    { MCI_SET,          "MCI_SET" },
    { MCI_STEP,         "MCI_STEP" },
    { MCI_RECORD,       "MCI_RECORD" },
    { MCI_SYSINFO,      "MCI_SYSINFO" },
    { MCI_BREAK,        "MCI_BREAK" },
    { MCI_SOUND,        "MCI_SOUND" },
    { MCI_SAVE,         "MCI_SAVE" },
    { MCI_STATUS,       "MCI_STATUS" },
    { MCI_CUE,          "MCI_CUE" },
    { MCI_REALIZE,      "MCI_REALIZE" },
    { MCI_WINDOW,       "MCI_WINDOW" },
    { MCI_PUT,          "MCI_PUT" },
    { MCI_WHERE,        "MCI_WHERE" },
    { MCI_FREEZE,       "MCI_FREEZE" },
    { MCI_UNFREEZE,     "MCI_UNFREEZE" },
    { MCI_LOAD,         "MCI_LOAD" },
    { MCI_CUT,          "MCI_CUT" },
    { MCI_COPY,         "MCI_COPY" },
    { MCI_PASTE,        "MCI_PASTE" },
    { MCI_UPDATE,       "MCI_UPDATE" },
    { MCI_RESUME,       "MCI_RESUME" },
    { MCI_DELETE,       "MCI_DELETE" }
};
#endif

/**********************************************************************\
*
* ThunkMciCommand16
*
* This function converts a 16 bit mci command request into an
* equiverlant 32 bit request.
*
* The ideas behind this function were stolen from ThunkWMMsg16,
* see wmsg16.c and mciDebugOut see mci.c
*
* We return 0 if the thunk was OK, any other value should be used as
* an error code.  If the thunk failed all allocated resources will
* be freed by this function.  If the thunk was sucessful (ie. returned 0)
* UnThunkMciCommand16 MUST be called to free allocated resources.
*
* Here are the assumptions that I have used to perform the thunking:
*
* 1. MCI_OPEN is a special case.
*
* 2. If the message is NOT defined in mmsystem.h then it is treated as a
*    "user" command.  If a user command table is associated with the given
*    device ID we use this command table as an aid to perform the thunking.
*    If a user command table is NOT associated with the device ID the
*    command does NOT GET THUNKED, we return straight away, calling
*    mciSendCommand only to get a relevant error code.
*
* 3. If the command IS defined in mmsystem.h we perfrom a "manual" thunk
*    of the command IF the associated PARMS structure contains ReservedX
*    fields.  We mask out the associated flags as each field is thunked.
*
* 4. If there are any flags left then we use the command table
*    as an aid to perform the thunking.
*
\**********************************************************************/
DWORD
ThunkMciCommand16(
    MCIDEVICEID DeviceID,
    UINT OrigCommand,
    DWORD OrigFlags,
    PMCI_GENERIC_PARMS16 lp16OrigParms,
    PDWORD pNewParms,
    LPWSTR *lplpCommand,
    PUINT puTable
    )
{
#if DBG
    register    int             i;
                int             n;

    dprintf3(( "ThunkMciCommand16 :" ));
    dprintf5(( " OrigDevice -> %lX", DeviceID ));

    n = sizeof(mciMessageNames) / sizeof(MCI_MESSAGE_NAMES);
    for ( i = 0; i < n; i++ ) {
        if ( mciMessageNames[i].uMsg == OrigCommand ) {
            break;
        }
    }
    dprintf3(( "OrigCommand  -> 0x%lX", (DWORD)OrigCommand ));

    //
    // Special case MCI_STATUS.  I get loads of these from mplayer.
    // I only want to display MCI_STATUS messages if the debug level is
    // set to level 3, that way I won't get swamped with them.
    //
    if ( mciMessageNames[i].uMsg != MCI_STATUS ) {
        if ( i != n ) {
            dprintf2(( "Command Name -> %s", mciMessageNames[i].lpstMsgName ));
        }
        else {
            dprintf2(( "Command Name -> UNKNOWN COMMAND (%x)", OrigCommand ));
        }
    }
    else {
        dprintf3(( "Command Name -> MCI_STATUS" ));
    }

    dprintf5(( "OrigFlags    -> 0x%lX", OrigFlags ));
    dprintf5(( "OrigParms    -> 0x%lX", lp16OrigParms ));
#endif

    //
    // Thunk the generic params.  These are common to all mci devices.
    //
    ThunkGenericParms( &OrigFlags, lp16OrigParms,
                       (PMCI_GENERIC_PARMS)pNewParms );

    //
    // We thunk the MCI_OPEN command and all other commands that contain a
    // "ReservedX" field in their PARMS structure here.  We mask out each
    // flag as it is processed, if any flags are left we use the command
    // table to complete the thunk.
    //
    // The following commands have ReservedX fields:
    //      MCI_WINDOW
    //      MCI_SET
    //
    // This means that MOST COMMANDS GET THUNKED VIA THE COMMAND TABLE.
    //
    switch ( OrigCommand ) {

        case MCI_OPEN:
            //
            // MCI_OPEN is a special case message that I don't
            // how to deal with yet.
            //
            ThunkOpenCmd( &OrigFlags, (PMCI_OPEN_PARMS16)lp16OrigParms,
                          (PMCI_OPEN_PARMS)pNewParms );
            return 0;

            //
            // The next four commands have Reserved padding fields
            // these have to thunked manually.
            //

        case MCI_SET:
            ThunkSetCmd( DeviceID, &OrigFlags,
                         (PMCI_SET_PARMS16)lp16OrigParms,
                         (PMCI_SET_PARMS)pNewParms );
            break;

        case MCI_WINDOW:
            ThunkWindowCmd( DeviceID, &OrigFlags,
                            (PMCI_ANIM_WINDOW_PARMS16)lp16OrigParms,
                            (PMCI_ANIM_WINDOW_PARMS)pNewParms );
            break;

            //
            // Have to special case this command because the command table
            // is not correct.
            //
        case MCI_SETVIDEO:
            ThunkSetVideoCmd( &OrigFlags,
                              (PMCI_DGV_SETVIDEO_PARMS16)lp16OrigParms,
                              (LPMCI_DGV_SETVIDEO_PARMS)pNewParms );
            break;

            //
            // These two commands don't have any command extensions
            // so we return immediately.
            //
        case MCI_SYSINFO:
            ThunkSysInfoCmd( (PMCI_SYSINFO_PARMS16)lp16OrigParms,
                             (PMCI_SYSINFO_PARMS)pNewParms );
            return 0;

        case MCI_BREAK:
            ThunkBreakCmd( &OrigFlags,
                           (PMCI_BREAK_PARMS16)lp16OrigParms,
                           (PMCI_BREAK_PARMS)pNewParms );
            return 0;
    }

    //
    // Find the command table for the given command ID.
    // We always load the command table this is because the command table is
    // needed for UnThunking.
    //
    *lplpCommand = FindCommandItem( DeviceID, NULL, (LPWSTR)OrigCommand,
                                    NULL, puTable );
    //
    // If the command table is not found we return straight away.
    // Note that storage has been allocated for pNewParms and that the
    // MCI_WAIT and MCI_NOTIFY flags have been thunked.
    // We do not return an error here, but call mciSendCommand to
    // let it determine a suitable error code, we must also call
    // UnthunkMciCommand to free the allocated storage.
    //
    if ( *lplpCommand == NULL ) {
        dprintf(( "Command table not found !!" ));
        return 0;
    }
    dprintf4(( "Command table has been loaded -> 0x%lX", *lplpCommand ));

    //
    // If OrigFlags is not equal to 0 we still have work to do !
    // Note that this will be true for the majority of cases.
    //
    if ( OrigFlags ) {

        dprintf3(( "Thunking via command table" ));

        //
        // Now we thunk the command
        //
        return ThunkCommandViaTable( *lplpCommand, OrigFlags,
                                     (DWORD UNALIGNED *)lp16OrigParms,
                                     (LPBYTE)pNewParms );
    }

    return 0;

}

/*****************************Private*Routine******************************\
* ThunkGenericParms
*
* As we know that the first dword field is a Window handle
* this field is taken care of here.  Also the MCI_WAIT flag is
* masked out if it is set.
*
*
* History:
* 22-11-93 - StephenE - Created
*
\**************************************************************************/
VOID
ThunkGenericParms(
    PDWORD pOrigFlags,
    PMCI_GENERIC_PARMS16 lp16GenParms,
    PMCI_GENERIC_PARMS lp32GenParms
    )
{

    // Look for the notify flag and thunk accordingly
    //
    if ( *pOrigFlags & MCI_NOTIFY ) {

        dprintf4(( "AllocMciParmBlock: Got MCI_NOTIFY flag." ));

        lp32GenParms->dwCallback =
            (DWORD)HWND32( FETCHWORD( lp16GenParms->dwCallback ) );

    }

    *pOrigFlags &= ~(MCI_WAIT | MCI_NOTIFY);
}

/**********************************************************************\
* ThunkOpenCmd
*
* Thunk the Open mci command parms.
\**********************************************************************/
DWORD
ThunkOpenCmd(
    PDWORD pOrigFlags,
    PMCI_OPEN_PARMS16 lp16OpenParms,
    PMCI_OPEN_PARMS p32OpenParms
    )
{
    PMCI_ANIM_OPEN_PARMS    p32OpenAnimParms;
    PMCI_WAVE_OPEN_PARMS    p32OpenWaveParms;

    PMCI_ANIM_OPEN_PARMS16  lpOpenAnimParms16;
    PMCI_WAVE_OPEN_PARMS16  lp16OpenWaveParms;

    //
    // Now scan our way thru all the known MCI_OPEN flags, thunking as
    // necessary.
    //
    // Start at the Device Type field
    //
    if ( *pOrigFlags & MCI_OPEN_TYPE ) {
        if ( *pOrigFlags & MCI_OPEN_TYPE_ID ) {

            dprintf4(( "ThunkOpenCmd: Got MCI_OPEN_TYPE_ID flag." ));

            p32OpenParms->lpstrDeviceType =
                                (LPSTR)lp16OpenParms->lpstrDeviceType;

            dprintf5(( "lpstrDeviceType -> %ld", p32OpenParms->lpstrDeviceType ));

        }
        else {

            dprintf4(( "ThunkOpenCmd: Got MCI_OPEN_TYPE flag" ));

            p32OpenParms->lpstrDeviceType =
                GETVDMPTR( lp16OpenParms->lpstrDeviceType );

            dprintf5(( "lpstrDeviceType -> %s", p32OpenParms->lpstrDeviceType ));
            dprintf5(( "lpstrDeviceType -> 0x%lX", p32OpenParms->lpstrDeviceType ));
        }
    }

    //
    // Now do the Element Name field
    //
    if ( *pOrigFlags & MCI_OPEN_ELEMENT ) {
        if ( *pOrigFlags & MCI_OPEN_ELEMENT_ID ) {

            dprintf4(( "ThunkOpenCmd: Got MCI_OPEN_ELEMENT_ID flag" ));
            p32OpenParms->lpstrElementName =
                (LPSTR)( FETCHDWORD( lp16OpenParms->lpstrElementName ) );
            dprintf5(( "lpstrElementName -> %ld", p32OpenParms->lpstrElementName ));

        }
        else {

            dprintf4(( "ThunkOpenCmd: Got MCI_OPEN_ELEMENT flag" ));
            p32OpenParms->lpstrElementName =
                GETVDMPTR( lp16OpenParms->lpstrElementName );
            dprintf5(( "lpstrElementName -> %s", p32OpenParms->lpstrElementName ));
            dprintf5(( "lpstrElementName -> 0x%lX", p32OpenParms->lpstrElementName ));
        }
    }

    //
    // Now do the Alias Name field
    //
    if ( *pOrigFlags & MCI_OPEN_ALIAS  ) {

        dprintf4(( "ThunkOpenCmd: Got MCI_OPEN_ALIAS flag" ));
        p32OpenParms->lpstrAlias = GETVDMPTR( lp16OpenParms->lpstrAlias );
        dprintf5(( "lpstrAlias -> %s", p32OpenParms->lpstrAlias ));
        dprintf5(( "lpstrAlias -> 0x%lX", p32OpenParms->lpstrAlias ));
    }

    //
    // Clear the MCI_OPEN_SHAREABLE flag if it is set
    //
#if DBG
    if ( *pOrigFlags & MCI_OPEN_SHAREABLE ) {
        dprintf4(( "ThunkOpenCmd: Got MCI_OPEN_SHAREABLE flag." ));
    }
#endif

    *pOrigFlags &= ~(MCI_OPEN_SHAREABLE | MCI_OPEN_ALIAS |
                     MCI_OPEN_ELEMENT | MCI_OPEN_ELEMENT_ID |
                     MCI_OPEN_TYPE | MCI_OPEN_TYPE_ID);

    //
    // If we don't have any extended flags I can return now
    //
    if ( *pOrigFlags == 0 ) {
        return (DWORD)p32OpenParms;
    }

    //
    // If there are any flags left then these are intended for an extended
    // form of MCI open.  Three different forms are known, these being:
    //      MCI_ANIM_OPEN_PARMS
    //      MCI_OVLY_OPEN_PARMS
    //      MCI_WAVE_OPEN_PARMS
    //
    // If I could tell what sort of device I had I could thunk the
    // extensions with no problems, but we don't have a device ID yet
    // so I can't figure out what sort of device I have without parsing
    // the parameters that I already know about.
    //
    // But, I am in luck; MCI_WAVE_OPEN_PARMS has one extended parameter
    // dwBufferSeconds which has a MCI_WAVE_OPEN_BUFFER flag associated with
    // it.  This field is also a DWORD in the other two parms structures.
    //

    if ( *pOrigFlags & MCI_WAVE_OPEN_BUFFER ) {
        //
        // Set up the VDM ptr for lpOpenWaveParms16 to point to OrigParms
        //
        lp16OpenWaveParms = (PMCI_WAVE_OPEN_PARMS16)lp16OpenParms;
        p32OpenWaveParms  = (PMCI_WAVE_OPEN_PARMS)p32OpenParms;

        dprintf4(( "ThunkOpenCmd: Got MCI_WAVE_OPEN_BUFFER flag." ));
        p32OpenWaveParms->dwBufferSeconds =
                FETCHDWORD( lp16OpenWaveParms->dwBufferSeconds );
        dprintf5(( "dwBufferSeconds -> %ld", p32OpenWaveParms->dwBufferSeconds ));
    }


    //
    // Now look for MCI_ANIM_OPEN_PARM and MCI_OVLY_OPEN_PARMS extensions.
    // Set up the VDM ptr for lpOpenAnimParms16 to point to OrigParms
    //
    lpOpenAnimParms16 = (PMCI_ANIM_OPEN_PARMS16)lp16OpenParms;
    p32OpenAnimParms  = (PMCI_ANIM_OPEN_PARMS)p32OpenParms;

    //
    // Check MCI_ANIN_OPEN_PARENT flag, this also checks
    // the MCI_OVLY_OPEN_PARENT flag too.
    //
    if ( *pOrigFlags & MCI_ANIM_OPEN_PARENT ) {

        dprintf4(( "ThunkOpenCmd: Got MCI_Xxxx_OPEN_PARENT flag." ));

        p32OpenAnimParms->hWndParent =
            HWND32(FETCHWORD(lpOpenAnimParms16->hWndParent) );
    }

    //
    // Check MCI_ANIN_OPEN_WS flag, this also checks
    // the MCI_OVLY_OPEN_WS flag too.
    //
    if ( *pOrigFlags & MCI_ANIM_OPEN_WS ) {

        dprintf4(( "ThunkOpenCmd: Got MCI_Xxxx_OPEN_WS flag." ));

        p32OpenAnimParms->dwStyle =
            FETCHDWORD( lpOpenAnimParms16->dwStyle );

        dprintf5(( "dwStyle -> %ld", p32OpenAnimParms->dwStyle ));
    }

#if DBG
    //
    // Check the MCI_ANIN_OPEN_NOSTATIC flag
    //
    if ( *pOrigFlags & MCI_ANIM_OPEN_NOSTATIC ) {
        dprintf4(( "ThunkOpenCmd: Got MCI_ANIM_OPEN_NOSTATIC flag." ));
    }
#endif

    *pOrigFlags &= ~(MCI_ANIM_OPEN_NOSTATIC | MCI_ANIM_OPEN_WS |
                     MCI_ANIM_OPEN_PARENT | MCI_WAVE_OPEN_BUFFER);

    return (DWORD)p32OpenParms;
}

/**********************************************************************\
* ThunkSetCmd
*
* Thunk the ThunkSetCmd mci command parms.
*
* The following are "basic" flags that all devices must support.
*   MCI_SET_AUDIO
*   MCI_SET_DOOR_CLOSED
*   MCI_SET_DOOR_OPEN
*   MCI_SET_TIME_FORMAT
*   MCI_SET_VIDEO
*   MCI_SET_ON
*   MCI_SET_OFF
*
* The following are "extended" flags that "sequencer" devices support.
*   MCI_SEQ_SET_MASTER
*   MCI_SEQ_SET_OFFSET
*   MCI_SEQ_SET_PORT
*   MCI_SEQ_SET_SLAVE
*   MCI_SEQ_SET_TEMPO
*
* The following are "extended" flags that "waveaudio" devices support.
*   MCI_WAVE_INPUT
*   MCI_WAVE_OUTPUT
*   MCI_WAVE_SET_ANYINPUT
*   MCI_WAVE_SET_ANYOUTPUT
*   MCI_WAVE_SET_AVGBYTESPERSEC
*   MCI_WAVE_SET_BITSPERSAMPLES
*   MCI_WAVE_SET_BLOCKALIGN
*   MCI_WAVE_SET_CHANNELS
*   MCI_WAVE_SET_FORMAT_TAG
*   MCI_WAVE_SET_SAMPLESPERSEC
*
\**********************************************************************/
DWORD
ThunkSetCmd(
    MCIDEVICEID DeviceID,
    PDWORD pOrigFlags,
    PMCI_SET_PARMS16 lpSetParms16,
    PMCI_SET_PARMS lpSetParms32
    )
{

    //
    // The following pointers will be used to point to the original
    // 16-bit Parms structure.
    //
    PMCI_WAVE_SET_PARMS16       lpSetWaveParms16;
    PMCI_SEQ_SET_PARMS16        lpSetSeqParms16;

    //
    // The following pointers will be used to point to the new
    // 32-bit Parms structure.
    //
    PMCI_WAVE_SET_PARMS         lpSetWaveParms32;
    PMCI_SEQ_SET_PARMS          lpSetSeqParms32;


    //
    // GetDevCaps is used to determine what sort of device are dealing
    // with.  We need this information to determine if we should use
    // standard, wave or sequencer MCI_SET structure.
    //
    MCI_GETDEVCAPS_PARMS        GetDevCaps;
    DWORD                       dwRetVal;

    //
    // First do the fields that are common to all devices.  Thunk the
    // dwAudio field.
    //
    if ( *pOrigFlags & MCI_SET_AUDIO ) {

        dprintf4(( "ThunkSetCmd: Got MCI_SET_AUDIO flag." ));
        lpSetParms32->dwAudio = FETCHDWORD( lpSetParms16->dwAudio );
        dprintf5(( "dwAudio -> %ld", lpSetParms32->dwAudio ));
    }

    //
    // Thunk the dwTimeFormat field.
    //
    if ( *pOrigFlags & MCI_SET_TIME_FORMAT ) {

        dprintf4(( "ThunkSetCmd: Got MCI_SET_TIME_FORMAT flag." ));
        lpSetParms32->dwTimeFormat = FETCHDWORD( lpSetParms16->dwTimeFormat );
        dprintf5(( "dwTimeFormat -> %ld", lpSetParms32->dwTimeFormat ));
    }

#if DBG
    //
    // Mask out the MCI_SET_DOOR_CLOSED
    //
    if ( *pOrigFlags & MCI_SET_DOOR_CLOSED ) {
        dprintf4(( "ThunkSetCmd: Got MCI_SET_DOOR_CLOSED flag." ));
    }

    //
    // Mask out the MCI_SET_DOOR_OPEN
    //
    if ( *pOrigFlags & MCI_SET_DOOR_OPEN ) {
        dprintf4(( "ThunkSetCmd: Got MCI_SET_DOOR_OPEN flag." ));
    }

    //
    // Mask out the MCI_SET_VIDEO
    //
    if ( *pOrigFlags & MCI_SET_VIDEO ) {
        dprintf4(( "ThunkSetCmd: Got MCI_SET_VIDEO flag." ));
    }

    //
    // Mask out the MCI_SET_ON
    //
    if ( *pOrigFlags & MCI_SET_ON ) {
        dprintf4(( "ThunkSetCmd: Got MCI_SET_ON flag." ));
    }

    //
    // Mask out the MCI_SET_OFF
    //
    if ( *pOrigFlags & MCI_SET_OFF ) {
        dprintf4(( "ThunkSetCmd: Got MCI_SET_OFF flag." ));
    }
#endif

    *pOrigFlags &= ~(MCI_SET_AUDIO | MCI_SET_TIME_FORMAT |
                     MCI_SET_OFF | MCI_SET_ON | MCI_SET_VIDEO |
                     MCI_SET_DOOR_OPEN | MCI_SET_DOOR_CLOSED |
                     MCI_SET_AUDIO | MCI_SET_TIME_FORMAT );

    //
    // We have done all the standard flags.  If there are any flags
    // still set we must have an extended command.
    //
    if ( *pOrigFlags == 0 ) {
        return (DWORD)lpSetParms32;
    }

    //
    // Now we need to determine what type of device we are
    // dealing with.  We can do this by send an MCI_GETDEVCAPS
    // command to the device. (We might as well use the Unicode
    // version of mciSendCommand and avoid another thunk).
    //
    ZeroMemory( &GetDevCaps, sizeof(MCI_GETDEVCAPS_PARMS) );
    GetDevCaps.dwItem = MCI_GETDEVCAPS_DEVICE_TYPE;
    dwRetVal = mciSendCommandW( DeviceID, MCI_GETDEVCAPS, MCI_GETDEVCAPS_ITEM,
                                 (DWORD)&GetDevCaps );

    //
    // What do we do if dwRetCode is not equal to 0 ?  If this is the
    // case it probably means that we have been given a duff device ID,
    // anyway it is pointless to carry on with the thunk so I will clear
    // the *pOrigFlags variable and return.  This means that the 32 bit version
    // of mciSendCommand will get called with only half the message thunked,
    // but as there is probably already a problem with the device or
    // the device ID is duff, mciSendCommand should be able to work out a
    // suitable error code to return to the application.
    //
    if ( dwRetVal ) {
        *pOrigFlags = 0;
        return (DWORD)lpSetParms32;
    }

    switch ( GetDevCaps.dwReturn ) {

    case MCI_DEVTYPE_WAVEFORM_AUDIO:

        //
        // Set up the VDM ptr for lpSetWaveParms16 to point to OrigParms
        //
        dprintf3(( "ThunkSetCmd: Got a WaveAudio device." ));
        lpSetWaveParms16 = (PMCI_WAVE_SET_PARMS16)lpSetParms16;
        lpSetWaveParms32 = (PMCI_WAVE_SET_PARMS)lpSetParms32;

        //
        // Thunk the wInput field.
        //
        if ( *pOrigFlags & MCI_WAVE_INPUT ) {

            dprintf4(( "ThunkSetCmd: Got MCI_WAVE_INPUT flag." ));
            lpSetWaveParms32->wInput = FETCHWORD( lpSetWaveParms16->wInput );
            dprintf5(( "wInput -> %u", lpSetWaveParms32->wInput ));
        }

        //
        // Thunk the wOutput field.
        //
        if ( *pOrigFlags & MCI_WAVE_OUTPUT ) {

            dprintf4(( "ThunkSetCmd: Got MCI_WAVE_OUTPUT flag." ));
            lpSetWaveParms32->wOutput = FETCHWORD( lpSetWaveParms16->wOutput );
            dprintf5(( "wOutput -> %u", lpSetWaveParms32->wOutput ));
        }

        //
        // Thunk the wFormatTag field.
        //
        if ( *pOrigFlags & MCI_WAVE_SET_FORMATTAG ) {

            dprintf4(( "ThunkSetCmd: Got MCI_WAVE_SET_FORMATTAG flag." ));
            lpSetWaveParms32->wFormatTag =
                FETCHWORD( lpSetWaveParms16->wFormatTag );
            dprintf5(( "wFormatTag -> %u", lpSetWaveParms32->wFormatTag ));
        }

        //
        // Thunk the nChannels field.
        //
        if ( *pOrigFlags & MCI_WAVE_SET_CHANNELS ) {

            dprintf4(( "ThunkSetCmd: Got MCI_WAVE_SET_CHANNELS flag." ));
            lpSetWaveParms32->nChannels =
                FETCHWORD( lpSetWaveParms16->nChannels );
            dprintf5(( "nChannels -> %u", lpSetWaveParms32->nChannels ));
        }

        //
        // Thunk the nSamplesPerSec field.
        //
        if ( *pOrigFlags & MCI_WAVE_SET_SAMPLESPERSEC ) {

            dprintf4(( "ThunkSetCmd: Got MCI_WAVE_SET_SAMPLESPERSEC flag." ));
            lpSetWaveParms32->nSamplesPerSec =
                FETCHDWORD( lpSetWaveParms16->nSamplesPerSecond );
            dprintf5(( "nSamplesPerSec -> %u", lpSetWaveParms32->nSamplesPerSec ));
        }

        //
        // Thunk the nAvgBytesPerSec field.
        //
        if ( *pOrigFlags & MCI_WAVE_SET_AVGBYTESPERSEC ) {

            dprintf4(( "ThunkSetCmd: Got MCI_WAVE_SET_AVGBYTESPERSEC flag." ));
            lpSetWaveParms32->nAvgBytesPerSec =
                FETCHDWORD( lpSetWaveParms16->nAvgBytesPerSec );
            dprintf5(( "nAvgBytesPerSec -> %u", lpSetWaveParms32->nAvgBytesPerSec ));
        }

        //
        // Thunk the nBlockAlign field.
        //
        if ( *pOrigFlags & MCI_WAVE_SET_BLOCKALIGN ) {

            dprintf4(( "ThunkSetCmd: Got MCI_WAVE_SET_BLOCKALIGN flag." ));
            lpSetWaveParms32->nBlockAlign =
                FETCHWORD( lpSetWaveParms16->nBlockAlign );
            dprintf5(( "nBlockAlign -> %u", lpSetWaveParms32->nBlockAlign ));
        }

        //
        // Thunk the nBitsPerSample field.
        //
        if ( *pOrigFlags & MCI_WAVE_SET_BITSPERSAMPLE ) {
            dprintf4(( "ThunkSetCmd: Got MCI_WAVE_SET_BITSPERSAMPLE flag." ));
            lpSetWaveParms32->wBitsPerSample =
                FETCHWORD( lpSetWaveParms16->wBitsPerSample );
            dprintf5(( "wBitsPerSamples -> %u", lpSetWaveParms32->wBitsPerSample ));
        }

        //
        // Turn off all the flags in one go.
        //
        *pOrigFlags &= ~(MCI_WAVE_INPUT | MCI_WAVE_SET_BITSPERSAMPLE |
                         MCI_WAVE_SET_BLOCKALIGN | MCI_WAVE_SET_AVGBYTESPERSEC |
                         MCI_WAVE_SET_SAMPLESPERSEC | MCI_WAVE_SET_CHANNELS |
                         MCI_WAVE_SET_FORMATTAG | MCI_WAVE_OUTPUT);



        break;

    case MCI_DEVTYPE_SEQUENCER:
        //
        // Set up the VDM ptr for lpSetSeqParms16 to point to OrigParms
        //
        dprintf3(( "ThunkSetCmd: Got a Sequencer device." ));
        lpSetSeqParms16 = (PMCI_SEQ_SET_PARMS16)lpSetParms16;
        lpSetSeqParms32 = (PMCI_SEQ_SET_PARMS)lpSetParms32;

        //
        // Thunk the dwMaster field.
        //
        if ( *pOrigFlags & MCI_SEQ_SET_MASTER ) {

            dprintf4(( "ThunkSetCmd: Got MCI_SEQ_SET_MASTER flag." ));
            lpSetSeqParms32->dwMaster = FETCHDWORD( lpSetSeqParms16->dwMaster );
            dprintf5(( "dwMaster -> %ld", lpSetSeqParms32->dwMaster ));
        }

        //
        // Thunk the dwPort field.
        //
        if ( *pOrigFlags & MCI_SEQ_SET_PORT ) {

            dprintf4(( "ThunkSetCmd: Got MCI_SEQ_SET_PORT flag." ));
            lpSetSeqParms32->dwPort = FETCHDWORD( lpSetSeqParms16->dwPort );
            dprintf5(( "dwPort -> %ld", lpSetSeqParms32->dwPort ));
        }

        //
        // Thunk the dwOffset field.
        //
        if ( *pOrigFlags & MCI_SEQ_SET_OFFSET ) {

            dprintf4(( "ThunkSetCmd: Got MCI_SEQ_SET_OFFSET flag." ));
            lpSetSeqParms32->dwOffset= FETCHDWORD( lpSetSeqParms16->dwOffset );
            dprintf5(( "dwOffset -> %ld", lpSetSeqParms32->dwOffset ));
        }

        //
        // Thunk the dwSlave field.
        //
        if ( *pOrigFlags & MCI_SEQ_SET_SLAVE ) {

            dprintf4(( "ThunkSetCmd: Got MCI_SEQ_SET_SLAVE flag." ));
            lpSetSeqParms32->dwSlave = FETCHDWORD( lpSetSeqParms16->dwSlave );
            dprintf5(( "dwSlave -> %ld", lpSetSeqParms32->dwSlave ));
        }

        //
        // Thunk the dwTempo field.
        //
        if ( *pOrigFlags & MCI_SEQ_SET_TEMPO ) {

            dprintf4(( "ThunkSetCmd: Got MCI_SEQ_SET_TEMPO flag." ));
            lpSetSeqParms32->dwTempo = FETCHDWORD( lpSetSeqParms16->dwTempo );
            dprintf5(( "dwTempo -> %ld", lpSetSeqParms32->dwTempo ));
        }

        //
        // Turn off all the flags in one go.
        //
        *pOrigFlags &= ~(MCI_SEQ_SET_MASTER | MCI_SEQ_SET_PORT |
                         MCI_SEQ_SET_OFFSET | MCI_SEQ_SET_SLAVE |
                         MCI_SEQ_SET_TEMPO);
        break;

    }

    return (DWORD)lpSetParms32;
}

/**********************************************************************\
* ThunkSetVideoCmd
*
* Thunk the SetVideo mci command parms.
*
\**********************************************************************/
DWORD
ThunkSetVideoCmd(
    PDWORD pOrigFlags,
    PMCI_DGV_SETVIDEO_PARMS16 lpSetParms16,
    LPMCI_DGV_SETVIDEO_PARMS lpSetParms32
    )
{

    if ( *pOrigFlags & MCI_DGV_SETVIDEO_ITEM ) {

        dprintf4(( "ThunkSetVideoCmd: Got MCI_DGV_SETVIDEO_ITEM flag." ));
        lpSetParms32->dwItem = FETCHDWORD( lpSetParms16->dwItem );
        dprintf5(( "dwItem -> %ld", lpSetParms32->dwItem ));
    }

    if ( *pOrigFlags & MCI_DGV_SETVIDEO_VALUE ) {

        if ( lpSetParms32->dwItem == MCI_DGV_SETVIDEO_PALHANDLE ) {

            HPAL16  hpal16;

            dprintf4(( "ThunkSetVideoCmd: Got MCI_DGV_SETVIDEO_PALHANDLE." ));

            hpal16 = (HPAL16)LOWORD( FETCHDWORD( lpSetParms16->dwValue ) );
            lpSetParms32->dwValue = (DWORD)HPALETTE32( hpal16 );
            dprintf5(( "\t-> 0x%X", hpal16 ));

        }
        else {

            dprintf4(( "ThunkSetVideoCmd: Got an MCI_INTEGER." ));
            lpSetParms32->dwValue = FETCHDWORD( lpSetParms16->dwValue );
            dprintf5(( "dwValue -> %ld", lpSetParms32->dwValue ));
        }
    }

#if DBG
    //
    // Turn off the MCI_SET_ON FLAG.
    //
    if ( *pOrigFlags & MCI_SET_ON ) {
        dprintf4(( "ThunkSetVideoCmd: Got MCI_SET_ON flag." ));
    }

    //
    // Turn off the MCI_SET_OFF FLAG.
    //
    if ( *pOrigFlags & MCI_SET_OFF ) {
        dprintf4(( "ThunkSetVideoCmd: Got MCI_SET_OFF flag." ));
    }
#endif

    *pOrigFlags &= ~(MCI_DGV_SETVIDEO_ITEM | MCI_DGV_SETVIDEO_VALUE |
                     MCI_SET_ON | MCI_SET_OFF);


    return (DWORD)lpSetParms32;

}


/**********************************************************************\
* ThunkSysInfoCmd
*
* Thunk the SysInfo mci command parms.
\**********************************************************************/
DWORD
ThunkSysInfoCmd(
    PMCI_SYSINFO_PARMS16 lpSysInfo16,
    PMCI_SYSINFO_PARMS lpSysInfo32
    )
{

    //
    // Thunk the dwRetSize, dwNumber and wDeviceType parameters.
    //
    lpSysInfo32->dwRetSize = FETCHDWORD( lpSysInfo16->dwRetSize );
    dprintf5(( "dwRetSize -> %ld", lpSysInfo32->dwRetSize ));

    lpSysInfo32->dwNumber = FETCHDWORD( lpSysInfo16->dwNumber );
    dprintf5(( "dwNumber -> %ld", lpSysInfo32->dwNumber ));

    lpSysInfo32->wDeviceType = (UINT)FETCHWORD( lpSysInfo16->wDeviceType );
    dprintf5(( "wDeviceType -> %ld", lpSysInfo32->wDeviceType ));

    //
    // Thunk lpstrReturn
    //
    if ( lpSysInfo32->dwRetSize > 0 ) {

        lpSysInfo32->lpstrReturn = GETVDMPTR( lpSysInfo16->lpstrReturn );
        dprintf5(( "lpstrReturn -> 0x%lX", lpSysInfo16->lpstrReturn ));
    }
    else {
        dprintf1(( "ThunkSysInfoCmd: lpstrReturn is 0 bytes long !!!" ));

        /* lpstrReturn has been set to NULL by ZeroMemory above */
    }

    return (DWORD)lpSysInfo32;

}

/**********************************************************************\
* ThunkBreakCmd
*
* Thunk the Break mci command parms.
\**********************************************************************/
DWORD
ThunkBreakCmd(
    PDWORD pOrigFlags,
    PMCI_BREAK_PARMS16 lpBreak16,
    PMCI_BREAK_PARMS lpBreak32
    )
{
    //
    // Check for the MCI_BREAK_KEY flag
    //
    if ( *pOrigFlags & MCI_BREAK_KEY ) {
        dprintf4(( "ThunkBreakCmd: Got MCI_BREAK_KEY flag." ));
        lpBreak32->nVirtKey = (int)FETCHWORD( lpBreak16->nVirtKey );
        dprintf5(( "nVirtKey -> %d", lpBreak32->nVirtKey ));
    }

    //
    // Check for the MCI_BREAK_HWND flag
    //
    if ( *pOrigFlags & MCI_BREAK_HWND ) {
        dprintf4(( "ThunkBreakCmd: Got MCI_BREAK_HWND flag." ));
        lpBreak32->hwndBreak = HWND32(FETCHWORD(lpBreak16->hwndBreak));
    }
    return (DWORD)lpBreak32;

}

/**********************************************************************\
* ThunkWindowCmd
*
* Thunk the mci Window command parms.
\**********************************************************************/
DWORD
ThunkWindowCmd(
    MCIDEVICEID DeviceID,
    PDWORD pOrigFlags,
    PMCI_ANIM_WINDOW_PARMS16 lpAniParms16,
    PMCI_ANIM_WINDOW_PARMS lpAniParms32
    )
{
    //
    // GetDevCaps is used to determine what sort of device are dealing
    // with.  We need this information to determine if we should use
    // overlay or animation MCI_WINDOW structure.
    //
    MCI_GETDEVCAPS_PARMS        GetDevCaps;
    DWORD                       dwRetVal;

    //
    // Now we need to determine what type of device we are
    // dealing with.  We can do this by send an MCI_GETDEVCAPS
    // command to the device. (We might as well use the Unicode
    // version of mciSendCommand and avoid another thunk).
    //
    ZeroMemory( &GetDevCaps, sizeof(MCI_GETDEVCAPS_PARMS) );
    GetDevCaps.dwItem = MCI_GETDEVCAPS_DEVICE_TYPE;
    dwRetVal = mciSendCommandW( DeviceID, MCI_GETDEVCAPS, MCI_GETDEVCAPS_ITEM,
                                (DWORD)&GetDevCaps );
    //
    // What do we do if dwRetCode is not equal to 0 ?  If this is the
    // case it probably means that we have been given a duff device ID,
    // anyway it is pointless to carry on with the thunk so I will clear
    // the *pOrigFlags variable and return.  This means that the 32 bit version
    // of mciSendCommand will get called with only half the message thunked,
    // but as there is probably already a problem with the device or
    // the device ID is duff, mciSendCommand should be able to work out a
    // suitable error code to return to the application.
    //
    if ( dwRetVal ) {
        *pOrigFlags = 0;
        return (DWORD)lpAniParms32;
    }

    //
    // Do we have an Animation or Overlay device type ?
    // Because Animation and Overlay have identical flags and
    // parms structures they can share the same code.
    //
    if ( GetDevCaps.dwReturn == MCI_DEVTYPE_ANIMATION
      || GetDevCaps.dwReturn == MCI_DEVTYPE_OVERLAY
      || GetDevCaps.dwReturn == MCI_DEVTYPE_DIGITAL_VIDEO ) {

        //
        // Check for the MCI_ANIM_WINDOW_TEXT
        //
        if ( *pOrigFlags & MCI_ANIM_WINDOW_TEXT ) {

            dprintf4(( "ThunkWindowCmd: Got MCI_Xxxx_WINDOW_TEXT flag." ));

            lpAniParms32->lpstrText = GETVDMPTR( lpAniParms16->lpstrText );

            dprintf5(( "lpstrText -> %s", lpAniParms32->lpstrText ));
            dprintf5(( "lpstrText -> 0x%lX", lpAniParms32->lpstrText ));

        }

        //
        // Check for the MCI_ANIM_WINDOW_HWND flag
        //
        if ( *pOrigFlags & MCI_ANIM_WINDOW_HWND ) {

            dprintf4(( "ThunkWindowCmd: Got MCI_Xxxx_WINDOW_HWND flag." ));
            lpAniParms32->hWnd = HWND32( FETCHWORD( lpAniParms16->hWnd ) );
            dprintf5(( "hWnd -> 0x%lX", lpAniParms32->hWnd ));
        }

        //
        // Check for the MCI_ANIM_WINDOW_STATE flag
        //
        if ( *pOrigFlags & MCI_ANIM_WINDOW_STATE ) {

            dprintf4(( "ThunkWindowCmd: Got MCI_Xxxx_WINDOW_STATE flag." ));
            lpAniParms32->nCmdShow = FETCHWORD( lpAniParms16->nCmdShow );
            dprintf5(( "nCmdShow -> 0x%lX", lpAniParms32->nCmdShow ));
        }

#if DBG
        //
        // Check for the MCI_ANIM_WINDOW_DISABLE_STRETCH flag
        //
        if ( *pOrigFlags & MCI_ANIM_WINDOW_DISABLE_STRETCH ) {
            dprintf4(( "ThunkWindowCmd: Got MCI_Xxxx_WINDOW_DISABLE_STRETCH flag." ));
        }

        //
        // Check for the MCI_ANIM_WINDOW_ENABLE_STRETCH flag
        //
        if ( *pOrigFlags & MCI_ANIM_WINDOW_ENABLE_STRETCH ) {
            dprintf4(( "ThunkWindowCmd: Got MCI_Xxxx_WINDOW_ENABLE_STRETCH flag." ));
        }
#endif

        *pOrigFlags &= ~(MCI_ANIM_WINDOW_TEXT | MCI_ANIM_WINDOW_HWND |
                         MCI_ANIM_WINDOW_STATE |
                         MCI_ANIM_WINDOW_DISABLE_STRETCH |
                         MCI_ANIM_WINDOW_ENABLE_STRETCH );
    }

    return (DWORD)lpAniParms32;
}


/**********************************************************************\
*  ThunkCommandViaTable
*
\**********************************************************************/
int
ThunkCommandViaTable(
    LPWSTR lpCommand,
    DWORD dwFlags,
    DWORD UNALIGNED *pdwOrig16,
    LPBYTE pNewParms
    )
{

#if DBG
    static  LPSTR   f_name = "ThunkCommandViaTable: ";
#endif

    LPWSTR  lpFirstParameter;

    UINT    wID;
    DWORD   dwValue;

    UINT    wOffset16, wOffset1stParm16;
    UINT    wOffset32, wOffset1stParm32;

    UINT    wParamSize;

    DWORD   dwParm16;
    PDWORD  pdwParm32;

    DWORD   dwMask = 1;

    //
    // Calculate the size of this command parameter block in terms
    // of bytes, then get a VDM pointer to the OrigParms.
    //
    dprintf3(( "%s16 bit Parms -> %lX", f_name, pdwOrig16 ));

    //
    // Skip past command entry
    //
    lpCommand = (LPWSTR)((LPBYTE)lpCommand +
                    mciEatCommandEntry( lpCommand, NULL, NULL ));
    //
    // Get the next entry
    //
    lpFirstParameter = lpCommand;

    //
    // Skip past the DWORD return value
    //
    wOffset1stParm32 = wOffset1stParm16 = 4;

    lpCommand = (LPWSTR)((LPBYTE)lpCommand +
                    mciEatCommandEntry( lpCommand, &dwValue, &wID ));
    //
    // If it is a return value, skip it
    //
    if ( wID == MCI_RETURN ) {

        //
        // Look for a string return type, these are a special case.
        //
        if ( dwValue == MCI_STRING ) {

            DWORD   dwStrlen;
            LPSTR   *lplpStr;

            //
            // Get string pointer and length
            //
            dwParm16 = FETCHDWORD(*(LPDWORD)((LPBYTE)pdwOrig16 + 4));
            dwStrlen = FETCHDWORD(*(LPDWORD)((LPBYTE)pdwOrig16 + 8));

            //
            // Copy string pointer
            //
            lplpStr = (LPSTR *)(pNewParms + 4);
            if ( dwStrlen > 0 ) {
                *lplpStr = GETVDMPTR( dwParm16 );
                dprintf5(( "%sReturn string -> 0x%lX", f_name, *lplpStr ));
                dprintf5(( "%sReturn length -> 0x%lX", f_name, dwStrlen ));
            }

            //
            // Copy string length
            //
            pdwParm32 = (LPDWORD)(pNewParms + 8);
            *pdwParm32 = dwStrlen;
        }

        //
        // Adjust the offset of the first parameter.  Remember that RECTS
        // are a different size in 16-bit world.
        //
        wParamSize = mciGetParamSize( dwValue, wID );
        wOffset1stParm16 += (dwValue == MCI_RECT ? sizeof(RECT16) : wParamSize);
        wOffset1stParm32 += wParamSize;

        //
        // Save the new first parameter
        //
        lpFirstParameter = lpCommand;
    }

    //
    // Walk through each flag
    //
    while ( dwMask != 0 ) {

        //
        // Is this bit set?
        //
        if ( (dwFlags & dwMask) != 0 ) {

            wOffset16 = wOffset1stParm16;
            wOffset32 = wOffset1stParm32;
            lpCommand = (LPWSTR)((LPBYTE)lpFirstParameter +
                                         mciEatCommandEntry( lpFirstParameter,
                                                             &dwValue, &wID ));

            //
            // What parameter uses this bit?
            //
            while ( wID != MCI_END_COMMAND && dwValue != dwMask ) {

                wParamSize = mciGetParamSize( dwValue, wID );
                wOffset16 += (wID == MCI_RECT ? sizeof( RECT16 ) : wParamSize);
                wOffset32 += wParamSize;

                if ( wID == MCI_CONSTANT ) {

                    while ( wID != MCI_END_CONSTANT ) {

                        lpCommand = (LPWSTR)((LPBYTE)lpCommand +
                                mciEatCommandEntry( lpCommand, NULL, &wID ));
                    }
                }
                lpCommand = (LPWSTR)((LPBYTE)lpCommand +
                             mciEatCommandEntry( lpCommand, &dwValue, &wID ));
            }

            if ( wID != MCI_END_COMMAND ) {

                //
                // Thunk the argument if there is one.  The argument is at
                // wOffset16 from the start of OrigParms.
                // This offset is in bytes.
                //
                dprintf5(( "%sOffset 16 -> 0x%lX", f_name, wOffset16 ));
                dprintf5(( "%sOffset 32 -> 0x%lX", f_name, wOffset32 ));

                if ( wID != MCI_FLAG ) {
                    dwParm16 = FETCHDWORD(*(LPDWORD)((LPBYTE)pdwOrig16 + wOffset16));
                    pdwParm32 = (LPDWORD)(pNewParms + wOffset32);
                }

                switch ( wID ) {

                    case MCI_STRING:
                        {
                            LPSTR   str16 = (LPSTR)dwParm16;
                            dprintf4(( "%sGot STRING flag -> 0x%lX", f_name, dwMask ));
                            *pdwParm32 = (DWORD)GETVDMPTR( str16 );
                            dprintf5(( "%s\t-> 0x%lX", f_name, *pdwParm32 ));
                            dprintf5(( "%s\t-> %s", f_name, *pdwParm32 ));
                        }
                        break;

                    case MCI_HWND:
                        {
                            HWND16  hwnd16;
                            dprintf4(( "%sGot HWND flag -> 0x%lX", f_name, dwMask ));
                            hwnd16 = (HWND16)LOWORD( dwParm16 );
                            *pdwParm32 = (DWORD)HWND32( hwnd16 );
                            dprintf5(( "\t-> 0x%X", hwnd16 ));
                        }
                        break;

                    case MCI_HPAL:
                        {
                            HPAL16  hpal16;
                            dprintf4(( "%sGot HPAL flag -> 0x%lX", f_name, dwMask ));
                            hpal16 = (HPAL16)LOWORD( dwParm16 );
                            *pdwParm32 = (DWORD)HPALETTE32( hpal16 );
                            dprintf5(( "\t-> 0x%X", hpal16 ));
                        }
                        break;

                    case MCI_HDC:
                        {
                            HDC16   hdc16;
                            dprintf4(( "%sGot HDC flag -> 0x%lX", f_name, dwMask ));
                            hdc16 = (HDC16)LOWORD( dwParm16 );
                            *pdwParm32 = (DWORD)HDC32( hdc16 );
                            dprintf5(( "\t-> 0x%X", hdc16 ));
                        }
                        break;

                    case MCI_RECT:
                        {
                            PRECT16 pRect16 = (PRECT16)((LPBYTE)pdwOrig16 + wOffset16);
                            PRECT   pRect32 = (PRECT)pdwParm32;

                            dprintf4(( "%sGot RECT flag -> 0x%lX", f_name, dwMask ));
                            pRect32->top    = (LONG)pRect16->top;
                            pRect32->bottom = (LONG)pRect16->bottom;
                            pRect32->left   = (LONG)pRect16->left;
                            pRect32->right  = (LONG)pRect16->right;
                        }
                        break;

                    case MCI_CONSTANT:
                    case MCI_INTEGER:
                        dprintf4(( "%sGot INTEGER flag -> 0x%lX", f_name, dwMask ));
                        *pdwParm32 = dwParm16;
                        dprintf5(( "\t-> 0x%lX", dwParm16 ));
                        break;
                }
            }
        }

        //
        // Go to the next flag
        //
        dwMask <<= 1;
    }
    return 0;
}


/**********************************************************************\
*
* UnThunkMciCommand16
*
* This function "unthunks" a 32 bit mci send command request.
*
* The ideas behind this function were stolen from UnThunkWMMsg16,
* see wmsg16.c
*
\**********************************************************************/
int
UnThunkMciCommand16(
    MCIDEVICEID devID,
    UINT OrigCommand,
    DWORD OrigFlags,
    PMCI_GENERIC_PARMS16 lp16GenericParms,
    PDWORD NewParms,
    LPWSTR lpCommand,
    UINT uTable
    )
{
    BOOL        fReturnValNotThunked = FALSE;

#if DBG
    static      LPSTR   f_name = "UnThunkMciCommand16: ";
    register    int     i;
                int     n;

    dprintf3(( "UnThunkMciCommand :" ));
    n = sizeof(mciMessageNames) / sizeof(MCI_MESSAGE_NAMES);
    for ( i = 0; i < n; i++ ) {
        if ( mciMessageNames[i].uMsg == OrigCommand ) {
            break;
        }
    }
    dprintf3(( "OrigCommand -> %lX", (DWORD)OrigCommand ));
    dprintf3(( "       Name -> %s", i != n ? mciMessageNames[i].lpstMsgName : "Unkown Name" ));

    dprintf5(( "  OrigFlags -> %lX", OrigFlags ));
    dprintf5(( "  OrigParms -> %lX", lp16GenericParms ));
    dprintf5(( "   NewParms -> %lX", NewParms ));

    //
    // If NewParms is 0 we shouldn't be here, I haven't got an assert
    // macro, but the following we do the same thing.
    //
    if ( NewParms == 0 ) {
        dprintf(( "%scalled with NewParms == NULL !!", f_name ));
        dprintf(( "Call StephenE NOW !!" ));
        DebugBreak();
    }
#endif

    //
    // We have to do a manual unthunk of MCI_SYSINFO because the
    // command table is not consistent.  As a command table should be
    // available now we can load it and then use it to unthunk MCI_OPEN.
    //
    switch ( OrigCommand ) {

    case MCI_OPEN:
        UnThunkOpenCmd( (PMCI_OPEN_PARMS16)lp16GenericParms,
                        (PMCI_OPEN_PARMS)NewParms );
        break;

    case MCI_SYSINFO:
#if DBG
        UnThunkSysInfoCmd( OrigFlags,
                           (PMCI_SYSINFO_PARMS)NewParms );
#endif
        break;

    case MCI_STATUS:
        UnThunkStatusCmd( devID, OrigFlags,
                          (DWORD UNALIGNED *)lp16GenericParms,
                          (DWORD)NewParms );
        break;

    default:
        fReturnValNotThunked = TRUE;
        break;
    }

    //
    // Do we have a command table ?  It is possible that we have
    // a custom command but we did not find a custom command table, in which
    // case we should just free the pNewParms storage.
    //
    if ( lpCommand != NULL ) {

        //
        // We now parse the custom command table to see if there is a
        // return field in the parms structure.
        //
        dprintf3(( "%sUnthunking via command table", f_name ));
        UnThunkCommandViaTable( lpCommand,
                                (DWORD UNALIGNED *)lp16GenericParms,
                                (DWORD)NewParms, fReturnValNotThunked );

        //
        // Now we have finished with the command table we should unlock it.
        //
        dprintf4(( "%sUnlocking custom command table", f_name ));
        mciUnlockCommandTable( uTable );
    }

    return 0;
}


/**********************************************************************\
* UnThunkOpenCmd
*
* UnThunk the Open mci command parms.
\**********************************************************************/
VOID
UnThunkOpenCmd(
    PMCI_OPEN_PARMS16 lpOpenParms16,
    PMCI_OPEN_PARMS lpOpenParms32
    )
{
    WORD                 wDevice;

    dprintf4(( "Copying Device ID." ));

    wDevice = LOWORD( lpOpenParms32->wDeviceID );
    STOREWORD( lpOpenParms16->wDeviceID, wDevice );

    dprintf5(( "wDeviceID -> %u", wDevice ));

}


#if DBG
/**********************************************************************\
* UnThunkSysInfoCmd
*
* UnThunk the SysInfo mci command parms.
\**********************************************************************/
VOID
UnThunkSysInfoCmd(
    DWORD OrigFlags,
    PMCI_SYSINFO_PARMS lpSysParms
    )
{
    //
    // Had better check that we did actually allocate
    // a pointer.
    //
    if ( lpSysParms->lpstrReturn && lpSysParms->dwRetSize ) {

       