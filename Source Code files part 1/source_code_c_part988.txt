
        if ( NULL != pRequest )
        {
            pRequest->Release();
        }

        m_RequestQueue.RemoveAt( 0 );       
    }
}

BOOL CAdapThread::Init( void )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Initializes the control variables
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    if ( !m_fOk )
    {
        if ( ( m_hEventQuit = CreateEvent( NULL, TRUE, FALSE, NULL ) ) != NULL )
        {
            if ( ( m_hSemReqPending = CreateSemaphore( NULL, 0, 0x7FFFFFFF, NULL ) ) != NULL )
            {
                if ( ( m_hThreadReady = CreateEvent( NULL, TRUE, FALSE, NULL ) ) != NULL )
                {
                    m_fOk = TRUE;
                }
            }
        }
    }

    if ( !m_fOk )
    {
        ERRORTRACE( ( LOG_WMIADAP, "CAdapThread::Init() failed.\n" ) );
    }

    return m_fOk;
}

BOOL CAdapThread::Clear( BOOL fClose )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Clears the control variables and thread variables
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    CInCritSec  ics(&m_cs);

    // Don't close the handles unless we've been told to.

    m_fOk = FALSE;
    
    if ( NULL != m_hEventQuit )
    {
        if ( fClose )
        {
            CloseHandle( m_hEventQuit );
        }

        m_hEventQuit = NULL;
    }

    if ( NULL != m_hSemReqPending )
    {
        if ( fClose )
        {
            CloseHandle( m_hSemReqPending );
        }

        m_hSemReqPending = NULL;
    }

    if ( NULL != m_hThread )
    {
        if ( fClose )
        {
            CloseHandle( m_hThread );
        }

        m_hThread = NULL;
    }

    m_dwThreadId = 0;

    return TRUE;
}

HRESULT CAdapThread::Enqueue( CAdapThreadRequest* pRequest )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Add a request to the request queue
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_NO_ERROR;
    
    // Ensure that the thread has started
    // ==================================

    hr = Begin();
    
    if ( SUCCEEDED( hr ) )
    {
        // We will use a new one for EVERY operation
        HANDLE  hEventDone = CreateEvent( NULL, TRUE, FALSE, NULL );

        if ( NULL != hEventDone )
        {
            // Let the request know about the new event handle
            // ===========================================

            pRequest->SetWhenDoneHandle( hEventDone );

            // Auto-lock the queue
            // ===================

            CInCritSec  ics( &m_cs );

            try
            {
                // Add the request to the queue 
                // ============================
        
                m_RequestQueue.Add( (void*) pRequest );
                pRequest->AddRef();
                
                ReleaseSemaphore( m_hSemReqPending, 1, NULL );
            }
            catch(...)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    return TRUE;
}

HRESULT CAdapThread::Begin( void )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  If the thread has not already started, then intializes the control variables, and starts 
//  the thread.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Verify that the thread does not already exist
    // =============================================

    if ( NULL == m_hThread )
    {
        // Coping will enter and exit the critical section
        CInCritSec  ics( &m_cs );

        // Double check the thread handle here in case somebody fixed us up while we were
        // waiting on the critical section.

        if ( NULL == m_hThread )
        {

            // Initialize the control variables
            // ================================

            if ( Init() )
            {
                // Makes sure the pending event semaphore is signalled once for each entry in the queue
                // ====================================================================================

                if ( m_RequestQueue.Size() > 0 )
                {
                    ReleaseSemaphore( m_hSemReqPending, m_RequestQueue.Size(), NULL );
                }

                // Start the thread
                // ================

                m_hThread = (HANDLE) _beginthreadex( NULL, 0, CAdapThread::ThreadProc, (void*) this,
                                        0, (unsigned int *) &m_dwThreadId );

                if ( NULL == m_hThread )
                {
                    hr = WBEM_E_FAILED;
                }
                else
                {
                    if ( WAIT_OBJECT_0 != WaitForSingleObject( m_hThreadReady, 60000 ) )
                    {
                        hr = WBEM_E_FAILED;
                        ERRORTRACE( ( LOG_WMIADAP, "Worker thread for %S could not be verified.\n", (LPCWSTR)m_pPerfLib->GetServiceName() ) );          
                        SetEvent( m_hEventQuit );
                    }
                    else
                    {
                        DEBUGTRACE( ( LOG_WMIADAP, "Worker thread for %S is 0x%x\n", (LPCWSTR)m_pPerfLib->GetServiceName(), m_dwThreadId ) );
                    }
                }
            }   
            else
            {
                hr = WBEM_E_FAILED;
            }

        }   // IF NULL == m_hThread

    }

    if ( FAILED( hr ) )
    {
        ERRORTRACE( ( LOG_WMIADAP, "CAdapThread::Begin() failed: %X.\n", hr ) );
    }

    return hr;
}

unsigned CAdapThread::ThreadProc( void * pVoid )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  This is the static entry point fo the worker thread.  It addref's the thread's perflib
//  (see comment below) and then calls the objects processing method.
//
////////////////////////////////////////////////////////////////////////////////////////////

{
    unsigned uRet;

    try
    {
        // The calling object
        // ==================

        CAdapThread* pThis = (CAdapThread*) pVoid;

        // The perflib to be processed
        // ===========================

        CAdapPerfLib* pPerfLib = pThis->m_pPerfLib;

        // In an attempt to avoid circular references, we are addrefing the performance library wrapper
        // instead of the thread object.  The thread object will be destructed by the perflib wrapper 
        // only after the final reference is released.  This thread is dependent on the perflib, but is 
        // by the thread wrapper.  As a result, when the thread has completed processing, if we indicate 
        // that we are finished with the perflib by releasing the perflib wrapper, then the thread wrapper 
        // may destroyed at the same time.  Note the use of auto-release.

        if ( NULL != pPerfLib )
            pPerfLib->AddRef();

        CAdapReleaseMe arm( pPerfLib );

        // Call the processing method
        // ==========================

        uRet = pThis->RealEntry();
    }
    catch(...)
    {
        // <Gasp> We have been betrayed... try to write something to the error log
        // =======================================================================

        CriticalFailADAPTrace( "An unhandled exception has been thrown in a worker thread." );
    
        uRet = ERROR_OUTOFMEMORY;
    }

    return uRet;
}

unsigned CAdapThread::RealEntry( void )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  This is the method that contains the loop that processes the requests.  While there
//  are requests in the queue and the thread has not been instructed to terminate, then
//  grab a request and execute it.  When the request has completed, then signal the completion
//  event to tell the originating thread that the request has been satisfied.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HANDLE  ahEvents[2];

    // Use local copies of these in case we have some timing issue in which we get destructed
    // on another thread, but for some reason this guy keeps going.

    HANDLE  hPending = m_hSemReqPending,
            hQuit = m_hEventQuit;

    ahEvents[0] = hPending;
    ahEvents[1] = hQuit;

    DWORD   dwWait = 0;
    DWORD   dwReturn = 0;

    // Signal that everything is OK and we are ready to rock!
    // ======================================================

    if ( SetEvent( m_hThreadReady ) )
    {
        // If the m_hEventQuit event is signaled, or if it runs into a bizarre error,
        // exit loop, otherwise continue as long as there is requests in the queue
        // ==========================================================================

        while ( ( dwWait = WaitForMultipleObjects( 2, ahEvents, FALSE,  INFINITE ) ) == WAIT_OBJECT_0 )
        {
            // Check for the quit event, since if both events are signalled, we'll let this
            // guy take precedence
            if ( WaitForSingleObject( hQuit, 0 ) == WAIT_OBJECT_0 )
            {
                break;
            }

            // Get the next request from of the FIFO queue
            // ===========================================

            m_cs.Enter();
            CAdapThreadRequest* pRequest = (CAdapThreadRequest*) m_RequestQueue.GetAt( 0 );
            CAdapReleaseMe  armRequest( pRequest );

            m_RequestQueue.RemoveAt( 0 );
            m_cs.Leave();

            // Execute it
            // ==========

            dwReturn = pRequest->Execute( m_pPerfLib );

            // Fire the completion event
            // ==========================

            if ( NULL != pRequest->GetWhenDoneHandle() )
            {
                SetEvent( pRequest->GetWhenDoneHandle() );
            }
        }

        DEBUGTRACE( ( LOG_WMIADAP, "Thread 0x%x for %S is terminating\n", m_dwThreadId, (LPCWSTR)m_pPerfLib->GetServiceName() ) );

        // If the exit condition is not due to a signaled m_hEventQuit, then evaluate error
        // ================================================================================

        if ( WAIT_FAILED == dwWait )
        {
            dwReturn = GetLastError();
        }
    }

    if ( ERROR_SUCCESS != dwReturn )
    {
        ERRORTRACE( ( LOG_WMIADAP, "CAdapThread::RealEntry() for %S failed: %X.\n", (LPCWSTR)m_pPerfLib->GetServiceName(), dwReturn ) );
    }

    return dwReturn;
}

HRESULT CAdapThread::Shutdown( DWORD dwTimeout )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Performs a gentle shutdown of the thread by signaling the exit event.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_NO_ERROR;

    // Make sure that we are not killing ourself
    // =========================================

    if ( ( NULL != m_hThread ) && ( GetCurrentThreadId() != m_dwThreadId ) )
    {
        SetEvent( m_hEventQuit );
        DWORD   dwWait = WaitForSingleObject( m_hThread, dwTimeout );

        switch ( dwWait )
        {
        case WAIT_OBJECT_0:
            {
                m_hThread = NULL;
                hr = WBEM_S_NO_ERROR;
            }break;
        case WAIT_TIMEOUT:
            {
                hr = WBEM_E_FAILED;
            }break;
        default:
            {
                hr = WBEM_E_FAILED;
            }
        }

        if ( FAILED( hr ) )
        {
            ERRORTRACE( ( LOG_WMIADAP, "CAdapThread::Shutdown() failed.\n" ) );
        }
    }
    else
    {
        hr = WBEM_S_FALSE;
    }

    return hr;
}

HRESULT CAdapThread::Reset( void )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  This function will be called if a thread apparently got eaten, in which case, we're
//  not sure if it will come back or not.  So, we will clear our member data (not close anything)
//  and kick off a new processing thread.  Please note that this could leak handles, but then again,
//  it looks like somebody ate a thread, so there are other potential problems afoot here.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Signal the quit event so if the thread that is executing ever returns it will know to drop
    // out.  Clear can then rid us of the appropriate handles so we can start all over again.
    SetEvent( m_hEventQuit );

    // Scoping will enter and exit the critical section, so if anyone tries to enqueue any requests
    // while we are executing, we don't step all over each other.

    CInCritSec  ics( &m_cs );

    // Clear shouldn't close the handles
    Clear( FALSE );

    if ( Init() )
    {
        hr = Begin();
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    if ( FAILED( hr ) )
    {
        ERRORTRACE( ( LOG_WMIADAP, "CAdapThread::Reset() failed: %X.\n", hr ) );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\adap\adaputil.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ADAPUTIL.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wtypes.h>
#include <oleauto.h>
#include <winmgmtr.h>
#include "AdapUtil.h"

extern HANDLE g_hAbort;


HRESULT CAdapUtility::NTLogEvent( DWORD dwEventType,
								  DWORD dwEventID, 
                                  CInsertionString c1,
                                  CInsertionString c2,
                                  CInsertionString c3,
                                  CInsertionString c4,
                                  CInsertionString c5,
                                  CInsertionString c6,
                                  CInsertionString c7,
                                  CInsertionString c8,
                                  CInsertionString c9,
                                  CInsertionString c10 )
{
    HRESULT hr = WBEM_E_FAILED;
    CInsertionString ci[10];
    CEventLog el;

    // Also, during debug builds, we will BEEP for a second when we have decided to generate an
    // event

#ifdef _DEBUG
    MessageBeep( 0xFFFFFFFF );
#endif

    if ( el.Open() )
    {
        if ( el.Report( dwEventType, dwEventID, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10 ) )
        {
            hr = WBEM_NO_ERROR;
        }
    }

    el.Close();

    return hr;
}

HRESULT CAdapUtility::AdapTrace( const char* format, ... )
{
    HRESULT hr = WBEM_E_FAILED;

    va_list list;
    va_start( list, format ); 

    if ( 0 != DebugTrace(LOG_WMIADAP, format, list ) )
    {
        hr = WBEM_NO_ERROR;
    }
    va_end( list );

    return hr;
}

HRESULT CAdapUtility::Abort( WString wstrClassName, CAdapPerfLib* pPerfLib, HRESULT hRes ) 
{ 
    HRESULT hr = WBEM_NO_ERROR;

    if ( NULL != g_hAbort ) 
        SetEvent( g_hAbort ); 

    // Log an event
    CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
							  WBEM_MC_ADAP_GENERAL_OBJECT_FAILURE,
                              (LPWSTR) wstrClassName,
                              pPerfLib->GetLibraryName(),
                              CHex( hRes ) );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\adap\adaputil.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ADAPUTIL.H

Abstract:

History:

--*/


#ifndef _ADAPUTIL_H_
#define _ADAPUTIL_H_

#include "CWbemTime.h"
#include <wstring.h>
#include <flexarry.h>
#include <arrtempl.h>
#include <evtlog.h>
#include <wbemidl.h>
#include <wbemutil.h>
#include "Adapperf.h"

class CAdapUtility
{
public:
    static HRESULT NTLogEvent(DWORD dwEventType,
							  DWORD dwEventID,
                              CInsertionString c1 = CInsertionString(),
                              CInsertionString c2 = CInsertionString(),
                              CInsertionString c3 = CInsertionString(),
                              CInsertionString c4 = CInsertionString(),
                              CInsertionString c5 = CInsertionString(),
                              CInsertionString c6 = CInsertionString(),
                              CInsertionString c7 = CInsertionString(),
                              CInsertionString c8 = CInsertionString(),
                              CInsertionString c9 = CInsertionString(),
                              CInsertionString c10 = CInsertionString() );
    static HRESULT AdapTrace( const char* format, ... );

    static HRESULT Abort( WString wstrClassName, CAdapPerfLib* pPerfLib, HRESULT hRes );

};

#endif  //_ADAPUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\adap\adapreg.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ADAPREG.H

Abstract:

History:

--*/

// Use this guy to build a list of class objects we can retrieve via
// class name.  At this time, it just brute forces a class and a flex
// array, but could be modified to use an STL map just as easily.

#ifndef __ADAPREG_H__
#define __ADAPREG_H__

#include <wbemcomn.h>
#include "ntreg.h"
#include "adapcls.h"


#define HKEY_PERFORMANCE_TEXT       (( HKEY ) (ULONG_PTR)((LONG)0x80000050) )
#define HKEY_PERFORMANCE_NLSTEXT    (( HKEY ) (ULONG_PTR)((LONG)0x80000060) )

//
// common THROTTLING PARAMS
//
#define ADAP_IDLE_USER  3000
#define ADAP_IDLE_IO    500000
#define ADAP_LOOP_SLEEP 200
#define ADAP_MAX_WAIT   (2*60*1000)



#define	ADAP_LOCALE_KEY				L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\PerfLib"
#define WMI_ADAP_REVERSE_PERFLIB	L"WMIAPRPL"

#define ADAP_EVENT_MESSAGE_LENGTH   2048
#define ADAP_EVENT_MESSAGE_PREFIX   "An unhandled exception occured.  The following performance libraries were processed: "
#define ADAP_EVENT_MESSAGE_DELIM    L", "

// These are the various statuses we can set while ADAP is running
typedef enum
{
	eADAPStatusPending,
	eADAPStatusRunning,
	eADAPStatusProcessLibs,
	eADAPStatusCommit,
	eADAPStatusFinished
}	eADAPStatus;

// HRESULT	GetServicePID( WCHAR* wszService, DWORD* pdwPID );

class CPerfLibList
{
	WCHAR*				m_wszPerfLibList;
	CRITICAL_SECTION	m_csPerfLibList;

public:
	CPerfLibList() : m_wszPerfLibList( NULL )
	{
		InitializeCriticalSection( &m_csPerfLibList );
	}

	~CPerfLibList()
	{
		if ( NULL != m_wszPerfLibList )
			delete m_wszPerfLibList;

		DeleteCriticalSection( &m_csPerfLibList );
	}

	HRESULT AddPerfLib( WCHAR* wszPerfLib );
	HRESULT	HandleFailure();
};

class CAdapRegPerf : public CNTRegistry
///////////////////////////////////////////////////////////////////////////////
//
//	This is the control mechanism which interfaces with the 
//
///////////////////////////////////////////////////////////////////////////////
{
private:	
	// The unified 'master' class lists for both the raw and the cooked classes
	// ========================================================================

	CMasterClassList*	m_apMasterClassList[WMI_ADAP_NUM_TYPES];

	// The repository containing all names databases
	// =============================================

	CLocaleCache*		m_pLocaleCache;

	// The winmgmt synchronization members
	// ===================================

	DWORD				m_dwPID;
	HANDLE				m_hSyncThread;
	HANDLE				m_hTerminationEvent;
	BOOL				m_fQuit;

	IWbemServices*		m_pRootDefault;
	IWbemClassObject*	m_pADAPStatus;

	// Registry change notification members 
	// ====================================

	HKEY				m_hPerflibKey;
	HANDLE				m_hRegChangeEvent;

	//
	//

	CKnownSvcs * m_pKnownSvcs;
	BOOL m_bFull;

	// Private methods
	// ===============

	HRESULT ProcessLibrary( WCHAR* pwcsServiceName, BOOL bDelta );

	static unsigned int __stdcall GoGershwin( void * pParam );
	static LONG	__stdcall AdapUnhandledExceptionFilter( LPEXCEPTION_POINTERS lpexpExceptionInfo );

	HRESULT GetADAPStatusObject( void );
	void SetADAPStatus( eADAPStatus status );
	void GetTime( LPWSTR Buff );

public:
	CAdapRegPerf(BOOL bFull);
	~CAdapRegPerf();
	
	HRESULT Initialize(BOOL bDelta, BOOL bThrottle);

	HRESULT Dredge( BOOL bDelta, BOOL bThrottle ); 

	static HRESULT Clean();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\adap\adapreg.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ADAPREG.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wtypes.h>
#include <oleauto.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <malloc.h>
#include <tchar.h>
#include <process.h>
#include <arrtempl.h>
#include <cominit.h>
#include <winmgmtr.h>
#include <wbemcli.h>
#include <throttle.h>
#include <psapi.h>

#include "adapreg.h"
#include "perflibschema.h"
#include "WMIBroker.h"
#include "adaputil.h"
#include "winuser.h"
#include <comdef.h>

// Performance library processing list
// ===================================

CPerfLibList    g_PerfLibList;
HANDLE g_hAbort = NULL;


/////////////////////////////////////////////////////////////////////////////
//
//	returns the PID (the first found if many are there) if success
//	returns ZERO if fails 
//
/////////////////////////////////////////////////////////////////////////////


#define MAX_ITERATION 8
#define MAX_MODULE  (1024)

DWORD GetExecPid()
{
    DWORD ThisProc = 0;
    LONG lRet = 0;
    HKEY hKey;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        L"Software\\Microsoft\\WBEM\\CIMOM",
                        NULL,
                        KEY_READ,
                        &hKey);
    if (ERROR_SUCCESS == lRet)
    {    
        DWORD dwType;
        DWORD dwSize = sizeof(DWORD);
        RegQueryValueEx(hKey,
                      L"ProcessID",
                      NULL,
                      &dwType,
                      (BYTE*)&ThisProc,
                      &dwSize);
        RegCloseKey(hKey);
    }

    return ThisProc;
    
/* 
	if (!ExecName){
		return 0;
	}

	DWORD i=1;
	DWORD ThisProc = 0;
	DWORD Size = i*MAX_MODULE;
	DWORD cbReturned = 0;
	DWORD * pProcId = new DWORD[Size];
	do {
		if (pProcId && EnumProcesses(pProcId,Size*sizeof(DWORD),&cbReturned)){
			break;
		} else {
			i++;
			delete [] pProcId;
			Size = i*MAX_MODULE;
			pProcId = new DWORD[Size];
		}
	} while ( (i<=8) );

	cbReturned /= sizeof(DWORD);
	if (pProcId && cbReturned) {

		DWORD SizeModules = MAX_MODULE;
		HMODULE * pModules = new HMODULE[SizeModules];

		if (pModules){

			for (DWORD j=0;j<cbReturned;j++)
			{
				HANDLE hProcess = OpenProcess( PROCESS_QUERY_INFORMATION |
                                   PROCESS_VM_READ,
                                   FALSE, pProcId[j] );

				DWORD cbRetModules = 0;
				if (hProcess && 
					EnumProcessModules(hProcess,pModules,sizeof(DWORD)*SizeModules,&cbRetModules))
				{					
                    WCHAR ModuleName[MAX_PATH];
					if (GetModuleBaseNameW(hProcess,
						                  pModules[0], // first module is executable
									      ModuleName,
									      sizeof(ModuleName)/sizeof(WCHAR)))
					{					    
						if (0 == _wcsicmp(ExecName,ModuleName))
						{
                            ThisProc = pProcId[j];

							CloseHandle(hProcess);
							hProcess = NULL;

							break;
						}
					};
				}
				if (hProcess)
				{
				    CloseHandle(hProcess);
                    hProcess = NULL;
				}
			}

			delete [] pModules;
		}
	}
    
	if (pProcId){
		delete [] pProcId;
	}
	return ThisProc;
*/	
}


void DoResyncPerf( BOOL bDelta, BOOL bThrottle )
{
    DEBUGTRACE((LOG_WINMGMT,"ADAP Resync has started\n"));

    g_hAbort = CreateEventW( NULL, TRUE, FALSE, L"ADAP_ABORT");
    CCloseMe cmAbort( g_hAbort );

    if ( NULL != g_hAbort )
    {
        HRESULT hr = WBEM_S_NO_ERROR;

        CAdapRegPerf    regPerf(!bDelta);

        // Process each perflib that is registered on the system
        // =====================================================

		hr = regPerf.Initialize( bDelta, bThrottle );

		if ( SUCCEEDED( hr ) )
		{
			hr = regPerf.Dredge( bDelta, bThrottle );
		}

        if ( FAILED( hr ) )
        {
            CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_PROCESSING_FAILURE, CHex( hr ) );
        }
    }   

    DEBUGTRACE((LOG_WINMGMT,"ADAP Resync has completed\n"));

	return;
}

void DoClearADAP()
{
    DEBUGTRACE((LOG_WINMGMT,"ADAP registry reset has started\n"));

	CAdapRegPerf  regPerf(FALSE);

	regPerf.Clean();

    DEBUGTRACE((LOG_WINMGMT,"ADAP registry reset has completed\n"));
	
	return;
}


HRESULT DoReverseAdapterMaintenance( BOOL bThrottle );
/*
{
    ERRORTRACE((LOG_WMIADAP,"DoReverseAdapterDredge called"));
    return WBEM_NO_ERROR;
};
*/

///////////////////////////////////////////////////////////////////////////////
//
//	Entry Point
//	===========
//
///////////////////////////////////////////////////////////////////////////////

int WINAPI WinMain( 
  HINSTANCE hInstance,      // handle to current instance
  HINSTANCE hPrevInstance,  // handle to previous instance
  LPSTR szCmdLine,          // command line
  int nCmdShow              // show state
)
{

    try
    {
        // Ensure that we are NT5 or better
        // ================================
        OSVERSIONINFO   OSVer;

        OSVer.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );

        if ( GetVersionEx( &OSVer ) )
        {
            if ( ! ( ( VER_PLATFORM_WIN32_NT == OSVer.dwPlatformId ) && ( 5 <= OSVer.dwMajorVersion ) ) )
                return 0;
        }
        else
        {
            return 0;
        }

        // To avoid messy dialog boxes...
        // ==============================

        SetErrorMode( SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX );

        // Initialize COM.
        // ===============

        InitializeCom();
        CoInitializeSecurity( NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                EOAC_NONE, NULL );

		// Get the Winmgmt service PID
		// ===========================
		DWORD dwPID = GetExecPid();

        // The semaphore is used so that no more that two copies are running at any time.  
        // ==============================================================================

        WCHAR   wszObjName[256];
        HANDLE hSemaphore;

        swprintf(wszObjName, L"WMI_SysEvent_Semaphore_%d", dwPID);

        hSemaphore = CreateSemaphoreW(NULL, 2, 2, wszObjName);
        if(hSemaphore == NULL)
            return 0;

        CCloseMe cm1(hSemaphore);

        DWORD dwRet = WaitForSingleObject(hSemaphore, 0);
        if(dwRet != WAIT_OBJECT_0)
            return 0;

        // The mutex makes sure that multiple copies are sequential.
        // =========================================================

        HANDLE hMutex;

        hMutex = CreateMutexW( NULL, FALSE, L"ADAP_WMI_ENTRY" );
        if(hMutex == NULL)
            return 0;

        CCloseMe cm2(hMutex);

        switch ( WaitForSingleObject( hMutex, 400000) )
        {
        case WAIT_ABANDONED:
        case WAIT_OBJECT_0:
            {
			    BOOL bThrottle = FALSE;
			    BOOL bFull     = FALSE;
			    BOOL bDelta    = FALSE;
			    BOOL bReverse  = FALSE;
			    BOOL bClear    = FALSE;

                /*
                {
                	char pBuff[64];
                	sprintf(pBuff,"(ADAP) cmdline: %s\n",szCmdLine);
                	OutputDebugStringA(szCmdLine);
                }
                */
			    
			    if (szCmdLine)
			    {
			        while (*szCmdLine)
			        {
				        while(*szCmdLine && isspace((UCHAR)*szCmdLine)){
			    	        szCmdLine++;
			        	};        
				        if (*szCmdLine == '-' || *szCmdLine == '/')
			    	    {
			    	        szCmdLine++;
			    	        if (toupper((UCHAR)*szCmdLine) == 'T'){
			    	            bThrottle = TRUE;
			    	        } else if (toupper((UCHAR)*szCmdLine) == 'R') {
			    	            bReverse = TRUE;
			    	        } else if (toupper((UCHAR)*szCmdLine) == 'F') {
			    	            bFull = TRUE;
			       	        } else if (toupper((UCHAR)*szCmdLine) == 'D') {
			    	            bDelta = TRUE;
			    	        } else if (toupper((UCHAR)*szCmdLine) == 'C') {
			    	            bClear = TRUE;
			    	        }
			        	}
			            // move to the next white space
			            while(*szCmdLine && !isspace(*szCmdLine)){
			                szCmdLine++;
			            }

			        }
			    }
 
                if (bClear) // ClearADAP and/or ReverseAdap
                {
                    DoClearADAP();
                    if (bReverse)
                        DoReverseAdapterMaintenance( bThrottle );
                }
                else 
                {
					if (!bFull && !bDelta && !bReverse)
					{
						// no options, use Delta NO-THROTTLE
						DoResyncPerf(TRUE,FALSE);
					} 
					else 
					{
	                    if (bFull) {
	                        DoResyncPerf(FALSE,bThrottle);
	                    } 
	                    if (bDelta && !bFull) {
	                        DoResyncPerf(TRUE,bThrottle);
	                    }
	                    if (bReverse)
	                        DoReverseAdapterMaintenance( bThrottle );
					}
                }

                ReleaseMutex( hMutex );

            }break;
        }

        CoUninitialize();

        long l;
        ReleaseSemaphore(hSemaphore, 1, &l);
    }
    catch(...)
    {
        // <Gasp> We have been betrayed... try to write something to the error log
        // =======================================================================

        CriticalFailADAPTrace( "An unhandled exception has been thrown in the main thread." );
    }

    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
//  CPerfLibList
//
////////////////////////////////////////////////////////////////////////////////

HRESULT CPerfLibList::AddPerfLib( WCHAR* wszPerfLib )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    try
    {
        EnterCriticalSection( &m_csPerfLibList );
        {
            WCHAR*  wszNew = NULL;

            // Compute the size of the new buffer
            // ==================================

            DWORD   dwListSize = 0;
            
            if ( NULL != m_wszPerfLibList )
            {
                dwListSize += wcslen( m_wszPerfLibList );
                dwListSize += wcslen( ADAP_EVENT_MESSAGE_DELIM );
            }
            
            if ( NULL != wszPerfLib )
            {
                dwListSize += wcslen( wszPerfLib );
            }
            
            // Create the new buffer, and initialize the content
            // =================================================

            wszNew = new WCHAR[dwListSize + 1];

            // Copy the old buffer if required
            // ===============================

            if ( NULL != m_wszPerfLibList )
            {
                swprintf( wszNew, L"%s%s%s", m_wszPerfLibList, ADAP_EVENT_MESSAGE_DELIM, wszPerfLib );
                delete [] m_wszPerfLibList;
            }
            else
            {
                swprintf( wszNew, L"%s", wszPerfLib );
            }

            // And assign it to the static member
            // ==================================

            m_wszPerfLibList = wszNew;
        }
        LeaveCriticalSection( &m_csPerfLibList );
    }
    catch( unsigned int n )
    {
        // Handle the case where EnterCriticalSection() has throw an exception
        // ===================================================================

        if ( n == STATUS_INVALID_HANDLE )
            hr = WBEM_E_FAILED;
        else
            throw;
    }
    catch(...)
    {
        LeaveCriticalSection( &m_csPerfLibList );
        hr = WBEM_E_FAILED;
    }

    return hr;
}

HRESULT CPerfLibList::HandleFailure()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    try
    {
        char    szMessage[ADAP_EVENT_MESSAGE_LENGTH];

        EnterCriticalSection( &m_csPerfLibList );
        {
            DWORD dwMessageLen = strlen( ADAP_EVENT_MESSAGE_PREFIX );

            if ( NULL != m_wszPerfLibList )
            {
                dwMessageLen += wcslen( m_wszPerfLibList );
            }

            if ( ADAP_EVENT_MESSAGE_LENGTH > dwMessageLen )
            {
                sprintf( szMessage, "%s%S\n", ADAP_EVENT_MESSAGE_PREFIX, (NULL != m_wszPerfLibList) ? m_wszPerfLibList : L"<NULL>" );
            }
        }
        LeaveCriticalSection( &m_csPerfLibList );

        CriticalFailADAPTrace( szMessage );
    }
    catch( unsigned int n )
    {
        // Handle the case where EnterCriticalSection() has throw an exception
        // ===================================================================

        if ( n == STATUS_INVALID_HANDLE )
            hr = WBEM_E_FAILED;
        else
            throw;
    }
    catch(...)
    {
        LeaveCriticalSection( &m_csPerfLibList );
        hr = WBEM_E_FAILED;
    }

    return hr;
}
////////////////////////////////////////////////////////////////////////////////
//
//  Static Members
//
////////////////////////////////////////////////////////////////////////////////


LONG CAdapRegPerf::AdapUnhandledExceptionFilter( LPEXCEPTION_POINTERS lpexpExceptionInfo )
{

    // TODO: language specification

    g_PerfLibList.HandleFailure();
    
    return EXCEPTION_CONTINUE_SEARCH;
}

////////////////////////////////////////////////////////////////////////////////
//
//  CAdapRegPerf
//
////////////////////////////////////////////////////////////////////////////////

CAdapRegPerf::CAdapRegPerf(BOOL bFull)
: m_pLocaleCache( NULL ),
  m_fQuit( FALSE ),
  m_dwPID( 0 ),
  m_pADAPStatus( NULL ),
  m_pRootDefault( NULL ),
  m_hRegChangeEvent( NULL ),
  m_hPerflibKey( NULL ),
  m_pKnownSvcs(NULL),
  m_bFull(bFull)
{
	for ( DWORD dwType = 0; dwType < WMI_ADAP_NUM_TYPES; dwType++ )
		m_apMasterClassList[dwType] = NULL;
}


CAdapRegPerf::~CAdapRegPerf()
{
    // Status: COMPLETE
	// ================
    SetADAPStatus( eADAPStatusFinished);

    //
    // Add TimeStamp to registry if FULL
    //
    if (m_bFull)
    {
	    FILETIME FileTime;
	    GetSystemTimeAsFileTime(&FileTime);
	    LONG lRet;
	    HKEY hKey;

	    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
	                        L"Software\\Microsoft\\WBEM\\CIMOM",
	                        NULL,
	                        KEY_WRITE,
	                        &hKey);
	    if (ERROR_SUCCESS == lRet)
	    {    
	        RegSetValueEx(hKey,
	                      ADAP_TIMESTAMP_FULL,
	                      NULL,
	                      REG_BINARY,
	                      (BYTE*)&FileTime,
	                      sizeof(FILETIME));
	        RegCloseKey(hKey);
	    }
    }

    if (m_pKnownSvcs)
    {
        m_pKnownSvcs->Save();
        m_pKnownSvcs->Release();
    }

	// Cleanup
	// =======
	for ( DWORD dwType = 0; dwType < WMI_ADAP_NUM_TYPES; dwType++ )
	{
        if ( NULL != m_apMasterClassList[dwType] )
		{
			m_apMasterClassList[dwType]->Release();
		}
	}

    if ( NULL != m_pLocaleCache )
	{
        m_pLocaleCache->Release();
	}

    if ( NULL != m_pRootDefault )
    {
        m_pRootDefault->Release();
    }

    if ( NULL != m_pADAPStatus )
    {
        m_pADAPStatus->Release();
    }

	if ( NULL != m_hPerflibKey ) 
	{
		RegCloseKey( m_hPerflibKey );
	}

	if ( NULL != m_hRegChangeEvent )
	{
		CloseHandle( m_hRegChangeEvent );
	}

    SetEvent( m_hTerminationEvent );

}

HRESULT CAdapRegPerf::Initialize(BOOL bDelta, BOOL bThrottle)
///////////////////////////////////////////////////////////////////////////////
//
//	Initialize is responsible for setting up the dredging environment.  The 
//	unhandled exception filter is set to handle any exceptions throw and not 
//	handled by perforance libraries.  The termination event is a signal used
//	to identify when the process is being abnormally terminated.  The 
//	GoGershwin thread is suitably named since it is something to watch over
//	over the main process.  The locale cache is a cache of all locales 
//	available in the performance domain (enumeration of the names' database
//	subkeys).  The master class lists for both the cooked and the raw classes
//	represent the state of the performance objects in WMI.
//
//	Parameters:
//		none
//
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_NO_ERROR;

    // Initialize the root\default pointer. This will be used to track our status
	// ==========================================================================
    GetADAPStatusObject();

    // Set the filter for handling unhandled exceptions thrown in threads generated by the perflibs
    // ============================================================================================
    SetUnhandledExceptionFilter( CAdapRegPerf::AdapUnhandledExceptionFilter );

    // ADAP termination event
    // ======================
    m_hTerminationEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

    if ( NULL == m_hTerminationEvent )
    {
		hr = WBEM_E_FAILED;
	}

	// Open the registry key to be monitored
	// =====================================
	if ( SUCCEEDED( hr ) )
	{
		if ( ERROR_SUCCESS != RegOpenKeyEx( HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\Windows NT\\CurrentVersion\\Perflib"), 0, KEY_NOTIFY, &m_hPerflibKey ) )
		{
			hr = WBEM_E_FAILED;
		}
	}

	// Create the registry change event
	// ================================
	if ( SUCCEEDED( hr ) )
	{
		m_hRegChangeEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

		if ( NULL == m_hRegChangeEvent )
		{
			hr = WBEM_E_FAILED;
		}
	}

	// Create the names' database change notification
	// ==============================================
	// Note that we are only looking for subkeys being added or deleted.  We do
	// not want to monitor the registry values since the status and signature 
	// values may be changing throughout the course of the dredge, and we do 
	// not want to cause a re-cache unless a performance library is added 
	// (i.e. a performance subkey is added

	if ( SUCCEEDED( hr ) )
	{
		if ( ERROR_SUCCESS != RegNotifyChangeKeyValue( m_hPerflibKey, TRUE, REG_NOTIFY_CHANGE_LAST_SET, m_hRegChangeEvent, TRUE ) )
		{
			hr = WBEM_E_FAILED;
		}
	}

	// Get the WinMgmt Service PID
	// ===========================
	if ( SUCCEEDED( hr ) )
	{
		m_dwPID = GetExecPid();
	}
    // Create the "Someone to watch over me" thread 
    // ============================================
	if ( SUCCEEDED( hr ) )
	{
        UINT    nThreadID = 0;

        m_hSyncThread = ( HANDLE ) _beginthreadex( NULL, 0, CAdapRegPerf::GoGershwin, (void*) this, 0, &nThreadID );

        DEBUGTRACE ( ( LOG_WMIADAP, "The Monitor thread ID is 0x%x\n", nThreadID ) );
        
        if ( (HANDLE)-1 == m_hSyncThread )
        {
			hr = WBEM_E_FAILED;
		}
	}

	// Set up the locale cache
	// =======================
	if ( SUCCEEDED( hr ) )
	{
        m_pLocaleCache = new CLocaleCache( );

        if ( NULL == m_pLocaleCache )
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
		else
		{
			hr = m_pLocaleCache->Initialize();
		}
	}

	//
	//
	m_pKnownSvcs = new CKnownSvcs();
	if (m_pKnownSvcs)
    	m_pKnownSvcs->Load();

	// Set up the master class lists for the raw classes
	// =================================================
	if ( SUCCEEDED( hr ) )
    {
        m_apMasterClassList[WMI_ADAP_RAW_CLASS] = new CMasterClassList( m_pLocaleCache, m_pKnownSvcs );

        if ( NULL != m_apMasterClassList[WMI_ADAP_RAW_CLASS] )
        {
            hr = m_apMasterClassList[WMI_ADAP_RAW_CLASS]->BuildList( ADAP_PERF_RAW_BASE_CLASS, bDelta, bThrottle );
        }
		else
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}

	// Set up the master class lists for the cooked classes
	// ====================================================
	if ( SUCCEEDED( hr ) )
	{
		m_apMasterClassList[WMI_ADAP_COOKED_CLASS] = new CMasterClassList( m_pLocaleCache, m_pKnownSvcs );

		if ( NULL != m_apMasterClassList[WMI_ADAP_COOKED_CLASS] )
		{
			m_apMasterClassList[WMI_ADAP_COOKED_CLASS]->BuildList( ADAP_PERF_COOKED_BASE_CLASS, bDelta, bThrottle );
		}
		else
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
    }

#ifdef _DUMP_LIST
    m_apMasterClassList[WMI_ADAP_RAW_CLASS]->Dump();
    m_apMasterClassList[WMI_ADAP_COOKED_CLASS]->Dump();
#endif
    
	return hr;
}

HRESULT CAdapRegPerf::Dredge( BOOL bDelta, BOOL bThrottle )
///////////////////////////////////////////////////////////////////////////////
//
//	This is the entry point method which dredges the registry for performance 
//	counters and registers the classes in WMI.  This method enumerates all of 
//	the service keys looking for 'Performance' subkeys which indicate 
//	performance libraries.  If a library is discovered, then it is sent to
//	the ProcessLibrary method for, you guessed it, processing.
//
//	Parameters:
//		none
//
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    WString wstrServiceKey, 
            wstrPerformanceKey;

    if ( SUCCEEDED( hr ) )
    {
        // Status: PROCESSING
		// ==================
        SetADAPStatus( eADAPStatusProcessLibs);

        // Open the services key
        // =====================
        long    lError = Open( HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services" );

        if ( CNTRegistry::no_error == lError )
        {
            // Iterate through the services list
            // =================================
            DWORD   dwIndex = 0;
            DWORD   dwBuffSize = 0;
            WCHAR*  pwcsServiceName = NULL;

            while ( ( CNTRegistry::no_error == lError ) && ( !m_fQuit ) )
            {
                // Reset the processing status
                // ===========================
                hr = WBEM_NO_ERROR;

				if ( WAIT_OBJECT_0 == WaitForSingleObject( m_hRegChangeEvent, 0 ) )
				{
					m_pLocaleCache->Reset();
					dwIndex = 0;

					// Reset the event and reset the change notification
					ResetEvent( m_hRegChangeEvent );
					RegNotifyChangeKeyValue( m_hPerflibKey, TRUE, REG_NOTIFY_CHANGE_LAST_SET, m_hRegChangeEvent, TRUE );
				}

                // For each service name, we will check for a performance 
                // key and if it exists, we will process the library
                // ======================================================
                lError = Enum( dwIndex, &pwcsServiceName , dwBuffSize );

                if (bThrottle)
                {
                    HRESULT hrThr = Throttle(THROTTLE_USER|THROTTLE_IO,
                                          ADAP_IDLE_USER,
                                          ADAP_IDLE_IO,
                                          ADAP_LOOP_SLEEP,
                                          ADAP_MAX_WAIT);
                    if (THROTTLE_FORCE_EXIT == hrThr)
                    {
                        //OutputDebugStringA("(ADAP) Unthrottle command received\n");
                        bThrottle = FALSE;
                        UNICODE_STRING BaseUnicodeCommandLine = NtCurrentPeb()->ProcessParameters->CommandLine;
                        WCHAR * pT = wcschr(BaseUnicodeCommandLine.Buffer,L't');
                        if (0 == pT)
                        	pT = wcschr(BaseUnicodeCommandLine.Buffer,L'T');
                        if (pT)
                        {
                            *pT = L' ';
                            pT--;
                            *pT = L' ';                                       
                        }                        
                    }
                }

                if ( CNTRegistry::no_error == lError )
                {
                    try
                    {
                        // Create the perfomance key path
                        // ==============================
                        wstrServiceKey = L"SYSTEM\\CurrentControlSet\\Services\\";
                        wstrServiceKey += pwcsServiceName;

                        wstrPerformanceKey = wstrServiceKey;
                        wstrPerformanceKey += L"\\Performance";
                    }
                    catch( ... )
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }

                    if ( SUCCEEDED( hr ) )
                    {
                        CNTRegistry reg;

                        // Atempt to open the performance registry key for the service
                        // ===========================================================
                        long lPerfError = reg.Open( HKEY_LOCAL_MACHINE, wstrPerformanceKey );

                        if ( CNTRegistry::no_error == lPerfError )
                        {
                            // If we can open it, then we have found a perflib!  Process it 
							// unless it is the reverse provider perflib
                            // =============================================================

							if ( 0 != _wcsicmp( pwcsServiceName, WMI_ADAP_REVERSE_PERFLIB ) )
							{
								hr = ProcessLibrary( pwcsServiceName, bDelta );
							}
                        }
                        else if ( CNTRegistry::access_denied == lPerfError )
                        {
                            ServiceRec * pSvcRec = NULL;
                            if (0 == m_pKnownSvcs->Get(pwcsServiceName,&pSvcRec))
                            {
                                if (!pSvcRec->IsELCalled())
                                {
	                        	    CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
														  WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
														  (LPCWSTR)wstrPerformanceKey, L"Access Denied" );
								    pSvcRec->SetELCalled();
							    }
							}
                        }
                        else
                        {
                            // Otherwise, it is not a perflib service
                            // ======================================
                        }
                    }   
                }   
                else if ( CNTRegistry::no_more_items != lError )
                {
                    if ( CNTRegistry::out_of_memory == lError )
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }
                    else
                    {
                        hr = WBEM_E_FAILED;
                    }
                }

                dwIndex++;
            }

            // Cleanup the service name buffer
            // ===============================

            if ( NULL != pwcsServiceName )
            {
                delete [] pwcsServiceName;
                pwcsServiceName = NULL;
            }
        }
        else if ( CNTRegistry::access_denied == lError )
        {
            CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, L"SYSTEM\\CurrentControlSet\\Services\\", L"Access Denied" );
            hr = WBEM_E_FAILED;
        }
        else
        {
            hr = WBEM_E_FAILED;
        }

        // Now that we have a master class list that contains updated
        // data from all of the perflibs, commit any changes to WMI
        // ==========================================================
        if ( SUCCEEDED ( hr ) && ( !m_fQuit ) )
        {
            // Status: COMMIT
			// ==============
            SetADAPStatus( eADAPStatusCommit );

			for ( DWORD dwType = 0; dwType < WMI_ADAP_NUM_TYPES; dwType++ )
			{
				m_apMasterClassList[dwType]->Commit(bThrottle);
			}
        }
    }

    if ( SUCCEEDED( hr ) )
    {
        DEBUGTRACE( ( LOG_WMIADAP, "CAdapRegPerf::Dredge() for %S succeeded.\n", (WCHAR *)wstrServiceKey ) );
    }
    else
    {
        ERRORTRACE( ( LOG_WMIADAP, "CAdapRegPerf::Dredge() failed: %X.\n", hr ) );
    }

    return hr;
}


HRESULT CAdapRegPerf::Clean()
////////////////////////////////////////////////////////////////////////////////
//
//  This method enumerates all of the keys from the 
//  HLM\System\CurrentControlSet\Services and searches for a performance subkey.
//  If a performance subkey is discovered, then any information that was placed 
//  in the key by ADAP is deleted.
//
//  Parameters:
//      none
//
////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    WString wstrServiceKey,             // The path to the service key
            wstrPerformanceKey;         // The path to the performance subkey

    CNTRegistry regOuter;               // The registry object for the services enumeration

    // Open the services key
    // =====================
    long    lError = regOuter.Open( HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services" );

    if ( CNTRegistry::no_error == lError )
    {
        // Iterate through the services list
        // =================================
        DWORD   dwIndex = 0;
        DWORD   dwBuffSize = 0;
        WCHAR*  pwcsServiceName = NULL;

        while ( CNTRegistry::no_error == lError ) 
        {
            // Reset the processing status
            // ===========================
            hr = WBEM_NO_ERROR;

            // For each service name, we will check for a performance 
            // key and if it exists, we will process the library
            // ======================================================

            lError = regOuter.Enum( dwIndex, &pwcsServiceName , dwBuffSize );

            if ( CNTRegistry::no_error == lError )
            {
                try
                {
                    // Create the perfomance key path
                    // ==============================

                    wstrServiceKey = L"SYSTEM\\CurrentControlSet\\Services\\";
                    wstrServiceKey += pwcsServiceName;

                    wstrPerformanceKey = wstrServiceKey;
                    wstrPerformanceKey += L"\\Performance";
                }
                catch( ... )
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }

                if ( SUCCEEDED( hr ) )
                {
                    CNTRegistry regInner;       // The registry object for the performance subkey

                    // Atempt to open the performance registry key for the service
                    // ===========================================================
                    long lPerfError = regInner.Open( HKEY_LOCAL_MACHINE, wstrPerformanceKey );
    
                    if ( CNTRegistry::no_error == lPerfError )
                    {
                        // If we can open it, then we have found a perflib!  Clean it!
                        // =============================================================
                        regInner.DeleteValue( ADAP_PERFLIB_STATUS_KEY );
                        regInner.DeleteValue( ADAP_PERFLIB_SIGNATURE );
                        regInner.DeleteValue( ADAP_PERFLIB_SIZE );
                        regInner.DeleteValue( ADAP_PERFLIB_TIME );                        
                    }
                    else if ( CNTRegistry::access_denied == lPerfError )
                    {
                        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
												  WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
												  (LPCWSTR)wstrPerformanceKey, L"Access Denied" );
                    }
                    else
                    {
                        // Otherwise, it is not a perflib service
                        // ======================================
                    }
                }   
            }   
            else if ( CNTRegistry::no_more_items != lError )
            {
                if ( CNTRegistry::out_of_memory == lError )
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
                else
                {
                    hr = WBEM_E_FAILED;
                }
            }

            dwIndex++;
        }

        // Cleanup the service name buffer
        // ===============================
        if ( NULL != pwcsServiceName )
        {
            delete [] pwcsServiceName;
            pwcsServiceName = NULL;
        }
    }
    else if ( CNTRegistry::access_denied == lError )
    {
        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, L"SYSTEM\\CurrentControlSet\\Services\\", L"Access Denied" );
        hr = WBEM_E_FAILED;
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    if ( SUCCEEDED( hr ) )
    {
        DEBUGTRACE( ( LOG_WMIADAP, "CAdapRegPerf::Clean() succeeded.\n" ) );
    }
    else
    {
        ERRORTRACE( ( LOG_WMIADAP, "CAdapRegPerf::Clean() failed: %X.\n", hr ) );
    }

    return hr;
}

HRESULT CAdapRegPerf::ProcessLibrary( WCHAR* pwcsServiceName, BOOL bDelta )
///////////////////////////////////////////////////////////////////////////////
//
//	Once a performance library has been discovered, then it's schema must be 
//	retrieved and the performance library's class list compared to what is 
//	already in the WMI repository.  The comparison is achieved in the "Merge"
//	method of the master class list which extracts any classes from the perf 
//	lib's class list that are not already in the master class list.  The 
//	comparison occurs for both the raw and the cooked classes.
//
//	Parameters:
//		pwcsServiceName	- The name of the service to be processed
//
///////////////////////////////////////////////////////////////////////////////
{

    HRESULT hr = WBEM_NO_ERROR;

    try
    {
		// Add the name of the performance library to the perflib list
		// ===========================================================
		// The list is used for book keeping purposses to track processing
		// in the event of a perflib failure

        g_PerfLibList.AddPerfLib( pwcsServiceName );        

        // Construct and initialize the schema for the perflib
        // ===================================================
        DWORD LoadStatus = EX_STATUS_UNLOADED;
        CPerfLibSchema Schema( pwcsServiceName, m_pLocaleCache );
        hr = Schema.Initialize( bDelta, &LoadStatus );
        
        DEBUGTRACE(( LOG_WMIADAP,"CPerfLibSchema::Initialize for %S hr %08x\n",pwcsServiceName,hr));

		if ( !bDelta || ( bDelta && ( hr != WBEM_S_ALREADY_EXISTS ) ) )
		{
			// Update raw and cooked classes
			// =============================
			for ( DWORD dwType = 0; ( dwType < WMI_ADAP_NUM_TYPES ) && SUCCEEDED( hr ); dwType++ )
			{
				// Get the class list for classes from the perflib's schema
				// ========================================================
				CClassList* pClassList = NULL;

				hr = Schema.GetClassList( dwType, &pClassList );
				CAdapReleaseMe  rmClassList( pClassList );

				
                DEBUGTRACE(( LOG_WMIADAP,"GetClassList for %S hr %08x\n",pwcsServiceName,hr));
                
				if ( SUCCEEDED( hr ) )
				{
					// Merge the raw classes obtained from the perflib into the master class list
					// ==========================================================================
					hr = m_apMasterClassList[dwType]->Merge( pClassList, bDelta );

                    DEBUGTRACE(( LOG_WMIADAP,"m_apMasterClassList[%d]->Merge for %S hr %08x\n",dwType,pwcsServiceName,hr));
				}

				//if (bDelta && FAILED(hr)){
				//    // the class was not in the repository if we are here
				//    LoadStatus = EX_STATUS_UNLOADED;
				//}
			}
		};

        if (FAILED(hr) && (LoadStatus != EX_STATUS_LOADABLE)) 
        {
			for ( DWORD dwType = 0; ( dwType < WMI_ADAP_NUM_TYPES ) ; dwType++ )
			{
			    DEBUGTRACE((LOG_WMIADAP,"ProcessLibrary ForceStatus for %S hr = %08x\n",pwcsServiceName,hr));

			    DWORD NewStatus = ADAP_OBJECT_IS_DELETED;
			    
			    if (LoadStatus == EX_STATUS_UNLOADED)
			    {
			        NewStatus |= ADAP_OBJECT_IS_TO_BE_CLEARED;
			    }			    

			    m_apMasterClassList[dwType]->ForceStatus(pwcsServiceName,TRUE,NewStatus);
			}
		}
	}
    catch(...)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

unsigned int CAdapRegPerf::GoGershwin( void* pParam )
///////////////////////////////////////////////////////////////////////////////
//
//	The monitoring thread entry point
//
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    try 
    {
        CAdapRegPerf*   pThis = (CAdapRegPerf*)pParam;

        HANDLE          ahHandles[2];

        // If we don't have an initialized PID, then find one from WMI
        // ===========================================================

        if ( 0 == pThis->m_dwPID )
        {
            pThis->m_dwPID = GetExecPid();
        }
        
        // Get the process handle and wait for a signal
        // ============================================

        if ( SUCCEEDED( hr ) && ( 0 != pThis->m_dwPID ) )
        {
            ahHandles[0] = OpenProcess( SYNCHRONIZE, FALSE, pThis->m_dwPID );
            CCloseMe    cmProcess( ahHandles[0] );

            ahHandles[1] = pThis->m_hTerminationEvent;

            DWORD dwRet = WaitForMultipleObjects( 2, ahHandles, FALSE, INFINITE );

            switch ( dwRet )
            {
            case WAIT_FAILED:               // Something is wierd
            case WAIT_OBJECT_0:             // The service process
                {
                    pThis->m_fQuit = TRUE;  // Set the termination flag
                } break;
            case ( WAIT_OBJECT_0 + 1 ):     // The completion event
                {
                    // continue
                }break;
            }
        }
    }
    catch(...)
    {
        // <Gasp> We have been betrayed... try to write something to the error log
        // =======================================================================

        CriticalFailADAPTrace( "An unhandled exception has been thrown in the WMI monitoring thread." );
    }

    return 0;
}

HRESULT CAdapRegPerf::GetADAPStatusObject( void )
{
    IWbemLocator*   pLocator = NULL;

    HRESULT hr = CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, IID_IWbemLocator,
                    (void**) &pLocator );
    CReleaseMe  rm( pLocator );

    if ( SUCCEEDED( hr ) )
    {
        BSTR    bstrNameSpace = SysAllocString( L"root\\default" );
        BSTR    bstrInstancePath = SysAllocString( L"__ADAPStatus=@" );

        CSysFreeMe  sfm1( bstrNameSpace );
        CSysFreeMe  sfm2( bstrInstancePath );

        if ( NULL != bstrNameSpace && NULL != bstrInstancePath )
        {
            // Connect to Root\default and get hold of the status object
            hr = pLocator->ConnectServer(   bstrNameSpace,  // NameSpace Name
                                            NULL,           // UserName
                                            NULL,           // Password
                                            NULL,           // Locale
                                            0L,             // Security Flags
                                            NULL,           // Authority
                                            NULL,           // Wbem Context
                                            &m_pRootDefault     // Namespace
                                            );

            if ( SUCCEEDED( hr ) )
            {

                // Set Interface security
                hr = WbemSetProxyBlanket( m_pRootDefault, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
                    RPC_C_AUTHN_LEVEL_PKT,RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );

                if ( SUCCEEDED( hr ) )
                {
                    hr = m_pRootDefault->GetObject( bstrInstancePath, 0L, NULL, &m_pADAPStatus, NULL );

                    if ( SUCCEEDED( hr ) )
                    {
                        SetADAPStatus( eADAPStatusRunning );
                    }
                }
            }
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }

    }   // IF got locator

    return hr;
}

// Gets the time in the popular DMTF format
void CAdapRegPerf::GetTime( LPWSTR Buff )
{
    SYSTEMTIME st;
    int Bias=0;
    char cOffsetSign = '+';

    GetLocalTime( &st );

    TIME_ZONE_INFORMATION ZoneInformation;
    DWORD dwRet = GetTimeZoneInformation(&ZoneInformation);
    if(dwRet != TIME_ZONE_ID_UNKNOWN)
        Bias = -ZoneInformation.Bias;

    if(Bias < 0)
    {
        cOffsetSign = '-';
        Bias = -Bias;
    }


    swprintf(Buff, L"%4d%02d%02d%02d%02d%02d.%06d%c%03d", 
                st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, 
                st.wSecond, st.wMilliseconds*1000, cOffsetSign, Bias); 
}

// Sets the status back in WMI
void CAdapRegPerf::SetADAPStatus( eADAPStatus status )
{
    // Make sure we've got both our pointers
    if ( NULL != m_pRootDefault && NULL != m_pADAPStatus )
    {
        // We only need 25 characters for this
        WCHAR   wcsTime[32];
        
        _variant_t    var;

        // legacy fastprox behavior
        WCHAR pNum[16];
        wsprintfW(pNum,L"%u",status);
        var = pNum;

        HRESULT hr = m_pADAPStatus->Put( L"Status", 0L, &var, 0 );//CIM_UINT32 );

        if ( SUCCEEDED( hr ) )
        {
            // Set the time property if necessary
            if ( status == eADAPStatusRunning || status == eADAPStatusFinished )
            {
                GetTime( wcsTime );

                // This can fail
                try
                {
                    var =  wcsTime;
                }
                catch(...)
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }

                if ( SUCCEEDED( hr ) )
                {
                    hr = ( status == eADAPStatusRunning ?
                        m_pADAPStatus->Put( L"LastStartTime", 0L, &var, CIM_DATETIME ) :
                        m_pADAPStatus->Put( L"LastStopTime", 0L, &var, CIM_DATETIME ) );
                }

            }

            if ( SUCCEEDED( hr ) )
            {
                hr = m_pRootDefault->PutInstance( m_pADAPStatus, 0L, NULL, NULL );
            }

        }   // Set the Status property

    }   // Make sure we've got both pointers

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\adap\classbroker.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    CLASSBROKER.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <objbase.h>
#include <oaidl.h>
#include <winmgmtr.h>
#include "adaputil.h"
#include "classbroker.h"

#include <comdef.h>

struct _CookingTypeRec
{
	DWORD dwType;
	WCHAR wcsName[128];
}
g_aCookingRecs[] =
{
	0x00000000, L"PERF_COUNTER_RAWCOUNT_HEX",
	0x00000100,	L"PERF_COUNTER_LARGE_RAWCOUNT_HEX",
	0x00000B00, L"PERF_COUNTER_TEXT",
	0x00010000,	L"PERF_COUNTER_RAWCOUNT",
	0x00010100, L"PERF_COUNTER_LARGE_RAWCOUNT",
	0x00012000, L"PERF_DOUBLE_RAW",
	0x00400400,	L"PERF_COUNTER_DELTA",
	0x00400500,	L"PERF_COUNTER_LARGE_DELTA",
	0x00410400,	L"PERF_SAMPLE_COUNTER",
	0x00450400, L"PERF_COUNTER_QUEUELEN_TYPE",
	0x00450500, L"PERF_COUNTER_LARGE_QUEUELEN_TYPE",
	0x00550500,	L"PERF_COUNTER_100NS_QUEUELEN_TYPE",
	0x00650500, L"PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE",
	0x10410400,	L"PERF_COUNTER_COUNTER",
	0x10410500,	L"PERF_COUNTER_BULK_COUNT",
	0x20020400, L"PERF_RAW_FRACTION",
	0x20410500,	L"PERF_COUNTER_TIMER",
	0x20470500,	L"PERF_PRECISION_SYSTEM_TIMER",
	0x20510500,	L"PERF_100NSEC_TIMER",
	0x20570500,	L"PERF_PRECISION_100NS_TIMER",
	0x20610500,	L"PERF_OBJ_TIME_TIMER",
	0x20670500, L"PERF_PRECISION_OBJECT_TIMER",
	0x20C20400,	L"PERF_SAMPLE_FRACTION",
	0x21410500,	L"PERF_COUNTER_TIMER_INV",
	0x21510500,	L"PERF_100NSEC_TIMER_INV",
	0x22410500, L"PERF_COUNTER_MULTI_TIMER",
	0x22510500,	L"PERF_100NSEC_MULTI_TIMER",
	0x23410500,	L"PERF_COUNTER_MULTI_TIMER_INV",
	0x23510500, L"PERF_100NSEC_MULTI_TIMER_INV",
	0x30020400,	L"PERF_AVERAGE_TIMER",
	0x30240500,	L"PERF_ELAPSED_TIME",
	0x40000200, L"PERF_COUNTER_NODATA",
	0x40020500,	L"PERF_AVERAGE_BULK",
	0x40030401,	L"PERF_SAMPLE_BASE",
	0x40030402, L"PERF_AVERAGE_BASE",
	0x40030403, L"PERF_RAW_BASE",
	0x40030500, L"PERF_PRECISION_TIMESTAMP",
	0x40030503,	L"PERF_LARGE_RAW_BASE",
	0x42030500,	L"PERF_COUNTER_MULTI_BASE",
	0x80000000,	L"PERF_COUNTER_HISTOGRAM_TYPE",
};

HRESULT GetCounterTypeString( DWORD dwType, WCHAR** pwcsString )
{
	HRESULT hRes = WBEM_E_NOT_FOUND;

	DWORD	dwLeft = 0,
			dwRight = sizeof( g_aCookingRecs ) / sizeof( _CookingTypeRec ),
			dwMid = ( dwLeft + dwRight ) / 2;

	while ( ( dwLeft <= dwRight ) && FAILED( hRes ) )
	{
		if ( g_aCookingRecs[dwMid].dwType < dwType )
		{
			dwLeft = dwMid + 1;
		}
		else if ( g_aCookingRecs[dwMid].dwType > dwType )
		{
			dwRight = dwMid - 1;
		}
		else
		{
			*pwcsString = g_aCookingRecs[dwMid].wcsName;
			hRes = WBEM_NO_ERROR;
			break;
		}

		dwMid = ( dwLeft + dwRight ) / 2;
	}

	return hRes;
}

///////////////////////////////////////////////////////////////////////////////
//
//                              CAdapPerfClassElem
//
///////////////////////////////////////////////////////////////////////////////

CClassBroker::CClassBroker( IWbemClassObject* pBaseClass, 
						    WString wstrClassName, 
							CPerfNameDb* pDefaultNameDb )
:	m_pPerfObj( NULL ), 
	m_pBaseClass( pBaseClass ), 
	m_wstrClassName( wstrClassName ), 
	m_pDefaultNameDb( pDefaultNameDb )
{
	if ( NULL != m_pBaseClass )
		m_pBaseClass->AddRef();
    
	if ( NULL != m_pDefaultNameDb )
        m_pDefaultNameDb->AddRef();
}

CClassBroker::CClassBroker( PERF_OBJECT_TYPE* pPerfObj, 
                            BOOL bCostly, 
                            IWbemClassObject* pBaseClass, 
                            CPerfNameDb* pDefaultNameDb, 
                            WCHAR* pwcsServiceName ) 
:   m_pPerfObj( pPerfObj ), 
    m_bCostly( bCostly ),
    m_pBaseClass( pBaseClass ),
    m_pDefaultNameDb( pDefaultNameDb ),
    m_wstrServiceName( pwcsServiceName )
{
	if ( NULL != m_pBaseClass )
		m_pBaseClass->AddRef();

    if ( NULL != m_pDefaultNameDb )
        m_pDefaultNameDb->AddRef();
}

CClassBroker::~CClassBroker()
{
	if ( NULL != m_pBaseClass )
		m_pBaseClass->Release();

    if ( NULL != m_pDefaultNameDb )
        m_pDefaultNameDb->Release();
}

HRESULT CClassBroker::Generate( DWORD dwType, IWbemClassObject** ppObj )
///////////////////////////////////////////////////////////////////////////////
//
//	Generates a class based on the object BLOB passed in via the constructor
//
//	Parameters:
//		ppObj -		A pointer to the new class object interface pointer
//
///////////////////////////////////////////////////////////////////////////////
{
    IWbemClassObject*    pNewClass = NULL;

	// Create the new class
	// ====================
    HRESULT hr = m_pBaseClass->SpawnDerivedClass( 0L, &pNewClass );
    CReleaseMe  rmNewClass( pNewClass );

	// And initialize the data
	// =======================
    if ( SUCCEEDED( hr ) )
    {
		// Class name
		// ==========
        hr = SetClassName( dwType, pNewClass );

		// Class Qualifiers
		// ================
        if ( SUCCEEDED( hr ) )
        {
            hr = SetClassQualifiers( pNewClass, dwType, ( ADAP_DEFAULT_OBJECT == m_pPerfObj->ObjectNameTitleIndex ) );
        }

		// Standard Properties
		// ===================
        if ( SUCCEEDED( hr ) )
        {
            hr = AddDefaultProperties( pNewClass );
        }

		// Perf Counter Properties
		// =======================
        if ( SUCCEEDED( hr ) )
        {
            hr = EnumProperties( dwType, pNewClass );
        }

		// Return the class object interface
		// =================================
        if ( SUCCEEDED( hr ) )
        {
            hr = pNewClass->QueryInterface( IID_IWbemClassObject, (void**) ppObj );
        }
    }

    return hr;
}

HRESULT CClassBroker::SetClassName( DWORD dwType, IWbemClassObject* pClass )
///////////////////////////////////////////////////////////////////////////////
//
//  Sets the name of the new WMI class. The syntax is: 
//
//      Win32_Perf_<servicename>_<displayname>
//
//  where the service name is the name of the namespace and the display name 
//	is the name of the object located in the perf name database
//
//	Parameters:
//		pClass -	The object which requires the name
//
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_NO_ERROR;

	WString wstrObjectName;
	WString wstrTempSvcName;

    if ( 0 == m_wstrClassName.Length() )
    {
        try
        {
			switch( dwType )
			{
				case WMI_ADAP_RAW_CLASS:	m_wstrClassName = ADAP_PERF_RAW_BASE_CLASS L"_"; break;
				case WMI_ADAP_COOKED_CLASS: m_wstrClassName = ADAP_PERF_COOKED_BASE_CLASS L"_"; break;
				default:					hr = WBEM_E_INVALID_PARAMETER_ID; break;
			}
        }
        catch(...)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

		// Process the performance class name
		// ==================================
        if ( SUCCEEDED( hr ) )
        {
			// Get the performance class' display name 
			// =======================================
			hr = m_pDefaultNameDb->GetDisplayName( m_pPerfObj->ObjectNameTitleIndex, wstrObjectName );

			// If no object name was returned, then log an error
			// =================================================
			if ( FAILED( hr ) )
			{
				CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
										  WBEM_MC_ADAP_MISSING_OBJECT_INDEX,
										  m_pPerfObj->ObjectNameTitleIndex,
										  (LPCWSTR)m_wstrServiceName );
			}

			// Replace reserved characters with proper names
			// =============================================
            if ( SUCCEEDED( hr ) )
            {
                hr = ReplaceReserved( wstrObjectName );
            }

            // Remove whitespace and extraneous characters
			// ===========================================
			if ( SUCCEEDED( hr ) )
			{
				hr = RemoveWhitespaceAndNonAlphaNum( wstrObjectName );
			}
		}

		// Now do the same for the service name
		// ====================================
		if ( SUCCEEDED( hr ) )
		{
			// Get the service name 
			// ====================
            wstrTempSvcName = m_wstrServiceName;

			// Replace reserved characters with proper names
			// =============================================
            if ( SUCCEEDED( hr ) )
            {
                hr = ReplaceReserved( wstrTempSvcName );
            }

            // Remove whitespace and extraneous characters
			// ===========================================
            if ( SUCCEEDED( hr ) )
            {
                hr = RemoveWhitespaceAndNonAlphaNum( wstrTempSvcName );
            }
		}

		// Now we can build the rest of the name and try setting it in the object
		// ======================================================================
        if ( SUCCEEDED( hr ) )
        {
            try
            {
                m_wstrClassName += wstrTempSvcName;
                m_wstrClassName += L"_";
                m_wstrClassName += wstrObjectName;
                if ( m_bCostly )
                {
                    m_wstrClassName += "_Costly";
                }

            }
            catch( ... )
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
        }
    }

	// Set the class name in the WMI object
	// ====================================
    if ( SUCCEEDED( hr ) )
    {
        _variant_t var = (LPWSTR) m_wstrClassName;
        hr = pClass->Put( L"__CLASS", 0L, &var, CIM_STRING );
    }

    return hr;
}

HRESULT CClassBroker::RemoveWhitespaceAndNonAlphaNum( WString& wstr )
///////////////////////////////////////////////////////////////////////////////
//
//	Removes spaces, tabs, etc. and non-alphanumeric characters from the 
//	input string
//
//	Parameters:
//		wstr -	The string to be processed
//
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    WCHAR*    pWstr = wstr.UnbindPtr();

	CVectorDeleteMe<WCHAR> vdmWstr( pWstr );

    if ( NULL != pWstr )
    {
        try
        {
            WCHAR*  pNewWstr = new WCHAR[lstrlenW(pWstr) + 1];

            int x = 0,
                y = 0;

            // Dump all of the leading, trailing and internal whitespace
			// =========================================================
            for ( ; NULL != pWstr[x]; x++ )
            {
                if ( !iswspace( pWstr[x] ) && isunialphanum( pWstr[x] ) )
                {
                    pNewWstr[y] = pWstr[x];
                    y++;
                }
            }

            pNewWstr[y] = NULL;

            // This will cause the WString to acquire the new pointer
			// ======================================================
            wstr.BindPtr( pNewWstr );
        }
        catch(...)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    return hr;
}

HRESULT CClassBroker::ReplaceReserved( WString& wstr )
///////////////////////////////////////////////////////////////////////////////
//
//	This is a 2-pass filter.  First we must determine the size of the new buffer by counting
//	the number of replacement candidates, and, after creating the new buffer, we copy the 
//	data, replacing the restricted characters where required.
//
//	Replaces:
//		"/" with "Per", 
//		"%" with "Percent", 
//		"#" with "Number", 
//		"@" with "At", 
//		"&" with "And"
//
//	Parameters:
//		wstr - String to be processed
//
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    int x = 0,
        y = 0;

    // Get the data buffer for processing
	// ==================================
    WCHAR*  pWstr = wstr.UnbindPtr();

	CVectorDeleteMe<WCHAR> vdmWstr( pWstr );

    if ( NULL != pWstr )
    {
		// First pass: Count the number of reserved characters
		// ===================================================
        DWORD   dwNumSlashes = 0,
                dwNumPercent = 0,
                dwNumAt = 0,
                dwNumNumber = 0,
                dwNumAmper = 0,
                dwNumReserved = 0;

        for ( ; NULL != pWstr[x]; x++ )
        {
            switch ( pWstr[x] )
            {
                case    L'/':   dwNumSlashes++; dwNumReserved++;    break;
                case    L'%':   dwNumPercent++; dwNumReserved++;    break;
                case    L'@':   dwNumAt++;      dwNumReserved++;    break;
                case    L'#':   dwNumNumber++;  dwNumReserved++;    break;
                case    L'&':   dwNumAmper++;   dwNumReserved++;    break;
                default:                        break;
            }
        }

        try
        {
			// Create the new buffer
			// =====================
            DWORD   dwBuffSize = lstrlenW(pWstr) + 1 + ( 3 * dwNumSlashes ) + ( 7 * dwNumPercent ) +
                        ( 2 * dwNumAt ) + ( 6 * dwNumNumber ) + ( 3 * dwNumAmper );

            WCHAR*  pNewWstr = new WCHAR[dwBuffSize];

            // Second pass: Replace reserved characters
			// ========================================
            for ( x = 0; NULL != pWstr[x]; x++ )
            {
                BOOL AllIsUpper = FALSE;
                DWORD Cnt;
                switch ( pWstr[x] )
                {
                    case    L'/':   
                        // if all characters up to the end of string or to the next space are uppercase
                        for (Cnt=1;pWstr[x+Cnt] && pWstr[x+Cnt]!=' ';Cnt++)
                        {
                            if (isupper(pWstr[x+Cnt])) 
                            {
                                AllIsUpper = TRUE;
                            }
                            else 
                            {
                                AllIsUpper = FALSE;
                                break;
                            }
                        };
                        if (!AllIsUpper) 
                        {
                            lstrcpyW( &pNewWstr[y], L"Per" );
                            y+=3;
                        }
                        else
                        {
                            x++;
                            pNewWstr[y]=pWstr[x];
                            y++;
                        }
                        break;
                    case    L'%':   lstrcpyW( &pNewWstr[y], L"Percent" );   y+=7;   break;
                    case    L'@':   lstrcpyW( &pNewWstr[y], L"At" );        y+=2;   break;
                    case    L'#':   lstrcpyW( &pNewWstr[y], L"Number" );    y+=6;   break;
                    case    L'&':   lstrcpyW( &pNewWstr[y], L"And" );       y+=3;   break;
                    default:        pNewWstr[y] = pWstr[x];                 y++;    break;
                }
            }

            pNewWstr[y] = NULL;

            // This will cause the WString to acquire the new pointer
			// ======================================================
            wstr.BindPtr( pNewWstr );
        }
        catch(...)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//                              CLocaleClassBroker
//
////////////////////////////////////////////////////////////////////////////////////////////

CLocaleClassBroker::CLocaleClassBroker( IWbemClassObject* pBaseClass, 
                                        WString wstrClassName, 
                                        CPerfNameDb* pDefaultNameDb, 
                                        CPerfNameDb* pLocaleNameDb )
: CClassBroker( pBaseClass, wstrClassName, pDefaultNameDb ), 
  m_pLocaleNameDb( pLocaleNameDb )
{
    if ( NULL != m_pLocaleNameDb )
        m_pLocaleNameDb->AddRef();
}

CLocaleClassBroker::CLocaleClassBroker( PERF_OBJECT_TYPE* pPerfObj, 
                                        BOOL bCostly, 
                                        IWbemClassObject* pBaseClass, 
                                        CPerfNameDb* pDefaultNameDb, 
                                        CPerfNameDb* pLocaleNameDb,
                                        LANGID LangId,
                                        WCHAR* pwcsServiceName )
: m_pLocaleNameDb( pLocaleNameDb ), m_LangId( LangId ),
  CClassBroker( pPerfObj, bCostly, pBaseClass, pDefaultNameDb, pwcsServiceName )
{
    if ( NULL != m_pLocaleNameDb )
        m_pLocaleNameDb->AddRef();
}

CLocaleClassBroker::~CLocaleClassBroker()
{
    if ( NULL != m_pLocaleNameDb )
        m_pLocaleNameDb->Release();
}

HRESULT CLocaleClassBroker::SetClassQualifiers( IWbemClassObject* pClass, DWORD dwType, BOOL fIsDefault )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Sets the class' qualifiers per the localized object rules.  Note that the operations 
//	are performed directly on the IWbemClassObject
//
//	The following qualifiers will be added:
//		- Amendment
//		- Locale(0x0409)
//		- DisplayName (Amended flavor)
//		- Genericperfctr (signals that this is a generic counter)
//
//	Parameters:
//		pClass		- The object to be massaged
//		fIsDefault	- Indicator for the default object (not used in localized objects)
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    _variant_t var;

    try
    {
		IWbemQualifierSet* pQualSet = NULL;
		hr = pClass->GetQualifierSet( &pQualSet );
		CReleaseMe	rmQualSet( pQualSet );

		// Amendment
		// =========
		if ( SUCCEEDED( hr ) )
		{
			var = (bool)true;
			hr = pQualSet->Put( L"Amendment", &var, 0L );
		}

        // Locale
		// ======
        if ( SUCCEEDED( hr ) )
        {
            var.Clear();
            V_VT(&var) = VT_I4;
            V_I4(&var) = m_LangId;
            hr = pQualSet->Put( L"locale", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
        }

        // DisplayName
		// ===========
        if ( SUCCEEDED( hr ) )
        {
            LPCWSTR pwcsDisplayName = NULL;

            var.Clear();

			// Fetch the name from the Names' database
			// =======================================
            hr = m_pLocaleNameDb->GetDisplayName( m_pPerfObj->ObjectNameTitleIndex, &pwcsDisplayName );

            // If this is a localized Db, this is a benign error.  We will just pull the value 
            // from the default db (it must be there, we wouldn't have a class name if it didn't
			// =================================================================================
            if ( FAILED( hr ) )
            {
                hr = m_pDefaultNameDb->GetDisplayName( m_pPerfObj->ObjectNameTitleIndex, &pwcsDisplayName );
            }

            if ( SUCCEEDED( hr ) )
            {
                var = (LPWSTR) pwcsDisplayName ;
                hr = pQualSet->Put( L"DisplayName", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | WBEM_FLAVOR_AMENDED );
            }
        }

        // Genericperfctr
		// ==============
        if ( SUCCEEDED(hr) )
        {
            var = (bool)true; 
            hr = pQualSet->Put( L"genericperfctr", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
        }

        // Perfindex
		// =========
				
		if ( SUCCEEDED( hr ) )
		{
			var.Clear();
			V_VT(&var) = VT_I4;
			V_I4(&var) = m_pPerfObj->ObjectNameTitleIndex;
			hr = pQualSet->Put( L"perfindex", (VARIANT*)&var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
		}

    }
    catch(...)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    if ( FAILED( hr ) )
    {
        // Something whacky happened: log an event
		// =======================================
        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
								  WBEM_MC_ADAP_GENERAL_OBJECT_FAILURE,
                                  (LPCWSTR)m_wstrClassName,
                                  (LPCWSTR)m_wstrServiceName,
                                  CHex( hr ) );
    }

    return hr;
}

HRESULT CLocaleClassBroker::AddDefaultProperties( IWbemClassObject* pObj )
////////////////////////////////////////////////////////////////////////////////////////////
//
//	Ignored for localized classes
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    return WBEM_S_NO_ERROR;
}

HRESULT CLocaleClassBroker::EnumProperties( DWORD dwType, IWbemClassObject* pObj )
////////////////////////////////////////////////////////////////////////////////////////////
//
//	Ignored for localized classes
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    return WBEM_S_NO_ERROR;
}

HRESULT CLocaleClassBroker::SetPropertyQualifiers( PERF_COUNTER_DEFINITION* pCtrDefinition, 
												   DWORD dwType,
                                                   BOOL fIsDefault,
                                                   LPCWSTR pwcsPropertyName, 
                                                   IWbemClassObject* pClass, 
                                                   BOOL bBase )
////////////////////////////////////////////////////////////////////////////////////////////
//
//	Adds localization qualifiers for the counter properties
//
//  The following qualifiers will be added:
//		- DisplayName (Amended flavor)
//
//	Properties:
//		pCtrDefinition		- The portion of the performance blob related to the property
//		fIsDefault			- Flag identifying default property
//		pwcsPropertyName	- The name of the property
//		pClass				- The WMI class containing the property
//		bBase				- Base property identifier
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    _variant_t    var;
    _variant_t    varHelp;
    
    try
    {
        // DisplayName
		// ===========
        if ( SUCCEEDED( hr ) )
        {
            LPCWSTR pwcsDisplayName = NULL;
            LPCWSTR pwcsHelpName = NULL;

			// Fetch the name from the Names' database
			// =======================================
            if ( !bBase )
            {
                hr = m_pLocaleNameDb->GetDisplayName( pCtrDefinition->CounterNameTitleIndex, &pwcsDisplayName );

	            // If this is a localized Db, this is a benign error.  We will just pull the value 
		        // from the default db (it must be there, we wouldn't have a class name if it didn't
				// =================================================================================
                if ( FAILED( hr ) )
                {
                    hr = m_pDefaultNameDb->GetDisplayName( pCtrDefinition->CounterNameTitleIndex, &pwcsDisplayName );
                }

                if ( SUCCEEDED( hr ) )
                {
                    var = (LPWSTR) pwcsDisplayName ;
                }

                hr = m_pLocaleNameDb->GetHelpName( pCtrDefinition->CounterHelpTitleIndex, &pwcsHelpName );

	            // If this is a localized Db, this is a benign error.  We will just pull the value 
		        // from the default db (it must be there, we wouldn't have a class name if it didn't
				// =================================================================================
                if ( FAILED( hr ) )
                {
                    hr = m_pDefaultNameDb->GetHelpName( pCtrDefinition->CounterHelpTitleIndex, &pwcsHelpName );
                }

                if ( SUCCEEDED( hr ) )
                {
                    varHelp = (LPWSTR) pwcsHelpName ;
                }
                
            }
            else
            {
                var = L"";
                varHelp = L"";
            }

			// Set the qualifier
			// =================
            if ( SUCCEEDED( hr ) )
            {
				IWbemQualifierSet* pQualSet = NULL;
				hr = pClass->GetPropertyQualifierSet( pwcsPropertyName, &pQualSet );
				CReleaseMe	rmQualSet( pQualSet );

				if ( SUCCEEDED( hr ) )
				{
					hr = pQualSet->Put( L"DisplayName", &var, 
						WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | WBEM_FLAVOR_AMENDED );
				    if (SUCCEEDED(hr))
				    {
				        hr = pQualSet->Put( L"Description", &varHelp, 
						                    WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | WBEM_FLAVOR_AMENDED );

				    }
				}
            }
        }
    }
    catch(...)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    if ( FAILED( hr ) )
    {
        // Something whacky happened: log an event
		// =======================================
        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
								  WBEM_MC_ADAP_GENERAL_OBJECT_FAILURE,
                                  (LPCWSTR)m_wstrClassName,
                                  (LPCWSTR)m_wstrServiceName,
                                  CHex( hr ) );
    }

    return hr;
}

HRESULT CLocaleClassBroker::AddProperty( PERF_COUNTER_DEFINITION* pCtrDefinition, 
										 DWORD dwType,
                                         BOOL fIsDefault,
                                         IWbemClassObject* pClass,
                                         WString &wstrLastCtrName,
                                         BOOL* pbLastCounterIsNotBase )
////////////////////////////////////////////////////////////////////////////////////////////
//
//	Ignored for localized classes
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    return WBEM_S_NO_ERROR;
}

HRESULT CLocaleClassBroker::GenPerfClass( PERF_OBJECT_TYPE* pPerfObj, 
										  DWORD dwType,
                                          BOOL bCostly, 
                                          IWbemClassObject* pBaseClass, 
                                          CPerfNameDb* pDefaultNameDb, 
                                          CPerfNameDb* pLocaleNameDb,
                                          LANGID LangId,
                                          WCHAR* pwcsServiceName,
                                          IWbemClassObject** ppObj)
///////////////////////////////////////////////////////////////////////////////
//
//	A static member of the broker.  It generates a WMI class based on the 
//	object BLOB.
//
//	Parameters:
//		pPerfObj		- The object BLOB
//		bCostly			- Costly object indicator
//		pBaseClass		- The new object's base class
//		pDefaultNameDb	- The default language names' database
//		pLocaleNameDb	- The localized language names' database
//		LangId			- The locale ID
//		pwcsServiceName	- The name of the perflib service
//		ppObj			- A pointer to the new class object interface pointer
//
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    IWbemClassObject* pObject = NULL;
    CLocaleClassBroker Broker( pPerfObj, bCostly, pBaseClass, pDefaultNameDb, pLocaleNameDb, LangId, pwcsServiceName );

    hr = Broker.Generate( dwType, &pObject );

    if ( SUCCEEDED( hr ) )
        *ppObj = pObject;

    return hr;
}

HRESULT CLocaleClassBroker::ConvertToLocale( IWbemClassObject* pDefaultClass,
                                             CLocaleDefn* pLocaleDefn,
                                             CLocaleDefn* pDefaultDefn,
                                             IWbemClassObject** ppObject)
///////////////////////////////////////////////////////////////////////////////
//
//	A static member of the broker.  It generates a new localized class based 
//	on the default object
//
///////////////////////////////////////////////////////////////////////////////
{
    // TODO: Break this up into smaller methods

    HRESULT hr = WBEM_S_NO_ERROR;

     _variant_t  var;
    int     nLocale = 0;
    int     nPerfIndex = 0; 
    int     nHelpIndex = 0;
    WString wstrClassName;
	DWORD	dwType = WMI_ADAP_RAW_CLASS;

    CPerfNameDb*    pLocaleNameDb = NULL;
    CPerfNameDb*    pDefaultNameDb = NULL;

    // Get references to the localized name's databases
    // ================================================
    hr = pLocaleDefn->GetNameDb( &pLocaleNameDb );
    CAdapReleaseMe  armLocaleNameDb( pLocaleNameDb );

    // Get references to the default name's databases
    // ==============================================
    if ( SUCCEEDED( hr ) )
    {
        hr = pDefaultDefn->GetNameDb( &pDefaultNameDb );
    }

    CAdapReleaseMe  armDefaultNameDb( pDefaultNameDb );

	// Get the locale ID
	// =================
    if ( SUCCEEDED( hr ) )
    {
        hr = pLocaleDefn->GetLID( &nLocale );
    }

    // Get the object's perf index
    // ===========================
    if ( SUCCEEDED( hr ) )
    {
		IWbemQualifierSet* pQualSet = NULL;
		hr = pDefaultClass->GetQualifierSet( &pQualSet );
		CReleaseMe	rmQualSet( pQualSet );

                
		if ( SUCCEEDED( hr ) )
		{
			hr =  pQualSet->Get( L"perfindex", 0L, &var, NULL );
			if (SUCCEEDED(hr)) 
			{
			    nPerfIndex = V_I4(&var);
			} 
			else 
			{
			    // see InitializeMembers
			    nPerfIndex = 0;
			    hr = WBEM_S_FALSE;
			    
			}
		}

		if ( SUCCEEDED( hr ) )
		{
			hr =  pQualSet->Get( L"helpindex", 0L, &var, NULL );
			if (SUCCEEDED(hr)) 
			{
			    nHelpIndex = V_I4(&var);
			} 
			else 
			{
			    // see InitializeMembers
			    nHelpIndex = 0;
			    hr = WBEM_S_FALSE;
			    
			}
		}
		

		if ( SUCCEEDED( hr ) )
		{
			hr = pQualSet->Get( L"Cooked", 0L, &var, NULL );

			if ( SUCCEEDED( hr ) && ( V_BOOL(&var) == VARIANT_TRUE ) )
			{
				dwType = WMI_ADAP_COOKED_CLASS;
			}
			else
			{
				dwType = WMI_ADAP_RAW_CLASS;
				hr = WBEM_S_FALSE;
			}
		}
    }

	// Get the class name
	// ==================
    if ( SUCCEEDED( hr ) )
    {
        var.Clear();
        hr =  pDefaultClass->Get( L"__CLASS", 0L, &var, NULL, NULL );
        
        wstrClassName = V_BSTR(&var); 
          
    }
    
    // Create locaized class
    // =====================
    IWbemClassObject*    pBaseClass = NULL;
    IWbemClassObject*    pLocaleClass = NULL;

    if ( SUCCEEDED( hr ) )
    {
        hr = pLocaleDefn->GetBaseClass( dwType, &pBaseClass );
		CReleaseMe  rmBaseClass( pBaseClass );

		if ( SUCCEEDED( hr ) )
		{
			hr = pBaseClass->SpawnDerivedClass( 0L, &pLocaleClass );
		}
	}

	// Initialize the data
	// ===================

    // Set the name
	// ============
    if ( SUCCEEDED( hr ) )
    {
        var.Clear();        
        var = LPCWSTR(wstrClassName);
        
        hr = pLocaleClass->Put( L"__CLASS", 0L, &var, CIM_STRING );
        
	}

    // Set Qualifiers
	// ==============
	if ( SUCCEEDED( hr ) )
	{
		IWbemQualifierSet* pQualSet = NULL;
		hr = pLocaleClass->GetQualifierSet( &pQualSet );
		CReleaseMe	rmQualSet( pQualSet );

		// Amendment
		// =========
		if ( SUCCEEDED( hr ) )
		{
		    var.Clear();
		    
			var = bool(true); 
			hr = pQualSet->Put( L"Amendment", &var, 0L );
		}

		// Locale
		// ======
		if ( SUCCEEDED( hr ) )
		{
			var.Clear();
			V_VT(&var) = VT_I4;
			V_I4(&var) = nLocale;
			hr = pQualSet->Put( L"locale", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
		}

        
		// DisplayName
		// ===========
		if ( SUCCEEDED( hr ) )
		{
			LPCWSTR     pwcsDisplayName = NULL;

			hr = pLocaleNameDb->GetDisplayName( nPerfIndex, &pwcsDisplayName );

	        // If this is a localized Db, this is a benign error.  We will just pull the value 
		    // from the default db (it must be there, we wouldn't have a class name if it didn't
			// =================================================================================
			if ( FAILED( hr ) )
			{
				hr = pDefaultNameDb->GetDisplayName( nPerfIndex, &pwcsDisplayName );
			}

			if ( SUCCEEDED( hr ) )
			{
			    var.Clear();
			    
				var = (WCHAR *)( pwcsDisplayName );
				hr = pQualSet->Put( L"DisplayName", &var,
						WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | WBEM_FLAVOR_AMENDED );

			}
			else
			{
			    // the nPerfInedx was bad
			    ERRORTRACE((LOG_WMIADAP,"class %S: DisplayName for counter %d not found\n",(WCHAR *)wstrClassName,nPerfIndex));
			}
		}


		// Description
		// ===========
		if ( SUCCEEDED( hr ) )
		{
			LPCWSTR     pwcsHelpName = NULL;

			hr = pLocaleNameDb->GetHelpName( nHelpIndex, &pwcsHelpName );

	        // If this is a localized Db, this is a benign error.  We will just pull the value 
		    // from the default db (it must be there, we wouldn't have a class name if it didn't
			// =================================================================================
			if ( FAILED( hr ) )
			{
				hr = pDefaultNameDb->GetHelpName( nHelpIndex, &pwcsHelpName );
			}

			if ( SUCCEEDED( hr ) )
			{
			    var.Clear();
			    
				var = (WCHAR *)( pwcsHelpName );
				hr = pQualSet->Put( L"Description", &var,
						WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | WBEM_FLAVOR_AMENDED );

			}
			else
			{
			    // the nPerfInedx was bad
			    ERRORTRACE((LOG_WMIADAP,"class %S: Description for counter %d not found\n",(WCHAR *)wstrClassName,nPerfIndex));
			}
		}

		// Genericperfctr
		// ==============
		if ( SUCCEEDED(hr) )
		{
			var.Clear();
			var = bool(true); 
			hr = pQualSet->Put( L"genericperfctr", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
		}
    }

    // Set Properties
	// ==============
    if ( SUCCEEDED( hr ) )
    {
        
        BSTR bstrPropName;

        pDefaultClass->BeginEnumeration( WBEM_FLAG_LOCAL_ONLY );

        while ( WBEM_S_NO_ERROR == pDefaultClass->Next( 0, &bstrPropName, NULL, NULL, NULL ) )
        {
            var.Clear();
            
            CIMTYPE ct;
            int nCounterIndex = 0;
            int nHelpIndex2    = 0;
            WString wstrDefaultPropDisplayName;

            // Create the property based upon the default property
            // ===================================================            
            V_VT(&var) = VT_NULL;
            V_I8(&var) = 0;

            hr = pDefaultClass->Get( bstrPropName, 0L, NULL, &ct, NULL );                        
            hr = pLocaleClass->Put( bstrPropName, 0L, (VARIANT*)&var, ct );

			// Grab the default property qualifier set
			// =======================================
			IWbemQualifierSet* pQualSet = NULL;
			hr = pDefaultClass->GetPropertyQualifierSet( bstrPropName, &pQualSet );
			CReleaseMe	rmQualSet( pQualSet );


            // Get the default perfindex to be (used to retrieve the display 
			// name from the localized names' database)
            // =============================================================
			if ( SUCCEEDED( hr ) )
			{
				hr = pQualSet->Get( L"perfindex", 0L, &var, NULL );
	            nCounterIndex = V_UI4(&var);
			}

			// DisplayName
			// ===========
			
			if ( SUCCEEDED( hr ) )
			{
				LPCWSTR     pwcsDisplayName = NULL;				

				hr = pLocaleNameDb->GetDisplayName( nCounterIndex, &pwcsDisplayName );

	            // If this is a localized Db, this is a benign error.  We will just pull the value 
		        // from the default db (it must be there, we wouldn't have a class name if it didn't
				// =================================================================================
				if ( FAILED( hr ) )
				{
					hr = pDefaultNameDb->GetDisplayName( nCounterIndex, &pwcsDisplayName );
				}

				if ( SUCCEEDED( hr ) )
				{
					IWbemQualifierSet* pLocaleQualSet = NULL;
					hr = pLocaleClass->GetPropertyQualifierSet( bstrPropName, &pLocaleQualSet );
					CReleaseMe	rmLocaleQualSet( pLocaleQualSet );
                
					var = (WCHAR *)( pwcsDisplayName );					
					hr = pLocaleQualSet->Put( L"DisplayName", &var, 
						WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | WBEM_FLAVOR_AMENDED );

				}
				else
				{
				    ERRORTRACE((LOG_WMIADAP,"class %S: Display for counter %d not found\n",(WCHAR *)wstrClassName,nCounterIndex));
				}
			}

            // HelpIndex
			if ( SUCCEEDED( hr ) )
			{
			    var.Clear();
				hr = pQualSet->Get( L"helpindex", 0L, &var, NULL );
	            nHelpIndex2 = V_UI4(&var);
			}

			// Description
			// ===========
			if ( SUCCEEDED( hr ) )
			{
				LPCWSTR     pwcsHelpName = NULL;	

				hr = pLocaleNameDb->GetHelpName( nHelpIndex2, &pwcsHelpName );

	            // If this is a localized Db, this is a benign error.  We will just pull the value 
		        // from the default db (it must be there, we wouldn't have a class name if it didn't
				// =================================================================================
				if ( FAILED( hr ) )
				{
					hr = pDefaultNameDb->GetHelpName( nHelpIndex2, &pwcsHelpName );
				}

				if ( SUCCEEDED( hr ) )
				{
					IWbemQualifierSet* pLocaleQualSet = NULL;
					hr = pLocaleClass->GetPropertyQualifierSet( bstrPropName, &pLocaleQualSet );
					CReleaseMe	rmLocaleQualSet( pLocaleQualSet );
                
					var = (WCHAR *)( pwcsHelpName );					
					hr = pLocaleQualSet->Put( L"Description", &var, 
						WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | WBEM_FLAVOR_AMENDED );

				}
				else
				{
				    ERRORTRACE((LOG_WMIADAP,"class %S: Description for counter %d not found\n",(WCHAR *)wstrClassName,nCounterIndex));
				}
			}
        
			SysFreeString( bstrPropName );
        }

        pDefaultClass->EndEnumeration();
    }

    if ( SUCCEEDED( hr ) )
    {
        *ppObject = pLocaleClass;

        if ( NULL != *ppObject )
            (*ppObject)->AddRef();
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//                              CDefaultClassBroker
//
////////////////////////////////////////////////////////////////////////////////////////////

HRESULT CDefaultClassBroker::SetClassQualifiers( IWbemClassObject* pClass, DWORD dwType, BOOL fIsDefault )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Sets the class' qualifiers.  Note that the operations are performed directly on the 
//  IWbemClassObject.
//
//  The following qualifiers will be added:
//		- Dynamic
//		- Provider("NT5_GenericPerfProvider_V1")
//		- Registrykey
//		- Locale(0x0409)
//		- Perfindex
//		- Helpindex
//		- Perfdetail
//		- Genericperfctr (signals that this is a generic counter)
//		- Singleton (if applicable)
//		- Costly (if applicable)  
//
//	Parameters:
//		pClass		- The object to be massaged
//		fIsDefault	- Indicator for the default object (not used in localized objects)
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    _variant_t var;

    try
    {
		IWbemQualifierSet* pQualSet = NULL;
		hr = pClass->GetQualifierSet( &pQualSet );
		CReleaseMe	rmQualSet( pQualSet );

		switch ( dwType )
		{
			case WMI_ADAP_RAW_CLASS:
			{
				// Default
				// =======
				if ( SUCCEEDED( hr ) && fIsDefault )
				{
					var = bool(true); 
					hr = pQualSet->Put( L"perfdefault", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
				}

				// Dynamic
				// =======
				if ( SUCCEEDED( hr ) )
				{
					var = bool(true); 
					hr = pQualSet->Put( L"dynamic", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
				}

				// Provider
				// ========
				if ( SUCCEEDED( hr ) )
				{
					var = L"Nt5_GenericPerfProvider_V1";
					hr = pQualSet->Put( L"provider", &var, 0L );
				}

				// Registrykey
				// ===========
				if ( SUCCEEDED( hr ) )
				{
					var = (WCHAR *)(m_wstrServiceName);
					hr = pQualSet->Put( L"registrykey", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
				}

				// Locale
				// ======
				if ( SUCCEEDED( hr ) )
				{
					var.Clear();
					V_VT(&var) = VT_I4;
					V_I4(&var) = 0x0409;
					hr = pQualSet->Put( L"locale", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
				}

				// Perfindex
				// =========
				if ( SUCCEEDED( hr ) )
				{
					V_VT(&var) = VT_I4;
					V_I4(&var) = m_pPerfObj->ObjectNameTitleIndex;
					hr = pQualSet->Put( L"perfindex", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
				}

				// Helpindex
				// =========
				if ( SUCCEEDED( hr ) )
				{
					V_VT(&var) = VT_I4;
					V_I4(&var) = m_pPerfObj->ObjectHelpTitleIndex;
					hr = pQualSet->Put( L"helpindex", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
				}

#ifdef _PM_CHANGED_THEIR_MIND_

				// Description
				// ==========
				if ( SUCCEEDED( hr ) )
				{
				    HRESULT hr2;
					LPCWSTR     pwcsHelpName = NULL;
					hr2 = m_pDefaultNameDb->GetHelpName( m_pPerfObj->ObjectHelpTitleIndex, &pwcsHelpName );				     
					var = (WCHAR *)pwcsHelpName;
					
				    if (SUCCEEDED(hr2))
				    {
				        hr = pQualSet->Put( L"Description", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );  
				    }
				    else
				    {
				        ERRORTRACE((LOG_WMIADAP,"class %S: Help for counter %d not found\n",(WCHAR *)m_wstrClassName,m_pPerfObj->ObjectHelpTitleIndex));
				    }
				    var.Clear();
				}
#endif
				// Perfdetail
				// ==========
				if ( SUCCEEDED( hr ) )
				{
                    V_VT(&var) = VT_I4;
					V_I4(&var) = m_pPerfObj->DetailLevel;
					hr = pQualSet->Put( L"perfdetail", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
				}

				// Genericperfctr
				// ==============
				if ( SUCCEEDED(hr) )
				{
					var = bool(true); 
					hr = pQualSet->Put( L"genericperfctr", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
				}

				// HiPerf
				// ==============
				if ( SUCCEEDED(hr) )
				{
					var = bool(true); 
					hr = pQualSet->Put( L"hiperf", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
				}

				// Singleton (set if the numinstances is PERF_NO_INSTANCES)
				// ========================================================
				if ( SUCCEEDED(hr) && IsSingleton( ) )
				{

					var = bool(true); 
					// This will have default flavors
					hr = pQualSet->Put( L"singleton", &var, 0L );
				}

				// Costly
				// ======
				if ( SUCCEEDED(hr) && m_bCostly )
				{
					var = bool(true); 
					hr = pQualSet->Put( L"costly", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
				}
			}break;

			case WMI_ADAP_COOKED_CLASS:
			{
                var.Clear();
                
				// Dynamic
				// =======
				if ( SUCCEEDED( hr ) )
				{					
					var = bool(true); 
					hr = pQualSet->Put( L"dynamic", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
				}
			
				// Provider
				// ========
				if ( SUCCEEDED( hr ) )
				{
					var = L"HiPerfCooker_v1";
					hr = pQualSet->Put( L"provider", &var, 0L );
				}

				// Locale
				// ======
				if ( SUCCEEDED( hr ) )
				{
					var.Clear();
					
					V_VT(&var) = VT_I4;
					V_I4(&var) = 0x0409;
					hr = pQualSet->Put( L"locale", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
				}

				// Registrykey
				// ===========
				if ( SUCCEEDED( hr ) )
				{
					var.Clear();
					var = (WCHAR *)( m_wstrServiceName );
					hr = pQualSet->Put( L"registrykey", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
				}

				// Cooked
				// ======

				if ( SUCCEEDED( hr ) )
				{
					var.Clear();				
					var = bool(true); 
					hr = pQualSet->Put( L"Cooked", &var, 0 );
				}

				// AutoCook
				// ========

				if ( SUCCEEDED( hr ) )
				{
				    V_VT(&var) = VT_I4;
					V_I4(&var) = 1 ;
					hr = pQualSet->Put( L"AutoCook", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
				}

				// Genericperfctr
				// ==============
				if ( SUCCEEDED(hr) )
				{
					var = bool(true); 
					hr = pQualSet->Put( L"genericperfctr", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
				}

				// HiPerf
				// ==============
				if ( SUCCEEDED(hr) )
				{
					var = bool(true); 
					hr = pQualSet->Put( L"hiperf", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
				}

				// AutoCook_RawClass
				// =================

				if ( SUCCEEDED( hr ) )
				{
					_variant_t varClassName;
					hr = pClass->Get( L"__CLASS", 0, &varClassName, 0, 0 );

					if ( SUCCEEDED( hr ) )
					{
						WCHAR* wszRawClass = NULL;
						WCHAR* wszClassRoot = varClassName.bstrVal + wcslen ( ADAP_PERF_COOKED_BASE_CLASS );
						
						wszRawClass = new WCHAR[ wcslen( wszClassRoot ) + wcslen( ADAP_PERF_RAW_BASE_CLASS ) + 1 ];
						CDeleteMe<WCHAR>	dmRawClass( wszRawClass );

						swprintf( wszRawClass, L"%s%s", ADAP_PERF_RAW_BASE_CLASS, wszClassRoot );

						var = wszRawClass;
						hr = pQualSet->Put( L"AutoCook_RawClass", 
						                    &var, 
						                    WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
						                    //WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS
					}				
				}

                // Perfindex
				// =========
				
				if ( SUCCEEDED( hr ) )
				{
					var.Clear();
				    V_VT(&var) = VT_I4;
					V_I4(&var) = m_pPerfObj->ObjectNameTitleIndex;					
					hr = pQualSet->Put( L"perfindex", (VARIANT*)&var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
				}

				// Helpindex
				// =========
				if ( SUCCEEDED( hr ) )
				{
					V_VT(&var) = VT_I4;
					V_I4(&var) = m_pPerfObj->ObjectHelpTitleIndex;
					hr = pQualSet->Put( L"helpindex", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
				}

#ifdef _PM_CHANGED_THEIR_MIND_
				// Description
				// ==========
				if ( SUCCEEDED( hr ) )
				{
				    HRESULT hr2;
					LPCWSTR     pwcsHelpName = NULL;
					hr2 = m_pDefaultNameDb->GetHelpName( m_pPerfObj->ObjectHelpTitleIndex, &pwcsHelpName );				     
					var = (WCHAR *)pwcsHelpName;
				    if (SUCCEEDED(hr2))
				    {
				        hr = pQualSet->Put( L"Description", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );  
				    }
				    else
				    {
				        ERRORTRACE((LOG_WMIADAP,"class %S: Help for counter %d not found\n",(WCHAR *)m_wstrClassName,m_pPerfObj->ObjectHelpTitleIndex));
				    }
				    var.Clear();
				}				
#endif
				// Singleton (set if the numinstances is PERF_NO_INSTANCES)
				// ========================================================
				if ( SUCCEEDED(hr) && IsSingleton( ) )
				{
					var.Clear();
					var = bool(true); 
					// This will have default flavors
					hr = pQualSet->Put( L"singleton", (VARIANT*)&var, 0L );
				}


			}break;
		}
    }
    catch(...)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    if ( FAILED( hr ) )
    {
        // Something whacky happened: log an event
		// =======================================
        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
								  WBEM_MC_ADAP_GENERAL_OBJECT_FAILURE,
                                  (LPCWSTR)m_wstrClassName,
                                  (LPCWSTR)m_wstrServiceName,
                                  CHex( hr ) );
    }

    return hr;
}

HRESULT CDefaultClassBroker::AddDefaultProperties( IWbemClassObject* pClass )
///////////////////////////////////////////////////////////////////////////////
//
//	Adds appropriate default properties.
//
//  The following qualifiers will be added:
//		- Name
//
//	Parameters:
//		pClass		- The object to be massaged
//
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // If we are not a singleton class, then we will
    // need a name property that is marked as a key
	// =============================================
    if ( !IsSingleton() )
    {
        _variant_t var;

		// Add the Name property
		// =====================

		V_VT(&var) = VT_NULL;
		V_I8(&var) = 0;
        hr = pClass->Put( L"Name", 0L, &var, CIM_STRING );

		// Add the property qualifiers
		// ===========================
        if ( SUCCEEDED( hr ) )
        {
			IWbemQualifierSet* pQualSet = NULL;
			hr = pClass->GetPropertyQualifierSet( L"Name", &pQualSet );
			CReleaseMe	rmQualSet( pQualSet );

			// Dynamic
			// =======
			if ( SUCCEEDED( hr ) )
			{
			    var.Clear();
				var = bool(true); 
				hr = pQualSet->Put( L"key", (VARIANT*)&var, 0L );
			}
        }
    }

    return hr;
}

HRESULT CDefaultClassBroker::EnumProperties( DWORD dwType, IWbemClassObject* pClass )
///////////////////////////////////////////////////////////////////////////////
//
//	Walks the counter definitions and generates corresponding properties
//
//	Parameters:
//		pClass		- The object to be massaged
//
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    BOOL    bLastCounterIsNotBase = FALSE;
    WString wstrLastCtrName;

    // Set to first counter definition
	// ===============================
    LPBYTE  pbData = ((LPBYTE) m_pPerfObj) + m_pPerfObj->HeaderLength;

    // Cast to a counter definition
	// ============================
    PERF_COUNTER_DEFINITION*    pCounterDefinition = (PERF_COUNTER_DEFINITION*) pbData;


	// For each counter definition, add a corresponding property
	// =========================================================
    for ( DWORD dwCtr = 0; SUCCEEDED( hr ) && dwCtr < m_pPerfObj->NumCounters; dwCtr++ )
    {
        hr = AddProperty( pCounterDefinition, dwType, ( dwCtr == (DWORD) m_pPerfObj->DefaultCounter),
                            pClass, wstrLastCtrName, &bLastCounterIsNotBase );

        // Now go to the next counter definition
		// =====================================
        pbData = ((LPBYTE) pCounterDefinition) + pCounterDefinition->ByteLength;
        pCounterDefinition = (PERF_COUNTER_DEFINITION*) pbData;
    }

    return hr;
}

HRESULT CDefaultClassBroker::AddProperty( PERF_COUNTER_DEFINITION* pCtrDefinition, 
										  DWORD dwType,
                                          BOOL fIsDefault,
                                          IWbemClassObject* pClass, 
                                          WString &wstrLastCtrName,
                                          BOOL* pbLastCounterIsNotBase )
///////////////////////////////////////////////////////////////////////////////
//
//	Adds a property defined by the counter definition
//	
//	Properties:
//		pCtrDefinition	- The counter BLOB
//		dwType			- Raw or Formatted object?
//		fIsDefault		- The default property flag
//		pClass			- The class containing the property
//		wstrLastCtrName	- The name of the last counter (required for base 
//							properties)
//		pbLastCounterIsNotBase
//						- An indicator for the previous counter's baseness
//
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    WString wstrPropertyName;
    DWORD   dwCounterTypeMask = PERF_SIZE_VARIABLE_LEN;
    BOOL    bBase = FALSE;

    if ( PERF_COUNTER_BASE == ( pCtrDefinition->CounterType & 0x00070000 ) )
    {
		// It's a base property
		// ====================
        if ( *pbLastCounterIsNotBase )
        {
            try
            {
				// The property name is the same as the previous property, 
				// but with "_Base" appended to the end
				// =======================================================
                wstrPropertyName = wstrLastCtrName;

				if ( WMI_ADAP_RAW_CLASS == dwType )
				{
					wstrPropertyName += "_Base";
				}
            }
            catch(...)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

            bBase = TRUE;
        }
        else
        {
			// Cannot have 2 consequtive bases
			// ===============================
            CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_BAD_PERFLIB_INVALID_DATA, (LPCWSTR)m_wstrServiceName, CHex(0) );
            hr = WBEM_E_FAILED;
        }
    }
    else
    {
		// It's not a base property so get the name from the names' database
		// =================================================================
        hr = m_pDefaultNameDb->GetDisplayName( pCtrDefinition->CounterNameTitleIndex, wstrPropertyName );

		if ( FAILED( hr ) )
        {
            // Index does not exist in the Names' DB: log an event
			// ===================================================
            CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
									  WBEM_MC_ADAP_MISSING_PROPERTY_INDEX,
                                      (LPCWSTR)m_wstrClassName,
                                      (LPCWSTR)m_wstrServiceName,
                                      pCtrDefinition->CounterNameTitleIndex );
        }

		// Replace reserved characters with text
		// =====================================
        if ( SUCCEEDED( hr ) )
        {
            hr = ReplaceReserved( wstrPropertyName );
        }

        // Remove restricted characters
		// ============================
        if ( SUCCEEDED ( hr ) )
        {
            hr = RemoveWhitespaceAndNonAlphaNum( wstrPropertyName );
		}
    }

    if ( SUCCEEDED( hr ) )
    {
        _variant_t    varTest;
        DWORD   dwBaseCtr = 1;

		// Ensure that the property does not exist
		// =======================================
        if ( FAILED( pClass->Get( wstrPropertyName, 0L, &varTest, NULL, NULL ) ) ) 
        {
            // Now check the perf counter type to see if it's a DWORD or LARGE.  
            // If it's anything else, we will NOT support this object
			// ================================================================
            DWORD   dwCtrType = pCtrDefinition->CounterType & dwCounterTypeMask;

            if ( PERF_SIZE_DWORD == dwCtrType ||
                 PERF_SIZE_LARGE == dwCtrType )
            {
                _variant_t    var;
                CIMTYPE ct = ( PERF_SIZE_DWORD == dwCtrType ? CIM_UINT32 : CIM_UINT64 );

				// Add the property
				// ================
                V_VT(&var) = VT_NULL;
                V_I8(&var) = 0;
                hr = pClass->Put( wstrPropertyName, 0L, &var, ct );

				// Set the property qualifiers
				// ===========================
                if ( SUCCEEDED( hr ) )
                {
                    hr = SetPropertyQualifiers( pCtrDefinition, 
												dwType,
                                                fIsDefault, 
                                                wstrPropertyName,
                                                pClass,
                                                bBase );
                }
            }
            else if ( PERF_SIZE_ZERO == dwCtrType )
            {
                // Ignore zero size properties
				// ===========================
            }
            else
            {
                // Illegal property type: log an event
				// ===================================
                CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
                                          WBEM_MC_ADAP_BAD_PERFLIB_BAD_PROPERTYTYPE,
                                          (LPCWSTR)m_wstrClassName,
                                          (LPCWSTR)m_wstrServiceName,
                                          (LPCWSTR)wstrPropertyName);
                hr = WBEM_E_FAILED;
            }
        }
		else if ( ( WMI_ADAP_COOKED_CLASS == dwType ) && ( bBase ) )
		{
            hr = SetPropertyQualifiers( pCtrDefinition, 
										dwType,
                                        fIsDefault, 
                                        wstrPropertyName,
                                        pClass,
                                        bBase );
		}
        else
        {
            // Raw Property already exists: log an event (
			// =========================================
            CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
									  WBEM_MC_ADAP_DUPLICATE_PROPERTY,
                                      (LPCWSTR)m_wstrClassName,
                                      (LPCWSTR)m_wstrServiceName,
                                      (LPCWSTR) wstrPropertyName );
            hr = WBEM_E_FAILED;
        }
    }

	if ( SUCCEEDED( hr ) )
	{
		*pbLastCounterIsNotBase = !bBase;
		wstrLastCtrName = wstrPropertyName;
	}
	else
    {
        // Wierdness: log an event
		// =======================
        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
								  WBEM_MC_ADAP_GENERAL_OBJECT_FAILURE,
                                  (LPCWSTR)m_wstrClassName,
                                  (LPCWSTR)m_wstrServiceName,
                                  CHex( hr ) );
    }

    return hr;
}

HRESULT CDefaultClassBroker::SetPropertyQualifiers( PERF_COUNTER_DEFINITION* pCtrDefinition,
												    DWORD dwType,
                                                    BOOL fIsDefault,
                                                    LPCWSTR pwcsPropertyName, 
                                                    IWbemClassObject* pClass,
                                                    BOOL bBase )
///////////////////////////////////////////////////////////////////////////////
//
//  Sets the qualifier values of the properties defined by the counter
//	definition.
//
//  The following qualifiers will be added:
//		- Perfdefault
//		- Display
//		- Countertype
//		- Perfindex
//		- Helpindex
//		- Defaultscale
//		- Perfdetail
//
//	Properties:
//		pCtrDefinition		- The portion of the performance blob related to the property
//		fIsDefault			- Flag identifying default property
//		pwcsPropertyName	- The name of the property
//		pClass				- The WMI class containing the property
//		bBase				- Base property identifier
//
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    _variant_t  var;

    try
    {
		IWbemQualifierSet* pQualSet = NULL;
		hr = pClass->GetPropertyQualifierSet( pwcsPropertyName, &pQualSet );
		CReleaseMe	rmQualSet( pQualSet );

		switch ( dwType )
		{
			case WMI_ADAP_RAW_CLASS:
			{
				// Perfdefault
				// ===========
				if ( SUCCEEDED( hr ) && fIsDefault )
				{
					var = bool(true); 
					hr = pQualSet->Put( L"perfdefault", (VARIANT*)&var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
				}

				// Display
				// =======
				if ( SUCCEEDED( hr ) )
				{
					LPCWSTR pwcsDisplayName = NULL;

					var.Clear();

					// Fetch the name from the Names' database
					// =======================================
					if ( !bBase )
					{
						hr = m_pDefaultNameDb->GetDisplayName( pCtrDefinition->CounterNameTitleIndex, &pwcsDisplayName );
						if ( SUCCEEDED( hr ) )
						{
							var = pwcsDisplayName;
						}
						else
						{
						    ERRORTRACE((LOG_WMIADAP,"class %S: DisplayName for counter %d not found\n",(WCHAR *)m_wstrClassName,pCtrDefinition->CounterNameTitleIndex));
						}
					}
					else
					{
						var = L"";
					}

					// If this is a localized Db, this could be a benign error
					// =======================================================
					if ( SUCCEEDED( hr ) )
					{
						hr = pQualSet->Put( L"DisplayName", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
					}
				}
				
#ifdef _PM_CHANGED_THEIR_MIND_
				// Description
				// ===========
				if ( SUCCEEDED( hr ) )
				{
					LPCWSTR pwcsHelpName = NULL;

					var.Clear();

					if ( !bBase )
					{
						hr = m_pDefaultNameDb->GetHelpName( pCtrDefinition->CounterHelpTitleIndex, &pwcsHelpName );
						if ( SUCCEEDED( hr ) )
						{
							var = pwcsHelpName;
						}
						else
						{
						    ERRORTRACE((LOG_WMIADAP,"class %S: Help for counter %d not found\n",(WCHAR *)m_wstrClassName,pCtrDefinition->CounterNameTitleIndex));
						}

					}
					else
					{
						var = L"";
					}

					if ( SUCCEEDED( hr ) )
					{
						hr = pQualSet->Put( L"Description", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
					}
				}
#endif				


				// Countertype
				// ===========
				if ( SUCCEEDED( hr ) )
				{
					var.Clear();
					V_VT(&var) = VT_I4;
					V_I4(&var) = pCtrDefinition->CounterType ;
					hr = pQualSet->Put( L"countertype", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
				}

				// Perfindex
				// =========
				if ( SUCCEEDED( hr ) )
				{
					V_VT(&var) = VT_I4;
					V_I4(&var) = pCtrDefinition->CounterNameTitleIndex ;
					hr = pQualSet->Put( L"perfindex", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
				}

				// Helpindex
				// =========
				if ( SUCCEEDED( hr ) )
				{
					V_VT(&var) = VT_I4;
					V_I4(&var) = pCtrDefinition->CounterHelpTitleIndex ;
					hr = pQualSet->Put( L"helpindex", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
				}

				// Defaultscale
				// ============
				if ( SUCCEEDED( hr ) )
				{
					V_VT(&var) = VT_I4;
					V_I4(&var) = pCtrDefinition->DefaultScale ;
					hr = pQualSet->Put( L"defaultscale", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
				}

				// Perfdetail
				// ==========
				if ( SUCCEEDED( hr ) )
				{
					V_VT(&var) = VT_I4;
					V_I4(&var) = pCtrDefinition->DetailLevel ;
					hr = pQualSet->Put( L"perfdetail", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
				}
			}break;
			case WMI_ADAP_COOKED_CLASS:
			{
			    var.Clear();

#ifdef _PM_CHANGED_THEIR_MIND_
				// Display
				// =======
				if ( SUCCEEDED( hr ) )
				{
					LPCWSTR pwcsDisplayName = NULL;

					var.Clear();

					// Fetch the name from the Names' database
					// =======================================
					if ( !bBase )
					{
						hr = m_pDefaultNameDb->GetDisplayName( pCtrDefinition->CounterNameTitleIndex, &pwcsDisplayName );
						if ( SUCCEEDED( hr ) )
						{
							var = pwcsDisplayName;
						}
						else
						{
						    ERRORTRACE((LOG_WMIADAP,"class %S: DisplayName for counter %d not found\n",(WCHAR *)m_wstrClassName,pCtrDefinition->CounterNameTitleIndex));
						}
					}
					else
					{
						var = L"";
					}

					// If this is a localized Db, this could be a benign error
					// =======================================================
					if ( SUCCEEDED( hr ) )
					{
						hr = pQualSet->Put( L"DisplayName", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
					}
				}

				// Description
				// ===========
				if ( SUCCEEDED( hr ) )
				{
					LPCWSTR pwcsHelpName = NULL;

					var.Clear();

					if ( !bBase )
					{
						hr = m_pDefaultNameDb->GetHelpName( pCtrDefinition->CounterHelpTitleIndex, &pwcsHelpName );
						if ( SUCCEEDED( hr ) )
						{
							var = pwcsHelpName;
						}
					}
					else
					{
						var = L"";
					}

					if ( SUCCEEDED( hr ) )
					{
						hr = pQualSet->Put( L"Description", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
					}
				}
#endif

			    
				if ( !bBase )
				{
					// CookingType
					// ===========
					if ( SUCCEEDED( hr ) )
					{
						WCHAR*	wszCookingType = NULL;
						hr = GetCounterTypeString( pCtrDefinition->CounterType, &wszCookingType );

						if ( SUCCEEDED( hr ) )
						{
							var = wszCookingType;
							hr = pQualSet->Put( L"CookingType", (VARIANT*)&var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
						}
					}

					// Counter
					// =======
					if ( SUCCEEDED( hr ) )
					{
						WString wstrPropertyName;

						var.Clear();

						// Fetch the name from the Names' database
						// =======================================
						hr = m_pDefaultNameDb->GetDisplayName( pCtrDefinition->CounterNameTitleIndex, wstrPropertyName );

						// Replace reserved characters with proper names
						// =============================================
						if ( SUCCEEDED( hr ) )
						{
							hr = ReplaceReserved( wstrPropertyName );
						}

						// Remove whitespace and extraneous characters
						// ===========================================
						if ( SUCCEEDED( hr ) )
						{
							hr = RemoveWhitespaceAndNonAlphaNum( wstrPropertyName );
						}

						if ( SUCCEEDED( hr ) )
						{
							var = LPCWSTR(wstrPropertyName );

							// If this is a localized Db, this could be a benign error
							// =======================================================
							hr = pQualSet->Put( L"Counter", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
						}				
					}

					// PerfTimeStamp & PerfTimeFreq
					// ============================
					if ( SUCCEEDED( hr ) )
					{
						_variant_t varStamp;
						_variant_t varFreq;

						if ( pCtrDefinition->CounterType & PERF_TIMER_100NS )
						{
							varStamp = L"TimeStamp_Sys100NS";
							varFreq = L"Frequency_Sys100NS";
						}
						else if ( pCtrDefinition->CounterType & PERF_OBJECT_TIMER )
						{
							varStamp = L"Timestamp_Object" ;
							varFreq = L"Frequency_Object" ;
						}
						else
						{
							varStamp = L"Timestamp_PerfTime";
							varFreq = L"Frequency_PerfTime";
						}
						
						hr = pQualSet->Put( L"PerfTimeStamp", &varStamp, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );

						if ( SUCCEEDED( hr ) )
						{
							hr = pQualSet->Put( L"PerfTimeFreq", &varFreq, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
						}
					}

    				// Perfindex
	    			// =========
		    		if ( SUCCEEDED( hr ) )
			    	{
				    	var.Clear();
    					V_VT(&var) = VT_I4;
	    				V_I4(&var) = pCtrDefinition->CounterNameTitleIndex;
    					hr = pQualSet->Put( L"perfindex", (VARIANT*)&var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
	    			}
	    			
    				// Helpindex
	    			// =========
		    		if ( SUCCEEDED( hr ) )
			    	{
				    	V_VT(&var) = VT_I4;
					    V_I4(&var) = pCtrDefinition->CounterHelpTitleIndex ;
    					hr = pQualSet->Put( L"helpindex", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
	    			}
	    			
					
				}
				else
				{
					// Base
					// ====
					if ( SUCCEEDED( hr ) )
					{
						WCHAR*	wszCounterBase = NULL;
						_variant_t	varCounter;
						hr = pQualSet->Get( L"Counter", 0L, &varCounter, NULL );

						wszCounterBase = new WCHAR[ wcslen( varCounter.bstrVal ) + 5 + 1 ];
						CDeleteMe<WCHAR>	dmCounterBase( wszCounterBase );

						if ( NULL == wszCounterBase )
						{
							hr = WBEM_E_OUT_OF_MEMORY;
						}
						else
						{
							swprintf( wszCounterBase, L"%s_Base", varCounter.bstrVal );
							var = wszCounterBase;
							hr = pQualSet->Put( L"Base", (VARIANT*)&var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
						}
					}
				}
			}break;
		}
    }
    catch(...)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    if ( FAILED( hr ) )
    {
        // Weirdness: log an event
		// =======================
        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
								  WBEM_MC_ADAP_GENERAL_OBJECT_FAILURE,
                                  (LPCWSTR)m_wstrClassName,
                                  (LPCWSTR)m_wstrServiceName,
                                  CHex( hr ) );
    }

    return hr;
}

HRESULT CDefaultClassBroker::GenPerfClass( PERF_OBJECT_TYPE* pPerfObj, 
										   DWORD dwType,
                                           BOOL bCostly, 
                                           IWbemClassObject* pBaseClass, 
                                           CPerfNameDb* pDefaultNameDb, 
                                           WCHAR* pwcsServiceName,
                                           IWbemClassObject** ppObj)
///////////////////////////////////////////////////////////////////////////////
//
//	A static member of the broker.  It generates a WMI class based on the 
//	object BLOB.
//
//	Parameters:
//		pPerfObj		- The object BLOB
//		bCostly			- Costly object indicator
//		pBaseClass		- The new object's base class
//		pDefaultNameDb	- The default language names' database
//		pwcsServiceName	- The name of the perflib service
//		ppObj			- A pointer to the new class object interface pointer
//
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    IWbemClassObject* pObject = NULL;
    CDefaultClassBroker Broker( pPerfObj, bCostly, pBaseClass, pDefaultNameDb, pwcsServiceName );

    hr = Broker.Generate( dwType, &pObject );

    if ( SUCCEEDED( hr ) )
        *ppObj = pObject;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\adap\localloc.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "precomp.h"
#include <arena.h>

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\adap\classbroker.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    CLASSBROKER.H

Abstract:

History:

--*/


#ifndef _CLASSBROKER_H_
#define _CLASSBROKER_H_

#include <windows.h>
#include <wbemcomn.h>
#include <wbemcli.h>
#include <wbemint.h>
#include "perfndb.h"

#define WMI_ADAP_DEFAULT_OBJECT		238;

class CClassBroker
{
protected:

	PERF_OBJECT_TYPE*	m_pPerfObj;
	BOOL				m_bCostly;
	WString				m_wstrServiceName;
	WString				m_wstrClassName;
	IWbemClassObject*	m_pBaseClass;
	CPerfNameDb*		m_pDefaultNameDb;

	HRESULT SetClassName( DWORD dwType, IWbemClassObject* pObj );

	virtual HRESULT SetClassQualifiers(	IWbemClassObject* pObj, DWORD dwType, BOOL fIsDefault ) = 0;

	virtual HRESULT AddDefaultProperties( IWbemClassObject* pObj ) = 0;

	virtual HRESULT EnumProperties( DWORD dwType, IWbemClassObject* pObj ) = 0;

	virtual HRESULT SetPropertyQualifiers( PERF_COUNTER_DEFINITION* pCtrDefinition, 
										   DWORD dwType,
										   BOOL fIsDefault,
										   LPCWSTR pwcsPropertyName,
										   IWbemClassObject* pClass,
										   BOOL bBase ) = 0;


	virtual HRESULT AddProperty( PERF_COUNTER_DEFINITION* pCtrDefinition, 
								 DWORD dwType,
								 BOOL fIsDefault,
								 IWbemClassObject* pClass,
								 WString &wstrLastCtrName,
								 BOOL* pbLastCounterIsNotBase ) = 0;

// Helper methods
// ==============

	BOOL IsSingleton()
	{
		return ( PERF_NO_INSTANCES == m_pPerfObj->NumInstances );
	}

	HRESULT RemoveWhitespaceAndNonAlphaNum( WString& wstr );
	HRESULT ReplaceReserved( WString& wstr );

public:

	CClassBroker( IWbemClassObject* pBaseClass, WString wstrClassName, CPerfNameDb* pDefaultNameDb );

	CClassBroker( PERF_OBJECT_TYPE* pPerfObj, 
				  BOOL bCostly, 
				  IWbemClassObject* pBaseClass, 
				  CPerfNameDb* pDefaultNameDb, 
				  WCHAR* pwcsServiceName );

	virtual ~CClassBroker();

	HRESULT Generate( DWORD dwType, IWbemClassObject** ppObj );
};

class CLocaleClassBroker : public CClassBroker
{
protected:
	CPerfNameDb*		m_pLocaleNameDb;
	LANGID				m_LangId;

	virtual HRESULT SetClassQualifiers(	IWbemClassObject* pObj, DWORD dwType, BOOL fIsDefault );

	virtual HRESULT AddDefaultProperties( IWbemClassObject* pObj );

	virtual HRESULT EnumProperties( DWORD dwType, IWbemClassObject* pObj );

	virtual HRESULT SetPropertyQualifiers( PERF_COUNTER_DEFINITION* pCtrDefinition, 
										   DWORD dwType,
										   BOOL fIsDefault,
										   LPCWSTR pwcsPropertyName,
										   IWbemClassObject* pClass,
										   BOOL bBase );

	virtual HRESULT AddProperty( PERF_COUNTER_DEFINITION* pCtrDefinition, 
								 DWORD dwType,
								 BOOL fIsDefault,
								 IWbemClassObject* pClass,
								 WString &wstrLastCtrName,
								 BOOL* pbLastCounterIsNotBase );
public:

	CLocaleClassBroker( IWbemClassObject* pBaseClass, 
						WString wstrClassName, 
						CPerfNameDb* pDefaultNameDb, 
						CPerfNameDb* pLocaleNameDb );

	CLocaleClassBroker( PERF_OBJECT_TYPE* pPerfObj, 
						BOOL bCostly, 
						IWbemClassObject* pBaseClass, 
						CPerfNameDb* pDefaultNameDb, 
						CPerfNameDb* pLocaleNameDb,
						LANGID LangId,
						WCHAR* pwcsServiceName );

	~CLocaleClassBroker();

	static HRESULT GenPerfClass( PERF_OBJECT_TYPE* pPerfObj, 
						DWORD dwType,
						BOOL bCostly, 
						IWbemClassObject* pBaseClass, 
						CPerfNameDb* pDefaultNameDb, 
						CPerfNameDb* pLocaleNameDb,
						LANGID LangId,
						WCHAR* pwcsServiceName,
						IWbemClassObject** ppObj);

	static HRESULT ConvertToLocale( IWbemClassObject* pDefaultObject,
									CLocaleDefn* pLocaleDefn,
									CLocaleDefn* pDefaultDefn,
									IWbemClassObject** ppObject );

};

class CDefaultClassBroker : public CClassBroker
{
protected:
	virtual HRESULT SetClassQualifiers(	IWbemClassObject* pObj, DWORD dwType, BOOL fIsDefault );

	virtual HRESULT AddDefaultProperties( IWbemClassObject* pObj );

	virtual HRESULT EnumProperties( DWORD dwType, IWbemClassObject* pObj );

	virtual HRESULT SetPropertyQualifiers( PERF_COUNTER_DEFINITION* pCtrDefinition, 
										   DWORD dwType,
										   BOOL fIsDefault,
										   LPCWSTR pwcsPropertyName,
										   IWbemClassObject* pClass,
										   BOOL bBase );

	virtual HRESULT AddProperty( PERF_COUNTER_DEFINITION* pCtrDefinition, 
								 DWORD dwType,
								 BOOL fIsDefault,
								 IWbemClassObject* pClass,
								 WString &wstrLastCtrName,
								 BOOL* pbLastCounterIsNotBase );

public:
	CDefaultClassBroker( PERF_OBJECT_TYPE* pPerfObj, 
						 BOOL bCostly, 
						 IWbemClassObject* pBaseClass, 
						 CPerfNameDb* pDefaultNameDb, 
						 WCHAR* pwcsServiceName )
	: CClassBroker( pPerfObj, bCostly, pBaseClass, pDefaultNameDb, pwcsServiceName ) {}

	static HRESULT GenPerfClass( PERF_OBJECT_TYPE* pPerfObj, 
					DWORD dwType,
					BOOL bCostly, 
					IWbemClassObject* pBaseClass, 
					CPerfNameDb* pDefaultNameDb, 
					WCHAR* pwcsServiceName,
					IWbemClassObject** ppObj);
};



#endif	// _BROKERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\adap\ntreg.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    NTREG.H

Abstract:

History:

--*/

#ifndef _NTREG_H_
#define _NTREG_H_

#include <windows.h>
//#include "corepol.h"

class CNTRegistry
{
    HKEY    m_hPrimaryKey;
    HKEY    m_hSubkey;
    int     m_nStatus;
    LONG    m_nLastError;
   
public:
    enum { no_error, failed, out_of_memory, no_more_items, access_denied, not_found };
    
    CNTRegistry();
   ~CNTRegistry();

    int Open(HKEY hStart, WCHAR *pszStartKey);

    int MoveToSubkey(WCHAR *pszNewSubkey);

    int DeleteValue(WCHAR *pwszValueName);

    int GetDWORD(WCHAR *pwszValueName, DWORD *pdwValue);
    int GetStr(WCHAR *pwszValueName, WCHAR **pwszValue);
    int GetBinary(WCHAR *pwszValueName, BYTE** ppBuffer);

    //Returns a pointer to a string buffer containing the null-terminated string.
    //The last entry is a double null terminator (i.e. the registry format for
    //a REG_MULTI_SZ).  Caller has do "delete []" the returned pointer.
    //dwSize is the size of the buffer returned.
    int GetMultiStr(WCHAR *pwszValueName, WCHAR** pwszValue, DWORD &dwSize);

    // Allows key enumneration
    int Enum( DWORD dwIndex, WCHAR** pwszValue, DWORD& dwSize );

    int SetDWORD(WCHAR *pwszValueName, DWORD dwValue);
    int SetStr(WCHAR *pwszValueName, WCHAR *wszValue);
    int SetBinary(WCHAR *pwszValueName, BYTE* pBuffer, DWORD dwSize );

    LONG GetLastError() { return m_nLastError; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\adap\perflibschema.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    PERFLIBSCHEMA.H

Abstract:

	interface for the CPerfLibSchema class.

History:

--*/

#ifndef _PERFLIBSCHEMA_H_
#define _PERFLIBSCHEMA_H_

#include <flexarry.h>
#include "perfndb.h"
#include "adapelem.h"
#include "adapcls.h"
#include "adapperf.h"
#include "perfthrd.h"

class CIndexTable
{
	enum { not_found = -1 };
private:
	CFlexArray	m_array;	// Array of indices

protected:
	int	Locate( int nIndex );

public:
	BOOL Add( int nIndex );
	void Empty();
};

class CPerfLibBlobDefn
{
protected:
	PERF_OBJECT_TYPE*	m_pPerfBlock;
	DWORD				m_dwNumBytes;
	DWORD				m_dwNumObjects;
	BOOL				m_fCostly;

public:
	CPerfLibBlobDefn() : m_pPerfBlock( NULL ), m_dwNumBytes ( 0 ), m_dwNumObjects ( 0 ), m_fCostly ( FALSE ) 
	{}

	virtual ~CPerfLibBlobDefn() 
	{
		if ( NULL != m_pPerfBlock )
			delete m_pPerfBlock;
	}

	PERF_OBJECT_TYPE*	GetBlob() { return m_pPerfBlock; }
	DWORD				GetNumObjects() { return m_dwNumObjects; }
	DWORD				GetSize() { return m_dwNumBytes; }
	BOOL				GetCostly() { return m_fCostly; }
	void				SetCostly( BOOL fCostly ) { m_fCostly = fCostly; }

	PERF_OBJECT_TYPE**	GetPerfBlockPtrPtr() { return &m_pPerfBlock; }
	DWORD*				GetSizePtr() { return &m_dwNumBytes; }
	DWORD*				GetNumObjectsPtr() { return &m_dwNumObjects; }
};

class CAdapPerfLib;
class CPerfThread;
class CLocaleCache;

class CPerfLibSchema  
{
protected:
	
// Perflib data
// ============

	// The service name of the perflib
	// ===============================
	WString	m_wstrServiceName;

	// The blobs
	// =========
	enum { GLOBAL, COSTLY, NUMBLOBS };
	CPerfLibBlobDefn	m_aBlob[NUMBLOBS];

	// The look aside table for blob processing
	// ========================================
	CIndexTable		m_aIndexTable[WMI_ADAP_NUM_TYPES];

	// The repository with all localized names databases
	// =================================================
	CLocaleCache*	m_pLocaleCache;

	// The unified class list for the perflib schema
	// =============================================
	CPerfClassList* m_apClassList[WMI_ADAP_NUM_TYPES];

	// Methods
	// =======
	HRESULT CreateClassList( DWORD dwType );

public:
	CPerfLibSchema( WCHAR* pwcsServiceName, CLocaleCache* pLocaleCache ); 
	virtual ~CPerfLibSchema();

	HRESULT Initialize( BOOL bDelta, DWORD * LoadStatus);
	HRESULT GetClassList( DWORD dwType, CClassList** ppClassList );
};

#endif	// _PERFLIBSCHEMA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\adap\perfndb.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    PERFNDB.H

Abstract:

History:

--*/

// Use this guy to build a map of index to display name from a localized
// Name Database  At this time, it just brute forces a class and a flex
// array, but could be modified to use an STL map just as easily.

#ifndef __PERFNDB_H__
#define __PERFNDB_H__

#include <wbemcomn.h>
#include "adapelem.h"
#include "ntreg.h"

class CPerfNameDb: public CAdapElement
{
public:
    CPerfNameDb(HKEY hKey);
	~CPerfNameDb();
	HRESULT Init(HKEY hKey);

	BOOL IsOk( void )
	{
		return m_fOk;
	}

	HRESULT GetDisplayName( DWORD dwIndex, WString& wstrDisplayName );
	HRESULT GetDisplayName( DWORD dwIndex, LPCWSTR* ppwcsDisplayName );

	HRESULT GetHelpName( DWORD dwIndex, WString& wstrHelpName );
	HRESULT GetHelpName( DWORD dwIndex, LPCWSTR* ppwcsHelpName );
	
	//VOID Dump();
	
private:
	// these are the MultiSz Pointers
    WCHAR * m_pMultiCounter;
    WCHAR * m_pMultiHelp;
	// these are the "indexed" pointers
    WCHAR ** m_pCounter;
	WCHAR ** m_pHelp;
	DWORD m_Size;
	//
	BOOL  m_fOk;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\adap\ntreg.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    NTREG.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <oaidl.h>
#include "ntreg.h"

#include "adaputil.h"

CNTRegistry::CNTRegistry() : m_hPrimaryKey(0), 
                             m_hSubkey(0),
                             m_nStatus(0),
                             m_nLastError(no_error)
{
}

CNTRegistry::~CNTRegistry()
{
    if (m_hSubkey)
        RegCloseKey(m_hSubkey);
    if (m_hPrimaryKey != m_hSubkey)
        RegCloseKey(m_hPrimaryKey);
}

int CNTRegistry::Open(HKEY hStart, WCHAR *pszStartKey)
{
    int nStatus = no_error;

    m_nLastError = RegOpenKeyExW(hStart, pszStartKey,
                                    0, KEY_ALL_ACCESS, &m_hPrimaryKey );

    switch( m_nLastError )
    {
    case ERROR_SUCCESS:
        nStatus = no_error; break;
    case ERROR_ACCESS_DENIED:
        nStatus = access_denied; break;
    case ERROR_FILE_NOT_FOUND:
        nStatus = not_found; break;
    default:
        nStatus = failed; break;
    }

    m_hSubkey = m_hPrimaryKey;

    return nStatus;
}

int CNTRegistry::MoveToSubkey(WCHAR *pszNewSubkey)
{
    int nStatus = no_error;

    m_nLastError = RegOpenKeyExW(m_hPrimaryKey, pszNewSubkey, 0, KEY_ALL_ACCESS, &m_hSubkey );

    switch( m_nLastError )
    {
    case ERROR_SUCCESS:
        nStatus = no_error; break;
    case ERROR_ACCESS_DENIED:
        nStatus = access_denied; break;
    default:
        nStatus = failed; break;
    }

    return nStatus;
}

int CNTRegistry::DeleteValue(WCHAR *pwszValueName)
{
    int nStatus = no_error;

    m_nLastError = RegDeleteValueW(m_hSubkey, pwszValueName);

    switch( m_nLastError )
    {
    case ERROR_SUCCESS:
        nStatus = no_error; break;
    case ERROR_ACCESS_DENIED:
        nStatus = access_denied; break;
    case ERROR_FILE_NOT_FOUND:
        nStatus = not_found; break;
    default:
        nStatus = failed; break;
    }

    return nStatus;
}

int CNTRegistry::GetDWORD(WCHAR *pwszValueName, DWORD *pdwValue)
{
    int nStatus = no_error;

    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = 0;

    m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType,
                                LPBYTE(pdwValue), &dwSize);

    switch( m_nLastError )
    {
    case ERROR_SUCCESS:
        {
            if (dwType != REG_DWORD)
                nStatus = failed;
            else
                nStatus = no_error; 
        }break;
    case ERROR_ACCESS_DENIED:
        nStatus = access_denied; break;
    case ERROR_FILE_NOT_FOUND:
        nStatus = not_found; break;
    default:
        nStatus = failed; break;
    }

    return nStatus;
}

int CNTRegistry::GetStr(WCHAR *pwszValueName, WCHAR **pwszValue)
{
    *pwszValue = 0;
    DWORD dwSize = 0;
    DWORD dwType = 0;

    m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType,
                                    0, &dwSize);
    if (m_nLastError != 0)
    {
        DEBUGTRACE( ( LOG_WMIADAP, "CNTRegistry::GetStr() failed: %X.\n", m_nLastError ) );
        return failed;
    }

    if ( ( dwType != REG_SZ ) && ( dwType != REG_EXPAND_SZ ) )
    {
        DEBUGTRACE( ( LOG_WMIADAP, "CNTRegistry::GetStr() failed due to an invalid registry data type.\n" ) );
        return failed;
    }

    WCHAR *p = new WCHAR[dwSize];

    m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType,
                                    LPBYTE(p), &dwSize);
    if (m_nLastError != 0)
    {
        delete [] p;
        DEBUGTRACE( ( LOG_WMIADAP, "CNTRegistry::GetStr() failed: %X.\n", m_nLastError ) );
        return failed;
    }

    if(dwType == REG_EXPAND_SZ)
    {
        WCHAR* wszTemp = NULL;

        // Get the initial length

        DWORD nSize = ExpandEnvironmentStringsW( (WCHAR *)p, wszTemp, 0 ) + 10;
        wszTemp = new WCHAR[ nSize ];
        ExpandEnvironmentStringsW( (WCHAR *)p, wszTemp, nSize - 1 );
        delete [] p;
        *pwszValue = wszTemp;
    }
    else
        *pwszValue = p;

    return no_error;
}

int CNTRegistry::GetBinary(WCHAR *pwszValueName, BYTE **ppBuffer)
{
    int nStatus = no_error;
    
    DWORD dwSize = 0;
    DWORD dwType = 0;

    m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType, 0, &dwSize );

    switch( m_nLastError )
    {
    case ERROR_SUCCESS:
        nStatus = no_error; break;
    case ERROR_ACCESS_DENIED:
        nStatus = access_denied; break;
    case ERROR_FILE_NOT_FOUND:
        nStatus = not_found; break;
    default:
        nStatus = failed; break;
    }

    if ( no_error == nStatus )
    {
        if ( dwType != REG_BINARY )
        {
            nStatus = failed;
        }

        if ( no_error == nStatus )
        {
            BYTE* pBuffer = new BYTE[dwSize];

            m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType, pBuffer, &dwSize );

            if ( ERROR_SUCCESS != m_nLastError )
            {
                delete [] pBuffer;
                nStatus = failed;
            }
            else
            {
                *ppBuffer = pBuffer;
            }
        }
    }

    return nStatus;
}

int CNTRegistry::Enum( DWORD dwIndex, WCHAR **pwszValue, DWORD& dwSize )
{

    if (pwszValue == NULL)
    {
        return failed;
    }

    DWORD   dwBuffSize = dwSize;

    m_nLastError = RegEnumKeyExW(m_hSubkey, dwIndex, *pwszValue, &dwBuffSize,
                                    NULL, NULL, NULL, NULL );

    while ( m_nLastError == ERROR_MORE_DATA )
    {
        // Grow in 256 byte chunks
        dwBuffSize += 256;

        try
        {
            // Reallocate the buffer and retry
            WCHAR*  p = new WCHAR[dwBuffSize];

            if ( NULL != *pwszValue )
            {
                delete *pwszValue;
            }

            *pwszValue = p;
            dwSize = dwBuffSize;

            m_nLastError = RegEnumKeyExW(m_hSubkey, dwIndex, *pwszValue, &dwBuffSize,
                                            NULL, NULL, NULL, NULL );

        }
        catch (...)
        {
            ERRORTRACE( ( LOG_WMIADAP, "CNTRegistry::Enum() failed due to out of memory exception.\n" ) );
            return out_of_memory;
        }

    }

    if ( ERROR_SUCCESS != m_nLastError )
    {
        if ( ERROR_NO_MORE_ITEMS == m_nLastError )
        {
            return no_more_items;
        }
        else
        {
            return failed;
        }
    }

    return no_error;
}

int CNTRegistry::GetMultiStr(WCHAR *pwszValueName, WCHAR** pwszValue, DWORD &dwSize)
{
    //Find out the size of the buffer required
    DWORD dwType;
    m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType, NULL, &dwSize);

    //If the error is an unexpected one bail out
    if ((m_nLastError != ERROR_SUCCESS) || (dwType != REG_MULTI_SZ))
    {
        dwSize = 0;
        DEBUGTRACE( ( LOG_WMIADAP, "CNTRegistry::GetMultiStr() failed: %X.\n", m_nLastError ) );
        return failed;
    }

    if (dwSize == 0)
    {
        dwSize = 0;
        DEBUGTRACE( ( LOG_WMIADAP, "CNTRegistry::GetMultiStr() failed due to null string.\n" ) );
        return failed;
    }

    //allocate the buffer required
    WCHAR *pData = new WCHAR[dwSize];
    
    //get the values
    m_nLastError = RegQueryValueExW(m_hSubkey, 
                                   pwszValueName, 
                                   0, 
                                   &dwType, 
                                   LPBYTE(pData), 
                                   &dwSize);

    //if an error bail out
    if (m_nLastError != 0)
    {
        delete [] pData;
        dwSize = 0;
        DEBUGTRACE( ( LOG_WMIADAP, "CNTRegistry::GetMultiStr() failed: %X.\n", m_nLastError ) );
        return failed;
    }

    *pwszValue = pData;

    return no_error;
}

int CNTRegistry::SetDWORD(WCHAR *pwszValueName, DWORD dwValue)
{
    int nStatus = no_error;

    m_nLastError = RegSetValueExW( m_hSubkey, 
                                   pwszValueName,
                                   0,
                                   REG_DWORD,
                                   (BYTE*)&dwValue,
                                   sizeof( dwValue ) );

    if ( m_nLastError != ERROR_SUCCESS )
    {
        nStatus = failed;
    }

    return nStatus;
}

int CNTRegistry::SetStr(WCHAR *pwszValueName, WCHAR *wszValue)
{
    int nStatus = no_error;

    m_nLastError = RegSetValueExW( m_hSubkey, 
                                   pwszValueName,
                                   0,
                                   REG_SZ,
                                   (BYTE*)wszValue,
                                   sizeof(WCHAR) * (wcslen(wszValue) + 1) );

    if ( m_nLastError != ERROR_SUCCESS )
    {
        nStatus = failed;
    }

    return nStatus;
}

int CNTRegistry::SetBinary(WCHAR *pwszValueName, BYTE* pBuffer, DWORD dwSize )
{
    int nStatus = no_error;

    m_nLastError = RegSetValueExW( m_hSubkey, pwszValueName, 0, REG_BINARY, pBuffer, dwSize );

    if ( ERROR_SUCCESS != m_nLastError )
    {
        nStatus = failed;
    }

    return nStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\adap\perflibschema.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    PERFLIBSCHEMA.CPP

Abstract:

    implementation of the CPerfLibSchema class.

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wtypes.h>
#include <oleauto.h>
#include <winmgmtr.h>
#include "PerfLibSchema.h"
#include "AdapUtil.h"

////////////////////////////////////////////////////////////////////////////////
//
//  CIndexTable
//
//  This is a look aside table used for processing the perflib data blob.  It
//  guarentees that no duplicate indicies will be allowed to be added to the 
//  table.
//
////////////////////////////////////////////////////////////////////////////////

int CIndexTable::Locate( int nIndex )
{
    int nRet    = not_found;
    int nSize   = m_array.Size();

    for ( int n = 0; ( not_found == nRet ) && ( n < nSize ); n++ )
    {
        int* pIndex = (int*)m_array.GetAt( n );

        if ( *pIndex == nIndex )
            nRet = n;
    }

    return nRet;
}

BOOL CIndexTable::Add( int nIndex )
{
    BOOL bRet = FALSE;

    if ( not_found == Locate( nIndex ) )
    {
        int* pIndex = new int( nIndex );
        m_array.Add( pIndex );
        bRet = TRUE;
    }

    return bRet;
}

void CIndexTable::Empty()
{
    int nSize = m_array.Size();

    for ( int nIndex = 0; nIndex < nSize; nIndex++ )
    {
        int* pIndex = (int*)m_array.GetAt( nIndex );
        delete pIndex;
    }

    m_array.Empty();
}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPerfLibSchema::CPerfLibSchema( WCHAR* pwcsServiceName, CLocaleCache* pLocaleCache ) 
: m_pLocaleCache( pLocaleCache )
{
    if ( NULL != m_pLocaleCache )
        m_pLocaleCache->AddRef();

	memset( m_apClassList, NULL, WMI_ADAP_NUM_TYPES * sizeof( CPerfClassList* ) );
	
    m_wstrServiceName = pwcsServiceName;
}

CPerfLibSchema::~CPerfLibSchema()
{
    if ( NULL != m_pLocaleCache )
        m_pLocaleCache->Release();

	for ( DWORD dwType = 0; dwType < WMI_ADAP_NUM_TYPES; dwType++ )
	{
		if ( NULL != m_apClassList[ dwType ] )
			m_apClassList[ dwType ]->Release();

		m_aIndexTable[ dwType ].Empty();
	}
}

HRESULT CPerfLibSchema::Initialize( BOOL bDelta, DWORD * pLoadStatus )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CAdapPerfLib*   pPerfLib = NULL;
    BOOL            bInactive = TRUE;

    try
    {
        // Create and initialize the perflib wrapper
        // =========================================
        pPerfLib = new CAdapPerfLib( m_wstrServiceName,pLoadStatus );
        CAdapReleaseMe  rmPerfLib( pPerfLib );

        if ( NULL != pPerfLib )
        {
            if ( bDelta && pPerfLib->CheckStatus( ADAP_PERFLIB_PREVIOUSLY_PROCESSED ) )
			{
				hr = WBEM_S_ALREADY_EXISTS;			
			}
			else if ( pPerfLib->IsOK() )			
			{

			    //
			    // errors from the perflib!Open call are returned here
			    //
                hr = pPerfLib->Initialize();

				// Get the perflib blobs
				// =====================
				if ( SUCCEEDED ( hr ) )
				{
					m_aBlob[COSTLY].SetCostly( TRUE );

					for ( int nBlob = GLOBAL; SUCCEEDED ( hr ) && nBlob < NUMBLOBS; nBlob ++ )
					{
						hr = pPerfLib->GetBlob( m_aBlob[nBlob].GetPerfBlockPtrPtr(), 
												m_aBlob[nBlob].GetSizePtr(), 
												m_aBlob[nBlob].GetNumObjectsPtr(), 
												m_aBlob[nBlob].GetCostly() );

				        // check the return status hr
				        if (FAILED(hr) && 
				            (!pPerfLib->IsCollectOK()) && 
				            pLoadStatus ){
				            (*pLoadStatus) |= EX_STATUS_COLLECTFAIL;
				        }

						// Perflib is inactive if ALL blobs are 0 length
						// =============================================
						bInactive = bInactive && ( 0 == m_aBlob[nBlob].GetSize() );
					}

					if ( bInactive )
					{
						pPerfLib->SetStatus( ADAP_PERFLIB_IS_INACTIVE );
						hr = WBEM_E_FAILED;
					}

					pPerfLib->Close();
				}			
			}
            else
			{
                hr = WBEM_E_FAILED;
			}
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }

        // store the final status in the registry in the EndProcessingStatus
        if ( NULL != pPerfLib )
        {            
            pPerfLib->Cleanup();
        }
    }
    catch(...)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT CPerfLibSchema::GetClassList( DWORD dwType, CClassList** ppClassList )
{
    HRESULT hr = WBEM_S_NO_ERROR;

	// If the class list does not already exist, then create it
	// ========================================================
    if ( NULL == m_apClassList[ dwType ] )
	{
        hr = CreateClassList( dwType );
	}

	// Set pass back the pointer
	// =========================
    if ( SUCCEEDED( hr ) )
    {
        *ppClassList = m_apClassList[ dwType ];
        if ( NULL != *ppClassList )
            (*ppClassList)->AddRef();
    }

    return hr;
}

HRESULT CPerfLibSchema::CreateClassList( DWORD dwType )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    m_apClassList[ dwType ] = new CPerfClassList( m_pLocaleCache, m_wstrServiceName );

    if ( NULL == m_apClassList[ dwType ] )
	{
        hr = WBEM_E_OUT_OF_MEMORY;
	}

    // Cycle through all perfomance blobs (Global & Costly)
    // ====================================================
    if ( SUCCEEDED( hr ) )
    {
        for ( DWORD dwBlob = GLOBAL; dwBlob < NUMBLOBS; dwBlob++ )
        {
            PERF_OBJECT_TYPE* pCurrentObject = NULL;

            CPerfLibBlobDefn* pBlobDefn = &m_aBlob[dwBlob];
            DWORD dwNumObjects = pBlobDefn->GetNumObjects();

            for ( DWORD dwCtr = 0; SUCCEEDED( hr ) && dwCtr < dwNumObjects; dwCtr++ )
            {
                // Get the current object
                // ======================
				if ( 0 == dwCtr )
				{
					pCurrentObject = pBlobDefn->GetBlob();
				}
				else
				{
					LPBYTE  pbData = (LPBYTE) pCurrentObject;
					pbData += pCurrentObject->TotalByteLength;
					pCurrentObject = (PERF_OBJECT_TYPE*) pbData;
				}

				// To ensure uniqueness, we manage a list of processed indicies
				// ============================================================
                if ( m_aIndexTable[dwType].Add( pCurrentObject->ObjectNameTitleIndex ) )
                {
                    hr = m_apClassList[dwType]->AddPerfObject( pCurrentObject, dwType, pBlobDefn->GetCostly() );
                }
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\adap\perfndb.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    PERFNDB.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcli.h>
#include <cominit.h>
#include <winmgmtr.h>
#include <tchar.h>
#include "perfndb.h"
#include "adaputil.h"
#include "adapreg.h"

CPerfNameDb::CPerfNameDb(HKEY hKey):
    m_pMultiCounter(NULL),
    m_pMultiHelp(NULL),
	m_pCounter(NULL),
    m_pHelp(NULL),
	m_Size(0),
	m_fOk(FALSE)
{    
    try {
        
        m_fOk = SUCCEEDED(Init(hKey));
    } 
    catch (...) 
    {
       CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
							     WBEM_MC_ADAP_PERFLIB_SUBKEY_FAILURE,
                                 L"HKEY_PERFORMANCE_xxxTEXT",
                                 CHex( ::GetLastError() ));
    
    }
    //Dump();
}

HRESULT
CPerfNameDb::Init(HKEY hKey)
{
    LONG lRet;
    DWORD dwType;
    DWORD dwInc = 0x10000;
    DWORD dwSize = dwInc;
    BYTE * pData;
    DWORD SizeCounter;
    DWORD SizeHelp;
    WCHAR * pEnd;
	DWORD Index;
    
    HRESULT hr = S_FALSE;


    pData = new BYTE[dwSize];

    if (!pData)
        return WBEM_E_OUT_OF_MEMORY;

retry1:
    {
	    lRet = RegQueryValueEx(hKey,
	                           _T("Counter"),
	                           NULL,
	                           &dwType,
	                           pData,
	                           &dwSize);
	    if (ERROR_SUCCESS == lRet)
	    {
	        m_pMultiCounter = (WCHAR *)pData;
	        pData = NULL;
	        hr = S_OK;
	        SizeCounter = dwSize;
	    }
	    else if (ERROR_MORE_DATA == lRet)
	    {
	        delete [] pData;	        
	        pData = new BYTE[dwSize];
	        if (!pData)
	        {
	            hr = WBEM_E_OUT_OF_MEMORY;
	            goto cleanup;
	        }
			else
			{
				goto retry1;
			}
	    }
	    else
	    {
	        hr = WBEM_E_FAILED;
	        goto cleanup;
	    }
    };

    if (S_OK != hr) // we exited the loop without openeing the DB
        goto cleanup;

    hr = S_FALSE;
    dwSize = dwInc;

    //
    // start a new loop for the help texts
    //
    pData = new BYTE[dwSize];

    if (!pData)
        return WBEM_E_OUT_OF_MEMORY;

retry2:
    {
	    lRet = RegQueryValueEx(hKey,
	                           _T("Help"),
	                           NULL,
	                           &dwType,
	                           pData,
	                           &dwSize);
	    if (ERROR_SUCCESS == lRet)
	    {
	        m_pMultiHelp = (WCHAR *)pData;
	        pData = NULL;
	        hr = S_OK;
	        SizeHelp = dwSize;	        
	    }
	    else if (ERROR_MORE_DATA == lRet)
	    {
	        delete [] pData;	        
	        pData = new BYTE[dwSize];
	        if (!pData)
	        {
	            hr = WBEM_E_OUT_OF_MEMORY;
	            goto cleanup;
	        }
			else
			{
				goto retry2;
			}
	    }
	    else
	    {
	        hr = WBEM_E_FAILED;
	        goto cleanup;
	    }
    };

    if (S_OK != hr) // we exited the loop without openeing the DB
        goto cleanup;
    //
    //  now parse the string, and set-up the arrays
    //
    pEnd = (WCHAR *)(((ULONG_PTR)m_pMultiCounter)+SizeCounter);
	// points to the last char
	pEnd--;
    while (*pEnd == L'\0')
		pEnd--;
	while (*pEnd)
		pEnd--;
	// past the zero after the last index
	pEnd--; 
	while (*pEnd)
		pEnd--;
	// this should point to the last index as a string
	pEnd++;
    
	Index = _wtoi(pEnd);

	if (Index)
	{
		Index+=2; // just to be safe
		m_Size = Index;

        m_pCounter = new WCHAR*[Index];
		if (!m_pCounter){
	        hr = WBEM_E_OUT_OF_MEMORY;
	        goto cleanup;
		}
		memset(m_pCounter,0,Index*sizeof(WCHAR *));

        m_pHelp = new WCHAR*[Index];
		if (!m_pHelp){
	        hr = WBEM_E_OUT_OF_MEMORY;
	        goto cleanup;
		}
		memset(m_pHelp,0,Index*sizeof(WCHAR *));

		DWORD IndexCounter;
        DWORD IndexHelp;
		WCHAR * pStartCounter = m_pMultiCounter;
		WCHAR * pStartHelp = m_pMultiHelp;

		ULONG_PTR LimitMultiCounter = (ULONG_PTR)m_pMultiCounter + SizeCounter;
		ULONG_PTR LimitMultiHelp = (ULONG_PTR)m_pMultiHelp + SizeHelp;

		while ((*pStartCounter) && ((ULONG_PTR)pStartCounter < LimitMultiCounter))
		{
            IndexCounter = _wtoi(pStartCounter);
			while(*pStartCounter)
                pStartCounter++;
			pStartCounter++;     // points to the string
			if (IndexCounter && (IndexCounter < Index))
				m_pCounter[IndexCounter] = pStartCounter;
			// skip the string
			while(*pStartCounter)
                pStartCounter++;  
			pStartCounter++; // points to the next number
		}
		while((*pStartHelp) && ((ULONG_PTR)pStartHelp < LimitMultiHelp))
		{
			IndexHelp = _wtoi(pStartHelp);
			while(*pStartHelp)
                pStartHelp++;
			pStartHelp++;     // points to the string
			if (IndexHelp && (IndexHelp < Index))
				m_pHelp[IndexHelp] = pStartHelp;
			// skip the string
			while(*pStartHelp)
                pStartHelp++;  
			pStartHelp++; // points to the next number		
		}
		hr = S_OK;
	}
	else
	{
		hr = WBEM_E_FAILED;
	}

cleanup:
    if (pData)
        delete [] pData;
    return hr;
}

HRESULT 
CPerfNameDb::GetDisplayName(DWORD dwIndex, 
                            WString& wstrDisplayName )
{
    HRESULT hr;
    if (dwIndex < m_Size)
    {
        try {
            // Check for a vaild display name
            if (m_pCounter[dwIndex]) {
                wstrDisplayName = m_pCounter[dwIndex];
                hr = WBEM_S_NO_ERROR;
            } else {
                hr = WBEM_E_FAILED;
            }            
        } catch (...) {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    } else {
        hr = WBEM_E_INVALID_PARAMETER;
    }
    return hr;
}

HRESULT 
CPerfNameDb::GetDisplayName(DWORD dwIndex, 
                            LPCWSTR* ppwcsDisplayName )
{
    HRESULT hr;
    if (dwIndex < m_Size && ppwcsDisplayName)
    {
        // Check for a vaild display name
        if (m_pCounter[dwIndex]) 
        {
            *ppwcsDisplayName = m_pCounter[dwIndex];
            hr = WBEM_S_NO_ERROR;
        } 
        else 
        {
            hr = WBEM_E_FAILED;
        }
    } else {
        hr = WBEM_E_INVALID_PARAMETER;
    }
    return hr;
}

HRESULT 
CPerfNameDb::GetHelpName( DWORD dwIndex, WString& wstrHelpName )
{
    HRESULT hr;
    if (dwIndex < m_Size)
    {
        try {
            // Check for a vaild display name
            if (m_pHelp[dwIndex]) {
                wstrHelpName = m_pHelp[dwIndex];
                hr = WBEM_S_NO_ERROR;
            } else {
                hr = WBEM_E_FAILED;
            }            
        } catch (...) {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    } else {
        hr = WBEM_E_INVALID_PARAMETER;
    }
    return hr;
};

HRESULT 
CPerfNameDb::GetHelpName( DWORD dwIndex, LPCWSTR* ppwcsHelpName )
{
    HRESULT hr;
    if (dwIndex < m_Size && ppwcsHelpName)
    {
        // Check for a vaild display name
        if (m_pHelp[dwIndex]) 
        {
            *ppwcsHelpName = m_pHelp[dwIndex];
            hr = WBEM_S_NO_ERROR;
        } 
        else 
        {
            hr = WBEM_E_FAILED;
        }
    } else {
        hr = WBEM_E_INVALID_PARAMETER;
    }
    return hr;
};


#ifdef _DUMP_DATABASE_NAME_

VOID 
CPerfNameDb::Dump()
{
    if (m_pHelp && m_pCounter)
	{
		WCHAR pBuff[2048];
        DWORD i;

		for (i=0;i<m_Size;i++)
		{
			if (m_pCounter[i])
			{
		        wsprintfW(pBuff,L"%d %s\n",i,m_pCounter[i]);
				OutputDebugStringW(pBuff);
			}
		}
		
		for (i=0;i<m_Size;i++)
		{
			if (m_pHelp[i])
			{
				if (lstrlenW(m_pHelp[i]) > 100)
				{
					m_pHelp[i][100]=0;
				}
		        wsprintfW(pBuff,L"%d %s\n",i,m_pHelp[i]);
				OutputDebugStringW(pBuff);
			}
		}
	}
};

#endif

CPerfNameDb::~CPerfNameDb()
{
	if (m_pMultiCounter)
		delete [] m_pMultiCounter;
    if (m_pMultiHelp)
        delete [] m_pMultiHelp;
	if (m_pCounter)
		delete [] m_pCounter;
    if (m_pHelp)
		delete [] m_pHelp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\adap\perfthrd.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    PERFTHRD.H

Abstract:

History:

--*/


#ifndef __PERFTHRD_H__
#define __PERFTHRD_H__

#include <wbemcomn.h>
#include <wbemint.h>
#include <winperf.h>
#include "adapthrd.h"

// One minute timeout
#define	PERFTHREAD_DEFAULT_TIMEOUT	60

class CPerfOpenRequest : public CAdapThreadRequest
{
public:

	HRESULT Execute( CAdapPerfLib* pPerfLib );
};

class CPerfCollectRequest : public CAdapThreadRequest
{
private:

	// Return data holders
	PERF_OBJECT_TYPE* m_pData;
	DWORD			m_dwBytes;
	DWORD			m_dwNumObjTypes;
	BOOL			m_fCostly;


public:

	CPerfCollectRequest( BOOL fCostly )
		: m_pData( NULL ), m_dwBytes( 0 ), m_dwNumObjTypes( 0 ), m_fCostly( fCostly ){};

	HRESULT Execute( CAdapPerfLib* pPerfLib );

	void GetData( PERF_OBJECT_TYPE** ppData, DWORD* pdwBytes, DWORD* pdwNumObjTypes )
	{
		*ppData = m_pData;
		*pdwBytes = m_dwBytes;
		*pdwNumObjTypes = m_dwNumObjTypes;
	}
};

class CPerfCloseRequest : public CAdapThreadRequest
{
public:

	HRESULT Execute( CAdapPerfLib* pPerfLib );
};

class CPerfThread : public CAdapThread
{
	DWORD	m_dwPerflibTimeoutSec;

public:
	CPerfThread( CAdapPerfLib* pPerfLib );

	HRESULT Open( CAdapPerfLib* pLib );
	HRESULT	GetPerfBlock( CAdapPerfLib* pLib, PERF_OBJECT_TYPE** ppData, DWORD* pdwBytes, DWORD* pdwNumObjTypes, BOOL fCostly );
	HRESULT	Close( CAdapPerfLib* pLib );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\adap\precomp.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#pragma warning (disable : 4786)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define WIN32_NO_STATUS

#include <ole2.h>
#include <windows.h>

#include "corepol.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\adap\resync.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    RESYNC.CPP

Abstract:

    Implements the windows application or an NT service which
    loads up the various transport prtocols.

    If started with /exe argument, it will always run as an exe.
    If started with /kill argument, it will stop any running exes or services.
    If started with /? or /help dumps out information.

History:

    a-davj  04-Mar-97   Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <malloc.h>
#include <tchar.h>
#include <reg.h>
#include <wbemutil.h>
#include <cntserv.h>
#include <sync.h>
#include <winntsec.h>

#include <wbemidl.h>
#include <cominit.h>
#include <wbemint.h>
#include <wbemprov.h>
#include <winmgmtr.h>
#include <genutils.h>

#include "WinMgmt.h"
#include "adapreg.h"
#include "adaputil.h"
#include "process.h"
#include "resync.h"


// Timeout is a 64-bit value.  See documentation on SetWaitableTimer
// for why we are setting it this way.
#define             _SECOND     10000000
#define             RESYNC_TIMEOUT_INTERVAL 10 * _SECOND
#define             WMIADAP_DEFAULT_DELAY   10

BOOL                gfResyncInit = FALSE;
HANDLE              ghWaitableTimer = NULL;
BOOL                gfSpawnedResync = FALSE;
DWORD               gdwADAPDelaySec = 0;

HANDLE              ghResyncThreadHandle = NULL;
HANDLE              ghResyncThreadEvent = NULL;
CRITICAL_SECTION*   g_pResyncCs = NULL;
DWORD               gdwResyncThreadId = 0;

// A global handle used to store the last dredger we
// kicked off!
HANDLE              ghChildProcessHandle = NULL;

PCREATEWAITABLETIMERW   gpCreateWaitableTimerW = NULL;
PSETWAITABLETIMER       gpSetWaitableTimerW = NULL;
HINSTANCE               ghKernel32;

class CAutoFreeLib
{
public:
    ~CAutoFreeLib() { if ( NULL != ghKernel32 ) FreeLibrary( ghKernel32); }
};

void ResetResyncTimer( HANDLE hResyncTimer )
{
    DWORD dwErr = 0;
    __int64 qwDueTime  = gdwADAPDelaySec * _SECOND; // RESYNC_TIMEOUT_INTERVAL;

    // Convert it to relative time
    qwDueTime *= -1;

    // Copy the relative time into a LARGE_INTEGER.
    LARGE_INTEGER   li;

    li.LowPart  = (DWORD) ( qwDueTime & 0xFFFFFFFF );
    li.HighPart = (LONG)  ( qwDueTime >> 32 );

    if ( !gpSetWaitableTimerW( hResyncTimer, &li, 0, NULL, NULL, FALSE ) )
    {
        dwErr = GetLastError();
    }

}

// This thread controls the actual shelling of a resync perf operation
unsigned __stdcall ResyncPerfThread( void* pVoid )
{
    RESYNCPERFDATASTRUCT*   pResyncPerfData = (RESYNCPERFDATASTRUCT*) pVoid;

    // We get the two handles, copy them and wait on them
    // The first handle is the terminate event, the second is the
    // timer on which to spin off the resync

    HANDLE  aHandles[2];

    aHandles[0] = pResyncPerfData->m_hTerminate;
    HANDLE  hTimer = pResyncPerfData->m_hWaitableTimer;

    CRITICAL_SECTION*   pcs = pResyncPerfData->m_pcs;

    delete pResyncPerfData;
    pResyncPerfData = NULL;

    // Reset the spawned flag
    gfSpawnedResync = FALSE;

    // Okay.  Signal this event so the starting thread can get us going
    SetEvent( ghResyncThreadEvent );

    // Now, if ghChildProcessHandle is not NULL, then we've obviously kicked off a
    // dredge before.  See where the last one is at.  If it's not done, wait for
    // it to finish.  We will always check this at the start of this chunk of code,
    // since we are really the only location in which the process handle can ever get set,
    // and there really shouldn't be more than one thread ever, waiting to start another
    // dredge

    if ( NULL != ghChildProcessHandle )
    {

        aHandles[1] = ghChildProcessHandle;

        DWORD   dwWait = WaitForMultipleObjects( 2, aHandles, FALSE, INFINITE );

        // If abort was signalled, leave!
        if ( dwWait == WAIT_OBJECT_0 )
        {
            return 0;
        }

        // If the process handle was signalled, close the process, reset the timer
        // and we'll get ready to start the next dredge!
        if ( dwWait == WAIT_OBJECT_0 + 1 )
        {
            EnterCriticalSection( pcs );

            CloseHandle( ghChildProcessHandle );
            ghChildProcessHandle = NULL;
            ResetResyncTimer( hTimer );

            LeaveCriticalSection( pcs );

        }

    }
    else
    {
        // If the Child Process Handle is NULL, we've never dredged before, so we'll
        // just reset the timer
        ResetResyncTimer( hTimer );
    }

    BOOL    fHoldOff = TRUE;

    // Reset this handle to the timer now
    aHandles[1] = hTimer;

    while ( fHoldOff )
    {
        // Wait for either the terminate event or the timer
        DWORD   dwWait = WaitForMultipleObjects( 2, aHandles, FALSE, INFINITE );

        // This means the timer was signaled
        if ( dwWait == WAIT_OBJECT_0 + 1 )
        {
            // Quick sanity check on the abort event
            if ( WaitForSingleObject( aHandles[0], 0 ) == WAIT_OBJECT_0 )
            {
                // Outa here!
                break;
            }

            EnterCriticalSection( pcs );

            // Finally, if the current thread id != gdwResyncThreadId, this means another
            // resync perf thread got kicked off, inside of the critical section,
            // so we should just let it wait on the timer.  We don't really need to do
            // this, since the main thread will wait on this thread to complete before
            // it actually kicks off another thread.

            if ( GetCurrentThreadId() != gdwResyncThreadId )
            {
                // Used the following int 3 for debugging
                // _asm int 3;
                LeaveCriticalSection( pcs );
                break;
            }

            // Once we get through the critical section, check that the
            // timer is still signalled.  If it is not, this means that somebody
            // got control of the critical section and reset the timer

            if ( WaitForSingleObject( aHandles[1], 0 ) == WAIT_OBJECT_0 )
            {

                // Last quick sanity check on the abort event
                if ( WaitForSingleObject( aHandles[0], 0 ) == WAIT_OBJECT_0 )
                {
                    // Outa here!
                    LeaveCriticalSection( pcs );
                    break;
                }

                // Okay, we really will try to create the process now.
                gfSpawnedResync = TRUE;

                // We signalled to start the process, so make it so.
                PROCESS_INFORMATION pi;
                STARTUPINFO si;
                memset(&si, 0, sizeof(si));
                si.cb = sizeof(si);

                TCHAR szPath[MAX_PATH+1];
                GetModuleFileName(NULL, szPath, MAX_PATH);

                TCHAR szCmdLine[256];

                _stprintf(szCmdLine, __TEXT("WINMGMT.EXE -RESYNCPERF %d"), _getpid());

                BOOL bRes = CreateProcess(szPath, szCmdLine, NULL, NULL, FALSE, CREATE_NO_WINDOW,
                                        NULL, NULL,  &si, &pi);
                if(bRes)
                {
                    // Who cares about this one?
                    CloseHandle(pi.hThread);

                    // Clean up our old values
                    if ( NULL != ghChildProcessHandle )
                    {
                        CloseHandle( ghChildProcessHandle );
                        ghChildProcessHandle = NULL;
                    }


                    ghChildProcessHandle = pi.hProcess;
                }

                // We're done
                fHoldOff = FALSE;

            }   // Check that we're still signalled, or we will just have to go back to waiting

            LeaveCriticalSection( pcs );

        }   // IF timer was signalled

    }   // WHILE fHoldOff

    return 0;
}

// For the waitable timer
//#define _SECOND 10000000

// Create all the things we need
BOOL InitResync( void )
{
    if ( gfResyncInit )
        return gfResyncInit;

    if ( ( NULL == gpCreateWaitableTimerW ) && ( NULL == gpSetWaitableTimerW ) )
    {
        ghKernel32 = LoadLibrary( __TEXT("Kernel32.dll") );
        if ( NULL == ghKernel32 )
        {
            return FALSE;
        }
        
        gpCreateWaitableTimerW = ( PCREATEWAITABLETIMERW ) GetProcAddress( ghKernel32, "CreateWaitableTimerW" );
        gpSetWaitableTimerW = ( PSETWAITABLETIMER ) GetProcAddress( ghKernel32, "SetWaitableTimer" );

        if ( ( NULL == gpCreateWaitableTimerW ) || ( NULL == gpSetWaitableTimerW ) )
        {
            FreeLibrary( ghKernel32 );
            ghKernel32 = NULL;
            return FALSE;
        }
    }
        
    if ( NULL == ghWaitableTimer )
    {
        ghWaitableTimer = gpCreateWaitableTimerW( NULL, TRUE, NULL );

        // We gotta big problem
        if ( NULL == ghWaitableTimer )
        {
            // Log an error here
            ERRORTRACE( ( LOG_WINMGMT, "Could not create a waitable timer for Resyncperf.\n" ) );
        }

    }

    if ( NULL == ghResyncThreadEvent )
    {
        ghResyncThreadEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

        // We gotta big problem
        if ( NULL == ghResyncThreadEvent )
        {
            // Log an event here
            ERRORTRACE( ( LOG_WINMGMT, "Could not create a ResyncThreadEvent event for Resyncperf.\n" ) );
        }

    }

    // This critical section won't be freed or deleted because of
    // potential timing issues.  But since it's only one, I think
    // we can live with it.
    if ( NULL == g_pResyncCs )
    {
        g_pResyncCs = new CRITICAL_SECTION;

        // We gotta big problem
        if ( NULL == g_pResyncCs )
        {
            // Log an event here
            ERRORTRACE( ( LOG_WINMGMT, "Could not create a ResyncCs critical section for Resyncperf.\n" ) );
        }
        else
        {
            InitializeCriticalSection( g_pResyncCs );
        }

    }

    gfResyncInit = (    NULL    !=  ghWaitableTimer &&
                        NULL    !=  g_pResyncCs     &&
                        NULL    != ghResyncThreadEvent  );

    // Read the initialization information

    CNTRegistry reg;
    
    if ( CNTRegistry::no_error == reg.Open( HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\WBEM\\CIMOM" ) )
    {
        long lError = reg.GetDWORD( L"ADAPDelay", &gdwADAPDelaySec );

        if ( CNTRegistry::no_error == lError )
        {
            //This is what we want
        }
        else if ( CNTRegistry::not_found == lError )
        {
            // Not set, so add it
            reg.SetDWORD( L"ADAPDelay", WMIADAP_DEFAULT_DELAY );
            gdwADAPDelaySec = WMIADAP_DEFAULT_DELAY;
        }
        else
        {
            // Error
            ERRORTRACE( ( LOG_WINMGMT, "ResyncPerf experienced an error while attempting to read the WMIADAPDelay value in the CIMOM subkey.  Continuing using a default value.\n" ) );
            gdwADAPDelaySec = WMIADAP_DEFAULT_DELAY;
        }
    }
    else
    {
        // Error
        ERRORTRACE( ( LOG_WINMGMT, "ResyncPerf could not open the CIMOM subkey to read initialization data. Continuing using a default value.\n" ) );
        gdwADAPDelaySec = WMIADAP_DEFAULT_DELAY;
    }

    return gfResyncInit;
}

// PLEASE NOTE - THIS FUNCTION IS NOT REENTRANT!  PLEASE DO NOT CALL IT ON MULTIPLE THREADS!
void ResyncPerf( HANDLE hTerminate )
{
    // Make sure this is Win2000 or greater
    if ( !IsW2KOrMore() )
    {
        return;
    }

    // Assume that we should check the timer
    BOOL    fFirstTime = !gfResyncInit;

    if ( !InitResync() )
        return;

    // Auto FreeLibrary for the gpKernel32 Library handle
    CAutoFreeLib    aflKernel32;
    
    EnterCriticalSection( g_pResyncCs );

    // Now, if this or the first time, or the spawned resyncflag is set to TRUE, then we need
    // to kick off another thread.  By checking gfSpawnedResync in a critical section, since
    // it only gets set in the same critical section, we ensure that we will resignal as needed
    // as well as only kick off a thread when we really need to.

    BOOL    fSpawnThread = ( fFirstTime || gfSpawnedResync );

    if ( !fSpawnThread )
    {
        // We are here because we don't appear to have spawned a resync.
        // This is either because we are servicing many lodctr requests
        // within our time delay, or a dredger was started and
        // a previous request request to dredge is waiting for
        // the process to complete.  If the child process handle
        // is not NULL, there is no real need to reset the
        // waitable timer

        if ( NULL == ghChildProcessHandle && ghResyncThreadHandle )
        {
            // Reset the timer here
            ResetResyncTimer( ghWaitableTimer );
        }

    }

    LeaveCriticalSection( g_pResyncCs );


    if ( fSpawnThread )
    {
        HANDLE  ahHandle[2];

        if ( NULL != ghResyncThreadHandle )
        {
            ahHandle[0] = hTerminate;
            ahHandle[1] = ghResyncThreadHandle;

            // Wait for ten seconds on this handle.  If it is not signalled, something is
            // direly wrong.  We're probably not going to be able to kick off a dredge
            // so put some info to this effect in the error log.  The only time we should
            // have contention here, is when a lodctr event is signalled, just as the timer
            // becomes signalled.  The resync thread will wake up and start another dredge
            // this thread will wait for the other thread to complete before continuing.
            // We will kick off another resync thread, which will start another dredge,
            // but it will wait for the first dredge to continue.  This is a worst case
            // scenario, and arguably kicking off two dredges isn't that bad of a bailout

            DWORD   dwRet = WaitForMultipleObjects( 2, ahHandle, FALSE, 10000 );

            // We're done
            if ( dwRet == WAIT_OBJECT_0 )
            {
                return;
            }

            if ( dwRet != WAIT_OBJECT_0 + 1 )
            {
                ERRORTRACE( ( LOG_WINMGMT, "The wait for a termination event or ResyncThreadHandle timed out in Resyncperf.\n" ) );
                return;
            }

            CloseHandle( ghResyncThreadHandle );
            ghResyncThreadHandle = NULL;
        }

        EnterCriticalSection( g_pResyncCs );

        DWORD   dwThreadId = 0;

        RESYNCPERFDATASTRUCT*   pResyncData = new RESYNCPERFDATASTRUCT;

        // Boy are we low on memory!
        if ( NULL == pResyncData )
        {
            LeaveCriticalSection( g_pResyncCs );

            // Log an event here
            ERRORTRACE( ( LOG_WINMGMT, "Could not create a RESYNCPERFDATASTRUCT in Resyncperf.\n" ) );
            
            return;
        }

        // Store the data for the resync operation
        pResyncData->m_hTerminate = hTerminate;
        pResyncData->m_hWaitableTimer = ghWaitableTimer;
        pResyncData->m_pcs = g_pResyncCs;

        ghResyncThreadHandle = (HANDLE) _beginthreadex( NULL, 0, ResyncPerfThread, (void*) pResyncData,
                                                        0, (unsigned int *) &gdwResyncThreadId );

        LeaveCriticalSection( g_pResyncCs );


        if ( NULL == ghResyncThreadHandle )
        {
            LeaveCriticalSection( g_pResyncCs );

            // Log an event here
            ERRORTRACE( ( LOG_WINMGMT, "Could not create a ResyncPerfThread thread in Resyncperf.\n" ) );

            return;
        }
        else
        {
            // Wait for the resync thread event to be signalled by the thread we just started.
            // If it doesn't signal in 10 seconds, something is VERY wrong
            DWORD   dwWait = WaitForSingleObject( ghResyncThreadEvent, INFINITE );

            if ( dwWait != WAIT_OBJECT_0 )
            {
                // Log an event
                ERRORTRACE( ( LOG_WINMGMT, "The ResyncPerfThread thread never signaled the ghResyncThreadEvent in Resyncperf.\n" ) );

                return;
            }
        }

    }   // IF fSpawnThread

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\adap\wmibroker.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    WMIBROKER.H

Abstract:

	interface for the CWMIBroker class.

History:

--*/

#ifndef _WMIBROKER_H_
#define _WMIBROKER_H_

#include <wbemcli.h>
#include "perfndb.h"

#define CLSID_NT5PerfProvider_V1     L"{FF37A93C-C28E-11d1-AEB6-00C04FB68820}"
#define CLSID_NT5PerfProvider_V1_Srv L"{76A94DE3-7C26-44f5-8E98-C5AEA48186CB}"

#define CLSID_HiPerfCooker_V1      L"{B0A2AB46-F612-4469-BEC4-7AB038BC476C}"
#define CLSID_HiPerfCooker_V1_Srv  L"{B0A2AB46-F612-4469-BEC4-7AB038BC476C}"


class CWMIBroker  
{
	WString m_wstrNamespace;
	DWORD	m_dwWMIPID;

	HRESULT Connect( IWbemServices** ppNamespace, CPerfNameDb* pDefaultNameDb = NULL );
	HRESULT ConnectToNamespace( IWbemServices** ppNamespace );
	virtual void HandleConnectServerFailure( HRESULT hr );

	HRESULT VerifyNamespace( IWbemServices* pNS );

	virtual HRESULT VerifyProviderClasses( IWbemServices* pNS, 
	                                       LPCWSTR wszProvider, 
	                                       LPCWSTR wszGUID_Client,
	                                       LPCWSTR wszGUID_Server = NULL);
	virtual HRESULT VerifyBaseClasses( IWbemServices* pNS );

	HRESULT VerifyByTemplate( IWbemServices* pNS, IWbemClassObject** ppTemplate, WCHAR* wcsClassName );

	HRESULT SetBaseClassQualifiers( IWbemClassObject* pBaseClass, BOOL bDefault );
	HRESULT SetProperties( IWbemClassObject* pPerfClass );

public:
	CWMIBroker( WString wstrNamespace );
	virtual ~CWMIBroker();

	static HRESULT VerifyWMI();
	static HRESULT GetNamespace( WString wstrNamespace, IWbemServices** ppNamespace );
};

#endif // _WMIBROKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\adap\wmibroker.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    WMIBROKER.H

Abstract:

    implementation of the CWMIBroker class.

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcli.h>
#include <cominit.h>
#include <winmgmtr.h>
#include <stdio.h>

#include "perfndb.h"
#include "adaputil.h"
#include "adapcls.h"
#include "ntreg.h"
#include "WMIBroker.h"

#include <comdef.h>

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CWMIBroker::CWMIBroker( WString wstrNamespace )
: m_wstrNamespace( wstrNamespace )
{
}

CWMIBroker::~CWMIBroker()
{
}

// This function is used to hook us up to Winmgmt and registry data
HRESULT CWMIBroker::Connect( IWbemServices** ppNamespace, CPerfNameDb* pDefaultNameDb )
{
    HRESULT hr = WBEM_NO_ERROR;
    
    IWbemServices* pNamespace = NULL;

		{
            // Connect to the namespace
            hr= ConnectToNamespace( &pNamespace );

            if ( SUCCEEDED( hr ) )
            {
                hr = VerifyNamespace( pNamespace );
            }
            
            if ( SUCCEEDED( hr ) )
            {
                *ppNamespace = pNamespace;
                DEBUGTRACE( ( LOG_WMIADAP, "The ADAP process ( PID: %d ) is connected to the WinMgmt service ( PID: %d )\n", GetCurrentProcessId(), 0 ) );
            }
        }

    return hr;
}

HRESULT CWMIBroker::ConnectToNamespace( IWbemServices** ppNamespace )
{
    IWbemServices*  pNameSpace = NULL;
    IWbemLocator*   pWbemLocator = NULL;
    CReleaseMe      rmWbemLocator(pWbemLocator);

    HRESULT hr = CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (void**) &pWbemLocator );

    if ( SUCCEEDED(hr) )
    {
        // Name space to connect to

        BSTR        bstrNameSpace = NULL;

        try
        {
            bstrNameSpace = SysAllocString( m_wstrNamespace );
        }
        catch(...)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            bstrNameSpace = NULL;
        }

        CSysFreeMe  sfmNameSpace( bstrNameSpace);

        if ( NULL != bstrNameSpace )
        {
            hr = pWbemLocator->ConnectServer(   bstrNameSpace,  // NameSpace Name
                                                NULL,           // UserName
                                                NULL,           // Password
                                                NULL,           // Locale
                                                0L,             // Security Flags
                                                NULL,           // Authority
                                                NULL,           // Wbem Context
                                                &pNameSpace     // Namespace
                                                );

            if ( SUCCEEDED( hr ) )
            {
                // Set Interface security
                hr = WbemSetProxyBlanket( pNameSpace, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
                    RPC_C_AUTHN_LEVEL_PKT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );

                if ( FAILED( hr ) )
                {
                    // Handle this as appropriate
                    if (wcsstr(bstrNameSpace,L"MS_")) {
                        ERRORTRACE( ( LOG_WMIADAP, "ConnectServer on namespace %S hr = %08x\n",(LPWSTR)bstrNameSpace,hr) );
                    } else {
                        HandleConnectServerFailure( hr );
                    }
                }

            }   // IF ConnectServer
            else
            {
                // We are no longer creating namespaces since we are living under
                // root\cimv2 and NOW deriving off of CIM_StatisticalInformation
                // HOWEVER, we'll keep the function around, since the way this thing's
                // going, someone's bound to change this on us AGAIN

                //  hr = CreateNamespace( m_wstrNamespace, &pNameSpace );

                // Handle this as appropriate
                if (wcsstr(bstrNameSpace,L"MS_")) {
                    ERRORTRACE( ( LOG_WMIADAP, "ConnectServer on namespace %S hr = %08x\n",(LPWSTR)bstrNameSpace,hr) );
                } else {
                    HandleConnectServerFailure( hr );
                }
            }
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            // Handle this as appropriate
            HandleConnectServerFailure( hr );
        }
    }
    else
    {
        // Handle this as appropriate
        HandleConnectServerFailure( hr );
    }

    if ( NULL != pNameSpace )
    {
        *ppNamespace = pNameSpace;
    }

    return hr;
}

HRESULT CWMIBroker::VerifyNamespace( IWbemServices* pNS )
{
    HRESULT hr = WBEM_NO_ERROR;

    // Check that the provider classes exist.  We will only do this for the base namespace,
    // Root\cimv2
    if ( lstrcmpiW( m_wstrNamespace, ADAP_ROOT_NAMESPACE ) == 0 )
    {
        hr = VerifyProviderClasses( pNS, L"NT5_GenericPerfProvider_V1", 
                                    CLSID_NT5PerfProvider_V1_Srv,
                                    CLSID_NT5PerfProvider_V1 );

		if ( SUCCEEDED( hr ) )
		{
			hr = VerifyProviderClasses( pNS, L"HiPerfCooker_v1", 
			                           CLSID_HiPerfCooker_V1_Srv,
			                           CLSID_HiPerfCooker_V1);
		}
    }

    if ( SUCCEEDED( hr ) )
    {
        hr = VerifyBaseClasses( pNS );
    }

    return hr;
}

HRESULT 
CWMIBroker::VerifyProviderClasses( IWbemServices* pNamespace, 
	                                       LPCWSTR wszProvider, 
	                                       LPCWSTR wszGUID_Server,
	                                       LPCWSTR wszGUID_Client)
{
    HRESULT hr = WBEM_NO_ERROR;

    // Verify that an instance of the generic provider exists
    // We need to create an object with our desired attributes so that we may
    // use it to compare it to the instance in WMI, if it already exists
    // ======================================================================

    // NOTE:    
    //      What if the generic provider has not been installed
    // ========================================================

    try
    {
        // Create the generic provider instance 
        // ====================================

        IWbemClassObject*    pProviderClass = NULL;

		WCHAR*	wszRelPath = new WCHAR[64 + wcslen( wszProvider )];
		CVectorDeleteMe<WCHAR> dmRelPath( wszRelPath );
		
		swprintf( wszRelPath, L"__Win32Provider.Name=\"%s\"", wszProvider );

        BSTR        bstrProviderInst = SysAllocString( wszRelPath );
        CSysFreeMe  fmProviderInst(bstrProviderInst);

        BSTR        bstrProviderClass = SysAllocString( L"__Win32Provider" );
        CSysFreeMe  fmProviderClass(bstrProviderClass);

        hr = pNamespace->GetObject( bstrProviderClass, 0L, NULL, &pProviderClass, NULL );
        CReleaseMe      rmProviderClass( pProviderClass );

        if ( SUCCEEDED( hr ) )
        {
            IWbemClassObject*    pProviderInstance = NULL;
            _variant_t var;

            hr = pProviderClass->SpawnInstance( 0L, &pProviderInstance );
            CReleaseMe      rmProviderInstance( pProviderInstance );

            if ( SUCCEEDED( hr ) )
            {
                var = wszProvider;
                hr = pProviderInstance->Put(L"Name", 0L, &var, CIM_STRING );
            }

            if ( SUCCEEDED( hr ) )
            {
                var = wszGUID_Server;
                hr = pProviderInstance->Put( L"CLSID", 0L, &var, CIM_STRING );

                if ( SUCCEEDED( hr ) )
                {
                    var = wszGUID_Client;
                    hr = pProviderInstance->Put( L"ClientLoadableCLSID", 0L, &var, CIM_STRING );
                    
                    if ( SUCCEEDED(hr) ){
                        var = L"NetworkServiceHost";
                        hr = pProviderInstance->Put(L"HostingModel",0L,&var,CIM_STRING);
                    }
                    
                }
            }

            if ( SUCCEEDED( hr ) )
            {

                IWbemClassObject*   pDbProviderInstance = NULL;

                // Try to get the object from the db.
                // ==================================

                HRESULT hresDb = pNamespace->GetObject( bstrProviderInst, 0L, NULL,
                                        (IWbemClassObject**)&pDbProviderInstance, NULL );

                // If we got an object from the database, then we need to compare it to the
                // one we just built.  If the comparison fails, we should replace the object
                // =========================================================================

                if ( SUCCEEDED( hresDb ) && NULL != pDbProviderInstance )
                {
                    if ( pProviderInstance->CompareTo( WBEM_FLAG_IGNORE_OBJECT_SOURCE,
                                                pDbProviderInstance ) != WBEM_S_SAME )
                    {
                        hr = pNamespace->PutInstance( pProviderInstance, 0L, NULL, NULL );
                    }

                    pDbProviderInstance->Release();
                }
                else
                {
                    hr = pNamespace->PutInstance( pProviderInstance, 0L, NULL, NULL );
                }
            }
        }
    }
    catch(...)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    // Log an error event and bail, because something is pretty badly wrong
	// ====================================================================
    if ( FAILED( hr ) )
    {
        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
								  WBEM_MC_ADAP_UNABLE_TO_ADD_PROVIDER,
                                  CHex( hr ) );

        ERRORTRACE( ( LOG_WMIADAP, "CAdapSync::VerifyProviderClasses() failed: %X.\n", hr ) );

        return hr;
    }

    // Add the Instance Provider
	// =========================
    try
    {
        IWbemClassObject*    pInstProvRegClass = NULL;

		WCHAR*	wszProviderKey = new WCHAR[ 128 + wcslen( wszProvider ) ];
		CVectorDeleteMe<WCHAR>	dmProviderKey( wszProviderKey );

		swprintf( wszProviderKey, L"__InstanceProviderRegistration.Provider=\"\\\\\\\\.\\\\root\\\\cimv2:__Win32Provider.Name=\\\"%s\\\"\"", wszProvider );

        BSTR        bstrInstProvRegInst = SysAllocString( wszProviderKey );
        CSysFreeMe  fmInstProvRegInst( bstrInstProvRegInst );

        BSTR        bstrInstProvRegClass = SysAllocString( L"__InstanceProviderRegistration" );
        CSysFreeMe  fmInstProvRegClass( bstrInstProvRegClass );
    
        hr = pNamespace->GetObject( bstrInstProvRegClass, 0L, NULL, &pInstProvRegClass, NULL );
        CReleaseMe      rmProviderClass( pInstProvRegClass );

        if ( SUCCEEDED( hr ) )
        {
            IWbemClassObject*    pInstProvRegInstance = NULL;
            _variant_t var;

            hr = pInstProvRegClass->SpawnInstance( 0L, &pInstProvRegInstance);
            CReleaseMe      rmInstProvRegInstance( pInstProvRegInstance );

            if ( SUCCEEDED( hr ) )
            {
				WCHAR*	wszProviderInst = new WCHAR[ 64 + wcslen( wszProvider ) ];
				CVectorDeleteMe<WCHAR> dmProviderInst( wszProviderInst );

				swprintf( wszProviderInst, L"\\\\.\\root\\cimv2:__Win32Provider.Name=\"%s\"", wszProvider );

                var = wszProviderInst;
                hr = pInstProvRegInstance->Put( L"Provider", 0L, (VARIANT*)&var, CIM_REFERENCE );
            }

            if ( SUCCEEDED( hr ) )
            {
                var = bool(true);
                hr = pInstProvRegInstance->Put( L"SupportsGet", 0L, (VARIANT*)&var, CIM_BOOLEAN );
            }
            
            if ( SUCCEEDED( hr ) )
            {
                var = bool(true);
                hr = pInstProvRegInstance->Put( L"SupportsEnumeration", 0L, (VARIANT*)&var, CIM_BOOLEAN );
            }

            if ( SUCCEEDED( hr ) )
            {

                IWbemClassObject*   pDbInstProvRegInstance = NULL;

                // Try to get the object from the db.
                HRESULT hresDb = pNamespace->GetObject( bstrInstProvRegInst, 0L, NULL, &pDbInstProvRegInstance, NULL );

                // If we got an object from the database, then we need to compare it to
                // the one we just built.  If the comparison fails, we should replace the
                // object.

                if ( SUCCEEDED( hresDb ) && NULL != pDbInstProvRegInstance )
                {
                    if ( pInstProvRegInstance->CompareTo( WBEM_FLAG_IGNORE_OBJECT_SOURCE,
                                                pDbInstProvRegInstance ) != WBEM_S_SAME )
                    {
                        hr = pNamespace->PutInstance( pInstProvRegInstance, 0L, NULL, NULL );
                    }

                    pDbInstProvRegInstance->Release();
                }
                else
                {
                    hr = pNamespace->PutInstance( pInstProvRegInstance, 0L, NULL, NULL );
                }

            }   // IF Successfully built the object

        }   // IF able to get the class

    }   
    catch(...)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    if ( FAILED( hr ) )
    {
        // Log the event
        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
								  WBEM_MC_ADAP_UNABLE_TO_ADD_PROVREG,
                                  CHex( hr ) );
    }

    return hr;
}

HRESULT CWMIBroker::VerifyBaseClasses( IWbemServices* pNS )
{
    HRESULT hr = WBEM_NO_ERROR;

    BOOL bDefault = TRUE;

    // Verify the base Perf classes
	// ============================

    try
    {
        _variant_t	var;

		// Verify CIM_StatisticalInformation
		// =================================
		// If the "abstract" qualifier exists, then we presume to be in the 
		// default (as opposed to localized) namespace 

        BSTR    bstrCimStatisticalClass = SysAllocString( ADAP_PERF_CIM_STAT_INFO );
        CSysFreeMe  fmCimStatisticalClass(bstrCimStatisticalClass);

        IWbemClassObject*   pCimStatClass = NULL;

        hr = pNS->GetObject( bstrCimStatisticalClass, 0L, NULL, (IWbemClassObject**)&pCimStatClass, NULL );
        CReleaseMe  rmCimStatClass( pCimStatClass );

		if ( SUCCEEDED( hr ) )
		{
			IWbemQualifierSet* pQualSet = NULL;

			hr = pCimStatClass->GetQualifierSet( &pQualSet );
			CReleaseMe rmStatClass( pQualSet );

			if ( SUCCEEDED ( hr ) )
			{
				bDefault = ( SUCCEEDED ( ( pQualSet->Get( L"abstract", 0, &var, NULL ) ) ) );
			}
		}
		else
		{
		    ERRORTRACE((LOG_WMIADAP,"unable to obtain class CIM_StatisticalInformation for namespace %S:  hr = %08x\n",(WCHAR *)m_wstrNamespace,hr));
		}

		// Verify Win32_Perf
		// =================
		//	We do this by creating a template class with all of the properties and 
		//	qualifiers set, and then compare this to the object in the repository.
		//	If the class does not exist, or if it different that the template, then
		//	update the repository using the template object

        if ( SUCCEEDED ( hr ) )
        {
			IWbemClassObject*    pPerfClass = NULL;

			// Do not use auto release since the pointer 
			// may change in the VerifyByTemplate method
			// =========================================
			hr = pCimStatClass->SpawnDerivedClass( 0L, &pPerfClass );

			// Set the name
			// ============
			if ( SUCCEEDED( hr ) )
			{			    
				var = ADAP_PERF_BASE_CLASS ;
				hr = pPerfClass->Put(L"__CLASS", 0L, &var, CIM_STRING );
			}

			// Set the class qualifiers
			// ========================
			if ( SUCCEEDED( hr ) )
			{
				hr = SetBaseClassQualifiers( pPerfClass, bDefault );
			}

			// Create the class properties
			// ===========================
			if ( SUCCEEDED( hr ) )
			{
				hr = SetProperties( pPerfClass );
			}

			// Verify the repository's version
			// ===============================
			if ( SUCCEEDED( hr ) )
			{
				hr = VerifyByTemplate( pNS, &pPerfClass, ADAP_PERF_BASE_CLASS );
			}

			// If we have had a failure, log an error event and bail
			// =====================================================
			if ( FAILED( hr ) )
			{
				CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
										  WBEM_MC_ADAP_UNABLE_TO_ADD_WIN32PERF,
										  (LPCWSTR)m_wstrNamespace, CHex( hr ) );
				ERRORTRACE( ( LOG_WMIADAP, "CAdapSync::VerifyBaseClasses() failed when comparing Win32_Perf: %X.\n", hr ) );
				return hr;
			}

			// Verify Win32_PerfRawData
			// ========================

			IWbemClassObject*    pRawPerfClass = NULL;
			_variant_t var2;

			// Spawn a derived class
			// =====================
			if ( SUCCEEDED ( hr ) )
			{
				// Do not use auto release since the pointer 
				// may change in the VerifyByTemplate method
				// =========================================
				hr = pPerfClass->SpawnDerivedClass( 0L, &pRawPerfClass );

				// Set the name
				// ============
				if ( SUCCEEDED( hr ) )
				{
					var2 =  ADAP_PERF_RAW_BASE_CLASS ;
					hr = pRawPerfClass->Put(L"__CLASS", 0L, (VARIANT*)&var2, CIM_STRING );

					// Set the class qualifiers
					// ========================
					hr = SetBaseClassQualifiers( pRawPerfClass, bDefault );

					if ( SUCCEEDED( hr ) )
					{
						hr = VerifyByTemplate( pNS, &pRawPerfClass, ADAP_PERF_RAW_BASE_CLASS );
					}

					pRawPerfClass->Release();
				}
				
			}

			// If we have had a failure, log an error event and bail
			// =====================================================
			if ( FAILED( hr ) )
			{
				CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
										  WBEM_MC_ADAP_UNABLE_TO_ADD_WIN32PERFRAWDATA,
										  (LPCWSTR)m_wstrNamespace, CHex( hr ) );
				ERRORTRACE( ( LOG_WMIADAP, "CAdapSync::VerifyBaseClasses() failed when comparing Win32_PerfRawData: %X.\n", hr ) );
				return hr;
			}

			// Verify Win32_PerfFormattedData
			// ==============================

			IWbemClassObject*    pFormattedPerfClass = NULL;

			// Spawn a derived class
			// =====================
			if ( SUCCEEDED ( hr ) )
			{
				// Do not use auto release since the pointer 
				// may change in the VerifyByTemplate method
				// =========================================
				hr = pPerfClass->SpawnDerivedClass( 0L, &pFormattedPerfClass );

				// Set the name
				// ============
				if ( SUCCEEDED( hr ) )
				{
					var2 = ADAP_PERF_COOKED_BASE_CLASS ;
					hr = pFormattedPerfClass->Put(L"__CLASS", 0L, &var2, CIM_STRING );

					// Set the class qualifiers
					// ========================
					hr = SetBaseClassQualifiers( pFormattedPerfClass, bDefault );

					if ( SUCCEEDED( hr ) )
					{
						hr = VerifyByTemplate( pNS, &pFormattedPerfClass, ADAP_PERF_COOKED_BASE_CLASS );
					}

					pFormattedPerfClass->Release();

				}
				
			}

			if ( FAILED( hr ) )
			{
				CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
										  WBEM_MC_ADAP_UNABLE_TO_ADD_WIN32PERFRAWDATA, 
										  (LPCWSTR)m_wstrNamespace, CHex( hr ) );
				ERRORTRACE( ( LOG_WMIADAP, "CAdapSync::VerifyBaseClasses() failed when comparing Win32_PerfFormattedData: %X.\n", hr ) );
				return hr;
			}

			pPerfClass->Release();
		}
    }
    catch(...)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT CWMIBroker::VerifyByTemplate( IWbemServices* pNS, IWbemClassObject** ppTemplate, WCHAR* wcsClassName )
{
	HRESULT hr = WBEM_NO_ERROR;
	BOOL	fGetClass = FALSE;

	IWbemClassObject*   pClass = NULL;

	// Get the repository's version of the class
	// =========================================

	BSTR strClassName = SysAllocString( wcsClassName );
	CSysFreeMe  fmClassName( strClassName );

	HRESULT hresDb = pNS->GetObject( strClassName, 0L, NULL, &pClass, NULL );
	CReleaseMe	rmClass( pClass );

	// If we successfully retrieved an object from the database, then we compare it to
	// the template we just built.  If the comparison fails, we should replace the object
	// ==================================================================================

	if ( SUCCEEDED( hresDb ) && NULL != pClass )
	{
		if ( WBEM_S_SAME == pClass->CompareTo( WBEM_FLAG_IGNORE_OBJECT_SOURCE, *ppTemplate ) )
		{
			// If they are the same, then swap the template for the stored object
			// ==================================================================
			(*ppTemplate)->Release();
			*ppTemplate = pClass;
			(*ppTemplate)->AddRef();
		}
		else
		{
			// If they are not the same, then force an update of the repository
			// ================================================================
			hr = pNS->PutClass( *ppTemplate, WBEM_FLAG_UPDATE_FORCE_MODE, NULL, NULL );

			if ( FAILED( hr ) )
			{
				CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
										  WBEM_MC_ADAP_PERFLIB_PUTCLASS_FAILURE, 
										  ADAP_PERF_RAW_BASE_CLASS, (LPCWSTR) m_wstrNamespace, CHex( hr ) );
			}
			else
			{
				// Now we need to retrieve the class so we can spawn subclasses as necessary
				fGetClass = TRUE;
			}
		}
	}
	else
	{
		// If the retrieval failed, then add the template class to the repository
		// ======================================================================

		hr = pNS->PutClass( *ppTemplate, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );

		if ( FAILED( hr ) )
		{
			CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
									  WBEM_MC_ADAP_PERFLIB_PUTCLASS_FAILURE, 
									  ADAP_PERF_RAW_BASE_CLASS, (LPCWSTR) m_wstrNamespace, CHex( hr ) );
		}
		else
		{
			// Now we need to retrieve the class so we can spawn subclasses as necessary
			fGetClass = TRUE;
		}
	}

	// If we need to retrieve the class from the repository, do so now
	if ( SUCCEEDED( hr ) && fGetClass )
	{
		IWbemClassObject*	pSavedObj = NULL;

		hr = pNS->GetObject( strClassName, 0L, NULL, &pSavedObj, NULL );

		if ( SUCCEEDED( hr ) )
		{
			(*ppTemplate)->Release();
			*ppTemplate = pSavedObj;
		}
		else
		{
			CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
									  WBEM_MC_ADAP_PERFLIB_PUTCLASS_FAILURE, 
									  ADAP_PERF_RAW_BASE_CLASS, (LPCWSTR) m_wstrNamespace, CHex( hr ) );
		}
	}

	return hr;
}

HRESULT CWMIBroker::SetBaseClassQualifiers( IWbemClassObject* pBaseClass, BOOL bDefault )
{
    HRESULT hr = WBEM_NO_ERROR;

    _variant_t    var;
	IWbemQualifierSet*	pQualSet = NULL;

    hr = pBaseClass->GetQualifierSet( &pQualSet );
	CReleaseMe	rmQualSet( pQualSet );

	// In the root namespace the class is abstract, in the 
	// localized namespaces the class is an amendment
	// ===================================================
	if ( bDefault )
	{
		var = bool(true); 
		hr = pQualSet->Put( L"abstract", &var, 0L );

		if ( SUCCEEDED( hr ) )
		{
		    V_VT(&var) = VT_I4;
		    V_I4(&var) = ( ADAP_DEFAULT_LANGID );
			hr = pQualSet->Put( L"Locale", &var, 0L );
		}
	}
	else
	{
		var = bool(true); 
		hr = pQualSet->Put( L"amendment", &var, 0L );
	}

    return hr;
}

HRESULT CWMIBroker::SetProperties( IWbemClassObject* pPerfClass )
{
	HRESULT hr = WBEM_NO_ERROR;

	_variant_t	var;
	V_VT(&var) = VT_NULL;
	V_I8(&var) = 0;
	
	// Create the class properties
	// ===========================

	if ( SUCCEEDED( hr ) )
		hr = pPerfClass->Put(L"Frequency_PerfTime", 0L, &var, CIM_UINT64 );

	if ( SUCCEEDED( hr ) )
		hr = pPerfClass->Put(L"Timestamp_PerfTime", 0L, &var, CIM_UINT64 );
    
	if ( SUCCEEDED( hr ) )
		hr = pPerfClass->Put(L"Timestamp_Sys100NS", 0L, &var, CIM_UINT64 );

	if ( SUCCEEDED( hr ) )
		hr = pPerfClass->Put(L"Frequency_Sys100NS", 0L, &var, CIM_UINT64 );

	if ( SUCCEEDED( hr ) )
		hr = pPerfClass->Put(L"Frequency_Object", 0L, &var, CIM_UINT64 );

	if ( SUCCEEDED( hr ) )
		hr = pPerfClass->Put(L"Timestamp_Object", 0L, &var, CIM_UINT64 );
	
	return hr;
}

// This function is called when we actually fail to connect to a namespace.  Because there are special
// cases for when a localized namespace may or may not exist, derived classes can do their own
// handling.  We, on the other hand, could care less and will always log an event
void CWMIBroker::HandleConnectServerFailure( HRESULT hr )
{
    // Log an event
    CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
							  WBEM_MC_ADAP_CONNECTION_FAILURE,
                              (LPCWSTR) m_wstrNamespace,
                              CHex( hr ) );

}

HRESULT CWMIBroker::GetNamespace( WString wstrNamespace, IWbemServices** ppNamespace )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CWMIBroker aBroker( wstrNamespace );

    hr = aBroker.Connect( ppNamespace );

    return hr;
}

HRESULT CWMIBroker::VerifyWMI()
{
    HRESULT hr = WBEM_E_FAILED;

    HANDLE hWMIMutex = CreateMutex( NULL, FALSE, __TEXT("WINMGMT_ACTIVE") );
    if ( hWMIMutex == NULL || GetLastError() == ERROR_ALREADY_EXISTS)
    {
        hr = WBEM_S_NO_ERROR;
    }

    if ( NULL != hWMIMutex )
    {
        CloseHandle( hWMIMutex );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\adap\perfthrd.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    PERFTHRD.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <process.h>
//#include <wbemcli.h>
//#include <cominit.h>
#include <WinMgmtR.h>
#include "ntreg.h"
#include "perfthrd.h"
#include "adaputil.h"

//  IMPORTANT!!!!

//  This code MUST be revisited to do the following:
//  A>>>>>  Exception Handling around the outside calls
//  B>>>>>  Use a named mutex around the calls
//  C>>>>>  Make the calls on another thread
//  D>>>>>  Place and handle registry entries that indicate a bad DLL!

CPerfThread::CPerfThread( CAdapPerfLib* pPerfLib ) : CAdapThread( pPerfLib )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Constructor
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    CNTRegistry reg;

    if ( CNTRegistry::no_error == reg.Open( HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\WBEM\\CIMOM" ) )
    {
        long lError = reg.GetDWORD( L"ADAPPerflibTimeout", &m_dwPerflibTimeoutSec );
        if ( CNTRegistry::no_error == lError )
        {
            // This is what we want
        }
        else if ( CNTRegistry::not_found == lError )
        {
            // Not set, so add it
            reg.SetDWORD( L"ADAPPerflibTimeout", PERFTHREAD_DEFAULT_TIMEOUT );
            m_dwPerflibTimeoutSec = PERFTHREAD_DEFAULT_TIMEOUT;
        }
        else 
        {
            // Unknown error, continue with default value
            m_dwPerflibTimeoutSec = PERFTHREAD_DEFAULT_TIMEOUT;
        }
    }
    else
    {
        m_dwPerflibTimeoutSec = PERFTHREAD_DEFAULT_TIMEOUT;
    }
}

HRESULT CPerfThread::Open( CAdapPerfLib* pLib )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Open creates a new open request object using the CAdapPerfLib parameter.  It then queues
//  it up and waits for PERFTHREAD_TIMEOUT milliseconds.  If the operation has not returned 
//  in time, then ...
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_E_FAILED;

    try
    {
        // Create new request object
        // =========================

        CPerfOpenRequest*   pRequest = new CPerfOpenRequest;
        CAdapReleaseMe      armRequest( pRequest );

        if ( NULL == pRequest )
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
        else
        {
            // Queue the request and return
            // ============================

            Enqueue( pRequest );

            // Wait for the call to return
            // ===========================

            switch ( WaitForSingleObject( pRequest->GetWhenDoneHandle(), ( m_dwPerflibTimeoutSec * 1000 ) ) )
            {
            case WAIT_OBJECT_0:
                {
                    // SUCCESS: Call returned before it timed-out
                    // ==========================================

                    hr = pRequest->GetHRESULT();
                }break;

            case WAIT_TIMEOUT:
                {
                    pLib->SetStatus( ADAP_PERFLIB_IS_INACTIVE );
                    hr = WBEM_E_FAILED; //Reset();
                    if (!pLib->GetEventLogCalled())
                    {
                        pLib->SetEventLogCalled(TRUE);
                        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_PERFLIB_FUNCTION_TIMEOUT, (LPCWSTR)pLib->GetServiceName(), L"open" );
                    }
                }
            }
        }
    }
    catch(...)
    {
        ERRORTRACE( ( LOG_WMIADAP, "CPerfThread::Open() failed due to out of memory exception.\n" ) );
        hr = WBEM_E_FAILED;
    }

    return hr;
}

HRESULT CPerfThread::GetPerfBlock( CAdapPerfLib* pLib, PERF_OBJECT_TYPE** ppData,
                                       DWORD* pdwBytes, DWORD* pdwNumObjTypes, BOOL fCostly )
{
    HRESULT hr = WBEM_E_FAILED;

    try
    {
        CPerfCollectRequest*    pRequest = new CPerfCollectRequest( fCostly );
        CAdapReleaseMe          armRequest( pRequest );

        Enqueue( pRequest );

        switch ( WaitForSingleObject( pRequest->GetWhenDoneHandle(), ( m_dwPerflibTimeoutSec * 1000 ) ) )
        {
        case WAIT_OBJECT_0:
            {
                hr = pRequest->GetHRESULT();
                pRequest->GetData( ppData, pdwBytes, pdwNumObjTypes );
                if (FAILED(hr)){
                    pLib->SetStatus( ADAP_PERFLIB_FAILED );
                }
            }break;
        case WAIT_TIMEOUT:
            {
                pLib->SetStatus( ADAP_PERFLIB_IS_INACTIVE );
                hr = WBEM_E_FAILED; //Reset();
                if (!pLib->GetEventLogCalled())
                {
                    pLib->SetEventLogCalled(TRUE);
                    CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_BAD_PERFLIB_TIMEOUT, (LPCWSTR)pLib->GetServiceName(), L"collect" );
                }
            }break;
        }
    }
    catch(...)
    {
        // DEVDEV
        // should se call pLib->SetStatus(SOMETHING); ?
        //
        ERRORTRACE( ( LOG_WMIADAP, "CPerfThread::GetPerfBlock() failed due to out of memory exception.\n" ) );
        return WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT CPerfThread::Close( CAdapPerfLib* pLib )
{
    HRESULT hr = WBEM_E_FAILED;
    
    try
    {
        CPerfCloseRequest*  pRequest = new CPerfCloseRequest;
        CAdapReleaseMe      armRequest( pRequest );

        Enqueue( pRequest );

        switch ( WaitForSingleObject( pRequest->GetWhenDoneHandle(), ( m_dwPerflibTimeoutSec * 1000 ) ) )
        {
        case WAIT_OBJECT_0:
            {
                hr = pRequest->GetHRESULT();
            }break;
        case WAIT_TIMEOUT:
            {
                pLib->SetStatus( ADAP_PERFLIB_IS_INACTIVE );
                hr = WBEM_E_FAILED; //Reset();
                if (!pLib->GetEventLogCalled())
                {
                    pLib->SetEventLogCalled(TRUE);
                    CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_BAD_PERFLIB_TIMEOUT, (LPCWSTR)pLib->GetServiceName(), L"close" );
                }
            }break;
        }
    }
    catch(...)
    {
        ERRORTRACE( ( LOG_WMIADAP, "CPerfThread::Close() failed due to out of memory exception.\n" ) );
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT CPerfOpenRequest::Execute( CAdapPerfLib* pPerfLib )
{
    // Call the open function in the perflib
    // =====================================

    m_hrReturn = pPerfLib->_Open();
    return m_hrReturn;
}

HRESULT CPerfCollectRequest::Execute( CAdapPerfLib* pPerfLib )
{
    // Call the collect function in the perflib
    // ========================================

    m_hrReturn = pPerfLib->_GetPerfBlock( &m_pData, &m_dwBytes, &m_dwNumObjTypes, m_fCostly );
    return m_hrReturn;
}

HRESULT CPerfCloseRequest::Execute( CAdapPerfLib* pPerfLib )
{
    // Call the open function in the perflib
    // =====================================

    m_hrReturn = pPerfLib->_Close();
    return m_hrReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\baseprov\baseclsf.inl ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//***************************************************************************
//
// CLocatorFactory::CLocatorFactory
// CLocatorFactory::~CLocatorFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

template<class TProvider>
CLocatorFactory<TProvider>::CLocatorFactory()
{
    m_cRef=0L;
    return;
}

template<class TProvider>
CLocatorFactory<TProvider>::~CLocatorFactory(void)
{
    return;
}

//***************************************************************************
//
// CLocatorFactory::QueryInterface
// CLocatorFactory::AddRef
// CLocatorFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


template<class TProvider>
STDMETHODIMP CLocatorFactory<TProvider>::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return E_NOINTERFACE;
}

template<class TProvider>
STDMETHODIMP_(ULONG) CLocatorFactory<TProvider>::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);;
}

template<class TProvider>
STDMETHODIMP_(ULONG) CLocatorFactory<TProvider>::Release(void)
{
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if(cRef == 0)
    {
        delete this;
    }
    return cRef;
}

//***************************************************************************
//
// CLocatorFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

template<class TProvider>
STDMETHODIMP CLocatorFactory<TProvider>::CreateInstance(LPUNKNOWN pUnkOuter
    , REFIID riid, PPVOID ppvObj)
{
    IHmmLocator *   pObj;
    HRESULT             hr;

    *ppvObj=NULL;
    hr=E_OUTOFMEMORY;

    // This object doesnt support aggregation.

    if (NULL!=pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    //Create the object passing function to notify on destruction.
    
    pObj=(IHmmLocator*)new CProviderLocator<TProvider>;

    if (NULL==pObj)
        return hr;

    hr=pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.
    if (FAILED(hr))
        delete pObj;
    return hr;
}

//***************************************************************************
//
// CLocatorFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************


template<class TProvider>
STDMETHODIMP CLocatorFactory<TProvider>::LockServer(BOOL fLock)
{
    LockServer(fLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\baseprov\basedll.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "baseloc.h"

static long g_cObj = 0;
static long g_cLock = 0;
static HMODULE ghModule;

static BOOL g_bInit = FALSE;

struct CClassInfo
{
    const CLSID* m_pClsid;
    IClassFactory* m_pFactory;
    LPSTR m_szName;
    BOOL m_bFreeThreaded;
};

static CClassInfo g_ClassInfo;

void ObjectCreated()
{
   InterlockedIncrement(&g_cObj);
}

void ObjectDestroyed()
{
   InterlockedDecrement(&g_cObj);
}

void LockServer(BOOL fLock)
{
   if(fLock)
       InterlockedIncrement(&g_cLock);
   else
       InterlockedDecrement(&g_cLock);
}


void SetClassInfo(REFCLSID rclsid, IClassFactory* pFactory, LPSTR szName,
                  BOOL bFreeThreaded)
{
    pFactory->AddRef();

    if(g_ClassInfo.m_pFactory)
        g_ClassInfo.m_pFactory->Release();

    g_ClassInfo.m_pFactory = pFactory;

    g_ClassInfo.m_pClsid = &rclsid;

    g_ClassInfo.m_szName = new char[strlen(szName) + 1];
    strcpy(g_ClassInfo.m_szName, szName);

    g_ClassInfo.m_bFreeThreaded = bFreeThreaded;
}

void SetModuleHandle(HMODULE hModule)
{
    ghModule = hModule;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{

    if(!g_bInit) // protect // TBD!!!!!
    {
        DllInitialize();
        g_bInit = TRUE;
    }

    HRESULT hr;

    if (*g_ClassInfo.m_pClsid!=rclsid)
        return E_FAIL;

    IClassFactory* pObj = g_ClassInfo.m_pFactory;
    if (NULL==pObj)
        return ResultFromScode(E_OUTOFMEMORY);

    hr=pObj->QueryInterface(riid, ppv);

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.//
// Return:  TRUE if there are no objects in use and the class factory 
//          isn't locked.
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
    return sc;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during initialization or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    if(!g_bInit) // protect // TBD!!!!!
    {
        DllInitialize();
        g_bInit = TRUE;
    }

    char       szID[128];
    WCHAR      wcID[128];
    char       szCLSID[128];
    char       szModule[MAX_PATH];
    HKEY hKey1, hKey2;

    // Create the path.

    StringFromGUID2(*g_ClassInfo.m_pClsid, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("CLSID\\"));
    lstrcat(szCLSID, szID);


    // Create entries under CLSID

    RegCreateKey(HKEY_CLASSES_ROOT, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, 
                  (BYTE *)g_ClassInfo.m_szName, 
                  lstrlen(g_ClassInfo.m_szName)+1);
    RegCreateKey(hKey1,"InprocServer32",&hKey2);

    GetModuleFileName(ghModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        lstrlen(szModule)+1);

    const char* szModel;
    if(g_ClassInfo.m_bFreeThreaded)
    {
        szModel = "Both";
    }
    else
    {
        szModel = "Apartment";
    }
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                        (BYTE *)szModel, lstrlen(szModel)+1);
    CloseHandle(hKey1);
    CloseHandle(hKey2);
    return NOERROR;
}


//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    if(!g_bInit) // protect // TBD!!!!!
    {
        DllInitialize();
        g_bInit = TRUE;
    }

    char       szID[128];
    WCHAR      wcID[128];
    char  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    StringFromGUID2(*g_ClassInfo.m_pClsid, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_CLASSES_ROOT, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, "InProcServer32");
        CloseHandle(hKey);
    }

    dwRet = RegOpenKey(HKEY_CLASSES_ROOT, "CLSID", &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        CloseHandle(hKey);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\baseprov\baseloc.h ===
//***************************************************************************
//
//  locator.h
//
//  Copyright (c)1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _LOCATOR__H_
#define _LOCATOR__H_

#include <hmmsvc.h>

typedef void** PPVOID;

// This class is the class factory for CInstPro objects.

template<class TProvider>
class CLocatorFactory : public IClassFactory
{
    protected:
        LONG           m_cRef;

    public:
        CLocatorFactory(void);
        ~CLocatorFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                                 , PPVOID);
        STDMETHODIMP         LockServer(BOOL);
};

#include "baseclsf.inl"

template<class TProvider>
class CProviderLocator : public IHmmLocator
{
    protected:
        LONG           m_cRef;         //Object reference count

    public:
        CProviderLocator();
        ~CProviderLocator(void);

        //Non-delegating object IUnknown
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo){return HMM_E_NOT_SUPPORTED;};

        STDMETHOD(GetTypeInfo)(
           THIS_
           UINT itinfo,
           LCID lcid,
           ITypeInfo FAR* FAR* pptinfo){return HMM_E_NOT_SUPPORTED;};

        STDMETHOD(GetIDsOfNames)(
          THIS_
          REFIID riid,
          OLECHAR FAR* FAR* rgszNames,
          UINT cNames,
          LCID lcid,
          DISPID FAR* rgdispid){return HMM_E_NOT_SUPPORTED;};

        STDMETHOD(Invoke)(
          THIS_
          DISPID dispidMember,
          REFIID riid,
          LCID lcid,
          WORD wFlags,
          DISPPARAMS FAR* pdispparams,
          VARIANT FAR* pvarResult,
          EXCEPINFO FAR* pexcepinfo,
          UINT FAR* puArgErr){return HMM_E_NOT_SUPPORTED;};

       /* IHmmLocator methods */
        STDMETHOD_(SCODE, ConnectServer)(THIS_ BSTR Server,  BSTR User, BSTR Password, BSTR LocaleId, long lFlags, IHmmServices FAR* FAR* ppNamespace);

};

#include "baseloc.inl"

void ObjectCreated();
void ObjectDestroyed();
void LockServer(BOOL bLock);

void SetClassInfo(REFCLSID rclsid, IClassFactory* pFactory, char* szName,
                    BOOL bFreeThreaded);
void SetModuleHandle(HMODULE hModule);
void DllInitialize();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\baseprov\baseprov.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "baseprov.h"

#ifdef __FOR_ALPHA
    #define EXTRA_PUT_PARAMS
#else
    #define EXTRA_PUT_PARAMS ,0
#endif
//***************************************************************************
//
// CInstPro::CInstPro
// CInstPro::~CInstPro
//
//***************************************************************************

CBaseProvider::CBaseProvider(BSTR ObjectPath, BSTR User, BSTR Password)
{
    m_pNamespace = NULL;
    m_cRef=0;

    ObjectCreated();

    IHmmLocator *pOLEMSLocator;
    SCODE sc;

    // Get a pointer locator and use it to get a pointer to the gateway

    sc = CoCreateInstance(CLSID_HmmLocator,
                    NULL,
                    CLSCTX_INPROC_SERVER, 
                    IID_IHmmLocator,
                    (void**)&pOLEMSLocator);
    if(FAILED(sc))
        return;
    
    if(ObjectPath == NULL)
    {
        ObjectPath = L"root\\default";
    }
    sc = pOLEMSLocator->ConnectServer(ObjectPath, User, Password, 0, 0, 
                            &m_pNamespace);
    pOLEMSLocator->Release(); // Release the locator handle, we no longer need it
    if(sc != S_OK) {
        m_pNamespace = NULL;
        return;
        }

#ifndef __FOR_ALPHA
    // Mark this interface pointer as "critical"
    // =========================================

    IHmmConfigure* pConfigure;
    sc = m_pNamespace->QueryInterface(IID_IHmmConfigure, (void**)&pConfigure);
    if(SUCCEEDED(sc))
    {
        pConfigure->SetConfigurationFlags(HMM_CONFIGURATION_FLAG_CRITICAL_USER);
        pConfigure->Release();
    }
    else
    {
        // something weird happened --- old version of HMOM or something
    }
#endif
    
    sc = m_pNamespace->GetObject(L"AssocProvNotifyStatus", 0, &m_pStatusClass, 
                                    NULL);
    if(FAILED(sc)) 
    {
        sc = m_pNamespace->GetObject(L"__ExtendedStatus", 0, &m_pStatusClass,
                                    NULL);
        if(FAILED(sc))
        {
            m_pNamespace = NULL;
            return;
        }
    }
    
    return;
}

CBaseProvider::~CBaseProvider(void)
{
    ObjectDestroyed();
    return;
}

//***************************************************************************
//
// CInstPro::QueryInterface
// CInstPro::AddRef
// CInstPro::Release
//
// Purpose: IUnknown members for CInstPro object.
//***************************************************************************


STDMETHODIMP CBaseProvider::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IHmmServices == riid)
        *ppv=this;

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CBaseProvider::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CBaseProvider::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if(cRef == 0)
    {
        delete this;
    }
    return cRef;
}

//***************************************************************************
//
// CInstPro::PutInstance
//
// Purpose: Wites the intances data.  Here we dont do anything and just
// return HMM_NO_ERROR;
//
//***************************************************************************

STDMETHODIMP CBaseProvider::PutInstance(  IHmmClassObject FAR* pClassInt,
                long lFlags, IHmmClassObject FAR* FAR* ppErrorObject)
{
    return HMM_E_NOT_SUPPORTED;
}


//***************************************************************************
//
// CInstPro::CreateInstanceEnumAsync
//
// Purpose: Asynchronously enumerates the instances.  AsyncEnum is where the
//          thread runs.
//
//***************************************************************************

SCODE CBaseProvider::StuffErrorCode(HRESULT hCode, IHmmObjectSink* pSink)
{
    IHmmClassObject* pStatus;
    HRESULT hres;

    hres = m_pStatusClass->SpawnInstance(0, &pStatus);
    VARIANT v;
    V_VT(&v) = VT_I4;
    V_I4(&v) = hCode;
    hres = pStatus->Put(L"StatusCode", 0, &v EXTRA_PUT_PARAMS);

    hres = pSink->Indicate(1, &pStatus);
    pStatus->Release();
    return hres;
}


SCODE CBaseProvider::CreateInstanceEnumAsync( BSTR RefStr, long lFlags, 
       IHmmObjectSink FAR* pHandler, long FAR* plAsyncRequestHandle)
{
    HRESULT hres = EnumInstances(RefStr, lFlags, pHandler);
    StuffErrorCode(hres, pHandler);
    return hres;
}

SCODE CBaseProvider::GetObjectAsync(BSTR ObjectPath, long lFlags,
                    IHmmObjectSink FAR* pHandler, long * plAsyncRquestHandle)
{
    CObjectPathParser Parser;
    ParsedObjectPath* pParsedPath;
    int nRes = Parser.Parse(ObjectPath, &pParsedPath);
    if(nRes != CObjectPathParser::NoError)
    {
        return HMM_E_INVALID_PARAMETER;
    }

    IHmmClassObject* pInstance;
    HRESULT hres = GetInstance(pParsedPath, lFlags, &pInstance);
    Parser.Free(pParsedPath);

    StuffErrorCode(hres, pHandler);
    return HMM_S_NO_ERROR;
}
 
STDMETHODIMP CBaseProvider::ExecQueryAsync(BSTR QueryFormat, BSTR Query, 
                                           long lFlags, 
        IHmmObjectSink* pResponseHandler, long* plAsyncRequestHandle)
{
    StuffErrorCode(HMM_E_PROVIDER_NOT_CAPABLE, pResponseHandler);
    return HMM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\comlib\commain.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    COMMAIN.CPP

Abstract:

    COM Helpers

History:

--*/

#include <windows.h>
#include <objbase.h>
#include <stdio.h>
#include <vector>
#include <clsfac.h>
#include "commain.h"

void CopyOrConvert(TCHAR * pTo, WCHAR * pFrom, int iLen)
{ 
#ifdef UNICODE
    lstrcpy(pTo, pFrom);
#else
    wcstombs(pTo, pFrom, iLen);
#endif
    return;
}

struct CClassInfo
{
    const CLSID* m_pClsid;
    CUnkInternal* m_pFactory;
    LPTSTR m_szName;
    BOOL m_bFreeThreaded;
    BOOL m_bReallyFree;
    DWORD m_dwCookie;
public:
    CClassInfo(): m_pClsid(0), m_pFactory(0), m_szName(0), m_bFreeThreaded(0), m_dwCookie(0){}
    CClassInfo(CLSID* pClsid, LPTSTR szName, BOOL bFreeThreaded, BOOL bReallyFree) : 
        m_pClsid(pClsid), m_pFactory(NULL), m_szName(szName), 
        m_bFreeThreaded(bFreeThreaded), m_bReallyFree( bReallyFree )
    {}
	~CClassInfo() 
	{ delete [] m_szName; m_pFactory->InternalRelease();}
};

static std::vector<CClassInfo*>* g_pClassInfos;
static HMODULE ghModule;

/*
class __CleanUp
{
public:
	__CleanUp() {}
	~__CleanUp() 
	{
		g_pClassInfos->erase();
	}
};
*/

void SetModuleHandle(HMODULE hModule)
{
    ghModule = hModule;
}

HMODULE GetThisModuleHandle()
{
    return ghModule;
}


HRESULT RegisterServer(CClassInfo* pInfo, BOOL bExe)
{
    TCHAR       szID[128];
    WCHAR      wcID[128];
    TCHAR       szCLSID[128];
    TCHAR       szModule[MAX_PATH];
    HKEY hKey1, hKey2;

    // Create the path.

    StringFromGUID2(*pInfo->m_pClsid, wcID, 128);
    CopyOrConvert(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\Classes\\CLSID\\"));
    lstrcat(szCLSID, szID);


    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);

    TCHAR* szName = new TCHAR[lstrlen(pInfo->m_szName)+100];
#ifdef UNICODE
    wsprintf(szName, L"Microsoft WBEM %s", pInfo->m_szName);
#else
    sprintf(szName, "Microsoft WBEM %s", pInfo->m_szName);
#endif

    RegSetValueEx(hKey1, NULL, 0, REG_SZ, 
                  (BYTE *)szName, (lstrlen(szName)+1) * sizeof(TCHAR));
    RegCreateKey(hKey1,
        bExe?TEXT("LocalServer32"): TEXT("InprocServer32"),
        &hKey2);

    GetModuleFileName(ghModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        (lstrlen(szModule)+1) * sizeof(TCHAR));

    const TCHAR* szModel;
    if(pInfo->m_bFreeThreaded)
    {
		if ( !pInfo->m_bReallyFree )
		{
			szModel = TEXT("Both");
		}
		else
		{
			szModel = TEXT("Free");
		}
    }
    else
    {
        szModel = TEXT("Apartment");
    }
    RegSetValueEx(hKey2, TEXT("ThreadingModel"), 0, REG_SZ, 
                                        (BYTE *)szModel, (lstrlen(szModel)+1) * sizeof(TCHAR));

    RegCloseKey(hKey1);
    RegCloseKey(hKey2);
    return NOERROR;
}

HRESULT UnregisterServer(CClassInfo* pInfo, BOOL bExe)
{
    TCHAR       szID[128];
    WCHAR      wcID[128];
    TCHAR  szCLSID[256];
    HKEY hKey;

    // Create the path using the CLSID

    StringFromGUID2(*pInfo->m_pClsid, wcID, 128);
    CopyOrConvert(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\Classes\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, bExe? TEXT("LocalServer32"): TEXT("InProcServer32"));
        RegCloseKey(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Classes\\CLSID"), &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        RegCloseKey(hKey);
    }

    return NOERROR;
}

extern CLifeControl* g_pLifeControl;
CComServer* g_pServer = NULL;

CComServer::CComServer()    
{
    g_pServer = this;
}

CLifeControl* CComServer::GetLifeControl()
{
    return g_pLifeControl;
}

HRESULT CComServer::InitializeCom()
{
    return CoInitialize(NULL);
}

HRESULT CComServer::AddClassInfo( REFCLSID rclsid, 
                                  CUnkInternal* pFactory, 
                                  LPTSTR szName, 
                                  BOOL bFreeThreaded, 
                                  BOOL bReallyFree /* = FALSE */)
{
    if ( NULL == g_pClassInfos )
    {
        return E_FAIL;
    }

    if(pFactory == NULL)
        return E_OUTOFMEMORY;

    CClassInfo* pNewInfo = new CClassInfo;

    if (!pNewInfo)
        return E_OUTOFMEMORY;
    
    //
    // this object does not hold external references to class factories.
    //
    pFactory->InternalAddRef();

    pNewInfo->m_pFactory = pFactory;
    pNewInfo->m_pClsid = &rclsid;

    pNewInfo->m_szName = new TCHAR[lstrlen(szName) + 1];
    if (!pNewInfo->m_szName)
    {
        delete pNewInfo;
        return E_OUTOFMEMORY;
    }

    lstrcpy(pNewInfo->m_szName, szName);
    pNewInfo->m_bFreeThreaded = bFreeThreaded;
	pNewInfo->m_bReallyFree = bReallyFree;

    g_pClassInfos->insert( g_pClassInfos->end(), pNewInfo );
    return S_OK;
}

HRESULT CComServer::RegisterInterfaceMarshaler(REFIID riid, LPTSTR szName,
                                            int nNumMembers, REFIID riidParent)
{
    TCHAR       szID[128];
    WCHAR      wcID[128];
    TCHAR       szPath[256];
    HKEY hKey1, hKey2;

    // Create the path.

    StringFromGUID2(riid, wcID, 128);
    CopyOrConvert(szID, wcID, 128);
    lstrcpy(szPath, TEXT("SOFTWARE\\Classes\\Interface\\"));
    lstrcat(szPath, szID);


    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szPath, &hKey1);

    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)szName, (lstrlen(szName)+1) * sizeof(TCHAR));
    RegCreateKey(hKey1, TEXT("ProxyStubClsid32"), &hKey2);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szID, (lstrlen(szID)+1) * sizeof(TCHAR));
    
    RegCloseKey(hKey1);
    RegCloseKey(hKey2);
    return S_OK;
}

HRESULT CComServer::RegisterInterfaceMarshaler(REFIID riid, CLSID psclsid, LPTSTR szName,
                                            int nNumMembers, REFIID riidParent)
{

    TCHAR       szID[128];
	TCHAR		szClsID[128];
    WCHAR      wcID[128];
    TCHAR       szPath[128];
	TCHAR		szNumMethods[32];
    HKEY hKey1, hKey2, hKey3;

    // Create the path.

    StringFromGUID2(riid, wcID, 128);
    CopyOrConvert(szID, wcID, 128);

	// ProxyStub Class ID
    StringFromGUID2(psclsid, wcID, 128);
    CopyOrConvert(szClsID, wcID, 128);

    lstrcpy(szPath, TEXT("SOFTWARE\\Classes\\Interface\\"));
    lstrcat(szPath, szID);

	// Number of Methods
	wsprintf( szNumMethods, TEXT("%d"), nNumMembers );

    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szPath, &hKey1);

    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)szName, (lstrlen(szName)+1) * sizeof(TCHAR));
    RegCreateKey(hKey1, TEXT("ProxyStubClsid32"), &hKey2);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szClsID, (lstrlen(szID)+1) * sizeof(TCHAR));

    RegCreateKey(hKey1, TEXT("NumMethods"), &hKey3);
    RegSetValueEx(hKey3, NULL, 0, REG_SZ, (BYTE *)szNumMethods, (lstrlen(szNumMethods)+1) * sizeof(TCHAR));
    
    RegCloseKey(hKey1);
    RegCloseKey(hKey2);
    RegCloseKey(hKey3);
    return S_OK;
}

HRESULT CComServer::UnregisterInterfaceMarshaler(REFIID riid)
{
    TCHAR       szID[128];
    WCHAR      wcID[128];
    TCHAR  szPath[128];
    HKEY hKey;

    // Create the path using the CLSID

    StringFromGUID2(riid, wcID, 128);
    CopyOrConvert(szID, wcID, 128);
    lstrcpy(szPath, TEXT("SOFTWARE\\Classes\\Interface\\"));
    lstrcat(szPath, szID);

    // First delete the ProxyStubClsid32 subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szPath, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, TEXT("ProxyStubClsid32"));
        RegCloseKey(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Classes\\Interface"), &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, szID);
        RegCloseKey(hKey);
    }

    return S_OK;
}

BOOL GlobalCanShutdown()
{
    return g_pServer->CanShutdown();
}

HRESULT GlobalInitialize()
{
    g_pClassInfos = new std::vector<CClassInfo*>;

    if ( g_pClassInfos == NULL )
    {
        return E_OUTOFMEMORY;
    }

    return g_pServer->Initialize();
}

void GlobalUninitialize()
{
    g_pServer->Uninitialize();
   
    if ( NULL != g_pClassInfos )
    {
        for( int i=0; i < g_pClassInfos->size(); i++ )
        {
            delete (*g_pClassInfos)[i];
        }

        delete g_pClassInfos;
        g_pClassInfos = NULL;
    }
}

void GlobalPostUninitialize()
{
    g_pServer->PostUninitialize();
}

void GlobalRegister()
{
    g_pServer->Register();
}

void GlobalUnregister()
{
    g_pServer->Unregister();
}

HRESULT GlobalInitializeCom()
{
    return g_pServer->InitializeCom();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\baseprov\basemain.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "baseloc.h"

BOOL WINAPI DllMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pvReserved)
{
    if (DLL_PROCESS_ATTACH==ulReason)
    {
        SetModuleHandle(hInstance);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\baseprov\baseloc.inl ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

template<class TProvider>
CProviderLocator<TProvider>::CProviderLocator()
{
    m_cRef=0;
    ObjectCreated();
    return;
}

template<class TProvider>
CProviderLocator<TProvider>::~CProviderLocator(void)
{
    ObjectDestroyed();
    return;
}

template<class TProvider>
STDMETHODIMP CProviderLocator<TProvider>::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || riid == IID_IHmmLocator)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

template<class TProvider>
STDMETHODIMP_(ULONG) CProviderLocator<TProvider>::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

template<class TProvider>
STDMETHODIMP_(ULONG) CProviderLocator<TProvider>::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if(cRef == 0)
    {
        delete this;
    }
    return cRef;
}

template<class TProvider>
STDMETHODIMP CProviderLocator<TProvider>::ConnectServer(BSTR Path,  
                              BSTR User, BSTR Password, 
                              BSTR LocaleId, long lFlags, 
                              IHmmServices FAR* FAR* ppNamespace)
{
    SCODE sc;  

    // Create a new instance of the provider to handle the namespace.

    TProvider * pNew = new TProvider(Path,User,Password);
    if(pNew == NULL)
        return HMM_E_FAILED;
    sc = pNew->QueryInterface(IID_IHmmServices,(void **) ppNamespace);
    if(sc != S_OK) 
        delete pNew;
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\comlib\commain.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    COMMAIN.H

Abstract:

	COM Helpers.

History:

--*/

#ifndef __WBEM_COMMAIN__H_
#define __WBEM_COMMAIN__H_

#include <unk.h>
#include <clsfac.h>

HMODULE GetThisModuleHandle();

class CComServer
{
public:
    virtual HRESULT Initialize() = 0;
    virtual void Uninitialize(){}
    virtual void PostUninitialize(){}
    virtual HRESULT InitializeCom();
    virtual void Register(){}
    virtual void Unregister(){}
    virtual BOOL CanShutdown(){ return TRUE; }

    CLifeControl* GetLifeControl();
protected:
    CComServer();

    HRESULT AddClassInfo( REFCLSID rclsid, 
                          CUnkInternal* pFactory, 
                          LPTSTR szName,
                          BOOL bFreeThreaded, 
                          BOOL bReallyFree = FALSE );
	
	// Assumes riid and ProxyStubClsId are same
    HRESULT RegisterInterfaceMarshaler(REFIID riid, LPTSTR szName, 
                                int nNumMembers, REFIID riidParent);
	// ProxyStubClsId must be explicitly specified
    HRESULT RegisterInterfaceMarshaler(REFIID riid, CLSID psclsid, LPTSTR szName, 
                                int nNumMembers, REFIID riidParent);
    HRESULT UnregisterInterfaceMarshaler(REFIID riid);
};

/***************************************************************************
  We are trying NOT to be dependant on wbemcomn in this module.  This is 
  so this library will not have to be paired with the static or dll version
  of wbemcomn.  This is the reason for the following definitions ...
****************************************************************************/

class CMyCritSec : public CRITICAL_SECTION
{
public:
    CMyCritSec() 
    {
        InitializeCriticalSection(this);
    }
    ~CMyCritSec()
    {
        DeleteCriticalSection(this);
    }
    void Enter()
    {
        EnterCriticalSection(this);
    }
    void Leave()
    {
        LeaveCriticalSection(this);
    }
};

class CMyInCritSec
{
protected:
    CRITICAL_SECTION* m_pcs;
public:
    CMyInCritSec(CRITICAL_SECTION* pcs) : m_pcs(pcs)
    {
        EnterCriticalSection(m_pcs);
    }
    ~CMyInCritSec()
    {
        LeaveCriticalSection(m_pcs);
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\baseprov\baseprov.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#ifndef _PROVIDER__H_
#define _PROVIDER__H_

#include <windows.h>
#include <hmmsvc.h>
#include <genlex.h>
#include <objpath.h>

#include "baseloc.h"

class CBaseProvider : public IHmmServices
{
    protected:
        LONG              m_cRef;         //Object reference count
        IHmmServices *  m_pNamespace;
        IHmmClassObject * m_pStatusClass;

     public:
        CBaseProvider(BSTR ObjectPath = NULL, BSTR User = NULL, 
                       BSTR Password = NULL);
        ~CBaseProvider();

        //Non-delegating object IUnknown

        STDMETHOD(QueryInterface)(REFIID, PPVOID);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);

        STDMETHOD(GetTypeInfoCount)(UINT* pctinfo){return HMM_E_NOT_SUPPORTED;};

        STDMETHOD(GetTypeInfo)(
           THIS_
           UINT itinfo,
           LCID lcid,
           ITypeInfo** pptinfo){return HMM_E_NOT_SUPPORTED;};

        STDMETHOD(GetIDsOfNames)(
          THIS_
          REFIID riid,
          OLECHAR** rgszNames,
          UINT cNames,
          LCID lcid,
          DISPID* rgdispid){return HMM_E_NOT_SUPPORTED;};

        STDMETHOD(Invoke)(
          THIS_
          DISPID dispidMember,
          REFIID riid,
          LCID lcid,
          WORD wFlags,
          DISPPARAMS* pdispparams,
          VARIANT* pvarResult,
          EXCEPINFO* pexcepinfo,
          UINT* puArgErr){return HMM_E_NOT_SUPPORTED;};


        //IHmmServices
    STDMETHOD(OpenNamespace)(BSTR Namespace, long lFlags, 
        IHmmServices** ppNewContext, 
        IHmmClassObject** ppErrorObject) {return HMM_E_NOT_SUPPORTED;}
    STDMETHOD(CancelAsyncRequest)(long lAsyncRequestHandle)
        {return HMM_E_NOT_SUPPORTED;};
    STDMETHOD(QueryObjectSink)(IHmmObjectSink** ppResponseHandler, 
        IHmmClassObject** ppErrorObject){return HMM_E_NOT_SUPPORTED;};
    STDMETHOD(GetObject)(BSTR ObjectPath, long lFlags, 
        IHmmClassObject** ppObject, IHmmClassObject** ppErrorObject)
        {return HMM_E_NOT_SUPPORTED;}

    STDMETHOD(GetObjectAsync)(BSTR ObjectPath, long lFlags, 
        IHmmObjectSink* pResponseHandler, long* plAsyncRequestHandle);

    STDMETHOD(PutClass)(IHmmClassObject* pObject, long lFlags, 
        IHmmClassObject** ppErrorObject){return HMM_E_NOT_SUPPORTED;};
    STDMETHOD(PutClassAsync)(IHmmClassObject* pObject, long lFlags, 
        IHmmObjectSink* pResponseHandler, long* plAsyncRequestHandle)
        {return HMM_E_NOT_SUPPORTED;};
    STDMETHOD(DeleteClass)(BSTR Class, long lFlags, 
        IHmmClassObject** ppErrorObject){return HMM_E_NOT_SUPPORTED;};
    STDMETHOD(DeleteClassAsync)(BSTR Class, long lFlags, 
        IHmmObjectSink* pResponseHandler, long* plAsyncRequestHandle)
        {return HMM_E_NOT_SUPPORTED;};
    STDMETHOD(CreateClassEnum)(BSTR Superclass, long lFlags, 
        IEnumHmmClassObject** ppEnum, IHmmClassObject** ppErrorObject)
        {return HMM_E_NOT_SUPPORTED;};
    STDMETHOD(CreateClassEnumAsync)(BSTR Superclass, long lFlags, 
        IHmmObjectSink* pResponseHandler, long* plAsyncRequestHandle)
        {return HMM_E_NOT_SUPPORTED;};

    STDMETHOD(PutInstance)(IHmmClassObject* pInst, long lFlags, 
        IHmmClassObject** ppErrorObject);

    STDMETHOD(PutInstanceAsync)(IHmmClassObject* pInst, long lFlags, 
        IHmmObjectSink* pResponseHandler, long* plAsyncRequestHandle)
        {return HMM_E_NOT_SUPPORTED;};
    STDMETHOD(DeleteInstance)(BSTR ObjectPath, long lFlags, 
        IHmmClassObject** ppErrorObject){return HMM_E_NOT_SUPPORTED;};
    STDMETHOD(DeleteInstanceAsync)(BSTR ObjectPath, long lFlags, 
        IHmmObjectSink* pResponseHandler, long* plAsyncRequestHandle)
        {return HMM_E_NOT_SUPPORTED;};
    STDMETHOD(CreateInstanceEnum)(BSTR Class, long lFlags, 
        IEnumHmmClassObject** ppEnum, IHmmClassObject** ppErrorObject) 
        {return HMM_E_NOT_SUPPORTED;}

    STDMETHOD(CreateInstanceEnumAsync)(BSTR Class, long lFlags, 
        IHmmObjectSink* pResponseHandler, long* plAsyncRequestHandle);

    STDMETHOD(ExecQuery)(BSTR QueryLanguage, BSTR Query, long lFlags, 
        IEnumHmmClassObject** ppEnum, IHmmClassObject** ppErrorObject)
        {return HMM_E_NOT_SUPPORTED;}

    STDMETHOD(ExecQueryAsync)(BSTR QueryFormat, BSTR Query, long lFlags, 
        IHmmObjectSink* pResponseHandler, long* plAsyncRequestHandle);

public: //helpers

    HRESULT StuffErrorCode(HRESULT hCode, IHmmObjectSink* pSink);

protected: // override
    virtual HRESULT EnumInstances(BSTR strClass, long lFlags, 
                                  IHmmObjectSink* pHandler) = 0;
    virtual HRESULT GetInstance(ParsedObjectPath* pPath, long lFlags,
                                  IHmmClassObject** ppInstance) = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\comlib\precomp.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\comlib\sources.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

WMIPRECOMPSHARED=1
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETPATH=obj
TARGETTYPE=LIBRARY

# The INCLUDES variable specifies any include paths that are specific to
# this source directory. Separate multiple paths with single
# semicolons. Relative path specifications are okay.
INCLUDES=$(INCLUDES); \
	$(WBEMCOMN_INC)

# Next, specify options for the compiler using C_DEFINES.
C_DEFINES=$(C_DEFINES) /D__WINNT_BUILD__ /D_UNICODE /DUNICODE
USE_NATIVE_EH=1

USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\contprov\common.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#ifndef _COMMON_H_
#define _COMMON_H_

#include <stdio.h>

#define LOGFILE	"LOG.TXT"

// Logging macros

#define _LOGGING

#ifdef _LOGGING

#define INITLOG \
{\
DeleteFile(LOGFILE);\
}

#define LOG(msg) \
{\
FILE *f = fopen(LOGFILE, "a");\
SYSTEMTIME st;\
GetLocalTime(&st);\
fprintf(f, "%u\\%u\\%u %u:%u %s\n", st.wDay, st.wMonth, st.wYear, st.wHour, st.wMinute, msg);\
fclose(f);\
}

#define LOGERROR(msg) \
{\
FILE *f = fopen(LOGFILE, "a");\
SYSTEMTIME st;\
GetLocalTime(&st);\
fprintf(f, "%u\\%u\\%u %u:%2u **ERROR**: %s\n", st.wDay, st.wMonth, st.wYear, st.wHour, st.wMinute, msg);\
fclose(f);\
}

#else

#define INITLOG
#define LOG(msg)
#define ERROR(msg)

#endif // _LOGGING

#endif // _COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\contprov\hiperfserver.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// HiPerfServer.cpp: implementation of the CHiPerfServer class.
//
//////////////////////////////////////////////////////////////////////

#define _WIN32_DCOM

#include <commain.h>
#include <clsfac.h>
#include <wbemcli.h>
#include <wbemint.h>

#include "common.h"
#include "HiPerProv.h"
#include "HiPerfServer.h"
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

class CHiPerfServer : public CComServer  
{
public:

	virtual void Initialize()
	{
		INITLOG;
		LOG("Initializing server.");

		AddClassInfo(CLSID_ContinousProvider_v1, 
			new CSimpleClassFactory<CHiPerfProvider>(GetLifeControl()), 
			"WBEM HiPerf Provider", TRUE);
	}
} g_Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\comlib\comdllsv\dllmain.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    DLLMAIN.CPP

Abstract:

    DLL/COM helpers.

History:

--*/

#include "precomp.h"
#include "commain.cpp"

#define DBG_PRINTFA( a ) { char pBuff[256]; sprintf a ; OutputDebugStringA(pBuff); }

class CDllLifeControl : public CLifeControl
{
protected:
    long m_lCount;
public:
    CDllLifeControl() : m_lCount(0) {}

    virtual BOOL ObjectCreated(IUnknown* pv)
    {
        InterlockedIncrement(&m_lCount);
        //DBG_PRINTFA((pBuff,"+ %p\n",pv));
        return TRUE;
    }
    virtual void ObjectDestroyed(IUnknown* pv)
    {
        InterlockedDecrement(&m_lCount);
        //DBG_PRINTFA((pBuff,"- %p\n",pv));        
    }
    virtual void AddRef(IUnknown* pv){}
    virtual void Release(IUnknown* pv){}

    HRESULT CanUnloadNow()
    {
        HRESULT hRes = (m_lCount == 0)?S_OK:S_FALSE;
        //DBG_PRINTFA((pBuff,"CanUnloadNow %08x\n",hRes));
        return hRes;
    }
};

static CMyCritSec g_CS;
static BOOL g_bInit = FALSE;
static BOOL g_fAttached = FALSE;
CLifeControl* g_pLifeControl = NULL;

//
// these 2 functions assume that g_CS is held.
// 

HRESULT EnsureInitialized()
{
    HRESULT hr;

    if ( g_bInit )
    {
        return S_OK;
    }

    g_pLifeControl = new CDllLifeControl;

    if ( g_pLifeControl == NULL )
    {
        return E_OUTOFMEMORY;
    }

    hr = GlobalInitialize();

    if ( FAILED(hr) )
    {
        return hr;
    }

    g_bInit = TRUE;

    return S_OK;
}

void EnsureUninitialized()
{
    if ( g_bInit )
    {
        GlobalUninitialize();
        delete g_pLifeControl;
        g_pLifeControl = NULL;
        g_bInit = FALSE;
    }
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void** ppv)
{
    HRESULT hr;

    CMyInCritSec ics( &g_CS ); 

    if ( !g_fAttached )
    {
        return E_UNEXPECTED;
    }

    hr = EnsureInitialized();

    if ( FAILED(hr) )
    {
        return hr;
    }

    for(int i = 0; i < g_pClassInfos->size(); i++)
    {
        CClassInfo* pInfo = (*g_pClassInfos)[i];
        if(*pInfo->m_pClsid == rclsid)    
        {
            return pInfo->m_pFactory->QueryInterface(riid, ppv);
        }
    }

    return E_FAIL;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.//
// Return:  TRUE if there are no objects in use and the class factory 
//          isn't locked.
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    CMyInCritSec ics( &g_CS ); 

    if ( !g_fAttached )
    {
        return S_FALSE;
    }

    if ( !g_bInit )
    {
        return S_OK;
    }

    HRESULT hres = ((CDllLifeControl*)g_pLifeControl)->CanUnloadNow();
    
    if( hres == S_OK )
    {
        if ( GlobalCanShutdown() )
        {
            EnsureUninitialized();
            return S_OK;
        }
    }

    return S_FALSE;
}


//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during initialization or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    HRESULT hr;

    CMyInCritSec ics( &g_CS ); 

    if ( !g_fAttached )
    {
        return E_UNEXPECTED;
    }

    hr = EnsureInitialized();

    if ( FAILED(hr) )
    {
        return hr;
    }

    GlobalRegister();

    if ( NULL == g_pClassInfos )
    {
        return E_FAIL;
    }

    for(int i = 0; i < g_pClassInfos->size(); i++)
    {
        CClassInfo* pInfo = (*g_pClassInfos)[i];
        HRESULT hres = RegisterServer(pInfo, FALSE);
        if(FAILED(hres)) return hres;
    }

    return S_OK;
}


//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

    CMyInCritSec ics( &g_CS ); 

    if ( !g_fAttached )
    {
        return E_UNEXPECTED;
    }
    
    hr = EnsureInitialized();

    if ( FAILED(hr) )
    {
        return hr;
    }

    GlobalUnregister();

    if ( NULL == g_pClassInfos )
    {
        return E_FAIL;
    }

    for(int i = 0; i < g_pClassInfos->size(); i++)
    {
        CClassInfo* pInfo = (*g_pClassInfos)[i];
        HRESULT hres = UnregisterServer(pInfo, FALSE);
        if(FAILED(hres)) return hres;
    }

    return S_OK;
}

BOOL WINAPI DllMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pvReserved)
{
    if (DLL_PROCESS_ATTACH==ulReason)
    {
        SetModuleHandle(hInstance);
        g_fAttached = TRUE;
	DisableThreadLibraryCalls ( hInstance ) ;
    }
    else if(DLL_PROCESS_DETACH==ulReason)
    {
        if ( g_fAttached )
        {
            GlobalPostUninitialize();
        }

        // This will prevent us from performing any other logic
        // until we are attached to again.
        g_fAttached = FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\comlib\comexesv\exemain.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    EXEMAIN.CPP

Abstract:

  EXE/COM Helpers

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <tchar.h>
#include "commain.cpp"

DWORD g_dwMainThreadId = 0xFFFFFFFF;

class CExeClassFactory : public IClassFactory, IExternalConnection 
{
    long m_lRef;
    IClassFactory* m_pFactory;
    CUnkInternal* m_pInternalUnk;

public:
    
    CExeClassFactory( CUnkInternal* pInternalUnk )
    : m_pInternalUnk( pInternalUnk ), m_lRef(0), m_pFactory(0)
    { 
        m_pInternalUnk->InternalAddRef();
        m_pInternalUnk->InternalQueryInterface( IID_IClassFactory,
                                                (void**)&m_pFactory );
    }

    ~CExeClassFactory()
    {
        m_pInternalUnk->InternalRelease();
    }

    STDMETHOD(QueryInterface)( REFIID riid, void** ppv )
    {
        HRESULT hr;

        if ( riid == IID_IUnknown || riid == IID_IClassFactory )
        {
            *ppv = this;
            AddRef();
            hr = S_OK;
        }
        else if ( riid == IID_IExternalConnection )
        {
            *ppv = (IExternalConnection*)this;
            AddRef();
            hr = S_OK;
        }
        else
        {
            *ppv = NULL;
            hr = E_NOINTERFACE;
        }

        return hr;
    }
    
    STDMETHOD_(ULONG, AddRef)()
    {
        return InterlockedIncrement( &m_lRef );
    }
    
    STDMETHOD_(ULONG, Release)()
    {
        long lRef = InterlockedDecrement( &m_lRef );

        if ( lRef == 0 )
        {
            delete this;
        }

        return lRef;
    }

    STDMETHOD(CreateInstance)(IUnknown* pOuter, REFIID riid, void** ppv)
    {
        return m_pFactory->CreateInstance( pOuter, riid, ppv );
    }

    STDMETHOD(LockServer)(BOOL fLock)
    {
        return m_pFactory->LockServer( fLock );
    }

    STDMETHOD_(DWORD,AddConnection)( DWORD exconn, DWORD dwreserved )
    {
        m_pFactory->LockServer( TRUE );
        return 1;
    }

    STDMETHOD_(DWORD,ReleaseConnection)( DWORD exconn, 
                                         DWORD dwreserved,
                                         BOOL fLastReleaseCloses )
    {
        m_pFactory->LockServer( FALSE );
        return 1;
    }
};

class CExeLifeControl : public CLifeControl
{
protected:
    long m_lNumObjects;
    BOOL m_bUnloading;
    CMyCritSec m_cs;

protected:
    virtual void Quit()
    {
        PostThreadMessage(g_dwMainThreadId, WM_QUIT, 0, 0);
    }
public:
    CExeLifeControl() : m_lNumObjects(0), m_bUnloading(FALSE){}
    virtual BOOL ObjectCreated(IUnknown* pv)
    {
        CMyInCritSec ics(&m_cs);
        if(m_bUnloading)
            return FALSE;

        m_lNumObjects++;
        return TRUE;
    }
    virtual void ObjectDestroyed(IUnknown* pv)
    {
        EnterCriticalSection(&m_cs);
        long l = --m_lNumObjects;
        if(l == 0)
        {
            m_bUnloading = TRUE;
            LeaveCriticalSection(&m_cs);
            Quit();
        }
        else
        {
            LeaveCriticalSection(&m_cs);
        }
    }

    virtual void AddRef(IUnknown* pv){}
    virtual void Release(IUnknown* pv){}
};

void MessageLoop()
{
    MSG msg;
    while(GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}


struct ServiceInfo
{
    BOOL m_bUsed;

    LPTSTR m_szServiceName;
    LPTSTR m_szDisplayName;
    BOOL m_bAuto;

    HANDLE m_hEvent;
    SERVICE_STATUS_HANDLE m_hStatus;

    ServiceInfo() : m_bUsed(FALSE){}

} g_ServiceInfo;

void SetServiceInfo(LPTSTR szServiceName, LPTSTR szDisplayName, BOOL bAuto)
{
    g_ServiceInfo.m_bUsed = TRUE;
    g_ServiceInfo.m_szServiceName = szServiceName;
    g_ServiceInfo.m_szDisplayName = szDisplayName;
    g_ServiceInfo.m_bAuto = bAuto;
}

void WINAPI ServiceHandler(DWORD dwControl)
{
    SERVICE_STATUS Status;
    Status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    Status.dwCurrentState = SERVICE_RUNNING;
    Status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    Status.dwWin32ExitCode = NO_ERROR;
    Status.dwCheckPoint = 0;
    Status.dwWaitHint = 0;

    if(!SetServiceStatus(g_ServiceInfo.m_hStatus, &Status))
    {
        long lRes = GetLastError();
        return;
    }
    switch(dwControl)
    {
    case SERVICE_CONTROL_STOP:
        Status.dwCurrentState = SERVICE_STOPPED;
        SetServiceStatus(g_ServiceInfo.m_hStatus, &Status);
        SetEvent(g_ServiceInfo.m_hEvent);
        ExitProcess(0);
        return;
    case SERVICE_CONTROL_PAUSE:
    case SERVICE_CONTROL_CONTINUE:
    case SERVICE_CONTROL_INTERROGATE:
    case SERVICE_CONTROL_SHUTDOWN:
        return;
    };
}

void WINAPI ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
    g_ServiceInfo.m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    g_ServiceInfo.m_hStatus = RegisterServiceCtrlHandler(
        g_ServiceInfo.m_szServiceName,
        (LPHANDLER_FUNCTION)&ServiceHandler);
    if(g_ServiceInfo.m_hStatus == NULL)
    {
        long lRes = GetLastError();
        return;
    }

    SERVICE_STATUS Status;
    Status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    Status.dwCurrentState = SERVICE_START_PENDING;
    Status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    Status.dwWin32ExitCode = NO_ERROR;
    Status.dwCheckPoint = 0;
    Status.dwWaitHint = 10000;

    if(!SetServiceStatus(g_ServiceInfo.m_hStatus, &Status))
    {
        long lRes = GetLastError();
        return;
    }

    Status.dwCurrentState = SERVICE_RUNNING;
    if(!SetServiceStatus(g_ServiceInfo.m_hStatus, &Status))
    {
        long lRes = GetLastError();
        return;
    }

    MessageLoop();
}


BOOL StartService()
{
    SERVICE_TABLE_ENTRY aEntries[2];
    aEntries[0].lpServiceName = g_ServiceInfo.m_szServiceName;
    aEntries[0].lpServiceProc = (LPSERVICE_MAIN_FUNCTION)&ServiceMain;
    aEntries[1].lpServiceName = NULL;
    aEntries[1].lpServiceProc = NULL;

    if(!StartServiceCtrlDispatcher(aEntries))
    {
        long lRes = GetLastError();
        return FALSE;
    }

    return TRUE;
}

BOOL InstallService()
{
    SC_HANDLE hManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    TCHAR szFilename[1024];
    GetModuleFileName(NULL, szFilename, 1023);

    SC_HANDLE hService = CreateService(hManager,
        g_ServiceInfo.m_szServiceName,
        g_ServiceInfo.m_szDisplayName,
        SERVICE_ALL_ACCESS,
        SERVICE_WIN32_OWN_PROCESS,
        g_ServiceInfo.m_bAuto?SERVICE_AUTO_START : SERVICE_DEMAND_START,
        SERVICE_ERROR_NORMAL,
        szFilename, NULL, NULL, NULL,
        NULL, //Local System
        NULL // no password
    );

    if(hService == NULL)
    {
        long lRes = GetLastError();
        return FALSE;
    }
/*
    // Create AppId key
    // ================

    GUID AppId = *g_aClassInfos[0].m_pClsid;
    char szAppId[128];
    WCHAR wszAppId[128];
    char szAppIdKey[128];

    StringFromGUID2(*pInfo->m_pClsid, wszAppId, 128);
    wcstombs(szAppId, wszAppId, 128);
    strcpy(szAppIdKey, "SOFTWARE\\Classes\\AppId\\");
    strcat(szAppIdKey, szAppId);

    HKEY hKey1;
    RegCreateKey(HKEY_LOCAL_MACHINE, szAppIdKey, &hKey1);

    RegSetValueEx(hKey1, "LocalService", 0, REG_SZ,
        g_ServiceInfo.m_szServiceName,
        strlen(g_ServiceInfo.m_szServiceName)+1);
*/
    return TRUE;

}

BOOL DeinstallService()
{
    SC_HANDLE hManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    SC_HANDLE hService = OpenService(hManager, g_ServiceInfo.m_szServiceName,
        SERVICE_ALL_ACCESS);
    if(hService == NULL)
    {
        long lRes = GetLastError();
        return FALSE;
    }

    if(!DeleteService(hService))
    {
        long lRes = GetLastError();
        return FALSE;
    }

    return TRUE;
}

CLifeControl* g_pLifeControl = new CExeLifeControl;

void CALLBACK MyTimerProc(HWND hWnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{
    PostQuitMessage(0);
}

void __cdecl main()
{
    LPTSTR szOrigCommandLine = GetCommandLine();
    LPTSTR szCommandLine = new TCHAR[lstrlen(szOrigCommandLine)+1];

    if (!szCommandLine)
        return;

    lstrcpy(szCommandLine, szOrigCommandLine);
    TCHAR * pc = szCommandLine;
    while(*pc)
        *(pc++) = (TCHAR)toupper(*pc);

    GlobalInitialize();
    if(_tcsstr(szCommandLine, TEXT("-REGSERVER")) ||
        _tcsstr(szCommandLine, TEXT("/REGSERVER")))
    {
        GlobalRegister();
        for(int i = 0; i < g_pClassInfos->size(); i++)
        {
            CClassInfo* pInfo = (*g_pClassInfos)[i];
            HRESULT hres = RegisterServer(pInfo, TRUE);
            if(FAILED(hres)) return;
        }
        if(g_ServiceInfo.m_bUsed)
        {
            InstallService();
        }
    }
    else if(_tcsstr(szCommandLine, TEXT("-UNREGSERVER")) ||
            _tcsstr(szCommandLine, TEXT("/UNREGSERVER")))
    {
        GlobalUnregister();
        for(int i = 0; i < g_pClassInfos->size(); i++)
        {
            CClassInfo* pInfo = (*g_pClassInfos)[i];
            HRESULT hres = UnregisterServer(pInfo, TRUE);
            if(FAILED(hres)) return;
        }
        if(g_ServiceInfo.m_bUsed)
        {
            DeinstallService();
        }
    }
    else if(_tcsstr(szCommandLine, TEXT("EMBEDDING")) == NULL &&
        !g_ServiceInfo.m_bUsed)
    {
        printf("Cannot run standalone\n");
    }
    else
    {
        int i;
        if(FAILED(GlobalInitializeCom()))
            return;

        for(i = 0; i < g_pClassInfos->size(); i++)
        {
            CClassInfo* pInfo = (*g_pClassInfos)[i];

            IClassFactory* pFactory = new CExeClassFactory( pInfo->m_pFactory);

            if ( pFactory == NULL )
                return;

            HRESULT hres = CoRegisterClassObject(
                *pInfo->m_pClsid, pFactory, CLSCTX_SERVER,
                REGCLS_MULTIPLEUSE, &pInfo->m_dwCookie);

            if(FAILED(hres)) return;
        }

        if(g_ServiceInfo.m_bUsed)
        {
            StartService();
        }
        else
        {
            g_dwMainThreadId = GetCurrentThreadId();
            MessageLoop();
        }

        for(i = 0; i < g_pClassInfos->size(); i++)
        {
            CClassInfo* pInfo = (*g_pClassInfos)[i];
            HRESULT hres = CoRevokeClassObject(pInfo->m_dwCookie);

            if(FAILED(hres)) return;
        }

        SetTimer(NULL, 0, 1000, (TIMERPROC)MyTimerProc);
        MessageLoop();

        GlobalUninitialize();
    }
}

int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPrev, LPSTR lpCmdLine,
                   int nCmdShow)
{
    main();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\contprov\hiperfserver.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// HiPerfServer.h: interface for the CHiPerfServer class.
//
//////////////////////////////////////////////////////////////////////

#ifndef _HIPERFSERVER_H_
#define _HIPERFSERVER_H_

// {2C45361C-74EE-11d2-B339-00105A1469B7}
const CLSID CLSID_ContinousProvider_v1 = {0x2c45361c, 0x74ee, 0x11d2, 0xb3, 0x39, 0x0, 0x10, 0x5a, 0x14, 0x69, 0xb7};


#endif // _HIPERFSERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\contprov\hiperprov.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//////////////////////////////////////////////////////////////////////
//
//	HiPerfProv.h
//
//	Based on NTPerf by raymcc.
//
//	Created by a-dcrews, Oct 15, 1998
//	
//////////////////////////////////////////////////////////////////////

#ifndef _HIPERFPROV_H_
#define _HIPERFPROV_H_

#include <unk.h>

#define NUM_SAMPLE_INSTANCES	10
#define SAMPLE_CLASS			L"Win32_ContinuousCounter"

// {49707B1E-74C3-11d2-B338-00105A1469B7}
const IID IID_IHiPerfProvider = {0x49707b1e, 0x74c3, 0x11d2, 0xb3, 0x38, 0x0, 0x10, 0x5a, 0x14, 0x69, 0xb7};

class CHiPerfProvider : public CUnk
{
protected:
	IWbemObjectAccess *m_aInstances[NUM_SAMPLE_INSTANCES];

	LONG m_hName;

	HRESULT SetHandles(IWbemClassObject* pSampleClass);

	friend class CRefresher;

protected:
	class XProviderInit : public CImpl<IWbemProviderInit, CHiPerfProvider>
	{
	public:
		XProviderInit(CHiPerfProvider *pObject) : 
		  CImpl<IWbemProviderInit, CHiPerfProvider>(pObject)
		  {}

		STDMETHOD(Initialize)( 
			/* [unique][in] */ LPWSTR wszUser,
			/* [in] */ LONG lFlags,
			/* [in] */ LPWSTR wszNamespace,
			/* [unique][in] */ LPWSTR wszLocale,
			/* [in] */ IWbemServices __RPC_FAR *pNamespace,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink );
	} m_XProviderInit;
	friend XProviderInit;

    class XHiPerfProvider : public CImpl<IWbemHiPerfProvider, CHiPerfProvider>
	{
	public:
		XHiPerfProvider(CHiPerfProvider *pObject) : 
		  CImpl<IWbemHiPerfProvider, CHiPerfProvider>(pObject)
		  {}

		STDMETHOD(QueryInstances)( 
			/* [in] */ IWbemServices __RPC_FAR *pNamespace,
			/* [string][in] */ WCHAR __RPC_FAR *wszClass,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [in] */ IWbemObjectSink __RPC_FAR *pSink );
        
		STDMETHOD(CreateRefresher)( 
			/* [in] */ IWbemServices __RPC_FAR *pNamespace,
			/* [in] */ long lFlags,
			/* [out] */ IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher );
        
		STDMETHOD(CreateRefreshableObject)( 
			/* [in] */ IWbemServices __RPC_FAR *pNamespace,
			/* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
			/* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pContext,
			/* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
			/* [out] */ long __RPC_FAR *plId );
        
		STDMETHOD(StopRefreshing)( 
			/* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
			/* [in] */ long lId,
			/* [in] */ long lFlags );

		STDMETHOD(CreateRefreshableEnum)(
			/* [in] */ IWbemServices* pNamespace,
			/* [in, string] */ LPCWSTR wszClass,
			/* [in] */ IWbemRefresher* pRefresher,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext* pContext,
			/* [in] */ IWbemHiPerfEnum* pHiPerfEnum,
			/* [out] */ long* plId);

		STDMETHOD(GetObjects)(
            /* [in] */ IWbemServices* pNamespace,
			/* [in] */ long lNumObjects,
			/* [in,size_is(lNumObjects)] */ IWbemObjectAccess** apObj,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pContext);

	} m_XHiPerfProvider;
	friend XHiPerfProvider;

	class XRefresher : public CImpl<IWbemRefresher, CHiPerfProvider> 
	{
		friend XHiPerfProvider;
		IWbemObjectAccess *m_aRefInstances[NUM_SAMPLE_INSTANCES];

		BOOL AddObject(IWbemObjectAccess *pObj, LONG *plId);
		BOOL RemoveObject(LONG lId);

	public:
		XRefresher(CHiPerfProvider *pObject);
		virtual ~XRefresher();

		STDMETHOD(Refresh)(/* [in] */ long lFlags);
	} m_XRefresher;
	friend XRefresher;

public:
	CHiPerfProvider(CLifeControl *pControl);
	~CHiPerfProvider();

	virtual void* GetInterface(REFIID riid);
};

#endif // _HIPERFPROV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\assocqe.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    ASSOCQE.H

Abstract:

	WinMgmt Association Query Engine

History:

    raymcc  04-Jul-99   Created

--*/

#ifndef _ASSOCQE_H_
#define _ASSOCQE_H_


class CAssocQE_Sink;
class CAssocQuery;

typedef HRESULT (CAssocQuery::*PF_FilterForwarder)(IWbemClassObject *);

#define  ROLETEST_MODE_PATH_VALUE   1
#define  ROLETEST_MODE_CIMREF_TYPE  2

#define  ASSOCQ_FLAG_QUERY_ENDPOINT 1
#define  ASSOCQ_FLAG_OTHER_ENDPOINT 2

class CAssocQuery : IUnknown
{
    friend class CAssocQE_Sink;

    LONG               m_lRef;                  // COM ref count

    CAssocQueryParser *m_pParser;               // Parsed query access
    CBasicObjectSink  *m_pDestSink;             // Final destination sink
    IWbemClassObject  *m_pEndpoint;             // Endpoint in query
    BSTR               m_bstrEndpointClass;     // Class name of endpoint
    BSTR               m_bstrEndpointPath;      // Full path of endpoint
    BSTR               m_bstrEndpointRelPath;   // Rel path of endpoint
    bool               m_bEndpointIsClass;      // True if endpoint a class
    CWStringArray      m_aEndpointHierarchy;    // Query endpoint class hiearchy
    DWORD              m_dwQueryStartTime;      // When query started
    DWORD              m_dwLastResultTime;      // Updated during indications
    LONG               m_lActiveSinks;          // How many sinks are still running
    HANDLE             m_hSinkDoneEvent;        // Signaled as sinks complete
    CFlexArray         m_aMaster;               // Assoc class list
    BOOL               m_bLimitNeedsDecrement;
    // Helpers for 'associators of' queries.
    // =====================================
    CFlexArray         m_aEpCandidates;         // List of paths to EP candidates for associators queries
    CRITICAL_SECTION   m_csCandidateEpAccess;   // Critsec to protect access to Ep candidate array

    // Dynamic class cache.
    // ====================
    CFlexArray         m_aDynClasses;           // Contains all dynamic classes available as of this query

    // Helpers for references of + CLASSDEFSONLY
    // =========================================
    CWStringArray      m_aDeliveredClasses;     // List of class names already in the below list
    CRITICAL_SECTION   m_csDeliveredAccess;

    // From the original call.
    // =======================
    IWbemContext      *m_pContext;
    CWbemNamespace    *m_pNs;
    bool m_bCancel;


    // Various Internal methods.
    // =========================

    CAssocQuery();
   ~CAssocQuery();

    // Class list manipulation.
    // ========================

    HRESULT BuildMasterAssocClassList(
        IN OUT CFlexArray &aResultSet
        );

    HRESULT MergeInClassRefList(
        IN OUT CFlexArray &aResultSet
        );

    HRESULT RemoveNonDynClasses(
        IN OUT CFlexArray &aMaster
        );

    HRESULT ReduceToRealClasses(
        IN OUT CFlexArray & aResultSet
        );

    // Endpoint analysis.
    // ==================

    HRESULT CanPropRefQueryEp(
        IN BOOL bStrict,
        IN LPWSTR pszPropName,
        IN IWbemClassObject *pObj,
        OUT BSTR *strRefType
        );

    HRESULT CanClassRefQueryEp(
        IN BOOL bStrict,
        IN IWbemClassObject *pCls,
        OUT CWStringArray *paNames
        );

    HRESULT CanClassRefReachQueryEp(
        IWbemQualifierSet *pQSet,
        BOOL bStrict
        );

    HRESULT DoesAssocInstRefQueryEp(
        IN IWbemClassObject *pObj,
        OUT BSTR *pszRole
        );

    HRESULT EpClassTest(
        LPCWSTR pszResultClass,
        BSTR strClassName,
        IWbemClassObject *pTestClass
        );

    HRESULT GetUnknownEpRoleAndPath(
        IN IWbemClassObject *pAssoc,
        IN BOOL *pFoundQueryEp,
        OUT BSTR *pszRole,
        OUT BSTR *pszUnkEpPath
        );


    // Flow-of-control methods.
    // ========================

    void BranchToQueryType();

    // Schema-query flow-of-control.
    // =============================

    void ExecSchemaQuery();

    HRESULT SchemaQ_RefsQuery(
        IN OUT CFlexArray &aResultSet
        );

    HRESULT SchemaQ_AssocsQuery(
        IN CFlexArray &aAssocSet
        );

    HRESULT SchemaQ_Terminate(
        IN CFlexArray &aResultSet
        );

    HRESULT SchemaQ_RefsFilter(
        IN OUT CFlexArray &aSrc
        );

    HRESULT SchemaQ_AssocsFilter(
        IN OUT CFlexArray &aSrc
        );

    HRESULT SchemaQ_GetAndFilterOtherEndpoints(
        IN CFlexArray &aAssocs,
        OUT CFlexArray &aEndpoints
        );

    HRESULT SchemaQ_GetOtherEpClassName(
        IN IWbemClassObject *pAssoc,
        OUT BSTR *strOtherEpName
        );

    // Normal (instances, classrefs queries)
    // =====================================

    void ExecNormalQuery();

    HRESULT NormalQ_PreQueryClassFilter(
        CFlexArray &aMaster
        );

    HRESULT NormalQ_ReferencesOf();
    HRESULT NormalQ_AssociatorsOf();

    HRESULT NormalQ_GetRefsOfEndpoint(
        IN IWbemClassObject *pClass,
        IN IWbemObjectSink  *pSink
        );

    HRESULT ConvertEpListToClassDefsOnly();

    HRESULT NormalQ_LoadCheck();

    HRESULT PerformFinalEpTests(
        IWbemClassObject *pEp
        );

    HRESULT NormalQ_ConstructRefsQuery(
        IN IWbemClassObject *pClass,
        IN OUT IWbemContext *pContextCopy,
        OUT BSTR *strQuery
        );

    HRESULT GetCimTypeForRef(
        IN IWbemClassObject *pCandidate,
        IN BSTR pszRole,
        OUT BSTR *strCimType
        );

    HRESULT AssocClassHasOnlyKeys(
        IN IWbemClassObject *pObj
        );

    HRESULT Normal_ExecRefs(
        IN CFlexArray &aMasterClassList
        );



    // Filter auxiliaries for various query types.
    // ===========================================

    HRESULT FilterForwarder_NormalRefs(
        IN IWbemClassObject *pCandidate
        );

    HRESULT FilterForwarder_NormalAssocs(
        IN IWbemClassObject *pAssocInst
        );

    HRESULT NormalQ_AssocInstTest(
        IN IWbemClassObject *pAssoc,
        OUT LPWSTR *pszOtherEp
        );

    HRESULT CanAssocClassRefUnkEp(
        IN IWbemClassObject *pClass,
        IN CWStringArray &aUnkEpHierarchy
        );

    // DB Access abstraction for Quasar ease of porting.
    // =================================================

    HRESULT Db_GetClass(
        IN LPCWSTR pszName,
         OUT IWbemClassObject **pObj
        );

    HRESULT Db_GetRefClasses(
        IN  LPCWSTR pszClass,
        OUT CWStringArray &aRefClasses
        );

    HRESULT Db_GetInstRefs(
        IN LPCWSTR pszTarget,
        IN IWbemObjectSink *pDest
        );

    HRESULT Db_GetClassRefClasses(
        IN CFlexArray &aDest
        );

    HRESULT GetClassDynasty(
        IN LPCWSTR pszClass,
        OUT CFlexArray &aDynasty
        );


    // Various static auxiliaries for tests.
    // ======================================

    static HRESULT St_HasClassRefs(
        IN IWbemClassObject *pCandidate
        );

    HRESULT AccessCheck(IWbemClassObject* pObj);

    static HRESULT St_GetObjectInfo(
        IN  IWbemClassObject *pObj,
        OUT BSTR *pClass,
        OUT BSTR *pRelpath,
        OUT BSTR *pPath,
        OUT CWStringArray &aHierarchy
        );

    static HRESULT St_ObjPathInfo(
        IN LPCWSTR pszPath,
        OUT BSTR *pszClass,
        OUT BOOL *pbIsClass
        );

    static HRESULT St_ReleaseArray(
        IN CFlexArray &aObjects
        );

    static HRESULT St_ObjHasQualifier(
        IN LPCWSTR pszQualName,
        IN IWbemClassObject *pObj
        );

    static HRESULT St_ObjIsOfClass(
        IN LPCWSTR pszRequiredClass,
        IN IWbemClassObject *pObj
        );

    HRESULT GetClassDefsOnlyClass(
        IN IWbemClassObject *pExample,
        OUT IWbemClassObject **pClass
        );

    HRESULT FindParentmostClass(
        IN  IWbemClassObject *pAssocInst,
        OUT IWbemClassObject **pClassDef
        );

    HRESULT TagProp(
        IN IWbemClassObject *pObjToTag,
        IN LPCWSTR pszPropName,
        IN LPCWSTR pszInOutTag
        );

    // Other.
    // ======
    void UpdateTime() { m_dwLastResultTime = GetCurrentTime(); }
    void SignalSinkDone() { SetEvent(m_hSinkDoneEvent);}

    HRESULT GetDynClasses();

    HRESULT GetDynClass(
        IN  LPCWSTR pszClassName,
        OUT IWbemClassObject **pCls
        );
    void SortDynClasses();

    HRESULT ResolveEpPathsToObjects(int nMaxToProcess);

    HRESULT ComputeInOutTags(
        IN IWbemClassObject *pAssocInst,
        IN IWbemClassObject *pClass
        );

    static HRESULT PathPointsToObj(
        IN LPCWSTR pszPath,
        IN IWbemClassObject *pObj,
        IN CWbemNamespace *pNs
        );

    HRESULT GetClassFromAnywhere(
        IN  LPCWSTR pszEpClassName,
        IN  LPCWSTR pszFullClassPath,
        OUT IWbemClassObject **pCls
        );

    HRESULT AddEpCandidatePath(
        IN BSTR strOtherEp
        );

    void EmptyCandidateEpArray();

    CObjectSink *CreateSink(PF_FilterForwarder pfnFilter, BSTR strTrackingQuery);
    static void EmptyObjectList(CFlexArray &);

public:
    static CAssocQuery *CreateInst();

    // IUnknown.
    // =========

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    STDMETHODIMP QueryInterface(REFIID riid, void** ppv);

    HRESULT Execute(
        IN  CWbemNamespace *pNs,
        IN  LPWSTR wszQuery,
        IN  IWbemContext* pContext,
        IN  CBasicObjectSink* pSink
        );

    HRESULT Cancel();

    static HRESULT RoleTest(
        IN IWbemClassObject *pEndpoint,
        IN IWbemClassObject *pCandidate,
        IN CWbemNamespace *pNs,
        IN LPCWSTR pszRole,
        IN DWORD dwMode
        );
};



class CAssocQE_Sink : public CObjectSink
{
    friend class CAssocQuery;

    BOOL                    m_bQECanceled;
    CAssocQuery             *m_pQuery;
    PF_FilterForwarder      m_pfnFilter;
    BSTR                    m_strQuery;
    BOOL                    m_bOriginalOpCanceled;

public:
    CAssocQE_Sink(CAssocQuery *pQuery, PF_FilterForwarder pFilter, BSTR m_strQuery);
   ~CAssocQE_Sink();

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam
                         );

    virtual HRESULT Add(ADDREF IWbemClassObject* pObj);
};




#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\contprov\hiperprov.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//////////////////////////////////////////////////////////////////////
//
//  HiPerfProv.cpp
//
//  
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <stdio.h>

#include <wbemidl.h>
#include <wbemint.h>

#include "common.h"
#include "HiPerProv.h"

///////////////////////////////////////////////////////////////////
//
//                          CHiPerfProvider
//
///////////////////////////////////////////////////////////////////

CHiPerfProvider::CHiPerfProvider(CLifeControl *pControl) : 
CUnk(pControl), m_XProviderInit(this), m_XHiPerfProvider(this), m_XRefresher(this)
//ok
{
    LOG("CHiPerfProvider::CHiPerfProvider");

    // Initialize internal instance cache to empty
    for (int i = 0; i < NUM_SAMPLE_INSTANCES; i++)
        m_aInstances[i] = 0;

    // Initialize property value handles to zero
    m_hName         = 0;
}

CHiPerfProvider::~CHiPerfProvider()
//ok
{
    LOG("CHiPerfProvider::~CHiPerfProvider");

    // Release all the objects which have been added to the array.
    for (int i = 0; i < NUM_SAMPLE_INSTANCES; i++)
    {
        if (m_aInstances[i])
            m_aInstances[i]->Release();
    }
}

void* CHiPerfProvider::GetInterface(REFIID riid)
//ok
{
    if(riid == IID_IWbemProviderInit)
        return &m_XProviderInit;
    if (riid == IID_IWbemHiPerfProvider)
        return &m_XHiPerfProvider;
    if (riid == IID_IUnknown)
        return &m_XHiPerfProvider;
    return NULL;
}


///////////////////////////////////////////////////////////////////
//
//  COM implementations
//
///////////////////////////////////////////////////////////////////

HRESULT CHiPerfProvider::SetHandles(IWbemClassObject* pSampleClass)
//ok
{
    LOG("CHiPerfProvider::SetHandles");

    // Get the property handles for the well-known properties in
    // this counter type.  These property handles are available
    // to all nested classes of HiPerfProvider
    IWbemObjectAccess *pAccess;
    LONG    hName       = 0;
    HRESULT hRes = 0;
    BSTR PropName = 0;

    hRes = pSampleClass->QueryInterface(IID_IWbemObjectAccess, (LPVOID *)&pAccess);
    if (FAILED(hRes))
    {
        LOGERROR("Could not retrieve the IWbemObjectAccess object");
        return hRes;
    }

    // Name handle
    PropName = SysAllocString(L"Name");
    hRes = pAccess->GetPropertyHandle(PropName, 0, &hName);
    if (FAILED(hRes))
    {
        LOGERROR("Could not get access handle for Name property");
        pAccess->Release();
        return hRes;
    }
    m_hName = hName;
    SysFreeString(PropName);

    pAccess->Release();
    return WBEM_NO_ERROR;
}


STDMETHODIMP CHiPerfProvider::XProviderInit::Initialize( 
    /* [unique][in] */  LPWSTR wszUser,
    /* [in] */          LONG lFlags,
    /* [in] */          LPWSTR wszNamespace,
    /* [unique][in] */  LPWSTR wszLocale,
    /* [in] */          IWbemServices __RPC_FAR *pNamespace,
    /* [in] */          IWbemContext __RPC_FAR *pCtx,
    /* [in] */          IWbemProviderInitSink __RPC_FAR *pInitSink)
//ok
{
    LOG("CHiPerfProvider::XProviderInit::Initialize");

    IWbemClassObject  *pSampleClass = 0;
    IWbemObjectAccess *pAccess = 0;

    // Get a copy of our sample class def so that we can create & maintain
    // instances of it.
    BSTR bstrObject = SysAllocString(SAMPLE_CLASS);

    HRESULT hRes = pNamespace->GetObject(bstrObject, 0, pCtx, &pSampleClass, 0);

    SysFreeString(bstrObject);

    if (FAILED(hRes))
    {
        LOGERROR("Could not create a sample object");
        return hRes;
    }

    hRes = m_pObject->SetHandles(pSampleClass);
    if (FAILED(hRes))
    {
        pSampleClass->Release();
        return hRes;
    }

    // Precreate 10 instances, and set them up in an array which
    // is a member of this C++ class.
    //
    // We only store the IWbemObjectAccess pointers, since
    // we are updating 'well-known' properties and already 
    // know their names.
    for (int i = 0; i < NUM_SAMPLE_INSTANCES; i++)
    {
        IWbemClassObject *pInst = 0;

        hRes = pSampleClass->SpawnInstance(0, &pInst);
        if (FAILED(hRes))
        {
            LOGERROR("Could not spawn an instance of the sample class");
            pSampleClass->Release();
            return hRes;
        }

        // Get the IWbemObjectAccess interface and cache it
        pInst->QueryInterface(IID_IWbemObjectAccess, (LPVOID *)&pAccess);
        pInst->Release();

        // Set the instance's name.
        WCHAR wcsName[128];
        swprintf(wcsName, L"Inst_%d", i);
        hRes = pAccess->WritePropertyValue(m_pObject->m_hName, (wcslen(wcsName)+1)*sizeof(wchar_t), (BYTE*)wcsName);
        if (FAILED(hRes))
        {
            LOGERROR("Failed to set name of sample class");
            pSampleClass->Release();
            pAccess->Release();
            return hRes;
        }

        // Add to the instance array
        m_pObject->m_aInstances[i] = pAccess;
    }

    // We now have all the instances ready to go and all the 
    // property handles cached.   Tell WINMGMT that we're
    // ready to start 'providing'.
    pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);

    pSampleClass->Release();

    return NO_ERROR;
}

STDMETHODIMP CHiPerfProvider::XHiPerfProvider::QueryInstances( 
    /* [in] */          IWbemServices __RPC_FAR *pNamespace,
    /* [string][in] */  WCHAR __RPC_FAR *wszClass,
    /* [in] */          long lFlags,
    /* [in] */          IWbemContext __RPC_FAR *pCtx,
    /* [in] */          IWbemObjectSink __RPC_FAR *pSink )
//ok
{
    LOG("CHiPerfProvider::XHiPerfProvider::QueryInstances");

    HRESULT hRes;

    if (pNamespace == 0 || wszClass == 0 || pSink == 0)
        return WBEM_E_INVALID_PARAMETER;

    for (int i = 0; i < NUM_SAMPLE_INSTANCES; i++)
    {
        IWbemObjectAccess *pAccess = m_pObject->m_aInstances[i];
        
        // Every object can be access one of two ways.  In this case
        // we get the 'other' (primary) interface to this same object.
        IWbemClassObject *pOtherFormat = 0;
        hRes = pAccess->QueryInterface(IID_IWbemClassObject, (LPVOID *) &pOtherFormat);
        if (FAILED(hRes))
        {
            LOGERROR("Could not obtain the IWbemClassObject interface");
            return hRes;
        }

        // Send a copy back to the caller.
        pSink->Indicate(1, &pOtherFormat);

        pOtherFormat->Release();    // Don't need this any more
    }
    
    // Tell WINMGMT we are all finished supplying objects.
    pSink->SetStatus(0, WBEM_NO_ERROR, 0, 0);

    return NO_ERROR;
}    

STDMETHODIMP CHiPerfProvider::XHiPerfProvider::CreateRefresher( 
     /* [in] */ IWbemServices __RPC_FAR *pNamespace,
     /* [in] */ long lFlags,
     /* [out] */ IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher )
//////////////////////////////////////////////////////////////////////
//
//  Called whenever a new refresher is needed by the client.
//
//  Parameters:
//  <pNamespace>        A pointer to the relevant namespace.  Not used.
//  <lFlags>            Not used.
//  <ppRefresher>       Receives the requested refresher.
//
//////////////////////////////////////////////////////////////////////
//ok
{
    LOG("CContinousProvider::XContinousProvider::CreateRefresher");

    *ppRefresher = NULL;
    
    return NO_ERROR;
}

STDMETHODIMP CHiPerfProvider::XHiPerfProvider::CreateRefreshableObject( 
    /* [in] */ IWbemServices __RPC_FAR *pNamespace,
    /* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pContext,
    /* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
    /* [out] */ long __RPC_FAR *plId )
//////////////////////////////////////////////////////////////////////
//
//  Called whenever a user wants to include an object in a refresher.
//     
//  Parameters:
//  <pNamespace>        A pointer to the relevant namespace in WINMGMT.
//  <pTemplate>         A pointer to a copy of the object which is to be
//                      added.  This object itself cannot be used, as
//                      it not owned locally.        
//  <pRefresher>        The refresher to which to add the object.
//  <lFlags>            Not used.
//  <pContext>          Not used here.
//  <ppRefreshable>     A pointer to the internal object which was added
//                      to the refresher.
//  <plId>              The Object Id (for identification during removal).        
//
//////////////////////////////////////////////////////////////////////
//ok
{
    LOG("CHiPerfProvider::XHiPerfProvider::CreateRefreshableObject");

    // Find out which object is being requested for addition.
    wchar_t wcsBuf[128];
    *wcsBuf = 0;
    LONG lNameLength = 0;
    pTemplate->ReadPropertyValue(m_pObject->m_hName, (wcslen(wcsBuf)+1)*sizeof(wchar_t), &lNameLength, LPBYTE(wcsBuf));
    
    // Scan out the index from the instance name.  We only do this
    // because the instance name is a string.
    DWORD dwIndex = 0;    
    swscanf(wcsBuf, L"Inst_%u", &dwIndex);

    // Now we know which object is desired.
    IWbemObjectAccess *pOurCopy = m_pObject->m_aInstances[dwIndex];

    pOurCopy->ReadPropertyValue(m_pObject->m_hName, 128, &lNameLength, LPBYTE(wcsBuf));

    char szbuf[256];
    wcstombs(szbuf, wcsBuf, 127);
    LOG(szbuf);

    // The refresher being supplied by the caller is actually
    // one of our own refreshers, so a simple cast is convenient
    // so that we can access private members.
    XRefresher *pOurRefresher;

    if (pRefresher)
    {
        LOG ("NON-NULL refresher");
        pOurRefresher = (XRefresher *) pRefresher;
    }
    else
    {
        LOG ("NULL refresher");
        pOurRefresher = &m_pObject->m_XRefresher;
    }

    if(pOurRefresher)
        pOurRefresher->AddObject(pOurCopy, plId);

    // Return a copy of the internal object.
    pOurCopy->AddRef();
    *ppRefreshable = pOurCopy;
    *plId = LONG(dwIndex);

    return NO_ERROR;
}
    
STDMETHODIMP CHiPerfProvider::XHiPerfProvider::StopRefreshing( 
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lId,
    /* [in] */ long lFlags )
//////////////////////////////////////////////////////////////////////
//
//  Called whenever a user wants to remove an object from a refresher.
//     
//  Parameters:
//  <pRefresher>            The refresher object from which we are to 
//                          remove the perf object.
//  <lId>                   The ID of the object.
//  <lFlags>                Not used.
//  
//////////////////////////////////////////////////////////////////////
//ok
{
    LOG("CHiPerfProvider::XHiPerfProvider::StopRefreshing");

    // The refresher being supplied by the caller is actually
    // one of our own refreshers, so a simple cast is convenient
    // so that we can access private members.
    XRefresher *pOurRefresher;

    if (pRefresher)
    {
        LOG ("NON-NULL refresher");
        pOurRefresher = (XRefresher *) pRefresher;
    }
    else
    {
        LOG ("NULL refresher");
        pOurRefresher = &m_pObject->m_XRefresher;
    }

    pOurRefresher->RemoveObject(lId);

    return NO_ERROR;
}

STDMETHODIMP CHiPerfProvider::XHiPerfProvider::CreateRefreshableEnum( 
    /* [in] */ IWbemServices* pNamespace,
    /* [in, string] */ LPCWSTR wszClass,
    /* [in] */ IWbemRefresher* pRefresher,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext* pContext,
    /* [in] */ IWbemHiPerfEnum* pHiPerfEnum,
    /* [out] */ long* plId )
{
    // Just a placeholder for now
    LOG("CHiPerfProvider::XHiPerfProvider::CreateRefreshableEnum");
    return E_NOTIMPL;
}

STDMETHODIMP CHiPerfProvider::XHiPerfProvider::GetObjects( 
    /* [in] */ IWbemServices* pNamespace,
    /* [in] */ long lNumObjects,
    /* [in,size_is(lNumObjects)] */ IWbemObjectAccess** apObj,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext* pContext)
{
    // Just a placeholder for now
    LOG("CHiPerfProvider::XHiPerfProvider::GetObjects");
    return E_NOTIMPL;
}

CHiPerfProvider::XRefresher::XRefresher(CHiPerfProvider *pObject) : 
CImpl<IWbemRefresher, CHiPerfProvider>(pObject)
//ok
{
    LOG("CHiPerfProvider::XRefresher::XRefresher");
    // Initialize the instance cache to be empty
    for (int i = 0; i < NUM_SAMPLE_INSTANCES; i++)
        m_aRefInstances[i] = 0;
}

CHiPerfProvider::XRefresher::~XRefresher()
//ok
{
    LOG("CHiPerfProvider::XRefresher::~XRefresher");
    // Release the cached IWbemObjectAccess instances.
    for (DWORD i = 0; i < NUM_SAMPLE_INSTANCES; i++)
    {
        if (m_aRefInstances[i])
            m_aRefInstances[i]->Release();
    }            
}

BOOL CHiPerfProvider::XRefresher::AddObject(IWbemObjectAccess *pObj, LONG *plId)
//////////////////////////////////////////////////////////////////////
//
//  Adds an object to the refresher.   This is a private mechanism
//  used by CHiPerfProvider and not part of the COM interface.
//
//  The ID we return for future identification is simply
//  the array index.
//
//////////////////////////////////////////////////////////////////////
//ok
{
    LOG("CHiPerfProvider::XRefresher::AddObject");

    for (DWORD i = 0; i < NUM_SAMPLE_INSTANCES; i++)
    {
        if (m_aRefInstances[i] == 0)
        {
            pObj->AddRef();
            m_aRefInstances[i] = pObj;
            
            // The ID we return for future identification is simply
            // the array index.
            *plId = i;
            LOG("Added Object");
            return TRUE;
        }
    }        

    LOGERROR("Failed to Add Object");
    return FALSE;
}

BOOL CHiPerfProvider::XRefresher::RemoveObject(LONG lId)
//////////////////////////////////////////////////////////////////////
//
//  Removes an object from the refresher.  This is a private mechanism 
//  used by CHiPerfProvider and not part of the COM interface.
//
//  Removes an object from the refresher by ID.   In our case, the ID
//  is actually the array index we used internally, so it is simple
//  to locate and remove the object.
//
//////////////////////////////////////////////////////////////////////
//ok
{
    LOG("CHiPerfProvider::XRefresher::RemoveObject");

    if (m_aRefInstances[lId] == 0)
        return FALSE;
        
    m_aRefInstances[lId]->Release();
    m_aRefInstances[lId] = 0;

    return TRUE;        
}

HRESULT CHiPerfProvider::XRefresher::Refresh(/* [in] */ long lFlags)
//////////////////////////////////////////////////////////////////////
//
//  Executed to refresh a set of instances bound to the particular 
//  refresher.
//
//////////////////////////////////////////////////////////////////////
//ok
{
    LOG("CHiPerfProvider::XRefresher::Refresh");
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\assocqp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ASSOCQP.H

Abstract:

    WQL association query parser

History:

    raymcc   04-Jul-99   Created.
    raymcc   14-Aug-99   Resubmit due to VSS problem.

--*/

#ifndef _ASSOCQP_H_
#define _ASSOCQP_H_

#define QUERY_TYPE_GETASSOCS		    0x1
#define QUERY_TYPE_GETREFS			    0x2
#define QUERY_TYPE_CLASSDEFS_ONLY	    0x4
#define QUERY_TYPE_SCHEMA_ONLY		    0x8
#define QUERY_TYPE_KEYSONLY             0x10
#define QUERY_TYPE_CLASSDEFS_ONLY_EX    0x20

class CAssocQueryParser
{
    LPWSTR m_pszQueryText;
    LPWSTR m_pszTargetObjPath;
    LPWSTR m_pszResultClass;
    LPWSTR m_pszAssocClass;
    LPWSTR m_pszRole;
    LPWSTR m_pszResultRole;
    LPWSTR m_pszRequiredQual;
    LPWSTR m_pszRequiredAssocQual;
    DWORD   m_dwType;

    CObjectPathParser *m_pPathParser;
    ParsedObjectPath  *m_pPath;

public:
    CAssocQueryParser();
   ~CAssocQueryParser();

    HRESULT Parse(LPWSTR Query);
        // Parses both query and target object path.
        // Returns:
        //      WBEM_E_INVALID_QUERY on syntax error
        //      WBEM_E_INVALID_OBJECT_PATH if the object
        //          path is syntactically invalid.
        //      WBEM_E_OUT_OF_MEMORY
        //      WBEM_S_NO_ERROR

    LPCWSTR GetQueryText() { return m_pszQueryText; }
    LPCWSTR GetTargetObjPath() { return m_pszTargetObjPath; }
    LPCWSTR GetResultClass() { return m_pszResultClass; }
    LPCWSTR GetAssocClass() { return m_pszAssocClass; }
    LPCWSTR GetRole() { return m_pszRole; }
    LPCWSTR GetResultRole() { return m_pszResultRole; }
    LPCWSTR GetRequiredQual() { return m_pszRequiredQual; }
    LPCWSTR GetRequiredAssocQual() { return m_pszRequiredAssocQual; }
    DWORD   GetQueryType() { return m_dwType; }
        // Returns a mask of
        //      QUERY_TYPE_GETREFS
        //      QUERY_TYPE_GETASSOCS
        //      QUERY_TYPE_CLASSDEFS_ONLY
        //      QUERY_TYPE_KEYSONLY
        //      QUERY_TYPE_SCHEMA_ONLY

    const   ParsedObjectPath *GetParsedPath() { return m_pPath; }
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\assocqp.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ASSOCQP.CPP

Abstract:

    Association query parser

History:

    raymcc   04-Jul-99   Created.
    raymcc   14-Aug-99   Resubmit due to VSS problem.

--*/

#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>

#include <wbemcore.h>


// ==========================================================================
//                        ASSOCIATION QUERY PARSER.
// ==========================================================================


#define QASSOC_TOK_STRING       101
#define QASSOC_TOK_IDENT        102
#define QASSOC_TOK_DOT          103
#define QASSOC_TOK_EQU          104
#define QASSOC_TOK_COLON        105

#define QASSOC_TOK_ERROR        1
#define QASSOC_TOK_EOF          0

#define ST_IDENT                13
#define ST_STRING               19
#define ST_QSTRING              26
#define ST_QSTRING_ESC          30

// DFA State Table for Assoc query tokens.
// =======================================

LexEl AssocQuery_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  L'{',   GLEX_EMPTY, ST_STRING,  0,               GLEX_CONSUME,

/* 4 */  L'=',   GLEX_EMPTY, 0,  QASSOC_TOK_EQU, GLEX_ACCEPT|GLEX_RETURN,
/* 5 */  L'.',   GLEX_EMPTY, 0,  QASSOC_TOK_DOT, GLEX_ACCEPT|GLEX_RETURN,
/* 6 */  L':',   GLEX_EMPTY, 0,  QASSOC_TOK_COLON, GLEX_ACCEPT|GLEX_RETURN,

/* 7 */  L' ',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 8 */  L'\t',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 9 */  L'\n',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME|GLEX_LINEFEED,
/* 10 */  L'\r',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 11 */  0,      GLEX_EMPTY, 0,  QASSOC_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 12 */  GLEX_ANY, GLEX_EMPTY, 0,        QASSOC_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,


/* ST_IDENT */

/* 13 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 14 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 15 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 16 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 17 */  GLEX_ANY, GLEX_EMPTY,  0,  QASSOC_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

/* ST_STRING */
/* 18 */  0, GLEX_EMPTY, 0,        QASSOC_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,
/* 19 */  L'"', GLEX_EMPTY, ST_QSTRING, 0, GLEX_ACCEPT,
/* 20 */  L'}',  GLEX_EMPTY, 0, QASSOC_TOK_STRING, GLEX_RETURN,
/* 21 */  L' ',  GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 22 */  L'\r',  GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 23 */  L'\n',  GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 24 */  L'\t',  GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 25 */  GLEX_ANY, GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,

/* ST_QSTRING */
/* 26 */   0,    GLEX_EMPTY,   0, QASSOC_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,
/* 27 */   L'"', GLEX_EMPTY,   ST_STRING, 0, GLEX_ACCEPT,
/* 28 */   L'\\', GLEX_EMPTY,   ST_QSTRING_ESC, 0, GLEX_ACCEPT,
/* 29 */   GLEX_ANY, GLEX_EMPTY, ST_QSTRING, 0, GLEX_ACCEPT,

/* ST_QSTRING_ESC */
/* 30 */   GLEX_ANY, GLEX_EMPTY, ST_QSTRING, 0, GLEX_ACCEPT,
};

/*----------------------------------------------------

References of {objpath} where
    ResultClass=XXX
    Role=YYY
    RequiredQualifier=QualifierName
    ClassDefsOnly

Associators of {objpath} where
    ResultClass=XXX
    AssocClass=YYY
    Role=PPP
    RequiredQualifier=QualifierName
    RequiredAssocQualifier=QualifierName
    ClassDefsOnly

------------------------------------------------------*/

static BOOL ParseAssocQuery(
    IN  LPWSTR  Query,
    OUT LPWSTR *pTargetObj,
    OUT LPWSTR *pResultClass,
    OUT LPWSTR *pAssocClass,
    OUT LPWSTR *pRole,
    OUT LPWSTR *pResultRole,
    OUT LPWSTR *pRequiredQualifier,
    OUT LPWSTR *pRequiredAssocQualifier,
    OUT DWORD  *pdwQueryType
    )
{
    *pTargetObj = 0;
    *pResultClass = 0;
    *pAssocClass = 0;
    *pRole = 0;
    *pResultRole = 0;
    *pRequiredQualifier = 0;
    *pRequiredAssocQualifier = 0;
    *pdwQueryType = 0;

    // TBD: Check for out-of-memory here
    CTextLexSource src(Query);
    CGenLexer Lexer(AssocQuery_LexTable, &src);

    int nTok = 0;
    BOOL bHadTokens = FALSE;

    // Get first token.
    // TBD: Check for out-of-memory
    // =============================
    nTok = Lexer.NextToken();
    if (nTok != QASSOC_TOK_IDENT)
        goto Error;

    // REFERENCES or ASSOCIATORS
    // =========================
    if (wbem_wcsicmp(L"References", Lexer.GetTokenText()) == 0)
        *pdwQueryType |= QUERY_TYPE_GETREFS;
    else if (wbem_wcsicmp(L"Associators", Lexer.GetTokenText()) == 0)
        *pdwQueryType |= QUERY_TYPE_GETASSOCS;
    else
        goto Error;

    // OF
    // ==
    nTok = Lexer.NextToken();
    if (nTok != QASSOC_TOK_IDENT)
        goto Error;
    if (wbem_wcsicmp(L"of", Lexer.GetTokenText()) != 0)
        goto Error;

    // {OBJECTPATH}
    // ============
    nTok = Lexer.NextToken();
    if (nTok != QASSOC_TOK_STRING)
        goto Error;

    *pTargetObj = Macro_CloneLPWSTR(Lexer.GetTokenText());

    // WHERE
    // =====
    nTok = Lexer.NextToken();
    if (nTok == QASSOC_TOK_EOF)
        goto Completed;

    if (nTok != QASSOC_TOK_IDENT)
        goto Error;

    if (wbem_wcsicmp(L"where", Lexer.GetTokenText()) != 0)
        goto Error;

    // Check for RESULTCLASS, ROLE, ASSOCCLASS, CLASSDEFSONLY,
    // REQUIREDQUALIFIER, REQUIREDASSOCQUALIFIER
    // ======================================================

    for (;;)
    {
        nTok = Lexer.NextToken();
        if (nTok == QASSOC_TOK_ERROR)
            goto Error;

        if (nTok == QASSOC_TOK_EOF)
        {
            if(!bHadTokens)
                goto Error;
            else
                goto Completed;
        }

        if (nTok != QASSOC_TOK_IDENT)
            goto Error;

        bHadTokens = TRUE;

        if (wbem_wcsicmp(L"RESULTCLASS", Lexer.GetTokenText()) == 0)
        {
            if(*pResultClass)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_EQU)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_IDENT)
                goto Error;
            *pResultClass = Macro_CloneLPWSTR(Lexer.GetTokenText());
        }
        else if (wbem_wcsicmp(L"ROLE", Lexer.GetTokenText()) == 0)
        {
            if(*pRole)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_EQU)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_IDENT)
                goto Error;
            *pRole = Macro_CloneLPWSTR(Lexer.GetTokenText());
        }
        else if (wbem_wcsicmp(L"RESULTROLE", Lexer.GetTokenText()) == 0)
        {
            if(*pResultRole)
                goto Error;
            if(*pdwQueryType & QUERY_TYPE_GETREFS)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_EQU)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_IDENT)
                goto Error;
            *pResultRole = Macro_CloneLPWSTR(Lexer.GetTokenText());
        }
        else if (wbem_wcsicmp(L"ASSOCCLASS", Lexer.GetTokenText()) == 0)
        {
            if(*pAssocClass)
                goto Error;
            if(*pdwQueryType & QUERY_TYPE_GETREFS)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_EQU)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_IDENT)
                goto Error;
            *pAssocClass = Macro_CloneLPWSTR(Lexer.GetTokenText());
        }
        else if (wbem_wcsicmp(L"REQUIREDQUALIFIER", Lexer.GetTokenText()) == 0)
        {
            if(*pRequiredQualifier)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_EQU)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_IDENT)
                goto Error;
            *pRequiredQualifier = Macro_CloneLPWSTR(Lexer.GetTokenText());
        }
        else if (wbem_wcsicmp(L"REQUIREDASSOCQUALIFIER", Lexer.GetTokenText()) == 0)
        {
            if(*pRequiredAssocQualifier)
                goto Error;
            if(*pdwQueryType & QUERY_TYPE_GETREFS)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_EQU)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_IDENT)
                goto Error;
            *pRequiredAssocQualifier = Macro_CloneLPWSTR(Lexer.GetTokenText());
        }
        else if (wbem_wcsicmp(L"CLASSDEFSONLY", Lexer.GetTokenText()) == 0)
        {
            *pdwQueryType |= QUERY_TYPE_CLASSDEFS_ONLY;
        }
        else if (wbem_wcsicmp(L"KEYSONLY", Lexer.GetTokenText()) == 0)
        {
            *pdwQueryType |= QUERY_TYPE_KEYSONLY;
        }
        else if (wbem_wcsicmp(L"SCHEMAONLY", Lexer.GetTokenText()) == 0)
        {
            *pdwQueryType |= QUERY_TYPE_SCHEMA_ONLY;
        }
        else
        {
            goto Error;
        }
    }


Completed:
    if( (*pdwQueryType & QUERY_TYPE_SCHEMA_ONLY) &&
        (*pdwQueryType & QUERY_TYPE_CLASSDEFS_ONLY))
    {
        goto Error;
    }
    return TRUE;

Error:
    delete *pTargetObj;
    delete *pResultClass;
    delete *pAssocClass;
    delete *pRole;
    delete *pResultRole;
    delete *pRequiredQualifier;
    delete *pRequiredAssocQualifier;

    *pTargetObj = 0;
    *pResultClass = 0;
    *pAssocClass = 0;
    *pRole = 0;
    *pResultRole = 0;
    *pdwQueryType = 0;
    *pRequiredQualifier = 0;
    *pRequiredAssocQualifier = 0;

    return FALSE;
}

//***************************************************************************
//
//***************************************************************************

CAssocQueryParser::CAssocQueryParser()
{
    m_pszQueryText = 0;
    m_pszTargetObjPath = 0;
    m_pszResultClass = 0;
    m_pszAssocClass= 0;
    m_pszRole = 0;
    m_pszResultRole = 0;
    m_pszRequiredQual = 0;
    m_pszRequiredAssocQual = 0;
    m_dwType = 0;
    m_pPathParser = 0;
    m_pPath = 0;
}

//***************************************************************************
//
//***************************************************************************

CAssocQueryParser::~CAssocQueryParser()
{
    delete m_pszQueryText;
    delete m_pszTargetObjPath;
    delete m_pszResultClass;
    delete m_pszAssocClass;
    delete m_pszRole;
    delete m_pszResultRole;
    delete m_pszRequiredQual;
    delete m_pszRequiredAssocQual;

    if (m_pPathParser)
    {
        if (m_pPath)
            m_pPathParser->Free(m_pPath);
        delete m_pPathParser;
    }
}

//***************************************************************************
//
//***************************************************************************
HRESULT CAssocQueryParser::Parse(LPWSTR pszQuery)
{
    if (pszQuery == NULL)
        return WBEM_E_INVALID_QUERY;

    // Clone the query text for debugging.
    // ===================================
    int nLen = wcslen(pszQuery) + 1;
    m_pszQueryText = new wchar_t[nLen];
    if (m_pszQueryText == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    wcscpy(m_pszQueryText, pszQuery);

    // Parse it.
    // =========

    BOOL bRes = ParseAssocQuery(
        m_pszQueryText,
        &m_pszTargetObjPath,
        &m_pszResultClass,
        &m_pszAssocClass,
        &m_pszRole,
        &m_pszResultRole,
        &m_pszRequiredQual,
        &m_pszRequiredAssocQual,
        &m_dwType
        );

    if (bRes == FALSE)
        return WBEM_E_INVALID_QUERY;

    // Parse the object path.
    // ======================

    if (m_pszTargetObjPath)
    {
        m_pPathParser = new CObjectPathParser;
        if (!m_pPathParser)
            return WBEM_E_OUT_OF_MEMORY;
        int nStatus = m_pPathParser->Parse(m_pszTargetObjPath,  &m_pPath);
        if (nStatus != 0)
            return WBEM_E_INVALID_OBJECT_PATH;
    }

    return WBEM_S_NO_ERROR;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\assocqe.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    ASSOCQE.CPP

Abstract:

    WinMgmt Association Query Engine

History:

    raymcc  04-Jul-99   Adapted from QENGINE.CPP sources by revolutionary means,
                        as it was 'Independence Day 1999'.
    raymcc  31-Jul-99   Finished classref support
    raymcc  19-Aug-99   Fixed security & IN/OUT tagging problems.
    raymcc  10-Sep-99   Remaining Win2K bugs
    raymcc  25-May-00   Assoc-by-rule

--*/

#include "precomp.h"

#include <stdio.h>
#include <stdlib.h>

#include <wbemcore.h>
#include <tchar.h>

#include <oahelp.inl>
#include <wqllex.h>
#include <wqlnode.h>

#define WBEM_S_QUERY_OPTIMIZED_OUT  0x48001


int _Trace(char *pFile, const char *fmt, ...);
HRESULT ClassListDump(IN LPWSTR pszTitle,CFlexArray &aClasses);
void DiagnosticThread();





//***************************************************************************
//
//  Change these to ConfigMgr
//
//***************************************************************************

#define RUNAWAY_QUERY_TEST_THRESHOLD     (60000*10)
#define START_ANOTHER_SINK_THRESHOLD     (5000)
#define MAX_CONCURRENT_SINKS             5
#define MAX_CLASS_NAME                   512
#define DYN_CLASS_CACHE_REUSE_WINDOW     5000
#define MAX_INTERLEAVED_RESOLUTIONS      5


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  BEGIN QUERY ENGINE CONSTRUCTOR/DESTRUCTOR & COM SUPPORT
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


//***************************************************************************
//
//  CAssocQuery::CAssocQuery
//
//***************************************************************************
// full profiler line coverage

CAssocQuery::CAssocQuery()
{
    m_lRef = 0;

    m_pParser = 0;
    m_pDestSink = 0;
    m_pEndpoint = 0;

    m_bstrEndpointClass = 0;
    m_bstrEndpointRelPath = 0;
    m_bstrEndpointPath = 0;

    m_bEndpointIsClass = false;
    m_dwQueryStartTime = 0;
    m_dwLastResultTime = 0;
    m_lActiveSinks = 0;
    m_hSinkDoneEvent = 0;
    m_bEndpointIsClass = 0;

    m_pContext = 0;
    m_pNs = 0;

    InitializeCriticalSection(&m_csCandidateEpAccess);
    InitializeCriticalSection(&m_csDeliveredAccess);

    m_bCancel = false;
    m_bLimitNeedsDecrement = false;
    try 
    { 
        CAsyncServiceQueue* pTemp = ConfigMgr::GetAsyncSvcQueue();
        if(pTemp)
        {
            pTemp->IncThreadLimit();
            m_bLimitNeedsDecrement = true;
            pTemp->Release();
        }
    }
    catch(...) 
    {
        ExceptionCounter c;
    }
}

//***************************************************************************
//
//  CAssocQuery::~CAssocQuery()
//
//***************************************************************************
// full profiler line coverage

CAssocQuery::~CAssocQuery()
{
    // Cleanup.
    // ========
    if (m_pParser)
        delete m_pParser;

    if (m_bstrEndpointClass)
        SysFreeString(m_bstrEndpointClass);
    if (m_bstrEndpointRelPath)
        SysFreeString(m_bstrEndpointRelPath);
    if (m_bstrEndpointPath)
        SysFreeString(m_bstrEndpointPath);

    if (m_hSinkDoneEvent)
        CloseHandle(m_hSinkDoneEvent);

    EmptyObjectList(m_aMaster);
    EmptyObjectList(m_aDynClasses);

    // Release objects.
    // ================
    if (m_pDestSink)
        m_pDestSink->Release();
    if (m_pEndpoint)
        m_pEndpoint->Release();
    if (m_pContext)
        m_pContext->Release();
    if (m_pNs)
        m_pNs->Release();

    EmptyCandidateEpArray();    // Call this before deleting critsec

    DeleteCriticalSection(&m_csCandidateEpAccess);
    DeleteCriticalSection(&m_csDeliveredAccess);

    try 
    { 
        if(m_bLimitNeedsDecrement)
        {
            CAsyncServiceQueue* pTemp = ConfigMgr::GetAsyncSvcQueue();
            if(pTemp)
            {
                pTemp->DecThreadLimit();
                pTemp->Release();
            }
        }
    }
    catch(...) 
    {
        ExceptionCounter c;    
    }
}


//***************************************************************************
//
//  CAssocQuery::CreateInst
//
//  Mini factory
//
//***************************************************************************
// full profiler line coverage


CAssocQuery* CAssocQuery::CreateInst()
{
    typedef CAssocQuery* (*PFN_CreateAssocEng)();
    static BOOL bAttemptedAlternate = FALSE;
    static PFN_CreateAssocEng pAssocEngProc = 0;

    // Allow a hook into an external engine.  Will allow us to add
    // in rule-based associations in Pulsar, if required.
    // ===========================================================

    if (!bAttemptedAlternate)
    {
        bAttemptedAlternate = TRUE;

        TCHAR *pszAltAssocEng = 0;
        Registry r(WBEM_REG_WINMGMT);
        r.GetStr(__TEXT("AltAssocEngine"), &pszAltAssocEng);
        CDeleteMe<TCHAR> delMe1(pszAltAssocEng);

        if (pszAltAssocEng && _tcslen(pszAltAssocEng) > 0)
        {
            HMODULE hLib = LoadLibrary(pszAltAssocEng);
            if (hLib != 0)
            {
                pAssocEngProc = (PFN_CreateAssocEng) GetProcAddress(hLib, "CreateAssocEngInst");
            }
        }
    }

    // If there is an external engine, use it.
    // =======================================

    CAssocQuery *p = NULL;

    if (pAssocEngProc)
        p = pAssocEngProc();

    // If here, use the default.
    // =========================

    else
        p = new CAssocQuery();

    if (!p)
        return 0;
    p->AddRef();
    return p;
}


//***************************************************************************
//
//  CAssocQuery::Release
//
//***************************************************************************
// full profiler line coverage

ULONG CAssocQuery::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

//***************************************************************************
//
//  CStdProvider::Release
//
//***************************************************************************
// full profiler line coverage

ULONG CAssocQuery::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

//***************************************************************************
//
//  CNt5Refresher::QueryInterface
//
//  Standard COM QueryInterface().  We have to support two interfaces,
//  the IWbemServices interface itself to provide the objects and
//  the IWbemProviderInit interface to initialize the provider.
//
//***************************************************************************
// not called

HRESULT CAssocQuery::QueryInterface(
    REFIID riid,
    void** ppv
    )
{
    if (riid == IID_IUnknown)
    {
        *ppv = (IUnknown *) this;
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}


//***************************************************************************
//
//  CAssocQuery::Cancel
//
//  Attempts to cancel the query in the prime of its life.
//
//***************************************************************************
// not called

HRESULT CAssocQuery::Cancel()
{
    m_bCancel = true;
    return WBEM_S_NO_ERROR;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  END QUERY ENGINE CONSTRUCTOR/DESTRUCTOR & COM SUPPORT
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@













//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  BEGIN FLOW CONTROL
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

//***************************************************************************
//
//  CAssocQuery::Execute
//
//  ENTRY POINT from QENGINE.CPP
//
//  Attempts to executes a 'references' or 'associators' query.
//  Returns status via <pSink>.
//
//  Uses the calling thread to coordinate the entire query. The thread
//  logically blocks (and does some background work) until the entire query
//  is finished and is responsible for sending the final HRESULT
//  to the destination sink.
//
//  Ref count of 'this' is not changed in this function.  On entry,
//  the ref count is 1, so the caller makes the Release call.
//
//***************************************************************************
// ok

HRESULT CAssocQuery::Execute(
    IN  CWbemNamespace *pNs,
    IN  LPWSTR pszQuery,
    IN  IWbemContext* pContext,
    IN  CBasicObjectSink* pSink
    )
{
    HRESULT hRes;

    m_dwQueryStartTime = GetCurrentTime();

    // Check the Repository.
    // =====================

    m_pNs = pNs;                // Copy this for future use
    m_pNs->AddRef();

    // Build a query parser.
    // =====================

    m_pParser = new CAssocQueryParser;
    if (m_pParser == NULL)
    {
        pSink->Return(WBEM_E_OUT_OF_MEMORY);    //!
        return WBEM_E_OUT_OF_MEMORY;            //!
    }

    // Parse the query.
    // ================

    hRes = m_pParser->Parse(pszQuery);
    if (FAILED(hRes))
    {
        pSink->Return(hRes);                   //!
        return (hRes);                         //!
    }

    // If the query is KEYSONLY, we can toss out the original
    // context object and use a copy with merged in __GET_EXT_KEYS_ONLY
    // techniques.  Otherwise, we AddRef() the original context.
    // =================================================================

    BOOL bKeysOnlyQuery = (m_pParser->GetQueryType() & QUERY_TYPE_KEYSONLY) != 0;
    if (pContext)
    {
        if (bKeysOnlyQuery)                         //!
        {
            hRes = pContext->Clone(&m_pContext);    //!
            if (FAILED(hRes))
            {
                pSink->Return(hRes);
                return hRes;
            }
            hRes = m_pNs->MergeGetKeysCtx(m_pContext);  //!
            if (FAILED(hRes))
            {
                pSink->Return(hRes);
                return hRes;
            }
        }
        else
        {
            m_pContext = pContext;      // Yup, this too.
            m_pContext->AddRef();
        }
    }

    // At this point, the query and object path are syntactically
    // valid.  That's all we know.  Not much, eh?
    //
    // Next, get the endpoint referred to in the query.
    // ===========================================================

    IWbemClassObject* pErrorObj = NULL;

    hRes = pNs->Exec_GetObjectByPath(
        (LPWSTR) m_pParser->GetTargetObjPath(), // Path
        0,                                      // Flags
        pContext,                               // Context
        &m_pEndpoint,                           // Result obj
        &pErrorObj                              // Error obj, if any
        );

    CReleaseMe _1(pErrorObj);

    if (FAILED(hRes))
    {
        pSink->Return(hRes, pErrorObj);         //!
        return hRes;                            //!
    }

    // Record whether the endpoint is a class or instance.
    // ===================================================

    CVARIANT v;
    m_pEndpoint->Get(L"__GENUS", 0, &v, 0, 0);
    if (v.GetLONG() == 1)
        m_bEndpointIsClass = true;
    else
        m_bEndpointIsClass = false;

    // Initial validation.
    // For SCHEMAONLY, the endpoint must be a class.
    // For CLASSDEFS_ONLY, the endpoint must be an instance.
    // Otherwise, the endpoint can be either a class or
    // instance the association must be an instance.
    // ====================================================

    if (m_pParser->GetQueryType() & QUERY_TYPE_SCHEMA_ONLY)
    {
        if (m_bEndpointIsClass == false)               //!
        {
            pSink->Return(WBEM_E_INVALID_QUERY);
            return WBEM_E_INVALID_QUERY;
        }
    }
    else if (m_pParser->GetQueryType() & QUERY_TYPE_CLASSDEFS_ONLY)
    {
        if (m_bEndpointIsClass == true)                //!
        {
            pSink->Return(WBEM_E_INVALID_QUERY);
            return WBEM_E_INVALID_QUERY;
        }
        // Don't allow CLASSDEFSONLY and RESULTCLASS at the same time.
        if (m_pParser->GetResultClass() != 0)
        {
            pSink->Return(WBEM_E_INVALID_QUERY);
            return WBEM_E_INVALID_QUERY;
        }
    }

    // Get the class hierarchy and other info about the endpoint.
    // ==========================================================

    hRes = St_GetObjectInfo(
        m_pEndpoint,
        &m_bstrEndpointClass,
        &m_bstrEndpointRelPath,
        &m_bstrEndpointPath,
        m_aEndpointHierarchy
        );

    if (FAILED(hRes))
    {
        pSink->Return(hRes);
        return hRes;
    }

    // Now we at least know if there is going to be a chance.
    // ======================================================

    m_pDestSink = pSink;
    m_pDestSink->AddRef();

    try
    {
        BranchToQueryType();            // Forward-only execution, conceptually
    }
    catch(...)
    {
        ExceptionCounter c;
        pSink->Return(WBEM_E_CRITICAL_ERROR);
        return WBEM_E_CRITICAL_ERROR;
    }

    return WBEM_S_NO_ERROR;
}



//***************************************************************************
//
//  CAssocQuery::BranchToQueryType
//
//  This takes over once the query is known to be syntactically valid
//  and the endpoint object was found.
//
//  Status & results are returned to the destination sink in the
//  deeper functions.
//
//***************************************************************************
// ok

void CAssocQuery::BranchToQueryType()
{
    // Next, test for <SchemaOnly> or <ClassDefsOnly> query,
    // which allows us a short-cut.
    // =====================================================

    if (m_pParser->GetQueryType() & QUERY_TYPE_SCHEMA_ONLY)
    {
        ExecSchemaQuery();  // forward-only branch
    }
    // If here, we are executing a 'normal' query where
    // the association must be an instance.
    // ================================================
    else
    {
        ExecNormalQuery();
    }
}


//****************************************************************************
//
//  CAssocQuery::ExecSchemaQuery
//
//****************************************************************************
//  ok

void CAssocQuery::EmptyObjectList(CFlexArray &aTarget)
{
    for (int i = 0; i < aTarget.Size(); i++)
    {
        IWbemClassObject *pObj = (IWbemClassObject *) aTarget[i];
        pObj->Release();
    }
    aTarget.Empty();
}


//****************************************************************************
//
//  CAssocQuery::ExecSchemaQuery
//
//  This executes a SCHEMAONLY.
//
//  1. Get the list of classes which can reference the endpoint.
//  2. If REFERENCES OF, branch.
//  3. IF ASSOCIATORS OF, branch.
//
//  Execution model from this point:
//    Deeper functions only Indicate() results or else return hRes to
//    caller.  The only SetStatus() call for the destination sink
//    is at the bottom of this function.
//
//***************************************************************************
// ok

void CAssocQuery::ExecSchemaQuery()
{
    HRESULT hRes;
    CFlexArray aResultSet;

    // (1)
    // ===
    hRes = BuildMasterAssocClassList(aResultSet);

    if (SUCCEEDED(hRes))
    {
        // (2)
        // ===
        if (m_pParser->GetQueryType() & QUERY_TYPE_GETREFS)
            hRes = SchemaQ_RefsQuery(aResultSet);
        // (3)
        // ===
        else
            hRes = SchemaQ_AssocsQuery(aResultSet);
    }

    m_pDestSink->Return(hRes);
}


//****************************************************************************
//
//   CAssocQuery::ExecNormalQuery
//
//  This executes a normal query.  The association object must be
//  an instance pointing to the endpoint.  Either endpoint can be a
//  class or an instance.
//
//****************************************************************************
// ok

void CAssocQuery::ExecNormalQuery()
{
    HRESULT hRes;

    DWORD dwQueryType = m_pParser->GetQueryType();

    // Set up some helper events.
    // ==========================

    m_hSinkDoneEvent = CreateEvent(0,0,0,0);

    // Get the list of classes that can participate.
    // =============================================

    hRes = BuildMasterAssocClassList(m_aMaster);
    if (FAILED(hRes))
    {
        m_pDestSink->Return(hRes);
        return;
    }

    // Now reduce this to instantiable classes.
    // ========================================

    hRes = ReduceToRealClasses(m_aMaster);
    if (FAILED(hRes))
    {
        m_pDestSink->Return(hRes);
        return;
    }

    // Filter class list based on some quick analysis of the query.
    // ============================================================

    hRes = NormalQ_PreQueryClassFilter(m_aMaster);
    if (FAILED(hRes))
    {
        m_pDestSink->Return(hRes);
        return;
    }

#ifdef DIAGNOSTICS
    ClassListDump(L"---FINAL WORKING CLASS LIST----", m_aMaster);
#endif

    // Remove non-dynamic classes, as we will get static refs all in one go.
    // IMPORTANT: This must remain located after the zero-array size test above,
    // because the array size *will* be zero if the relationships are
    // all in the repository and we don't want the query to fail!
    // =========================================================================

    hRes = RemoveNonDynClasses(m_aMaster);
    if (FAILED(hRes))
    {
        m_pDestSink->Return(hRes);
        return;
    }

    if (ConfigMgr::ShutdownInProgress())
    {
        m_pDestSink->Return(WBEM_E_SHUTTING_DOWN);
        return;
    }

    // Now, we branch depending on the query type.
    // ===========================================

            // REFERENCES OF
    if (dwQueryType & QUERY_TYPE_GETREFS)
    {
        hRes = NormalQ_ReferencesOf();
    }
    else    // ASSOCIATORS OF
    {
        hRes = NormalQ_AssociatorsOf();
    }


    // At this point, we simply wait until the
    // total sink count is zero, indicating that the
    // query is completed.  We look at any errors
    // that were reported and determine what to return.
    // ================================================

    if (SUCCEEDED(hRes))
    while (m_lActiveSinks)
    {
        // Break if a sink finishes or 250 milliseconds pass
        // =================================================

        WaitForSingleObject(m_hSinkDoneEvent, 250);

        // If doing an ASSOCIATORS OF query (not with CLASSDEFSONLY)
        // then do some background tasking.
        // =========================================================

        if ((dwQueryType & QUERY_TYPE_GETASSOCS) != 0 &&
             (dwQueryType & QUERY_TYPE_CLASSDEFS_ONLY) == 0)
                hRes = ResolveEpPathsToObjects(MAX_INTERLEAVED_RESOLUTIONS);

        if (FAILED(hRes))
            break;

        if (m_bCancel)
        {
            hRes = WBEM_E_CALL_CANCELLED;
            break;
        }
    }

    // If an associators query, resolve the endpoints.
    // ===============================================

    if (SUCCEEDED(hRes))
    {
        if ((dwQueryType & QUERY_TYPE_GETASSOCS) != 0)
        {
            hRes = ResolveEpPathsToObjects(-1);
        }
    }

    m_pDestSink->Return(hRes);
}

//****************************************************************************
//
//  CAssocQuery::LoadCheck
//
//  Checks the load being induced by this query and prevents too much
//  concurrency.
//
//****************************************************************************
// ok

HRESULT CAssocQuery::NormalQ_LoadCheck()
{
    while (1)
    {
        if (m_lActiveSinks <= MAX_CONCURRENT_SINKS)
            break;

        // If we have a lot of active sinks, see if they
        // are fairly active, otherwise add another one.
        // =============================================

        DWORD dwNow = GetCurrentTime();
        if (dwNow - m_dwLastResultTime > START_ANOTHER_SINK_THRESHOLD)
            break;

        if (dwNow - m_dwQueryStartTime > RUNAWAY_QUERY_TEST_THRESHOLD)
            return WBEM_E_CRITICAL_ERROR;

        Sleep(50);  // Yield time to other threads
    }

    return WBEM_S_NO_ERROR;
}



//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  END FLOW CONTROL
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


























//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  BEGIN MASTER ASSOC CLASS LIST MANIPULATION
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


//****************************************************************************
//
//  CAssocQuery::BuildMasterAssocClassList
//
//  This function determines all the classes that could reference the
//  endpoint, depending on the query type.
//
//  Note: If the endpoint is a class and the query type is NOT schema-only,
//  this includes weakly typed classes that have HASCLASSREFS qualifiers
//  which can actually potentially reference the endpoint.
//
//  HRESULT only
//  Does not access the destination sink on error.
//
//  PARAMETERS:
//  <aClasses>      On entry, this is empty.  On exit, it contains
//                  ref counted copies of cached classes.  The objects
//                  within it need to be treated as read-only.  If they
//                  are modified in any way, they should be cloned.
//
//****************************************************************************
// ok

HRESULT CAssocQuery::BuildMasterAssocClassList(
    IN OUT CFlexArray &aMaster
    )
{
    CWStringArray aAllRefClasses;
    HRESULT hRes;

    BOOL bSchemaOnly = (m_pParser->GetQueryType() & QUERY_TYPE_SCHEMA_ONLY) != 0;

    // If the endpoint is a class, we want to add in
    // classes with HASCLASSREF qualifiers.
    // =============================================

    if (m_bEndpointIsClass && !bSchemaOnly)
        hRes = MergeInClassRefList(aMaster);

    // Go to the repository and get all classes which
    // can reference this class. Since a lot of duplicates
    // can happen, we do a union of the class list as
    // we move through it.
    // ====================================================

    for (int i = 0; i < m_aEndpointHierarchy.Size(); i++)
    {
        CWStringArray aRefClasses;

        hRes = Db_GetRefClasses(
            m_aEndpointHierarchy[i],
            aRefClasses
            );

        if (hRes == WBEM_E_NOT_FOUND)
            continue;         // It might be a dynamic endpoint
        else if (FAILED(hRes))
            return hRes;

        CWStringArray aTmp;
        CWStringArray::Union(aAllRefClasses, aRefClasses, aTmp);
        aAllRefClasses = aTmp;
    }

    // Now get each class definition from the repository.
    // This results in a lot of redundancy, since we end up
    // with subclasses of classes which actually contain
    // the references.
    // ====================================================

    for (i = 0; i < aAllRefClasses.Size(); i++)
    {
        LPWSTR pszClassName = aAllRefClasses[i];

        IWbemClassObject *pObj = 0;

        hRes = Db_GetClass(
            pszClassName,
            &pObj
            );

        if (FAILED(hRes))
        {
            return hRes;
        }

        // See if the class can really reference the endpoint
        // and discard it if not.
        // ==================================================

        hRes = CanClassRefQueryEp(bSchemaOnly, pObj, 0);
        if (FAILED(hRes))
            pObj->Release();
        else
            aMaster.Add(pObj);
    }

    // Now get the dynamic classes from class providers.
    // =================================================

    hRes = GetDynClasses();

    // Eliminate all the classes that cannot really
    // reference the endpoint.
    // ============================================

    for (i = 0; i < m_aDynClasses.Size(); i++)
    {
        IWbemClassObject *pDynClass = (IWbemClassObject *) m_aDynClasses[i];
        hRes = CanClassRefQueryEp(bSchemaOnly, pDynClass, 0);
        if (SUCCEEDED(hRes))
        {
            // If here, we will keep the dyn class as a result
            // set candidate.
            // ===============================================
            pDynClass->AddRef();
            aMaster.Add(pDynClass);
        }
    }

#ifdef DIAGNOSTICS
    ClassListDump(L"BuildMasterAssocClassList", aMaster);
#endif

    return WBEM_S_NO_ERROR;
}


//****************************************************************************
//
//  CAssocQuery::RemoveNonDynClasses
//
//  Removes all classes which don't have [dynamic] qualifiers.
//  This allows a single query to the repository for all references
//  and individual queries to providers to be cleanly separated.
//
//****************************************************************************
//  full profiler line coverage

HRESULT CAssocQuery::RemoveNonDynClasses(
    IN OUT CFlexArray &aMaster
    )
{
    HRESULT hRes1, hRes2;

    for (int i = 0; i < aMaster.Size(); i++)
    {
        IWbemClassObject *pClass = (IWbemClassObject *) aMaster[i];
        hRes1 = St_ObjHasQualifier(L"dynamic", pClass);
        hRes2 = St_ObjHasQualifier(L"rulebased", pClass);

        if (FAILED(hRes1) && FAILED(hRes2))
        {
            aMaster[i] = 0;
            pClass->Release();
        }
    }

    aMaster.Compress();
    return WBEM_S_NO_ERROR;
}

//****************************************************************************
//
//  CAssocQuery::MergeInClassRefList
//
//  Builds the list of classes from all sources which have HasClassRefs
//  qualifiers.  In addition, the class must be capable of referencing
//  the endpoint when it is a class.
//
//  Precondition: Query endpoint is known to be a class.
//
//****************************************************************************
// ok

HRESULT CAssocQuery::MergeInClassRefList(
    IN OUT CFlexArray &aResultSet
    )
{
    HRESULT hRes;

    CFlexArray aTemp;
    hRes = Db_GetClassRefClasses(aTemp);

    for (int i = 0; i < aTemp.Size(); i++)
    {
        IWbemClassObject *pClass = (IWbemClassObject *) aTemp[i];
        hRes = CanClassRefQueryEp(FALSE, pClass, 0);

        if (SUCCEEDED(hRes))
            aResultSet.Add(pClass);
        else
            pClass->Release();
    }

    return WBEM_S_NO_ERROR;
}


//****************************************************************************
//
//  CAssocQuery::CanClassRefQueryEp
//
//  Determines if a class can reference the endpoint class.
//
//  This works for both strongly typed and CLASSREF typed objects.
//
//  PARAMETERS:
//  <bStrict>           If TRUE, the match must be exact.  The tested
//                      class must have properties which directly reference
//                      the endpoint class name.  If FALSE, the class
//                      can have properties which reference any of the
//                      superclasses of the query endpoint class.
//  <pCls>              The class to test.
//  <paNames>           The role properties which would reference the query
//                      endpoint. (optional). If not NULL, should point to
//                      an empty array.
//
//  Returns:
//  WBEM_S_NO_ERROR if so
//  WBEM_E_FAILED
//
//****************************************************************************
// partly tested

HRESULT CAssocQuery::CanClassRefQueryEp(
    IN BOOL bStrict,
    IN IWbemClassObject *pCls,
    OUT CWStringArray *paNames
    )
{
    BOOL bIsACandidate = FALSE;
    HRESULT hRes;
    CIMTYPE cType;
    LONG lFlavor;

    LPCWSTR pszRole = m_pParser->GetRole();

    // Loop through the properties trying to find a legitimate
    // reference to our endpoint class.
    // =======================================================

    pCls->BeginEnumeration(WBEM_FLAG_REFS_ONLY);

    while (1)
    {
        BSTR strPropName = 0;
        hRes = pCls->Next(
            0,                  // Flags
            &strPropName,       // Name
            0,                  // Value
            &cType,             // CIMTYPE
            &lFlavor            // FLAVOR
            );

        CSysFreeMe _1(strPropName);

        if (hRes == WBEM_S_NO_MORE_DATA)
            break;

        // If the ROLE property is specified, and this property is not that
        // ROLE, we can immediately eliminate it.
        // ================================================================

        if (pszRole && _wcsicmp(strPropName, pszRole) != 0)
            continue;

        // Mask out references inherited from parent classes, if strict
        // rules in force.
        // ============================================================

        //if (bStrict && lFlavor == WBEM_FLAVOR_ORIGIN_PROPAGATED)
        //    continue;

        // If the object has reference properties which are not inherited
        // from the parent, then it is immediately candidate.
        // ===============================================================

        hRes = CanPropRefQueryEp(bStrict, strPropName, pCls, 0);
        if (SUCCEEDED(hRes))
        {
            bIsACandidate = TRUE;
            if (paNames)
                paNames->Add(strPropName);
        }
    }   // Enum of ref properties


    pCls->EndEnumeration();

    if (bIsACandidate)
        return WBEM_S_NO_ERROR;

    return WBEM_E_FAILED;
}

//****************************************************************************
//
//  CAssocQuery::GetCimTypeForRef
//
//****************************************************************************
//

HRESULT CAssocQuery::GetCimTypeForRef(
    IN IWbemClassObject *pCandidate,
    IN BSTR pszRole,
    OUT BSTR *strCimType
    )
{
    if (strCimType == 0)
        return WBEM_E_INVALID_PARAMETER;
    *strCimType = 0;

    // Get the qualifier set for the specified <role> property.
    // ========================================================

    IWbemQualifierSet *pQSet = 0;
    HRESULT hRes = pCandidate->GetPropertyQualifierSet(pszRole, &pQSet);
    if (FAILED(hRes))
        return WBEM_E_NOT_FOUND;
    CReleaseMe _1(pQSet);

    // Now, get the type of the role.
    // ==============================

    CVARIANT vCimType;
    hRes = pQSet->Get(L"CIMTYPE", 0, &vCimType, 0);
    if (FAILED(hRes) || V_VT(&vCimType) != VT_BSTR)
        return WBEM_E_FAILED;

    // Get the class name from it.
    // ===========================

    BSTR strRefClass = V_BSTR(&vCimType);
    if (wcslen(strRefClass) > MAX_CLASS_NAME)
        return WBEM_E_FAILED;

    wchar_t ClassName[MAX_CLASS_NAME];
    *ClassName = 0;
    if (strRefClass)
    {
        _wcsupr(strRefClass);
        swscanf(strRefClass, L"REF:%s", ClassName);
    }

    if (wcslen(ClassName))
    {
        *strCimType = SysAllocString(ClassName);
        return WBEM_S_NO_ERROR;
    }

    return WBEM_E_NOT_FOUND;
}



//****************************************************************************
//
//  CAssocQuery::DoesAssocInstRefQueryEp
//
//  Determines if an association instance actually references the
//  query endpoint.  Returns the role via which it actually references
//  the query endpoint.
//
//****************************************************************************
//
HRESULT CAssocQuery::DoesAssocInstRefQueryEp(
    IN IWbemClassObject *pObj,
    OUT BSTR *pstrRole
    )
{
    if (pstrRole == 0 || pObj == 0)
        return WBEM_E_INVALID_PARAMETER;

    BOOL bIsACandidate = FALSE;
    HRESULT hRes;

    // Loop through the properties trying to find a legitimate
    // reference to our endpoint class.
    // =======================================================

    pObj->BeginEnumeration(WBEM_FLAG_REFS_ONLY);

    while (1)
    {
        BSTR strPropName = 0;
        hRes = pObj->Next(
            0,                  // Flags
            &strPropName,       // Name
            0,                  // Value
            0,
            0
            );

        CSysFreeMe _1(strPropName);

        if (hRes == WBEM_S_NO_MORE_DATA)
            break;

        hRes = RoleTest(m_pEndpoint, pObj, m_pNs, strPropName, ROLETEST_MODE_PATH_VALUE);
        if (SUCCEEDED(hRes))
        {
            *pstrRole = SysAllocString(strPropName);
            pObj->EndEnumeration();
            return WBEM_S_NO_ERROR;
        }
    }   // Enum of ref properties


    pObj->EndEnumeration();

    return WBEM_E_NOT_FOUND;
}

//****************************************************************************
//
//  CAssocQuery::NormalQ_PreQueryClassFilter
//
//  For normal queries, filters the master class list depending on the
//  query parameters and the query type to eliminate as many association
//  classes as possible from participating in the query.  This is done
//  entirely by schema-level analysis and the query parameters.
//
//  Also, if the query endpoint is a class, then we eliminate dynamic
//  classes which don't have HasClassRefs qualifiers.
//
//****************************************************************************
// visual ok

HRESULT CAssocQuery::NormalQ_PreQueryClassFilter(
    CFlexArray &aMaster
    )
{
    HRESULT hRes;
    BOOL bChg = FALSE;

    CWStringArray aResClassHierarchy;    // Result class hierarchy
    CWStringArray aAssocClassHierarchy;  // Association class hierarchy

    IWbemClassObject *pResClass = 0;     // Result class object
    IWbemClassObject *pAssocClass = 0;   // Assoc class object

    LPCWSTR pszResultClass = m_pParser->GetResultClass();
    LPCWSTR pszAssocClass = m_pParser->GetAssocClass();

    // Get the RESULTCLASS.
    // ====================

    if (pszResultClass)
    {
        HRESULT hRes = GetClassFromAnywhere(pszResultClass, 0, &pResClass);
        if (hRes == WBEM_E_NOT_FOUND)
        {
            EmptyObjectList(aMaster);
            return WBEM_S_NO_ERROR;
        }
        else if (FAILED(hRes))
            return WBEM_E_FAILED;

        // Get its hierarchy.
        // ==================

        hRes = St_GetObjectInfo(
            pResClass, 0, 0, 0,
            aResClassHierarchy
            );

        if (FAILED(hRes))
            return WBEM_E_FAILED;

        // Get all the subclasses.
        // =======================

        CFlexArray aFamily;
        hRes = GetClassDynasty(pszResultClass, aFamily);

        for (int i = 0; i < aFamily.Size(); i++)
        {
            CVARIANT vClass;
            IWbemClassObject *pCls = (IWbemClassObject *) aFamily[i];
            pCls->Get(L"__CLASS", 0, &vClass, 0, 0);
            aResClassHierarchy.Add(vClass.GetStr());
        }

        EmptyObjectList(aFamily);
    }

    CReleaseMe _1(pResClass);

    // If the ASSOCCLASS was specified, get it and its hierarchy.
    // ==========================================================

    if (pszAssocClass)
    {
        HRESULT hRes = GetClassFromAnywhere(pszAssocClass, 0, &pAssocClass);
        if (hRes == WBEM_E_NOT_FOUND)
        {
            EmptyObjectList(aMaster);
            return WBEM_S_NO_ERROR;
        }
        else if (FAILED(hRes))
            return WBEM_E_FAILED;

        // Get its hierarchy.
        // ==================

        hRes = St_GetObjectInfo(
            pAssocClass, 0, 0, 0,
            aAssocClassHierarchy
            );

        if (FAILED(hRes))
            return WBEM_E_FAILED;
    }

    CReleaseMe _2(pAssocClass);


    // Prepurge if REFERENCES OF + RESULTCLASS is used
    // or ASSOCIATORS OR + ASSOCCLASS.  In both of these cases, the master class
    // list is largely irrelevant and will be mostly purged because these are present
    // in the query.
    //
    // [a] If RESULTCLASS/ASSOCCLASS is directly mentioned in the master, the master is
    //     purged and RESULTCLASS/ASSOCCLASS is added.
    //
    // [b] If RESULTCLASS/ASSOCCLASS is a subclass of a class in the master list, we examine
    //     its class hierarchy and determine if any of its superclasses appear in
    //     the master list.  If so, we purge the master list and replace it with a
    //     single entry, containing the RESULTCLASS def.
    //
    // [c] If RESULTCLASS/ASSOCCLASS is a superclass, we examine each class C in the
    //     master and determine if any of the superclasses of C are the
    //     RESULTCLASS/ASSOCCLASS.  If so, we retain C in the master. If not, we purge it.
    //

    LPCWSTR pszTestClass = 0;   // RESULTCLASS/ASSOCCLASS alias
    IWbemClassObject *pTestClass = 0;
    CWStringArray *paTest = 0;

    if ((m_pParser->GetQueryType() & QUERY_TYPE_GETREFS) && pszResultClass)
    {
        pszTestClass = pszResultClass;
        pTestClass = pResClass;
        paTest = &aResClassHierarchy;
    }

    if ((m_pParser->GetQueryType() & QUERY_TYPE_GETASSOCS) && pszAssocClass)
    {
        pszTestClass = pszAssocClass;
        pTestClass = pAssocClass;
        paTest = &aAssocClassHierarchy;
    }

    if (pszTestClass && pTestClass && paTest)
    {
        // Test [a] : Look for direct match.
        // =================================

        BOOL bPurgeAndReplace = FALSE;

        for (int i = 0; i < aMaster.Size(); i++)
        {
            IWbemClassObject *pClass = (IWbemClassObject *) aMaster[i];
            CVARIANT v;
            hRes = pClass->Get(L"__CLASS", 0, &v, 0, 0);
            if (FAILED(hRes))
                return hRes;

            if (_wcsicmp(V_BSTR(&v), pszTestClass) == 0)
            {
                bPurgeAndReplace = TRUE;
            }

            // Test [b]
            // If here, there was no equivalence.  So, the test class may be a subclass
            // of a class in master.  We simply look to see if this class name appears
            // in the hierarchy of the result class.
            // ===========================================================================

            if (!bPurgeAndReplace)
            for (int ii = 0; ii < paTest->Size(); ii++)
            {
                if (_wcsicmp(V_BSTR(&v), paTest->operator[](ii)) == 0)
                {
                    bPurgeAndReplace = TRUE;
                    break;
                }
            }


            if (bPurgeAndReplace)
            {
                // Get rid of everything but this one.
                // ===================================
                EmptyObjectList(aMaster);    // Will Release <pClass> once
                pTestClass->AddRef();       // Compensate for CReleaseMe _1 or _2
                aMaster.Add(pTestClass);
                break;
            }
        }
    }

    // Process possibly-altered master class list using other filters.
    // ===============================================================

    for (int i = 0; i < aMaster.Size(); i++)
    {
        IWbemClassObject *pClass = (IWbemClassObject *) aMaster[i];
        BOOL bKeep = TRUE;

        CVARIANT v;
        hRes = pClass->Get(L"__CLASS", 0, &v, 0, 0);
        if (FAILED(hRes))
            return hRes;

        // If query type is REFERENCES OF
        // ==============================

        if (m_pParser->GetQueryType() & QUERY_TYPE_GETREFS)
        {
            // ROLE test
            // =========

            LPCWSTR pszRole = m_pParser->GetRole();
            if (pszRole)
            {
                CWStringArray aNames;
                hRes = CanClassRefQueryEp(FALSE, pClass, &aNames);
                if (FAILED(hRes))
                    bKeep = FALSE;
                else
                {
                    for (int ii = 0; ii < aNames.Size(); ii++)
                    {
                        if (_wcsicmp(aNames[ii], pszRole) != 0)
                           bKeep = FALSE;
                    }
                }
            }

            // REQUIREDQUALIFIER test
            // =======================
            LPCWSTR pszRequiredQual = m_pParser->GetRequiredQual();
            if (pszRequiredQual)
            {
                hRes = St_ObjHasQualifier(pszRequiredQual, pClass);
                if (FAILED(hRes))
                {
                    // If not in the primary object, check subclasses.
                    CFlexArray aDynasty;
                    hRes = GetClassDynasty(v.GetStr(), aDynasty);
                    if (FAILED(hRes))
                        bKeep = FALSE;

                    int nCandidateCount = 0;
                    for (int ii = 0; ii< aDynasty.Size(); ii++)
                    {
                        IWbemClassObject *pTestCls = (IWbemClassObject *) aDynasty[ii];
                        hRes = St_ObjHasQualifier(pszRequiredQual, pTestCls);
                        if (SUCCEEDED(hRes))
                            nCandidateCount++;
                    }
                    EmptyObjectList(aDynasty);
                    if (nCandidateCount == 0)
                        bKeep = FALSE;  // Nobody in the family has the qualifier
                }
            }

            // RESULTCLASS test, test [c]
            // ==========================
            LPCWSTR pszResultClass2 = m_pParser->GetResultClass();
            if (pszResultClass2)
            {
                hRes = St_ObjIsOfClass(pszResultClass2, pClass);
                if (FAILED(hRes))
                    bKeep = FALSE;
            }
        }

        // If query type is ASSOCIATORS OF
        // ===============================

        else
        {
            // ROLE test
            // =========

            LPCWSTR pszRole = m_pParser->GetRole();
            if (pszRole)
            {
                CWStringArray aNames;
                hRes = CanClassRefQueryEp(FALSE, pClass, &aNames);
                if (FAILED(hRes))
                    bKeep = FALSE;
                else
                {
                    bKeep = FALSE;
                    for (int ii = 0; ii < aNames.Size(); ii++)
                    {
                        if (_wcsicmp(aNames[ii], pszRole) == 0)
                            bKeep = TRUE;
                    }
                }
            }

            // ASSOCCLASS, test[c]
            // ===================

            LPCWSTR pszAssocClass2 = m_pParser->GetAssocClass();
            if (pszAssocClass2)
            {
                hRes = St_ObjIsOfClass(pszAssocClass2, pClass);
                if (FAILED(hRes))
                    bKeep = FALSE;
            }

            // REQUIREDASSOCQUALIFER
            // =====================

            LPCWSTR pszRequiredAssocQual = m_pParser->GetRequiredAssocQual();
            if (pszRequiredAssocQual)
            {
                hRes = St_ObjHasQualifier(pszRequiredAssocQual, pClass);
                if (FAILED(hRes))
                {
                    // If not in the primary object, check subclasses.
                    CFlexArray aDynasty;
                    hRes = GetClassDynasty(v.GetStr(), aDynasty);
                    if (FAILED(hRes))
                        bKeep = FALSE;

                    int nCandidateCount = 0;
                    for (int ii = 0; ii < aDynasty.Size(); ii++)
                    {
                        IWbemClassObject *pTestCls = (IWbemClassObject *) aDynasty[ii];
                        hRes = St_ObjHasQualifier(pszRequiredAssocQual, pTestCls);
                        if (SUCCEEDED(hRes))
                            nCandidateCount++;
                    }
                    EmptyObjectList(aDynasty);
                    if (nCandidateCount == 0)
                        bKeep = FALSE;  // Nobody in the family has the qualifier
                }
            }

            // If RESULTCLASS was used, branch out and see if the association
            // class can even reference it.
            // ==============================================================

            LPCWSTR pszResultClass3 = m_pParser->GetResultClass();
            if (pszResultClass3 && m_bEndpointIsClass == FALSE)
            {
                // The above compound test is to err on the side of safety,
                // as the following function cannot deal with CLASSREFs. So,
                // we simply don't try to prefilter in that case.
                // =========================================================

                hRes = CanAssocClassRefUnkEp(pClass, aResClassHierarchy);
                if (FAILED(hRes))
                    bKeep = FALSE;
            }

            // If RESULTROLE is used, ensure the class even has a property of this name.
            // =========================================================================

            LPCWSTR pszResultRole = m_pParser->GetResultRole();
            if (pszResultRole)
            {
                CVARIANT v2;
                hRes = pClass->Get(pszResultRole, 0, &v2, 0, 0);
                if (FAILED(hRes))
                    bKeep = FALSE;
            }

        }   // end ASSOCIATORS OF test block

        // If query endpoint is a class, eliminate [dynamic] classes which don't
        // have HasClassRefs.
        // ======================================================================

        if (m_bEndpointIsClass)
        {
            hRes = St_ObjHasQualifier(L"dynamic", pClass);
            if (SUCCEEDED(hRes))
            {
                hRes = St_ObjHasQualifier(L"HasClassRefs", pClass);
                if (FAILED(hRes))
                    bKeep = FALSE;
            }
        }


        // Yawn.  So what did we end up deciding, anyway?
        // ==============================================

        if (bKeep == FALSE)
        {
            aMaster[i] = 0;
            pClass->Release();
        }
    }

    // No Swiss Cheese allowed. Close them holes.
    // ==========================================

    aMaster.Compress();

    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//  CAssocQuery::CanAssocClassRefUnkEp
//
//  Determines if the association class can reference the specified
//  class.
//
//  Returns:
//  WBEM_S_NO_ERROR if the assoc can reference the specified class.
//  WBEM_E_NOT_FOUND if the assoc cannot reference the class.
//  WBEM_E_FAILED in other cases.
//
//***************************************************************************
//
HRESULT CAssocQuery::CanAssocClassRefUnkEp(
    IN IWbemClassObject *pAssocClass,
    IN CWStringArray &aUnkEpHierarchy
    )
{
    HRESULT hRes;
    BOOL bFound = FALSE;

    // Loop through all references and see if any of them can
    // reference any of the classes in the result class hierarchy.
    // ===========================================================

    hRes = pAssocClass->BeginEnumeration(WBEM_FLAG_REFS_ONLY);

    while (1)
    {
        BSTR strPropName = 0;

        hRes = pAssocClass->Next(
            0,                  // Flags
            &strPropName,       // Name
            0,                  // Value
            0,
            0
            );

        CSysFreeMe _1(strPropName);

        if (hRes == WBEM_S_NO_MORE_DATA)
            break;

        BSTR strCimType = 0;
        hRes = GetCimTypeForRef(pAssocClass, strPropName, &strCimType);
        CSysFreeMe _2(strCimType);

        if (SUCCEEDED(hRes) && strCimType)
            for (int i = 0; i < aUnkEpHierarchy.Size(); i++)
            {
                if (_wcsicmp(aUnkEpHierarchy[i], strCimType) == 0)
                {
                    bFound = TRUE;
                    break;
                }
            }
    }

    pAssocClass->EndEnumeration();

    if (bFound)
    {
        return WBEM_S_NO_ERROR;
    }

    return WBEM_E_NOT_FOUND;
}


//***************************************************************************
//
//  CAssocQuery::ReduceToRealClasses
//
//  Reduces the master class list to classes which can be instantiated.
//
//  To have an instance, a class must
//  1. Have a [key] or be singleton
//  2. Not be abstract
//  3. Not have an instantiable superclass
//
//  Parameters:
//      IN OUT aMaster          Contains the unpruned result inbound
//                              and contains the pruned result set outbound
//
//  Return value:
//      HRESULT                  The destination sink is not accessed
//
//***************************************************************************
//

HRESULT CAssocQuery::ReduceToRealClasses(
    IN OUT CFlexArray & aMaster
    )
{
    HRESULT hRes;

    for (int i = 0; i < aMaster.Size(); i++)
    {
        BOOL bKeep = TRUE;
        IWbemClassObject *pObj = (IWbemClassObject *) aMaster[i];

        // See if class is abstract.
        // =========================
        IWbemQualifierSet *pQSet = 0;
        hRes = pObj->GetQualifierSet(&pQSet);
        if (FAILED(hRes))
            return hRes;
        CReleaseMe _1(pQSet);

        CVARIANT v1, v2, v3;
        HRESULT hResAbstract = pQSet->Get(L"ABSTRACT", 0, &v1, 0);
        HRESULT hResSingleton = pQSet->Get(L"SINGLETON", 0, &v2, 0);
        HRESULT hResDynamic = pQSet->Get(L"DYNAMIC", 0, &v3, 0);

        // See if there is at least one key.
        // =================================
        HRESULT hResHasKeys = WBEM_E_FAILED;
        pObj->BeginEnumeration(WBEM_FLAG_KEYS_ONLY);
        int nCount = 0;

        while (1)
        {
            // Actually, we don't care about anything
            // other than if keys even exist.  We
            // do this by simply testing how many
            // times this iterates.

            hRes = pObj->Next(0,0,0,0,0);
            if (hRes == WBEM_S_NO_MORE_DATA)
                break;
            nCount++;
        }

        pObj->EndEnumeration();
        if (nCount)
            hResHasKeys = WBEM_S_NO_ERROR;

        // Decision matrix which perform tests as to whether
        // this is an instantiable class.
        // ==================================================

        if (SUCCEEDED(hResAbstract))           // Abstracts are never instantiable
            bKeep = FALSE;
        else if (SUCCEEDED(hResDynamic))       // Dynamics must be instantiable
            bKeep = TRUE;
        else if (SUCCEEDED(hResHasKeys))       // Must be static/non-abstract
            bKeep = TRUE;
        else if (SUCCEEDED(hResSingleton))     // Must be static/non-abstract
            bKeep = TRUE;
        else
            bKeep = FALSE;          // Must be plain old keyless class

        // Final decision to zap or keep.
        // ==============================
        if (!bKeep)
        {
            aMaster[i] = 0;
            pObj->Release();
        }
    }

    aMaster.Compress();

    // Next, eliminate subclass/superclass pairs.
    // ==========================================

    for (i = 0; i < aMaster.Size(); i++)
    {
        IWbemClassObject *pObj = (IWbemClassObject *) aMaster[i];
        CWStringArray aHierarchy;
        hRes = St_GetObjectInfo(pObj, 0, 0, 0, aHierarchy);
        BOOL bKillIt = FALSE;

        if (FAILED(hRes))
            return WBEM_E_FAILED;

        // We now have the class and all of its superclasses in
        // <aHierarchy>.  We need to look at all the other classes
        // and see if any of them have a class name mentioned in
        // this array.
        // ========================================================

        for (int i2 = 0; i2 < aMaster.Size(); i2++)
        {
            IWbemClassObject *pTest = (IWbemClassObject *) aMaster[i2];

            if (pTest == 0 || i2 == i)
                continue;
                    // If the object has already been eliminated or
                    // if we are comparing an object with itself

            CVARIANT v;
            hRes = pTest->Get(L"__CLASS", 0, &v, 0, 0);
            if (FAILED(hRes))
                return hRes;

            LPWSTR pszName = V_BSTR(&v);
            if (pszName == 0)
                return WBEM_E_FAILED;

            bKillIt = FALSE;
            for (int i3 = 0; i3 < aHierarchy.Size(); i3++)
            {
                if (_wcsicmp(aHierarchy[i3], pszName) == 0)
                {
                    bKillIt = TRUE;
                    break;
                }
            }
            if (bKillIt)
                break;
        }

        if (bKillIt)
        {
            aMaster[i] = 0;
            pObj->Release();
        }
    }

    // Get rid of NULL entries.
    // ========================

    aMaster.Compress();

#ifdef DIAGNOSTICS
    ClassListDump(L"Reduced Class Set", aMaster);
#endif

    return WBEM_S_NO_ERROR;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  END MASTER ASSOC CLASS LIST MANIPULATION
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@









//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  BEGIN NORMAL QUERY SUPPORT
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



//****************************************************************************
//
//  CAssocQuery::NormalQ_ReferencesOf
//
//  Entry point for all normal REFERENCES OF queries.
//
//****************************************************************************
// untested; no support for classrefs, autoassocs, or classdefsonly

HRESULT CAssocQuery::NormalQ_ReferencesOf()
{
    HRESULT hRes;
    CObjectSink *pSink;

    // Issue one-time call into repository for static instances.
    // =========================================================
    pSink = CreateSink(FilterForwarder_NormalRefs, L"<objdb refs request>");

    if (pSink)
    {
	    hRes = Db_GetInstRefs(
	        m_bstrEndpointPath,
	        pSink
	        );

	    pSink->Release();
    }
    else
    {
        hRes = WBEM_E_OUT_OF_MEMORY;
    }

    if (FAILED(hRes))
    {
        if (!(hRes == WBEM_E_NOT_FOUND || hRes == WBEM_E_CALL_CANCELLED))
        {
            // We only go here if the repository is really griping.
            // ====================================================
            return WBEM_E_FAILED;
        }
    }

    hRes = WBEM_S_NO_ERROR;

    // Check for cancellation.
    // =======================

    if (m_bCancel)
    {
        hRes = WBEM_E_CALL_CANCELLED;
        return hRes;
    }

    // Now get all the dynamic ones.
    // =============================

    for (int i = 0; i < m_aMaster.Size(); i++)
    {
        IWbemClassObject *pClass = (IWbemClassObject *) m_aMaster[i];

        IWbemQualifierSet *pQSet = 0;
        hRes = pClass->GetQualifierSet(&pQSet);
        if (FAILED(hRes))
            return hRes;
        CReleaseMe _1(pQSet);

        CVARIANT v1, v2;
        HRESULT hResRuleBased = pQSet->Get(L"RULEBASED", 0, &v1, 0);
        HRESULT hResDynamic = pQSet->Get(L"DYNAMIC", 0, &v2, 0);

        if (SUCCEEDED(hResDynamic))
        {
            // If here, a normal association class.
            //
            // Build the query relative to this class that would select instances
            // which can point to the endpoint.
            // ==================================================================

            // We may be able to infer that keys_only behavior is possible.
            // ============================================================
            IWbemContext *pCopy = 0;
            if (m_pContext)
                m_pContext->Clone(&pCopy);                

            BSTR strQuery = 0;
            hRes = NormalQ_ConstructRefsQuery(pClass, pCopy, &strQuery);
            CSysFreeMe fm(strQuery);            
            if (FAILED(hRes))
                return WBEM_E_FAILED;

            // The query may have been optimized out of existence.
            // ===================================================

            if (hRes == WBEM_S_QUERY_OPTIMIZED_OUT)
            {
                if (pCopy)
                    pCopy->Release();
                hRes = 0;
                continue;
            }

            // Now submit the query to the sink.
            // =================================

            pSink = CreateSink(FilterForwarder_NormalRefs, strQuery);

            if (pSink)
            {
	            hRes = CoImpersonateClient();
	            if (SUCCEEDED(hRes))
	            {
	                BSTR bStrWQL = SysAllocString(L"WQL");
	                if (bStrWQL)
	                {
    	                CSysFreeMe fm_(bStrWQL);
		                hRes = m_pNs->ExecQueryAsync(bStrWQL, strQuery, 0, pCopy, pSink);
	                }
	                else
                        hRes = WBEM_E_OUT_OF_MEMORY;
		            CoRevertToSelf();
                }
                if (pCopy)
	                pCopy->Release();                
	            pSink->Release();
            }
            else
            {
                hRes = WBEM_E_OUT_OF_MEMORY;
            }

            if (FAILED(hRes))
                return hRes;

            hRes = NormalQ_LoadCheck();

            if (FAILED(hRes))
                return hRes;

            if (m_bCancel)
            {
                hRes = WBEM_E_CALL_CANCELLED;
                break;
            }

            // Cancel the query if out of memory.
            // ==================================
            BOOL bRes = CWin32DefaultArena::ValidateMemSize();
            if (!bRes)
            {
            }
        }
        // Rule based
        else if (SUCCEEDED(hResRuleBased))
        {
            CFlexArray aTriads;

            hRes = CoImpersonateClient();
            if (FAILED(hRes))
                return hRes;            
                
            hRes = m_pNs->ManufactureAssocs(pClass, m_pEndpoint, m_pContext, v1.GetStr(), aTriads);
            
            CoRevertToSelf();

            if (FAILED(hRes))
                return hRes;

            // Now deliver stuff to sink
            // =========================

            pSink = CreateSink(FilterForwarder_NormalRefs, L"<rulebased>");

            if (pSink)
            {
	            for (int ii = 0; ii < aTriads.Size(); ii++)
	            {
	                SAssocTriad *pTriad = (SAssocTriad *) aTriads[ii];
	                pSink->Indicate(1, &pTriad->m_pAssoc);
	            }

	            pSink->SetStatus(0, 0, 0, 0);
	            pSink->Release();
            }
            else
            {
                hRes = WBEM_E_OUT_OF_MEMORY;
            }

            SAssocTriad::ArrayCleanup(aTriads);
        }
    }

    return hRes;
}

//****************************************************************************
//
//  CAssocQuery::NormalQ_AssociatorsOf
//
//  Entry point for all normal ASSOCIATORS OF queries.
//
//****************************************************************************
//
//

HRESULT CAssocQuery::NormalQ_AssociatorsOf()
{
    HRESULT hRes;
    CObjectSink *pSink;

    // Issue one-time call into repository for static instances.
    // =========================================================
    pSink = CreateSink(FilterForwarder_NormalAssocs, L"<objdb assocs request>");

    if (pSink)
    {
	    hRes = Db_GetInstRefs(
	        m_bstrEndpointPath,
	        pSink
	        );

	    pSink->Release();
    }
    else
    {
        hRes = WBEM_E_OUT_OF_MEMORY;
    }

    if (FAILED(hRes))
    {
        if (!(hRes == WBEM_E_NOT_FOUND || hRes == WBEM_E_CALL_CANCELLED))
        {
            // We only go here if the repository is really griping.
            // ====================================================
            return WBEM_E_FAILED;
        }
    }

    hRes = WBEM_S_NO_ERROR;

    // Check for cancellation.
    // =======================

    if (m_bCancel)
    {
        hRes = WBEM_E_CALL_CANCELLED;
        return hRes;
    }

    // Now get dynamic associations.
    // =============================

    for (int i = 0; i < m_aMaster.Size(); i++)
    {
        IWbemClassObject *pClass = (IWbemClassObject *) m_aMaster[i];

        IWbemQualifierSet *pQSet = 0;
        hRes = pClass->GetQualifierSet(&pQSet);
        if (FAILED(hRes))
            return hRes;
        CReleaseMe _1(pQSet);

        CVARIANT v1, v2;
        HRESULT hResRuleBased = pQSet->Get(L"RULEBASED", 0, &v1, 0);
        HRESULT hResDynamic = pQSet->Get(L"DYNAMIC", 0, &v2, 0);

        if (SUCCEEDED(hResDynamic))
        {
            // Build the query relative to this class that would select instances
            // which can point to the endpoint.
            // ==================================================================

            BSTR strQuery = 0;
            hRes = NormalQ_ConstructRefsQuery(pClass, 0, &strQuery);
            CSysFreeMe fm(strQuery);
            if (FAILED(hRes))
                return WBEM_E_FAILED;

            if (hRes == WBEM_S_QUERY_OPTIMIZED_OUT)
            {
                hRes = 0;
                continue;
            }

            CObjectSink *pInSink = CreateSink(FilterForwarder_NormalAssocs, strQuery);

            if (pInSink)
            {
	            IWbemContext *pCopy = 0;
	            if (m_pContext)
	                m_pContext->Clone(&pCopy);

	            m_pNs->MergeGetKeysCtx(pCopy);

	            hRes = CoImpersonateClient();
	            if (SUCCEEDED(hRes))
	            {
	                BSTR bStrWQL = SysAllocString(L"WQL");
	                if (bStrWQL)
	                {
    	                CSysFreeMe fm_(bStrWQL);
	            	    hRes = m_pNs->ExecQueryAsync(bStrWQL, strQuery, 0, pCopy, pInSink);
	                }
	                else
                        hRes = WBEM_E_OUT_OF_MEMORY;	                	
		            CoRevertToSelf();
	            }

	            if (pCopy)
	                pCopy->Release();

	            pInSink->Release();
            }
            else
            {
                hRes = WBEM_E_OUT_OF_MEMORY;
            }

            if (FAILED(hRes))
            {
                return hRes;
            }

            NormalQ_LoadCheck();

            // Check for cancellation.
            // =======================

            if (m_bCancel)
            {
                hRes = WBEM_E_CALL_CANCELLED;
                break;
            }

            // Cancel the query if out of memory.
            // ==================================
            BOOL bRes = CWin32DefaultArena::ValidateMemSize();
            if (!bRes)
            {
            }
        }
        // Rule based
        else if (SUCCEEDED(hResRuleBased))
        {
            CFlexArray aTriads;

            hRes = CoImpersonateClient();
            if (FAILED(hRes))
                return hRes;
                
            hRes = m_pNs->ManufactureAssocs(pClass, m_pEndpoint, m_pContext, v1.GetStr(), aTriads);
            CoRevertToSelf();

            if (FAILED(hRes))
                return hRes;

            // Now deliver stuff to sink
            // =========================

            pSink = CreateSink(FilterForwarder_NormalRefs, L"<rulebased>");

            if (pSink)
            {
	            for (int ii = 0; ii < aTriads.Size(); ii++)
	            {
	                SAssocTriad *pTriad = (SAssocTriad *) aTriads[ii];
	                pSink->Indicate(1, &pTriad->m_pEp2);
	            }

	            pSink->SetStatus(0, 0, 0, 0);
	            pSink->Release();
            }
            else
            {
                hRes = WBEM_E_OUT_OF_MEMORY;
            }

            SAssocTriad::ArrayCleanup(aTriads);
        }
    }

    return hRes;
}


//***************************************************************************
//
//  CAssocQuery::NormalQ_GetRefsOfEndpoint
//
//  Builds a query text to select association instances which can reference
//  the endpoint instance.
//
//  Returns:
//  WBEM_S_NO_ERROR
//  A WBEM_E_ code
//
//***************************************************************************
//  ok

HRESULT CAssocQuery::NormalQ_ConstructRefsQuery(
    IN IWbemClassObject *pClass,
    IN OUT IWbemContext *pContextCopy,
    OUT BSTR *strQuery
    )
{
    if (strQuery == 0)
        return WBEM_E_INVALID_PARAMETER;

    *strQuery = 0;

    HRESULT hRes;
    CVARIANT v;

    // Get the class name of the association we are
    // trying to get instances for.
    // ============================================

    hRes = pClass->Get(L"__CLASS", 0, &v, 0, 0);
    if (FAILED(hRes))
        return WBEM_E_FAILED;

    // Build up the query we want.
    // ===========================

    WString wsQuery = "select * from ";
    wsQuery += V_BSTR(&v);                  // Add in assoc class
    wsQuery += " where ";

    // Next determine which role to use to reach the query endpoint.
    // =============================================================

    CWStringArray aNames;
    hRes = CanClassRefQueryEp(FALSE, pClass, &aNames);
    if (FAILED(hRes))
        return WBEM_E_FAILED;

    // If RESULTROLE is specified in the query, then eliminate
    // it from aNames, since aNames is reserved for roles
    // pointing to the query endpoint.
    // =======================================================
    LPCWSTR pszResultRole = m_pParser->GetResultRole();
    if (pszResultRole)
    {
        for (int i = 0; i < aNames.Size(); i++)
        {
            if (_wcsicmp(aNames[i], pszResultRole) == 0)
            {
                aNames.RemoveAt(i);
                i--;
            }
        }
    }

    // Ensure something is going to point to our endpoint.
    // ===================================================
    if (aNames.Size() == 0)
        return WBEM_S_QUERY_OPTIMIZED_OUT;

    // Now build up the query which refers to the endpoint explicitly.
    // If more than one role works, build up an OR clause.
    // ===============================================================

    while (aNames.Size())
    {
        wsQuery += aNames[0];
        wsQuery += "=\"";

        WString Path(m_bstrEndpointRelPath);
        wsQuery += Path.EscapeQuotes();
        wsQuery += "\"";

        aNames.RemoveAt(0);
        if (aNames.Size())
            wsQuery += " OR ";
    }

    // If here, we have the role to use.
    // =================================

    *strQuery = SysAllocString(wsQuery);

    DEBUGTRACE((LOG_WBEMCORE, "Association Engine: submitting query <%S> to core\n", LPWSTR(wsQuery) ));

    // Determine if association class only has keys anyway, in which
    // case we can merge in the keys_only behavior.  In cases
    // where the provider can only enumerate instead of interpret
    // the query, this might help.
    // =============================================================

    if (pContextCopy)
    {
        hRes = AssocClassHasOnlyKeys(pClass);
        if (hRes == WBEM_S_NO_ERROR)
        {
            hRes = m_pNs->MergeGetKeysCtx(pContextCopy);
        }
    }

    return WBEM_S_NO_ERROR;
}

//****************************************************************************
//
//  CAssocQuery::AssocClassHasOnlyKeys
//
//  Returns WBEM_S_NO_ERROR if the assoc class only has keys.
//
//****************************************************************************
//
HRESULT CAssocQuery::AssocClassHasOnlyKeys(
    IN IWbemClassObject *pObj
    )
{
    int nKeyCount = 0;
    HRESULT hRes;

    pObj->BeginEnumeration(WBEM_FLAG_KEYS_ONLY);
    while (1)
    {
        hRes = pObj->Next(0, 0, 0, 0, 0);
        if (hRes == WBEM_S_NO_MORE_DATA)
            break;
        nKeyCount++;
    }
    pObj->EndEnumeration();

    CVARIANT v;
    hRes = pObj->Get(L"__PROPERTY_COUNT", 0, &v, 0, 0);
    if (FAILED(hRes) || v.GetType() != VT_I4)
        return WBEM_E_FAILED;

    if (V_I4(&v) == nKeyCount)
        return WBEM_S_NO_ERROR;

    return WBEM_E_FAILED;
}

//****************************************************************************
//
//  CAssocQuery::FilterFowarder_NormalRefs
//
//  Filtering and forwarding for REFERENCES OF queries.
//  Handles normal queries and CLASSDEFSONLY queries; not used for
//  SCHEMAONLY queries.
//
//****************************************************************************
//  visual ok

HRESULT CAssocQuery::FilterForwarder_NormalRefs(
    IN IWbemClassObject *pCandidate
    )
{
    BOOL bKeep = TRUE;
    HRESULT hRes = 0;

    if (pCandidate == 0)
        return WBEM_E_INVALID_PARAMETER;

    // All objects must be instances.  We filter out any
    // class definitions.
    // ==================================================

    CVARIANT vGenus;
    pCandidate->Get(L"__GENUS", 0, &vGenus, 0, 0);
    if (vGenus.GetType() == VT_I4 && LONG(vGenus) == 1)
        return WBEM_S_NO_ERROR;

    // The object must pass a security check.
    // ======================================

    hRes = AccessCheck((CWbemObject *) pCandidate);
    if (FAILED(hRes))
        return WBEM_S_NO_ERROR;

    // RESULTCLASS test
    // ================

    LPCWSTR pszResultClass = m_pParser->GetResultClass();
    if (pszResultClass)
    {
        hRes = St_ObjIsOfClass(pszResultClass, pCandidate);
        if (FAILED(hRes))
            bKeep = FALSE;
    }


    // Verify the association points to the endpoint and
    // if so, get the role via which it does so.
    // ==================================================

    BSTR strRole = 0;
    hRes = DoesAssocInstRefQueryEp(
        pCandidate,
        &strRole
        );

    CSysFreeMe _1(strRole);

    if (FAILED(hRes))
        bKeep = FALSE;

    // ROLE
    // ====

    LPCWSTR pszRole = m_pParser->GetRole();          // x
    if (pszRole && strRole)
    {
         if (_wcsicmp(pszRole, strRole) != 0)
             bKeep = FALSE;
    }

    // REQUIREDQUALIFIER test
    // =======================

    LPCWSTR pszRequiredQual = m_pParser->GetRequiredQual();
    if (pszRequiredQual)
    {
        hRes = St_ObjHasQualifier(pszRequiredQual, pCandidate);
        if (FAILED(hRes))
            bKeep = FALSE;
    }

    if (!bKeep)
        return WBEM_S_NO_ERROR;

    // If here, the object is a candidate.  If the query type
    // is not CLASSDEFSONLY, then we directly send it back.
    // ======================================================

    if ((m_pParser->GetQueryType() & QUERY_TYPE_CLASSDEFS_ONLY) == 0)
    {
        hRes = m_pDestSink->Indicate(1, &pCandidate);
        return hRes;
    }

    IWbemClassObject *pRetCls = NULL;
    {
        CInCritSec ics(&m_csDeliveredAccess);
	    
    	hRes = GetClassDefsOnlyClass(pCandidate, &pRetCls);
    }

    // We may already have delivered the class in question,
    // so we don't just assume there is a pointer here.
    // ====================================================

    if (SUCCEEDED(hRes) && pRetCls)
    {
        hRes = m_pDestSink->Indicate(1, &pRetCls);
        pRetCls->Release();
    }

    if (FAILED(hRes))
        return hRes;

    return WBEM_S_OPERATION_CANCELLED;
}



//****************************************************************************
//
//  CAssocQuery::FilterForwarder_NormalAssocs
//
//  First level association instance filtering for ASSOCIATORS OF queries.
//  Handles normal queries and CLASSDEFSONLY queries; not used for
//  SCHEMAONLY queries.
//
//****************************************************************************
// visual ok

HRESULT CAssocQuery::FilterForwarder_NormalAssocs(
    IN IWbemClassObject *pAssocInst
    )
{
    HRESULT hRes = 0;
    BOOL bKeep = TRUE;

    if (pAssocInst == 0)
        return WBEM_E_INVALID_PARAMETER;

    // All objects must be instances.  We filter out any
    // class definitions.
    // ==================================================

    CVARIANT vGenus;
    pAssocInst->Get(L"__GENUS", 0, &vGenus, 0, 0);
    if (vGenus.GetType() == VT_I4 && LONG(vGenus) == 1)
        return WBEM_S_NO_ERROR;

    // The object must pass a security check.
    // ======================================

    hRes = AccessCheck((CWbemObject *) pAssocInst);
    if (FAILED(hRes))
        return WBEM_S_NO_ERROR;

    // ASSOCCLASS
    // ==========

    LPCWSTR pszAssocClass = m_pParser->GetAssocClass();
    if (pszAssocClass)
    {
        hRes = St_ObjIsOfClass(pszAssocClass, pAssocInst);
        if (FAILED(hRes))
            bKeep = FALSE;
    }

    // REQUIREDASSOCQUALIFIER
    // ======================
    LPCWSTR pszRequiredAssocQual = m_pParser->GetRequiredAssocQual();
    if (pszRequiredAssocQual)
    {
        hRes = St_ObjHasQualifier(pszRequiredAssocQual, pAssocInst);
        if (FAILED(hRes))
            bKeep = FALSE;
    }

    // ROLE
    // ====
    LPCWSTR pszRole = m_pParser->GetRole();
    if (pszRole)
    {
         hRes = RoleTest(m_pEndpoint, pAssocInst, m_pNs, pszRole, ROLETEST_MODE_PATH_VALUE);
         if (FAILED(hRes))
             bKeep = FALSE;
    }

    // If we have already rejected the instance, just give up without going any further.
    // =================================================================================

    if (bKeep == FALSE)
        return WBEM_S_NO_ERROR;

    // If here, looks like we'll be in the business of actually getting
    // the other endpoint.  Other rejections are still possible based
    // on RESULTROLE, however.
    // ================================================================

    // Get the Unknown Ep role.
    // ========================

    hRes = WBEM_S_NO_ERROR;

    // By keeping track of the last property we enumed, we will be able to handle
    // associations with multiple endpoints. (sanjes)
    // ==========================================================================

    BOOL bQueryEndpointFound = FALSE;

    pAssocInst->BeginEnumeration(WBEM_FLAG_REFS_ONLY);

    while (hRes == WBEM_S_NO_ERROR)
    {
        // Make sure these are reinitialized on each loop.

        BSTR strUnkEpPath = 0, strUnkEpRole = 0;
        bKeep = TRUE;

        // Just keep passing in the last property we got
        // ==============================================

        hRes = GetUnknownEpRoleAndPath(pAssocInst, &bQueryEndpointFound, &strUnkEpRole, &strUnkEpPath );
        if (FAILED(hRes))
        {
            pAssocInst->EndEnumeration();
            return WBEM_E_FAILED;
        }
        else if (hRes == WBEM_S_NO_MORE_DATA)
        {
            break;
        }

        CSysFreeMe _1(strUnkEpRole);

        // If we ran out of properties we should quit.
        // ===========================================

        if (SUCCEEDED(hRes))
        {
            // Verify the RESULTROLE.
            // ======================

            LPCWSTR pszResultRole = m_pParser->GetResultRole();
            if (pszResultRole)
            {
                if (_wcsicmp(pszResultRole, strUnkEpRole) != 0)
                    bKeep = FALSE;
            }

            // If here, we have the path of the unknown endpoint.
            // We save it away in a protected array.
            // ==================================================

            if (bKeep)
                hRes = AddEpCandidatePath(strUnkEpPath);    // Acquires pointer
            else
                SysFreeString(strUnkEpPath);
        }
    }

    // End the enumeration
    // ===================
    pAssocInst->EndEnumeration();


    return WBEM_S_NO_ERROR;
}


//****************************************************************************
//
//  CAssocQuery::AddEpCandidatePath
//
//  Adds the path to a candidate endpoint.  This is an intermediate
//  step in an ASSOCIATORS OF query.
//
//****************************************************************************
// visual ok

HRESULT CAssocQuery::AddEpCandidatePath(
    IN BSTR strOtherEp
    )
{
    CInCritSec ics(&m_csCandidateEpAccess);
    
    int nRes = m_aEpCandidates.Add(strOtherEp);
    
    if (nRes !=0)
        return WBEM_E_OUT_OF_MEMORY;
    return WBEM_S_NO_ERROR;
}

//****************************************************************************
//
//  CAssocQuery::EmptyCandidateEpArray
//
//  Empties the Endpoint candidate array.
//
//****************************************************************************
// visual ok

void CAssocQuery::EmptyCandidateEpArray()
{
    CInCritSec ics(&m_csCandidateEpAccess);
    
    for (int i = 0; i < m_aEpCandidates.Size(); i++)
        SysFreeString((BSTR) m_aEpCandidates[i]);
    m_aEpCandidates.Empty();    
}


//****************************************************************************
//
//  CAssocQuery::PerformFinalEpTests
//
//  Performs all final filter tests on the query endpoint.
//
//  Returns
//  WBEM_S_NO_ERROR if the object should be retained.
//  WBEM_E_INVALID_OBJECT if the object should not be retained.
//
//****************************************************************************
//
HRESULT CAssocQuery::PerformFinalEpTests(
    IWbemClassObject *pEp
    )
{
    BOOL bKeep = TRUE;
    HRESULT hRes;

    // Perform final tests. RESULTROLE
    // was verified in the intermediate stage.
    // =======================================

    LPCWSTR pszResultClass = m_pParser->GetResultClass();
    if (pszResultClass)
    {
        hRes = St_ObjIsOfClass(pszResultClass, pEp);
        if (FAILED(hRes))
             bKeep = FALSE;
    }

    // REQUIREDQUALIFIER test
    // =======================

    LPCWSTR pszRequiredQual = m_pParser->GetRequiredQual();
    if (pszRequiredQual)
    {
        hRes = St_ObjHasQualifier(pszRequiredQual, pEp);
        if (FAILED(hRes))
            bKeep = FALSE;
    }

    if (bKeep)
        return WBEM_S_NO_ERROR;

    return WBEM_E_INVALID_OBJECT;
}


//****************************************************************************
//
//  CAssocQuery::ResolvePathsToObjects
//
//****************************************************************************
//

HRESULT CAssocQuery::EpClassTest(
    LPCWSTR pszResultClass,
    BSTR strClassName,
    IWbemClassObject *pTestClass
    )
{
    HRESULT hRes;

    if (pszResultClass == 0 || strClassName == 0 || pTestClass == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (_wcsicmp(pszResultClass, strClassName) == 0)
        return WBEM_S_NO_ERROR;

    // Check the derivation of the class and see if the result class is mentioned.
    // ===========================================================================

    CVARIANT v;
    hRes = pTestClass->Get(L"__DERIVATION", 0,&v, 0, 0);
    if (FAILED(hRes))
        return hRes;

    CSAFEARRAY sa((SAFEARRAY *) v);
    v.Unbind();

    int nNum = sa.GetNumElements();

    for (int j = 0; j < nNum; j++)
    {
        BSTR bstrCls = 0;
        if (FAILED(sa.Get(j, &bstrCls)))
	    return WBEM_E_OUT_OF_MEMORY;
        CSysFreeMe _(bstrCls);
        if (_wcsicmp(bstrCls, pszResultClass) == 0)
            return WBEM_S_NO_ERROR;
    }

    return WBEM_E_NOT_FOUND;
}

//****************************************************************************
//
//  CAssocQuery::ResolvePathsToObjects
//
//  Runs through the existing endpoints and gets the objects, passes them
//  through the final tests sends them to to the caller.
//
//  Autoassoc support can directly populate the m_aEpCandidates array.
//
//  <nMaxToProcess>     If -1, process all.  Otherwise, only process
//                      as many as are requested.
//
//****************************************************************************
// visual ok

HRESULT CAssocQuery::ResolveEpPathsToObjects(
    IN int nMaxToProcess
    )
{
    if (ConfigMgr::ShutdownInProgress())
        return WBEM_E_SHUTTING_DOWN;

    HRESULT hRes = WBEM_S_NO_ERROR;
    IWbemClassObject *pEp = NULL;

    // If the query type is CLASSDEFS only, reduce the Ep list
    // to a list of class definitions.
    // =======================================================

    if (m_pParser->GetQueryType() & QUERY_TYPE_CLASSDEFS_ONLY)
        ConvertEpListToClassDefsOnly();

    // Determine how much of the ep list to process.
    // =============================================
    

    int nArraySize;
    {
        CInCritSec ics(&m_csCandidateEpAccess);
	    nArraySize = m_aEpCandidates.Size();

	    if (nMaxToProcess == -1 || nMaxToProcess > nArraySize)
	        nMaxToProcess = nArraySize;
    }

    // RESULTCLASS test
    // ================
    LPCWSTR pszResultClass = m_pParser->GetResultClass();

    // Process each element in EP list.
    // ================================

    for (int i = 0; i < nMaxToProcess; i++)
    {
        pEp = 0;

        // Extract one endpoint.
        // =====================
        BSTR strEpPath = NULL;
        {
            CInCritSec ics(&m_csCandidateEpAccess);
	        strEpPath = (BSTR) m_aEpCandidates[0];
    	    m_aEpCandidates.RemoveAt(0);
        }
        CSysFreeMe _2(strEpPath);

        // Do some analysis on the path.
        // =============================

        BSTR strClassName = 0;
        BOOL bIsClass;
        hRes = St_ObjPathInfo(strEpPath, &strClassName, &bIsClass);
        if (FAILED(hRes))
        {
            hRes = 0;
            continue;
        }

        BOOL bKeep = TRUE;

        CSysFreeMe _1(strClassName);

        // Important optimization: If RESULTCLASS is specified, look
        // up the class definition before trying to get the endpoint
        // just in case it can't pass the test.
        // ==========================================================

        if (pszResultClass)
        {
            // Get the class and do a RESULTCLASS test to avoid
            // getting the object.
            // =================================================
            IWbemClassObject *pTestClass;
            hRes = GetClassFromAnywhere(strClassName, 0, &pTestClass);

            if (FAILED(hRes))
            {
                ERRORTRACE((LOG_WBEMCORE, "Association cannot find class <%S>",
                        strClassName
                        ));
                hRes = 0;
                continue;
            }
            CReleaseMe _11(pTestClass);

            // Make sure the endpoint class passes query tests.
            // =================================================

            hRes = EpClassTest(pszResultClass, strClassName, pTestClass);
            if (FAILED(hRes))
            {
                hRes = WBEM_S_NO_ERROR;
                continue;
            }
        }


        // If a class, use our high-speed class getter.
        // ============================================

        if (bIsClass)
        {
            // GetClassFromAnyWhere

            hRes = GetClassFromAnywhere(strClassName, strEpPath, &pEp);
            if (FAILED(hRes))
            {
                ERRORTRACE((LOG_WBEMCORE, "Association cannot resolve dangling reference <%S>",
                        strEpPath
                        ));
                hRes = 0;
                continue;
            }
        }

        // Otherwise, an instance and we go the slow route.
        // ================================================

        else    // An instance
        {
            #ifdef DIAGNOSTICS
            _Trace("C:\\TEMP\\ASSOCQE.LOG", "Resolving EP %S\n", strEpPath);
            #endif

            IWbemClassObject* pErrorObj = NULL;
            hRes = m_pNs->Exec_GetObjectByPath(
                strEpPath,
                0,                              // Flags
                m_pContext,                     // Context
                &pEp,                           // Result obj
                &pErrorObj                      // Error obj, if any
                );

            CReleaseMe _11(pErrorObj);

            if (FAILED(hRes))
            {

                ERRORTRACE((LOG_WBEMCORE, "Association cannot resolve dangling reference <%S>",
                        strEpPath
                        ));
                hRes = 0;
                continue;
            }
        }

        // So, do we actually have an object, or are we fooling
        // ourselves?
        // =====================================================
        if (!pEp)
        {
            hRes = 0;
            continue;
        }


        // The object must pass a security check.
        // ======================================

        hRes = AccessCheck((CWbemObject *) pEp);
        if (FAILED(hRes))
        {
            pEp->Release();
            hRes = 0;
            continue;
        }

        // If we are going to keep this, send it to the caller.
        // ====================================================

        hRes = PerformFinalEpTests(pEp);

        if (SUCCEEDED(hRes))
            hRes = m_pDestSink->Indicate(1, &pEp);

        pEp->Release();
        hRes = WBEM_S_NO_ERROR;
    }

    return hRes;
}


//****************************************************************************
//
//  CAssocQuery::St_ObjPathPointsToClass
//
//  Returns WBEM_S_NO_ERROR if the object path points to a class,
//  or WBEM_E_FAILED if not.  Can also return codes for invalid paths,
//  out of memory, etc.
//
//****************************************************************************
//
HRESULT CAssocQuery::St_ObjPathInfo(
    IN LPCWSTR pszPath,
    OUT BSTR *pszClass,
    OUT BOOL *pbIsClass
    )
{
    CObjectPathParser Parser;
    ParsedObjectPath* pParsedPath = NULL;

    if (pszPath == 0)
        return WBEM_E_INVALID_PARAMETER;

    int nRes = Parser.Parse(pszPath, &pParsedPath);

    if (nRes != CObjectPathParser::NoError ||
        pParsedPath->m_pClass == NULL)
    {
        // Fatal. Bad path in association.
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    if (pbIsClass)
    {
        if (pParsedPath->m_dwNumKeys == 0)
            *pbIsClass = TRUE;
        else
            *pbIsClass = FALSE;
    }

    if (pszClass && pParsedPath->m_pClass)
        *pszClass = SysAllocString(pParsedPath->m_pClass);

    Parser.Free(pParsedPath);

    return WBEM_S_NO_ERROR;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  END NORMAL QUERY SUPPORT
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@











//***************************************************************************
//
//***************************************************************************
//


//***************************************************************************
//
//  CAssocQuery::CanClassRefReachQueryEp
//
//  Determines whether the property to which pQSet is bound can reach
//  the query endpoint via a CLASSREF qualifier.
//
//  <pQSet> bound to the property which supposedly references the query
//          endpoint.
//  <bStrict>  If true, the reference must directly reference the query
//          endpoint class, if FALSE it may reference any of the superclasses.
//
//  Returns:
//  WBEM_S_NO_ERROR if the reference occurs.
//  WBEM_E_NOT_FOUND if the references does not occur.
//
//***************************************************************************
// visual ok

HRESULT CAssocQuery::CanClassRefReachQueryEp(
    IWbemQualifierSet *pQSet,
    BOOL bStrict
    )
{
    HRESULT hRes;
    CVARIANT v;
    hRes = pQSet->Get(L"CLASSREF", 0, &v, 0);
    if (FAILED(hRes))
        return WBEM_E_NOT_FOUND;

    if (V_VT(&v) != (VT_BSTR | VT_ARRAY))
        return WBEM_E_INVALID_OBJECT;

    CSAFEARRAY sa((SAFEARRAY *) v);
    v.Unbind();

    int nNum = sa.GetNumElements();

    // Iterate through the safearray.
    // ==============================

    for (int i = 0; i < nNum; i++)
    {
        BSTR bstrClass = 0;
        if (FAILED(sa.Get(i, &bstrClass)))
		return WBEM_E_OUT_OF_MEMORY;
        if (bstrClass == 0)
            continue;
        CSysFreeMe _(bstrClass);
        if (bStrict)
        {
            if (_wcsicmp(bstrClass, m_bstrEndpointClass) == 0)
                return WBEM_S_NO_ERROR;
        }
        else for (int i2 = 0; i2 < m_aEndpointHierarchy.Size(); i2++)
        {
            if (_wcsicmp(bstrClass, m_aEndpointHierarchy[i2]) == 0)
                return WBEM_S_NO_ERROR;
        }
    }

    return WBEM_E_NOT_FOUND;
}








//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  BEGIN HELPER FUNCTIONS
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

//****************************************************************************
//
//  CAssocQuery::St_GetObjectInfo
//
//  Returns info about the object, such as its path, class, and
//  class hierarchy.
//
//****************************************************************************
// ok

HRESULT CAssocQuery::St_GetObjectInfo(
    IN  IWbemClassObject *pObj,
    OUT BSTR *pClass,
    OUT BSTR *pRelpath,
    OUT BSTR *pPath,
    OUT CWStringArray &aHierarchy
    )
{
    HRESULT hRes;
    int nRes;
    CVARIANT v;

    if (!pObj)
        return WBEM_E_INVALID_PARAMETER;

    // Get the owning class.
    // =====================

    hRes = pObj->Get(L"__CLASS", 0, &v, 0, 0);
    if (FAILED(hRes))
        return hRes;

    if (V_VT(&v) != VT_BSTR)
        return WBEM_E_INVALID_OBJECT;

    nRes = aHierarchy.Add(LPWSTR(v));
    if (nRes)
        return WBEM_E_OUT_OF_MEMORY;

    if (pClass)
    {
        *pClass = V_BSTR(&v);
        v.Unbind();
    }
    v.Clear();

    // Get the rel path.
    // =================

    if (pRelpath)
    {
        hRes = pObj->Get(L"__RELPATH", 0, &v, 0, 0);
        if (FAILED(hRes))
            return hRes;
        *pRelpath = V_BSTR(&v);
        v.Unbind();
    }
    v.Clear();

    if (pPath)
    {
        hRes = pObj->Get(L"__PATH", 0, &v, 0, 0);
        if (FAILED(hRes))
            return hRes;
        *pPath = V_BSTR(&v);
        v.Unbind();
    }
    v.Clear();

    // Get the superclasses.
    // =====================

    hRes = pObj->Get(L"__DERIVATION", 0,&v, 0, 0);
    if (FAILED(hRes))
        return hRes;

    CSAFEARRAY sa((SAFEARRAY *) v);
    v.Unbind();

    int nNum = sa.GetNumElements();

    for (int j = 0; j < nNum; j++)
    {
        BSTR bstrClass = 0;
        nRes = sa.Get(j, &bstrClass);
        if (FAILED(nRes))
        	return WBEM_E_OUT_OF_MEMORY;
        
        CSysFreeMe _(bstrClass);
        nRes = aHierarchy.Add(bstrClass);
        if (nRes)
            return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;
}



//****************************************************************************
//
//  CAssocQuery::GetUnknownEpRoleAndPath
//
//  Given an association object (class or inst), returns the role and
//  path which references the unknown endpoint.
//
//  Calling code is responsible for calling BeginEnum/EndEnum
//
//  All the OUT parameters are optional.
//
//****************************************************************************
//
HRESULT CAssocQuery::GetUnknownEpRoleAndPath(
    IN IWbemClassObject *pAssoc,
    IN BOOL *pFoundQueryEp,
    OUT BSTR *pszRole,
    OUT BSTR *pszUnkEpPath
    )
{
    HRESULT hRes = WBEM_E_FAILED;

    if (pAssoc == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Loop through the properties trying to find a legitimate
    // reference to our endpoint class.
    // =======================================================

    // sanjes
    // pAssoc->BeginEnumeration(WBEM_FLAG_REFS_ONLY);

    while (1)
    {
        BSTR strPropName = 0;
        hRes = pAssoc->Next(0, &strPropName,  0, 0, 0);
        CSysFreeMe _1(strPropName);

        if (hRes == WBEM_S_NO_MORE_DATA)
            break;

        hRes = RoleTest(m_pEndpoint, pAssoc, m_pNs, strPropName, ROLETEST_MODE_PATH_VALUE);
        if (SUCCEEDED(hRes) && *pFoundQueryEp == FALSE)    // The query  ep
        {
            *pFoundQueryEp = TRUE;
            continue;
        }

        // If here, we found the prop name which apparently references the
        // other endpoint.
        // ===============================================================

        if (pszRole)
            *pszRole = SysAllocString(strPropName);

        CVARIANT vPath;
        hRes = pAssoc->Get(strPropName, 0, &vPath, 0, 0);
        if (FAILED(hRes) || vPath.GetType() != VT_BSTR)
            break;

        if (pszUnkEpPath)
            *pszUnkEpPath = SysAllocString(vPath.GetStr());
        hRes = WBEM_S_NO_ERROR;
        break;
    }

    // sanjes
    // pAssoc->EndEnumeration();

    return hRes;    // Unexpected in real life
}

//****************************************************************************
//
//  CAssocQuery::RoleTest
//
//  Determines if the <pCandidate> object can point to the <pEndpoint> object
//  via the specified <pszRole> property.
//
//  Parameters:
//  <pEndpoint>     The test endpoint object
//  <pCandidate>    The association object which may point to the endpoint.
//  <pszRole>       The role to use for the test.
//  <dwMode>        One of the ROLETEST_MODE_ constants.
//
//  Precisely,
//
//  (1) ROLETEST_MODE_PATH_VALUE
//  The candidate must reference the endpoint exactly via the specified
//  role property, which must contain the path of the endpoint.
//  Requirement: Both <pEndpoint> <pCandidate> can be anything.
//
//  (2) ROLETEST_MODE_CIMREF_TYPE
//  The role path is NULL and the CIM reference type is used to determine
//  if the endpoint can be referenced.  In this case, the CIM reference
//  type must exactly reference the endpoint class.
//  Requirement: Both <pEndpoint> and <pCandidate> are classes.
//
//  Returns:
//      WBEM_S_NO_ERROR
//      WBEM_E_NOT_FOUND         If the role cannot reference the endpoint.
//      WBEM_E_INVALID_PARAMETER ...in most other cases.
//
//****************************************************************************
// visual ok

HRESULT CAssocQuery::RoleTest(
    IN IWbemClassObject *pEndpoint,
    IN IWbemClassObject *pCandidate,
    IN CWbemNamespace *pNs,
    IN LPCWSTR pszRole,
    IN DWORD dwMode
    )
{
    HRESULT hRes;
    CVARIANT v;
    BOOL bEndpointIsClass, bCandidateIsClass;

    if (!pszRole || !pEndpoint || !pCandidate)
        return WBEM_E_INVALID_PARAMETER;

    // Get the genus values of the endpoint & candidate.
    // =================================================

    pEndpoint->Get(L"__GENUS", 0, &v, 0, 0);
    if (v.GetLONG() == 1)
        bEndpointIsClass = TRUE;
    else
        bEndpointIsClass = FALSE;
    v.Clear();

    pCandidate->Get(L"__GENUS", 0, &v, 0, 0);
    if (v.GetLONG() == 1)
        bCandidateIsClass = TRUE;
    else
        bCandidateIsClass = FALSE;
    v.Clear();

    // Get the qualifier set for the specified <role> property.
    // ========================================================

    IWbemQualifierSet *pQSet = 0;
    hRes = pCandidate->GetPropertyQualifierSet(pszRole, &pQSet);
    if (FAILED(hRes))
        return WBEM_E_NOT_FOUND;
    CReleaseMe _1(pQSet);

    // Now, get the type of the role.
    // ==============================

    CVARIANT vCimType;
    hRes = pQSet->Get(L"CIMTYPE", 0, &vCimType, 0);
    if (FAILED(hRes) || V_VT(&vCimType) != VT_BSTR)
        return WBEM_E_FAILED;

    // Get the class name from it.
    // ===========================

    BSTR strRefClass = V_BSTR(&vCimType);
    if (wcslen(strRefClass) > MAX_CLASS_NAME)
        return WBEM_E_FAILED;

    wchar_t ClassName[MAX_CLASS_NAME];
    *ClassName = 0;
    if (strRefClass)
    {
        _wcsupr(strRefClass);
        swscanf(strRefClass, L"REF:%s", ClassName);
    }
    // Once here, 'object ref' types will simply
    // have a zero-length <ClassName> string.


    // Determine which of the four cases we are executing.
    // ===================================================

    if (dwMode == ROLETEST_MODE_CIMREF_TYPE)
    {
        if (bCandidateIsClass == FALSE && bEndpointIsClass == FALSE)
            return WBEM_E_INVALID_PARAMETER;

        if (*ClassName == 0)
            return WBEM_E_NOT_FOUND;

        // See if the class name and the class of the object
        // are the same.
        // ==================================================
        CVARIANT vCls;
        HRESULT hResInner = pEndpoint->Get(L"__CLASS", 0, &vCls, 0, 0);
        if (FAILED(hResInner))
            return hResInner;
        
        if (_wcsicmp(ClassName, vCls.GetStr()) == 0)
            return WBEM_S_NO_ERROR;

        // Find out if the CIM type string points to the object.
        // =====================================================
        hRes = PathPointsToObj(ClassName, pEndpoint, pNs);
    }

    // The endpoint must be directly and exactly referenced
    // by the role property's *value*.
    // ====================================================

    else if (dwMode == ROLETEST_MODE_PATH_VALUE)
    {
        // Get the value of the role property.
        // ===================================

        CVARIANT vRolePath;
        hRes = pCandidate->Get(pszRole, 0, &vRolePath, 0, 0);
        if (FAILED(hRes))
            return WBEM_E_FAILED;

        if (vRolePath.GetType() == VT_NULL)
            return WBEM_E_NOT_FOUND;

        hRes = PathPointsToObj(vRolePath.GetStr(), pEndpoint, pNs);
    }
    else
        return WBEM_E_INVALID_PARAMETER;

    return hRes;
}




//****************************************************************************
//
//  CAssocQuery::St_ObjIsOfClass
//
//  Determines if the specified object is of or derives from the specified
//  class.
//
//  Returns:
//      WBEM_E_INVALID_CLASS if there is no match.
//      WBEM_S_NO_ERROR      if there is a match.
//      WBEM_E_*             on other failures
//
//****************************************************************************
// visual ok

HRESULT CAssocQuery::St_ObjIsOfClass(
    IN LPCWSTR pszRequiredClass,
    IN IWbemClassObject *pObj
    )
{
    if (pszRequiredClass == 0)
        return WBEM_E_INVALID_PARAMETER;

    HRESULT hRes;
    CWStringArray aHierarchy;

    hRes = St_GetObjectInfo(pObj, 0, 0, 0, aHierarchy);
    if (FAILED(hRes))
        return hRes;

    for (int i = 0; i < aHierarchy.Size(); i++)
        if (_wcsicmp(pszRequiredClass, aHierarchy[i]) == 0)
            return WBEM_S_NO_ERROR;

    return WBEM_E_INVALID_CLASS;
}



//****************************************************************************
//
//  CAssocQuery::PathPointsToObj
//
//  Determines if a particular object path points to the specified object
//  or not.  Tries to avoid full object path parsing, if possible.
//
//  Returns WBEM_S_NO_ERROR, WBEM_E_FAILED
//
//****************************************************************************
// ok

HRESULT CAssocQuery::PathPointsToObj(
    IN LPCWSTR pszPath,
    IN IWbemClassObject *pObj,
    IN CWbemNamespace *pNs
    )
{
    HRESULT hRes;

    if (pszPath == 0 || pObj == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Test for simple equality of __RELPATH.
    // ======================================

    CVARIANT vRel;
    hRes = pObj->Get(L"__RELPATH", 0, &vRel, 0, 0);
    if (FAILED(hRes))
        return WBEM_E_FAILED;

    if (_wcsicmp(pszPath, V_BSTR(&vRel)) == 0)
        return WBEM_S_NO_ERROR;

    // Test for simple equality of __PATH.
    // ===================================

    CVARIANT vFullPath;
    hRes = pObj->Get(L"__PATH", 0, &vFullPath, 0, 0);
    if (FAILED(hRes))
        return WBEM_E_FAILED;

    if (_wcsicmp(pszPath, V_BSTR(&vFullPath)) == 0)
        return WBEM_S_NO_ERROR;

    // If here, we have to actually parse the object paths
    // in question.
    // ===================================================

    LPWSTR pszNormalizedPath = CQueryEngine::NormalizePath(pszPath, pNs);
    LPWSTR pszNormalizedTargetPath = CQueryEngine::NormalizePath(vFullPath.GetStr(), pNs);
    CDeleteMe <wchar_t> _1(pszNormalizedPath);
    CDeleteMe <wchar_t> _2(pszNormalizedTargetPath);

    if (pszNormalizedPath && pszNormalizedTargetPath)
        if (_wcsicmp(pszNormalizedPath, pszNormalizedTargetPath) == 0)
            return WBEM_S_NO_ERROR;

    return WBEM_E_FAILED;
}

//***************************************************************************
//
//  CAssocQualifierL::St_ObjHasQualifier
//
//  Determines if an object has a particular qualifier.  Used for
//  REQUIREDQUALIFIER or REQUIREDASSOCQUALIFIER tests.  The qualifier
//  must be present and not be VARIANT_FALSE.
//  Returns WBEM_S_NO_ERROR if the object has the qualifier.
//  Returns an WBEM_E_ error code otherwise.
//
//***************************************************************************
// visual ok

HRESULT CAssocQuery::St_ObjHasQualifier(
    IN LPCWSTR pszQualName,
    IN IWbemClassObject *pObj
    )
{
    if (pszQualName == 0 || wcslen(pszQualName) == 0 || pObj == 0)
        return WBEM_E_INVALID_PARAMETER;

    IWbemQualifierSet *pQSet = 0;

    HRESULT hRes = pObj->GetQualifierSet(&pQSet);
    if (FAILED(hRes))
        return WBEM_E_FAILED;
    CReleaseMe _1(pQSet);

    CVARIANT v;
    hRes = pQSet->Get(pszQualName, 0, &v, 0);

    if (SUCCEEDED(hRes))
    {
        if (V_VT(&v) == VT_BOOL && V_BOOL(&v) == VARIANT_FALSE)
            return WBEM_E_FAILED;
        return WBEM_S_NO_ERROR;
    }

    return WBEM_E_FAILED;
}




//***************************************************************************
//
//  CAssocQuery::St_ReleaseArray
//
//***************************************************************************
// visual ok

HRESULT CAssocQuery::St_ReleaseArray(
    IN CFlexArray &aObjects
    )
{
    // Release all the objects.
    // ========================

    for (int i = 0; i < aObjects.Size(); i++)
    {
        IWbemClassObject *p = (IWbemClassObject *) aObjects[i];
        p->Release();
    }

    return WBEM_S_NO_ERROR;
}


//****************************************************************************
//
//  CAssocQuery::Db_GetClass
//
//  DB abstraction layer.  Will make it easier to plug in Quasar engine.
//
//****************************************************************************
// ok

HRESULT CAssocQuery::Db_GetClass(
    IN LPCWSTR pszClassName,
    OUT IWbemClassObject **pClass
    )
{
    HRESULT hRes = CRepository::GetObject(
            m_pNs->GetNsSession(),
            m_pNs->GetScope(),
            pszClassName,
            0,
            pClass
            );

    return hRes;
}


//****************************************************************************
//
//  CAssocQuery::Db_GetInstRefs
//
//  DB abstraction layer.  Will make it easier to plug in Quasar engine.
//
//****************************************************************************
//

HRESULT CAssocQuery::Db_GetInstRefs(
    IN LPCWSTR pszTargetObj,
    IN IWbemObjectSink *pSink
    )
{
    HRESULT hRes = CRepository::GetInstanceRefs(
        m_pNs->GetNsSession(),
        m_pNs->GetScope(),
        pszTargetObj,
        pSink
        );

    return hRes;
}


//****************************************************************************
//
//  CAssocQuery::Db_GetClass
//
//  DB abstraction layer.  Will make it easier to plug in Quasar engine.
//
//****************************************************************************
// ok

HRESULT CAssocQuery::Db_GetRefClasses(
    IN  LPCWSTR pszClass,
    OUT CWStringArray &aRefClasses
    )
{
    HRESULT hRes = CRepository::GetRefClasses(
            m_pNs->GetNsSession(),
            m_pNs->GetNsHandle(),
            pszClass,
            FALSE,
            aRefClasses
            );

    return hRes;
}


//***************************************************************************
//
//  CAssocQuery::Db_GetClassRefClasses
//
//  Gets all classes with HasClassRefs qualifiers.
//
//***************************************************************************
//
HRESULT CAssocQuery::Db_GetClassRefClasses(
    IN CFlexArray &aDest
    )
{
    HRESULT hRes;
    CSynchronousSink* pRefClassSink = 0;

    pRefClassSink = new CSynchronousSink;
    
    if (NULL == pRefClassSink)
        return WBEM_E_OUT_OF_MEMORY;
        
    pRefClassSink->AddRef();
    CReleaseMe _1(pRefClassSink);


    hRes = CRepository::GetClassesWithRefs(
        m_pNs->GetNsSession(),
        m_pNs->GetNsHandle(),
        pRefClassSink
        );

    if (FAILED(hRes))
        return WBEM_E_CRITICAL_ERROR;

    pRefClassSink->GetStatus(&hRes, NULL, NULL);

    CRefedPointerArray<IWbemClassObject>& raObjects = pRefClassSink->GetObjects();

    for (int i = 0; i < raObjects.GetSize(); i++)
    {
        IWbemClassObject *pClsDef = (IWbemClassObject *) raObjects[i];
        pClsDef->AddRef();
        aDest.Add(pClsDef);
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//  CAssocQuery::GetClassFromAnywhere
//
//  Tries to get a class definition from anywhere as fast as possible.
//  We do this by the following algorithm in a hope to achieve best
//  performance:
//
//  (1) Search the dynamic class cache
//  (2) Call the database directly for this namespace
//  (3) Call Exec_GetObjectByPath (hoping that an unrelated dyn class
//      provider has the class)
//
//***************************************************************************
// visual ok

HRESULT CAssocQuery::GetClassFromAnywhere(
    IN  LPCWSTR pszEpClassName,
    IN  LPCWSTR pszFullClassPath,
    OUT IWbemClassObject **pCls
    )
{
    HRESULT hRes;

    // Try to find the class in the dynamic class cache.
    // We will only look for classes in our own namespace, however.
    // ============================================================
    hRes = GetDynClass(pszEpClassName, pCls);

    if (SUCCEEDED(hRes))
        return hRes;

    // If here, no luck in the dynamic class cache.  Try
    // the repository.  We try to use the full path to support
    // the limited cross-namespace support required by
    // SNMP SMIR, etc.
    // ========================================================

    if (pszFullClassPath == 0)
        pszFullClassPath = pszEpClassName;

    hRes = Db_GetClass(pszFullClassPath, pCls);

    if (SUCCEEDED(hRes))
        return hRes;

    // If here, our hopes are nearly dashed. One last chance
    // that a dyn class provider may have it if the
    // class was supplied by a provider other than the
    // one which supplied the association class.
    // =====================================================

    IWbemClassObject* pErrorObj = NULL;

    hRes = m_pNs->Exec_GetObjectByPath(
            (LPWSTR) pszFullClassPath,          // Class name
            0,                                  // Flags
            m_pContext,                         // Context
            pCls,                               // Result obj
            &pErrorObj                          // Error obj, if any
            );

    CReleaseMe _1(pErrorObj);

    // If we found it, great.
    // ======================

    if (SUCCEEDED(hRes))
        return hRes;

    return WBEM_E_NOT_FOUND;
}


//***************************************************************************
//
//  CAssocQuery::St_HasClassRefs
//
//  Determines if a class has a <HasClassRefs> qualifier.
//
//  Parameters
//  <pCandidate>        Points to the object to be tested (read-only).
//
//  Return value:
//  WBEM_S_NO_ERROR     If the class has a <HasClassRefs> qualifier.
//  WBEM_E_NOT_FOUND        If the class doesn't have the qualifier.
//  ...other codes
//
//***************************************************************************
// visual ok

HRESULT CAssocQuery::St_HasClassRefs(
    IN IWbemClassObject *pCandidate
    )
{
    if (pCandidate == 0)
        return WBEM_E_INVALID_PARAMETER;

    HRESULT hRes = St_ObjHasQualifier(L"HasClassRefs", pCandidate);
    if (SUCCEEDED(hRes))
        return WBEM_S_NO_ERROR;

    return WBEM_E_NOT_FOUND;
}


//***************************************************************************
//
//  CAssocQuery::AccessCheck
//
//  Does a security check on a static object to make sure that the user
//  should see it.
//
//  If the object is in the current namespace anyway, we short-circuit
//  and allow it without a lot of hassle. The guy is obviously one of us
//  and should be allowed to proceed unhindered. In those weird cases where
//  the object was from a foreign namespace, we have to play INS and check
//  on him.
//
//***************************************************************************

HRESULT CAssocQuery::AccessCheck(
    IWbemClassObject *pSrc
    )
{
    if (pSrc == 0)
        return WBEM_E_INVALID_PARAMETER;

    CWbemObject *pObj = (CWbemObject *) pSrc;

    // Easy case is 9x box where user is cleared for everything
    // ========================================================

    if((m_pNs->GetSecurityFlags() & SecFlagWin9XLocal) != 0)
        return WBEM_S_NO_ERROR;

    // Short-circuit case: We get the __NAMESPACE and see if it
    // the same as the NS in which we are executing the query.
    // ========================================================

    try // native interfaces throws
    {
        LPWSTR pszNamespace = m_pNs->GetName();

        CVar vNs, vServer;
        if (FAILED(pObj->GetProperty(L"__NAMESPACE" , &vNs)) ||vNs.IsNull())
            return WBEM_E_INVALID_OBJECT;
        if (FAILED(pObj->GetProperty(L"__SERVER", &vServer)) || vServer.IsNull())
            return WBEM_E_INVALID_OBJECT;

        // If server name and namespace are the same, we are already implicitly
        // allowed to see the object.
        // ====================================================================
        if (_wcsicmp(LPWSTR(vNs), pszNamespace) == 0 &&
            _wcsicmp(LPWSTR(vServer), ConfigMgr::GetMachineName()) == 0)
                return WBEM_S_NO_ERROR;
    }
    catch (CX_MemoryException &)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }    
    catch (CX_Exception &)
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    // If here, we have to do a real check.
    // ====================================

    HRESULT hRes = WBEM_S_NO_ERROR;

    try
    {
        BOOL bRet = TRUE;
        CVar vProp;
        if (FAILED(pObj->GetProperty(L"__Path" , &vProp)) || vProp.IsNull())
            return WBEM_E_INVALID_OBJECT;

        // Parse the object path to get the class involved.
        // ================================================

        CObjectPathParser p;
        ParsedObjectPath* pOutput = 0;

        int nStatus = p.Parse(vProp.GetLPWSTR(),  &pOutput);

        if (pOutput->IsLocal(ConfigMgr::GetMachineName()))
        {
            LPWSTR wszNewNamespace = pOutput->GetNamespacePart();
            CDeleteMe<WCHAR> dm1(wszNewNamespace);

            if (wszNewNamespace)  
            {
                if (wbem_wcsicmp(wszNewNamespace, m_pNs->GetName()))
                {
	                CWbemNamespace* pNewLocal = CWbemNamespace::CreateInstance();

	                if (pNewLocal)
	                {
						hRes = pNewLocal->Initialize(wszNewNamespace, m_pNs->GetUserName(),
	                                            0, 0, m_pNs->IsForClient(), TRUE,
	                                            m_pNs->GetClientMachine(), m_pNs->GetClientProcID(),
	                                            FALSE, NULL);
						if (SUCCEEDED(hRes))
						{
							DWORD dwAccess = pNewLocal->GetUserAccess();
							if ((dwAccess  & WBEM_ENABLE) == 0)
								hRes = WBEM_E_ACCESS_DENIED;;
						}
	                    pNewLocal->Release();
	                }
	                else
	                {
	                    hRes = WBEM_E_OUT_OF_MEMORY;
	                }
                }
            }
            else
            {
                hRes = WBEM_E_OUT_OF_MEMORY;
            }
        }
        p.Free(pOutput);
    }
    catch(...)
    {
        ExceptionCounter c;    
        hRes = WBEM_E_ACCESS_DENIED;
    }


    return hRes;
}









//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  END HELPER FUNCTIONS
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@





//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  BEGIN SINK CODE
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



//***************************************************************************
//
//  CAssocQuery::CreateSink
//
//  Creates a sink which is bound this the current query.
//
//***************************************************************************
//
CObjectSink *CAssocQuery::CreateSink(
    PF_FilterForwarder pfnFilter,
    BSTR strTrackingQuery
    )
{
    CAssocQE_Sink *p = new CAssocQE_Sink(this, pfnFilter, strTrackingQuery);
    if (!p)
        return NULL;

    p->AddRef();        // For the caller
    return p;
}


//***************************************************************************
//
//  CAssocQE_Sink::CAssocQE_Sink
//
//***************************************************************************
//
CAssocQE_Sink::CAssocQE_Sink(
    CAssocQuery *pQuery,
    PF_FilterForwarder pFilter,
    BSTR strTrackingQuery
    )
    : CObjectSink(0)    // Starting ref count
{
    m_pQuery = pQuery;
    m_pQuery->AddRef();
    m_pfnFilter = pFilter;
    m_lRef = 0;
    m_bQECanceled = FALSE;
    m_bOriginalOpCanceled = FALSE;
    InterlockedIncrement(&m_pQuery->m_lActiveSinks);
    if (strTrackingQuery)
        m_strQuery = SysAllocString(strTrackingQuery);

}

//***************************************************************************
//
//  CAssocQE_Sink::~CAssocQE_Sink
//
//***************************************************************************
// ok

CAssocQE_Sink::~CAssocQE_Sink()
{
    InterlockedDecrement(&m_pQuery->m_lActiveSinks);
    m_pQuery->SignalSinkDone();
    m_pQuery->Release();
    if (m_strQuery)
        SysFreeString(m_strQuery);
}

//***************************************************************************
//
//  CAssocQE_Sink::Indicate
//
//***************************************************************************
// ok

STDMETHODIMP CAssocQE_Sink::Indicate(
    IN long lNumObjects,
    IN IWbemClassObject** apObj
    )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    if (ConfigMgr::ShutdownInProgress())
        return WBEM_E_SHUTTING_DOWN;

    // Short-circuit a cancelled sink.
    // ===============================
    if (m_bQECanceled)
    {
        return hRes;
    }

    for (int i = 0; i < lNumObjects; i++)
    {
        IWbemClassObject *pCandidate = apObj[i];

        if (m_pfnFilter)
        {
            // Call the filter & forward function bound to this
            // sink instance.

            hRes = (m_pQuery->*m_pfnFilter)(pCandidate);

            // Check for out-and-out failure.
            // ==============================

            if (FAILED(hRes))
            {
                m_bQECanceled = TRUE;
                m_pQuery->Cancel();
                break;
            }

            // If we are simply cancelling this one sink due to efficiency
            // reasons, then tell just the provider to cancel, but not the
            // whole query.
            // ============================================================

            if (hRes == WBEM_S_OPERATION_CANCELLED)
            {
                m_bQECanceled = TRUE;
                hRes = WBEM_E_CALL_CANCELLED;
                break;
            }
        }
    }

    m_pQuery->UpdateTime();
    return hRes;
}

HRESULT CAssocQE_Sink::Add(IWbemClassObject* pObj)
{
    return Indicate(1, &pObj);
}

//***************************************************************************
//
//  CAssocQE_Sink::SetStatus
//
//***************************************************************************
//

STDMETHODIMP CAssocQE_Sink::SetStatus(
    long lFlags,
    long lParam,
    BSTR strParam,
    IWbemClassObject* pObjParam
    )
{
    m_pQuery->UpdateTime();
    m_pQuery->SignalSinkDone();

    if (FAILED(lParam))
    {
        // TBD report provider error; cancel query
    }
    return WBEM_S_NO_ERROR;
};





//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  END SINK CODE
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@





//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  BEGIN CLASSDEFSONLY CODE
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


//***************************************************************************
//
//  GetClassDefsOnlyClass
//
//  This takes an association instance, and looks up its class definition.
//  It looks up the parent-most class possible which is non-abstract
//  and instantiable.  This class is already in the master class list.
//
//  It then tags the roles on that class definition with IN or OUT depending
//  on which property actually references the endpoint and which ones do
//  not.
//
//  Second, it does 'hypothetical' tagging, where the OUT roles are each
//  given an independent pass to see if they *could* reference the
//  query endpoint, and the IN role is examined to see if it could
//  in turn reference the unknowns.
//
//  Returns
//  WBEM_E_INVALID_OBJECT if the association cannot point to
//  the endpoint in the current query.
//
//  WBEM_S_NO_ERROR is returned if IN/OUT tagging was properly
//  achieved.
//
//  WBEM_E_* on other conditions, which indicate drastic failure, such
//  as out-of-memory.
//
//***************************************************************************
//

HRESULT CAssocQuery::GetClassDefsOnlyClass(
    IN  IWbemClassObject *pExample,
    OUT IWbemClassObject **pClass
    )
{
    HRESULT hRes;

    if (!pExample || !pClass)
        return WBEM_E_INVALID_PARAMETER;

    *pClass = 0;

    try
    {
        // Get the class that we need.
        // ===========================

        IWbemClassObject *pCandidate = 0;
        hRes = FindParentmostClass(pExample, &pCandidate);
        if (FAILED(hRes))
            return hRes;

        CReleaseMe _(pCandidate);

        _variant_t vClassName;
        hRes = pCandidate->Get(L"__CLASS", 0, &vClassName, 0, 0);
        if (FAILED(hRes) || V_VT(&vClassName) != VT_BSTR)
            return WBEM_E_FAILED;

        // If the class has already been delivered, just quit now.
        // =======================================================

        for (int i = 0; i < m_aDeliveredClasses.Size(); i++)
        {
            if (_wcsicmp(m_aDeliveredClasses[i], V_BSTR(&vClassName)) == 0)
                return WBEM_S_NO_ERROR;
        }

        // If here, it's a new class.  Make a copy that we can modify
        // and send back to the user.
        // ==========================================================

        IWbemClassObject *pCopy = 0;
        hRes = pCandidate->Clone(&pCopy);
        if (FAILED(hRes))
            return hRes;

        hRes = ComputeInOutTags(pExample, pCopy);

        // Add the class name to the 'delivered' list.
        // ===========================================
        
        m_aDeliveredClasses.Add(V_BSTR(&vClassName));

        // Send it back.  The additional AddRef is because of the
        // CReleaseMe binding.
        // ======================================================
        pCandidate->AddRef();
        *pClass = pCopy;
    }
    catch (CX_MemoryException &) // WString throw
    {
        return WBEM_E_FAILED;
    }

    return WBEM_S_NO_ERROR;
}



//***************************************************************************
//
//  CAssocQuery::TagProp
//
//  Tags a property in an object with the named qualifier.  Used to
//  add IN or OUT to class definitions when executing CLASSDEFSONLY queries.
//
//***************************************************************************
//
HRESULT CAssocQuery::TagProp(
    IN IWbemClassObject *pObjToTag,
    IN LPCWSTR pszPropName,
    IN LPCWSTR pszInOutTag
    )
{
    IWbemQualifierSet *pQSet = 0;
    HRESULT hRes = pObjToTag->GetPropertyQualifierSet(pszPropName, &pQSet);
    if (FAILED(hRes))
        return hRes;
    CReleaseMe _1(pQSet);

    CVARIANT v;
    v.SetBool(TRUE);
    pQSet->Put(pszInOutTag, &v, 0);

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//  CAssocQuery::ComputeInOutTags
//
//  Computes the IN/OUT tags on a class using the specified association
//  instance.
//
//  Does not deliver the instance to the sink.
//
//***************************************************************************
// ok

HRESULT CAssocQuery::ComputeInOutTags(
    IN IWbemClassObject *pAssocInst,
    IN IWbemClassObject *pClass
    )
{
    HRESULT hRes;

    if (pAssocInst == 0 || pClass == 0)
        return WBEM_E_INVALID_PARAMETER;

    try
    {
        // Loop through the properties trying to find a legitimate
        // reference to our endpoint class.
        // =======================================================

        pAssocInst->BeginEnumeration(WBEM_FLAG_REFS_ONLY);
        while (1)
        {
            BSTR strPropName = 0;
            hRes = pAssocInst->Next(0,&strPropName,0,0,0);
            CSysFreeMe _1(strPropName);
            if (hRes == WBEM_S_NO_MORE_DATA)
                break;

            hRes = RoleTest(m_pEndpoint, pAssocInst, m_pNs, strPropName, ROLETEST_MODE_PATH_VALUE);
            if (SUCCEEDED(hRes))
            {
                TagProp(pClass, strPropName, L"IN");
            }
            else
                TagProp(pClass, strPropName, L"OUT");
        }   // Enum of ref properties

        pAssocInst->EndEnumeration();


        // Try to infer additional IN/OUT flows by examining the
        // class itself.   Some of these are only possible, rather
        // the definite.  Note that if more than one property
        // has IN flow, {P1=IN, P2=IN, P3=OUT } then by implication each
        // of P1 and P2 can also be OUT, since when one of (P1,P2) is IN
        // the other must be OUT unless there are two refecences to
        // the same object.  Obviously, this entire mechanism is weak
        // theoretically.  It is only there for the CIM Object Browser
        // to have some good idea that there are 'probably' instances
        // for that particular association.
        // =============================================================
        CWStringArray aClassInProps;
        hRes = CanClassRefQueryEp(FALSE, pClass, &aClassInProps);

        for (int i = 0; i < aClassInProps.Size(); i++)
        {
            TagProp(pClass, aClassInProps[i], L"IN");
            for (int i2 = 0; i2 < aClassInProps.Size(); i2++)
            {
                // Tag all the others as OUTs as well.
                if (_wcsicmp(aClassInProps[i2], aClassInProps[i]) != 0)
                {
                    TagProp(pClass, aClassInProps[i], L"OUT");
                }
            }
        }
    }
    catch (CX_MemoryException &) // WString throws
    {
        return WBEM_E_FAILED;
    }

    return WBEM_S_NO_ERROR;
}



//***************************************************************************
//
//  CAssocQuery::FindParentMostClass
//
//  Finds the parent-most class definition object which is still a 'real'
//  class, of the class name specified.  Given {A,B:A,C:B,D:C}, all of
//  which are instantiable, finds 'A' if 'D' is specified in the <pszClass>
//  parameter.
//
//  Note that the master class list only contains classes from the
//  dynamic portion of the database.  Thus, if the association is a static
//  type, we simply look up the first non-abstract class in the repository.
//
//***************************************************************************
//
HRESULT CAssocQuery::FindParentmostClass(
    IN  IWbemClassObject *pAssocInst,
    OUT IWbemClassObject **pClassDef
    )
{
    HRESULT hRes;
    int i;

    if (pAssocInst == 0 || pClassDef == 0)
        return WBEM_E_INVALID_PARAMETER;
    *pClassDef = 0;

    // Get the class hierarchy of the object.
    // ======================================
    CWStringArray aHierarchy;
    hRes = St_GetObjectInfo(
        pAssocInst,
        0, 0, 0,
        aHierarchy
        );

    if (FAILED(hRes))
        return hRes;

    IWbemClassObject *pTarget = 0;

    // Traverse the hierarchy, looking for the class def.
    // ==================================================

    for (i = aHierarchy.Size() - 1; i >= 0; i--)
    {
        for (int i2 = 0; i2 < m_aMaster.Size(); i2++)
        {
            IWbemClassObject *pObj = (IWbemClassObject *) m_aMaster[i2];
            CVARIANT vClassName;
            hRes = pObj->Get(L"__CLASS", 0, &vClassName, 0, 0);
            if (FAILED(hRes) || vClassName.GetType() != VT_BSTR)
                return WBEM_E_FAILED;

            if (_wcsicmp(aHierarchy[i], vClassName.GetStr()) == 0)
            {
                pTarget = pObj;
                break;
            }
        }
        if (pTarget)
            break;
    }

    // If the association class was non-dynamic, it won't have been located
    // by the above search.  Instead, we will go to the repository and
    // starting with the dynasty superclass, work down to the current class
    // until we find a non-abstract class.
    // ====================================================================

    if (pTarget == 0)
    {
        for (i = aHierarchy.Size() - 1; i >= 0; i--)
        {
            IWbemClassObject *pTest = 0;
            hRes = Db_GetClass(aHierarchy[i], &pTest);
            if (FAILED(hRes))
                break;
            hRes = St_ObjHasQualifier(L"ABSTRACT", pTest);
            if (SUCCEEDED(hRes))
            {
                pTest->Release();
                continue;
            }
            else    // This is what we want to send back
            {
                *pClassDef = pTest;
                return WBEM_S_NO_ERROR;
            }
        }
    }

    // Now, see if we found it.
    // ========================

    if (pTarget == 0)
        return WBEM_E_NOT_FOUND;

    pTarget->AddRef();
    *pClassDef = pTarget;
    return WBEM_S_NO_ERROR;
}








//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  END CLASSDEFSONLY CODE
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@





//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  BEGIN SCHEMA-ONLY SPECIFIC CODE
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

//***************************************************************************
//
//  CAssocQuery::SchemaQ_RefsFilter
//
//  Reduces the class set of a schemaonly 'references of' query by
//  cutting out anything specified in the filters.  The filters applied
//  are RESULTCLASS, REQUIREDQUALIFIER, and ROLE.
//
//  The size and content of <aSrc> is altered.  Objects not used
//  are Released().
//
//  Returns status in HRESULT, does not access the destination sink on error.
//
//***************************************************************************
// executions=1; no filtering though

HRESULT CAssocQuery::SchemaQ_RefsFilter(
    IN OUT CFlexArray &aSrc // IN: the unreduced class set, OUT the reduced one
    )
{
    HRESULT hRes;

    // Loop through the result set, looking for things to toss out.
    // ============================================================

    for (int i = 0; i < aSrc.Size(); i++)                   // x
    {
        BOOL bIsACandidate = TRUE;

        // Extract this class definition from the source array.
        // ====================================================

        IWbemClassObject *pCls = (IWbemClassObject *) aSrc[i];

        // Start testing.
        //
        // RESULTCLASS --the object must be of the specified
        // class or part of its hierarchy.
        // ==================================================

        LPCWSTR pszResultClass = m_pParser->GetResultClass();
        if (pszResultClass)
        {
            hRes = St_ObjIsOfClass(pszResultClass, pCls);
            if (FAILED(hRes))
            {
                aSrc[i] = 0;
                pCls->Release();
                hRes = 0;
                continue;
            }
        }

        // If here, there either isn't a RESULTCLASS test or we passed it.
        // Next, we try REQUIREDQUALIFIER.
        // ===============================================================

        LPCWSTR pszRequiredQual = m_pParser->GetRequiredQual();
        if (pszRequiredQual)
        {
            hRes = St_ObjHasQualifier(pszRequiredQual, pCls);
            if (FAILED(hRes))
            {
                aSrc[i] = 0;
                pCls->Release();
                hRes = 0;
                continue;
            }
        }


        // Next, we try ROLE.
        // ==================

        LPCWSTR pszRole = m_pParser->GetRole();          // x

        if (pszRole)
        {
             hRes = RoleTest(m_pEndpoint, pCls, m_pNs, pszRole, ROLETEST_MODE_CIMREF_TYPE);
             if (FAILED(hRes))
             {
                aSrc[i] = 0;
                pCls->Release();
                hRes = 0;
                continue;
             }
        }

    }

    aSrc.Compress();

    return WBEM_S_NO_ERROR;
}


//****************************************************************************
//
//  CAssocQuery::TerminateSchemaQuery
//
//  For schema queries, sends the final result objects to the destination
//  sink and shuts down the query.  At this point, all the objects are in
//  the result set array and ready to be delivered.
//
//****************************************************************************
// visual ok

HRESULT CAssocQuery::SchemaQ_Terminate(
    IN CFlexArray &aResultSet
    )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    aResultSet.Compress();  // Remove NULLs

    // Indicate everything.
    // ====================

    if (aResultSet.Size())
    {
        IWbemClassObject **p = (IWbemClassObject **) aResultSet.GetArrayPtr();
        hRes = m_pDestSink->Indicate(aResultSet.Size(), p);
        St_ReleaseArray(aResultSet);
    }

    return hRes;
}

//****************************************************************************
//
//  CAssocQuery::SchemaQ_RefsQuery
//
//  At this point we have the final list of classes. We now apply any
//  secondary filters and send the result back to the client.
//
//  (1) We apply all filters specified in the query.
//  (2) If CLASSDEFSONLY, we post filter yet again.
//  (3) Deliver to client
//
//****************************************************************************
// visual ok

HRESULT CAssocQuery::SchemaQ_RefsQuery(
    IN OUT CFlexArray &aResultSet
    )
{
    HRESULT hRes;

    // Apply various filters.
    // ======================

    hRes = SchemaQ_RefsFilter(aResultSet);
    if (FAILED(hRes))
        return hRes;

    return SchemaQ_Terminate(aResultSet);
}


//****************************************************************************
//
//  CAssocQuery::SchemaQ_AssocsQuery
//
//  At this point we have the list of association classes.  We apply
//  association-level filters, and then get the other endpoint classes,
//  filtering them in parallel.  The final result set is placed in
//  <aOtherEndpoints> and delivered to the user by the final call
//  to SchemaQ_Terminate.
//
//****************************************************************************
//  visual ok

HRESULT CAssocQuery::SchemaQ_AssocsQuery(
    IN CFlexArray &aAssocSet
    )
{
    HRESULT hRes;

    // Apply association filters.
    // ========================

    hRes = SchemaQ_AssocsFilter(aAssocSet);
    if (FAILED(hRes))
        return hRes;

    // Now, get the other endpoints.  We filter them
    // in parallel, due to the good locality of reference
    // in this case.
    // ==================================================

    CFlexArray aOtherEndpoints;

    hRes = SchemaQ_GetAndFilterOtherEndpoints(
        aAssocSet,
        aOtherEndpoints
        );

    St_ReleaseArray(aAssocSet); // Done with the associations themselves

    if (FAILED(hRes))
        return hRes;

    // Apply other-endpoint filters.
    // =============================

    return SchemaQ_Terminate(aOtherEndpoints);
}


//***************************************************************************
//
//  CAssocQuery::ConvertEpListToClassDefsOnly
//
//  Filters the endpoint list of instances and changes it into the minimal
//  set of class definitions.  Classes must be in the same namespace.
//
//***************************************************************************
//
HRESULT CAssocQuery::ConvertEpListToClassDefsOnly()
{
    CFlexArray aNew;
    HRESULT hRes;

    CInCritSec ics(&m_csCandidateEpAccess);

    for (int i = 0; i < m_aEpCandidates.Size(); i++)
    {
        BSTR strEpPath = (BSTR) m_aEpCandidates[i];
        if (strEpPath == 0)
            continue;

        BSTR strClassName = 0;
        hRes = St_ObjPathInfo(strEpPath, &strClassName, 0);
        if (FAILED(hRes))
        {
            hRes = 0;
            continue;
        }

        BOOL bFound = FALSE;

        // See if class is in our new destination array.
        // =============================================

        for (int i2 = 0; i2 < aNew.Size(); i2++)
        {
            BSTR strTest = (BSTR) aNew[i2];
            if (_wcsicmp(strClassName, strTest) == 0)
            {
                bFound = TRUE;
                break;
            }
        }

        if (bFound == TRUE)
            SysFreeString(strClassName);
        else
            aNew.Add(strClassName);
    }

    EmptyCandidateEpArray();

    for (i = 0; i < aNew.Size(); i++)
    {
        m_aEpCandidates.Add(aNew[i]);
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//  CAssocQuery::SchemaQ_AssocsFilter
//
//  Called during an 'associators of' query, this filters out the
//  classes which don't pass the test for the association classes
//  themselves.
//
//  Tests for ROLE and REQUIREDASSOCQUALIFIER.
//
//***************************************************************************
// ok

HRESULT CAssocQuery::SchemaQ_AssocsFilter(
    IN OUT CFlexArray &aSrc
    )
{
    HRESULT hRes;

    LPCWSTR pszRole = m_pParser->GetRole();
    LPCWSTR pszRequiredAssocQual = m_pParser->GetRequiredAssocQual();

    // If there are no filters anyway, short-circuit.
    // ==============================================

    if (pszRole == 0 && pszRequiredAssocQual == 0)
    {
        return WBEM_S_NO_ERROR;
    }

    // If here, some tests are required.
    // =================================

    for (int i = 0; i < aSrc.Size(); i++)
    {
        IWbemClassObject *pCls = (IWbemClassObject *) aSrc[i];

        // If ROLE is present, ensure query endpoint is referenced
        // by it.
        // =======================================================

        if (pszRole)
        {
             hRes = RoleTest(m_pEndpoint, pCls, m_pNs, pszRole, ROLETEST_MODE_CIMREF_TYPE);
             if (FAILED(hRes))
             {
                aSrc[i] = 0;
                pCls->Release();
                hRes = 0;
                continue;
             }
        }

        // If REQUIREDASSOCQUALIFIER was in the query,
        // ensure it is present.
        // ===========================================

        if (pszRequiredAssocQual)
        {
            hRes = St_ObjHasQualifier(pszRequiredAssocQual, pCls);
            if (FAILED(hRes))
            {
                aSrc[i] = 0;
                pCls->Release();
                hRes = 0;
                continue;
            }
        }
    }

    aSrc.Compress();

    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//  CAssocQuery::SchemaQ_GetAndFilterOtherEndpoints
//
//  Given the set of classes in <aAssocs>, get the other endpoint
//  classes.
//
//  The filtering is achieved in parallel, since we have locality
//  of reference between the association object and the endpoint.
//
//  Parameters:
//  <aAssocs>       The association classes.
//  <aEndpoints>    Receives the endpoint classes.
//
//  Result:
//  HRESULT         Does not access the destination sink.
//
//***************************************************************************
// ok

HRESULT CAssocQuery::SchemaQ_GetAndFilterOtherEndpoints(
    IN CFlexArray &aAssocs,
    OUT CFlexArray &aEndpoints
    )
{
    HRESULT hRes;

    for (int i = 0; i < aAssocs.Size(); i++)
    {
        IWbemClassObject *pAssoc = (IWbemClassObject *) aAssocs[i];
        IWbemClassObject *pEpClass = 0;

        // Find the property that references the other endpoint.
        // ====================================================

        BSTR strOtherEpName = 0;
        hRes = SchemaQ_GetOtherEpClassName(pAssoc, &strOtherEpName);
        if (FAILED(hRes))
            continue;

        CSysFreeMe _1(strOtherEpName);

        // If we failed to get a name we should continue.
        if ( S_OK != hRes )
        {
            hRes = 0;
            continue;
        }

        // Now, get that class.  The class comes back
        // property AddRef'ed. If we don't use it, then we
        // have to Release it.
        // ===============================================
        hRes = GetClassFromAnywhere(strOtherEpName, 0, &pEpClass);

        if (FAILED(hRes))
        {
            // WE have a dangling reference.
            // =============================
            ERRORTRACE((LOG_WBEMCORE, "Invalid path %S specified in an "
                "association class\n", strOtherEpName));
            EmptyObjectList(aEndpoints);
            return WBEM_E_INVALID_OBJECT_PATH;
        }

        //
        // If here, we have the endpoint class in <pEpClass>
        // and the associationclass in pAssoc.
        // Now, apply the filters, both to the association and the endpoint.
        //


        // RESULTCLASS
        // Verify that the class of the endpoint is this
        // or part of its hierarchy.
        // =============================================

        LPCWSTR pszResultClass = m_pParser->GetResultClass();
        if (pszResultClass)
        {
            hRes = St_ObjIsOfClass(pszResultClass, pEpClass);
            if (FAILED(hRes))
            {
                pEpClass->Release();
                hRes = 0;
                continue;
            }
        }

        // ROLE.
        // The association must point back to the endpoint
        // via this.
        // ================================================

        LPCWSTR pszRole = m_pParser->GetRole();
        if (pszRole)
        {
             hRes = RoleTest(m_pEndpoint, pAssoc, m_pNs, pszRole, ROLETEST_MODE_CIMREF_TYPE);
             if (FAILED(hRes))
             {
                pEpClass->Release();
                hRes = 0;
                continue;
             }
        }

        // RESULTROLE
        // The association must point to the other endpoint
        // via this property.
        // ================================================

        LPCWSTR pszResultRole = m_pParser->GetResultRole();
        if (pszResultRole)
        {
             hRes = RoleTest(pEpClass, pAssoc, m_pNs, pszResultRole, ROLETEST_MODE_CIMREF_TYPE);
             if (FAILED(hRes))
             {
                pEpClass->Release();
                hRes = 0;
                continue;
             }
        }

        // ASSOCCLASS
        // Verify that the class of the association is this.
        // =================================================

        LPCWSTR pszAssocClass = m_pParser->GetAssocClass();
        if (pszAssocClass)
        {
            hRes = St_ObjIsOfClass(pszAssocClass, pAssoc);
            if (FAILED(hRes))
            {
                pEpClass->Release();
                hRes = 0;
                continue;
            }
        }

        // REQUIREDQUALIFIER
        // Endpoint must have this qualifier.
        // ===================================

        LPCWSTR pszQual = m_pParser->GetRequiredQual();
        if (pszQual)
        {
            hRes = St_ObjHasQualifier(pszQual, pEpClass);
            if (FAILED(hRes))
            {
                pEpClass->Release();
                hRes = 0;
                continue;
            }
        }

        // REQUIREDASSOCQUALIFIER
        // Association object must have this qualifier.
        // ============================================

        LPCWSTR pszRequiredAssocQual = m_pParser->GetRequiredAssocQual();
        if (pszRequiredAssocQual)
        {
            hRes = St_ObjHasQualifier(pszRequiredAssocQual, pAssoc);
            if (FAILED(hRes))
            {
                pEpClass->Release();
                hRes = 0;
                continue;
            }
        }

        // If here, we passed the barrage of filtering
        // tests and can happily report that the class
        // is part of the result set.
        // ===========================================

        aEndpoints.Add(pEpClass);       // Add it
    }

    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//  CAssocQuery::SchemaQ_GetOtherEpClassName
//
//  Finds the property in the association which references the
//  'other endpoint' in the query.  This is achieved by locating
//  a property which *does* reference the endpoint and assuming that
//  any remaining property must reference the 'other endpoint'.
//  If both references can reach the query endpoint, then no
//  harm is done
//
//  This function assumes well-formed associations with two
//  references.
//
//  PARAMETERS:
//  <pAssoc>            The association class
//  <strOtherEpName>    Receives the name of the class of the 'other endpoint'
//
//  RESULT:
//  WBEM_S_NO_ERROR, WBEM_E_FAILED
//
//***************************************************************************
// ok

HRESULT CAssocQuery::SchemaQ_GetOtherEpClassName(
    IN IWbemClassObject *pAssocClass,
    OUT BSTR *strOtherEpName
    )
{
    HRESULT hRes = WBEM_E_FAILED;

    if (strOtherEpName == 0)
        return hRes;
    *strOtherEpName = 0;

    BOOL bStrict = (m_pParser->GetQueryType() & QUERY_TYPE_SCHEMA_ONLY) != 0;

    // Enumerate just the references.
    // ===============================

    hRes = pAssocClass->BeginEnumeration(WBEM_FLAG_REFS_ONLY);
    if (FAILED(hRes))
        return WBEM_E_FAILED;

    // Loop through the references.
    // ============================

    int nCount = 0;
    while (1)
    {
        CVARIANT vRefPath;
        BSTR strPropName = 0;
        BSTR strEpClass = 0;

        hRes = pAssocClass->Next(
            0,                  // Flags
            &strPropName,       // Name
            vRefPath,           // Value
            0,                  // CIM type (refs only already)
            0                   // Flavor
            );

        if (hRes == WBEM_S_NO_MORE_DATA)
            break;

        CSysFreeMe _1(strPropName);
        hRes = CanPropRefQueryEp(bStrict, strPropName, pAssocClass, &strEpClass);
        CSysFreeMe _2(strEpClass);

        if (FAILED(hRes) || nCount)
        {
            // If here on the second iteration or the first iteration
            // with a failure, we have found the 'other endpoint'.
            // ======================================================
            *strOtherEpName = SysAllocString(strEpClass);
            if (*strOtherEpName == 0)
                return WBEM_E_OUT_OF_MEMORY;
            hRes = WBEM_S_NO_ERROR;
            break;
        }
        else
            nCount++;
    }

    pAssocClass->EndEnumeration();

    return hRes;
}


//***************************************************************************
//
//  CAssocQuery::CanPropRefQueryEp
//
//  For class definitions, determines if the specified property in the
//  object can reference the query endpoint.   This works for both strongly
//  typed and CLASSREF typed properties.
//
//  PARAMETERS:
//  <pszPropName>       The property to test.  Must be a reference property.
//  <bStrict>           If TRUE, then the property must actually reference
//                      the class of the endpoint. If FALSE, it may reference
//                      any of the superclasses of the endpoint.
//  <pObj>              The association object with the property to be tested.
//  <strRefType>        Optionally receives the name of the class in the
//                      CIMTYPE "REF:Classname>" string, as long as
//                      the reference is strongly typed (does not work
//                      for CLASSREF types).
//
//  RETURNS:
//  HRESULT
//      WBEM_S_NO_ERROR if the property can reference the query endpoint.
//      WBEM_E_NOT_FOUND if the property cannot reference the query endpoint.
//      or
//      WBEM_E_INVALID_PARAMETER
//      WBEM_E_FAILED
//
//***************************************************************************
//

HRESULT CAssocQuery::CanPropRefQueryEp(
    IN BOOL bStrict,
    IN LPWSTR pszPropName,
    IN IWbemClassObject *pObj,
    OUT BSTR *strRefType
    )
{
    HRESULT hRes;
    wchar_t ClassName[MAX_CLASS_NAME];

    *ClassName = 0;

    if (pszPropName == 0 || pObj == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Get the qualifier set for this property.
    // ========================================

    IWbemQualifierSet *pQSet = 0;
    hRes = pObj->GetPropertyQualifierSet(pszPropName,&pQSet);
    if (FAILED(hRes))
        return WBEM_E_FAILED;
    CReleaseMe _1(pQSet);

    // Now get the CIMTYPE of this reference.
    // ======================================

    CVARIANT v;
    hRes = pQSet->Get(L"CIMTYPE", 0, &v, 0);
    if (FAILED(hRes) || V_VT(&v) != VT_BSTR)
        return WBEM_E_FAILED;

    BSTR strRefClass = V_BSTR(&v);
    if (wcslen(strRefClass) > MAX_CLASS_NAME)
        return WBEM_E_FAILED;
    if (strRefClass)
    {
        _wcsupr(strRefClass);
        swscanf(strRefClass, L"REF:%s", ClassName);
    }


    // Send a copy of the class name back to the
    // caller, if required.
    // =========================================

    if (strRefType)
    {
        *strRefType = 0;
        if (*ClassName)
        {
            *strRefType = SysAllocString(ClassName);
            if (*strRefType == 0)
                return WBEM_E_OUT_OF_MEMORY;
        }
    }

    // Now see if this class is any of the classes in our
    // query endpoint.
    // ==================================================

    if (*ClassName)
    {
        // If <bStrict> we must match the class name of the
        // query endpoint exactly.

        if (bStrict)
        {
            if (_wcsicmp(ClassName, m_bstrEndpointClass) == 0)
                return WBEM_S_NO_ERROR;
        }
        // Else, any of the superclasses of the endpoint will do.
        else
        {
           for (int i = 0; i < m_aEndpointHierarchy.Size(); i++)
           {
                if (_wcsicmp(ClassName, m_aEndpointHierarchy[i]) == 0)
                    return WBEM_S_NO_ERROR;
           }
        }
    }

    // If here, we can try to see if the property has a CLASSREF
    // qualifier instead.
    // =========================================================

    hRes = CanClassRefReachQueryEp(pQSet, bStrict);

    if (SUCCEEDED(hRes))
        return WBEM_S_NO_ERROR;

    // If here, the property doesn't reference the query
    // endpoint in any way.
    // =================================================

    return WBEM_E_NOT_FOUND;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  END SCHEMA-ONLY SPECIFIC CODE
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  BEGIN DYNAMIC CLASS HELPERS
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



//***************************************************************************
//
//  ClassNameTest
//
//  Sort helper
//
//***************************************************************************
//
static int ClassNameTest(
    IN CFlexArray &Classes,
    IN int nIndex1,                // iBackscan
    IN int nIndex2                 // iBackscan-nInterval
    )
{
    // Name test.
    // ==========
    IWbemClassObject *pC1 = (IWbemClassObject *) Classes[nIndex1];
    IWbemClassObject *pC2 = (IWbemClassObject *) Classes[nIndex2];

    CVARIANT v1, v2;
    pC1->Get(L"__CLASS", 0, &v1, 0, 0);
    pC2->Get(L"__CLASS", 0, &v2, 0, 0);

    return _wcsicmp(V_BSTR(&v1), V_BSTR(&v2));
}


//***************************************************************************
//
//  CAssocQuery::SortDynClasses
//
//  Sorts the dynamic classes so they can be binary searched later.
//
//***************************************************************************
//
void CAssocQuery::SortDynClasses()
{
    // Shell sort.
    // ===========
    int nSize = m_aDynClasses.Size();

    for (int nInterval = 1; nInterval < nSize / 9; nInterval = nInterval * 3 + 1);

    while (nInterval)
    {
        for (int iCursor = nInterval; iCursor < nSize; iCursor++)
        {
            int iBackscan = iCursor;

            while (iBackscan - nInterval >= 0
                   && ClassNameTest(m_aDynClasses, iBackscan, iBackscan-nInterval) < 0)
            {
                // Swap.
                // =====
                IWbemClassObject *pTmp = (IWbemClassObject *) m_aDynClasses[iBackscan - nInterval];
                m_aDynClasses[iBackscan - nInterval] = m_aDynClasses[iBackscan];
                m_aDynClasses[iBackscan] = pTmp;
                iBackscan -= nInterval;
            }
        }
        nInterval /= 3;
    }
}


//***************************************************************************
//
//  CAssocQuery::GetDynClasses
//
//  Fills the per-query cache with all available dynamic assoc classes.
//
//***************************************************************************
//
HRESULT CAssocQuery::GetDynClasses()
{

    CSynchronousSink* pDynClassSink = 0;
    HRESULT hRes = 0;

    // Now, get all dynamic classes.
    // =============================

    pDynClassSink = new CSynchronousSink;
    if (NULL == pDynClassSink)
        return WBEM_E_OUT_OF_MEMORY;
    pDynClassSink->AddRef();
    CReleaseMe _1(pDynClassSink);

    hRes = m_pNs->GetDynamicReferenceClasses( 0L, m_pContext, pDynClassSink );

    if (FAILED(hRes))
        return hRes;

	if ( SUCCEEDED( hRes ) )
	{
		pDynClassSink->Block();
		pDynClassSink->GetStatus(&hRes, NULL, NULL);
	}

    // Now get all the dynamic class definitions.
    // ==========================================

    CRefedPointerArray<IWbemClassObject>& raObjects =
        pDynClassSink->GetObjects();

    for (int i = 0; i < raObjects.GetSize(); i++)
    {
        IWbemClassObject *pClsDef = (IWbemClassObject *) raObjects[i];
        pClsDef->AddRef();
        m_aDynClasses.Add(pClsDef);
    }

    SortDynClasses();

    return WBEM_S_NO_ERROR;

}

//***************************************************************************
//
//  CAssocQuery::GetDynClass
//
//  Attempts to find the requested class in the dynamic class cache.
//
//***************************************************************************
//

HRESULT CAssocQuery::GetDynClass(
    IN  LPCWSTR pszClassName,
    OUT IWbemClassObject **pCls
    )
{
    if (pCls == 0 || pszClassName == 0)
        return WBEM_E_INVALID_PARAMETER;
    *pCls = 0;

    CFlexArray &a = m_aDynClasses;

    // Binary search the cache.
    // ========================

    int l = 0, u = a.Size() - 1;
    while (l <= u)
    {
        int m = (l + u) / 2;
        IWbemClassObject *pItem = (IWbemClassObject *) a[m];

        CVARIANT vClassName;
        pItem->Get(L"__CLASS", 0, &vClassName, 0, 0);
        int nRes = _wcsicmp(pszClassName, V_BSTR(&vClassName));

        if (nRes < 0)
            u = m - 1;
        else if (nRes > 0)
            l = m + 1;
        else
        {
            pItem->AddRef();
            *pCls = pItem;
            return WBEM_S_NO_ERROR;
        }
    }

    return WBEM_E_NOT_FOUND;
}



//***************************************************************************
//
//  GetClassDynasty
//
//  Gets all the classes in a dynasty.  The returned array has a
//  set of IWbemClassObject pointers that need releasing.
//
//***************************************************************************
//
HRESULT CAssocQuery::GetClassDynasty(
    IN LPCWSTR pszClass,
    OUT CFlexArray &aDynasty
    )
{
    HRESULT hRes;
    CSynchronousSink* pClassSink = 0;

    pClassSink = new CSynchronousSink;
    if (NULL == pClassSink)
        return WBEM_E_OUT_OF_MEMORY;    
    pClassSink->AddRef();
    CReleaseMe _1(pClassSink);

    hRes = m_pNs->Exec_CreateClassEnum(
        LPWSTR(pszClass),
        WBEM_FLAG_DEEP,
        m_pContext,
        pClassSink
        );

    if (FAILED(hRes))
        return WBEM_E_CRITICAL_ERROR;

    pClassSink->GetStatus(&hRes, NULL, NULL);

    CRefedPointerArray<IWbemClassObject>& raObjects = pClassSink->GetObjects();

    for (int i = 0; i < raObjects.GetSize(); i++)
    {
        IWbemClassObject *pClsDef = (IWbemClassObject *) raObjects[i];
        pClsDef->AddRef();
        aDynasty.Add(pClsDef);
    }

    return WBEM_S_NO_ERROR;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  END DYNAMIC CLASS HELPERS
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@




//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  BEGIN DEBUG HELP
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


CCritSec g_TraceCS;
BOOL bTraceInit = FALSE;

int _Trace(char *pFile, const char *fmt, ...)
{
    CInCritSec ics(&g_TraceCS);
    char *buffer = new char[2048];

    if (buffer == 0)
    {
        return 0;
    }

    va_list argptr;
    int cnt;
    va_start(argptr, fmt);
    cnt = _vsnprintf(buffer, 2047, fmt, argptr);
    va_end(argptr);

    FILE *f = fopen(pFile, "at");
	if (f)
	{
		fprintf(f, "%s", buffer);
		fclose(f);
	}
	else
		cnt = 0;

    delete [] buffer;

    return cnt;
}



//****************************************************************************
//
//  ClassListDump
//
//****************************************************************************
//
HRESULT ClassListDump(
    IN LPWSTR pszTitle,
    CFlexArray &aClasses
    )
{
    _Trace("c:\\temp\\assocqe.log", "--- BEGIN %S\n", pszTitle);
    for (int i = 0; i < aClasses.Size(); i++)
    {
        IWbemClassObject *pClass = (IWbemClassObject *) aClasses[i];

        CVARIANT v;
        pClass->Get(L"__CLASS", 0, &v, 0, 0);
        _Trace("c:\\temp\\assocqe.log", "   %S\n", V_BSTR(&v));
    }

    _Trace("c:\\temp\\assocqe.log", "---END %S\n", pszTitle);
    return 0;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  END DEBUG HELP
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

// eof

/*
extern LONG g_lTotalSinks;
extern LONG g_lTotalProviderSinks;
extern LONG g_lTotalWrapperSinks;
extern LONG g_lTotalDecoratingSinks;
extern LONG g_lTotalFilterSinks;
*/

void ObjectTracking_Dump();

#pragma warning(push)
#pragma warning(disable:4715)       // not all control paths return due to loop
DWORD WINAPI DiagnosticThread(LPVOID)
{
    for (;;)
    {
        Sleep(10000);
/*
        extern LONG g_lTotalProviderSinks;
        extern LONG g_lTotalWrapperSinks;
        _Trace("c:\\temp\\sink.log", "CIMOM sinks = %d\n", g_lTotalSinks);
        _Trace("c:\\temp\\sink.log", "Provider Sinks = %d\n", g_lTotalProviderSinks);
        _Trace("c:\\temp\\sink.log", "Wrapper Sinks = %d\n", g_lTotalWrapperSinks);
        _Trace("c:\\temp\\sink.log", "Decorating Sinks = %d\n", g_lTotalDecoratingSinks);
        _Trace("c:\\temp\\sink.log", "Filter Sinks = %d\n", g_lTotalFilterSinks);
*/
    }

    return 0;
}
#pragma warning(pop)

void DiagnosticThread()
{
    static BOOL bThread = FALSE;

    if (!bThread)
    {
        bThread = TRUE;
        DWORD dwId;

        HANDLE hThread = CreateThread(
            0,                     // Security
            0,
            DiagnosticThread,          // Thread proc address
            0,                   // Thread parm
            0,                     // Flags
            &dwId
            );

        if (hThread == NULL)
            return;
        CloseHandle(hThread);
    }
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\callres.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    CALLRES.H

Abstract:

    Call Result Class

History:

--*/

#ifndef __CALL_RESULT__H_
#define __CALL_RESULT__H_

class CCallResult : public IWbemCallResultEx
{
protected:
    long m_lRef;

    IWbemClassObject* m_pResObj;
    HRESULT m_hres;
    BSTR m_strResult;
    IWbemServices* m_pResNamespace;
    IWbemClassObject* m_pErrorObj;

    BOOL m_bReady;
    HANDLE m_hReady;
    IWbemClassObject** m_ppResObjDest;
    CRITICAL_SECTION m_cs;
    CDerivedObjectSecurity m_Security;

    void Enter() {EnterCriticalSection(&m_cs);}
    void Leave() {LeaveCriticalSection(&m_cs);}

protected:
    class CResultSink : public CBasicObjectSink
    {
        CCallResult* m_pOwner;
    public:

        STDMETHOD_(ULONG, AddRef)() {return m_pOwner->AddRef();}
        STDMETHOD_(ULONG, Release)() {return m_pOwner->Release();}

        STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** aObjects);
        STDMETHOD(SetStatus)(long lFlags, HRESULT hres, BSTR strParam,
            IWbemClassObject* pErrorObj);

    public:
        CResultSink(CCallResult* pOwner) : m_pOwner(pOwner){}
    } m_XSink;
    friend CResultSink;

public:
    STDMETHOD_(ULONG, AddRef)() {return InterlockedIncrement(&m_lRef);}
    STDMETHOD_(ULONG, Release)()
    {
        long lRef = InterlockedDecrement(&m_lRef);
        if(lRef == 0)
            delete this;
        return lRef;
    }
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);

    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
    {return E_NOTIMPL;}
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
    {return E_NOTIMPL;}
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR** rgszNames, UINT cNames,
      LCID lcid, DISPID* rgdispid)
    {return E_NOTIMPL;}
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
      DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
      UINT* puArgErr)
    {return E_NOTIMPL;}

    STDMETHOD(GetResultObject)(long lTimeout, IWbemClassObject** ppObj);
    STDMETHOD(GetResultString)(long lTimeout, BSTR* pstr);
    STDMETHOD(GetCallStatus)(long lTimeout, long* plStatus);
    STDMETHOD(GetResultServices)(long lTimeout, IWbemServices** ppServices);


    virtual HRESULT STDMETHODCALLTYPE GetResult(
            /* [in] */ long lTimeout,
            /* [in] */ long lFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvResult
            );


    HRESULT Indicate(long lNumObjects, IWbemClassObject** aObjects);
    HRESULT SetStatus(HRESULT hres, BSTR strParam, IWbemClassObject* pErrorObj);
public:
    CCallResult(IWbemClassObject** ppResObjDest = NULL);

    CCallResult(IWbemClassObject* pResObj, HRESULT hres,
                IWbemClassObject* pErrorObj);
    ~CCallResult();

    INTERNAL CBasicObjectSink* GetSink() {return &m_XSink;}
    void SetResultString(LPWSTR wszRes);
    void SetResultServices(IWbemServices* pRes);
    HRESULT SetResultObject(IWbemClassObject* pRes);
    void SetErrorInfo();
};



#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\cfgmgr.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    CFGMGR.CPP

Abstract:

  This file implements the WinMgmt configuration manager class.

  See cfgmgr.h for documentation.

  Classes implemented:
      ConfigMgr      configuration manager

History:

    09-Jul-96   raymcc    Created.
    3/10/97     levn      Fully documented (ha, ha)


--*/


#include "precomp.h"

#define OBJECT_BLOB_CRC

#include <stdio.h>
#include <wbemcore.h>
#include <decor.h>
#include "PersistCfg.h"
#include <sleeper.h>
#include <genutils.h>
#include <TCHAR.H>
#include <oahelp.inl>
#include <wmiarbitrator.h>
#include <comdef.h>

#define CONFIG_DEFAULT_START_DB_SIZE                200000
#define CONFIG_DEFAULT_MAX_DB_SIZE                  0
#define CONFIG_DEFAULT_DB_GROW_BY                   65536
#define CONFIG_DEFAULT_BACKUP_INTERVAL_THRESHOLD    30
#define CONFIG_DEFAULT_QUEUE_SIZE                   1

#define CONFIG_DEFAULT_MAX_ENUM_CACHE_SIZE          0
#define CONFIG_DEFAULT_MAX_ENUM_OVERFLOW            0x20000

#define DEFAULT_SHUTDOWN_TIMEOUT                    10000

#ifdef _WIN64
#pragma message("WIN64 QUOTA")
#define CONFIG_MAX_COMMITTED_MEMORY                 300000000
#else
#pragma message("WIN32 QUOTA")
#define CONFIG_MAX_COMMITTED_MEMORY                 150000000       // 100 meg
#endif


extern LPTSTR g_pWorkDir;
extern LPTSTR g_pDbDir;
extern BOOL g_bDebugBreak;
extern BOOL g_bLogging;
extern LPTSTR g_szHotMofDirectory;
extern DWORD g_dwQueueSize;
extern BOOL g_bDontAllowNewConnections;

//*********************************************************************************
//
//*********************************************************************************

LONG ExceptionCounter::s_Count = 0;

static _IWmiESS *g_pESS = 0;
static _IWmiProvSS *g_pProvSS = 0;

static HRESULT InitSubsystems();
static HRESULT InitESS(_IWmiCoreServices *pSvc, BOOL bAutoRecoverd);
static HRESULT ShutdownESS();
static HRESULT ShutdownSubsystems(BOOL bIsSystemShutDown);


BOOL ConfigMgr::ShutdownInProgress() { return g_bDontAllowNewConnections; }

DWORD g_dwMaxEnumCacheSize = CONFIG_DEFAULT_MAX_ENUM_CACHE_SIZE;
DWORD g_dwMaxEnumOverflowSize = CONFIG_DEFAULT_MAX_ENUM_OVERFLOW;

HANDLE g_hMutex = NULL;
HANDLE g_hOpenForClients = NULL;
HRESULT g_hresForClients = WBEM_E_CRITICAL_ERROR;

CAsyncServiceQueue* g_pAsyncSvcQueue = NULL;
extern IWbemEventSubsystem_m4* g_pEss_m4;
CEventLog* g_pEventLog = NULL;

extern IClassFactory* g_pContextFac;
extern IClassFactory* g_pPathFac;
CCritSec ConfigMgr::g_csEss;

DWORD g_dwBackupInterval = 30;

CPersistentConfig g_persistConfig;
CRegistryMinMaxLimitControl* g_pLimitControl = NULL;

extern bool g_bDefaultMofLoadingNeeded;

_IWmiCoreWriteHook * g_pRAHook = NULL;


//*********************************************************************************
//
//*********************************************************************************



class CCoreTimerGenerator : public CTimerGenerator
{
protected:
    void virtual NotifyStartingThread()
    {
        gClientCounter.LockCore(TIMERTHREAD);
    }

    void virtual NotifyStoppingThread()
    {
        gClientCounter.UnlockCore(TIMERTHREAD);
    }
};

CCoreTimerGenerator* g_pTimerGenerator = NULL;

void ConfigMgr::FatalInitializationError(DWORD dwRes)
{
    // If there are any clients waiting to get in, this must be set or else they
    // will wait forever.  g_hresForClients should be set to error by default!

    SetEvent(g_hOpenForClients);

    ERRORTRACE((LOG_WBEMCORE, "Failure to initialize the repository (id = 0x%X)\n", dwRes));
    if (g_pEventLog == NULL)
        return;

    DWORD dwMsgId;
    WORD dwSeverity;
    if(dwRes == WBEM_E_ALREADY_EXISTS)
    {
        dwMsgId = WBEM_MC_MULTIPLE_NOT_SUPPORTED;
        dwSeverity = EVENTLOG_WARNING_TYPE;
    }
    else if(dwRes == WBEM_E_INITIALIZATION_FAILURE)
    {
        dwMsgId = WBEM_MC_FAILED_TO_INITIALIZE_REPOSITORY;
        dwSeverity = EVENTLOG_ERROR_TYPE;
    }
    else
    {
        dwMsgId = WBEM_MC_WBEM_CORE_FAILURE;
    }

    g_pEventLog->Report(EVENTLOG_ERROR_TYPE, dwMsgId);

}

//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************
HRESULT ConfigMgr::SetReady()
{
    HRESULT hRes;
    IWmiDbHandle *pNs = NULL;
    IWmiDbSession * pSess = NULL;

    DEBUGTRACE((LOG_WBEMCORE, "****************** WinMgmt Startup ******************\n"));

    // Initialize unloading instruction configuration
    // ==============================================

    hRes = CRepository::GetDefaultSession(&pSess);
    if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "System preperation: failed to get new session <0x%X>!\n", hRes));
		return hRes;
	}
	CReleaseMe rm0(pSess);

	//Deal with objects in root namespace...
	{
		hRes = CRepository::OpenEseNs(pSess,L"root", &pNs);
		if (FAILED(hRes))
		{
			ERRORTRACE((LOG_WBEMCORE, "System preperation: failed to open root namespace <0x%X>!\n", hRes));
			return hRes;
		}
		CReleaseMe rm1(pNs);

		hRes = ConfigMgr::SetIdentificationObject(pNs,pSess);
		if (FAILED(hRes))
		{
			ERRORTRACE((LOG_WBEMCORE, "System preperation: failed to set identification objects in root <0x%X>!\n", hRes));
			return hRes;
		}
	}

	{
		hRes = CRepository::OpenEseNs(pSess, L"root\\default", &pNs);
		if (FAILED(hRes))
		{
			ERRORTRACE((LOG_WBEMCORE, "System preperation: failed to open root\\default namespace <0x%X>!\n", hRes));
			return hRes;
		}
		CReleaseMe rm1(pNs);

		hRes = ConfigMgr::SetIdentificationObject(pNs,pSess);
		if (FAILED(hRes))
		{
			ERRORTRACE((LOG_WBEMCORE, "System preperation: failed to set identification objects in root\\default <0x%X>!\n", hRes));
			return hRes;
		}

		hRes = ConfigMgr::SetAdapStatusObject(pNs,pSess);
		if (FAILED(hRes))
		{
			ERRORTRACE((LOG_WBEMCORE, "System preperation: failed to set ADAP Status objects in root\\default <0x%X>!\n", hRes));
			return hRes;
		}
	}

    // Finish client preparations
    // ==========================

    hRes = PrepareForClients(0);
    if(FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "System preperation: Prepare for clients failed <0x%X>!\n", hRes));
        return hRes;
	}

    return WBEM_S_NO_ERROR;
}

//******************************************************************************
//
//  This routine checks if a string property has changed, and if it has, updates
//  it and setus a bool indicating that an update was done
//
//******************************************************************************

HRESULT PutValueIfDiff(CWbemObject * pObj, LPWSTR pwsValueName, LPWSTR pwsValue, bool &bDiff)
{
    if(pwsValue == NULL)
        return S_OK;
        
    VARIANT var;
    VariantInit(&var);
    HRESULT hr = pObj->Get(pwsValueName, 0, &var, NULL, NULL);
    CClearMe ccme(&var);
    if(SUCCEEDED(hr))
    {
        if(var.vt == VT_BSTR && var.bstrVal && !wbem_wcsicmp(var.bstrVal, pwsValue))
            return S_OK;
    }
    bDiff = true;
    BSTR bStr = SysAllocString(pwsValue);
    if (bStr)
    {
	    CVar v2(VT_BSTR,bStr,TRUE);
	    return pObj->SetPropValue(pwsValueName, &v2, CIM_STRING);
    }
    else
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
}


//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************
HRESULT ConfigMgr::SetIdentificationObject(
    IWmiDbHandle* pNs,
    IWmiDbSession * pSess
    )
{
    HRESULT hRes;

    // __CIMOMIdentification class
    try // CIdentificationClass can throw and internal fastprox interfaces
    {

            bool bDifferenceFound = false;
            IWbemClassObject * pInst = NULL;
            hRes = CRepository::GetObject(pSess, pNs, L"__CIMOMIdentification=@", 0,&pInst);
            if(pInst == NULL)
            {
                // Instance isnt there, create it.  Start by getting the class

                bDifferenceFound = true;
                IWbemClassObject * pClass = NULL;
                hRes = CRepository::GetObject(pSess, pNs, L"__CIMOMIdentification", 0,&pClass);
                if(pClass == NULL)
                {
                    // class also needs to be created

                    CIdentificationClass * pIdentificationClass = new CIdentificationClass;
		            if(pIdentificationClass == NULL)
			            return WBEM_E_OUT_OF_MEMORY;

	                CDeleteMe<CIdentificationClass> dm1(pIdentificationClass);
	
	                pIdentificationClass->Init();

	                IWbemClassObject *pObj = NULL;
	                hRes = pIdentificationClass->QueryInterface(IID_IWbemClassObject, (LPVOID *) &pObj);
	                if (FAILED(hRes))
	                    return hRes;
                    CReleaseMe rm3(pObj);
            	    hRes = CRepository::PutObject(pSess, pNs, IID_IWbemClassObject, pObj, WMIDB_DISABLE_EVENTS);
                    if(FAILED(hRes))
                        return hRes;
                    hRes = CRepository::GetObject(pSess, pNs, L"__CIMOMIdentification", 0,&pClass);
                    if(FAILED(hRes))
                        return hRes;
                }
                CReleaseMe rm0(pClass);
                hRes = pClass->SpawnInstance(0, &pInst);
                if(FAILED(hRes))
                    return hRes;
            }
            CReleaseMe rm(pInst);

            // We now have an instance.  Set the values

            CWbemObject * pObj = (CWbemObject *)pInst;

            WCHAR wTemp[MAX_PATH+1];
            BOOL bRet = ConfigMgr::GetDllVersion(__TEXT("wbemcore.dll"), __TEXT("ProductVersion"), wTemp, MAX_PATH);
            if(bRet)
            {
                HKEY hKey = 0;
                if (RegOpenKey(HKEY_LOCAL_MACHINE, __TEXT("software\\microsoft\\wbem\\cimom"), &hKey) != ERROR_SUCCESS)
                    return WBEM_E_FAILED;
                CRegCloseMe cm(hKey);


                // Get the properties.  Note if any changes were found.

                hRes = PutValueIfDiff(pObj, L"VersionUsedToCreateDB", wTemp, bDifferenceFound);
                if(FAILED(hRes))
                    return hRes;

                hRes = PutValueIfDiff(pObj, L"VersionCurrentlyRunning", wTemp, bDifferenceFound);
                if(FAILED(hRes))
                    return hRes;

                DWORD lSize = 2*(MAX_PATH+1);
                DWORD dwType;

                if(ERROR_SUCCESS != RegQueryValueExW(hKey, L"SetupDate",NULL, &dwType,(BYTE *)wTemp, &lSize))
                    return WBEM_E_FAILED;
                hRes = PutValueIfDiff(pObj, L"SetupDate", wTemp, bDifferenceFound);
                if(FAILED(hRes))
                    return hRes;

                lSize = 2*(MAX_PATH+1);
                if(ERROR_SUCCESS != RegQueryValueExW(hKey, L"SetupTime", NULL, &dwType, (BYTE *)wTemp, &lSize))
                    return WBEM_E_FAILED;
                hRes = PutValueIfDiff(pObj, L"SetupTime", wTemp, bDifferenceFound);
                if(FAILED(hRes))
                    return hRes;

                lSize = 2*(MAX_PATH+1);
                if(ERROR_SUCCESS != RegQueryValueExW(hKey, L"Working Directory", NULL, &dwType,
                                                                (BYTE *)wTemp, &lSize))
                    return WBEM_E_FAILED;
                hRes = PutValueIfDiff(pObj, L"WorkingDirectory", wTemp, bDifferenceFound);
                if(FAILED(hRes))
                    return hRes;

                if(bDifferenceFound)
	                hRes = CRepository::PutObject(pSess, pNs, IID_IWbemClassObject, pObj, WMIDB_DISABLE_EVENTS);
                else
                    hRes = S_OK;

            }
        else
            return WBEM_E_FAILED;

    } catch (CX_MemoryException &) {
        //
        hRes = WBEM_E_OUT_OF_MEMORY;
    }
    catch (CX_Exception &)
    {
        return WBEM_E_CRITICAL_ERROR;
    }    

    return hRes;
}


HRESULT ConfigMgr::SetAdapStatusObject(
    IWmiDbHandle*  pNs,
    IWmiDbSession* pSess
    )
{
    HRESULT hRes;

    // __AdapStatus class
    try // CAdapStatusClass can throw
    { 
        // if the object already exists, dont bother

        IWbemClassObject * pInst = NULL;
        HRESULT hr = CRepository::GetObject(pSess, pNs, L"__AdapStatus=@", 0,&pInst);
        if(SUCCEEDED(hr) && pInst)
        {
            pInst->Release();
            return S_OK;
        }

        CAdapStatusClass * pAdapStatusClass = new CAdapStatusClass;
		if(pAdapStatusClass == NULL)
			return WBEM_E_OUT_OF_MEMORY;
			
	    CDeleteMe<CAdapStatusClass> dm1(pAdapStatusClass);
	
	    pAdapStatusClass->Init();

		CAdapStatusInstance * pAdapStatusInstance = new CAdapStatusInstance;
	    if(pAdapStatusInstance == NULL)
			return WBEM_E_OUT_OF_MEMORY;

	    CDeleteMe<CAdapStatusInstance> dm2(pAdapStatusInstance);
		
		pAdapStatusInstance->Init(pAdapStatusClass);
		
	    IWbemClassObject *pObj = NULL;
	    hRes = pAdapStatusClass->QueryInterface(IID_IWbemClassObject, (LPVOID *) &pObj);
	    if (FAILED(hRes))
	        return hRes;
	    CReleaseMe rm1(pObj);
	
	    hRes = CRepository::PutObject(pSess, pNs, IID_IWbemClassObject, pObj, WMIDB_DISABLE_EVENTS);
	    if (FAILED(hRes))
	        return hRes;
	
	    IWbemClassObject *pObj2 = NULL;
	    hRes = pAdapStatusInstance->QueryInterface(IID_IWbemClassObject, (LPVOID *) &pObj2);
	    if (FAILED(hRes))
	        return hRes;
	    CReleaseMe rm2(pObj2);
	
	    hRes = CRepository::PutObject(pSess, pNs, IID_IWbemClassObject, pObj2, WMIDB_DISABLE_EVENTS);
	    if (FAILED(hRes))
	        return hRes;
	
    } catch (CX_MemoryException &) {
        //
        hRes = WBEM_E_OUT_OF_MEMORY;
    }
    catch (CX_Exception &)
    {
        return WBEM_E_CRITICAL_ERROR;
    }    

    return hRes;
}

//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************

IWbemEventSubsystem_m4* ConfigMgr::GetEssSink()
{
    CInCritSec ics(&g_csEss);
    if(g_pEss_m4)
        g_pEss_m4->AddRef();
    return g_pEss_m4;
}

//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************
IWbemContext* ConfigMgr::GetNewContext()
{
    HRESULT hres;
    if(g_pContextFac == NULL)
        return NULL;

    IWbemContext* pContext;
    hres = g_pContextFac->CreateInstance(NULL, IID_IWbemContext,
                                            (void**)&pContext);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_WBEMCORE,"CRITICAL ERROR: cannot create contexts: %X\n", hres));
        return NULL;
    }
    return pContext;
}

//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************

READONLY LPWSTR ConfigMgr::GetMachineName()
{
    static wchar_t ThisMachine[MAX_COMPUTERNAME_LENGTH+1];
    static BOOL bFirstCall = TRUE;

    if (bFirstCall)
    {
        wchar_t ThisMachineA[MAX_COMPUTERNAME_LENGTH+1];
        DWORD dwSize = sizeof(ThisMachineA)/sizeof(ThisMachineA[0]);
        GetComputerNameW(ThisMachineA, &dwSize);
        bFirstCall = FALSE;
        swprintf(ThisMachine, L"%s", ThisMachineA);
    }

    return ThisMachine;
}

//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************

CWbemQueue* ConfigMgr::GetUnRefedSvcQueue()
{
    return g_pAsyncSvcQueue;
}

//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************

CAsyncServiceQueue* ConfigMgr::GetAsyncSvcQueue()
{
    CInCritSec ics(&g_csEss);
    if(g_pAsyncSvcQueue)
        return NULL;
    g_pAsyncSvcQueue->AddRef();
    return g_pAsyncSvcQueue;
}

//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************

HRESULT ConfigMgr::EnqueueRequest(CAsyncReq * pRequest, HANDLE* phWhenDone)
{
    try
    {
        CAsyncServiceQueue* pTemp = 0;

        {
            CInCritSec ics(&g_csEss);
            if(g_pAsyncSvcQueue == NULL)
                return WBEM_E_SHUTTING_DOWN;
            pTemp = g_pAsyncSvcQueue;
            g_pAsyncSvcQueue->AddRef();
        }

        HRESULT hr = pTemp->Enqueue(pRequest, phWhenDone);
        pTemp->Release();
        return hr;
    }
    catch(CX_MemoryException &)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        ExceptionCounter c;    
        return WBEM_E_CRITICAL_ERROR;
    }
}

//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************

HRESULT ConfigMgr::EnqueueRequestAndWait(CAsyncReq * pRequest)
{
    try
    {
        CAsyncServiceQueue* pTemp = 0;

        {
            CInCritSec ics(&g_csEss);
            if(g_pAsyncSvcQueue == NULL)
                return WBEM_E_SHUTTING_DOWN;
            pTemp = g_pAsyncSvcQueue;
            g_pAsyncSvcQueue->AddRef();
        }

        HRESULT hr = pTemp->EnqueueAndWait(pRequest);
        pTemp->Release();
        return hr;
    }
    catch(CX_MemoryException &)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        ExceptionCounter c;    
        return WBEM_E_CRITICAL_ERROR;
    }
}
//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************

LPTSTR ConfigMgr::GetWorkingDir()
{
    return g_pWorkDir;
}

//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************
BOOL ConfigMgr::DebugBreak()
{
    return g_bDebugBreak;
}

//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************
BOOL ConfigMgr::LoggingEnabled()
{
    return g_bLogging;
}

//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************

//CProviderCache* ConfigMgr::GetProviderCache()
//{
//return g_pProvCache;
//}

//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************


LPTSTR ConfigMgr::GetDbDir()
{
    if (g_pDbDir == NULL)
    {
        if (g_pWorkDir == NULL)
        {
            Registry r1(WBEM_REG_WBEM);
            if (r1.GetStr(__TEXT("Installation Directory"), &g_pWorkDir))
            {
                g_pWorkDir = new TCHAR[MAX_PATH + 1 + lstrlen(__TEXT("\\WBEM"))];
                if (g_pWorkDir == 0)
                    return 0;
                GetSystemDirectory(g_pWorkDir, MAX_PATH + 1);
                lstrcat(g_pWorkDir, __TEXT("\\WBEM"));
            }
        }
        Registry r(WBEM_REG_WINMGMT);
        if (r.GetStr(__TEXT("Repository Directory"), &g_pDbDir))
        {
            g_pDbDir = new TCHAR [lstrlen(g_pWorkDir) + lstrlen(__TEXT("\\Repository")) +1];
            if (g_pDbDir == 0)
                return 0;
            wsprintf(g_pDbDir, __TEXT("%s\\REPOSITORY"), g_pWorkDir);

            r.SetStr(__TEXT("Repository Directory"), g_pDbDir);
        }
    }
    return g_pDbDir;
}


DWORD ConfigMgr::ReadBackupConfiguration()
{
    Registry r(WBEM_REG_WINMGMT);
    // Get the database backup intervals (in minutes)
    if (r.GetDWORDStr(__TEXT("Backup Interval Threshold"), &g_dwBackupInterval) == Registry::failed)
    {
        r.SetDWORDStr(__TEXT("Backup Interval Threshold"), CONFIG_DEFAULT_BACKUP_INTERVAL_THRESHOLD);
        g_dwBackupInterval = CONFIG_DEFAULT_BACKUP_INTERVAL_THRESHOLD;
    }

    return WBEM_NO_ERROR;
}
DWORD ConfigMgr::GetBackupInterval()
{
    return g_dwBackupInterval;
}

DWORD ConfigMgr::GetMaxMemoryQuota()
{
    static DWORD dwMaxMemQuota = CONFIG_MAX_COMMITTED_MEMORY;
    static BOOL bCalled = FALSE;

    if (!bCalled)
    {
        Registry r(WBEM_REG_WINMGMT);

        if (r.GetDWORD(__TEXT("Max Committed Memory Quota"), &dwMaxMemQuota) == Registry::failed)
            r.SetDWORD(__TEXT("Max Committed Memory Quota"), dwMaxMemQuota);

        bCalled = TRUE;
    }

    return dwMaxMemQuota;
}

DWORD ConfigMgr::GetMaxWaitBeforeDenial()
{
    //static DWORD dwMaxWaitBeforeDenial = 80000;
	static DWORD dwMaxWaitBeforeDenial = 5000;
    static BOOL bCalled = FALSE;

    if (!bCalled)
    {
        Registry r(WBEM_REG_WINMGMT);

        if (r.GetDWORD(__TEXT("Max Wait Before Denial"), &dwMaxWaitBeforeDenial) == Registry::failed)
            r.SetDWORD(__TEXT("Max Wait Before Denial"), dwMaxWaitBeforeDenial);

        bCalled = TRUE;
    }

    return dwMaxWaitBeforeDenial;
}


DWORD ConfigMgr::GetNewTaskResistance()
{
    static DWORD dwResistance = 10;
    static BOOL bCalled = FALSE;

    if (!bCalled)
    {
        Registry r(WBEM_REG_WINMGMT);

        if (r.GetDWORD(__TEXT("New Task Resistance Factor"), &dwResistance) == Registry::failed)
            r.SetDWORD(__TEXT("New Task Resistance Factor"), dwResistance);

        bCalled = TRUE;
    }

    return dwResistance;
}


DWORD ConfigMgr::GetUncheckedTaskCount()
{
    static DWORD dwUncheckedTaskCount = 50;
    static BOOL bCalled = FALSE;

    if (!bCalled)
    {
        Registry r(WBEM_REG_WINMGMT);

        if (r.GetDWORD(__TEXT("Unchecked Task Count"), &dwUncheckedTaskCount) == Registry::failed)
            r.SetDWORD(__TEXT("Unchecked Task Count"), dwUncheckedTaskCount);

        bCalled = TRUE;
    }

    return dwUncheckedTaskCount;
}

DWORD ConfigMgr::GetMaxTaskCount()
{
    static DWORD dwMaxTasks = 5000;
    static BOOL bCalled = FALSE;

    if (!bCalled)
    {
        Registry r(WBEM_REG_WINMGMT);

        if (r.GetDWORD(__TEXT("Max Tasks"), &dwMaxTasks) == Registry::failed)
            r.SetDWORD(__TEXT("Max Tasks"), dwMaxTasks);

        bCalled = TRUE;
    }

    if (dwMaxTasks < 5000)
        dwMaxTasks = 5000;

    return dwMaxTasks;
}

DWORD ConfigMgr::GetProviderDeliveryTimeout()
{
    static DWORD dwDeliveryTimeout = 600000;
    static BOOL bCalled = FALSE;

    if (!bCalled)
    {
        Registry r(WBEM_REG_WINMGMT);

        if (r.GetDWORD(__TEXT("Provider Delivery Timeout"), &dwDeliveryTimeout) == Registry::failed)
            r.SetDWORD(__TEXT("Provider Delivery Timeout"), dwDeliveryTimeout);

        bCalled = TRUE;
    }

    return dwDeliveryTimeout;
}

BOOL ConfigMgr::GetMergerThrottlingEnabled( void )
{
    static DWORD dwMergerThrottlingEnabled = TRUE;
    static BOOL bCalled = FALSE;

    if (!bCalled)
    {
        Registry r(WBEM_REG_WINMGMT);

		// We don't write this one out
        r.GetDWORD(__TEXT("Merger Throttling Enabled"), &dwMergerThrottlingEnabled);

        bCalled = TRUE;
    }

    return dwMergerThrottlingEnabled;

}

BOOL ConfigMgr::GetEnableQueryArbitration( void )
{
    static DWORD dwEnableQueryArbitration = TRUE;
    static BOOL bCalled = FALSE;

    if (!bCalled)
    {
        Registry r(WBEM_REG_WINMGMT);

		// We don't write this one out
        r.GetDWORD(__TEXT("Merger Query Arbitration Enabled"), &dwEnableQueryArbitration);

        bCalled = TRUE;
    }

    return dwEnableQueryArbitration;

}

BOOL ConfigMgr::GetMergerThresholdValues( DWORD* pdwThrottle, DWORD* pdwRelease, DWORD* pdwBatching )
{
    static DWORD dwMergerThrottleThreshold = 10;
    static DWORD dwMergerReleaseThreshold = 5;
	static DWORD dwBatchingThreshold = 131072;	// 128k
    static BOOL bCalled = FALSE;

    if (!bCalled)
    {
		// Temporrary stack variable to avboid thready synchronization issues
		DWORD	dwThrottle = 10;
		DWORD	dwRelease = 5;
		DWORD	dwBatching = 131072;

        Registry r(WBEM_REG_WINMGMT);

        if (r.GetDWORD(__TEXT("Merger Throttling Threshold"), &dwThrottle) == Registry::failed)
            r.SetDWORD(__TEXT("Merger Throttling Threshold"), dwThrottle);

        if (r.GetDWORD(__TEXT("Merger Release Threshold"), &dwRelease) == Registry::failed)
            r.SetDWORD(__TEXT("Merger Release Threshold"), dwRelease);

        if (r.GetDWORD(__TEXT("Merger Batching Threshold"), &dwBatching) == Registry::failed)
            r.SetDWORD(__TEXT("Merger Batching Threshold"), dwBatching);

		if ( dwThrottle < dwRelease )
		{
			// If the Throttling Threshold is < the Release Threshold, this is not
			// valid.  Spew something out into the errorlog and default to a release
			// which is 50% of the the throttle

			ERRORTRACE((LOG_WBEMCORE, "Throttling Threshold values invalid.  Release Threshold is greater than Throttle Threshold.  Defaulting to 50% of %d.\n", dwThrottle ));
			dwRelease = dwThrottle / 2;
		}

		dwMergerThrottleThreshold = dwThrottle;
		dwMergerReleaseThreshold = dwRelease;
		dwBatchingThreshold = dwBatching;

        bCalled = TRUE;
    }

	*pdwThrottle = dwMergerThrottleThreshold;
	*pdwRelease = dwMergerReleaseThreshold;
	*pdwBatching = dwBatchingThreshold;

    return bCalled;
}



/*
    * ==================================================================================================
	|
	| ULONG ConfigMgr::GetMinimumMemoryRequirements ( )
	| -------------------------------------------------
	| Returns minimum memory requirements for WMI. Currently defined as:
	| 
	| ARB_DEFAULT_SYSTEM_MINIMUM	0x1E8480	
	|
	| 2Mb
	| 
	|
	* ==================================================================================================
*/
#define ARB_DEFAULT_SYSTEM_MINIMUM			0x1E8480			// minimum is 2mb

ULONG ConfigMgr::GetMinimumMemoryRequirements ( )
{
	return ARB_DEFAULT_SYSTEM_MINIMUM ;
}




//	Defaults for arbitrator
#define ARB_DEFAULT_SYSTEM_HIGH			0x4c4b400			// System limits [80megs]
#define ARB_DEFAULT_SYSTEM_HIGH_FACTOR	50					// System limits [80megs] factor
#define ARB_DEFAULT_MAX_SLEEP_TIME		300000				// Default max sleep time for each task
#define ARB_DEFAULT_HIGH_THRESHOLD1		90					// High threshold 1
#define ARB_DEFAULT_HIGH_THRESHOLD1MULT 2					// High threshold 1 multiplier
#define ARB_DEFAULT_HIGH_THRESHOLD2		95					// High threshold 1
#define ARB_DEFAULT_HIGH_THRESHOLD2MULT 3					// High threshold 1 multiplier
#define ARB_DEFAULT_HIGH_THRESHOLD3		98					// High threshold 1
#define ARB_DEFAULT_HIGH_THRESHOLD3MULT 4					// High threshold 1 multiplier

BOOL ConfigMgr::GetArbitratorValues( DWORD* pdwEnabled, DWORD* pdwSystemHigh, DWORD* pdwMaxSleep,
								double* pdHighThreshold1, long* plMultiplier1, double* pdHighThreshold2,
								long* plMultiplier2, double* pdHighThreshold3, long* plMultiplier3 )
{

    static DWORD dwArbThrottlingEnabled = 1;
	static DWORD uArbSystemHigh = ARB_DEFAULT_SYSTEM_HIGH_FACTOR;
	static DWORD  dwArbMaxSleepTime = ARB_DEFAULT_MAX_SLEEP_TIME;
	static double dArbThreshold1 = ARB_DEFAULT_HIGH_THRESHOLD1 / (double) 100;
	static long  lArbThreshold1Mult = ARB_DEFAULT_HIGH_THRESHOLD1MULT;
	static double dArbThreshold2 = ARB_DEFAULT_HIGH_THRESHOLD2 / (double) 100;
	static long  lArbThreshold2Mult = ARB_DEFAULT_HIGH_THRESHOLD2MULT;
	static double dArbThreshold3 = ARB_DEFAULT_HIGH_THRESHOLD3 / (double) 100;
	static long  lArbThreshold3Mult = ARB_DEFAULT_HIGH_THRESHOLD3MULT;
    static BOOL bCalled = FALSE;

    if (!bCalled)
    {
		// Temporrary stack variable to avoid thread synchronization issues
		DWORD dwThrottlingEnabled = 1;
		DWORD uSystemHigh = ARB_DEFAULT_SYSTEM_HIGH_FACTOR;
		DWORD dwMaxSleepTime = ARB_DEFAULT_MAX_SLEEP_TIME;
		double dThreshold1 = ARB_DEFAULT_HIGH_THRESHOLD1 / (double) 100;
		DWORD dwThreshold1Mult = ARB_DEFAULT_HIGH_THRESHOLD1MULT;
		double dThreshold2 = ARB_DEFAULT_HIGH_THRESHOLD2 / (double) 100;
		DWORD dwThreshold2Mult = ARB_DEFAULT_HIGH_THRESHOLD2MULT;
		double dThreshold3 = ARB_DEFAULT_HIGH_THRESHOLD3 / (double) 100;
		DWORD dwThreshold3Mult = ARB_DEFAULT_HIGH_THRESHOLD3MULT;

        Registry r(WBEM_REG_WINMGMT);

		// Throttling Enabled - Don't write this if it doesn't exist
        r.GetDWORD(__TEXT("ArbThrottlingEnabled"), &dwThrottlingEnabled);

		// System High Max Limit
        if (r.GetDWORD(__TEXT("ArbSystemHighMaxLimitFactor"), &uSystemHigh) == Registry::failed)
            //r.SetDWORD(__TEXT("ArbSystemHighMaxLimitFactor"), uSystemHigh);

		// Max Sleep Time
        if (r.GetDWORD(__TEXT("ArbTaskMaxSleep"), &dwMaxSleepTime) == Registry::failed)
            r.SetDWORD(__TEXT("ArbTaskMaxSleep"), dwMaxSleepTime);

		// High Threshold 1
		DWORD	dwTmp = ARB_DEFAULT_HIGH_THRESHOLD1;

        if (r.GetDWORD(__TEXT("ArbSystemHighThreshold1"), &dwTmp) == Registry::failed)
            r.SetDWORD(__TEXT("ArbSystemHighThreshold1"), dwTmp);
		dThreshold1 = dwTmp / (double) 100;

		// High Threshold Multiplier 1
        if (r.GetDWORD(__TEXT("ArbSystemHighThreshold1Mult"), &dwThreshold1Mult) == Registry::failed)
            r.SetDWORD(__TEXT("ArbSystemHighThreshold1Mult"), dwThreshold1Mult);

		// High Threshold 2
		dwTmp = ARB_DEFAULT_HIGH_THRESHOLD2;

        if (r.GetDWORD(__TEXT("ArbSystemHighThreshold2"), &dwTmp) == Registry::failed)
            r.SetDWORD(__TEXT("ArbSystemHighThreshold2"), dwTmp);
		dThreshold2 = dwTmp / (double) 100;

		// High Threshold Multiplier 2
        if (r.GetDWORD(__TEXT("ArbSystemHighThreshold2Mult"), &dwThreshold2Mult) == Registry::failed)
            r.SetDWORD(__TEXT("ArbSystemHighThreshold2Mult"), dwThreshold2Mult);

		// High Threshold 3
		dwTmp = ARB_DEFAULT_HIGH_THRESHOLD3;

        if (r.GetDWORD(__TEXT("ArbSystemHighThreshold3"), &dwTmp) == Registry::failed)
            r.SetDWORD(__TEXT("ArbSystemHighThreshold3"), dwTmp);
		dThreshold3 = dwTmp / (double) 100;

		// High Threshold Multiplier 3
        if (r.GetDWORD(__TEXT("ArbSystemHighThreshold3Mult"), &dwThreshold3Mult) == Registry::failed)
            r.SetDWORD(__TEXT("ArbSystemHighThreshold3Mult"), dwThreshold3Mult);

		// Store the statics

		dwArbThrottlingEnabled = dwThrottlingEnabled;
		uArbSystemHigh = uSystemHigh;
		dwArbMaxSleepTime = dwMaxSleepTime;
		dArbThreshold1 = dThreshold1;
		lArbThreshold1Mult = dwThreshold1Mult;
		dArbThreshold2 = dThreshold2;
		lArbThreshold2Mult = dwThreshold2Mult;
		dArbThreshold3 = dThreshold3;
		lArbThreshold3Mult = dwThreshold3Mult;

		bCalled = TRUE;

	}

    *pdwEnabled = dwArbThrottlingEnabled;
	*pdwSystemHigh = uArbSystemHigh;
	*pdwMaxSleep = dwArbMaxSleepTime;
	*pdHighThreshold1 = dArbThreshold1;
	*plMultiplier1 = lArbThreshold1Mult;
	*pdHighThreshold2 = dArbThreshold2;
	*plMultiplier2 = lArbThreshold2Mult;
	*pdHighThreshold3 = dArbThreshold3;
	*plMultiplier3 = lArbThreshold3Mult;


	return bCalled;
}

BOOL ConfigMgr::GetEnableArbitratorDiagnosticThread( void )
{
    BOOL fArbDiagnosticThreadEnabled = FALSE;

    Registry r(WBEM_REG_WINMGMT);
    LPTSTR pPath = 0;
    if ( r.GetStr(__TEXT("Task Log File"), &pPath) == Registry::no_error )
	{
		fArbDiagnosticThreadEnabled = TRUE;
		delete [] pPath;
		pPath = NULL;
	}

	return fArbDiagnosticThreadEnabled;
}

LPTSTR ConfigMgr::GetHotMofDirectory()
{
    return g_szHotMofDirectory;
}

DWORD ConfigMgr::ReadEnumControlData( void )
{
    Registry r(WBEM_REG_WINMGMT);

    // If we get a non-zero value, this means we limit enum object data based on the
    // how full physical system memory is

    r.GetDWORDStr(__TEXT("High Threshold On Client Objects (B)"), &g_dwMaxEnumCacheSize );

    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//******************************************************************************
//
HRESULT ConfigMgr::GetDefaultRepDriverClsId(CLSID &clsid)
{
    Registry r(WBEM_REG_WINMGMT);
    TCHAR *pClsIdStr = 0;
    TCHAR *pJetClsId = __TEXT("{7998dc37-d3fe-487c-a60a-7701fcc70cc6}");
    HRESULT hRes;

    if (r.GetStr(__TEXT("Default Repository Driver"), &pClsIdStr))
    {
        // If here, default to Jet ESE for now.
        // =====================================
        r.SetStr(__TEXT("Default Repository Driver"), pJetClsId);
        hRes = CLSIDFromString(pJetClsId, &clsid);
        return hRes;
    }

    // If here, we actually retrieved one.
    // ===================================

    hRes = CLSIDFromString(pClsIdStr, &clsid);
    delete [] pClsIdStr;
    return hRes;
}



//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************
DWORD ConfigMgr::InitSystem()
{
    HRESULT hres;

    // This will initialize the global variable that controls enumerator
    // cache size
    ReadEnumControlData();

    g_pEventLog = new CEventLog;
    if (g_pEventLog == 0)
        return WBEM_E_OUT_OF_MEMORY;
    g_pEventLog->Open();

    // See if another copy is running.
    // ===============================

    DEBUGTRACE((LOG_WBEMCORE, "Created WINMGMT_ACTIVE mutex\n"));
    g_hMutex = CreateMutex(0, FALSE, __TEXT("WINMGMT_ACTIVE"));
    if (g_hMutex == NULL || GetLastError() == ERROR_ALREADY_EXISTS)
    {
        ERRORTRACE((LOG_WBEMCORE, "Mutex creation failed, or detected that the core is initialized multiple times: API returned 0x%X, "
            "GetLastError is %d\n", g_hMutex, GetLastError()));
        return WBEM_E_ALREADY_EXISTS;
    }

    g_hOpenForClients = CreateEvent(NULL, TRUE, FALSE, NULL);
    g_hresForClients = WBEM_E_CRITICAL_ERROR;

    // Init Arbitrator. Before the queue, since there is this dependecy now
    // ================
    _IWmiArbitrator * pTempArb = NULL;
    hres = CWmiArbitrator::Initialize(&pTempArb);
    CReleaseMe rmArb(pTempArb);
    if (FAILED(hres))
    {
	 ERRORTRACE((LOG_WBEMCORE, "Arbitrator initialization returned failure <0x%X>!\n", hres));
        return hres;
    }    

    // Create service queue objects
    // ============================
    g_pAsyncSvcQueue = new CAsyncServiceQueue(pTempArb);
    g_pTimerGenerator = new CCoreTimerGenerator;
    g_pLimitControl = new CRegistryMinMaxLimitControl(
        LOG_WBEMCORE, L"the number of objects held on clients' behalf",
        L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
        L"Low Threshold On Client Objects (B)",
        L"High Threshold On Client Objects (B)",
        L"Max Wait On Client Objects (ms)");

    if (g_pAsyncSvcQueue == NULL   ||
        g_pTimerGenerator  == NULL || 
        g_pLimitControl == NULL    ||
        !g_pAsyncSvcQueue->IsInit())
    {        
        return WBEM_E_OUT_OF_MEMORY;
    }

    g_pLimitControl->Reread();

    hres = CoGetClassObject(CLSID_WbemContext, CLSCTX_INPROC_SERVER,
                NULL, IID_IClassFactory, (void**)&g_pContextFac);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_WBEMCORE,"CRITICAL ERROR: cannot create contexts: %X\n", hres));
        return WBEM_E_CRITICAL_ERROR;
    }

    hres = CoGetClassObject(CLSID_WbemDefPath, CLSCTX_INPROC_SERVER,
                NULL, IID_IClassFactory, (void**)&g_pPathFac);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_WBEMCORE,"CRITICAL ERROR: cannot create paths: %X\n", hres));
        return WBEM_E_CRITICAL_ERROR;
    }

    //
    // Must lock it to keep fastprox in memory!
    //

    g_pContextFac->LockServer(TRUE);
    g_pPathFac->LockServer(TRUE);

    // Read registry and get system info.
    // ==================================

    DEBUGTRACE((LOG_WBEMCORE,"Reading config info from registry\n"));

    Registry r1(WBEM_REG_WBEM);
    Registry r(WBEM_REG_WINMGMT);
    if (r1.GetStr(__TEXT("Installation Directory"), &g_pWorkDir))
    {
        g_pWorkDir = new TCHAR[MAX_PATH + 1 + lstrlen(__TEXT("\\WBEM"))];
        if (NULL == g_pWorkDir)
            return WBEM_E_OUT_OF_MEMORY;
        GetSystemDirectory(g_pWorkDir, MAX_PATH + 1);
        lstrcat(g_pWorkDir, __TEXT("\\WBEM"));
    }

    if (r.GetStr(__TEXT("Repository Directory"), &g_pDbDir))
    {
        g_pDbDir = new TCHAR [lstrlen(g_pWorkDir) + lstrlen(__TEXT("\\Repository")) +1];
        if (NULL == g_pDbDir)
            return WBEM_E_OUT_OF_MEMORY;
        wsprintf(g_pDbDir, __TEXT("%s\\Repository"), g_pWorkDir);

        r.SetStr(__TEXT("Repository Directory"), g_pDbDir);
    }

    // Write build info to the registry.
    // =================================
#ifdef UNICODE
    TCHAR tchDateTime[30];
    wsprintf(tchDateTime, __TEXT("%S %S"), __DATE__, __TIME__);

#else
    TCHAR *tchDateTime = __DATE__ " " __TIME__;
#endif

    TCHAR * pCurrVal = NULL;
    int iRet = r.GetStr(__TEXT("Build"), &pCurrVal);
    if(iRet == Registry::failed || wbem_wcsicmp(pCurrVal, tchDateTime))
        r.SetStr(__TEXT("Build"),  tchDateTime );
    if(iRet == Registry::no_error)
        delete pCurrVal;

    // Check to see if debug breaks are enabled.
    // =========================================

    DWORD dwDebug = 0;
    r.GetDWORDStr(__TEXT("DebugBreak"), &dwDebug);
    g_bDebugBreak = dwDebug;

    // Check for logging.
    // ==================
    DWORD dwLogging = 0;
    if (r.GetDWORDStr(__TEXT("Logging"), &dwLogging) != 0)
        dwLogging = 1;
    g_bLogging = dwLogging;

    if (r1.GetStr(__TEXT("MOF Self-Install Directory"), &g_szHotMofDirectory) == Registry::failed)
    {
        g_szHotMofDirectory = new TCHAR [lstrlen(g_pWorkDir) + lstrlen(__TEXT("\\MOF")) +1];
        if (NULL == g_szHotMofDirectory)
            return WBEM_E_OUT_OF_MEMORY;
        wsprintf(g_szHotMofDirectory, __TEXT("%s\\MOF"), g_pWorkDir);

        r.SetStr(__TEXT("MOF Self-Install Directory"), g_szHotMofDirectory);
    }

    // Construct the path to the database.
    // ===================================

    WbemCreateDirectory(g_pDbDir);

    DEBUGTRACE((LOG_WBEMCORE,"Database location = <%s>\n", g_pDbDir));

    // Open/create the database.
    // =========================

    HRESULT hRes = InitSubsystems();
    if (FAILED(hRes))
        return hRes;

	// Reset directory and registry permissions
	// ========================================
	if (!SetDirRegSec())
        ERRORTRACE((LOG_WBEMCORE,"An error occurred while setting directory and registry permissions\n"));

    // Done.
    // =====

    return WBEM_NO_ERROR;
}

BOOL ConfigMgr::DoCleanShutdown()
{
    BOOL bRetVal = FALSE;
    DWORD dwVal = 0;
    Registry r(WBEM_REG_WINMGMT);
    if (r.GetDWORDStr(__TEXT("Force Clean Shutdown"), &dwVal) == Registry::no_error)
    {
        bRetVal = dwVal;
        DEBUGTRACE((LOG_WBEMCORE, "Registry entry is forcing a clean shutdown\n"));
    }
    return bRetVal;
}
//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************
DWORD ConfigMgr::Shutdown(BOOL bProcessShutdown, BOOL bIsSystemShutDown)
{
    g_bDontAllowNewConnections = TRUE;

    if (!bIsSystemShutDown)
        CWin32DefaultArena::WriteHeapHint();

    ShutdownSubsystems(bIsSystemShutDown);

    if (!bIsSystemShutDown)
    {
	    DEBUGTRACE((LOG_WBEMCORE, "ConfigMgr shutting down cleanly\n"));

	    if(g_pTimerGenerator)
	    {
	        g_pTimerGenerator->Shutdown();
	        delete g_pTimerGenerator;
	        g_pTimerGenerator = NULL;
	    }

	    if(g_pAsyncSvcQueue)
	    {
	        CInCritSec ics(&g_csEss);
	        g_pAsyncSvcQueue->Shutdown(bIsSystemShutDown);
	        g_pAsyncSvcQueue->Release();
	        g_pAsyncSvcQueue = NULL;
	    }

	    CUnloadInstruction::Clear();

	    if (g_pContextFac)
	    {
	        //
	        // Must unlock it to allow fastprox to go away
	        //

	        g_pContextFac->LockServer(FALSE);
	        g_pContextFac->Release();
	        g_pContextFac = NULL;
	    }
	    if (g_pPathFac)
	    {
	        //
	        // Must unlock it to allow fastprox to go away
	        //

	        g_pPathFac->LockServer(FALSE);
	        g_pPathFac->Release();
	        g_pPathFac = NULL;
	    }


	    if(g_pLimitControl)
	        delete g_pLimitControl;
	    g_pLimitControl = NULL;

	    if(g_hMutex)
	        CloseHandle(g_hMutex);
	    g_hMutex = NULL;

	    g_pEventLog->Close();
	    delete g_pEventLog;
	    g_pEventLog = NULL;

	    delete [] g_pDbDir;
	    g_pDbDir = NULL;

	    delete [] g_pWorkDir;
	    g_pWorkDir = NULL;

	    delete [] g_szHotMofDirectory;
	    g_szHotMofDirectory = NULL;

	    CloseHandle(g_hOpenForClients);
	    g_hOpenForClients = INVALID_HANDLE_VALUE;

    }

    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************
BOOL ConfigMgr::GetDllVersion(TCHAR * pDLLName, TCHAR * pResStringName,
                        WCHAR * pRes, DWORD dwResSize)
{
    // Extract Version informatio

    DWORD dwTemp, dwSize = MAX_PATH;
    TCHAR cName[MAX_PATH];
    BOOL bRet = FALSE;

	// rajeshr : Fix for Prefix Bug# 144470
	cName[0] = NULL;

    int iLen = 0;
    if(g_pWorkDir)
        iLen = wcslen(g_pWorkDir);
    iLen += wcslen(pDLLName) + 2;
    if(iLen > MAX_PATH)
        return FALSE;


    if(g_pWorkDir)
        lstrcpy(cName, g_pWorkDir);
    lstrcat(cName,__TEXT("\\"));
    lstrcat(cName, pDLLName);
    long lSize = GetFileVersionInfoSize(cName, &dwTemp);
    if(lSize < 1)
        return FALSE;

    TCHAR * pBlock = new TCHAR[lSize];
    if(pBlock != NULL)
    {
		CDeleteMe<TCHAR> dm(pBlock);
		try
		{
			bRet = GetFileVersionInfo(cName, NULL, lSize, pBlock);
			if(bRet)
			{
				TCHAR lpSubBlock[MAX_PATH];
				TCHAR * lpBuffer = NULL;
				UINT wBuffSize = MAX_PATH;
				short * piStuff;
				bRet = VerQueryValue(pBlock, __TEXT("\\VarFileInfo\\Translation") , (void**)&piStuff, &wBuffSize);
				if(bRet)
				{
					wsprintf(lpSubBlock,__TEXT("\\StringFileInfo\\%04x%04x\\%s"),piStuff[0], piStuff[1],__TEXT("ProductVersion"));
					bRet = VerQueryValue(pBlock, lpSubBlock, (void**)&lpBuffer, &wBuffSize);
				}
				if(bRet == FALSE)
				{
					// Try again in english
					wsprintf(lpSubBlock,__TEXT("\\StringFileInfo\\040904E4\\%s"),pResStringName);
					bRet = VerQueryValue(pBlock, lpSubBlock,(void**)&lpBuffer, &wBuffSize);
				}
				if(bRet)
#ifdef UNICODE
	                lstrcpy(pRes, lpBuffer);
#else
	                mbstowcs(pRes, lpBuffer, dwResSize);
#endif
			}
		}
		catch(...)
		{
            ExceptionCounter c;		
			return FALSE;
		}
    }
    return bRet;
}

//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************


CTimerGenerator* ConfigMgr::GetTimerGenerator()
{
    return g_pTimerGenerator;
}

CEventLog* ConfigMgr::GetEventLog()
{
    return g_pEventLog;
}

//***************************************************************************
//
//  LoadResourceStr
//
//  Loads a DBCS string from the resource string table and converts
//  it to an LPWSTR.  It must be done this way to work on both Windows 98
//  and Windows NT.
//
//  Parameters:
//  <dwId>          The string ID.
//
//  Return value:
//      A pointer to a string dynamically allocated by operator new.
//      Caller must delete the string when it is no longer required.
//      Returns NULL if string was not found.
//
//***************************************************************************
// ok
/*
LPWSTR ConfigMgr::LoadResourceStr(DWORD dwId)
{
    HMODULE hMod = GetModuleHandle(__TEXT("WBEMCORE.DLL"));

    if (hMod == 0)
        return 0;

    TCHAR AnsiStr[512];

    int nRes = LoadString(hMod, dwId, AnsiStr, 512);

    if (nRes == 0)
        return 0;

#ifdef UNICODE
    LPWSTR pWStr = new wchar_t[lstrlen(AnsiStr) + 1];
    lstrcpy(pWStr, AnsiStr);
#else
    LPWSTR pWStr = new wchar_t[strlen(AnsiStr) + 1];
    mbstowcs(pWStr, AnsiStr, strlen(AnsiStr) + 1);
#endif
    return pWStr;
}
*/

//***************************************************************************
//
//  GetPersistentCfgValue
//
//  Gets an item from persistent storage ($WINMGMT.cfg)
//
//***************************************************************************
BOOL ConfigMgr::GetPersistentCfgValue(DWORD dwOffset, DWORD &dwValue)
{
    return g_persistConfig.GetPersistentCfgValue(dwOffset, dwValue);
}

//***************************************************************************
//
//  GetPersistentCfgValue
//
//  Sets an item from persistent storage ($WinMgmt.cfg)
//
//***************************************************************************
BOOL ConfigMgr::SetPersistentCfgValue(DWORD dwOffset, DWORD dwValue)
{
    return g_persistConfig.SetPersistentCfgValue(dwOffset, dwValue);
}


//***************************************************************************
//
//  GetAutoRecoverMofsCleanDB
//
//  Retrieve a list of MOFs which need to be loaded when we have
//  have an empty database.  User needs to "delete []" the
//  returned string.  String is in a REG_MULTI_SZ format.
//
//***************************************************************************
TCHAR* ConfigMgr::GetAutoRecoverMofs(DWORD &dwSize)
{
    Registry r(WBEM_REG_WINMGMT);
    return r.GetMultiStr(__TEXT("Autorecover MOFs"), dwSize);
}

BOOL ConfigMgr::GetAutoRecoverDateTimeStamp(LARGE_INTEGER &liDateTimeStamp)
{
    Registry r(WBEM_REG_WINMGMT);
    TCHAR *pszTimestamp = NULL;
    if ((r.GetStr(__TEXT("Autorecover MOFs timestamp"), &pszTimestamp) == Registry::no_error) &&
        pszTimestamp)
    {
        liDateTimeStamp.QuadPart = _ttoi64(pszTimestamp);
        delete [] pszTimestamp;
        return TRUE;
    }
    return FALSE;
}
//***************************************************************************
//
//  GetDbArenaInfo
//
//  Retrieves information about the initial CIM.REP size statistics.
//
//***************************************************************************
BOOL ConfigMgr::GetDbArenaInfo(DWORD &dwStartSize)
{
    Registry r(WBEM_REG_WINMGMT);
    r.GetDWORDStr(__TEXT("Starting Db Size"), &dwStartSize);

    // If values are not set, find suitable defaults.
    // ==============================================
    if (dwStartSize == 0)
        dwStartSize = CONFIG_DEFAULT_START_DB_SIZE;

    return TRUE;
}

//***************************************************************************
//
//  PrepareForClients
//
//  Once the system is in the initialized state (SetReady has succeeded), this
//  function is called to prepare the system for real clients. This involves
//  pre-compiling the MOFs, etc.
//
//***************************************************************************
HRESULT ConfigMgr::PrepareForClients(long lFlags)
{

    ReadBackupConfiguration();
    ReadMaxQueueSize();
    g_hresForClients = WBEM_S_NO_ERROR;
    SetEvent(g_hOpenForClients);
    return g_hresForClients;
}

HRESULT ConfigMgr::WaitUntilClientReady()
{
    WaitForSingleObject(g_hOpenForClients, INFINITE);
    return g_hresForClients;
}

HRESULT ConfigMgr::AddCache()
{
    if(g_pLimitControl)
        return g_pLimitControl->AddMember();
    else
        return WBEM_S_NO_ERROR;
}

HRESULT ConfigMgr::RemoveCache()
{
    if(g_pLimitControl)
        return g_pLimitControl->RemoveMember();
    else
        return WBEM_S_NO_ERROR;
}

HRESULT ConfigMgr::AddToCache(DWORD dwSize, DWORD dwMemberSize, DWORD* pdwSleep)
{
    if(g_pLimitControl)
        return g_pLimitControl->Add(dwSize, dwMemberSize, pdwSleep);
    else
        return WBEM_S_NO_ERROR;
}

HRESULT ConfigMgr::RemoveFromCache(DWORD dwSize)
{
    if(g_pLimitControl)
        return g_pLimitControl->Remove(dwSize);
    else
        return WBEM_S_NO_ERROR;
}

void ConfigMgr::ReadMaxQueueSize()
{
    Registry r(WBEM_REG_WINMGMT);
    // Get the database backup intervals (in minutes)
    if (r.GetDWORDStr(__TEXT("Max Async Result Queue Size"), &g_dwQueueSize) == Registry::failed)
    {
        r.SetDWORDStr(__TEXT("Max Async Result Queue Size"), CONFIG_DEFAULT_QUEUE_SIZE);
        g_dwQueueSize = CONFIG_DEFAULT_QUEUE_SIZE;
    }
}

DWORD ConfigMgr::GetMaxQueueSize()
{
    return g_dwQueueSize;
}

#ifdef __MILLENNIUM_BUILD__

bool ConfigMgr::RepositoryUpgradeNeeded()
{
    Registry r(WBEM_REG_WINMGMT);

    DWORD dwNeedsInstall = 1;
    if (r.GetDWORDStr(__TEXT("RepositoryUpgradeRequired"), &dwNeedsInstall) == Registry::no_error)
        return true;
    else
        return false;
}

void ConfigMgr::ClearRepositoryUpgradeNeeded()
{
    Registry r(WBEM_REG_WINMGMT);
    r.DeleteValue(__TEXT("RepositoryUpgradeRequired"));
}

#endif /*__MILLENNIUM_BUILD__*/


//////////////////////////////////////////////////////////////////////////////////

IWbemPath *ConfigMgr::GetNewPath()
{
    HRESULT hres;
    if(g_pPathFac == NULL)
        return NULL;

    IWbemPath* pPath = NULL;
    hres = g_pPathFac->CreateInstance(NULL, IID_IWbemPath, (void**)&pPath);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_WBEMCORE,"CRITICAL ERROR: cannot create paths: %X\n", hres));
        return NULL;
    }
    return pPath;
}

//
//
// the Implementation of the Hook Class
//
/////////////////////////////////////////////////

CRAHooks::CRAHooks(_IWmiCoreServices *pSvc)
    :m_pSvc(pSvc),
    m_cRef(1)
{
    if (m_pSvc)
        m_pSvc->AddRef();
}

CRAHooks::~CRAHooks()
{
    if (m_pSvc)
        m_pSvc->Release();
}

STDMETHODIMP
CRAHooks::QueryInterface(REFIID riid, void ** ppv)
{
    if (!ppv)
        return E_POINTER;

    if (riid == IID_IUnknown ||
        riid == IID__IWmiCoreWriteHook)
    {
        *ppv = this;
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
};

ULONG STDMETHODCALLTYPE
CRAHooks::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG STDMETHODCALLTYPE
CRAHooks::Release()
{
    LONG lRet = InterlockedDecrement(&m_cRef);
    if (0 == lRet)
    {
        delete this;
        return 0;
    }
    return lRet;
}


STDMETHODIMP
CRAHooks::PostPut(long lFlags, HRESULT hApiResult,
                            IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace,
                            LPCWSTR wszClass, _IWmiObject* pNew,
                            _IWmiObject* pOld)
{
    //
    // Here we want to do something
    //
    HRESULT hRes = WBEM_S_NO_ERROR;

    if (SUCCEEDED(hApiResult))
    {
        if (0 == wbem_wcsicmp(GUARDED_NAMESPACE,wszNamespace))
        {
            BOOL bIsInDerivation = FALSE;

            if (WBEM_S_NO_ERROR == pNew->InheritsFrom(GUARDED_CLASS))
            {
                bIsInDerivation = TRUE;
            }

            //
            //  check qualifiers
            //
            if (bIsInDerivation)
            {
                HRESULT hRes1;
                IWbemQualifierSet * pQualSet = NULL;
                hRes1 = pNew->GetQualifierSet(&pQualSet);
                if (SUCCEEDED(hRes1))
                {
                    VARIANT Var;
                    VariantInit(&Var);
                    hRes1 = pQualSet->Get(GUARDED_HIPERF,0,&Var,NULL);
                    if (WBEM_S_NO_ERROR == hRes1 &&
                        (V_VT(&Var) == VT_BOOL) &&
                        (V_BOOL(&Var) == VARIANT_TRUE))
                    {
                        // variant does not own memory so far
                        hRes1 = pQualSet->Get(GUARDED_PERFCTR,0,&Var,NULL);
                        if (WBEM_E_NOT_FOUND == hRes1)
                        {
                            //
                            // here is our class that has been added
                            //
						    HMODULE hWmiSvc = GetModuleHandleW(WMISVC_DLL);
						    if (hWmiSvc)
						    {
						        DWORD (__stdcall * fnDredgeRA)(VOID * pVoid);
						        fnDredgeRA = (DWORD (__stdcall * )(VOID * pVoid))GetProcAddress(hWmiSvc,FUNCTION_DREDGERA);
						        if (fnDredgeRA)
						        {
						            fnDredgeRA(NULL);
						        }
						    }
						    else
						    {
						        // be nice towards winmgmt.exe and do not propagate errors
						    }
                        }
                    }
                    VariantClear(&Var);
                    pQualSet->Release();
                }
                else
                {
                    hRes = hRes1;  // class with no qualifier set is BAD, propagate
                }
            }
        }
    }

    return hRes;
}

STDMETHODIMP
CRAHooks::PreDelete(long lFlags, long lUserFlags,
                            IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace,
                            LPCWSTR wszClass)
{
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP
CRAHooks::PostDelete(long lFlags,
                            HRESULT hApiResult,
                            IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace,
                            LPCWSTR wszClass, _IWmiObject* pOld)
{
    return WBEM_S_NO_ERROR;
}


STDMETHODIMP
CRAHooks::PrePut(long lFlags, long lUserFlags,
                            IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace,
                            LPCWSTR wszClass, _IWmiObject* pCopy)
{
    return WBEM_S_NO_ERROR;
}

//
//
//   function for instaling the Hook
//
///////////////////////////////////////////////////////////

HRESULT InitRAHooks(_IWmiCoreServices *pSvc)
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    if (!g_pRAHook)
    {
        g_pRAHook = new CRAHooks(pSvc); // refcount is ONE
        if (g_pRAHook)
        {
            hRes = pSvc->RegisterWriteHook(WBEM_FLAG_CLASS_PUT,
                                           g_pRAHook);
        }
        else
        {
            hRes = WBEM_E_OUT_OF_MEMORY;
        }
    }

    return hRes;
}


//
//
//
//
///////////////////////////////////////////////////////////

HRESULT ShutdownRAHooks()
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    if (g_pRAHook)
    {
        _IWmiCoreServices *pSvc = ((CRAHooks *)g_pRAHook)->GetSvc();
        if (pSvc)
        {
            hRes = pSvc->UnregisterWriteHook(g_pRAHook);
        }
        g_pRAHook->Release();
        g_pRAHook = NULL;
    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//

bool IsNtSetupRunning()
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                    L"system\\Setup",
                    0, KEY_READ, &hKey);
    if(lRes)
        return false;

    DWORD dwSetupRunning;
    DWORD dwLen = sizeof(DWORD);
    lRes = RegQueryValueExW(hKey, L"SystemSetupInProgress", NULL, NULL,
                (LPBYTE)&dwSetupRunning, &dwLen);
    RegCloseKey(hKey);

    if(lRes == ERROR_SUCCESS && (dwSetupRunning == 1))
    {
        return true;
    }
    return false;
}

//***************************************************************************
//
//***************************************************************************

HRESULT InitESS(_IWmiCoreServices *pSvc, BOOL bAutoRecoverd)
{
    HRESULT hRes;

    // Check if event subsystem is enabled
    // ===================================

    Registry r(WBEM_REG_WINMGMT);

    DWORD dwEnabled = 1;
    r.GetDWORDStr(__TEXT("EnableEvents"), &dwEnabled);
    if (dwEnabled != 1 || IsNtSetupRunning())
        return WBEM_S_NO_ERROR;

    // If here, we have to bring events into the picture.
    // ===================================================

    hRes = CoCreateInstance(CLSID_WmiESS, NULL,
                        CLSCTX_INPROC_SERVER, IID__IWmiESS,
                        (void**) &g_pESS);

    if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Unable to load Event Subsystem: 0x%X\n", hRes));
        return hRes;
	}

    if(bAutoRecoverd)
        hRes = g_pESS->Initialize(WMIESS_INIT_REPOSITORY_RECOVERED, 0, pSvc);
    else
        hRes = g_pESS->Initialize(0, 0, pSvc);
    if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Unable to Initialize Event Subsystem: 0x%X\n", hRes));
        return hRes;
	}

    hRes = g_pESS->QueryInterface(IID_IWbemEventSubsystem_m4, (LPVOID *) &g_pEss_m4);
        if (FAILED(hRes))
            return hRes;

    if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Unable to QI for IID_IWbemEventSubsystem_m4: 0x%X\n", hRes));
        return hRes;
	}

    CCoreServices::SetEssPointers(g_pEss_m4, g_pESS);

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
//
static HRESULT ShutdownRepository(BOOL bIsSystemShutdown)
{
    HRESULT hRes = CRepository::Shutdown(bIsSystemShutdown);
    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//
static HRESULT ShutdownESS(BOOL bIsSystemShutDown)
{
    HRESULT hRes;

    if (g_pESS)
    {
        IWbemShutdown *pShutdown = 0;
        hRes = g_pESS->QueryInterface(IID_IWbemShutdown, (LPVOID *) & pShutdown);
        if (FAILED(hRes))
            return hRes;

        if (bIsSystemShutDown)
        {
            hRes = pShutdown->Shutdown(0, 0, 0);
        }
        else
        {
            hRes = pShutdown->Shutdown(0, DEFAULT_SHUTDOWN_TIMEOUT, 0);
        }
        if (FAILED(hRes))
            return hRes;

        if (g_pEss_m4)
            g_pEss_m4->Release();

        pShutdown->Release();
        g_pESS->Release();
		g_pESS = NULL;
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT InitProvSS(CCoreServices *pSvc)
{
    HRESULT hRes;

    hRes = pSvc->GetProviderSubsystem(0, &g_pProvSS);
    if (FAILED(hRes))
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
//
static HRESULT ShutdownProvSS()
{
    HRESULT hRes;

    if (g_pProvSS)
    {
        IWbemShutdown *pShutdown = 0;

        hRes = g_pProvSS->QueryInterface(IID_IWbemShutdown, (LPVOID *) & pShutdown);

        if (FAILED(hRes))
            return hRes;

        hRes = pShutdown->Shutdown(0, DEFAULT_SHUTDOWN_TIMEOUT, 0);
        if (FAILED(hRes))
            return hRes;

        pShutdown->Release();
        g_pProvSS->Release();
        g_pProvSS = NULL;
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
//
static HRESULT InitRepository(CCoreServices *pSvc)
{
    HRESULT hRes = CRepository::Init();
    return hRes;
}


//***************************************************************************
//
//***************************************************************************
static HRESULT InitCore(CCoreServices *pSvc)
{
    return WBEM_S_NO_ERROR;
}

static HRESULT ShutdownCore()
{
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//  This determines if a previous autorecovery attempt was aborted
//
//***************************************************************************

bool AutoRecoveryWasInterrupted()
{
    DWORD dwValue;
    Registry r(WBEM_REG_WINMGMT);
    if (Registry::no_error == r.GetDWORD(__TEXT("NextAutoRecoverFile"), &dwValue))
        if(dwValue != 0xffffffff)
            return true;
    return false;
}

//***************************************************************************
//
//  Subsystem control
//
//***************************************************************************

HRESULT InitSubsystems()
{
    HRESULT hRes;
    BOOL bAutoRecovered = FALSE;

    CCoreServices::Initialize();

    CCoreServices *pSvc = CCoreServices::CreateInstance();
    if (pSvc == 0)
        return WBEM_E_OUT_OF_MEMORY;
        
    CReleaseMe _rm(pSvc);

    pSvc->StopEventDelivery();

    // Core startup.
    // =============

    hRes = InitCore(pSvc);
    if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Core Initialization returned failure <0x%X>!\n", hRes));
        return hRes;
	}

    // Init repository.
    // ================

    hRes = InitRepository(pSvc);
    if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Repository Initialization returned failure <0x%X>!\n", hRes));
        return hRes;
	}

    pSvc->StartEventDelivery();

/*
    // Init Arbitrator.
    // ================
    hRes = CWmiArbitrator::Initialize(pSvc);
    if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Arbitrator initialization returned failure <0x%X>!\n", hRes));
        return hRes;
	}

    _IWmiArbitrator * pTempArb = NULL;
    if (SUCCEEDED(pSvc->GetArbitrator(&pTempArb)))
    {
        CCoreQueue::SetArbitrator(pTempArb);
        pTempArb->Release();
    }
*/    

    // This will load the default mofs if auto recover is needed

    if (g_bDefaultMofLoadingNeeded || AutoRecoveryWasInterrupted())
    {
        ConfigMgr::LoadDefaultMofs();    // resets g_bDefaultMofLoadingNeeded
        bAutoRecovered = TRUE;
    }

    // Init Provider Subsystem.
    // ========================

    hRes = InitProvSS(pSvc);
    if (FAILED(hRes))
    if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Provider Subsystem initialization returned failure <0x%X>!\n", hRes));
        return hRes;
	}

    // Init ESS.
    // =========

    hRes = InitESS(pSvc, bAutoRecovered);
    if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Event Subsystem initialization returned failure <0x%X>!\n", hRes));
        return hRes;
	}

    // Init ReverseAdapters Hooks
    // =========
    hRes = InitRAHooks(pSvc);
    if (FAILED(hRes))
        return hRes;

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//
static HRESULT ShutdownSubsystems(BOOL bIsSystemShutdown)
{
    HRESULT hRes1, hRes2, hRes3, hRes4, hRes5, hRes6, hRes7 ;

    if (!bIsSystemShutdown)
    {
	    // ShutDown ReverseAdapters Hooks
    	// =========

        hRes7 = ShutdownRAHooks();

		// Kill ESS.
		// =========

		hRes1 = ShutdownESS(bIsSystemShutdown);

	    // Kill Provider Subsystem.
	    // ========================

	    hRes2 = ShutdownProvSS();


	    // Arbitrator
	    // ==========

        hRes3 = CWmiArbitrator::Shutdown(bIsSystemShutdown);	
        
    }

	// Repository.
	// ===========

    hRes4 = ShutdownRepository(bIsSystemShutdown);

    if (!bIsSystemShutdown)
    {
	    // Core startup.
	    // =============

	    hRes5 = ShutdownCore();


	    hRes6 = CCoreServices::UnInitialize();
    }

    return WBEM_S_NO_ERROR;
}


void ConfigMgr::SetDefaultMofLoadingNeeded()
{
    g_bDefaultMofLoadingNeeded = true;
}

HRESULT ConfigMgr::LoadDefaultMofs()
{
    g_bDefaultMofLoadingNeeded = false;

    DWORD dwSize;
	TCHAR *pszMofs;
	TCHAR szExpandedFilename[MAX_PATH+1];
    DWORD dwCurrMof;
    HRESULT hr;

    DWORD dwNextAutoRecoverFile = 0xffffffff;   // assume that this is clean
    Registry r(WBEM_REG_WINMGMT);
    r.GetDWORD(__TEXT("NextAutoRecoverFile"), &dwNextAutoRecoverFile);

	IWinmgmtMofCompiler * pCompiler = NULL;
	HRESULT hRes = CoCreateInstance(CLSID_WinmgmtMofCompiler, 0, CLSCTX_INPROC_SERVER,
							IID_IWinmgmtMofCompiler, (LPVOID *) &pCompiler);
	if(FAILED(hRes))
	{
		return hRes;
	}
    CReleaseMe relMe(pCompiler);

	//Get the list of MOFs we need to
	pszMofs = ConfigMgr::GetAutoRecoverMofs(dwSize);
    CVectorDeleteMe<TCHAR> vdm(pszMofs);

	if (pszMofs)
	{
		for (dwCurrMof = 0; *pszMofs != '\0'; dwCurrMof++)
		{
		    if(dwNextAutoRecoverFile == 0xffffffff || dwCurrMof >= dwNextAutoRecoverFile)
		    {
    			DWORD nRes = ExpandEnvironmentStrings(pszMofs,
    												  szExpandedFilename,
    												  FILENAME_MAX);
    			if (nRes == 0)
    			{
    				//That failed!
    				lstrcpy(szExpandedFilename, pszMofs);
    			}

    			//Call MOF Compiler with (pszMofs);

#ifdef UNICODE
                WCHAR * wPath = szExpandedFilename;
#else
    			WCHAR wPath[MAX_PATH+1];
    			mbstowcs(wPath, szExpandedFilename, MAX_PATH);
#endif			
    			
    			WBEM_COMPILE_STATUS_INFO Info;
    			hr = pCompiler->WinmgmtCompileFile(wPath, NULL,
        				WBEM_FLAG_CONNECT_REPOSITORY_ONLY | WBEM_FLAG_DONT_ADD_TO_LIST,
        				WBEM_FLAG_OWNER_UPDATE, WBEM_FLAG_OWNER_UPDATE, NULL, NULL, &Info);

                if(Info.hRes == CO_E_SERVER_STOPPING)
                {
                    r.SetDWORD(__TEXT("NextAutoRecoverFile"), dwCurrMof);
                    return CO_E_SERVER_STOPPING;
                }
                else if(hr) // will include S_FALSE
    			{
    			    ERRORTRACE((LOG_WBEMCORE, "MOF compilation of <%S> failed during auto-recovery.  Refer to the mofcomp.log for more details of failure.\n", wPath));

    				CEventLog *pEvt = ConfigMgr::GetEventLog();
    				if (pEvt)
    					pEvt->Report(EVENTLOG_ERROR_TYPE,
    								 WBEM_MC_MOF_NOT_LOADED_AT_RECOVERY,
    								 szExpandedFilename);
    			}
            }
            //Move on to the next string
			pszMofs += lstrlen(pszMofs) + 1;
		}

	}
    r.SetDWORD(__TEXT("NextAutoRecoverFile"), 0xffffffff);
	return WBEM_S_NO_ERROR;;
}

//***************************************************************************
//
// The following are used by SetDirRegSec to assist
// in setting directory and registry permissions
//
//***************************************************************************

#ifndef PROTECTED_DACL_SECURITY_INFORMATION 
#define PROTECTED_DACL_SECURITY_INFORMATION     (0x80000000L)
#endif

typedef enum _SE_OBJECT_TYPE
{
    SE_UNKNOWN_OBJECT_TYPE = 0,
    SE_FILE_OBJECT,
    SE_SERVICE,
    SE_PRINTER,
    SE_REGISTRY_KEY,
    SE_LMSHARE,
    SE_KERNEL_OBJECT,
    SE_WINDOW_OBJECT,
    SE_DS_OBJECT,
    SE_DS_OBJECT_ALL,
    SE_PROVIDER_DEFINED_OBJECT,
    SE_WMIGUID_OBJECT,
    SE_REGISTRY_WOW64_32KEY
} SE_OBJECT_TYPE;

typedef DWORD (WINAPI *PFN_SET_NAMED_SEC_INFO_W)
(
    IN LPWSTR                pObjectName,
    IN SE_OBJECT_TYPE        ObjectType,
    IN SECURITY_INFORMATION  SecurityInfo,
    IN PSID                  psidOowner,
    IN PSID                  psidGroup,
    IN PACL                  pDacl,
    IN PACL                  pSacl
);

typedef BOOL (WINAPI *PFN_ALLOCATE_AND_INITIALIZE_SID)
(
    IN PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
    IN BYTE nSubAuthorityCount,
    IN DWORD nSubAuthority0,
    IN DWORD nSubAuthority1,
    IN DWORD nSubAuthority2,
    IN DWORD nSubAuthority3,
    IN DWORD nSubAuthority4,
    IN DWORD nSubAuthority5,
    IN DWORD nSubAuthority6,
    IN DWORD nSubAuthority7,
    OUT PSID *pSid
);

class CFreeThisLib
{
protected:
    HINSTANCE m_hInstance;
public:
    CFreeThisLib(HINSTANCE hInstance = NULL) : m_hInstance(hInstance){}
    ~CFreeThisLib() {if (m_hInstance) ::FreeLibrary(m_hInstance);}
};

class CFreeThisSid
{
protected:
    PSID m_pSid;
public:
    CFreeThisSid(PSID pSid = NULL) : m_pSid(pSid){}
    ~CFreeThisSid() {if (m_pSid) FreeSid(m_pSid);}
    void operator= (PSID pSid) {m_pSid = pSid;}	// overwrites the previous pointer, does NOT delete it
};

template<class T>
class CFreeMe
{
protected:
    T* m_p;
public:
    CFreeMe(T* p = NULL) : m_p(p){}
    ~CFreeMe() {free(m_p);}
    void operator= (T* p) {m_p = p;}	// overwrites the previous pointer, does NOT delete it
};

//***************************************************************************
//
// SetDirRegSec
//
// Purpose: Set directory and registry security
//
// Return:  false if failed or true if succeeded
//***************************************************************************

bool ConfigMgr::SetDirRegSec(void)
{
	bool bRet = true;

    HINSTANCE t_Instance = ::LoadLibraryW(L"ADVAPI32");
    if (!t_Instance)
    {
		ERRORTRACE((LOG_WBEMCORE, "LoadLibrary for ADVAPI32 failed\n"));
		return false;
	}
	CFreeThisLib freeLib(t_Instance);

	PFN_ALLOCATE_AND_INITIALIZE_SID t_AllocateAndInitializeSid = (PFN_ALLOCATE_AND_INITIALIZE_SID) ::GetProcAddress(t_Instance, "AllocateAndInitializeSid");
	if (!t_AllocateAndInitializeSid)
	{      
		ERRORTRACE((LOG_WBEMCORE, "GetProcAddress for AllocateAndInitializeSid failed\n"));
		return false;
	}

    PFN_SET_NAMED_SEC_INFO_W t_SetNamedSecurityInfoW = (PFN_SET_NAMED_SEC_INFO_W) ::GetProcAddress(t_Instance, "SetNamedSecurityInfoW");
	if (!t_SetNamedSecurityInfoW)
	{      
		ERRORTRACE((LOG_WBEMCORE, "GetProcAddress for SetNamedSecurityInfo failed\n"));
		return false;
	}

	// alloc and init the sids

	SID_IDENTIFIER_AUTHORITY t_NtAuthoritySid = SECURITY_NT_AUTHORITY;

	PSID t_Administrator_Sid = NULL;
	BOOL t_BoolResult = t_AllocateAndInitializeSid(
							&t_NtAuthoritySid,
							2,
							SECURITY_BUILTIN_DOMAIN_RID,
							DOMAIN_ALIAS_RID_ADMINS,
							0, 0, 0, 0, 0, 0,
							&t_Administrator_Sid);
	CFreeThisSid freeSid1(t_Administrator_Sid);
	if (!t_BoolResult)
	{
		DWORD t_LastError = GetLastError();
		ERRORTRACE((LOG_WBEMCORE, "AllocateAndInitializeSid failed for the Administrator SID with error %d\n", t_LastError));
		bRet = false;
	}

	PSID t_System_Sid = NULL;
	t_BoolResult = t_AllocateAndInitializeSid(
							&t_NtAuthoritySid,
							1,
							SECURITY_LOCAL_SYSTEM_RID,
							0,
							0, 0, 0, 0, 0, 0,
							&t_System_Sid);
	CFreeThisSid freeSid2(t_System_Sid);
	if (!t_BoolResult)
	{
		DWORD t_LastError = GetLastError();
		ERRORTRACE((LOG_WBEMCORE, "AllocateAndInitializeSid failed for the System SID with error %d\n", t_LastError));
		bRet = false;
	}

	PSID t_PowerUsers_Sid = NULL;
	t_BoolResult = t_AllocateAndInitializeSid(
							&t_NtAuthoritySid,
							2,
							SECURITY_BUILTIN_DOMAIN_RID,
							DOMAIN_ALIAS_RID_POWER_USERS,
							0, 0, 0, 0, 0, 0,
							&t_PowerUsers_Sid);
	CFreeThisSid freeSid3(t_PowerUsers_Sid);
	if (!t_BoolResult)
	{
		DWORD t_LastError = GetLastError();
		ERRORTRACE((LOG_WBEMCORE, "AllocateAndInitializeSid failed for the PowerUsers SID with error %d\n", t_LastError));
		bRet = false;
	}

	SID_IDENTIFIER_AUTHORITY t_WorldAuthoritySid = SECURITY_WORLD_SID_AUTHORITY;

	PSID t_Everyone_Sid = NULL;
	t_BoolResult = t_AllocateAndInitializeSid(
							&t_WorldAuthoritySid,
							1,
							SECURITY_WORLD_RID,
							0,
							0, 0, 0, 0, 0, 0,
							&t_Everyone_Sid);
	CFreeThisSid freeSid4(t_Everyone_Sid);
	if (!t_BoolResult)
	{
		DWORD t_LastError = GetLastError();
		ERRORTRACE((LOG_WBEMCORE, "AllocateAndInitializeSid failed for the Everyone SID with error %d\n", t_LastError));
		bRet = false;
	}

	PSID t_LocalService_Sid = NULL;
	t_BoolResult = t_AllocateAndInitializeSid(
							&t_NtAuthoritySid,
							1,
							SECURITY_LOCAL_SERVICE_RID,
							0,
							0, 0, 0, 0, 0, 0,
							&t_LocalService_Sid);
	CFreeThisSid freeSid5(t_LocalService_Sid);
	if (!t_BoolResult)
	{
		DWORD t_LastError = GetLastError();
		ERRORTRACE((LOG_WBEMCORE, "AllocateAndInitializeSid failed for the Local Service SID with error %d\n", t_LastError));
		bRet = false;
	}

	PSID t_NetworkService_Sid = NULL;
	t_BoolResult = t_AllocateAndInitializeSid(
							&t_NtAuthoritySid,
							1,
							SECURITY_NETWORK_SERVICE_RID,
							0,
							0, 0, 0, 0, 0, 0,
							&t_NetworkService_Sid);
	CFreeThisSid freeSid6(t_NetworkService_Sid);
	if (!t_BoolResult)
	{
		DWORD t_LastError = GetLastError();
		ERRORTRACE((LOG_WBEMCORE, "AllocateAndInitializeSid failed for the Network Service SID with error %d\n", t_LastError));
		bRet = false;
	}


//	alloc and init the ACE's 

	ACCESS_ALLOWED_ACE *t_Administrator_ACE = NULL;
	CFreeMe<ACCESS_ALLOWED_ACE> freeMe1;
	DWORD t_Administrator_ACESize = 0;
	if (t_Administrator_Sid)
	{
		DWORD t_SidLength = ::GetLengthSid(t_Administrator_Sid);
		t_Administrator_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) (t_SidLength - sizeof(DWORD));
		t_Administrator_ACE = (ACCESS_ALLOWED_ACE*) malloc(t_Administrator_ACESize);
		if (t_Administrator_ACE)
		{
			freeMe1 = t_Administrator_ACE;
			CopySid(t_SidLength, (PSID) &t_Administrator_ACE->SidStart, t_Administrator_Sid);
			t_Administrator_ACE->Mask = 0x1F01FF;
			t_Administrator_ACE->Header.AceType = 0;
			t_Administrator_ACE->Header.AceFlags = 3;
			t_Administrator_ACE->Header.AceSize = (unsigned short) t_Administrator_ACESize;
		}
		else
		{
			ERRORTRACE((LOG_WBEMCORE, "Failed to allocate t_Administrator_ACE\n"));
			bRet = false;
		}
	}

	ACCESS_ALLOWED_ACE *t_System_ACE = NULL;
	CFreeMe<ACCESS_ALLOWED_ACE> freeMe2;
	DWORD t_System_ACESize = 0;
	if (t_System_Sid)
	{
		DWORD t_SidLength = ::GetLengthSid(t_System_Sid);
		t_System_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) (t_SidLength - sizeof(DWORD));
		t_System_ACE = (ACCESS_ALLOWED_ACE*) malloc(t_System_ACESize);
		if (t_System_ACE)
		{
			freeMe2 = t_System_ACE;
			CopySid(t_SidLength, (PSID) &t_System_ACE->SidStart, t_System_Sid);
			t_System_ACE->Mask = 0x1F01FF;
			t_System_ACE->Header.AceType = 0;
			t_System_ACE->Header.AceFlags = 3;
			t_System_ACE->Header.AceSize = (unsigned short) t_System_ACESize;
		}
		else
		{
			ERRORTRACE((LOG_WBEMCORE, "Failed to allocate t_System_ACE\n"));
			bRet = false;
		}
	}

	ACCESS_ALLOWED_ACE *t_PowerUsers_ACE = NULL;
	CFreeMe<ACCESS_ALLOWED_ACE> freeMe3;
	DWORD t_PowerUsers_ACESize = 0;
	if (t_PowerUsers_Sid)
	{
		DWORD t_SidLength = ::GetLengthSid(t_PowerUsers_Sid);
		t_PowerUsers_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) (t_SidLength - sizeof(DWORD));
		t_PowerUsers_ACE = (ACCESS_ALLOWED_ACE*) malloc(t_PowerUsers_ACESize);
		if (t_PowerUsers_ACE)
		{
			freeMe3 = t_PowerUsers_ACE;
			CopySid(t_SidLength, (PSID) &t_PowerUsers_ACE->SidStart, t_PowerUsers_Sid);
			t_PowerUsers_ACE->Mask = GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | DELETE;
			t_PowerUsers_ACE->Header.AceType = 0;
			t_PowerUsers_ACE->Header.AceFlags = 3;
			t_PowerUsers_ACE->Header.AceSize = (unsigned short) t_PowerUsers_ACESize;
		}
		else
		{
			ERRORTRACE((LOG_WBEMCORE, "Failed to allocate t_PowerUsers_ACE\n"));
			bRet = false;
		}
	}

	ACCESS_ALLOWED_ACE *t_Everyone_ACE = NULL;
	CFreeMe<ACCESS_ALLOWED_ACE> freeMe4;
	DWORD t_Everyone_ACESize = 0;
	if (t_Everyone_Sid)
	{
		DWORD t_SidLength = ::GetLengthSid(t_Everyone_Sid);
		t_Everyone_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) (t_SidLength - sizeof(DWORD));
		t_Everyone_ACE = (ACCESS_ALLOWED_ACE*) malloc(t_Everyone_ACESize);
		if (t_Everyone_ACE)
		{
			freeMe4 = t_Everyone_ACE;
			CopySid(t_SidLength, (PSID) &t_Everyone_ACE->SidStart, t_Everyone_Sid);
			t_Everyone_ACE->Mask = KEY_READ;
			t_Everyone_ACE->Header.AceType = 0;
			t_Everyone_ACE->Header.AceFlags = 3;
			t_Everyone_ACE->Header.AceSize = (unsigned short) t_Everyone_ACESize;
		}
		else
		{
			ERRORTRACE((LOG_WBEMCORE, "Failed to allocate t_Everyone_ACE\n"));
			bRet = false;
		}
	}

	ACCESS_ALLOWED_ACE *t_LocalService_ACE = NULL;
	CFreeMe<ACCESS_ALLOWED_ACE> freeMe5;
	DWORD t_LocalService_ACESize = 0;
	if (t_LocalService_Sid)
	{
		DWORD t_SidLength = ::GetLengthSid(t_LocalService_Sid);
		t_LocalService_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) (t_SidLength - sizeof(DWORD));
		t_LocalService_ACE = (ACCESS_ALLOWED_ACE*) malloc(t_LocalService_ACESize);
		if (t_LocalService_ACE)
		{
			freeMe5 = t_LocalService_ACE;
			CopySid(t_SidLength, (PSID) &t_LocalService_ACE->SidStart, t_LocalService_Sid);
			t_LocalService_ACE->Mask = GENERIC_READ | GENERIC_WRITE;
			t_LocalService_ACE->Header.AceType = 0;
			t_LocalService_ACE->Header.AceFlags = 3;
			t_LocalService_ACE->Header.AceSize = (unsigned short) t_LocalService_ACESize;
		}
		else
		{
			ERRORTRACE((LOG_WBEMCORE, "Failed to allocate t_LocalService_ACE\n"));
			bRet = false;
		}
	}

	ACCESS_ALLOWED_ACE *t_NetworkService_ACE = NULL;
	CFreeMe<ACCESS_ALLOWED_ACE> freeMe6;
	DWORD t_NetworkService_ACESize = 0;
	if (t_NetworkService_Sid)
	{
		DWORD t_SidLength = ::GetLengthSid(t_NetworkService_Sid);
		t_NetworkService_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) (t_SidLength - sizeof(DWORD));
		t_NetworkService_ACE = (ACCESS_ALLOWED_ACE*) malloc(t_NetworkService_ACESize);
		if (t_NetworkService_ACE)
		{
			freeMe6 = t_NetworkService_ACE;
			CopySid(t_SidLength, (PSID) &t_NetworkService_ACE->SidStart, t_NetworkService_Sid);
			t_NetworkService_ACE->Mask = GENERIC_READ | GENERIC_WRITE;
			t_NetworkService_ACE->Header.AceType = 0;
			t_NetworkService_ACE->Header.AceFlags = 3;
			t_NetworkService_ACE->Header.AceSize = (unsigned short) t_NetworkService_ACESize;
		}
		else
		{
			ERRORTRACE((LOG_WBEMCORE, "Failed to allocate t_NetworkService_ACE\n"));
			bRet = false;
		}
	}


	// Now we're ready to allocate the DACL
	DWORD t_TotalAclSize =	sizeof(ACL) +
							t_Administrator_ACESize +
							t_System_ACESize +
							t_PowerUsers_ACESize +
							t_LocalService_ACESize +
							t_NetworkService_ACESize;

	PACL t_Dacl = (PACL) malloc(t_TotalAclSize);
	if (t_Dacl)
	{
		CFreeMe<ACL> freeMe(t_Dacl);

		if (::InitializeAcl(t_Dacl, t_TotalAclSize, ACL_REVISION))
		{
			DWORD t_AceIndex = 0;

			if (t_Administrator_ACE && ::AddAce(t_Dacl, ACL_REVISION, t_AceIndex, t_Administrator_ACE, t_Administrator_ACESize))
				t_AceIndex++;

			if (t_System_ACE && ::AddAce(t_Dacl, ACL_REVISION, t_AceIndex, t_System_ACE, t_System_ACESize))
				t_AceIndex++;

			HKEY t_Key;
			SECURITY_INFORMATION t_SecurityInfo = 0L;

			t_SecurityInfo |= DACL_SECURITY_INFORMATION;
			t_SecurityInfo |= PROTECTED_DACL_SECURITY_INFORMATION;

			LONG t_RegStatus = ::RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\WBEM", 0, KEY_READ, &t_Key);

			if (t_RegStatus == ERROR_SUCCESS)
			{
				BYTE bRegVal[_MAX_PATH];
				wchar_t wszExpandedDirectory[_MAX_PATH];
				DWORD lBufSize = (_MAX_PATH - 1)*sizeof(WCHAR);
				WCHAR wstrKey[_MAX_PATH];
				
				// set security for Repository directory

				wcscpy(wstrKey,  L"Installation Directory");

				DWORD dwType;
				t_RegStatus = ::RegQueryValueExW(t_Key, wstrKey, NULL, &dwType, bRegVal, &lBufSize);
				if (t_RegStatus == ERROR_SUCCESS)
				{
					if (ExpandEnvironmentStringsW((LPCWSTR)bRegVal, (LPWSTR)wszExpandedDirectory, _MAX_PATH))
					{
						wcscat(wszExpandedDirectory, L"\\Repository");

						// verify that directory already exists; if not, create it so we can set its permissions
						DWORD dwAttributes = GetFileAttributesW(wszExpandedDirectory);
						if (dwAttributes == 0xFFFFFFFF)
						{
							if (!CreateDirectoryW(wszExpandedDirectory, NULL))
							{
								ERRORTRACE((LOG_WBEMCORE, "Failed to create Repository directory\n"));
								bRet = false;
							}
						}

						// now set the permissions
						DWORD t_SetStatus = t_SetNamedSecurityInfoW((LPWSTR)wszExpandedDirectory, SE_FILE_OBJECT, t_SecurityInfo, NULL, NULL, t_Dacl, NULL);

						if (t_SetStatus != ERROR_SUCCESS)
						{
							ERRORTRACE((LOG_WBEMCORE, "SetNamedSecurityInfoW failed for %S with error %d\n", wszExpandedDirectory, t_SetStatus));
							bRet = false;
						}
					}
					else
					{
						ERRORTRACE((LOG_WBEMCORE, "Failed to expand environment strings for repository directory\n"));
						bRet = false;
					}
				}
				else
				{
					ERRORTRACE((LOG_WBEMCORE, "Failed to retrieve Installation Directory from registry\n"));
					bRet = false;
				}

				// set security for Hot Mof directory

				bool bPowerUsers_ACE = false; 
				if (t_PowerUsers_ACE && ::AddAce(t_Dacl, ACL_REVISION, t_AceIndex, t_PowerUsers_ACE, t_PowerUsers_ACESize))
				{
					bPowerUsers_ACE = true;
					t_AceIndex++;
				}

				lBufSize = (_MAX_PATH - 1)*sizeof(WCHAR);

				wcscpy(wstrKey, L"MOF Self-Install Directory");

				t_RegStatus = ::RegQueryValueExW(t_Key, wstrKey, NULL, &dwType, bRegVal, &lBufSize);

				if (t_RegStatus == ERROR_SUCCESS)
				{
					if (ExpandEnvironmentStringsW((LPCWSTR)bRegVal, (LPWSTR)wszExpandedDirectory, _MAX_PATH))
					{
						// verify that directory already exists; if not, create it so we can set its permissions
						DWORD dwAttributes = GetFileAttributesW(wszExpandedDirectory);
						if (dwAttributes == 0xFFFFFFFF)
						{
							if (!CreateDirectoryW(wszExpandedDirectory, NULL))
							{
								ERRORTRACE((LOG_WBEMCORE, "Failed to create MOF Self-Install directory\n"));
								bRet = false;
							}
						}

						// now set the permissions
						DWORD t_SetStatus = t_SetNamedSecurityInfoW((LPWSTR)wszExpandedDirectory, SE_FILE_OBJECT, t_SecurityInfo, NULL, NULL, t_Dacl, NULL);

						if (t_SetStatus != ERROR_SUCCESS)
						{
							ERRORTRACE((LOG_WBEMCORE, "SetNamedSecurityInfoW failed for %S with error %d\n", wszExpandedDirectory, t_SetStatus));
							bRet = false;
						}
					}
					else
					{
						ERRORTRACE((LOG_WBEMCORE, "Failed to expand environment strings for MOF Self-Install directory\n"));
						bRet = false;
					}
				}
				else
				{
					ERRORTRACE((LOG_WBEMCORE, "Failed to retrieve MOF Self-Install Directory from registry\n"));
					bRet = false;
				}

				::RegCloseKey(t_Key);

				// set security for Logging directory

				t_RegStatus = ::RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\WBEM\\CIMOM", 0, KEY_READ, &t_Key);

				if (t_RegStatus == ERROR_SUCCESS)
				{
					lBufSize = (_MAX_PATH - 1)*sizeof(WCHAR);

					wcscpy(wstrKey, L"Logging Directory");

					t_RegStatus = ::RegQueryValueExW(t_Key, wstrKey, NULL, &dwType, bRegVal, &lBufSize);
					if (t_RegStatus == ERROR_SUCCESS)
					{
						// this registry value is not REG_EXPAND_SZ, so no need to expand before using

						// verify that directory already exists; if not, create it so we can set its permissions
						DWORD dwAttributes = GetFileAttributesW((wchar_t*)bRegVal);
						if (dwAttributes == 0xFFFFFFFF)
						{
							if (!CreateDirectoryW((wchar_t*)bRegVal, NULL))
							{
								ERRORTRACE((LOG_WBEMCORE, "Failed to create Logging directory\n"));
								bRet = false;
							}
						}

						// remove the power users ace and add the local and network service aces
						if (bPowerUsers_ACE && ::DeleteAce(t_Dacl, t_AceIndex - 1))
							t_AceIndex--;

						if (t_LocalService_ACE && ::AddAce(t_Dacl, ACL_REVISION, t_AceIndex, t_LocalService_ACE, t_LocalService_ACESize))
							t_AceIndex++;

						if (t_NetworkService_ACE && ::AddAce(t_Dacl, ACL_REVISION, t_AceIndex, t_NetworkService_ACE, t_NetworkService_ACESize))
							t_AceIndex++;

						// now set the permissions
						DWORD t_SetStatus = t_SetNamedSecurityInfoW((LPWSTR)bRegVal, SE_FILE_OBJECT, t_SecurityInfo, NULL, NULL, t_Dacl, NULL);

						if (t_SetStatus != ERROR_SUCCESS)
						{
							ERRORTRACE((LOG_WBEMCORE, "SetNamedSecurityInfoW failed for %S with error %d\n", bRegVal, t_SetStatus));
							bRet = false;
						}
					}
					else
					{
						ERRORTRACE((LOG_WBEMCORE, "Failed to retrieve Logging Directory from registry\n"));
						bRet = false;
					}

					::RegCloseKey(t_Key);
				}
				else
				{
					ERRORTRACE((LOG_WBEMCORE, "Failed to open WBEM\\CIMOM registry key\n"));
					bRet = false;
				}
			}
			else
			{
				ERRORTRACE((LOG_WBEMCORE, "Failed to open WBEM registry key\n"));
				bRet = false;
			}
		}
		else
		{
			ERRORTRACE((LOG_WBEMCORE, "Failed to initialize t_Dacl for setting directory permissions\n"));
			bRet = false;
		}
	}
	else
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed to allocate t_Dacl for setting directory permissions\n"));
		bRet = false;
	}


	// reset these masks for registry access now
	if (t_Administrator_ACE)
		t_Administrator_ACE->Mask = KEY_ALL_ACCESS;

	if (t_System_ACE)
		t_System_ACE->Mask = KEY_ALL_ACCESS;

	if (t_LocalService_ACE)
		t_LocalService_ACE->Mask = KEY_ALL_ACCESS;

	if (t_NetworkService_ACE)
		t_NetworkService_ACE->Mask = KEY_ALL_ACCESS;

	// Now we need to set permissions on the registry: Everyone - read; Admins, System, NetworkService, LocalService - full.
	t_TotalAclSize =	sizeof(ACL) +
						t_Administrator_ACESize +
						t_System_ACESize +
						t_Everyone_ACESize +
						t_LocalService_ACESize +
						t_NetworkService_ACESize;

	t_Dacl = (PACL) malloc(t_TotalAclSize);
	if (t_Dacl)
	{
		CFreeMe<ACL> freeMe(t_Dacl);

		if (::InitializeAcl(t_Dacl, t_TotalAclSize, ACL_REVISION))
		{
			DWORD t_AceIndex = 0;

			if (t_NetworkService_ACESize && ::AddAce(t_Dacl, ACL_REVISION, t_AceIndex, t_NetworkService_ACE, t_NetworkService_ACESize))
				t_AceIndex++;

			if (t_LocalService_ACESize && ::AddAce(t_Dacl, ACL_REVISION, t_AceIndex, t_LocalService_ACE, t_LocalService_ACESize))
				t_AceIndex++;

			if (t_Everyone_ACESize && ::AddAce(t_Dacl, ACL_REVISION, t_AceIndex, t_Everyone_ACE, t_Everyone_ACESize))
				t_AceIndex++;

			if (t_System_ACESize && ::AddAce(t_Dacl, ACL_REVISION, t_AceIndex, t_System_ACE, t_System_ACESize))
				t_AceIndex++;
			
			if (t_Administrator_ACESize && ::AddAce(t_Dacl, ACL_REVISION, t_AceIndex, t_Administrator_ACE, t_Administrator_ACESize))
				t_AceIndex++;

			SECURITY_INFORMATION t_SecurityInfo = 0L;

			t_SecurityInfo |= DACL_SECURITY_INFORMATION;
			t_SecurityInfo |= PROTECTED_DACL_SECURITY_INFORMATION;

			DWORD t_SetStatus = t_SetNamedSecurityInfoW((LPWSTR)L"MACHINE\\SOFTWARE\\Microsoft\\WBEM", SE_REGISTRY_KEY, t_SecurityInfo, NULL, NULL, t_Dacl, NULL);
			if (t_SetStatus != ERROR_SUCCESS)
			{
				ERRORTRACE((LOG_WBEMCORE, "SetNamedSecurityInfoW failed for registry with error %d\n", t_SetStatus));
				bRet = false;
			}
		}
		else
		{
			ERRORTRACE((LOG_WBEMCORE, "Failed to initialize t_Dacl for setting registry permissions\n"));
			bRet = false;
		}
	}
	else
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed to allocate t_Dacl for setting registry permissions\n"));
		bRet = false;
	}

	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\callres.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    CALLRES.CPP

Abstract:

    Call Result Class

History:

--*/

#include "precomp.h"
#include "wbemcore.h"

#pragma warning(disable:4355)

CCallResult::CCallResult(IWbemClassObject* pResObj, HRESULT hres,
            IWbemClassObject* pErrorObj)
    : m_lRef(1), m_pResObj(pResObj), m_hres(hres), m_pErrorObj(pErrorObj),
        m_pResNamespace(NULL), m_strResult(NULL), m_ppResObjDest(NULL),
        m_bReady(TRUE), m_XSink(this)
{
    if(pResObj)
        pResObj->AddRef();
    if(pErrorObj)
        pErrorObj->AddRef();
    gClientCounter.AddClientPtr(this, CALLRESULT);
    m_hReady = CreateEvent(NULL, TRUE, TRUE, NULL);
}

CCallResult::CCallResult(IWbemClassObject** ppResObjDest)
    : m_lRef(1), m_pResObj(NULL), m_hres(WBEM_E_CRITICAL_ERROR),
        m_pErrorObj(NULL), m_pResNamespace(NULL), m_strResult(NULL),
        m_ppResObjDest(ppResObjDest), m_bReady(FALSE), m_XSink(this)
{
    m_hReady = CreateEvent(NULL, TRUE, FALSE, NULL);
    gClientCounter.AddClientPtr(this, CALLRESULT);
    InitializeCriticalSection(&m_cs);
}

CCallResult::~CCallResult()
{
    if(m_pResObj)
        m_pResObj->Release();

    if(m_pErrorObj)
        m_pErrorObj->Release();

    if(m_pResNamespace)
        m_pResNamespace->Release();

    gClientCounter.RemoveClientPtr(this);
    SysFreeString(m_strResult);
    CloseHandle(m_hReady);
    DeleteCriticalSection(&m_cs);
}

HRESULT CCallResult::SetStatus(HRESULT hres, BSTR strParam,
                                IWbemClassObject* pErrorObj)
{
    Enter();

    // Check that SetStatus has not been called yet
    // ============================================

    if(m_bReady)
    {
        Leave();
        return WBEM_E_UNEXPECTED;
    }

    // Store data
    // ==========

    m_hres = hres;
    m_strResult = SysAllocString(strParam);
    m_pErrorObj = pErrorObj;
    if(pErrorObj)
        pErrorObj->AddRef();

    // Signal both events --- we are ready for everything
    // ==================================================

    m_bReady = TRUE;
    SetEvent(m_hReady);

    Leave();

    return WBEM_S_NO_ERROR;
}

HRESULT CCallResult::SetResultObject(IWbemClassObject* pResObj)
{
    Enter();

    // Check that neither SetStatus nor Indicate has been called yet
    // =============================================================

    if(m_bReady)
    {
        Leave();
        return WBEM_E_UNEXPECTED;
    }

    // Store data
    // ==========

    m_pResObj = pResObj;
    if(pResObj)
        pResObj->AddRef();

    if(m_ppResObjDest)
    {
        *m_ppResObjDest = pResObj;
        if(pResObj)
            pResObj->AddRef();
    }

    Leave();

    return WBEM_S_NO_ERROR;
}


void CCallResult::SetResultString(LPWSTR wszRes)
{
    SysFreeString(m_strResult);
    m_strResult = SysAllocString(wszRes);
}

void CCallResult::SetResultServices(IWbemServices* pRes)
{
    if(m_pResNamespace)
        m_pResNamespace->Release();
    m_pResNamespace = pRes;
    if(pRes)
        pRes->AddRef();
}

void CCallResult::SetErrorInfo()
{
    if(m_pErrorObj)
    {
        IErrorInfo* pInfo = NULL;
        m_pErrorObj->QueryInterface(IID_IErrorInfo, (void**)&pInfo);
        ::SetErrorInfo(0, pInfo);
        pInfo->Release();
    }
}



STDMETHODIMP CCallResult::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemCallResult)
    {
        AddRef();
        *ppv = (void*)this;
        return S_OK;
    }
    else return E_NOINTERFACE;
}


STDMETHODIMP CCallResult::GetResultObject(long lTimeout,
                                          IWbemClassObject** ppObj)
{
    if(!m_Security.AccessCheck())
        return WBEM_E_ACCESS_DENIED;

    *ppObj = NULL;
    if(lTimeout < 0 && lTimeout != -1)
        return WBEM_E_INVALID_PARAMETER;

    DWORD dwRes = CCoreQueue::QueueWaitForSingleObject(m_hReady, lTimeout);
    if(dwRes == WAIT_TIMEOUT)
        return WBEM_S_TIMEDOUT;

    if(dwRes == WAIT_FAILED)
        return WBEM_E_FAILED;

    // Event is signaled --- expect object
    // ===================================

    if(m_pResObj)
    {
        *ppObj = m_pResObj;
        m_pResObj->AddRef();
        return WBEM_S_NO_ERROR;
    }
    else
    {
        *ppObj = NULL;
        if(FAILED(m_hres))
            SetErrorInfo();

        return m_hres;
    }
}

STDMETHODIMP CCallResult::GetResultString(long lTimeout, BSTR* pstr)
{
    if(!m_Security.AccessCheck())
        return WBEM_E_ACCESS_DENIED;

    *pstr = NULL;
    if(lTimeout < 0 && lTimeout != -1)
        return WBEM_E_INVALID_PARAMETER;

    DWORD dwRes = CCoreQueue::QueueWaitForSingleObject(m_hReady, lTimeout);
    if(dwRes == WAIT_TIMEOUT)
        return WBEM_S_TIMEDOUT;

    if(dwRes == WAIT_FAILED)
        return WBEM_E_FAILED;

    // Event is signaled --- expect string
    // ===================================

    if(m_strResult)
    {
        *pstr = SysAllocString(m_strResult);
        return WBEM_S_NO_ERROR;
    }
    else
    {
        *pstr = NULL;
        if(SUCCEEDED(m_hres))
            return WBEM_E_INVALID_OPERATION;
        else
        {
            SetErrorInfo();
            return m_hres;
        }
    }
}

STDMETHODIMP CCallResult::GetCallStatus(long lTimeout, long* plStatus)
{
    if(!m_Security.AccessCheck())
        return WBEM_E_ACCESS_DENIED;

    *plStatus = WBEM_E_CRITICAL_ERROR;
    if(lTimeout < 0 && lTimeout != -1)
        return WBEM_E_INVALID_PARAMETER;

    DWORD dwRes = CCoreQueue::QueueWaitForSingleObject(m_hReady, lTimeout);
    if(dwRes == WAIT_TIMEOUT)
        return WBEM_S_TIMEDOUT;

    if(dwRes == WAIT_FAILED)
        return WBEM_E_FAILED;

    // Event is signaled --- expect status
    // ===================================

    *plStatus = m_hres;
    if(FAILED(m_hres))
    {
        SetErrorInfo();
    }
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CCallResult::GetResultServices(long lTimeout,
                                            IWbemServices** ppServices)
{
    if(!m_Security.AccessCheck())
        return WBEM_E_ACCESS_DENIED;

    *ppServices = NULL;
    if(lTimeout < 0 && lTimeout != -1)
        return WBEM_E_INVALID_PARAMETER;

    DWORD dwRes = CCoreQueue::QueueWaitForSingleObject(m_hReady, lTimeout);
    if(dwRes == WAIT_TIMEOUT)
        return WBEM_S_TIMEDOUT;

    if(dwRes == WAIT_FAILED)
        return WBEM_E_FAILED;

    if(m_pResNamespace)
    {
        *ppServices = m_pResNamespace;
        m_pResNamespace->AddRef();
        return WBEM_S_NO_ERROR;
    }
    else
    {
        *ppServices = NULL;
        if(SUCCEEDED(m_hres))
            return WBEM_E_INVALID_OPERATION;
        else
        {
            SetErrorInfo();
            return m_hres;
        }
    }
}


STDMETHODIMP CCallResult::GetResult(
        long lTimeout,
        long lFlags,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvResult
        )
{
	return WBEM_E_NOT_SUPPORTED;
}













STDMETHODIMP CCallResult::CResultSink::
Indicate(long lNumObjects, IWbemClassObject** aObjects)
{
    if(lNumObjects > 1)
    {
        return WBEM_E_UNEXPECTED;
    }
    if(lNumObjects == 0)
    {
        return WBEM_S_NO_ERROR;
    }

    return m_pOwner->SetResultObject(aObjects[0]);
}

STDMETHODIMP CCallResult::CResultSink::
SetStatus(long lFlags, HRESULT hres, BSTR strParam, IWbemClassObject* pErrorObj)
{
    if(lFlags != 0)
    {
        return WBEM_S_NO_ERROR;
    }

    return m_pOwner->SetStatus(hres, strParam, pErrorObj);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\clicnt.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    CLICNT.H

Abstract:

    Generic class for obtaining read and write locks to some resource.

History:
	
	26-Mar-98   a-davj    Created.

--*/

#ifndef __CLICNT__H_
#define __CLICNT__H_

#include <flexarry.h>

//*****************************************************************************
//
//	class CClientCnt
//
//	Keeps track of when the core can be unloaded.  Mainly it keep track of client connections,
//  but also can be called by other core code, such as the maintenance thread, to hold off
//  unloading.  This is very similar to the object counters, except this keeps track of only
//  objects which should prevent the core from unloading.  For example, a IWbemServices pointer used
//  internally for the ESS should not be in this list, but one given to a client would be.
//
//*****************************************************************************
//
//	AddClientPtr
//
//	Typcially called during the constructor of an object that has been given to a client
//
//	Parameters:
//
//		IUnknown *  punk	Pointer to an obejct.
//      DWORD dwType        Type of pointer
//
//	Returns:
//
//		true if OK
//
//*****************************************************************************
//
//	RemoveClientPtr
//
//	Typically called during the destructor of an object that might have been given to
//  a client.  Note that the code will search through the list of objects added and find
//  the object before doing anything.  So if the pointer is to an object not added via
//  AddClientPtr is passed, no harm is done.  This is important in the case of objects which
//  are not always given to a client.
//
//	Parameters:
//
//		IUnknown *  punk	Pointer to an obejct.
//
//	Returns:
//
//		true if removed.
//      flase is not necessarily a problem!
//*****************************************************************************
//
//	LockCore
//
//	Called in order to keep the core loaded.  This is called by the maintenance thread
//  in order to hold the core in memory.  Note that this acts like the LockServer call in
//  that serveral threads can call this an not block.  UnlockCore should be called when
//  the core is not needed anymore.
//
//	Returns:
//
//		long LockCount after call
//
//*****************************************************************************
//
//	UnlockCore
//
//	Called to reverse the effect of LockCore.
//
//	Returns:
//
//		long LockCount after call
//
//*****************************************************************************

enum ClientObjectType {CALLRESULT = 0, ENUMERATOR, NAMESPACE, LOCATOR, LOGIN, FACTORY};


// These types of locks are supported.  Note that LASTONE isnt valid and any new locks should go
// before it.  LASTONE is used to define the lock array size.

enum LockType {MAINTENANCE = 0, ESS, TIMERTHREAD, LASTONE};

struct Entry
{
	IUnknown * m_pUnk;
	ClientObjectType m_Type;
};

class CClientCnt
{
public:
	bool AddClientPtr(IUnknown *  punk, ClientObjectType Type);
	bool RemoveClientPtr(IUnknown *  punk);
    long LockCore(LockType lt);

    // Note that the second argument should be set to false only if it is not
    // desireable to notify WinMgmt.exe.
    long UnlockCore(LockType lt, bool Notify = true);
    bool OkToUnload();
    CClientCnt();
	~CClientCnt();
    void Empty();

protected:
	long m_lLockCounts[LASTONE];
	CFlexArray m_Array;
	CRITICAL_SECTION m_csEntering;
	void SignalIfOkToUnload();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\coreapi.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    COREAPI.H

Abstract:

    Implements the COM API layer of WMI

History:
    25-Apr-00   raymcc      Created from mixes Win2k sources

--*/

#include "precomp.h"

#include <windows.h>
#include <stdio.h>
#include <wbemcore.h>

//***************************************************************************
//
//***************************************************************************
//
CWmiCoreApi::CWmiCoreApi()
{
    m_uRefCount = 0;
    m_pCoreSvc = 0;
    m_pArb = 0;
    m_pNs = 0;
    m_pScope = 0;
    m_pProvFact = 0;
    m_uStateFlags = 0;
    memset(&m_TransactionGuid, 0, sizeof(GUID));
    m_pNsPath = 0;
    m_pScopePath = 0;
    m_pszScope = 0;
    m_pszNamespace = 0;
    m_pszUser = 0;
    m_bRepositOnly = 0;
    m_pRefreshingSvc = 0;
}

//***************************************************************************
//
//***************************************************************************
//
CWmiCoreApi::~CWmiCoreApi()
{
    ReleaseIfNotNULL(m_pCoreSvc);
    ReleaseIfNotNULL(m_pArb);
    ReleaseIfNotNULL(m_pNs);
    ReleaseIfNotNULL(m_pScope);
    ReleaseIfNotNULL(m_pProvFact);
    ReleaseIfNotNULL(m_pNsPath);
    ReleaseIfNotNULL(m_pScopePath);
    delete [] m_pszNamespace;
    delete [] m_pszScope;
    delete [] m_pszUser;
    ReleaseIfNotNULL(m_pRefreshingSvc);
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiCoreApi::InitNew(
    /* [in] */ LPCWSTR pszScope,
    /* [in] */ LPCWSTR pszNamespace,
    /* [in] */ LPCWSTR pszUserName,
    /* [in] */ ULONG uCallFlags,
    /* [in] */ DWORD dwSecFlags,
    /* [in] */ DWORD dwPermissions,
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **pServices
    )
{
    HRESULT hRes;

    // Check parms.
    // ============
    if (pszScope == 0 || pServices == 0 || pszNamespace == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (riid != IID_IWbemServices && riid != IID_IWbemServicesEx)
        return WBEM_E_INVALID_PARAMETER;

    // Create a new object.
    // ====================

    CWmiCoreApi *pNew = new CWmiCoreApi;
    if (!pNew)
        return WBEM_E_OUT_OF_MEMORY;
    pNew->AddRef();

    // Fill it in.
    // ===========

    _IWmiCoreServices *pCoreSvc = CCoreServices::CreateInstance();
    if (!pCoreSvc)
    {
        pNew->Release();
        return WBEM_E_OUT_OF_MEMORY;
    }

    pNew->m_bRepositOnly = TRUE;
    pNew->m_pszUser = Macro_CloneLPWSTR(pszUserName);
    pNew->m_pszNamespace = Macro_CloneLPWSTR(pszNamespace);
    pNew->m_pszScope = Macro_CloneLPWSTR(pszScope);
    pNew->m_pCoreSvc = pCoreSvc;

    IWbemPath *p1 = 0, *p2 = 0;
    hRes = pCoreSvc->CreatePathParser(0, &p1);
    if (FAILED(hRes))
    {
        pNew->Release();
        return hRes;
    }

    hRes = pCoreSvc->CreatePathParser(0, &p2);
    if (FAILED(hRes))
    {
        pNew->Release();
        return hRes;
    }

    pNew->m_pNsPath = p1;
    pNew->m_pScopePath = p2;

    hRes = pNew->m_pNsPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, pszNamespace);
    if (FAILED(hRes))
    {
        pNew->Release();
        return hRes;
    }

    hRes = pNew->m_pScopePath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, pszScope);
    if (FAILED(hRes))
    {
        pNew->Release();
        return hRes;
    }

    hRes = CRepository::OpenNs(pszNamespace, &pNew->m_pNs);
    if (FAILED(hRes))
    {
        pNew->Release();
        return hRes;
    }

    hRes = CRepository::OpenNs(pszScope, &pNew->m_pScope);
    if (FAILED(hRes))
    {
        pNew->Release();
        return hRes;
    }


    // If here, we're good to go.
    // AddRef once more to counteract the CReleaseMe
    // =============================================

    *pServices = (LPVOID *) pNew;

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
// *
HRESULT CWmiCoreApi::QueryInterface(
    REFIID riid,
    LPVOID FAR* ppvObj
    )
{
    *ppvObj = 0;

    if (IID_IUnknown==riid || IID_IWbemServices==riid || IID_IWbemServicesEx==riid )
    {
        *ppvObj = (IWbemServicesEx*)this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//***************************************************************************
//
//***************************************************************************
// *
ULONG CWmiCoreApi::AddRef()
{
    InterlockedIncrement((LONG *) &m_uRefCount);
    return m_uRefCount;
}

//***************************************************************************
//
//***************************************************************************
// *
ULONG CWmiCoreApi::Release()
{
    ULONG uNewCount = InterlockedDecrement((LONG *) &m_uRefCount);
    if (0 != uNewCount)
        return uNewCount;
    delete this;
    return 0;
}



//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiCoreApi::OpenNamespace(
            const BSTR Namespace,
            LONG lFlags,
            IWbemContext* pContext,
            IWbemServices** ppNewNamespace,
            IWbemCallResult** ppResult
            )
{
    HRESULT hRes = 0;
    HRESULT hResTemp = 0;
    CWmiCoreTask *pTask = 0;
    CReleaseMe _1(pTask);
    _IWmiCoreHandle *phTask = 0;
    CReleaseMe _2(phTask);
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _3(pFnz);

    // Check
    // =====

    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Validate.
    // =========

    hRes = ValidateAndLog_OpenNamespace(Namespace, lFlags,pContext, ppNewNamespace,
        ppResult
        );
    if (FAILED(hRes))
        return hRes;

    // Create a finalizer.
    // ===================

    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;

    // Create Primary Task.
    // ====================

    hRes = CWmiCoreTask::CreateTask(this, &pTask);
    if (FAILED(hRes))
        return WBEM_E_OUT_OF_MEMORY;

    hRes = pTask->Init_OpenNamespace(Namespace, lFlags, pContext, pFnz);
    if (FAILED(hRes))
        return hRes;

    phTask = pTask->GetHandleFromTask(pTask);

    // Tell Finalizer.
    // ===============

    hRes = pFnz->SetTaskHandle(phTask);
    if (FAILED(hRes))
        return hRes;

    // Dispatch task, whether sync or semisync.
    // ========================================

    hRes = CWmiCoreTask::DispatchTask(phTask);
    if (FAILED(hRes))
        return hRes;

    // If fully sync, execute this.
    // ============================

    if (ppResult == NULL)
    {
        hRes = pFnz->GetOperationResult(0, &hResTemp);
        if (FAILED(hRes))
            return hRes;
        if (FAILED(hResTemp))
            return hResTemp;
        hRes = pFnz->GetResultObject(0, IID_IWbemServices, (LPVOID *) ppResult);
        return hRes;
    }

    // Else, we are semisync.
    // ======================

    IWbemCallResult *pFinalResult = 0;
    hRes = pFnz->GetResultObject(0, IID_IWbemCallResult, (LPVOID *) &pFinalResult);
    if (FAILED(hRes))
        return hRes;

    *ppResult = pFinalResult;

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::CancelAsyncCall(
    IWbemObjectSink* pSink
    )
{
    HRESULT hRes = 0;
    _IWmiCoreHandle *phTask = 0;
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _1(phTask);
    CReleaseMe _2(pFnz);

    // Quick check.
    // ============
    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::QueryObjectSink(
    long lFlags,
    IWbemObjectSink** ppResponseHandler
    )
{
    // pass to ESS
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
// *
HRESULT CWmiCoreApi::GetObject(
    const BSTR ObjectPath,
    long lFlags,
    IWbemContext* pContext,
    IWbemClassObject** ppObject,
    IWbemCallResult** ppResult
    )
{
    HRESULT hRes = 0, hResTemp = 0;
    CWmiCoreTask *pTask = 0;
    CReleaseMe _1(pTask);
    _IWmiCoreHandle *phTask = 0;
    CReleaseMe _2(phTask);
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _3(pFnz);

    // Check
    // =====

    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Validate.
    // =========

    hRes = ValidateAndLog_GetObject(ObjectPath, lFlags, pContext, ppObject, ppResult);
    if (FAILED(hRes))
        return hRes;

    // Create a finalizer.
    // ===================

    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;

    // Create Primary Task.
    // ====================

    hRes = CWmiCoreTask::CreateTask(this, &pTask);
    if (FAILED(hRes))
        return WBEM_E_OUT_OF_MEMORY;

    hRes = pTask->Init_GetObject(ObjectPath, lFlags, pContext, pFnz);
    if (FAILED(hRes))
        return hRes;

    phTask = pTask->GetHandleFromTask(pTask);

    // Tell Finalizer.
    // ===============

    hRes = pFnz->SetTaskHandle(phTask);
    if (FAILED(hRes))
        return hRes;

    // Dispatch task, whether sync or semisync.
    // ========================================

    hRes = CWmiCoreTask::DispatchTask(phTask);
    if (FAILED(hRes))
        return hRes;

    // If fully sync, execute this.
    // ============================

    if (ppResult == NULL)
    {
        hRes = pFnz->GetOperationResult(0, &hResTemp);
        if (FAILED(hRes))
            return hRes;
        if (FAILED(hResTemp))
            return hResTemp;
        hRes = pFnz->GetResultObject(0, IID_IWbemClassObject, (LPVOID *) ppObject);
        return hRes;
    }

    // Else, we are semisync.
    // ======================

    IWbemCallResult *pFinalResult = 0;
    hRes = pFnz->GetResultObject(0, IID_IWbemCallResult, (LPVOID *) &pFinalResult);
    if (FAILED(hRes))
        return hRes;

    *ppResult = pFinalResult;

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
// *
HRESULT CWmiCoreApi::GetObjectAsync(
    const BSTR ObjectPath,
    long lFlags,
    IWbemContext* pContext,
    IWbemObjectSink* pResponseHandler
    )
{
    HRESULT hRes;
    _IWmiCoreHandle *phTask = 0;
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _1(pFnz);
    CReleaseMe _2(phTask);
    CWmiCoreTask *pTask = 0;
    CReleaseMe _3(pTask);

    // Quick check.
    // ============
    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Validate Parameters.
    // ====================

    hRes = ValidateAndLog_GetObjectAsync(ObjectPath, lFlags, pContext, pResponseHandler);
    if (FAILED(hRes))
        return hRes;

    // Create Finalizer.
    // =================

    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;

    // Create Primary Task.
    // ====================

    hRes = CWmiCoreTask::CreateTask(this, &pTask);
    if (FAILED(hRes))
        return WBEM_E_OUT_OF_MEMORY;

    hRes = pTask->Init_GetObjectAsync(ObjectPath, lFlags, pContext, pFnz);
    if (FAILED(hRes))
        return hRes;

    phTask = pTask->GetHandleFromTask(pTask);

    // Tell Finalizer.
    // ===============

    hRes = pFnz->SetTaskHandle(phTask);
    if (FAILED(hRes))
        return hRes;

    hRes = pFnz->SetDestinationSink(0, IID_IWbemObjectSink, (LPVOID *)&pResponseHandler);
    if (FAILED(hRes))
        return hRes;

    // Dispatch.
    // =========
    hRes = CWmiCoreTask::DispatchTask(phTask);

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
// *
HRESULT CWmiCoreApi::PutClass(
    IWbemClassObject* pObject,
    long lFlags,
    IWbemContext* pContext,
    IWbemCallResult** ppResult
    )
{
    HRESULT hRes = 0, hResTemp = 0;
    CWmiCoreTask *pTask = 0;
    CReleaseMe _1(pTask);
    _IWmiCoreHandle *phTask = 0;
    CReleaseMe _2(phTask);
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _3(pFnz);

    // Check
    // =====

    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Validate.
    // =========

    hRes = ValidateAndLog_PutClass(pObject, lFlags, pContext, ppResult);
    if (FAILED(hRes))
        return hRes;

    // Create a finalizer.
    // ===================

    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;

    // Create Primary Task.
    // ====================

    hRes = CWmiCoreTask::CreateTask(this, &pTask);
    if (FAILED(hRes))
        return WBEM_E_OUT_OF_MEMORY;

    hRes = pTask->Init_PutClass(pObject, lFlags, pContext, pFnz);
    if (FAILED(hRes))
        return hRes;

    phTask = pTask->GetHandleFromTask(pTask);

    // Tell Finalizer.
    // ===============

    hRes = pFnz->SetTaskHandle(phTask);
    if (FAILED(hRes))
        return hRes;

    // Dispatch task, whether sync or semisync.
    // ========================================

    hRes = CWmiCoreTask::DispatchTask(phTask);
    if (FAILED(hRes))
        return hRes;

    // If fully sync, execute this.
    // ============================

    if (ppResult == NULL)
    {
        hRes = pFnz->GetOperationResult(0, &hResTemp);
        if (FAILED(hRes))
            return hRes;
        return hResTemp;
    }

    // Else, we are semisync.
    // ======================

    IWbemCallResult *pFinalResult = 0;
    hRes = pFnz->GetResultObject(0, IID_IWbemCallResult, (LPVOID *) &pFinalResult);
    if (FAILED(hRes))
        return hRes;

    *ppResult = pFinalResult;

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
// *
HRESULT CWmiCoreApi::PutClassAsync(
    IWbemClassObject* pObject,
    long lFlags,
    IWbemContext* pContext,
    IWbemObjectSink* pResponseHandler
    )
{
    HRESULT hRes;
    _IWmiCoreHandle *phTask = 0;
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _1(pFnz);
    CReleaseMe _2(phTask);
    CWmiCoreTask *pTask = 0;
    CReleaseMe _3(pTask);

    // Quick check.
    // ============
    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Validate Parameters.
    // ====================

    hRes = ValidateAndLog_PutClassAsync(pObject, lFlags, pContext, pResponseHandler);
    if (FAILED(hRes))
        return hRes;

    // Create Finalizer.
    // =================

    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;

    // Create Primary Task.
    // ====================

    hRes = CWmiCoreTask::CreateTask(this, &pTask);
    if (FAILED(hRes))
        return WBEM_E_OUT_OF_MEMORY;

    hRes = pTask->Init_PutClassAsync(pObject, lFlags, pContext, pFnz);
    if (FAILED(hRes))
        return hRes;

    phTask = pTask->GetHandleFromTask(pTask);

    // Tell Finalizer.
    // ===============

    hRes = pFnz->SetTaskHandle(phTask);
    if (FAILED(hRes))
        return hRes;

    hRes = pFnz->SetDestinationSink(0, IID_IWbemObjectSink, (LPVOID *)&pResponseHandler);
    if (FAILED(hRes))
        return hRes;

    // Dispatch.
    // =========
    hRes = CWmiCoreTask::DispatchTask(phTask);

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//  *
HRESULT CWmiCoreApi::DeleteClass(
    const BSTR Class,
    long lFlags,
    IWbemContext* pContext,
    IWbemCallResult** ppResult
    )
{
    HRESULT hRes = 0, hResTemp = 0;
    CWmiCoreTask *pTask = 0;
    CReleaseMe _1(pTask);
    _IWmiCoreHandle *phTask = 0;
    CReleaseMe _2(phTask);
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _3(pFnz);

    // Check
    // =====

    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Validate.
    // =========

    hRes = ValidateAndLog_DeleteClass(Class, lFlags, pContext, ppResult);
    if (FAILED(hRes))
        return hRes;

    // Create a finalizer.
    // ===================

    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;

    // Create Primary Task.
    // ====================

    hRes = CWmiCoreTask::CreateTask(this, &pTask);
    if (FAILED(hRes))
        return WBEM_E_OUT_OF_MEMORY;

    hRes = pTask->Init_DeleteClass(Class, lFlags, pContext, pFnz);
    if (FAILED(hRes))
        return hRes;

    phTask = pTask->GetHandleFromTask(pTask);

    // Tell Finalizer.
    // ===============

    hRes = pFnz->SetTaskHandle(phTask);
    if (FAILED(hRes))
        return hRes;

    // Dispatch task, whether sync or semisync.
    // ========================================

    hRes = CWmiCoreTask::DispatchTask(phTask);
    if (FAILED(hRes))
        return hRes;

    // If fully sync, execute this.
    // ============================

    if (ppResult == NULL)
    {
        hRes = pFnz->GetOperationResult(0, &hResTemp);
        if (FAILED(hRes))
            return hRes;
        return hResTemp;
    }

    // Else, we are semisync.
    // ======================

    IWbemCallResult *pFinalResult = 0;
    hRes = pFnz->GetResultObject(0, IID_IWbemCallResult, (LPVOID *) &pFinalResult);
    if (FAILED(hRes))
        return hRes;

    *ppResult = pFinalResult;

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
// *
HRESULT CWmiCoreApi::DeleteClassAsync(
    const BSTR Class,
    long lFlags,
    IWbemContext* pContext,
    IWbemObjectSink* pResponseHandler
    )
{
    HRESULT hRes;
    _IWmiCoreHandle *phTask = 0;
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _1(pFnz);
    CReleaseMe _2(phTask);
    CWmiCoreTask *pTask = 0;
    CReleaseMe _3(pTask);

    // Quick check.
    // ============
    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Validate Parameters.
    // ====================

    hRes = ValidateAndLog_DeleteClassAsync(Class, lFlags, pContext, pResponseHandler);
    if (FAILED(hRes))
        return hRes;

    // Create Finalizer.
    // =================

    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;

    // Create Primary Task.
    // ====================

    hRes = CWmiCoreTask::CreateTask(this, &pTask);
    if (FAILED(hRes))
        return WBEM_E_OUT_OF_MEMORY;

    hRes = pTask->Init_DeleteClassAsync(Class, lFlags, pContext, pFnz);
    if (FAILED(hRes))
        return hRes;

    phTask = pTask->GetHandleFromTask(pTask);

    // Tell Finalizer.
    // ===============

    hRes = pFnz->SetTaskHandle(phTask);
    if (FAILED(hRes))
        return hRes;

    hRes = pFnz->SetDestinationSink(0, IID_IWbemObjectSink, (LPVOID *)&pResponseHandler);
    if (FAILED(hRes))
        return hRes;

    // Dispatch.
    // =========
    hRes = CWmiCoreTask::DispatchTask(phTask);

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
// *
HRESULT CWmiCoreApi::CreateClassEnum(
    const BSTR Superclass,
    long lFlags,
    IWbemContext* pContext,
    IEnumWbemClassObject** ppEnum
    )
{
    HRESULT hRes = 0, hResTemp = 0;
    CWmiCoreTask *pTask = 0;
    CReleaseMe _1(pTask);
    _IWmiCoreHandle *phTask = 0;
    CReleaseMe _2(phTask);
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _3(pFnz);

    // Check
    // =====

    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Validate.
    // =========

    hRes = ValidateAndLog_CreateClassEnum(Superclass, lFlags, pContext, ppEnum);
    if (FAILED(hRes))
        return hRes;

    // Create a finalizer.
    // ===================

    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;

    // Create Primary Task.
    // ====================

    hRes = CWmiCoreTask::CreateTask(this, &pTask);
    if (FAILED(hRes))
        return WBEM_E_OUT_OF_MEMORY;

    hRes = pTask->Init_CreateClassEnum(Superclass, lFlags, pContext, pFnz);
    if (FAILED(hRes))
        return hRes;

    phTask = pTask->GetHandleFromTask(pTask);

    // Tell Finalizer.
    // ===============

    hRes = pFnz->SetTaskHandle(phTask);
    if (FAILED(hRes))
        return hRes;

    // Dispatch task, whether sync or semisync.
    // ========================================

    hRes = CWmiCoreTask::DispatchTask(phTask);
    if (FAILED(hRes))
        return hRes;

    // Dispatch task, whether sync or semisync.
    // ========================================

    hRes = CWmiCoreTask::DispatchTask(phTask);
    if (FAILED(hRes))
        return hRes;

    hRes = pFnz->GetOperationResult(0, &hResTemp);
    if (FAILED(hRes))
        return hRes;
    if (FAILED(hResTemp))
        return hResTemp;
    hRes = pFnz->GetResultObject(lFlags, IID_IEnumWbemClassObject, (LPVOID *) ppEnum);

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//  *

HRESULT CWmiCoreApi::CreateClassEnumAsync(
    const BSTR Superclass,
    long lFlags,
    IWbemContext* pContext,
    IWbemObjectSink* pResponseHandler
    )
{
    HRESULT hRes;
    _IWmiCoreHandle *phTask = 0;
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _1(pFnz);
    CReleaseMe _2(phTask);
    CWmiCoreTask *pTask = 0;
    CReleaseMe _3(pTask);

    // Quick check.
    // ============
    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Validate Parameters.
    // ====================

    hRes = ValidateAndLog_CreateClassEnumAsync(Superclass, lFlags, pContext, pResponseHandler);
    if (FAILED(hRes))
        return hRes;

    // Create Finalizer.
    // =================

    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;

    // Create Primary Task.
    // ====================

    hRes = CWmiCoreTask::CreateTask(this, &pTask);
    if (FAILED(hRes))
        return WBEM_E_OUT_OF_MEMORY;

    hRes = pTask->Init_CreateClassEnumAsync(Superclass, lFlags, pContext, pFnz);
    if (FAILED(hRes))
        return hRes;

    phTask = pTask->GetHandleFromTask(pTask);

    // Tell Finalizer.
    // ===============

    hRes = pFnz->SetTaskHandle(phTask);
    if (FAILED(hRes))
        return hRes;

    hRes = pFnz->SetDestinationSink(0, IID_IWbemObjectSink, (LPVOID *)&pResponseHandler);
    if (FAILED(hRes))
        return hRes;

    // Dispatch.
    // =========
    hRes = CWmiCoreTask::DispatchTask(phTask);

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
// *

HRESULT CWmiCoreApi::PutInstance(
    IWbemClassObject* pInst,
    long lFlags,
    IWbemContext* pContext,
    IWbemCallResult** ppResult
    )
{
    HRESULT hRes = 0, hResTemp = 0;
    CWmiCoreTask *pTask = 0;
    CReleaseMe _1(pTask);
    _IWmiCoreHandle *phTask = 0;
    CReleaseMe _2(phTask);
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _3(pFnz);

    // Check
    // =====

    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Validate.
    // =========

    hRes = ValidateAndLog_PutInstance(pInst, lFlags, pContext, ppResult);
    if (FAILED(hRes))
        return hRes;

    // Create a finalizer.
    // ===================

    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;

    // Create Primary Task.
    // ====================

    hRes = CWmiCoreTask::CreateTask(this, &pTask);
    if (FAILED(hRes))
        return WBEM_E_OUT_OF_MEMORY;

    hRes = pTask->Init_PutInstance(pInst, lFlags, pContext, pFnz);
    if (FAILED(hRes))
        return hRes;

    phTask = pTask->GetHandleFromTask(pTask);

    // Tell Finalizer.
    // ===============

    hRes = pFnz->SetTaskHandle(phTask);
    if (FAILED(hRes))
        return hRes;

    // Dispatch task, whether sync or semisync.
    // ========================================

    hRes = CWmiCoreTask::DispatchTask(phTask);
    if (FAILED(hRes))
        return hRes;

    // If fully sync, execute this.
    // ============================

    if (ppResult == NULL)
    {
        hRes = pFnz->GetOperationResult(0, &hResTemp);
        if (FAILED(hRes))
            return hRes;
        return hResTemp;
    }

    // Else, we are semisync.
    // ======================

    IWbemCallResult *pFinalResult = 0;
    hRes = pFnz->GetResultObject(0, IID_IWbemCallResult, (LPVOID *) &pFinalResult);
    if (FAILED(hRes))
        return hRes;

    *ppResult = pFinalResult;

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
// *
HRESULT CWmiCoreApi::PutInstanceAsync(
    IWbemClassObject* pInst,
    long lFlags,
    IWbemContext* pContext,
    IWbemObjectSink* pResponseHandler
    )
{
    HRESULT hRes;
    _IWmiCoreHandle *phTask = 0;
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _1(pFnz);
    CReleaseMe _2(phTask);
    CWmiCoreTask *pTask = 0;
    CReleaseMe _3(pTask);

    // Quick check.
    // ============
    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Validate Parameters.
    // ====================

    hRes = ValidateAndLog_PutInstanceAsync(pInst, lFlags, pContext, pResponseHandler);
    if (FAILED(hRes))
        return hRes;

    // Create Finalizer.
    // =================

    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;

    // Create Primary Task.
    // ====================

    hRes = CWmiCoreTask::CreateTask(this, &pTask);
    if (FAILED(hRes))
        return WBEM_E_OUT_OF_MEMORY;

    hRes = pTask->Init_PutInstanceAsync(pInst, lFlags, pContext, pFnz);
    if (FAILED(hRes))
        return hRes;

    phTask = pTask->GetHandleFromTask(pTask);

    // Tell Finalizer.
    // ===============

    hRes = pFnz->SetTaskHandle(phTask);
    if (FAILED(hRes))
        return hRes;

    hRes = pFnz->SetDestinationSink(0, IID_IWbemObjectSink, (LPVOID *)&pResponseHandler);
    if (FAILED(hRes))
        return hRes;

    // Dispatch.
    // =========
    hRes = CWmiCoreTask::DispatchTask(phTask);

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
// *

HRESULT CWmiCoreApi::DeleteInstance(
    const BSTR ObjectPath,
    long lFlags,
    IWbemContext* pContext,
    IWbemCallResult** ppResult
    )
{
    HRESULT hRes = 0, hResTemp = 0;
    CWmiCoreTask *pTask = 0;
    CReleaseMe _1(pTask);
    _IWmiCoreHandle *phTask = 0;
    CReleaseMe _2(phTask);
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _3(pFnz);

    // Check
    // =====

    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Validate.
    // =========

    hRes = ValidateAndLog_DeleteInstance(ObjectPath, lFlags, pContext, ppResult);
    if (FAILED(hRes))
        return hRes;

    // Create a finalizer.
    // ===================

    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;

    // Create Primary Task.
    // ====================

    hRes = CWmiCoreTask::CreateTask(this, &pTask);
    if (FAILED(hRes))
        return WBEM_E_OUT_OF_MEMORY;

    hRes = pTask->Init_DeleteInstance(ObjectPath, lFlags, pContext, pFnz);
    if (FAILED(hRes))
        return hRes;

    phTask = pTask->GetHandleFromTask(pTask);

    // Tell Finalizer.
    // ===============

    hRes = pFnz->SetTaskHandle(phTask);
    if (FAILED(hRes))
        return hRes;

    // Dispatch task, whether sync or semisync.
    // ========================================

    hRes = CWmiCoreTask::DispatchTask(phTask);
    if (FAILED(hRes))
        return hRes;

    // If fully sync, execute this.
    // ============================

    if (ppResult == NULL)
    {
        hRes = pFnz->GetOperationResult(0, &hResTemp);
        if (FAILED(hRes))
            return hRes;
        return hResTemp;
    }

    // Else, we are semisync.
    // ======================

    IWbemCallResult *pFinalResult = 0;
    hRes = pFnz->GetResultObject(0, IID_IWbemCallResult, (LPVOID *) &pFinalResult);
    if (FAILED(hRes))
        return hRes;

    *ppResult = pFinalResult;

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
// *
HRESULT CWmiCoreApi::DeleteInstanceAsync(
    const BSTR ObjectPath,
    long lFlags,
    IWbemContext* pContext,
    IWbemObjectSink* pResponseHandler
    )
{
    HRESULT hRes;
    _IWmiCoreHandle *phTask = 0;
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _1(pFnz);
    CReleaseMe _2(phTask);
    CWmiCoreTask *pTask = 0;
    CReleaseMe _3(pTask);

    // Quick check.
    // ============
    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Validate Parameters.
    // ====================

    hRes = ValidateAndLog_DeleteInstanceAsync(ObjectPath, lFlags, pContext, pResponseHandler);
    if (FAILED(hRes))
        return hRes;

    // Create Finalizer.
    // =================

    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;

    // Create Primary Task.
    // ====================

    hRes = CWmiCoreTask::CreateTask(this, &pTask);
    if (FAILED(hRes))
        return WBEM_E_OUT_OF_MEMORY;

    hRes = pTask->Init_DeleteInstanceAsync(ObjectPath, lFlags, pContext, pFnz);
    if (FAILED(hRes))
        return hRes;

    phTask = pTask->GetHandleFromTask(pTask);

    // Tell Finalizer.
    // ===============

    hRes = pFnz->SetTaskHandle(phTask);
    if (FAILED(hRes))
        return hRes;

    hRes = pFnz->SetDestinationSink(0, IID_IWbemObjectSink, (LPVOID *)&pResponseHandler);
    if (FAILED(hRes))
        return hRes;

    // Dispatch.
    // =========
    hRes = CWmiCoreTask::DispatchTask(phTask);

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
// **
HRESULT CWmiCoreApi::CreateInstanceEnum(
    const BSTR Class,
    long lFlags,
    IWbemContext* pContext,
    IEnumWbemClassObject** ppEnum
    )
{
    HRESULT hRes = 0, hResTemp = 0;
    CWmiCoreTask *pTask = 0;
    CReleaseMe _1(pTask);
    _IWmiCoreHandle *phTask = 0;
    CReleaseMe _2(phTask);
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _3(pFnz);

    // Check
    // =====

    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Validate.
    // =========

    hRes = ValidateAndLog_CreateInstanceEnum(Class, lFlags, pContext, ppEnum);
    if (FAILED(hRes))
        return hRes;

    // Create Finalizer.
    // =================

    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;

    // Create Primary Task.
    // ====================

    hRes = CWmiCoreTask::CreateTask(this, &pTask);
    if (FAILED(hRes))
        return WBEM_E_OUT_OF_MEMORY;

    hRes = pTask->Init_CreateClassEnum(Class, lFlags, pContext, pFnz);
    if (FAILED(hRes))
        return hRes;

    phTask = pTask->GetHandleFromTask(pTask);

    // Tell Finalizer.
    // ===============

    hRes = pFnz->SetTaskHandle(phTask);
    if (FAILED(hRes))
        return hRes;

    // Dispatch task, whether sync or semisync.
    // ========================================

    hRes = CWmiCoreTask::DispatchTask(phTask);
    if (FAILED(hRes))
        return hRes;

    hRes = pFnz->GetOperationResult(0, &hResTemp);
    if (FAILED(hRes))
        return hRes;
    if (FAILED(hResTemp))
        return hResTemp;
    hRes = pFnz->GetResultObject(lFlags, IID_IEnumWbemClassObject, (LPVOID *) ppEnum);

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
// **
HRESULT CWmiCoreApi::CreateInstanceEnumAsync(
    const BSTR Class,
    long lFlags,
    IWbemContext* pContext,
    IWbemObjectSink* pResponseHandler
    )
{
    HRESULT hRes;
    _IWmiCoreHandle *phTask = 0;
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _1(pFnz);
    CReleaseMe _2(phTask);
    CWmiCoreTask *pTask = 0;
    CReleaseMe _3(pTask);

    // Quick check.
    // ============
    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Validate Parameters.
    // ====================

    hRes = ValidateAndLog_CreateInstanceEnumAsync(Class, lFlags, pContext, pResponseHandler);
    if (FAILED(hRes))
        return hRes;

    // Create Finalizer.
    // =================

    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;

    // Create Primary Task.
    // ====================

    hRes = CWmiCoreTask::CreateTask(this, &pTask);
    if (FAILED(hRes))
        return WBEM_E_OUT_OF_MEMORY;

    hRes = pTask->Init_CreateInstanceEnumAsync(Class, lFlags, pContext, pFnz);
    if (FAILED(hRes))
        return hRes;

    phTask = pTask->GetHandleFromTask(pTask);

    // Tell Finalizer.
    // ===============

    hRes = pFnz->SetTaskHandle(phTask);
    if (FAILED(hRes))
        return hRes;

    hRes = pFnz->SetDestinationSink(0, IID_IWbemObjectSink, (LPVOID *)&pResponseHandler);
    if (FAILED(hRes))
        return hRes;

    // Dispatch.
    // =========
    hRes = CWmiCoreTask::DispatchTask(phTask);

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
// **
HRESULT CWmiCoreApi::ExecQuery(
    const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext* pContext,
    IEnumWbemClassObject** ppEnum
    )
{
    HRESULT hRes = 0, hResTemp = 0;
    CWmiCoreTask *pTask = 0;
    CReleaseMe _1(pTask);
    _IWmiCoreHandle *phTask = 0;
    CReleaseMe _2(phTask);
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _3(pFnz);

    // Check
    // =====

    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Validate.
    // =========

    hRes = ValidateAndLog_ExecQuery(QueryLanguage, Query, lFlags, pContext, ppEnum);
    if (FAILED(hRes))
        return hRes;

    // Create Finalizer.
    // =================

    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;

    // Create Primary Task.
    // ====================

    hRes = CWmiCoreTask::CreateTask(this, &pTask);
    if (FAILED(hRes))
        return WBEM_E_OUT_OF_MEMORY;

    hRes = pTask->Init_ExecQuery(QueryLanguage, Query, lFlags,pContext, pFnz);
    if (FAILED(hRes))
        return hRes;

    phTask = pTask->GetHandleFromTask(pTask);

    // Tell Finalizer.
    // ===============

    hRes = pFnz->SetTaskHandle(phTask);
    if (FAILED(hRes))
        return hRes;

    // Dispatch task, whether sync or semisync.
    // ========================================

    hRes = CWmiCoreTask::DispatchTask(phTask);
    if (FAILED(hRes))
        return hRes;


    // Dispatch task, whether sync or semisync.
    // ========================================

    hRes = CWmiCoreTask::DispatchTask(phTask);
    if (FAILED(hRes))
        return hRes;

    hRes = pFnz->GetOperationResult(0, &hResTemp);
    if (FAILED(hRes))
        return hRes;
    if (FAILED(hResTemp))
        return hResTemp;
    hRes = pFnz->GetResultObject(lFlags, IID_IEnumWbemClassObject, (LPVOID *) ppEnum);
    return hRes;
}

//***************************************************************************
//
//***************************************************************************
// **
HRESULT CWmiCoreApi::ExecQueryAsync(
    const BSTR QueryFormat,
    const BSTR Query,
    long lFlags,
    IWbemContext* pContext,
    IWbemObjectSink* pResponseHandler
    )
{
    HRESULT hRes;
    _IWmiCoreHandle *phTask = 0;
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _1(pFnz);
    CReleaseMe _2(phTask);
    CWmiCoreTask *pTask = 0;
    CReleaseMe _3(pTask);

    // Quick check.
    // ============
    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Validate Parameters.
    // ====================

    hRes = ValidateAndLog_ExecQueryAsync(QueryFormat, Query, lFlags, pContext, pResponseHandler);
    if (FAILED(hRes))
        return hRes;

    // Create Finalizer.
    // =================

    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;

    // Create Primary Task.
    // ====================

    hRes = CWmiCoreTask::CreateTask(this, &pTask);
    if (FAILED(hRes))
        return WBEM_E_OUT_OF_MEMORY;

    hRes = pTask->Init_ExecQueryAsync(QueryFormat, Query, lFlags, pContext, pFnz);
    if (FAILED(hRes))
        return hRes;

    phTask = pTask->GetHandleFromTask(pTask);

    // Tell Finalizer.
    // ===============

    hRes = pFnz->SetTaskHandle(phTask);
    if (FAILED(hRes))
        return hRes;

    hRes = pFnz->SetDestinationSink(0, IID_IWbemObjectSink, (LPVOID *)&pResponseHandler);
    if (FAILED(hRes))
        return hRes;

    // Dispatch.
    // =========
    hRes = CWmiCoreTask::DispatchTask(phTask);

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ExecNotificationQuery(
    const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext* pContext,
    IEnumWbemClassObject** ppEnum
    )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ExecNotificationQueryAsync(
    const BSTR QueryFormat,
    const BSTR Query,
    long lFlags,
    IWbemContext* pContext,
    IWbemObjectSink* pResponseHandler
    )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
// **
HRESULT CWmiCoreApi::ExecMethod(
    const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext *pCtx,
    IWbemClassObject *pInParams,
    IWbemClassObject **ppOutParams,
    IWbemCallResult  **ppCallResult
    )
{
    HRESULT hRes = 0, hResTemp = 0;
    CWmiCoreTask *pTask = 0;
    CReleaseMe _1(pTask);
    _IWmiCoreHandle *phTask = 0;
    CReleaseMe _2(phTask);
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _3(pFnz);

    // Check
    // =====

    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Validate.
    // =========

    hRes = ValidateAndLog_ExecMethod(ObjectPath, MethodName, lFlags, pCtx, pInParams, ppOutParams, ppCallResult);
    if (FAILED(hRes))
        return hRes;

    // Create Finalizer.
    // =================

    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;

    // Create Primary Task.
    // ====================

    hRes = CWmiCoreTask::CreateTask(this, &pTask);
    if (FAILED(hRes))
        return WBEM_E_OUT_OF_MEMORY;

    hRes = pTask->Init_ExecMethod(ObjectPath, MethodName, lFlags, pCtx, pInParams, pFnz);
    if (FAILED(hRes))
        return hRes;

    phTask = pTask->GetHandleFromTask(pTask);

    // Tell Finalizer.
    // ===============

    hRes = pFnz->SetTaskHandle(phTask);
    if (FAILED(hRes))
        return hRes;

    // Dispatch task, whether sync or semisync.
    // ========================================

    hRes = CWmiCoreTask::DispatchTask(phTask);
    if (FAILED(hRes))
        return hRes;

    // If fully sync, execute this.
    // ============================

    if (ppCallResult == NULL)
    {
        hRes = pFnz->GetOperationResult(0, &hResTemp);
        if (FAILED(hRes))
            return hRes;
        if (FAILED(hResTemp))
            return hResTemp;
        hRes = pFnz->GetResultObject(0, IID_IWbemClassObject, (LPVOID *) ppOutParams);
        return hRes;
    }

    // Else, we are semisync.
    // ======================

    IWbemCallResult *pFinalResult = 0;
    hRes = pFnz->GetResultObject(0, IID_IWbemCallResult, (LPVOID *) &pFinalResult);
    if (FAILED(hRes))
        return hRes;

    *ppCallResult = pFinalResult;

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
// **
HRESULT CWmiCoreApi::ExecMethodAsync(
    const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext *pCtx,
    IWbemClassObject *pInParams,
    IWbemObjectSink* pResponseHandler
    )
{
    HRESULT hRes;
    _IWmiCoreHandle *phTask = 0;
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _1(pFnz);
    CReleaseMe _2(phTask);
    CWmiCoreTask *pTask = 0;
    CReleaseMe _3(pTask);

    // Quick check.
    // ============
    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Validate Parameters.
    // ====================

    hRes = ValidateAndLog_ExecMethodAsync(ObjectPath, MethodName, lFlags, pCtx, pInParams, pResponseHandler);
    if (FAILED(hRes))
        return hRes;

    // Create Finalizer.
    // =================

    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;

    // Create Primary Task.
    // ====================

    hRes = CWmiCoreTask::CreateTask(this, &pTask);
    if (FAILED(hRes))
        return WBEM_E_OUT_OF_MEMORY;

    hRes = pTask->Init_ExecMethodAsync(ObjectPath, MethodName, lFlags, pCtx, pInParams, pFnz);
    if (FAILED(hRes))
        return hRes;

    phTask = pTask->GetHandleFromTask(pTask);

    // Tell Finalizer.
    // ===============

    hRes = pFnz->SetTaskHandle(phTask);
    if (FAILED(hRes))
        return hRes;

    hRes = pFnz->SetDestinationSink(0, IID_IWbemObjectSink, (LPVOID *)&pResponseHandler);
    if (FAILED(hRes))
        return hRes;

    // Dispatch.
    // =========
    hRes = CWmiCoreTask::DispatchTask(phTask);

    return hRes;
}



//***************************************************************************
//
//***************************************************************************
// **
HRESULT CWmiCoreApi::Open(
            /* [in] */ const BSTR strScope,
            /* [in] */ const BSTR strParam,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServicesEx __RPC_FAR *__RPC_FAR *ppScope,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppResult
            )
{
    HRESULT hRes = 0, hResTemp = 0;
    CWmiCoreTask *pTask = 0;
    CReleaseMe _1(pTask);
    _IWmiCoreHandle *phTask = 0;
    CReleaseMe _2(phTask);
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _3(pFnz);

    // Check
    // =====

    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Validate.
    // =========

    hRes = ValidateAndLog_Open(strScope, strParam, lFlags, pCtx, ppScope, ppResult);
    if (FAILED(hRes))
        return hRes;


    // Create Finalizer.
    // =================

    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;

    // Create Primary Task.
    // ====================

    hRes = CWmiCoreTask::CreateTask(this, &pTask);
    if (FAILED(hRes))
        return WBEM_E_OUT_OF_MEMORY;

    hRes = pTask->Init_Open(strScope, strParam, lFlags, pCtx, pFnz);
    if (FAILED(hRes))
        return hRes;

    phTask = pTask->GetHandleFromTask(pTask);

    // Tell Finalizer.
    // ===============

    hRes = pFnz->SetTaskHandle(phTask);
    if (FAILED(hRes))
        return hRes;

    // Dispatch task, whether sync or semisync.
    // ========================================

    hRes = CWmiCoreTask::DispatchTask(phTask);
    if (FAILED(hRes))
        return hRes;

    // If fully sync, execute this.
    // ============================

    if (ppResult == NULL)
    {
        hRes = pFnz->GetOperationResult(0, &hResTemp);
        if (FAILED(hRes))
            return hRes;
        if (FAILED(hResTemp))
            return hResTemp;
        hRes = pFnz->GetResultObject(0, IID_IWbemServicesEx, (LPVOID *) ppScope);
        return hRes;
    }

    // Else, we are semisync.
    // ======================

    IWbemCallResultEx *pFinalResult = 0;
    hRes = pFnz->GetResultObject(0, IID_IWbemCallResultEx, (LPVOID *) &pFinalResult);
    if (FAILED(hRes))
        return hRes;

    *ppResult = pFinalResult;

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
// **
HRESULT CWmiCoreApi::OpenAsync(
            /* [in] */ const BSTR strScope,
            /* [in] */ const BSTR strParam,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSinkEx __RPC_FAR *pResponseHandler
            )
{
    HRESULT hRes;
    _IWmiCoreHandle *phTask = 0;
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _1(pFnz);
    CReleaseMe _2(phTask);
    CWmiCoreTask *pTask = 0;
    CReleaseMe _3(pTask);

    // Quick check.
    // ============
    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Validate Parameters.
    // ====================

    hRes = ValidateAndLog_OpenAsync(strScope, strParam, lFlags, pCtx, pResponseHandler);
    if (FAILED(hRes))
        return hRes;

    // Create Finalizer.
    // =================

    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;

    // Create Primary Task.
    // ====================

    hRes = CWmiCoreTask::CreateTask(this, &pTask);
    if (FAILED(hRes))
        return WBEM_E_OUT_OF_MEMORY;

    hRes = pTask->Init_OpenAsync(strScope, strParam, lFlags, pCtx, pFnz);
    if (FAILED(hRes))
        return hRes;

    phTask = pTask->GetHandleFromTask(pTask);

    // Tell Finalizer.
    // ===============

    hRes = pFnz->SetTaskHandle(phTask);
    if (FAILED(hRes))
        return hRes;

    hRes = pFnz->SetDestinationSink(0, IID_IWbemObjectSink, (LPVOID *)&pResponseHandler);
    if (FAILED(hRes))
        return hRes;

    // Dispatch.
    // =========
    hRes = CWmiCoreTask::DispatchTask(phTask);

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
// **

HRESULT CWmiCoreApi::Add(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    HRESULT hRes = 0, hResTemp = 0;
    CWmiCoreTask *pTask = 0;
    CReleaseMe _1(pTask);
    _IWmiCoreHandle *phTask = 0;
    CReleaseMe _2(phTask);
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _3(pFnz);

    // Check
    // =====

    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Validate.
    // =========

    hRes = ValidateAndLog_Add(strObjectPath, lFlags, pCtx, ppCallResult);
    if (FAILED(hRes))
        return hRes;

    // Create Finalizer.
    // =================

    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;

    // Create Primary Task.
    // ====================

    hRes = CWmiCoreTask::CreateTask(this, &pTask);
    if (FAILED(hRes))
        return WBEM_E_OUT_OF_MEMORY;

    hRes = pTask->Init_Add(strObjectPath, lFlags, pCtx, pFnz);
    if (FAILED(hRes))
        return hRes;

    phTask = pTask->GetHandleFromTask(pTask);

    // Tell Finalizer.
    // ===============

    hRes = pFnz->SetTaskHandle(phTask);
    if (FAILED(hRes))
        return hRes;

    // Dispatch task, whether sync or semisync.
    // ========================================

    hRes = CWmiCoreTask::DispatchTask(phTask);
    if (FAILED(hRes))
        return hRes;

    // If fully sync, execute this.
    // ============================

    if (ppCallResult == NULL)
    {
        hRes = pFnz->GetOperationResult(0, &hResTemp);
        if (FAILED(hRes))
            return hRes;
        return hResTemp;
    }

    // Else, we are semisync.
    // ======================

    IWbemCallResultEx *pFinalResult = 0;
    hRes = pFnz->GetResultObject(0, IID_IWbemCallResultEx, (LPVOID *) &pFinalResult);
    if (FAILED(hRes))
        return hRes;

    *ppCallResult = pFinalResult;

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
// *
HRESULT CWmiCoreApi::AddAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    HRESULT hRes;
    _IWmiCoreHandle *phTask = 0;
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _1(pFnz);
    CReleaseMe _2(phTask);
    CWmiCoreTask *pTask = 0;
    CReleaseMe _3(pTask);

    // Quick check.
    // ============
    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Validate Parameters.
    // ====================

    hRes = ValidateAndLog_AddAsync(strObjectPath, lFlags, pCtx, pResponseHandler);
    if (FAILED(hRes))
        return hRes;

    // Create Finalizer.
    // =================

    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;

    // Create Primary Task.
    // ====================

    hRes = CWmiCoreTask::CreateTask(this, &pTask);
    if (FAILED(hRes))
        return WBEM_E_OUT_OF_MEMORY;

    hRes = pTask->Init_AddAsync(strObjectPath, lFlags, pCtx, pFnz);
    if (FAILED(hRes))
        return hRes;

    phTask = pTask->GetHandleFromTask(pTask);

    // Tell Finalizer.
    // ===============

    hRes = pFnz->SetTaskHandle(phTask);
    if (FAILED(hRes))
        return hRes;

    hRes = pFnz->SetDestinationSink(0, IID_IWbemObjectSink, (LPVOID *)&pResponseHandler);
    if (FAILED(hRes))
        return hRes;

    // Dispatch.
    // =========
    hRes = CWmiCoreTask::DispatchTask(phTask);

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
// **
HRESULT CWmiCoreApi::Remove(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult)
{
    HRESULT hRes = 0, hResTemp;
    CWmiCoreTask *pTask = 0;
    CReleaseMe _1(pTask);
    _IWmiCoreHandle *phTask = 0;
    CReleaseMe _2(phTask);
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _3(pFnz);

    // Check
    // =====

    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Create Finalizer.
    // =================

    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;

    // Validate.
    // =========

    hRes = ValidateAndLog_Remove(strObjectPath, lFlags, pCtx, ppCallResult);
    if (FAILED(hRes))
        return hRes;

    // Create Primary Task.
    // ====================

    hRes = CWmiCoreTask::CreateTask(this, &pTask);
    if (FAILED(hRes))
        return WBEM_E_OUT_OF_MEMORY;

    hRes = pTask->Init_Remove(strObjectPath, lFlags, pCtx, pFnz);
    if (FAILED(hRes))
        return hRes;

    phTask = pTask->GetHandleFromTask(pTask);

    // Tell Finalizer.
    // ===============

    hRes = pFnz->SetTaskHandle(phTask);
    if (FAILED(hRes))
        return hRes;

    // Dispatch task, whether sync or semisync.
    // ========================================

    hRes = CWmiCoreTask::DispatchTask(phTask);
    if (FAILED(hRes))
        return hRes;

    // If fully sync, execute this.
    // ============================

    if (ppCallResult == NULL)
    {
        hRes = pFnz->GetOperationResult(0, &hResTemp);
        if (FAILED(hRes))
            return hRes;
        return hResTemp;
    }

    // Else, we are semisync.
    // ======================

    IWbemCallResultEx *pFinalResult = 0;
    hRes = pFnz->GetResultObject(0, IID_IWbemCallResultEx, (LPVOID *) &pFinalResult);
    if (FAILED(hRes))
        return hRes;

    *ppCallResult = pFinalResult;

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
// **
HRESULT CWmiCoreApi::RemoveAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hRes;
    _IWmiCoreHandle *phTask = 0;
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _1(pFnz);
    CReleaseMe _2(phTask);
    CWmiCoreTask *pTask = 0;
    CReleaseMe _3(pTask);

    // Quick check.
    // ============
    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Validate Parameters.
    // ====================

    hRes = ValidateAndLog_RemoveAsync(strObjectPath, lFlags, pCtx, pResponseHandler);
    if (FAILED(hRes))
        return hRes;

    // Create Finalizer.
    // =================

    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;

    // Create Primary Task.
    // ====================

    hRes = CWmiCoreTask::CreateTask(this, &pTask);
    if (FAILED(hRes))
        return WBEM_E_OUT_OF_MEMORY;

    hRes = pTask->Init_RemoveAsync(strObjectPath, lFlags, pCtx, pFnz);
    if (FAILED(hRes))
        return hRes;

    phTask = pTask->GetHandleFromTask(pTask);

    // Tell Finalizer.
    // ===============

    hRes = pFnz->SetTaskHandle(phTask);
    if (FAILED(hRes))
        return hRes;

    hRes = pFnz->SetDestinationSink(0, IID_IWbemObjectSink, (LPVOID *)&pResponseHandler);
    if (FAILED(hRes))
        return hRes;

    // Dispatch.
    // =========
    hRes = CWmiCoreTask::DispatchTask(phTask);

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
// *
HRESULT CWmiCoreApi::RefreshObject(
            /* [out][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pTarget,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    HRESULT hRes = 0, hResTemp = 0;
    CWmiCoreTask *pTask = 0;
    CReleaseMe _1(pTask);
    _IWmiCoreHandle *phTask = 0;
    CReleaseMe _2(phTask);
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _3(pFnz);

    // Check
    // =====

    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Validate.
    // =========

    hRes = ValidateAndLog_RefreshObject(pTarget, lFlags, pCtx, ppCallResult);
    if (FAILED(hRes))
        return hRes;

    // Create Finalizer.
    // =================

    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;

    // Create Primary Task.
    // ====================

    hRes = CWmiCoreTask::CreateTask(this, &pTask);
    if (FAILED(hRes))
        return WBEM_E_OUT_OF_MEMORY;

    hRes = pTask->Init_RefreshObject(pTarget, lFlags, pCtx, pFnz);
    if (FAILED(hRes))
        return hRes;

    phTask = pTask->GetHandleFromTask(pTask);

    // Tell Finalizer.
    // ===============

    hRes = pFnz->SetTaskHandle(phTask);
    if (FAILED(hRes))
        return hRes;

    // Dispatch task, whether sync or semisync.
    // ========================================

    hRes = CWmiCoreTask::DispatchTask(phTask);
    if (FAILED(hRes))
        return hRes;

    // If fully sync, execute this.
    // ============================

    if (ppCallResult == NULL)
    {
        hRes = pFnz->GetOperationResult(0, &hResTemp);
        if (FAILED(hRes))
            return hRes;
        if (FAILED(hResTemp))
            return hResTemp;
        hRes = pFnz->GetResultObject(0, IID_IWbemClassObject, (LPVOID *) pTarget);
        return hRes;
    }

    // Else, we are semisync.
    // ======================

    IWbemCallResultEx *pFinalResult = 0;
    hRes = pFnz->GetResultObject(0, IID_IWbemCallResultEx, (LPVOID *) &pFinalResult);
    if (FAILED(hRes))
        return hRes;

    *ppCallResult = pFinalResult;

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
// *
HRESULT CWmiCoreApi::RefreshObjectAsync(
            /* [out][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pTarget,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSinkEx __RPC_FAR *pResponseHandler
            )
{
    HRESULT hRes;
    _IWmiCoreHandle *phTask = 0;
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _1(pFnz);
    CReleaseMe _2(phTask);
    CWmiCoreTask *pTask = 0;
    CReleaseMe _3(pTask);

    // Quick check.
    // ============
    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Validate Parameters.
    // ====================

    hRes = ValidateAndLog_RefreshObjectAsync(pTarget, lFlags, pCtx, pResponseHandler);
    if (FAILED(hRes))
        return hRes;

    // Create Finalizer.
    // =================

    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;

    // Create Primary Task.
    // ====================

    hRes = CWmiCoreTask::CreateTask(this, &pTask);
    if (FAILED(hRes))
        return WBEM_E_OUT_OF_MEMORY;

    hRes = pTask->Init_RefreshObjectAsync(pTarget, lFlags, pCtx, pFnz);
    if (FAILED(hRes))
        return hRes;

    phTask = pTask->GetHandleFromTask(pTask);

    // Tell Finalizer.
    // ===============

    hRes = pFnz->SetTaskHandle(phTask);
    if (FAILED(hRes))
        return hRes;

    hRes = pFnz->SetDestinationSink(0, IID_IWbemObjectSink, (LPVOID *)&pResponseHandler);
    if (FAILED(hRes))
        return hRes;

    // Dispatch.
    // =========
    hRes = CWmiCoreTask::DispatchTask(phTask);

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::RenameObject(
            /* [in] */ const BSTR strOldObjectPath,
            /* [in] */ const BSTR strNewObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    HRESULT hRes = 0, hResTemp = 0;
    CWmiCoreTask *pTask = 0;
    CReleaseMe _1(pTask);
    _IWmiCoreHandle *phTask = 0;
    CReleaseMe _2(phTask);
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _3(pFnz);

    // Check
    // =====

    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Validate.
    // =========

    hRes = ValidateAndLog_RenameObject(strOldObjectPath, strNewObjectPath, lFlags, pCtx, ppCallResult);
    if (FAILED(hRes))
        return hRes;

    // Create Finalizer.
    // =================

    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;

    // Create Primary Task.
    // ====================

    hRes = CWmiCoreTask::CreateTask(this, &pTask);
    if (FAILED(hRes))
        return WBEM_E_OUT_OF_MEMORY;

    hRes = pTask->Init_RenameObject(strOldObjectPath, strNewObjectPath, lFlags, pCtx, pFnz);
    if (FAILED(hRes))
        return hRes;

    phTask = pTask->GetHandleFromTask(pTask);

    // Tell Finalizer.
    // ===============

    hRes = pFnz->SetTaskHandle(phTask);
    if (FAILED(hRes))
        return hRes;

    // Dispatch task, whether sync or semisync.
    // ========================================

    hRes = CWmiCoreTask::DispatchTask(phTask);
    if (FAILED(hRes))
        return hRes;

    // If fully sync, execute this.
    // ============================

    if (ppCallResult == NULL)
    {
        hRes = pFnz->GetOperationResult(0, &hResTemp);
        if (FAILED(hRes))
            return hRes;
        return hResTemp;
    }

    // Else, we are semisync.
    // ======================

    IWbemCallResultEx *pFinalResult = 0;
    hRes = pFnz->GetResultObject(0, IID_IWbemCallResult, (LPVOID *) &pFinalResult);
    if (FAILED(hRes))
        return hRes;

    *ppCallResult = pFinalResult;

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//  *
HRESULT CWmiCoreApi::RenameObjectAsync(
            /* [in] */ const BSTR strOldObjectPath,
            /* [in] */ const BSTR strNewObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    HRESULT hRes;
    _IWmiCoreHandle *phTask = 0;
    _IWmiFinalizer *pFnz = 0;
    CReleaseMe _1(pFnz);
    CReleaseMe _2(phTask);
    CWmiCoreTask *pTask = 0;
    CReleaseMe _3(pTask);

    // Quick check.
    // ============
    hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Validate Parameters.
    // ====================

    hRes = ValidateAndLog_RenameObjectAsync(strOldObjectPath, strNewObjectPath, lFlags, pCtx, pResponseHandler);
    if (FAILED(hRes))
        return hRes;

    // Create Finalizer.
    // =================

    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;

    // Create Primary Task.
    // ====================

    hRes = CWmiCoreTask::CreateTask(this, &pTask);
    if (FAILED(hRes))
        return WBEM_E_OUT_OF_MEMORY;

    hRes = pTask->Init_RenameObjectAsync(strOldObjectPath, strNewObjectPath, lFlags, pCtx, pFnz);
    if (FAILED(hRes))
        return hRes;

    phTask = pTask->GetHandleFromTask(pTask);

    // Tell Finalizer.
    // ===============

    hRes = pFnz->SetTaskHandle(phTask);
    if (FAILED(hRes))
        return hRes;

    hRes = pFnz->SetDestinationSink(0, IID_IWbemObjectSink, (LPVOID *)&pResponseHandler);
    if (FAILED(hRes))
        return hRes;

    // Dispatch.
    // =========
    hRes = CWmiCoreTask::DispatchTask(phTask);

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::CheckNs()
{
    return WBEM_S_NO_ERROR;
}



//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::FindKeyRoot(
            /* [string][in] */ LPCWSTR wszClassName,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppKeyRootClass
            )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::InternalGetClass(
            /* [string][in] */ LPCWSTR wszClassName,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppClass
            )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::InternalGetInstance(
            /* [string][in] */ LPCWSTR wszPath,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppInstance
            )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::InternalExecQuery(
            /* [string][in] */ LPCWSTR wszQueryLanguage,
            /* [string][in] */ LPCWSTR wszQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink
            )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::InternalCreateInstanceEnum(
            /* [string][in] */ LPCWSTR wszClassName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink
            )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::GetDbInstance(
            /* [string][in] */ LPCWSTR wszDbKey,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppInstance
            )
{
    // Direct repository access
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::GetDbReferences(
            /* [in] */ IWbemClassObject __RPC_FAR *pEndpoint,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink
            )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::InternalPutInstance(
            /* [in] */ IWbemClassObject __RPC_FAR *pInstance
            )
{
    // Direct repository access
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::GetNormalizedPath(
            /* [in] */ BSTR pstrPath,
            /* [out] */ BSTR __RPC_FAR *pstrStandardPath
            )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::Shutdown(
            /* [in] */ LONG uReason,
            /* [in] */ ULONG uMaxMilliseconds,
            /* [in] */ IWbemContext __RPC_FAR *pCtx
            )
{
    // Block access

    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
//


HRESULT CWmiCoreApi::ValidateAndLog_OpenNamespace(
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_GetObject(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_GetObjectAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_PutClass(
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_PutClassAsync(
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_DeleteClass(
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_DeleteClassAsync(
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_CreateClassEnum(
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_CreateClassEnumAsync(
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_PutInstance(
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_PutInstanceAsync(
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_DeleteInstance(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_DeleteInstanceAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_CreateInstanceEnum(
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_CreateInstanceEnumAsync(
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_ExecQuery(
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_ExecQueryAsync(
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_ExecNotificationQuery(
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_ExecNotificationQueryAsync(
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_ExecMethod(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_ExecMethodAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_Open(
            /* [in] */ const BSTR strScope,
            /* [in] */ const BSTR strParam,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServicesEx __RPC_FAR *__RPC_FAR *ppScope,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppResult
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_OpenAsync(
            /* [in] */ const BSTR strScope,
            /* [in] */ const BSTR strParam,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSinkEx __RPC_FAR *pResponseHandler
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_Add(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_AddAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_Remove(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_RemoveAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_RefreshObject(
            /* [out][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pTarget,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_RefreshObjectAsync(
            /* [out][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pTarget,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSinkEx __RPC_FAR *pResponseHandler
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_RenameObject(
            /* [in] */ const BSTR strOldObjectPath,
            /* [in] */ const BSTR strNewObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreApi::ValidateAndLog_RenameObjectAsync(
            /* [in] */ const BSTR strOldObjectPath,
            /* [in] */ const BSTR strNewObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\cfgmgr.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    CFGMGR.H

Abstract:

  This file implements the WinMgmt configuration manager class.

  See cfgmgr.h for documentation.

  Classes implemented:
      ConfigMgr      configuration manager

History:

    09-Jul-96   raymcc    Created.
    3/10/97     levn      Fully documented (ha ha)


--*/

#ifndef _CFGMGR_H_
#define _CFGMGR_H_

#include <unload.h>

class CWbemObject;
class CDynasty;
class CWbemQueue;
class CAsyncServiceQueue;
struct IWbemEventSubsystem_m4;

#define READONLY

#include <wmiutils.h>
#include <ql.h>
#include <reposit.h>
#include "coreq.h"

//******************************************************************************
//******************************************************************************
//
//  class ConfigMgr
//
//  This completely static class represents global configuration data for WinMgmt.
//  The rest of WinMgmt uses this class instead of global data itself.
//
//******************************************************************************
//
//  static GetProviderCache
//
//  Returns the pointer to the global provider cache object, as defined and
//  described in prvcache.h.
//
//  Returns:
//
//      CProviderCache*: internal pointer not to be modified or deleted!
//
//******************************************************************************
//
//  GetDbPtr
//
//  Returns the pointer to the WinMgmt static database object. The static database
//  is defined and described in objdb.h.
//
//  Returns:
//
//      CObjectDatabase*: internal pointer not to be modified or deleted!
//
//******************************************************************************
//
//  GetUnRefedSvcQueue
//
//  Returns the pointer to the global queue handling requests to providers.
//  Whenever WinMgmt needs to communicate to a provider, a request us added to
//  this queue. This queue is defined and described in provsvcq.h.
//
//  Returns:
//
//      CAsyncSvcQueue*: internal pointer not to be modified or deleted!
//
//******************************************************************************
//
//  GetAsyncSvcQueue
//
//  Returns the pointer to the global queue handling asynchrnous requests to
//  WinMgmt. Whenever a client makes a call into IWbemServices, WinMgmt adds a request
//  to this queue. This queue is defined and described in svcq.h
//
//  Returns:
//
//      CAsyncServiceQueue*: internal pointer not to be modified or deleted!
//
//******************************************************************************
//
//  GetMachineName
//
//  Returns the name of the computer we are running on as a UNICODE string,
//  even on Win95 where machine names are ASCII.
//
//  Returns:
//
//      LPWSTR: machine name. internal poitner not to be deleted!
//
//******************************************************************************
//
//  GetWorkingDir
//
//  Returns the working directory of WinMgmt, that is, where the database is
//  located.
//
//  Returns:
//
//      LPWSTR: internal pointer not to be deleted!
//
//******************************************************************************
//
//  static InitSystem
//
//  System initialization function invoked from wbemcore.dll entry point.
//  Performs the following tasks:
//
//  1) Looks for other copies of WinMgmt already running and stops with a fatal
//      error message if found.
//  2) Reads the registry for initialization information.
//  3) Creates the database object (this will in turn create the database file
//      if not found. See CObjectDatabase in objdb.h for details).
//  4) Writes appropriate information (like database location) into the
//      registry.
//
//  NOTE: since this function is invoked from inside the DLL entry point, there
//  are many restrictions on what it can do. In particular, it cannot create
//  threads and expect them to run. Thus, due to the multi-threaded nature of
//  WinMgmt, this function may not attempt to perform any WinMgmt operations at the
//  COM layer or the system will hang!
//
//******************************************************************************
//
//  static Shutdown
//
//  System Shutdown function invoked from wbemcore.dll entry point on PROCESS_
//  DETACH.  Deletes the CObjectDatabase instance (see objdb.h).
//
//******************************************************************************
//
//  static DebugBreak
//
//  Checks if Debug Break has been enabled (in the registry). This information
//  is used by the initialization code (InitSystem) to cause a user breakpoint
//  enabling us to attach a debugger to the service.
//
//  Returns:
//
//      BOOL:   TRUE iff Debug Break has been enabled.
//
//******************************************************************************
//
//  static LoggingEnabled
//
//  Checks if logging has been enabled. If it is, Trace calls output data to
//  a log file. If not, Trace calls are noops.
//
//  Returns:
//
//      BOOL:   TRUE iff logging is enabled.
//
//******************************************************************************
//
//  static GetEssSink
//
//  Retrieves the pointer to the Event Subsystem. Event subsystem pointer will
//  only be available if EnableEvents registry value is set to TRUE. Otherwise,
//  this function returns NULL. Note, that the Event Subsystem is loaded only
//  by ConfigMgr::SetReady function which is invoked the first time
//  DllGetClassObject is called in wbemcore.dll. Thus, ESS is not available
//  during WinMgmt initialization (InitSystem).
//
//  Returns:
//
//      IWbemObjectSink*:    the pointer to the ESS. Not to be released or
//                          deleted by the caller! May be NULL, see above.
//
//******************************************************************************
//
//  static SetReady
//
//  This function performs initialization, once WinMgmt is ready to go.
//  It is invoked the first type DllGetClassObject is called in wbemcore.dll.
//  By now, wbemcorwbemcore.dll has exited its entry point and so it is safe to load
//  additional DLLs and perform multi-threaded operations (unlike InitSystem).
//
//******************************************************************************
//
//  static SetIdentificationObject
//
//  This function (invoked from the SetReady function) stores proper information
//  in the root and root\defualt __WinMgmtIdentification objects. Namely, it
//  creates instances of this class in both namespace if not already there and
//  sets the current build of WinMgmt in the appropriate fields.
//
//  Parameters:
//
//      IN WCHAR* pwcNamespace     The namespace to initialize.
//
//******************************************************************************
//
//  static GetDllVersion
//
//  Retrives a string from a given DLLs resource table. If the string is longer
//  that the buffer, it is trucated.
//
//  Parameters:
//
//      IN char * pDLLName          The filename of the DLL. The DLL must be
//                                  located in WinMgmt working directory (See
//                                  GetWorkingDir) and a relative path is
//                                  expected here.
//      IN char * pResStringName    The resource string to query, e.g.,
//                                  "ProductVersion".
//      OUT WCHAR * pRes            Destination buffer.
//      IN DWORD dwResSize          Size of the destination buffer.
//
//  Returns:
//
//      BOOL:   TRUE on success, FALSE if DLL or string was not found.
//
//******************************************************************************
//
//  static RaiseClassDeletionEvent
//
//  Temporarary: raises a class deletion event. This function is used in the
//  object database, since events need to be raised for every deleted class.
//
//  Parameters:
//
//      LPWSTR wszNamespace         The name of the namespace where the class
//                                  is being deleted.
//      LPWSTR wszClass             The name of the class being deleted.
//      IWbemClassObject* pClass     The definition of the class being deleted.
//
//  Returns:
//
//      HRESULT: Whatever error code the ESS returns. Only WBEM_S_NO_ERROR is
//              documented.
//
//******************************************************************************
//
//  static LoadResourceStr
//
//  Loads a string resource from the string table in WBEMCORE.RC.
//
//  Parameters:
//      DWORD dwId          The string id.
//
//  Return value:
//  A dynamically allocated LPWSTR.  This string is loaded in DBCS form
//  for compatibility with Win98, but is returned in UNICODE form on both
//  Win98 and Windows NT.  Deallocate with operator delete.
//
//******************************************************************************
//
//	static GetPersistentCfgValue
//
//	retrieves a persistent value from the $WINMGMT.cfg file (or from the memory
//	cache of it if already loaded).
//
//	Parameters:
//		DWORD dwOffset		Persistent value index
//
//	Return Values
//		DWORD &dwValue		Returned value
//		BOOL				returns TRUE if successful, FALSE otherwise.
//******************************************************************************
//
//	static SetPersistentCfgValue
//
//	sets a persistent value in the $WinMgmt.cfg file (and in the memory cache).
//
//	Parameters:
//		DWORD dwOffset		Persistent value index
//
//	Return Values
//		DWORD &dwValue		Returned value
//		BOOL				returns TRUE if successful, FALSE otherwise.
//******************************************************************************
//
//  static SetADAPStatus
//
//  This function (invoked from the SetReady function) stores an __ADAPStatus
//	instance in the root\default namespace on W2k boxes. Namely, it creates
//	the class if it doesn't exist as well as a singleton instance if it is
//	not there.
//
//  Parameters:
//
//      IN WCHAR* pwcNamespace     The namespace to initialize.
//
//******************************************************************************

class CAsyncReq;

class ConfigMgr
{
    static CCritSec g_csEss;
public:
    static READONLY CWbemQueue* GetUnRefedSvcQueue();
    static READONLY CAsyncServiceQueue* GetAsyncSvcQueue();
    static HRESULT EnqueueRequest(CAsyncReq * pRequest, HANDLE* phWhenDone = NULL);
    static HRESULT EnqueueRequestAndWait(CAsyncReq * pRequest);
    static READONLY LPWSTR GetMachineName();
    static LPTSTR   GetWorkingDir();
    static DWORD    InitSystem();
    static DWORD    Shutdown(BOOL bProcessShutdown, BOOL bIsSystemShutDown);
    static BOOL     DebugBreak();
    static BOOL     ShutdownInProgress();
	static BOOL		DoCleanShutdown();
    static BOOL     LoggingEnabled();
    static IWbemEventSubsystem_m4* GetEssSink();
    static HRESULT  SetReady();
    static HRESULT  PrepareForClients(long lFlags);
    static void		FatalInitializationError(DWORD dwRes);
    static HRESULT	WaitUntilClientReady();
    static HRESULT     SetIdentificationObject(IWmiDbHandle *pNs, IWmiDbSession *pSess);
    static HRESULT  SetAdapStatusObject(IWmiDbHandle *pNs, IWmiDbSession *pSess);
	//static void		ProcessIdentificationObject(IWmiDbHandle *pNs, IWbemClassObject *pInst);
    static BOOL     GetDllVersion(TCHAR * pDLLName, TCHAR * pResStringName,
                        WCHAR * pRes, DWORD dwResSize);
    static IWbemContext* GetNewContext();
	static DWORD	ReadBackupConfiguration();
	static DWORD    GetBackupInterval();
	static DWORD    ReadEnumControlData();
	static LPTSTR	GetHotMofDirectory();
	static LPTSTR	GetDbDir();
	static BOOL		GetDbArenaInfo(DWORD &dwStartSize);
    static class CRefresherCache* GetRefresherCache();
    static class CTimerGenerator* GetTimerGenerator();
    static class CEventLog* GetEventLog();

    static DWORD GetMaxMemoryQuota();
    static DWORD GetUncheckedTaskCount();
    static DWORD GetMaxTaskCount();
    static DWORD GetMaxWaitBeforeDenial();
    static DWORD GetNewTaskResistance();

	static BOOL GetEnableQueryArbitration( void );
	static BOOL GetMergerThrottlingEnabled( void );
	static BOOL GetMergerThresholdValues( DWORD* pdwThrottle, DWORD* pdwRelease, DWORD* pdwBatching );
	static BOOL GetArbitratorValues( DWORD* pdwEnabled, DWORD* pdwSystemHigh, DWORD* pdwMaxSleep,
								double* pdHighThreshold1, long* plMultiplier1, double* pdHighThreshold2,
								long* plMultiplier2, double* pdHighThreshold3, long* plMultiplier3 );

	static ULONG GetMinimumMemoryRequirements ( ) ;
	static BOOL GetEnableArbitratorDiagnosticThread( void );

	static DWORD GetProviderDeliveryTimeout( void );

    static HRESULT  GetDefaultRepDriverClsId(CLSID &);

    static IWbemPath *GetNewPath();  // Returns NULL on error, requires Release() if successful.

/*
    static LPWSTR   LoadResourceStr(DWORD dwId);
*/    

	static BOOL GetPersistentCfgValue(DWORD dwOffset, DWORD &dwValue);
	static BOOL SetPersistentCfgValue(DWORD dwOffset, DWORD dwValue);

	//Retrieve a list of MOFs which need to be loaded when we have
	//have an empty database.  User needs to "delete []" the
	//returned string.  String is in a REG_MULTI_SZ format.
	//dwSize is the length of the buffer returned.
	static TCHAR* GetAutoRecoverMofs(DWORD &dwSize);

	static BOOL GetAutoRecoverDateTimeStamp(LARGE_INTEGER &liDateTimeStamp);

    static HRESULT AddCache();
    static HRESULT RemoveCache();
    static HRESULT AddToCache(DWORD dwSize, DWORD dwMemberSize,
                                DWORD* pdwSleep);
    static HRESULT RemoveFromCache(DWORD dwSize);
    static void ReadMaxQueueSize();
    static DWORD GetMaxQueueSize();

    static void SetDefaultMofLoadingNeeded();
    static HRESULT LoadDefaultMofs();
	static bool SetDirRegSec(void);
};

//
// 
//  The Hook Class for trapping the creation of Win32_PerRawData
//
///////////////////////////////////////////////////////////

extern _IWmiCoreWriteHook * g_pRAHook; // = NULL;

class CRAHooks : public _IWmiCoreWriteHook
{
public:
        CRAHooks(_IWmiCoreServices *pSvc);
        ~CRAHooks();
        _IWmiCoreServices * GetSvc(){ return m_pSvc; };

        STDMETHOD(QueryInterface)(REFIID riid, void ** ppv);
        ULONG STDMETHODCALLTYPE AddRef();
        ULONG STDMETHODCALLTYPE Release();
        STDMETHOD(PrePut)(long lFlags, long lUserFlags, IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace, 
                            LPCWSTR wszClass, _IWmiObject* pCopy);
        STDMETHOD(PostPut)(long lFlags, HRESULT hApiResult, 
                            IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace, 
                            LPCWSTR wszClass, _IWmiObject* pNew, 
                            _IWmiObject* pOld);
        STDMETHOD(PreDelete)(long lFlags, long lUserFlags, 
                            IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace, 
                            LPCWSTR wszClass);
        STDMETHOD(PostDelete)(long lFlags, HRESULT hApiResult, 
                            IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace, 
                            LPCWSTR wszClass, _IWmiObject* pOld);
private:
    LONG m_cRef;
    _IWmiCoreServices * m_pSvc;
};

//
//  
//  Data for the interception
//

#define GUARDED_NAMESPACE L"root\\cimv2"
#define GUARDED_CLASS     L"win32_perfrawdata"
#define GUARDED_HIPERF    L"hiperf"
#define GUARDED_PERFCTR   L"genericperfctr"
#define WMISVC_DLL        L"wmisvc.dll"
#define FUNCTION_DREDGERA "DredgeRA"

class ExceptionCounter
{
private:
    static LONG s_Count;
public:
    ExceptionCounter(){ InterlockedIncrement(&s_Count); };
};

#endif




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\coreapi.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    COREAPI.H

Abstract:

    Implements the COM API layer of WMI

History:
    25-Apr-00   raymcc      Created from mixes Win2k sources

--*/

#ifndef _COREAPI_H_
#define _COREAPI_H_

#define WMICORE_STATE_NORMAL
#define WMICORE_STATE_TRANSACTED
#define WMICORE_STATE_SHUTTING_DOWN
#define WMICORE_STATE_CLOSED

class CWmiCoreApi :
    public IWbemServicesEx,
    public IWbemInternalServices,
    public IWbemShutdown
{
    // Private data
    // =============

    ULONG m_uRefCount;

    _IWmiCoreServices       *m_pCoreSvc;
    _IWmiArbitrator         *m_pArb;

    IWmiDbHandle            *m_pNs;
    IWmiDbHandle            *m_pScope;

    _IWmiProviderFactory    *m_pProvFact;

    ULONG                    m_uStateFlags;
    GUID                     m_TransactionGuid;

    IWbemPath               *m_pNsPath;
    IWbemPath               *m_pScopePath;
    LPWSTR                   m_pszNamespace;
    LPWSTR                   m_pszScope;

    LPWSTR                   m_pszUser;
    BOOL                     m_bRepositOnly;
    IUnknown                *m_pRefreshingSvc;

    // Private methods.
    // ================

    CWmiCoreApi();
   ~CWmiCoreApi();

    HRESULT CheckNs();

    // Validation Functions.
    // =====================

    HRESULT ValidateAndLog_OpenNamespace(
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult
            );

    HRESULT ValidateAndLog_GetObject(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            );

    HRESULT ValidateAndLog_GetObjectAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );

    HRESULT ValidateAndLog_PutClass(
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            );

    HRESULT ValidateAndLog_PutClassAsync(
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );

    HRESULT ValidateAndLog_DeleteClass(
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            );

    HRESULT ValidateAndLog_DeleteClassAsync(
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );

    HRESULT ValidateAndLog_CreateClassEnum(
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            );

    HRESULT ValidateAndLog_CreateClassEnumAsync(
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );

    HRESULT ValidateAndLog_PutInstance(
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            );

    HRESULT ValidateAndLog_PutInstanceAsync(
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );

    HRESULT ValidateAndLog_DeleteInstance(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            );

    HRESULT ValidateAndLog_DeleteInstanceAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );

    HRESULT ValidateAndLog_CreateInstanceEnum(
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            );

    HRESULT ValidateAndLog_CreateInstanceEnumAsync(
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );

    HRESULT ValidateAndLog_ExecQuery(
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            );

    HRESULT ValidateAndLog_ExecQueryAsync(
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );

    HRESULT ValidateAndLog_ExecNotificationQuery(
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            );

    HRESULT ValidateAndLog_ExecNotificationQueryAsync(
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );

    HRESULT ValidateAndLog_ExecMethod(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            );

    HRESULT ValidateAndLog_ExecMethodAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );

    HRESULT ValidateAndLog_Open(
            /* [in] */ const BSTR strScope,
            /* [in] */ const BSTR strParam,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServicesEx __RPC_FAR *__RPC_FAR *ppScope,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppResult
            );

    HRESULT ValidateAndLog_OpenAsync(
            /* [in] */ const BSTR strScope,
            /* [in] */ const BSTR strParam,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSinkEx __RPC_FAR *pResponseHandler
            );

    HRESULT ValidateAndLog_Add(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult
            );

    HRESULT ValidateAndLog_AddAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );

    HRESULT ValidateAndLog_Remove(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult
            );

    HRESULT ValidateAndLog_RemoveAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );

    HRESULT ValidateAndLog_RefreshObject(
            /* [out][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pTarget,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult
            );

    HRESULT ValidateAndLog_RefreshObjectAsync(
            /* [out][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pTarget,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSinkEx __RPC_FAR *pResponseHandler
            );

    HRESULT ValidateAndLog_RenameObject(
            /* [in] */ const BSTR strOldObjectPath,
            /* [in] */ const BSTR strNewObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult
            );

    HRESULT ValidateAndLog_RenameObjectAsync(
            /* [in] */ const BSTR strOldObjectPath,
            /* [in] */ const BSTR strNewObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );



public:
        /* IUnknown methods */
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    // IWbemServices

        virtual HRESULT STDMETHODCALLTYPE OpenNamespace(
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult);

        virtual HRESULT STDMETHODCALLTYPE CancelAsyncCall(
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink);

        virtual HRESULT STDMETHODCALLTYPE QueryObjectSink(
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE GetObject(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

        virtual HRESULT STDMETHODCALLTYPE GetObjectAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE PutClass(
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

        virtual HRESULT STDMETHODCALLTYPE PutClassAsync(
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE DeleteClass(
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

        virtual HRESULT STDMETHODCALLTYPE DeleteClassAsync(
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE CreateClassEnum(
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);

        virtual HRESULT STDMETHODCALLTYPE CreateClassEnumAsync(
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE PutInstance(
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

        virtual HRESULT STDMETHODCALLTYPE PutInstanceAsync(
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE DeleteInstance(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

        virtual HRESULT STDMETHODCALLTYPE DeleteInstanceAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum(
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);

        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync(
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE ExecQuery(
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);

        virtual HRESULT STDMETHODCALLTYPE ExecQueryAsync(
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQuery(
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);

        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync(
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE ExecMethod(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

        virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    // IWbemServicesEx

        virtual HRESULT STDMETHODCALLTYPE Open(
            /* [in] */ const BSTR strScope,
            /* [in] */ const BSTR strParam,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServicesEx __RPC_FAR *__RPC_FAR *ppScope,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppResult);

        virtual HRESULT STDMETHODCALLTYPE OpenAsync(
            /* [in] */ const BSTR strScope,
            /* [in] */ const BSTR strParam,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSinkEx __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE Add(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult);

        virtual HRESULT STDMETHODCALLTYPE AddAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE Remove(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult);

        virtual HRESULT STDMETHODCALLTYPE RemoveAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE RefreshObject(
            /* [out][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pTarget,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult);

        virtual HRESULT STDMETHODCALLTYPE RefreshObjectAsync(
            /* [out][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pTarget,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSinkEx __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE RenameObject(
            /* [in] */ const BSTR strOldObjectPath,
            /* [in] */ const BSTR strNewObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult);

        virtual HRESULT STDMETHODCALLTYPE RenameObjectAsync(
            /* [in] */ const BSTR strOldObjectPath,
            /* [in] */ const BSTR strNewObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    // IWbemInternalServices

        virtual HRESULT STDMETHODCALLTYPE FindKeyRoot(
            /* [string][in] */ LPCWSTR wszClassName,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppKeyRootClass);

        virtual HRESULT STDMETHODCALLTYPE InternalGetClass(
            /* [string][in] */ LPCWSTR wszClassName,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppClass);

        virtual HRESULT STDMETHODCALLTYPE InternalGetInstance(
            /* [string][in] */ LPCWSTR wszPath,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppInstance);

        virtual HRESULT STDMETHODCALLTYPE InternalExecQuery(
            /* [string][in] */ LPCWSTR wszQueryLanguage,
            /* [string][in] */ LPCWSTR wszQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink);

        virtual HRESULT STDMETHODCALLTYPE InternalCreateInstanceEnum(
            /* [string][in] */ LPCWSTR wszClassName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink);

        virtual HRESULT STDMETHODCALLTYPE GetDbInstance(
            /* [string][in] */ LPCWSTR wszDbKey,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppInstance);

        virtual HRESULT STDMETHODCALLTYPE GetDbReferences(
            /* [in] */ IWbemClassObject __RPC_FAR *pEndpoint,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink);

        virtual HRESULT STDMETHODCALLTYPE InternalPutInstance(
            /* [in] */ IWbemClassObject __RPC_FAR *pInstance);

        virtual HRESULT STDMETHODCALLTYPE GetNormalizedPath(
            /* [in] */ BSTR pstrPath,
            /* [out] */ BSTR __RPC_FAR *pstrStandardPath);

    // IWbemShutdown


        virtual HRESULT STDMETHODCALLTYPE Shutdown(
            /* [in] */ LONG uReason,
            /* [in] */ ULONG uMaxMilliseconds,
            /* [in] */ IWbemContext __RPC_FAR *pCtx);

    // IWbemTransaction

        virtual HRESULT STDMETHODCALLTYPE Begin(
            /* [in] */ ULONG uTimeout,
            /* [in] */ ULONG uFlags,
            /* [in] */ GUID __RPC_FAR *pTransGUID);

        virtual HRESULT STDMETHODCALLTYPE Rollback(
            /* [in] */ ULONG uFlags);

        virtual HRESULT STDMETHODCALLTYPE Commit(
            /* [in] */ ULONG uFlags);

        virtual HRESULT STDMETHODCALLTYPE QueryState(
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puState);


public:

    static HRESULT CWmiCoreApi::InitNew(
        /* [in] */ LPCWSTR pszScope,
        /* [in] */ LPCWSTR pszNamespace,
        /* [in] */ LPCWSTR pszUserName,
        /* [in] */ ULONG uCallFlags,
        /* [in] */ DWORD dwSecFlags,
        /* [in] */ DWORD dwPermissions,
        /* [in] */ ULONG uFlags,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **pServices
        );

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\clicnt.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    CLICNT.CPP

Abstract:

    Call Result Class

History:

    26-Mar-98   a-davj    Created.

--*/


#include "precomp.h"
#include <wbemcore.h>

// This keeps track of when the core can be unloaded

CClientCnt gClientCounter;
extern long g_lInitCount;  // 0 DURING INTIALIZATION, 1 OR MORE LATER ON!

CClientCnt::CClientCnt()
{
    for(int i = 0; i < LASTONE; i++)
        m_lLockCounts[i] =0;
    InitializeCriticalSection(&m_csEntering);
}

CClientCnt::~CClientCnt()
{
    Empty();
    DeleteCriticalSection(&m_csEntering);
}

void CClientCnt::Empty()
{
    CInCritSec ics(&m_csEntering);
    int iSize = m_Array.Size();
    for(int iCnt = 0; iCnt < iSize; iCnt++)
    {
        Entry * pEntry = (Entry *)m_Array[iCnt];
        if(pEntry)
            delete pEntry;
    }
    m_Array.Empty();
}

bool CClientCnt::AddClientPtr(IUnknown *  punk,ClientObjectType Type)
{
    CInCritSec ics(&m_csEntering);
    bool bRet = false;
    Entry * pEntry = new Entry;
    if(pEntry)
    {
        pEntry->m_pUnk = punk;
        pEntry->m_Type = Type;
        int iRet = m_Array.Add(pEntry);
        if(iRet == CFlexArray::no_error)
            bRet = true;
        else
            delete pEntry;
    }
    return bRet;

}

bool CClientCnt::RemoveClientPtr(IUnknown *  punk)
{
    CInCritSec ics(&m_csEntering);
    bool bRet = false;
    int iSize = m_Array.Size();
    for(int iCnt = 0; iCnt < iSize; iCnt++)
    {
        Entry * pEntry = (Entry *)m_Array[iCnt];
        if(pEntry && pEntry->m_pUnk == punk)
        {
            bRet = true;
            delete pEntry;
            m_Array.RemoveAt(iCnt);
            break;
        }
    }
    if(bRet)
        SignalIfOkToUnload();
    return bRet;

}

long CClientCnt::LockCore(LockType lt)
{
    if(lt != LASTONE)
        return InterlockedIncrement(&m_lLockCounts[lt]);
    else
        return -1;              // should never happen
}

long CClientCnt::UnlockCore(LockType lt, bool Notify)
{
    if(lt == LASTONE)
        return -1;              // should never happen
    CInCritSec ics(&m_csEntering);
    m_lLockCounts[lt]--;
    long lRet = m_lLockCounts[lt];
    if(Notify)
        SignalIfOkToUnload();
    return lRet;

}


bool CClientCnt::OkToUnload()
{
    CInCritSec ics(&m_csEntering);

    // count our locks

    long lLocks = 0;
    for(int i = 0; i < LASTONE; i++)
        lLocks += m_lLockCounts[i];

    // We can shut down if we have 0 counts, and if we are not in the middle of initialization


    if(m_Array.Size() == 0 && lLocks == 0 && g_lInitCount != 0)
        return true;
    else
        return false;
}

void CClientCnt::SignalIfOkToUnload()
{
    // count our locks

    if(OkToUnload() && g_lInitCount != -1)
    {

        HANDLE hCanShutdownEvent = NULL;
        DEBUGTRACE((LOG_WBEMCORE,"Core can now unload\n"));
        hCanShutdownEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("WINMGMT_COREDLL_CANSHUTDOWN"));
        if(hCanShutdownEvent)
        {
            SetEvent(hCanShutdownEvent);
            CloseHandle(hCanShutdownEvent);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\coreq.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    EXECQ.H

Abstract:

  Defines classes related to execution queues.

  Classes defined:

      CCoreExecReq    An abstract request.
      CCoreQueue      A queue of requests with an associated thread

History:

      23-Jul-96     raymcc    Created.
      3/10/97       levn      Fully documented
      9/6/97        levn      Rewrote for thread pool
      2-May-00      raymcc    Decoupled from shared ESS version for tasks
                              & quotas

--*/

#ifndef __EXECQUEUE__H_
#define __EXECQUEUE__H_

#include "sync.h"
#include "wbemutil.h"

#ifdef __COLLECT_ALLOC_STAT
   #include "stackcom.h"
#endif

#include "wbemint.h"

//******************************************************************************
//******************************************************************************
//
//  class CCoreExecReq
//
//  Abstract base class for any schedulable request
//
//******************************************************************************
//
//  Execute
//
//  Primary method. Executes the request, whatever that means.
//
//  Returns:
//
//      int:    return code. 0 means success, everything else --- failure.
//              Exact error codes are request-specific.
//
//******************************************************************************

class CCoreExecReq
{
protected:
#ifdef WINMGMT_THREAD_DEBUG
    static CCritSec mstatic_cs;
    static CPointerArray<CCoreExecReq> mstatic_apOut;
#endif
#ifdef __COLLECT_ALLOC_STAT
public:
    CStackRecord m_Stack;
protected:
#endif
    HANDLE m_hWhenDone;
    CCoreExecReq* m_pNext;
    long m_lPriority;
	bool	m_fOk;

public:
    _IWmiCoreHandle *m_phTask;

    void SetWhenDoneHandle(HANDLE h) {m_hWhenDone = h;}
    HANDLE GetWhenDoneHandle() {return m_hWhenDone;}
    void SetNext(CCoreExecReq* pNext) {m_pNext = pNext;}
    CCoreExecReq* GetNext() {return m_pNext;}
    void SetPriority(long lPriority) {m_lPriority = lPriority;}
    long GetPriority() {return m_lPriority;}
    virtual void DumpError(){   DEBUGTRACE((LOG_WBEMCORE,
        "No additional info\n"));};
	bool IsOk( void ) { return m_fOk; }

public:
    CCoreExecReq();
    virtual ~CCoreExecReq();
    virtual HRESULT Execute() = 0; 
    virtual HRESULT SetTaskHandle(_IWmiCoreHandle *phTask);
};

class CDavidsRequest
{
protected:
    LPTHREAD_START_ROUTINE m_pfn;
    void* m_pParam;
public:
    CDavidsRequest(LPTHREAD_START_ROUTINE pFunctionToExecute, void* pParam)
        : m_pfn(pFunctionToExecute), m_pParam(pParam)
    {}
    HRESULT Execute()
    {
        return (HRESULT)m_pfn(m_pParam);
    }
};

//******************************************************************************
//******************************************************************************
//
//  class CCoreQueue
//
//  CCoreQueue represents the concept of a queue of requests with an associated
//  thread to execute those requests. In a lot of respects, it is similar to
//  a message queue. Requests are added to the queue (which is represented by
//  an array) and the thread (created by the Run function) picks them up one
//  by one and executes them.
//
//  The trick is what to do if while processing one request, another one
//  is generated and needs to be processed before the first one succeeds. This
//  is similar to a SendMessage, but trickier: the thread generating the new
//  request may not be the thread attached to the queue!
//
//  To overcome this problem, we make all our waits interruptible in the
//  following sense. Whenever the thread attached to the queue needs to block
//  waiting for something to happen (which is when another thread may post a
//  new request and deadlock the system), it uses QueueWaitForSingleObject
//  instead. This function will wait for the object that the thread wanted to
//  wait for but it will also wake up if a new Critical request is added to
//  the queue and process any such request while waiting.
//
//  See QueueWaitForSingleObject for details.
//
//  Operations of CCoreQueue are protected by a critical section, so multiple
//  threads can add requests simultaneously.
//
//******************************************************************************
//
//  Constructor
//
//  Creates and initializes all the synchronization objects, as well as the
//  thread local storage required by QueueWaitForSingleObject.
//
//******************************************************************************
//
//  Destructor
//
//  Deletes synchronization objects.
//
//******************************************************************************
//
//  virtual Enqueue
//
//  Adds a request to the queue. The acction depends on whether the request is
//  critical or not.  If not, it is added to the queue and the semaphor of
//  non-critical requests is incremented. The processing thread will pick it up
//  in FIFO order. If critical, request is added to the front of the queye and
//  the semaphor of critical requests is incremented. This will cause the
//  processing thread to take this request the next time it enters into a
//  waiting state (see QueueWaitForSingleObject).
//
//******************************************************************************
//
//  QueueWaitForSingleObject
//
//  The core of the trick. In WINMGMT, whenever a thread needs to wait for an
//  object, it calls this function instead. This function checks if the calling
//  thread is the registered processing thread for any CCoreQueue object (by
//  looking up the m_dwTlsIndex thread local variable for the thread). If it
//  is not, the function simply calls WaitForSingleObject.
//
//  If it is, the function queries the queue for the semaphore indicating the
//  number of critical requests on the queue. It then calls
//  WaitForMultipleObjects with the original handle and the semaphore. If the
//  semaphore is signaled during the wait (or was singlaled when we came in),
//  this function picks up the first requests on the queue and executes it;
//  once that request is complete, it resumes the wait (with adjusted timeout).
//
//  Parameters:
//
//      HANDLE hHandle      The handle of synchronization object to wait for.
//      DWORD dwTimeout     Timeout in milliseconds.
//
//  Returns:
//
//      Same values as WaitForSingleObject:
//          WAIT_OBJECT_0   hHandle became signaled
//          WAIT_TIMEOUT    Timed out.
//
//******************************************************************************
//**************************** protected ***************************************
//
//  Register
//
//  Registers the calling thread as the processing thread of this queue by
//  storing the pointer to the queue in the m_dwTlsIndex thread local storage
//  variable. QueueWaitForSingleObject reads this index to interrupt waits
//  when needed (see QueueWaitForSingleObject).
//
//  Returns:
//
//      CCoreQueue*:    the previous CCoreQueue this thread was registered for,
//                      or NULL if none. The caller MUST not delete this object.
//
//******************************************************************************
//
//  ThreadMain
//
//  This is the function that the thread created by Run executes.  It sits in
//  an infinite loop, retrieving requests and executing them one by one.
//  This function never returns.
//
//******************************************************************************
//
//  Dequeue
//
//  Retrieves the request at the head of the queue and removes it from the
//  queue.
//
//  Returns:
//
//      CCoreExecReq*:  the request that was at the head of the queue, or NULL
//                      if the queue was empty. The caller must delete this
//                      object when no longer needed.
//
//******************************************************************************
//
//  static _ThreadEntry
//
//  Stub function used to create the tread. Calls ThreadEntry on the real
//  CCoreQueue.
//
//  Parameters:
//
//      LPVOID pObj     Actually CCoreQueue* to the queue this thread is
//                      supposed to serve.
//
//  Returns:
//
//      never.
//
//******************************************************************************
//
//  static InitTls
//
//  Invoked only once during the life of the system (not the life of a queue),
//  creates a thread local storage location where the pointer to the queue is
//  stored for the attached threads (see Register and QueueWaitForSingleObject)
//
//******************************************************************************
//
//  GetNormalReadyHandle
//
//  Returns the handle to the semaphore which contains the number of
//  non-critical requests currently on the queue.
//
//  Returns:
//
//      HANDLE: the the semaphore
//
//******************************************************************************
//
//  GetCriticalReadyHandle
//
//  Returns the handle to the semaphore which contains the number of
//  critical requests currently on the queue.
//
//  Returns:
//
//      HANDLE: the the semaphore
//
//******************************************************************************
//
//  Execute
//
//  Dequeues and executes a single request.
//
//******************************************************************************

class CCoreQueue
{
protected:
    class CThreadRecord
    {
    public:
        CCoreQueue* m_pQueue;
        CCoreExecReq * m_pCurrentRequest;
        BOOL m_bReady;
        BOOL m_bExitNow;
        HANDLE m_hThread;
        HANDLE m_hAttention;

    public:
        CThreadRecord(CCoreQueue* pQueue);
        ~CThreadRecord();
        void Signal();
    };

protected:
    static long mstatic_lNumInits;

    long m_lRef;
    CCritSec m_cs;

    BOOL m_bShutDownCalled;

    CFlexArray m_aThreads;
    CCoreExecReq* m_pHead;
    CCoreExecReq* m_pTail;

    long m_lNumThreads;
    long m_lNumIdle;
    long m_lNumRequests;
    static long m_lEmergencyThreads;

    long m_lMaxThreads;
    long m_lHiPriBound;
    long m_lHiPriMaxThreads;
    static long m_lPeakThreadCount;
    static long m_lPeakEmergencyThreadCount;

    long m_lStartSlowdownCount;
    long m_lAbsoluteLimitCount;
    long m_lOneSecondDelayCount;

    double m_dblAlpha;
    double m_dblBeta;

    DWORD m_dwTimeout;
    DWORD m_dwOverflowTimeout;

    static _IWmiArbitrator* m_pArbitrator;

private:
	HRESULT PlaceRequestInQueue( CCoreExecReq* pReq );

protected:
    virtual void ThreadMain(CThreadRecord* pRecord);

    virtual void LogError(CCoreExecReq* pRequest, int nRes);

    static DWORD WINAPI _ThreadEntry(LPVOID pObj);
    static DWORD WINAPI _ThreadEntryRescue(LPVOID pObj);
    
    static void InitTls();

    virtual void InitializeThread();
    virtual void UninitializeThread();
    virtual BOOL CreateNewThread( BOOL = FALSE );
    static void Register(CThreadRecord* pRecord);
    virtual void ShutdownThread(CThreadRecord* pRecord);

    virtual BOOL IsSuitableThread(CThreadRecord* pRecord, CCoreExecReq* pReq);
    virtual BOOL DoesNeedNewThread(CCoreExecReq* pReq, bool bIgnoreNumRequests = false );
    virtual BOOL IsIdleTooLong(CThreadRecord* pRecord, DWORD dwIdle);
    virtual DWORD GetIdleTimeout(CThreadRecord* pRecord);
    virtual BOOL IsAppropriateThread();
    virtual DWORD WaitForSingleObjectWhileBusy(HANDLE hHandle, DWORD dwWait,
                                                CThreadRecord* pRecord);

	virtual DWORD UnblockedWaitForSingleObject(HANDLE hHandle, DWORD dwWait,
                                                CThreadRecord* pRecord);

    virtual BOOL Execute(CThreadRecord* pRecord);
    virtual BOOL IsSTA() {return FALSE;}
    virtual CCoreExecReq* SearchForSuitableRequest(CThreadRecord* pRecord);
    virtual void SitOutPenalty(long lRequestIndex);
    virtual DWORD CalcSitOutPenalty(long lRequestIndex);

    virtual void AdjustInitialPriority(CCoreExecReq* pRequest){}
    virtual void AdjustPriorityForPassing(CCoreExecReq* pRequest){}

    virtual BOOL IsDependentRequest ( CCoreExecReq* pRequest);
	static  VOID RecordPeakThreadCount ( ) ;
    
public:
    CCoreQueue();
    ~CCoreQueue();

    void AddRef() {InterlockedIncrement(&m_lRef);}
    void Release() {if(InterlockedDecrement(&m_lRef) == 0) delete this;}
    static DWORD GetTlsIndex();
    void Enter();
    void Leave();

    virtual HRESULT Enqueue(CCoreExecReq* pRequest, HANDLE* phWhenDone = NULL);
	HRESULT EnqueueWithoutSleep(CCoreExecReq* pRequest, HANDLE* phWhenDone = NULL );
    HRESULT EnqueueAndWait(CCoreExecReq* pRequest);

    virtual LPCWSTR GetType() {return L"";}

    BOOL SetThreadLimits(long lMaxThreads, long lHiPriMaxThreads = -1,
                            long lHiPriBound = 0);
    void SetIdleTimeout(DWORD dwTimeout) {m_dwTimeout = dwTimeout;}
    void SetOverflowIdleTimeout(DWORD dwTimeout)
        {m_dwOverflowTimeout = dwTimeout;}
    void SetRequestLimits(long lAbsoluteLimitCount,
            long lStartSlowdownCount = -1, long lOneSecondDelayCount = -1);

    void Shutdown(BOOL bIsSystemShutDown);

	DWORD GetSitoutPenalty( void ) { return CalcSitOutPenalty( m_lNumRequests ); }

    static DWORD QueueWaitForSingleObject(HANDLE hHandle, DWORD dwWait);
    static DWORD QueueUnblockedWaitForSingleObject(HANDLE hHandle, DWORD dwWait);
    static BOOL IsSTAThread();

	// Helper function for new merger requests which execute requests that
	// are stored in the merger.

	static HRESULT ExecSubRequest( CCoreExecReq* pNewRequest );

	static long GetPeakThreadCount ( ) { return m_lPeakThreadCount ; }
	static long GetPeakEmergThreadCount ( ) { return m_lPeakEmergencyThreadCount ; }
	static long GetEmergThreadCount ( )	{ return m_lEmergencyThreads ; }
	static void SetArbitrator(_IWmiArbitrator* pArbitrator);
};

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\coreq.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    EXECQ.CPP

Abstract:

  Implements classes related to abstract execution queues.

  Classes implemeted:

      CCoreExecReq    An abstract request.
      CCoreQueue      A queue of requests with an associated thread

History:

      23-Jul-96   raymcc    Created.
      3/10/97     levn      Fully documented (heh, heh)
      14-Aug-99   raymcc    Changed timeouts
      30-Oct-99   raymcc    Critsec changes for NT Wksta Stress Oct 30 1999
--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include <cominit.h>
#include <sync.h>
#include "genutils.h"
#include <wbemcore.h>
#include <wmiarbitrator.h>

#define IDLE_THREAD_TIMEOUT     12000
#define OVERLFLOW_TIMEOUT        5000


//***************************************************************************

// Local wrapper class.  Does not initialize or clean up the critsec.  Simply
// used as a wrapper for scoping so that AV and exception stack unwinding will
// cause the critsec to be exited properly once it is entered.

class CCritSecWrapper
{
    BOOL m_bIn;
    CRITICAL_SECTION *m_pcs;
public:
    CCritSecWrapper(CRITICAL_SECTION *pcs) { m_pcs = pcs; m_bIn = FALSE; }
   ~CCritSecWrapper() { if (m_bIn) Leave(); }
    void Enter() { EnterCriticalSection(m_pcs); m_bIn = TRUE; }
    void Leave() { LeaveCriticalSection(m_pcs); m_bIn = FALSE; }
};


//***************************************************************************

long CCoreQueue::mstatic_lNumInits = -1;
long CCoreQueue::m_lEmergencyThreads = 0 ;
long CCoreQueue::m_lPeakThreadCount = 0 ;
long CCoreQueue::m_lPeakEmergencyThreadCount = 0;
_IWmiArbitrator* CCoreQueue::m_pArbitrator = NULL ;
	
DWORD mstatic_dwTlsIndex = 0xFFFFFFFF;

class CTlsStaticCleanUp
{
public:
    CTlsStaticCleanUp() {}
    ~CTlsStaticCleanUp() { if (mstatic_dwTlsIndex != 0xFFFFFFFF) TlsFree(mstatic_dwTlsIndex); }
};
CTlsStaticCleanUp g_tlsStaticCleanup;

#ifdef WINMGMT_THREAD_DEBUG
    CCritSec CCoreExecReq::mstatic_cs;
    CPointerArray<CCoreExecReq> CCoreExecReq::mstatic_apOut;

    #define THREADDEBUGTRACE DEBUGTRACE
#else
    #define THREADDEBUGTRACE(X)
#endif


CCoreExecReq::CCoreExecReq()
    : m_hWhenDone(NULL), m_pNext(NULL),
    m_lPriority(0), m_fOk( true ), m_phTask(NULL)
{
#ifdef WINMGMT_THREAD_DEBUG
    CInCritSec ics(&mstatic_cs);
    mstatic_apOut.Add(this);
#endif
// has no affect    CCoreServices::g_pSvc->IncrementCounter(WMICORE_SELFINST_TASKS, 1);
}

CCoreExecReq::~CCoreExecReq()
{
#ifdef WINMGMT_THREAD_DEBUG
    CInCritSec ics(&mstatic_cs);
    for(int i = 0; i < mstatic_apOut.GetSize(); i++)
    {
        if(mstatic_apOut[i] == this)
        {
            mstatic_apOut.RemoveAt(i);
            break;
        }
    }
#endif
    if (m_phTask)
    {
		PCWmiTask(m_phTask)->MergeTaskStatusBit(WMICORE_TASK_STATUS_CORE_COMPLETED);
        m_phTask->Release();
        m_phTask = 0;
    }
//    removed because g_pSvc could be deleted at this point.  Also, if not,
//    this ignored anyway by the DecrementCounter code!
//    CCoreServices::g_pSvc->DecrementCounter(WMICORE_SELFINST_TASKS, 1);
}

HRESULT CCoreExecReq::SetTaskHandle(_IWmiCoreHandle *phTask)
{
    if (phTask)
    {
        phTask->AddRef();
        m_phTask = phTask;
    }
    return WBEM_S_NO_ERROR;
}

DWORD CCoreQueue::GetTlsIndex()
{
    return mstatic_dwTlsIndex;
}

//
//
//
void CCoreQueue::SetArbitrator(_IWmiArbitrator* pArbitrator)
{
	if (!m_pArbitrator)
	{
       	m_pArbitrator = pArbitrator;
       	if (m_pArbitrator)
       		m_pArbitrator->AddRef();
	}
}

//
// Be VERY CAREFUL when using this function.  It's here to support
// merger requests which actually execute a number of unqueued requests
// and in order to stay consistent, we want to ensure that the current
// request points to the true request, and not the dummy request we
// created as a starting point.
//

HRESULT CCoreQueue::ExecSubRequest( CCoreExecReq* pNewRequest )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

    CThreadRecord* pRecord = (CThreadRecord*)TlsGetValue(GetTlsIndex());
    if(pRecord)
    {
		if ( !pRecord->m_bExitNow )
		{
			CCoreExecReq* pCurrReq = pRecord->m_pCurrentRequest;

			pRecord->m_pCurrentRequest = pNewRequest;
			pRecord->m_pQueue->Execute( pRecord );

			// Restore the request
			pRecord->m_pCurrentRequest = pCurrReq;
		}
		else
		{
			hr = WBEM_E_SHUTTING_DOWN;
		}
    }
	else
	{
		hr = WBEM_E_FAILED;
	}

    return hr;
}


CCoreQueue::CThreadRecord::CThreadRecord(CCoreQueue* pQueue):
      m_pQueue(pQueue),
      m_pCurrentRequest(NULL),
      m_bReady(FALSE),
      m_bExitNow(FALSE)
{
    if (m_pQueue)
        m_pQueue->AddRef();
    m_hAttention = CreateEvent(NULL, FALSE, FALSE, NULL);
}

CCoreQueue::CThreadRecord::~CThreadRecord()
{
    CloseHandle(m_hAttention);
    CloseHandle(m_hThread);
    if (m_pQueue)
        m_pQueue->Release();
}

void CCoreQueue::CThreadRecord::Signal()
{
    SetEvent(m_hAttention);
}


//******************************************************************************
//
//  See execq.h for documentation
//
//******************************************************************************
CCoreQueue::CCoreQueue() : m_lNumThreads(0), m_lMaxThreads(1), m_lNumIdle(0),
    m_lNumRequests(0), m_pHead(NULL), m_pTail(NULL), m_dwTimeout(IDLE_THREAD_TIMEOUT),
    m_dwOverflowTimeout(OVERLFLOW_TIMEOUT), m_lHiPriBound(-1), m_lHiPriMaxThreads(1),
    m_lRef(0),
    m_bShutDownCalled(FALSE)
{
    InitTls();

	m_pArbitrator = NULL;	

    SetRequestLimits(4000);
}

//******************************************************************************
//
//  See execq.h for documentation
//
//******************************************************************************
CCoreQueue::~CCoreQueue()
{
    try
    {
	    Shutdown(FALSE); // SystemShutDown isa calles Explicitly

	    // Remove all outstanding requests
	    // ===============================

	    while(m_pHead)
	    {
	        CCoreExecReq* pReq = m_pHead;
	        m_pHead = m_pHead->GetNext();
	        delete pReq;
	    }

		if ( m_pArbitrator )
		{
			m_pArbitrator->Release ( ) ;
			m_pArbitrator = NULL ;
		}

    }   // end try
    catch(...) // To protect svchost.exe; we know this isn't a good recovery for WMI
    {
        ExceptionCounter c;    
        ERRORTRACE((LOG_WBEMCORE, "CCoreQueue() destructor exception\n"));
    }
}

void CCoreQueue::Shutdown(BOOL bIsSystemShutDown)
{
    try
    {
	    CCritSecWrapper cs(&m_cs);

	    if (!m_bShutDownCalled)
	    {
	        m_bShutDownCalled = TRUE;
	    }
	    else
	    {
	        return;
	    }

	    // Get all member thread handles
	    // =============================

		cs.Enter();
		int nNumHandles = m_aThreads.Size();
		HANDLE* ah = new HANDLE[nNumHandles];
		if (NULL == ah)
		{
	        nNumHandles = 0;
		}
		DEBUGTRACE((LOG_WBEMCORE, "Queue is shutting down!\n"));

		int i;
		for(i = 0; i < nNumHandles; i++)
		{
		    CThreadRecord* pRecord = (CThreadRecord*)m_aThreads[i];
		    ah[i] = pRecord->m_hThread;

		    // Inform the thread it should go away when ready
		    // ==============================================

		    pRecord->m_bExitNow = TRUE;

		    // Wake it up if necessary
		    // =======================
		
	        pRecord->Signal();
	    }
	    cs.Leave();


	    // Make sure all our threads are gone
	    // ==================================

	    if(nNumHandles > 0 && !bIsSystemShutDown)
	    {
	        WaitForMultipleObjects(nNumHandles, ah, TRUE, 10000);
	    }

	    for(i = 0; i < nNumHandles; i++)
	        CloseHandle(ah[i]);

	    delete [] ah;

    }   // end try
    catch(...) 
    {
        ExceptionCounter c;    
        ERRORTRACE((LOG_WBEMCORE, "CCoreQueue() destructor exception\n"));
    }
}

//******************************************************************************
//
//  See execq.h for documentation
//
//******************************************************************************
// static
void CCoreQueue::InitTls()
{
    if(InterlockedIncrement(&mstatic_lNumInits) == 0)
    {
        mstatic_dwTlsIndex = TlsAlloc();
    }
}

void CCoreQueue::Enter()
{
    EnterCriticalSection(&m_cs);
}

void CCoreQueue::Leave()
{
    LeaveCriticalSection(&m_cs);
}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
void CCoreQueue::Register(CThreadRecord* pRecord)
{
    TlsSetValue(mstatic_dwTlsIndex, (void*)pRecord);
}

BOOL CCoreQueue::IsSuitableThread(CThreadRecord* pRecord, CCoreExecReq* pReq)
{
    if(pRecord->m_pCurrentRequest == NULL)
        return TRUE;

    // This thread is in the middle of something. By default, ignore it
    // ================================================================

    return FALSE;
}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
HRESULT CCoreQueue::Enqueue(CCoreExecReq* pRequest, HANDLE* phWhenDone)
{
    try
    {

	    CCritSecWrapper cs(&m_cs);

	    if (m_bShutDownCalled)
	    {
	        return WBEM_E_SHUTTING_DOWN;
	    }

	    // Check if the request has a problem with it.  If so, return the
	    // appropriate error code.

	    if ( !pRequest->IsOk() )
	    {
	        return WBEM_E_OUT_OF_MEMORY;
	    }

#ifdef __COLLECT_ALLOC_STAT
	    pRequest->m_Stack.Create(0, FALSE);
#endif

		// Create an event handle to signal when request is finished, if required
	    // ======================================================================

	    if(phWhenDone)
	    {
	        *phWhenDone = CreateEvent(NULL, FALSE, FALSE, NULL);

			if ( NULL == *phWhenDone )
			{
				return WBEM_E_OUT_OF_MEMORY;
			}

	        pRequest->SetWhenDoneHandle(*phWhenDone);
	    }

	    cs.Enter();
		
		// Search for a suitable thread
	    // ============================

	    for(int i = 0; i < m_aThreads.Size(); i++)
	    {
	        CThreadRecord* pRecord = (CThreadRecord*)m_aThreads[i];

	        if(pRecord->m_bReady)
	        {
	            // Free. Check if suitable
	            // =======================

	            if(IsSuitableThread(pRecord, pRequest))
	            {
	                THREADDEBUGTRACE((LOG_WBEMCORE, "Enqueueing request %p onto a "
	                    "thread record %p. Previous request: %p\n", pRequest,
	                    pRecord, pRecord->m_pCurrentRequest));

	                pRecord->m_pCurrentRequest = pRequest;
	                THREADDEBUGTRACE((LOG_WBEMCORE, "In Enqueue, changing m_bReady "
	                    "for thread %p to 0. Was: %d\n", pRecord,
	                    pRecord->m_bReady));
	                pRecord->m_bReady = FALSE;
	                pRecord->Signal();
	                m_lNumIdle--;

	                // Done!
	                // =====

	                cs.Leave();
	                return WBEM_S_NO_ERROR;
	            }
	        }
	    }

		BOOL bNeedsAttention = FALSE ;

		if ( IsDependentRequest ( pRequest ) || ( (CWbemRequest*) pRequest)->GetForceRun ( ) > 0 )
		{
			bNeedsAttention = TRUE ;
		}

		THREADDEBUGTRACE((LOG_WBEMCORE, "Enqueueing request %p onto the queue\n",
		    pRequest));

		// No suitable thread found. Add to the queue
		// ==========================================

		if(m_lNumRequests >= m_lAbsoluteLimitCount && !bNeedsAttention )
		{
		    cs.Leave();
		    return WBEM_E_FAILED;
		}

		// Search for insert position based on priority
		// ============================================
		if ( !bNeedsAttention )
		{
			AdjustInitialPriority(pRequest);
		}
		else
		{		
			pRequest->SetPriority(0xA0000000);
		}


		if ( bNeedsAttention )
		{
			if (!CreateNewThread ( TRUE ))
			{
				if (0 == m_aThreads.Size())
				{
					cs.Leave();
					return WBEM_E_OUT_OF_MEMORY;
				}
			}
		}
		else
		{
			if(DoesNeedNewThread(pRequest, true))
			{
				if (!CreateNewThread())
				{
					if (0 == m_aThreads.Size())
					{
						cs.Leave();
						return WBEM_E_OUT_OF_MEMORY;
					}

				}	// IF !CreateNewThread

			}	// IF DoesNeedNewThread

		}	// ELSE !bNeedsAttention

		HRESULT hr = PlaceRequestInQueue( pRequest );

		long lIndex = m_lNumRequests;
		cs.Leave();

		if ( SUCCEEDED( hr ) )
		{
			SitOutPenalty(lIndex);
		}

		return hr;

    }   // end try
    catch(...) 
    {
        ExceptionCounter c;    
        ERRORTRACE((LOG_WBEMCORE, "CCoreQueue::Enqueue() exception\n"));
        return WBEM_E_CRITICAL_ERROR;
    }
}


//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
HRESULT CCoreQueue::EnqueueWithoutSleep(CCoreExecReq* pRequest, HANDLE* phWhenDone)
{
    try
    {

	    CCritSecWrapper cs(&m_cs);

	    // Check if the request has a problem with it.  If so, return the
	    // appropriate error code.

	    if ( !pRequest->IsOk() )
	    {
	        return WBEM_E_OUT_OF_MEMORY;
	    }

#ifdef __COLLECT_ALLOC_STAT
	    pRequest->m_Stack.Create(0, FALSE);
#endif
	    // Create an event handle to signal when request is finished, if required
	    // ======================================================================

	    if(phWhenDone)
	    {
	        *phWhenDone = CreateEvent(NULL, FALSE, FALSE, NULL);
	        pRequest->SetWhenDoneHandle(*phWhenDone);
	    }

	    cs.Enter();

	    // Search for a suitable thread
	    // ============================

	    for(int i = 0; i < m_aThreads.Size(); i++)
	    {
	        CThreadRecord* pRecord = (CThreadRecord*)m_aThreads[i];

	        if(pRecord->m_bReady)
	        {
	            // Free. Check if suitable
	            // =======================

	            if(IsSuitableThread(pRecord, pRequest))
	            {
	                THREADDEBUGTRACE((LOG_WBEMCORE, "Enqueueing request %p onto a "
	                    "thread record %p. Previous request: %p\n", pRequest,
	                    pRecord, pRecord->m_pCurrentRequest));

	                pRecord->m_pCurrentRequest = pRequest;
	                THREADDEBUGTRACE((LOG_WBEMCORE, "In Enqueue, changing m_bReady "
	                    "for thread %p to 0. Was: %d\n", pRecord,
	                    pRecord->m_bReady));
	                pRecord->m_bReady = FALSE;
	                pRecord->Signal();
	                m_lNumIdle--;

	                // Done!
	                // =====

	                cs.Leave();
	                return WBEM_S_NO_ERROR;
	            }
	        }
	    }

	    THREADDEBUGTRACE((LOG_WBEMCORE, "Enqueueing request %p onto the queue\n",
	        pRequest));

	    // No suitable thread found. Add to the queue
	    // ==========================================

	    if(m_lNumRequests >= m_lAbsoluteLimitCount)
	    {
	        cs.Leave();
	        return WBEM_E_FAILED;
	    }

	    // Search for insert position based on priority
	    // ============================================

	    AdjustInitialPriority(pRequest);

		// Create a new thread, if required
		// ================================
		if(DoesNeedNewThread(pRequest, true))
		{
			if (!CreateNewThread())
			{
				if (0 == m_aThreads.Size())
				{
					cs.Leave();
					return WBEM_E_OUT_OF_MEMORY;
				}
			}
		}

		HRESULT hr = PlaceRequestInQueue( pRequest );

		long lIndex = m_lNumRequests;
		cs.Leave();

	    return hr;

    }   // end try
    catch(...) 
    {
        ExceptionCounter c;    
        ERRORTRACE((LOG_WBEMCORE, "CCoreQueue::EnqueueWithoutSleep() exception\n"));
        return WBEM_E_CRITICAL_ERROR;
    }
}

HRESULT CCoreQueue::PlaceRequestInQueue( CCoreExecReq* pRequest )
{
    CCoreExecReq* pCurrent = m_pHead;
    CCoreExecReq* pLast = NULL;

	// Tracks whether or not we need to cleanup the queue
	bool		bQueued = false;

	try
	{
		// Find a spot in the current queue based on priority
		while(pCurrent && pCurrent->GetPriority() <= pRequest->GetPriority())
		{
			pLast = pCurrent;
			pCurrent = pCurrent->GetNext();
		}

		// Insert
		// ======

		// If we have a pCurrent pointer, then pRequest is higher in priority, so should
		// be inserted before it.  Otherwise, we are inserting at the end of the queue

		if(pCurrent)
		{
			pRequest->SetNext(pCurrent);
		}
		else
		{
			m_pTail = pRequest;
		}

		// If we have a pLast pointer, we need to point it at pRequest, otherwise, we
		// are inserting at the head of the queue.
		if(pLast)
		{
			pLast->SetNext(pRequest);
		}
		else
		{
			m_pHead = pRequest;
		}

		m_lNumRequests++;

		bQueued = true;

		// Adjust priorities of the loosers
		// ================================

		while(pCurrent)
		{
			AdjustPriorityForPassing(pCurrent);
			pCurrent = pCurrent->GetNext();
		}

		return WBEM_S_NO_ERROR;
	}
	catch( ... )
	{
		// Fixup the queue if necessary
		if ( bQueued )
		{
			// Fixup the tail to point to the last request
			if ( pRequest == m_pTail )
			{
				m_pTail = pLast;
			}

			// Fixup the head to point to the next request
			if ( pRequest == m_pHead )
			{
				m_pHead = pRequest->GetNext();
			}

			// Fixup pLast to skip over the current request
			if ( NULL != pLast )
			{
				pLast->SetNext( pRequest->GetNext() );
			}

			// Decrement this
			m_lNumRequests--;

		}

		return WBEM_E_CRITICAL_ERROR;
	}

}

DWORD CCoreQueue::CalcSitOutPenalty(long lRequestIndex)
{
    if(lRequestIndex <= m_lStartSlowdownCount)
        return 0; // no penalty

    if(lRequestIndex >= m_lAbsoluteLimitCount)
        lRequestIndex = m_lAbsoluteLimitCount;

    // Calculate the timeout
    // =====================

    double dblTimeout =
        m_dblAlpha / (m_lAbsoluteLimitCount - lRequestIndex) +
            m_dblBeta;

    // Return penalty
    // ===========

    return ((DWORD) dblTimeout);
}

void CCoreQueue::SitOutPenalty(long lRequestIndex)
{
    DWORD   dwSitOutPenalty = CalcSitOutPenalty( lRequestIndex );

    // Sleep on it
    // ===========

    if ( 0 != dwSitOutPenalty )
    {
        Sleep( dwSitOutPenalty );
    }
}


HRESULT CCoreQueue::EnqueueAndWait(CCoreExecReq* pRequest)
{
    if(IsAppropriateThread())
    {
        pRequest->Execute();
        delete pRequest;
        return WBEM_S_NO_ERROR;
    }

    HANDLE hWhenDone = NULL;
    HRESULT hr = Enqueue(pRequest, &hWhenDone);

	// Scoped closing of the handle
	CCloseMe	cmWhenDone( hWhenDone );

    if ( FAILED(hr) )
    {
        return hr;
    }

    DWORD dwRes = CCoreQueue::QueueWaitForSingleObject(hWhenDone, INFINITE);

    return ( dwRes == WAIT_OBJECT_0 ? WBEM_S_NO_ERROR : WBEM_E_FAILED );
}


BOOL CCoreQueue::DoesNeedNewThread(CCoreExecReq* pRequest, bool bIgnoreNumRequests )
{
	// We will ignore the number or requests ONLY if requested
	// Default is to check if there are any threads in the queue

    if(m_lNumIdle > 0 || ( !bIgnoreNumRequests && m_lNumRequests == 0 ) )
        return FALSE;

    if(m_lNumThreads < m_lMaxThreads)
        return TRUE;
    else if(pRequest->GetPriority() <= m_lHiPriBound &&
            m_lNumThreads < m_lHiPriMaxThreads)
        return TRUE;
    else
        return FALSE;
}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
BOOL CCoreQueue::Execute(CThreadRecord* pRecord)
{
    try
    {
	    CCoreExecReq * pReq = pRecord->m_pCurrentRequest;

#ifdef __COLLECT_ALLOC_STAT
	    CStackContinuation Cont;
	    Cont.m_pPrevStack = &pReq->m_Stack;
	    CStackContinuation* pPrev = CStackContinuation::Set(&Cont);
#endif

	    HRESULT hres;

	    hres = pReq->Execute();

#ifdef __COLLECT_ALLOC_STAT
	    CStackContinuation::Set(pPrev);
#endif

	    if(hres == RPC_E_RETRY)
	    {
	        // The request has been postponed
	        // ==============================

	        THREADDEBUGTRACE((LOG_WBEMCORE, "Thread %p postponed request %p\n",
	                    pRecord, pReq));
	    }
	    else
	    {
	        if(hres != 0)
	        {
	            LogError(pReq, hres);
	        }

	        HANDLE hWhenDone = pReq->GetWhenDoneHandle();
	        if(hWhenDone != NULL)
	        {
	            SetEvent(hWhenDone);
	        }

	        THREADDEBUGTRACE((LOG_WBEMCORE, "Thread %p done with request %p\n",
	                        pRecord, pReq));
	        delete pReq;
	    }

	    pRecord->m_pCurrentRequest = NULL;
	    return TRUE;

    }   // end try
    catch(...) 
    {
        ExceptionCounter c;    
        ERRORTRACE((LOG_WBEMCORE, "CCoreQueue::Execute() exception\n"));
        return FALSE;
    }
}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
void CCoreQueue::LogError(CCoreExecReq* pRequest, int nRes)
{
    try
    {
	    DEBUGTRACE((LOG_WBEMCORE,
	        "Error %X occured executing queued request\n", nRes));
	    pRequest->DumpError();
    }
    catch (CX_MemoryException &)
    {
        // we might be using Internal CWbemClass|Instance
        // interfaces that throws.
        // the caller thread is unprepared to handle exceptions ...
    }
}

void CCoreQueue::InitializeThread()
{
    InitializeCom();
}

void CCoreQueue::UninitializeThread()
{
    if(IsDcomEnabled() || IsNT())
        CoUninitialize();
}


CCoreExecReq* CCoreQueue::SearchForSuitableRequest(CThreadRecord* pRecord)
{
    try
    {

	    // Assumes in critical section
	    // ===========================

	    CCoreExecReq* pCurrent = m_pHead;
	    CCoreExecReq* pPrev = NULL;

		while(pCurrent)
		{
			if(IsSuitableThread(pRecord, pCurrent))
			{
				// Always except dependent requests, otherwise, we only accept requests if we are accepting
				// new tasks

				if ( IsDependentRequest( pCurrent ) || ((CWmiArbitrator*) m_pArbitrator)->AcceptsNewTasks() )
				{
					// Found one --- take it
					// =====================

					if(pPrev)
						pPrev->SetNext(pCurrent->GetNext());
					else
						m_pHead = pCurrent->GetNext();

					if(pCurrent == m_pTail)
						m_pTail = pPrev;

					m_lNumRequests--;
					break;
				}
				else
				{
					// This means we have a primary task *and* we are not accepting new tasks.  Since there
					// should NEVER be dependent tasks following primary tasks, we'll give up now.

					pCurrent = NULL;
					break;
				}
			}

			pPrev = pCurrent;
			pCurrent = pCurrent->GetNext();
		}

	    return pCurrent;

    }   // end try
    catch(...) 
    {
        ExceptionCounter c;    
        ERRORTRACE((LOG_WBEMCORE, "CCoreQueue::SearchForSuitableRequest() exception\n"));
        return NULL;
    }
}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
void CCoreQueue::ThreadMain(CThreadRecord* pRecord)
{
    CCritSecWrapper cs(&m_cs);

    InitializeThread();

    // Register this queue with this thread, so any further wait would be
    // interruptable
    // ==================================================================

    Register(pRecord);

    while (1)
    {
        // Returning from work. At this point, our event is not signaled,
        // our m_pCurrentRequest is NULL and our m_bReady is FALSE
        // ====================================================================

        // Search for work in the queue
        // ============================

        cs.Enter();

        CCoreExecReq* pCurrent = SearchForSuitableRequest(pRecord);
        if(pCurrent)
        {
            // Found some. Take it
            // ===================

            pRecord->m_pCurrentRequest = pCurrent;
        }
        else
        {
            // No work in the queue. Wait
            // ==========================

            THREADDEBUGTRACE((LOG_WBEMCORE, "ThreadMain of %p is setting Ready to "
                "TRUE. Was: %d\n", pRecord, pRecord->m_bReady));
            pRecord->m_bReady = TRUE;
            m_lNumIdle++;
            DWORD dwTimeout = GetIdleTimeout(pRecord);
            cs.Leave();
            DWORD dwRes = WbemWaitForSingleObject(pRecord->m_hAttention,
                                        dwTimeout);
            cs.Enter();

            if(dwRes != WAIT_OBJECT_0)
            {
                // Check if someone managed to place a request in our record
                // after the timeout.
                // =========================================================

                if(WbemWaitForSingleObject(pRecord->m_hAttention, 0) ==
                    WAIT_OBJECT_0)
                {
                    DEBUGTRACE((LOG_WBEMCORE, "AMAZING: Thread %p received "
                        "request %p after timing out. Returning to the "
                        "queue\n", pRecord, pRecord->m_pCurrentRequest));

                    if(pRecord->m_bExitNow || pRecord->m_pCurrentRequest == NULL)
                    {
                        THREADDEBUGTRACE((LOG_WBEMCORE, "Thread %p being stopped --- %d "
                            "requests in the queue (head = %p)\n", pRecord,
                            pRecord->m_pQueue->m_lNumRequests,
                            pRecord->m_pQueue->m_pHead));
                        ShutdownThread(pRecord);
                        cs.Leave();
                        return;
                    }
                    pRecord->m_pQueue->Enqueue(pRecord->m_pCurrentRequest);
                    pRecord->m_pCurrentRequest = NULL;
                }

                // Timeout. See if it is time to quit
                // ==================================

                THREADDEBUGTRACE((LOG_WBEMCORE, "ThreadMain of %p is setting Ready "
                    " to FALSE on timeout. Was: %d\n",
                    pRecord, pRecord->m_bReady));

                pRecord->m_bReady = FALSE;
                if(IsIdleTooLong(pRecord, dwTimeout))
                {
                    THREADDEBUGTRACE((LOG_WBEMCORE, "Thread %p timing out --- %d "
                        "requests in the queue (head = %p)\n", pRecord,
                        pRecord->m_pQueue->m_lNumRequests,
                        pRecord->m_pQueue->m_pHead));
                    ShutdownThread(pRecord);
                    cs.Leave();
                    return;
                }

                // Go and wait a little more
                // =========================

                m_lNumIdle--;
                cs.Leave();
                continue;
            }
            else
            {
                // Check why we were awaken
                // ========================

                if(pRecord->m_bExitNow || pRecord->m_pCurrentRequest == NULL)
                {
                    THREADDEBUGTRACE((LOG_WBEMCORE, "Thread %p being stopped --- %d "
                        "requests in the queue (head = %p)\n", pRecord,
                        pRecord->m_pQueue->m_lNumRequests,
                        pRecord->m_pQueue->m_pHead));
                    ShutdownThread(pRecord);
                    cs.Leave();
                    return;
                }

                // We have a request. Enqueue already adjusted lNumIdle and
                // our m_bReady;
            }
        }

        // Execute the request
        // ===================

#ifdef WINMGMT_THREAD_DEBUG
        if(pRecord->m_bReady)
            DebugBreak();
#endif

        THREADDEBUGTRACE((LOG_WBEMCORE, "Thread %p picking up normal request %p\n",
            pRecord, pRecord->m_pCurrentRequest));
        cs.Leave();
        Execute(pRecord);

#ifdef WINMGMT_THREAD_DEBUG
        if(pRecord->m_bReady)
            DebugBreak();
#endif
    }
}

DWORD CCoreQueue::GetIdleTimeout(CThreadRecord* pRecord)
{
    if(m_lNumThreads > m_lMaxThreads)
        return m_dwOverflowTimeout;
    else
        return m_dwTimeout;
}

BOOL CCoreQueue::IsIdleTooLong(CThreadRecord* pRecord, DWORD dwTimeout)
{
    if(m_lNumThreads > m_lMaxThreads)
        return TRUE;
    else if(dwTimeout < m_dwTimeout)
        return FALSE;
	else if ( m_lNumRequests > 0 && m_lNumThreads == 1 )
	{
		// If there are requests in the queue, and we're the only thread in the system, we shouldn't die.
		// The likelihood is that memory usage is causing the arbitrator to refuse tasks, and therefore
		// also disabling us from servicing requests (see SearchForSuitableRequest).
		return FALSE;
	}
    else
        return TRUE;
}

void CCoreQueue::ShutdownThread(CThreadRecord* pRecord)
{
    try
    {

	    CCritSecWrapper cs(&m_cs);

	    cs.Enter();
	    TlsSetValue(mstatic_dwTlsIndex, NULL);
	    for(int i = 0; i < m_aThreads.Size(); i++)
	    {
	        if(m_aThreads[i] == pRecord)
	        {
	            m_aThreads.RemoveAt(i);

	            // Make sure we don't close the handle if the queue's Shutdown is
	            // waiting on it
	            // ==============================================================

	            if(pRecord->m_bExitNow)
	                pRecord->m_hThread = NULL;
	            delete pRecord;
	            m_lNumIdle--;
	            m_lNumThreads--;

	            break;
	        }
	    }
	    UninitializeThread();
	    cs.Leave();

    }   // end try
    catch(...) 
    {
        ExceptionCounter c;    
        ERRORTRACE((LOG_WBEMCORE, "CCoreQueue::ShutdownThread() exception\n"));
    }
}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
// static
extern LONG g_lCoreThreads;

DWORD WINAPI CCoreQueue::_ThreadEntry(LPVOID pObj)
{

    try
    {
        InterlockedIncrement(&g_lCoreThreads);

		RecordPeakThreadCount ( );

	    CThreadRecord* pRecord = (CThreadRecord*)pObj;
	    CCoreQueue* pQueue = pRecord->m_pQueue;
	    if(pQueue)
	    {
	        pQueue->AddRef();
			pQueue->ThreadMain(pRecord);
			pQueue->Release();
	    }

	    InterlockedDecrement(&g_lCoreThreads);

    }   // end try
    catch(...) 
    {
        ExceptionCounter c;    
        ERRORTRACE((LOG_WBEMCORE, "CCoreQueue::_ThreadEntry() unhandled exception\n"));
    }
    
    return 0;
}

DWORD WINAPI CCoreQueue::_ThreadEntryRescue (LPVOID pObj)
{    
    try
    {		
	    InterlockedIncrement ( &m_lEmergencyThreads ) ;
	    RecordPeakThreadCount ( );

	    CThreadRecord* pRecord = (CThreadRecord*)pObj;
	    CCoreQueue* pQueue = pRecord->m_pQueue;
	    if(pQueue)
	    {
	        pQueue->AddRef();

			if ( m_pArbitrator )
			{
				( (CWmiArbitrator*) m_pArbitrator)->DecUncheckedCount ( ) ;
			}

			pQueue->ThreadMain(pRecord);

			if ( m_pArbitrator )
			{
				( (CWmiArbitrator*) m_pArbitrator)->IncUncheckedCount ( ) ;
			}	

			pQueue->Release();
	    }

		InterlockedDecrement ( &m_lEmergencyThreads ) ;



	    return 0;

    }   // end try
    catch(...) 
    {
        ExceptionCounter c;    
        ERRORTRACE((LOG_WBEMCORE, "CCoreQueue::ThreadEntryRescue() exception\n"));
        return 0;
    }
   
}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
BOOL CCoreQueue::CreateNewThread ( BOOL bNeedsAttention )
{
    try
    {
	    CInCritSec ics(&m_cs);

	    // Create new thread record
	    // ========================

	    CThreadRecord* pNewRecord = new CThreadRecord(this);
	    if (NULL == pNewRecord)
	        return FALSE;
	    if (0 != m_aThreads.Add(pNewRecord))
	    {
			delete pNewRecord;
	        return FALSE;
	    }

	    DWORD dwId;

		if ( !bNeedsAttention )
		{
			pNewRecord->m_hThread = CreateThread(0, 0, _ThreadEntry, pNewRecord, 0,
													&dwId);
		}
		else
		{
			pNewRecord->m_hThread = CreateThread(0, 0, _ThreadEntryRescue, pNewRecord, 0,
													&dwId);
		}

	    if(pNewRecord->m_hThread == NULL)
	    {
	        m_aThreads.RemoveAt(m_aThreads.Size()-1);
	        delete pNewRecord;
	        return FALSE;
	    }
	    else
	    {
			m_lNumThreads++;
	        return TRUE;
	    }

    }   // end try
    catch(...) 
    {
        ExceptionCounter c;    
        ERRORTRACE((LOG_WBEMCORE, "CCoreQueue::CreateNewThread() exception\n"));
        return FALSE;
    }
}

DWORD CompensateForBug(DWORD dwOriginal, DWORD dwElapsed)
{
    if(dwOriginal == 0xFFFFFFFF)
        return 0xFFFFFFFF;

    DWORD dwLeft = dwOriginal - dwElapsed;
    if(dwLeft > 0x7FFFFFFF)
        dwLeft = 0x7FFFFFFF;

    return dwLeft;
}

DWORD CCoreQueue::WaitForSingleObjectWhileBusy(HANDLE hHandle, DWORD dwWait,
                                                CThreadRecord* pRecord)
{
    CCritSecWrapper cs(&m_cs);

    CCoreExecReq* pOld = pRecord->m_pCurrentRequest;
    DWORD dwStart = GetTickCount();
    while (dwWait > GetTickCount() - dwStart)
    {
        // Search for work in the queue
        // ============================

        cs.Enter();
        CCoreExecReq* pCurrent = SearchForSuitableRequest(pRecord);
        if(pCurrent != NULL)
        {
            THREADDEBUGTRACE((LOG_WBEMCORE, "QUEUE: While busy, found work in the "
                "queue: thread %p, request %p, old request %p\n", pRecord,
                pCurrent, pRecord->m_pCurrentRequest));
            pRecord->m_pCurrentRequest = pCurrent;

            if(pRecord->m_pCurrentRequest == pOld)
            {
                // Something is very wrong
                // =======================

#ifdef WINMGMT_THREAD_DEBUG
                DebugBreak();
#endif
            }
        }
        else
        {
            // No work in the queue. Wait
            // ==========================

            THREADDEBUGTRACE((LOG_WBEMCORE, "While Busy thread %p is setting Ready "
                "to TRUE. Was: %d\n", pRecord, pRecord->m_bReady));

            pRecord->m_bReady = TRUE;

            // Block until a request comes through.
            // ====================================

            HANDLE ahSems[2];
            ahSems[0] = hHandle;
            ahSems[1] = pRecord->m_hAttention;

            cs.Leave();
            DWORD dwLeft = CompensateForBug(dwWait, (GetTickCount() - dwStart));
            DWORD dwRes = WbemWaitForMultipleObjects(2, ahSems, dwLeft);

            cs.Enter();
            THREADDEBUGTRACE((LOG_WBEMCORE, "While Busy thread %p is setting Ready "
                "to FALSE. Was: %d\n", pRecord, pRecord->m_bReady));
            pRecord->m_bReady = FALSE;
            if(dwRes != WAIT_OBJECT_0 + 1)
            {
                // Either our target handle is ready or we timed out
                // =================================================

                // Check if anyone placed a request in our record
                // ==============================================

                if(pRecord->m_pCurrentRequest != pOld)
                {
                    // Re-issue it to the queue
                    // ========================

                    DEBUGTRACE((LOG_WBEMCORE, "SURPRIZE: Somebody placed "
                        "request %p into thread record %p while it was getting "
                        "ready to continue. Reissuing\n",
                        pRecord->m_pCurrentRequest, pRecord));

                    pRecord->m_pQueue->Enqueue(pRecord->m_pCurrentRequest);
                    pRecord->m_pCurrentRequest = pOld;

                    // Decrement our semaphore
                    // =======================

                    dwRes = WaitForSingleObject(pRecord->m_hAttention, 0);
                    if(dwRes != WAIT_OBJECT_0)
                    {
                        // Internal error --- whoever placed the request had
                        // to have upped the semaphore
                        // =================================================

                        ERRORTRACE((LOG_WBEMCORE, "Internal error: queue "
                            "semaphore is too low\n"));
                    }
                }

                cs.Leave();
                return dwRes;
            }
            else
            {
                // Check why we were awaken
                // ========================

                if(pRecord->m_bExitNow || pRecord->m_pCurrentRequest == NULL)
                {
                    // Can't exit in the middle of a request. Leave it for later
                    // =========================================================

                    pRecord->Signal();
                    cs.Leave();
                    DWORD dwLeft = CompensateForBug(dwWait,
                                        (GetTickCount() - dwStart));
                    return WbemWaitForSingleObject(hHandle, dwLeft);
                }

                // We've got work to do
                // ====================

                if(pRecord->m_pCurrentRequest == pOld)
                {
                    // Something is very wrong
                    // =======================

#ifdef WINMGMT_THREAD_DEBUG
                    DebugBreak();
#endif
                }
            }
        }

        // Execute the request
        // ===================

        THREADDEBUGTRACE((LOG_WBEMCORE, "Switching to a dependent request %p. "
                "Previous was %p\n", pRecord->m_pCurrentRequest, pOld));
        cs.Leave();
        Execute(pRecord);
        pRecord->m_pCurrentRequest = pOld;
        THREADDEBUGTRACE((LOG_WBEMCORE, "Going back to request %p\n", pOld));
    }
    return WAIT_TIMEOUT;
}

DWORD CCoreQueue::UnblockedWaitForSingleObject(HANDLE hHandle, DWORD dwWait,
                                                CThreadRecord* pRecord)
{
    CCritSecWrapper cs(&m_cs);

    // Silently bump the max threads count.  We will not allow the queue to reuse
    // this thread, so we need to account for this missing thread while we
    // are blocked.  Essentially, we are hijacking the code that was hijacking
    // the thread

    cs.Enter();
        m_lMaxThreads++;
        m_lHiPriMaxThreads++;
    cs.Leave();

    DWORD   dwRet = WbemWaitForSingleObject( hHandle, dwWait );

    // The thread is back, so bump down the max threads number.  If extra threads were in
    // fact created, they should eventually peter out and go away.
    cs.Enter();
        m_lMaxThreads--;
        m_lHiPriMaxThreads--;
    cs.Leave();

    return dwRet;
}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
// static
DWORD CCoreQueue::QueueWaitForSingleObject(HANDLE hHandle, DWORD dwWait)
{
    try
    {
	    InitTls();

	    // Get the queue that is registered for this thread, if any
	    // ========================================================

	    CThreadRecord* pRecord = (CThreadRecord*)TlsGetValue(mstatic_dwTlsIndex);

	    if(pRecord == NULL)
	    {
	        // No queue is registered with this thread. Just wait
	        // ==================================================

	        return WbemWaitForSingleObject(hHandle, dwWait);
	    }

	    CCoreQueue* pQueue = pRecord->m_pQueue;

	    return pQueue->WaitForSingleObjectWhileBusy(hHandle, dwWait, pRecord);

    }
    catch(...) 
    {
        ExceptionCounter c;    
        ERRORTRACE((LOG_WBEMCORE, "CCoreQueue::QueueWaitForSingleObject() exception\n"));
        return WAIT_TIMEOUT;
    }
}

// static
DWORD CCoreQueue::QueueUnblockedWaitForSingleObject(HANDLE hHandle, DWORD dwWait)
{
    try
    {
	    InitTls();

	    // Get the queue that is registered for this thread, if any
	    // ========================================================

	    CThreadRecord* pRecord = (CThreadRecord*)TlsGetValue(mstatic_dwTlsIndex);

	    if(pRecord == NULL)
	    {
	        // No queue is registered with this thread. Just wait
	        // ==================================================

	        return WbemWaitForSingleObject(hHandle, dwWait);
	    }

	    CCoreQueue* pQueue = pRecord->m_pQueue;

	    return pQueue->UnblockedWaitForSingleObject(hHandle, dwWait, pRecord);

    }   // end try
    catch(...) 
    {
        ExceptionCounter c;    
        ERRORTRACE((LOG_WBEMCORE, "CCoreQueue::QueueUnblockedWaitForSingleObject() exception\n"));
        return WAIT_TIMEOUT;
    }
}

BOOL CCoreQueue::SetThreadLimits(long lMaxThreads, long lHiPriMaxThreads,
                                    long lHiPriBound)
{
    m_lMaxThreads = lMaxThreads;
    if(lHiPriMaxThreads == -1)
        m_lHiPriMaxThreads = lMaxThreads * 1.1;
    else
        m_lHiPriMaxThreads = lHiPriMaxThreads;
    m_lHiPriBound = lHiPriBound;

    BOOL bRet = TRUE;

    while(DoesNeedNewThread(NULL) && bRet)
	{
        bRet = CreateNewThread();
	}

    return bRet;
}

BOOL CCoreQueue::IsAppropriateThread()
{
    // Get the queue that is registered for this thread, if any
    // ========================================================

    CThreadRecord* pRecord = (CThreadRecord*)TlsGetValue(mstatic_dwTlsIndex);

    if(pRecord == NULL)
        return FALSE;

    CCoreQueue* pQueue = pRecord->m_pQueue;
    if(pQueue != this)
        return FALSE;

    return TRUE;
}

BOOL CCoreQueue::IsSTAThread()
{
    // Get the queue that is registered for this thread, if any
    // ========================================================

    CThreadRecord* pRecord = (CThreadRecord*)TlsGetValue(mstatic_dwTlsIndex);

    if(pRecord == NULL) return FALSE;

    return pRecord->m_pQueue->IsSTA();
}

void CCoreQueue::SetRequestLimits(long lAbsoluteLimitCount,
                              long lStartSlowdownCount,
                              long lOneSecondDelayCount)
{
    CCritSecWrapper cs(&m_cs);

    cs.Enter();

    m_lAbsoluteLimitCount = lAbsoluteLimitCount;

    m_lStartSlowdownCount = lStartSlowdownCount;
    if(m_lStartSlowdownCount < 0)
    {
        m_lStartSlowdownCount = m_lAbsoluteLimitCount / 2;
    }

    m_lOneSecondDelayCount = lOneSecondDelayCount;

    if(m_lOneSecondDelayCount < 0)
    {
        m_lOneSecondDelayCount =
            m_lAbsoluteLimitCount * 0.2 + m_lStartSlowdownCount * 0.8;
    }

    // Calculate coefficients
    // ======================

    m_dblBeta =
        1000 *
        ((double)m_lAbsoluteLimitCount - (double)m_lOneSecondDelayCount) /
        ((double)m_lStartSlowdownCount - (double)m_lOneSecondDelayCount);

    m_dblAlpha = m_dblBeta *
        ((double)m_lStartSlowdownCount - (double)m_lAbsoluteLimitCount);
    cs.Leave();
}


BOOL CCoreQueue::IsDependentRequest ( CCoreExecReq* pRequest )
{
    try
    {
	    BOOL bRet = FALSE;
		
		if ( pRequest )
		{
			CWbemRequest* pWbemRequest = (CWbemRequest*) pRequest ;
			if ( pWbemRequest )
			{
				if ( !pWbemRequest->IsDependee ( ) )
				{
					CWmiTask* pTask = (CWmiTask*) pRequest->m_phTask;
					if ( pTask )
					{
						CWbemNamespace* pNamespace = (CWbemNamespace*) pTask->GetNamespace ( );
						if ( pNamespace )
						{
							if ( pNamespace->GetIsProvider ( ) || pNamespace->GetIsESS ( ) )
							{
								bRet = TRUE;
							}
						}
					}
				}
				else
				{
					bRet = TRUE;
				}
			}
		}
		return bRet;

    }   // end try
    catch(...) 
    {
        ExceptionCounter c;    
        ERRORTRACE((LOG_WBEMCORE, "CCoreQueue::IsDependentRequest() exception\n"));
        return FALSE;
    }
}



VOID CCoreQueue::RecordPeakThreadCount (  )
{
	if ( ( g_lCoreThreads + m_lEmergencyThreads ) > m_lPeakThreadCount )
	{
		m_lPeakThreadCount = g_lCoreThreads + m_lEmergencyThreads ;
	}
	if ( m_lEmergencyThreads > m_lPeakEmergencyThreadCount )
	{
		m_lPeakEmergencyThreadCount = m_lEmergencyThreads;
	}
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\coresvc.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    coresvc.h

Abstract:

    CCoreServices Class

History:

--*/

#ifndef __CORE_SERVICES__H_
#define __CORE_SERVICES__H_

#include "sync.h"

enum CntType{
    WMICORE_SELFINST_USERS = 0,             // absolute
    WMICORE_SELFINST_CONNECTIONS,           // absolute
    WMICORE_SELFINST_TASKS,                 // absolute
    WMICORE_SELFINST_TASKS_EXECUTED,        // increment-only
    WMICORE_SELFINST_BACKLOG_BYTES,         // absolute
    WMICORE_SELFINST_TOTAL_API_CALLS,       // increment-only
    WMICORE_SELFINST_INTERNAL_OBJECT_COUNT, // absolute
    WMICORE_SELFINST_SINK_COUNT,            // absolute
    WMICORE_SELFINST_STD_SINK_COUNT,        // absolute
    WMICORE_LAST_ENTRY                      // Insert all new entries in front of this
};

typedef DWORD (*PFN_SetCounter)(DWORD dwCounter, DWORD dwValue);

class CPerTaskHook : public _IWmiCoreWriteHook
{
    CFlexArray *m_pHookList;
    ULONG m_uRefCount;

    CPerTaskHook();
   ~CPerTaskHook();

public:
        /* IUnknown methods */

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    HRESULT STDMETHODCALLTYPE QueryInterface(
        IN REFIID riid,
        OUT LPVOID *ppvObj
        );

        virtual HRESULT STDMETHODCALLTYPE PrePut(
            /* [in] */ long lFlags,
            /* [in] */ long lUserFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemPath __RPC_FAR *pPath,
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszClass,
            /* [in] */ _IWmiObject __RPC_FAR *pCopy
            );

        virtual HRESULT STDMETHODCALLTYPE PostPut(
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hRes,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemPath __RPC_FAR *pPath,
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszClass,
            /* [in] */ _IWmiObject __RPC_FAR *pNew,
            /* [in] */ _IWmiObject __RPC_FAR *pOld
            );

        virtual HRESULT STDMETHODCALLTYPE PreDelete(
            /* [in] */ long lFlags,
            /* [in] */ long lUserFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemPath __RPC_FAR *pPath,
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszClass
            );

        virtual HRESULT STDMETHODCALLTYPE PostDelete(
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hRes,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemPath __RPC_FAR *pPath,
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszClass,
            /* [in] */ _IWmiObject __RPC_FAR *pOld
            );

public:
        static HRESULT CreatePerTaskHook(OUT CPerTaskHook **pNew);
};


class CCoreServices : public _IWmiCoreServices
{
protected:
    friend class CPerTaskHook;

    long m_lRef;
	static _IWmiProvSS *m_pProvSS;
    static IWbemEventSubsystem_m4 *m_pEssOld;
    static _IWmiESS *m_pEssNew;
	static _IWbemFetchRefresherMgr* m_pFetchRefrMgr;
    static CCritSec m_csHookAccess;

// removed till blackcomb    static CRITICAL_SECTION m_csCounterAccess;
// removed till blackcomb    static DWORD m_dwCounters[WMICORE_LAST_ENTRY];
// removed till blackcomb    static HMODULE m_hWmiPerf;
// removed till blackcomb    static PFN_SetCounter m_pSetCounterFunction;

protected:
    bool IsProviderSubsystemEnabled();
    bool IsNtSetupRunning();

public:
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);

	// _IWmiCoreServices methods

        virtual HRESULT STDMETHODCALLTYPE GetObjFactory(
            /* [in] */ long lFlags,
            /* [out] */ _IWmiObjectFactory __RPC_FAR *__RPC_FAR *pFact);

        virtual HRESULT STDMETHODCALLTYPE GetServices(
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszUser,
            /* [in] */ LPCWSTR pszLocale,
            /* [in] */ long lFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pServices);

        virtual HRESULT STDMETHODCALLTYPE GetRepositoryDriver(
            /* [in] */ long lFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pDriver);

        virtual HRESULT STDMETHODCALLTYPE GetCallSec(
            /* [in] */ long lFlags,
            /* [out] */ _IWmiCallSec __RPC_FAR *__RPC_FAR *pCallSec);

        virtual HRESULT STDMETHODCALLTYPE GetProviderSubsystem(
            /* [in] */ long lFlags,
            /* [out] */ _IWmiProvSS __RPC_FAR *__RPC_FAR *pProvSS);

        virtual HRESULT STDMETHODCALLTYPE StopEventDelivery( void);

        virtual HRESULT STDMETHODCALLTYPE StartEventDelivery( void);

        virtual HRESULT STDMETHODCALLTYPE DeliverIntrinsicEvent(
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ ULONG uType,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ LPCWSTR pszClass,
            /* [in] */ LPCWSTR pszTransGuid,
            /* [in] */ ULONG uObjectCount,
            /* [in] */ _IWmiObject __RPC_FAR *__RPC_FAR *ppObjList);

        virtual HRESULT STDMETHODCALLTYPE DeliverExtrinsicEvent(
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ ULONG uFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ _IWmiObject __RPC_FAR *pEvt);

        virtual HRESULT STDMETHODCALLTYPE GetSystemObjects(
            /* [in] */ ULONG lFlags,
            /* [out] */ ULONG __RPC_FAR *puArraySize,
            /* [out] */ _IWmiObject __RPC_FAR *__RPC_FAR *pObjects);

        virtual HRESULT STDMETHODCALLTYPE GetSystemClass(
            /* [in] */ LPCWSTR pszClassName,
            /* [out] */ _IWmiObject __RPC_FAR *__RPC_FAR *pClassDef);

        virtual HRESULT STDMETHODCALLTYPE GetConfigObject(
            ULONG uID,
            /* [out] */ _IWmiObject __RPC_FAR *__RPC_FAR *pCfgObject);

        virtual HRESULT STDMETHODCALLTYPE RegisterWriteHook(
            /* [in] */ ULONG uFlags,
            /* [in] */ _IWmiCoreWriteHook __RPC_FAR *pHook);

        virtual HRESULT STDMETHODCALLTYPE UnregisterWriteHook(
            /* [in] */ _IWmiCoreWriteHook __RPC_FAR *pHook);

        virtual HRESULT STDMETHODCALLTYPE CreateCache(
            /* [in] */ ULONG uFlags,
            /* [out] */ _IWmiCache __RPC_FAR *__RPC_FAR *pCache);

        virtual HRESULT STDMETHODCALLTYPE CreateFinalizer(
            /* [in] */ ULONG uFlags,
            /* [out] */ _IWmiFinalizer __RPC_FAR *__RPC_FAR *pFinalizer);

        virtual HRESULT STDMETHODCALLTYPE CreatePathParser(
            /* [in] */ ULONG uFlags,
            /* [out] */ IWbemPath __RPC_FAR *__RPC_FAR *pParser);

        virtual HRESULT STDMETHODCALLTYPE CreateQueryParser(
            /* [in] */ ULONG uFlags,
            /* [out] */ _IWmiQuery __RPC_FAR *__RPC_FAR *pQuery);

        virtual HRESULT STDMETHODCALLTYPE GetDecorator(
            /* [in] */ ULONG uFlags,
            /* [out] */ IWbemDecorator __RPC_FAR *__RPC_FAR *pDec);


        virtual HRESULT STDMETHODCALLTYPE IncrementCounter(
            /* [in] */ ULONG uID,
            /* [in] */ ULONG uParam);

        virtual HRESULT STDMETHODCALLTYPE DecrementCounter(
            /* [in] */ ULONG uID,
            /* [in] */ ULONG uParam);

        virtual HRESULT STDMETHODCALLTYPE SetCounter(
            /* [in] */ ULONG uID,
            /* [in] */ ULONG uParam);

        virtual HRESULT STDMETHODCALLTYPE GetSelfInstInstances(
            /* [in] */ LPCWSTR pszClass,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink);

        virtual HRESULT STDMETHODCALLTYPE GetServices2(
            /* [in] */ LPCWSTR pszPath,
            /* [in] */ LPCWSTR pszUser,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ ULONG uClientFlags,
            /* [in] */ DWORD dwSecFlags,
            /* [in] */ DWORD dwPermissions,
            /* [in] */ ULONG uInternalFlags,
            /* [in] */ LPCWSTR pszClientMachine,
            /* [in] */ DWORD dwClientProcessID,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pServices);

        virtual HRESULT STDMETHODCALLTYPE GetConnector(
            /* [in] */ ULONG uFlags,
            /* [out] */ IWbemConnection __RPC_FAR *__RPC_FAR *pConnect);

        virtual HRESULT STDMETHODCALLTYPE NewPerTaskHook(
            /* [out] */ _IWmiCoreWriteHook __RPC_FAR *__RPC_FAR *pHook);

        virtual HRESULT STDMETHODCALLTYPE GetArbitrator(
            /* [out] */ _IWmiArbitrator __RPC_FAR *__RPC_FAR *pArb);


        virtual HRESULT STDMETHODCALLTYPE InitRefresherMgr(
			/* [in] */	long lFlags );

    CCoreServices();
    ~CCoreServices();
    static HRESULT InternalSetCounter(DWORD dwCounter, DWORD dwValue);

    static HRESULT DumpCounters(FILE *);

public:
    static CCoreServices *g_pSvc;

    static CCoreServices *CreateInstance() { CCoreServices * p = new CCoreServices;
                                             if (p) p->AddRef();
                                             return  p; }
	static HRESULT Initialize () ;
	static HRESULT UnInitialize () ;

    static HRESULT SetEssPointers(
        IWbemEventSubsystem_m4 *pEssOld,
        _IWmiESS               *pEssNew);
};


#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\coresvc.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    coresvc.cpp

Abstract:

    CCoreServices Class

History:

    raymcc      1-Mar-00        Created

--*/

#include "precomp.h"
#include "wbemcore.h"

#include "wmifinalizer.h"
#include "wmiarbitrator.h"

#pragma warning(disable:4355)

_IWmiProvSS *CCoreServices::m_pProvSS = 0;
_IWbemFetchRefresherMgr* CCoreServices::m_pFetchRefrMgr = NULL;
CCoreServices* CCoreServices::g_pSvc = 0;
IWbemEventSubsystem_m4 *CCoreServices::m_pEssOld = 0;
_IWmiESS               *CCoreServices::m_pEssNew = 0;

// removed till blackcomb HMODULE CCoreServices::m_hWmiPerf = 0;
// removed till blackcomb PFN_SetCounter CCoreServices::m_pSetCounterFunction = 0;
// removed till blackcomb DWORD CCoreServices::m_dwCounters[WMICORE_LAST_ENTRY] = {0,0,0,0,0,0,0,0};
CCritSec CCoreServices::m_csHookAccess;
// removed till blackcomb CRITICAL_SECTION CCoreServices::m_csCounterAccess;

static BOOL g_bEventsEnabled = FALSE;
static CFlexArray g_aHooks;

LONG g_nSinkCount = 0;
LONG g_nStdSinkCount = 0;
LONG g_nSynchronousSinkCount = 0;
LONG g_nProviderSinkCount = 0;
LONG g_nNamespaceCount = 0;
LONG g_lCoreThreads = 0;

//***************************************************************************
//
//***************************************************************************

struct SHookElement
{
    _IWmiCoreWriteHook *m_pHook;
    ULONG               m_uFlags;
    HRESULT             m_hResPre; // The PreXXX return code may prevent the PostXXX code to be called

    SHookElement();
   ~SHookElement();
    SHookElement(SHookElement &Src);
    SHookElement& operator =(SHookElement &Src);
};



//***************************************************************************
//
//***************************************************************************

HRESULT CCoreServices::Initialize ()
{
    m_pEssOld = 0;
    m_pEssNew = 0;

// removed till blackcomb    InitializeCriticalSection(&m_csCounterAccess);

    g_pSvc = CCoreServices::CreateInstance();

    HRESULT hr = CoCreateInstance( CLSID__WbemFetchRefresherMgr, NULL, CLSCTX_INPROC_SERVER,
                                    IID__IWbemFetchRefresherMgr, (void**) &m_pFetchRefrMgr );

    return hr;
}

//***************************************************************************
//
//***************************************************************************
HRESULT CCoreServices::SetEssPointers(
    IWbemEventSubsystem_m4 *pEssOld,
    _IWmiESS               *pEssNew
    )
{
    m_pEssOld = pEssOld;
    m_pEssOld->AddRef();
    m_pEssNew = pEssNew;
    m_pEssNew->AddRef();
    return 0;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CCoreServices::UnInitialize ()
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    if (m_pProvSS)
    {
        m_pProvSS->Release () ;
        m_pProvSS = NULL ;
    }

    // Cleanup the refresher manager fetcher
    if ( NULL != m_pFetchRefrMgr )
    {
        // We should uninitialize as well - commented out for now
        // m_pFetchRefrMgr->Uninit();
        m_pFetchRefrMgr->Release ();
        m_pFetchRefrMgr = NULL;
    }

    // Free up the perflib

    /* removed till Blackcomb
    EnterCriticalSection(&m_csCounterAccess);
    if(m_hWmiPerf)
    {
        // zero out the counters

        DWORD dwCnt;
        for(dwCnt = 0; dwCnt < WMICORE_LAST_ENTRY; dwCnt++)
            InternalSetCounter(dwCnt, 0);

        FreeLibrary(m_hWmiPerf);
        m_hWmiPerf = NULL;
        m_pSetCounterFunction = NULL;
    }
    LeaveCriticalSection(&m_csCounterAccess);
    DeleteCriticalSection(&m_csCounterAccess);
    */

    ReleaseIfNotNULL(m_pEssOld);
    ReleaseIfNotNULL(m_pEssNew);

    ReleaseIfNotNULL(g_pSvc);

    return hRes;
}

//***************************************************************************
//
//***************************************************************************

CCoreServices::CCoreServices() : m_lRef(0)
{
}

//***************************************************************************
//
//***************************************************************************

CCoreServices::~CCoreServices()
{
}

ULONG CCoreServices::AddRef()
{
    InterlockedIncrement(&m_lRef);
    return ULONG(m_lRef);
}

//***************************************************************************
//
//***************************************************************************

ULONG CCoreServices::Release()
{
    ULONG uNewCount = (ULONG) InterlockedDecrement(&m_lRef);
    if (0 != uNewCount)
        return uNewCount;
    delete this;
    return 0;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID__IWmiCoreServices)
    {
        AddRef();
        *ppv = (void*)this;
        return S_OK;
    }
    else return E_NOINTERFACE;
}


//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::GetObjFactory(
            /* [in] */ long lFlags,
            /* [out] */ _IWmiObjectFactory __RPC_FAR *__RPC_FAR *pFact)
{
    return WBEM_E_NOT_AVAILABLE;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::GetServices(
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszUser,
            /* [in] */ LPCWSTR pszLocale,
            /* [in] */ long lFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pServices)
{
    BOOL bRepositOnly = false;
    HRESULT hRes;

    if (lFlags & WMICORE_FLAG_REPOSITORY)
        bRepositOnly = true;

    CWbemNamespace *pNs = CWbemNamespace::CreateInstance();
    if (!pNs)
        return WBEM_E_OUT_OF_MEMORY;

	LPWSTR wszTempLocale = ( LPWSTR ) pszLocale ;
	if ( wszTempLocale == NULL )
	{
		wszTempLocale = GetDefaultLocale();
		if(wszTempLocale == NULL)
		{
			pNs->Release();
			return WBEM_E_OUT_OF_MEMORY;
		}
	}

    CVectorDeleteMe<WCHAR> vdm(pszLocale ? NULL : wszTempLocale );

    hRes = pNs->Initialize(
        LPWSTR(pszNamespace),
        pszUser ? ( LPWSTR ) pszUser : ADMINISTRATIVE_USER,
        0,
        FULL_RIGHTS,
        FALSE,
        bRepositOnly,
        NULL,
        0XFFFFFFFF,
        FALSE,
        NULL
        );


    if (SUCCEEDED(hRes))
    {
        pNs->SetLocale (wszTempLocale);
        if ( lFlags & WMICORE_CLIENT_TYPE_PROVIDER )
        {
            pNs->SetIsProvider(TRUE) ;
        }
        if ( lFlags & WMICORE_CLIENT_TYPE_ESS )
        {
            pNs->SetIsESS ( TRUE );
        }

        *pServices = pNs;

    } else {

        pNs->Release();

    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::GetRepositoryDriver(
            /* [in] */ long lFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pDriver)
{
    return WBEM_E_NOT_AVAILABLE;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::GetCallSec(
            /* [in] */ long lFlags,
            /* [out] */ _IWmiCallSec __RPC_FAR *__RPC_FAR *pCallSec)
{
    HRESULT t_Result = CoCreateInstance (

        CLSID__IWbemCallSec ,
        NULL ,
        CLSCTX_INPROC_SERVER ,
        IID__IWmiCallSec ,
        ( void ** ) pCallSec
    ) ;

    return t_Result ;
}

//***************************************************************************
//
//***************************************************************************
bool CCoreServices::IsProviderSubsystemEnabled()
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ, &hKey);
    if(lRes)
        return false;

    DWORD dwEnableProviderSubSystemFlag;
    DWORD dwLen = sizeof(DWORD);
    lRes = RegQueryValueExW(hKey, L"Enable Provider Subsystem", NULL, NULL,
                (LPBYTE)&dwEnableProviderSubSystemFlag, &dwLen);
    RegCloseKey(hKey);

    if(lRes == ERROR_SUCCESS && (dwEnableProviderSubSystemFlag == 0))
    {
        return false;
    }
    return true;
}

//***************************************************************************
//
//***************************************************************************
bool CCoreServices::IsNtSetupRunning()
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                    L"system\\Setup",
                    0, KEY_READ, &hKey);
    if(lRes)
        return false;

    DWORD dwSetupRunning;
    DWORD dwLen = sizeof(DWORD);
    lRes = RegQueryValueExW(hKey, L"SystemSetupInProgress", NULL, NULL,
                (LPBYTE)&dwSetupRunning, &dwLen);
    RegCloseKey(hKey);

    if(lRes == ERROR_SUCCESS && (dwSetupRunning == 1))
    {
        return true;
    }
    return false;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::GetProviderSubsystem(
            /* [in] */ long lFlags,
            /* [out] */ _IWmiProvSS __RPC_FAR *__RPC_FAR *pProvSS)
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    if (m_pProvSS == NULL)
    {
        if(!IsProviderSubsystemEnabled() || IsNtSetupRunning())
        {
            //Provider subsystem is currently disabled because of it's registry key, or
            //because NT Setup is currently running.
            *pProvSS = NULL;
            return S_FALSE;
        }

        hRes = CoCreateInstance(
            CLSID_WmiProvSS,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID__IWmiProvSS,
            (LPVOID *) &m_pProvSS
            );

        if (SUCCEEDED(hRes))
        {
		    CCoreServices *pSvc = CCoreServices::CreateInstance();
		    CReleaseMe _(pSvc);
        
            IWbemContext *pCtx = 0;

            hRes = m_pProvSS->Initialize(
                lFlags,
                pCtx,
                pSvc
                );

            if (FAILED(hRes))
            {
                m_pProvSS->Release() ;
                m_pProvSS = NULL ;
                hRes = WBEM_E_INITIALIZATION_FAILURE ;
            }
        else
        {
           m_pProvSS->AddRef();
                   *pProvSS = m_pProvSS;
        }
        }
        else // FAILED to CoCreate
            hRes = WBEM_E_INITIALIZATION_FAILURE;
    }
    else // Already created
    {
        m_pProvSS->AddRef();
        *pProvSS = m_pProvSS;
        hRes = WBEM_S_NO_ERROR;
    }

    return hRes;
}



//***************************************************************************
//
//***************************************************************************

HRESULT CCoreServices::DeliverIntrinsicEvent(
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ ULONG uType,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ LPCWSTR pszParam,
            /* [in] */ LPCWSTR pszTransGuid,
            /* [in] */ ULONG uObjectCount,
            /* [in] */ _IWmiObject __RPC_FAR *__RPC_FAR *ppObjList
            )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    if (g_bEventsEnabled == FALSE)
        return hRes;

    if (m_pEssOld)
    {
        hRes = m_pEssOld->ProcessInternalEvent(
            uType,
            LPWSTR(pszNamespace),
            LPWSTR(pszParam),
            LPWSTR(pszTransGuid),
            0,
            0,
            uObjectCount,
            ppObjList,
            pCtx
            );
    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CCoreServices::DeliverExtrinsicEvent(
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ ULONG uFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ _IWmiObject __RPC_FAR *pEvt
            )
{
    return E_NOTIMPL;
}


//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::StopEventDelivery( void)
{
    g_bEventsEnabled = FALSE;
    return 0;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::StartEventDelivery( void)
{
    g_bEventsEnabled = TRUE;
    return 0;
}



//***************************************************************************
//
//***************************************************************************

HRESULT CCoreServices::IncrementCounter(
            /* [in] */ ULONG uID,
            /* [in] */ ULONG uParam
            )
{
    if (uID == WMICORE_SELFINST_SINK_COUNT)
    {
        InterlockedIncrement(&g_nSinkCount);
    }
    else if (uID == WMICORE_SELFINST_STD_SINK_COUNT)
    {
        InterlockedIncrement(&g_nStdSinkCount);
    }
    else if ( uID == WMICORE_SELFINST_CONNECTIONS )
    {
        InterlockedIncrement(&g_nNamespaceCount);
    }

    /* removed till blackcomb
    CInCritSec cs(&m_csCounterAccess);
    DWORD dwShort = (DWORD) uParam;
    m_dwCounters[uID] += dwShort;
    return InternalSetCounter(uID, m_dwCounters[uID]);
    */
    return S_OK;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CCoreServices::DecrementCounter(
            /* [in] */ ULONG uID,
            /* [in] */ ULONG uParam
            )
{
    /* removed till blackcomb
    CInCritSec cs(&m_csCounterAccess);
    DWORD dwShort = (DWORD) uParam;
    m_dwCounters[uID] -= dwShort;
    return InternalSetCounter(uID, m_dwCounters[uID]);
    */

    if (uID == WMICORE_SELFINST_SINK_COUNT)
    {
        InterlockedDecrement(&g_nSinkCount);
    }
    else if (uID == WMICORE_SELFINST_STD_SINK_COUNT)
    {
        InterlockedDecrement(&g_nStdSinkCount);
    }
    else if ( uID == WMICORE_SELFINST_CONNECTIONS )
    {
        InterlockedDecrement(&g_nNamespaceCount);
    }

    return S_OK;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CCoreServices::SetCounter(
            /* [in] */ ULONG uID,
            /* [in] */ ULONG uParam
            )
{
    /* removed till blackcomb
    CInCritSec cs(&m_csCounterAccess);
    DWORD dwShort = (DWORD) uParam;
    m_dwCounters[uID] = dwShort;
    return InternalSetCounter(uID, m_dwCounters[uID]);
    */
    return S_OK;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CCoreServices::GetSelfInstInstances(
            /* [in] */ LPCWSTR pszClass,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink
            )
{
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

typedef _IWmiObject * PWMIOBJ;

STDMETHODIMP CCoreServices::GetSystemObjects(
            /* [in] */ ULONG lFlags,
            /* [out] */ ULONG __RPC_FAR *puArraySize,
            /* [out] */ _IWmiObject __RPC_FAR *__RPC_FAR *pObjects)
{
    CFlexArray Results;
    HRESULT hr;
    if(puArraySize == NULL)
        return WBEM_E_INVALID_PARAMETER;
    try
    {
        switch(lFlags)
        {
        case GET_SYSTEM_STD_OBJECTS:
            hr = GetSystemStdObjects(&Results);
            break;
        case GET_SYSTEM_SECURITY_OBJECTS:
            hr = GetSystemSecurityObjects(&Results);
            break;
        case GET_SYSTEM_ROOT_OBJECTS:
            hr = GetSystemRootObjects(&Results);
            break;
        case GET_SYSTEM_STD_INSTANCES:
            hr = GetStandardInstances(&Results);
            break;
        default:
            return WBEM_E_INVALID_PARAMETER;
        }
    }
    catch(...)
    {
        ExceptionCounter c;    
        //  The class init stuff uses exceptions to handle out of memory conditions.
        hr = WBEM_E_OUT_OF_MEMORY;
    }


    // See if the buffer is large enough

    if(SUCCEEDED(hr))
    {
        DWORD dwBuff = *puArraySize;
        *puArraySize = Results.Size();
        if(dwBuff < Results.Size() || pObjects == NULL)
            hr = WBEM_E_BUFFER_TOO_SMALL;
    }

    // If failure in lower level, free up any elements in the flex array

    if(FAILED(hr))
    {
        for(DWORD dwCnt = 0; dwCnt < Results.Size(); dwCnt++)
        {
            PWMIOBJ pObj = (PWMIOBJ)Results.GetAt(dwCnt);
            if(pObj)
                delete pObj;
        }
        return hr;
    }

    // for success, transfer the results from the flex array to the return array.

    for(DWORD dwCnt = 0; dwCnt < Results.Size(); dwCnt++)
    {
        pObjects[dwCnt] = (PWMIOBJ)Results.GetAt(dwCnt);
    }
    return hr;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::GetSystemClass(
            /* [in] */ LPCWSTR pszClassName,
            /* [out] */ _IWmiObject __RPC_FAR *__RPC_FAR *pClassDef)
{
    return WBEM_E_NOT_AVAILABLE;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::GetConfigObject(
            ULONG uID,
            /* [out] */ _IWmiObject __RPC_FAR *__RPC_FAR *pCfgObject)
{
    return WBEM_E_NOT_AVAILABLE;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::RegisterWriteHook(
            /* [in] */ ULONG uFlags,
            /* [in] */ _IWmiCoreWriteHook __RPC_FAR *pHook
            )
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    if (pHook == 0)
        return WBEM_E_INVALID_PARAMETER;

    SHookElement *pHookEl = new SHookElement;
    if (!pHookEl)
        return WBEM_E_OUT_OF_MEMORY;

    pHookEl->m_pHook = pHook;
    pHookEl->m_pHook->AddRef();
    pHookEl->m_uFlags = uFlags;

    EnterCriticalSection(&m_csHookAccess);

    int nRes = g_aHooks.Add(pHookEl);

    if (nRes)
    {
        delete pHookEl;
        hRes = WBEM_E_FAILED;
    }

    LeaveCriticalSection(&m_csHookAccess);

    return hRes;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::UnregisterWriteHook(
      _IWmiCoreWriteHook __RPC_FAR *pTargetHook
      )
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    if (pTargetHook == 0)
        return WBEM_E_INVALID_PARAMETER;

    BOOL bFound = FALSE;
    EnterCriticalSection(&m_csHookAccess);
    for (int i = 0; i < g_aHooks.Size(); i++)
    {
        SHookElement *pEl = (SHookElement *) g_aHooks.GetAt(i);
        if (pEl == 0)
            continue;

        _IWmiCoreWriteHook *pHook = pEl->m_pHook;
        if (pHook == pTargetHook)
        {
            g_aHooks.RemoveAt(i);
            delete pEl;
            hRes = WBEM_S_NO_ERROR;
            bFound = TRUE;
            break;
        }
    }

    if (!bFound)
        hRes = WBEM_E_NOT_FOUND;

    LeaveCriticalSection(&m_csHookAccess);

    return hRes;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::CreateCache(
            /* [in] */ ULONG uFlags,
            /* [out] */  _IWmiCache __RPC_FAR *__RPC_FAR *pCache
            )
{
    return WBEM_E_NOT_AVAILABLE;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::CreateFinalizer(
            /* [in] */ ULONG uFlags,
            /* [out] */  _IWmiFinalizer __RPC_FAR *__RPC_FAR *ppFnz
            )
{
    CWmiFinalizer *pFnz;
    try
    {
        pFnz = new CWmiFinalizer(this);
        if (!pFnz)
            return WBEM_E_OUT_OF_MEMORY;
    }
    catch (FNLZR_Exception &)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
    catch (...) // STATUS_NO_MEMORY from CritSec
    {
        ExceptionCounter c;    
        return WBEM_E_CRITICAL_ERROR;
    }
    
    pFnz->AddRef();
    *ppFnz = pFnz;

    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CCoreServices::CreatePathParser(
                ULONG uFlags,
                IWbemPath **pParser
                )
{
    HRESULT hRes = CoCreateInstance(CLSID_WbemDefPath, 0, CLSCTX_INPROC_SERVER,
                        IID_IWbemPath, (LPVOID *) pParser
                        );
    if (FAILED(hRes))
        return hRes;

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CCoreServices::CreateQueryParser(
                ULONG uFlags,
                _IWmiQuery **pResultQueryObj
                )
{
    _IWmiQuery *pQuery = 0;

    HRESULT hRes = CoCreateInstance(CLSID_WbemQuery, 0, CLSCTX_INPROC_SERVER,
                IID__IWmiQuery, (LPVOID *) &pQuery);

    if (FAILED(hRes))
        return hRes;

    *pResultQueryObj = pQuery;

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
HRESULT CCoreServices::GetDecorator(
                ULONG uFlags,
                IWbemDecorator **pDest
                )
{
    CDecorator *pDec = new CDecorator;
    if (!pDec)
        return WBEM_E_OUT_OF_MEMORY;
    pDec->AddRef();
    *pDest = pDec;
    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CCoreServices::GetServices2(
            /* [in] */ LPCWSTR pszPath,
            /* [in] */ LPCWSTR pszUser,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ ULONG uClientFlags,
            /* [in] */ DWORD dwSecFlags,
            /* [in] */ DWORD dwPermissions,
            /* [in] */ ULONG uInternalFlags,
            /* [in] */ LPCWSTR pszClientMachine,
            /* [in] */ DWORD dwClientProcessID,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pServices
            )
{
    HRESULT hRes = CWbemNamespace::PathBasedConnect(
            pszPath,
            pszUser,
            pCtx,
            uClientFlags,
            dwSecFlags,
            dwPermissions,
            uInternalFlags,
            pszClientMachine,
            dwClientProcessID,
            riid,
            pServices
            );

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CCoreServices::GetConnector(
            /* [in] */ ULONG uFlags,
            /* [out] */ IWbemConnection __RPC_FAR *__RPC_FAR *pConnect
            )
{
    HRESULT hr;

    // Must return a connector based on a CoImpersonateClient call.

    if(pConnect == NULL)
        return WBEM_E_INVALID_PARAMETER;
    *pConnect = NULL;

    if(uFlags == WBEM_CONN_TYPE_ADMINISTRATIVE)  // connects as admin, doesnt add to client count
        hr = CoCreateInstance(
            CLSID_ActualWbemAdministrativeLocator,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IWbemConnection,
            (LPVOID *) pConnect
            );
    else if (uFlags == WBEM_CONN_TYPE_UNAUTHENTICATED)  // checks for permission using thread token
        hr = CoCreateInstance(
            CLSID_ActualWbemUnauthenticatedLocator,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IWbemConnection,
            (LPVOID *) pConnect
            );
    else
        return WBEM_E_INVALID_PARAMETER;

    return hr;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CCoreServices::NewPerTaskHook(
            /* [out] */ _IWmiCoreWriteHook __RPC_FAR *__RPC_FAR *pHook
            )
{
    CPerTaskHook *pNewHook = 0;
    HRESULT hRes = CPerTaskHook::CreatePerTaskHook(&pNewHook);
    if (FAILED(hRes))
        return hRes;

    *pHook = (_IWmiCoreWriteHook *) pNewHook;
    return hRes;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CCoreServices::GetArbitrator(
            /* [out] */ _IWmiArbitrator **pReturnedArb
            )
{
    return E_NOTIMPL;
}

HRESULT CCoreServices::DumpCounters(FILE *f)
{
    if (!f)
        return E_FAIL;

    fprintf(f, "Total sinks active     = %d\n", g_nSinkCount);
    fprintf(f, "Total std sink objects = %d\n", g_nStdSinkCount);

    return 0;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::InitRefresherMgr(
            /* [in] */ long lFlags )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Get a refresher manager from the provider subsystem.  We initialize this once,
    // then retrieve from the fetcher.  If this succeeds, initialize the refreshing
    // services pointer with this guy so we can pawn off all the refresher
    // hi-perf provider fixup stuff.

    _IWmiProvSS *pProvSS = 0;
    GetProviderSubsystem(0, &pProvSS);
    CReleaseMe _2(pProvSS);

    // We'll need a Services pointer to create the manager
    IWbemServices*  pService = NULL;
    hr = GetServices( L"root", NULL,NULL,WMICORE_FLAG_REPOSITORY, IID_IWbemServices, (void**) &pService );
    CReleaseMe  rm1(pService);

    if ( NULL != m_pFetchRefrMgr )
    {
        hr = m_pFetchRefrMgr->Init( pProvSS, pService );
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CCoreServices::InternalSetCounter(
            DWORD dwCounter, DWORD dwValue)
{
/*  removed till blackcomb
    if(m_hWmiPerf == NULL)
    {
        m_hWmiPerf = LoadLibrary("WMIPERF.DLL");
        if(m_hWmiPerf)
            m_pSetCounterFunction = (PFN_SetCounter) GetProcAddress(m_hWmiPerf, "WriteCounter");
    }
    try
    {
    if(m_pSetCounterFunction)
        m_pSetCounterFunction(dwCounter, dwValue);
    }
    catch(...)
    {
    }
    */
    return S_OK;


}
//***************************************************************************
//
//***************************************************************************

ULONG CPerTaskHook::AddRef()
{
    InterlockedIncrement((LONG *) &m_uRefCount);
    return m_uRefCount;
}

//***************************************************************************
//
//***************************************************************************

ULONG CPerTaskHook::Release()
{
    ULONG uNewCount = InterlockedDecrement((LONG *) &m_uRefCount);
    if (0 != uNewCount)
        return uNewCount;
    delete this;
    return 0;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CPerTaskHook::QueryInterface(
    IN REFIID riid,
    OUT LPVOID *ppvObj
    )
{
    if (IID_IUnknown==riid || IID__IWmiCoreWriteHook==riid)
    {
        *ppvObj = this;
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}



//***************************************************************************
//
//***************************************************************************

CPerTaskHook::CPerTaskHook()
{
    m_pHookList = 0;
    m_uRefCount = 0;
}

//***************************************************************************
//
//***************************************************************************

CPerTaskHook::~CPerTaskHook()
{
    if (m_pHookList == 0)
        return;

    for (int i = 0; i < m_pHookList->Size(); i++)
    {
        SHookElement *pHE = (SHookElement *) m_pHookList->GetAt(i);
        delete pHE;
    }

    delete m_pHookList;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CPerTaskHook::CreatePerTaskHook(
    OUT CPerTaskHook **pDestNew
    )
{
    int nRes;

    *pDestNew = 0;

    CPerTaskHook *pNew = new CPerTaskHook;
    if (!pNew)
        return WBEM_E_OUT_OF_MEMORY;
    pNew->m_pHookList = new CFlexArray;
    if (NULL == pNew->m_pHookList)
    {
        return WBEM_E_OUT_OF_MEMORY;    
    }

    {
        CInCritSec ics(&CCoreServices::m_csHookAccess);

	    for (int i = 0; i < g_aHooks.Size(); i++)
	    {
	        SHookElement *pEl = (SHookElement *) g_aHooks.GetAt(i);
	        if (pEl == 0)
	            continue;
	        SHookElement *pNewEl = new SHookElement;

	        if (NULL == pNewEl)
	            return WBEM_E_OUT_OF_MEMORY;

	        *pNewEl = *pEl;
	        nRes = pNew->m_pHookList->Add(pNewEl);

	        if (nRes)
	        {            
	            delete pNew;
	            return WBEM_E_OUT_OF_MEMORY;
	        }
	    }
    
    }

    if (pNew->m_pHookList->Size() != 0)
    {
        pNew->AddRef();                 // counteract CReleaseMe
        *pDestNew = pNew;
    }
    else
    {
        *pDestNew = 0;                  // No sense in returning an empty list
        delete pNew;
    }

    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CPerTaskHook::PrePut(
            /* [in] */ long lFlags,
            /* [in] */ long lUserFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemPath __RPC_FAR *pPath,
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszClass,
            /* [in] */ _IWmiObject __RPC_FAR *pCopy
            )
{
    if (m_pHookList == 0)
        return 0;

    HRESULT hRes = 0;
    HRESULT hResBoth = 0;

    for (int i = 0; i < m_pHookList->Size(); i++)
    {
        SHookElement *pEl = (SHookElement *) m_pHookList->GetAt(i);
        if (pEl == 0)
            continue;
        _IWmiCoreWriteHook *pHook = pEl->m_pHook;

        //
        // One can register for both CLASS and INSTANCE
        // but there will be alwys ONE bit set in the lFlags
        //
        if (lFlags & pEl->m_uFlags)
        {
            hRes = pHook->PrePut(lFlags, lUserFlags, pCtx, pPath, pszNamespace, pszClass, pCopy);
            pEl->m_hResPre = hRes;
        }
        else
        {
            continue;
        }

        if (FAILED(hRes))
            return hRes;

        if (hRes == WBEM_S_POSTHOOK_WITH_BOTH)
            hResBoth = WBEM_S_POSTHOOK_WITH_BOTH;
    }

    return hResBoth;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CPerTaskHook::PostPut(
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hApiResult,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemPath __RPC_FAR *pPath,
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszClass,
            /* [in] */ _IWmiObject __RPC_FAR *pNew,
            /* [in] */ _IWmiObject __RPC_FAR *pOld
            )
{
    if (m_pHookList == 0)
        return 0;

    HRESULT hRes = 0;

    for (int i = 0; i < m_pHookList->Size(); i++)
    {
        SHookElement *pEl = (SHookElement *) m_pHookList->GetAt(i);
        if (pEl == 0)
            continue;
        if (pEl->m_hResPre == WBEM_S_NO_POSTHOOK)
            continue;
        _IWmiCoreWriteHook *pHook = pEl->m_pHook;

        //
        // One can register for both CLASS and INSTANCE
        // but there will be alwys ONE bit set in the lFlags
        //
        if (lFlags & pEl->m_uFlags)
        {
            hRes |= pHook->PostPut(lFlags, hApiResult, pCtx, pPath, pszNamespace, pszClass, pNew, pOld);
            pEl->m_hResPre = 0;
        }
        else
        {
            continue;
        }
    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CPerTaskHook::PreDelete(
            /* [in] */ long lFlags,
            /* [in] */ long lUserFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemPath __RPC_FAR *pPath,
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszClass
            )
{
    if (m_pHookList == 0)
        return 0;

    HRESULT hRes = 0, hResWithOld = 0;

    for (int i = 0; i < m_pHookList->Size(); i++)
    {
        SHookElement *pEl = (SHookElement *) m_pHookList->GetAt(i);
        if (pEl == 0)
            continue;
        _IWmiCoreWriteHook *pHook = pEl->m_pHook;

        if (lFlags & pEl->m_uFlags)
        {
            hRes = pHook->PreDelete(lFlags, lUserFlags, pCtx, pPath, pszNamespace, pszClass);
            pEl->m_hResPre = ULONG(hRes);
        }
        else
        {
            continue;
        }


        if (FAILED(hRes))
            return hRes;

        if (hRes == WBEM_S_POSTHOOK_WITH_OLD)
            hResWithOld = WBEM_S_POSTHOOK_WITH_OLD;
    }

    return hResWithOld;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CPerTaskHook::PostDelete(
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hApiResult,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemPath __RPC_FAR *pPath,
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszClass,
            /* [in] */ _IWmiObject __RPC_FAR *pOld
            )
{
    if (m_pHookList == 0)
        return 0;

    HRESULT hRes = 0;

    for (int i = 0; i < m_pHookList->Size(); i++)
    {
        SHookElement *pEl = (SHookElement *) m_pHookList->GetAt(i);
        if (pEl == 0)
            continue;
        if (pEl->m_hResPre == WBEM_S_NO_POSTHOOK)
            continue;

        if (lFlags & pEl->m_uFlags)
        {
            _IWmiCoreWriteHook *pHook = pEl->m_pHook;
            hRes |= pHook->PostDelete(lFlags, hApiResult, pCtx, pPath, pszNamespace, pszClass, pOld);
            pEl->m_hResPre = 0;
        }
        else
        {
            continue;
        }
    }

    return hRes;
}



//******************
//  Test hook
//******************



class CTestHook : public _IWmiCoreWriteHook
{
    ULONG m_uRefCount;
public:
        /* IUnknown methods */

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    HRESULT STDMETHODCALLTYPE QueryInterface(
        IN REFIID riid,
        OUT LPVOID *ppvObj
        );
        virtual HRESULT STDMETHODCALLTYPE PrePut(
            /* [in] */ long lFlags,
            /* [in] */ long lUserFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemPath __RPC_FAR *pPath,
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszClass,
            /* [in] */ _IWmiObject __RPC_FAR *pCopy
            );
        virtual HRESULT STDMETHODCALLTYPE PostPut(
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hRes,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemPath __RPC_FAR *pPath,
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszClass,
            /* [in] */ _IWmiObject __RPC_FAR *pNew,
            /* [in] */ _IWmiObject __RPC_FAR *pOld
            );
        virtual HRESULT STDMETHODCALLTYPE PreDelete(
            /* [in] */ long lFlags,
            /* [in] */ long lUserFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemPath __RPC_FAR *pPath,
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszClass
            );
        virtual HRESULT STDMETHODCALLTYPE PostDelete(
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hRes,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemPath __RPC_FAR *pPath,
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszClass,
            /* [in] */ _IWmiObject __RPC_FAR *pOld
            );

    CTestHook();
   ~CTestHook();
};



//***************************************************************************
//
//***************************************************************************

ULONG CTestHook::AddRef()
{
    InterlockedIncrement((LONG *) &m_uRefCount);
    return m_uRefCount;
}

//***************************************************************************
//
//***************************************************************************

ULONG CTestHook::Release()
{
    ULONG uNewCount = InterlockedDecrement((LONG *) &m_uRefCount);
    if (0 != uNewCount)
        return uNewCount;
    delete this;
    return 0;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CTestHook::QueryInterface(
    IN REFIID riid,
    OUT LPVOID *ppvObj
    )
{
    if (IID_IUnknown==riid || IID__IWmiCoreWriteHook==riid)
    {
        *ppvObj = this;
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}



//***************************************************************************
//
//***************************************************************************

CTestHook::CTestHook()
{
    m_uRefCount = 1;
}

//***************************************************************************
//
//***************************************************************************

CTestHook::~CTestHook()
{
}

//***************************************************************************
//
//***************************************************************************

HRESULT CTestHook::PrePut(
            /* [in] */ long lFlags,
            /* [in] */ long lUserFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemPath __RPC_FAR *pPath,
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszClass,
            /* [in] */ _IWmiObject __RPC_FAR *pCopy
            )
{
        return 0;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CTestHook::PostPut(
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hApiResult,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemPath __RPC_FAR *pPath,
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszClass,
            /* [in] */ _IWmiObject __RPC_FAR *pNew,
            /* [in] */ _IWmiObject __RPC_FAR *pOld
            )
{
        return 0;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CTestHook::PreDelete(
            /* [in] */ long lFlags,
            /* [in] */ long lUserFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemPath __RPC_FAR *pPath,
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszClass
            )
{
        return 0;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CTestHook::PostDelete(
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hApiResult,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemPath __RPC_FAR *pPath,
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszClass,
            /* [in] */ _IWmiObject __RPC_FAR *pOld
            )
{
        return 0;
}


CTestHook *pNewHook = 0;

HRESULT SetTestHook()
{
    pNewHook = new CTestHook;

    _IWmiCoreServices *pSvc = CCoreServices::CreateInstance();
    CReleaseMe rm(pSvc);

    return pSvc->RegisterWriteHook(0, pNewHook);
}

HRESULT RemoveTestHook()
{
    if (pNewHook == 0)
        return 0;

    _IWmiCoreServices *pSvc = CCoreServices::CreateInstance();
    CReleaseMe rm(pSvc);

    pSvc->UnregisterWriteHook(pNewHook);

    pNewHook->Release();
    pNewHook = 0;
    return 0;
}


SHookElement::SHookElement()
{
    m_pHook = 0;
    m_uFlags = 0;
    m_hResPre = 0;
}

SHookElement::~SHookElement()
{
    ReleaseIfNotNULL(m_pHook);
}

SHookElement::SHookElement(SHookElement &Src)
{
    m_pHook = 0;
    *this = Src;
}

SHookElement & SHookElement::operator =(SHookElement &Src)
{
    m_uFlags = Src.m_uFlags;
    ReleaseIfNotNULL(m_pHook);
    m_pHook = Src.m_pHook;
    if (m_pHook)
        m_pHook->AddRef();
    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\decor.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    DECOR.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <wbemcore.h>
#include <decor.h>
#include <clicnt.h>

ULONG STDMETHODCALLTYPE CDecorator::AddRef()
{
    return InterlockedIncrement(&m_lRefCount);
}

ULONG STDMETHODCALLTYPE CDecorator::Release()
{
    long lRef = InterlockedDecrement(&m_lRefCount);
    if(lRef == 0)
        delete this;
    return lRef;
}

STDMETHODIMP CDecorator::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemDecorator)
    {
        AddRef();
        *ppv = (IWbemDecorator*)this;
        return S_OK;
    }
    else if(riid == IID_IWbemLifeControl)
    {
        AddRef();
        *ppv = (IWbemLifeControl*)this;
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP CDecorator::DecorateObject(IWbemClassObject* pObject, 
                                        WBEM_CWSTR wszNamespace)
{
    CWbemObject* pIntObj = (CWbemObject*)pObject;

    pIntObj->Decorate(ConfigMgr::GetMachineName(), wszNamespace);
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CDecorator::UndecorateObject(IWbemClassObject* pObject)
{
    CWbemObject* pIntObj = (CWbemObject*)pObject;
    pIntObj->Undecorate();
    return WBEM_S_NO_ERROR;
}
    
STDMETHODIMP CDecorator::AddRefCore()
{
    gClientCounter.LockCore(ESS);
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CDecorator::ReleaseCore()
{
    gClientCounter.UnlockCore(ESS);
    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\decor.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    DECOR.H

Abstract:

History:

--*/

#ifndef __WBEM_DECORATOR__H_
#define __WBEM_DECORATOR__H_


class CDecorator : public IWbemDecorator, public IWbemLifeControl
{
protected:
    long m_lRefCount;

public:
    CDecorator() : m_lRefCount(0){}

    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);

    STDMETHOD(DecorateObject)(IWbemClassObject* pObject, 
                                WBEM_CWSTR wszNamespace);
    STDMETHOD(UndecorateObject)(IWbemClassObject* pObject);
    STDMETHOD(AddRefCore)();
    STDMETHOD(ReleaseCore)();
};
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\crep.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//***************************************************************************
//
//  CREP.CPP
//
//  Wrappers for repository drivers
//
//  raymcc  27-Apr-00       WMI Repository init & mapping layer
//
//***************************************************************************

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include "precomp.h"
//#include <windows.h>
#include <wbemcore.h>
#include <oahelp.inl>
#include <unk.h>

// ESE only.
// =========

IWmiDbController *CRepository::m_pEseController = 0;
IWmiDbSession *CRepository::m_pEseSession = 0;
IWmiDbHandle  *CRepository::m_pEseRoot = 0;


void Test();






//***************************************************************************
//
//  CRepository::Init
//
//***************************************************************************

HRESULT CRepository::Init()
{
    HRESULT hRes;
    IWmiDbController *pController = 0;
    WMIDB_LOGON_TEMPLATE *pTemplate = 0;
    IWmiDbSession *pSession= 0;
    IWmiDbHandle *pRoot = 0;

    // Retrieve the CLSID of the default driver.
    // =========================================
    CLSID clsid;
    hRes = ConfigMgr::GetDefaultRepDriverClsId(clsid);
    if (FAILED(hRes))
        return hRes;

    hRes = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IWmiDbController, (void **)&pController);

    if (FAILED(hRes))
        return hRes;

    CReleaseMe _1(pController);

    hRes = pController->GetLogonTemplate(0x409, 0, &pTemplate);

    if (FAILED(hRes))
        return hRes;

    for (DWORD i = 0; i < pTemplate->dwArraySize; i++)
    {
         if (!_wcsicmp(pTemplate->pParm[i].strParmDisplayName, L"Server"))
         {
              pTemplate->pParm[i].Value.bstrVal = 0;
              pTemplate->pParm[i].Value.vt = VT_BSTR;
         }
         else if (!_wcsicmp(pTemplate->pParm[i].strParmDisplayName, L"Database"))
         {
              WString sDir = ConfigMgr::GetWorkingDir();
              sDir += "\\repository\\wmi.edb";

              pTemplate->pParm[i].Value.bstrVal = SysAllocString(LPWSTR(sDir));
              pTemplate->pParm[i].Value.vt = VT_BSTR;
         }
         else if (!_wcsicmp(pTemplate->pParm[i].strParmDisplayName, L"UserID"))
         {
              pTemplate->pParm[i].Value.bstrVal = SysAllocString(L"Admin");
              pTemplate->pParm[i].Value.vt = VT_BSTR;
         }
         else if (!_wcsicmp(pTemplate->pParm[i].strParmDisplayName, L"Password"))
         {
              pTemplate->pParm[i].Value.bstrVal = SysAllocString(L"");
              pTemplate->pParm[i].Value.vt = VT_BSTR;
         }
    }

    // Logon to Jet.
    // =============

    hRes = pController->Logon(pTemplate, 0, WMIDB_HANDLE_TYPE_VERSIONED, &pSession, &pRoot);

    if (SUCCEEDED(hRes))
    {
        m_pEseSession = pSession;
        m_pEseRoot = pRoot;    // Refcount is ok
    }

    pController->FreeLogonTemplate(&pTemplate);

	if (SUCCEEDED(hRes))
	{
		m_pEseController = pController;
		m_pEseController->AddRef();
	}

    // Ensure ROOT and ROOT\DEFAULT are there.
    // =======================================

    if (SUCCEEDED(hRes))
        hRes = EnsureDefault();

    if (SUCCEEDED(hRes))
        hRes = UpgradeSystemClasses();


    if (SUCCEEDED(hRes))
    {
        DWORD dwMaxSize;
        HKEY hKey;
        long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                        L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                        0, KEY_READ | KEY_WRITE, &hKey);
        if(lRes)
            return lRes;
        CRegCloseMe cm(hKey);

        DWORD dwLen = sizeof(DWORD);
        lRes = RegQueryValueExW(hKey, L"Max Class Cache Size", NULL, NULL,
                    (LPBYTE)&dwMaxSize, &dwLen);

        if(lRes != ERROR_SUCCESS)
        {
            dwMaxSize = 5000000;
            lRes = RegSetValueExW(hKey, L"Max Class Cache Size", 0, REG_DWORD,
                    (LPBYTE)&dwMaxSize, sizeof(DWORD));
        }
        m_pEseController->SetCacheValue(dwMaxSize);
    }

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CRepository::EnsureDefault()
{
    HRESULT hRes;
    IWmiDbSession *pSession = NULL;
    IWmiDbSessionEx *pSessionEx = NULL;
    IWmiDbHandle *pRootNs = 0, *pRootDefaultNs = 0, *pRootSecurityNs = 0;

    //Create a new session...
    hRes = CRepository::GetNewSession(&pSession);
    if (FAILED(hRes))
        return hRes;

    //Get an EX version that supports transactioning...
    pSession->QueryInterface(IID_IWmiDbSessionEx, (void**)&pSessionEx);
    if (pSessionEx)
    {
        pSession->Release();
        pSession = pSessionEx;
    }
    CReleaseMe relMe1(pSession);

    //If we have transactionable session, use it!
    if (pSessionEx)
    {
        hRes = pSessionEx->BeginWriteTransaction(0);
        if (FAILED(hRes))
        {
            return hRes;
        }
    }

    try
    {
        //First we work on the ROOT namespace
        //-----------------------------------
        hRes = OpenEseNs(pSession, L"ROOT", &pRootNs);
        if (hRes == WBEM_E_NOT_FOUND)
        {
            //Create as it does not exist...
            hRes = CreateEseNs(pSession, L"ROOT", &pRootNs);
        }

        //Unfortunately, root always seems to have been created, so cannot actually optimise this one!
        if (SUCCEEDED(hRes))
        {
            //Create objects that only reside in the root namespace
            hRes = EnsureNsSystemRootObjects(pSession, pRootNs, NULL,  NULL);
        }
        if (SUCCEEDED(hRes))
        {
            //Create generic instances that exist in all namespaces
            hRes = EnsureNsSystemInstances(pSession, pRootNs, NULL,  NULL);
        }
        if (hRes == WBEM_E_NOT_FOUND)
        {
            //Something bad happened!  This error has a special meaning
            //later on, so remapping so something safer!
            hRes = WBEM_E_FAILED;
        }

        //Next we work on the ROOT\DEFAULT namesapce...
        //---------------------------------------------
        if (SUCCEEDED(hRes))
        {
            hRes = OpenEseNs(pSession, L"ROOT\\DEFAULT", &pRootDefaultNs);
        }
        if (hRes == WBEM_E_NOT_FOUND)
        {
            //Create the namespace as it does not exist and add all the standard
            //stuff that is needed in there...
            hRes = CreateEseNs(pSession, L"ROOT\\DEFAULT", &pRootDefaultNs);
            if (SUCCEEDED(hRes))
            {
                //Need to auto-recover MOFs as this point guarentees that this is
                //a new repository
                ConfigMgr::SetDefaultMofLoadingNeeded();
            }
            if (SUCCEEDED(hRes))
            {
                //Create generic instances that exist in all namespaces
                hRes = EnsureNsSystemInstances(pSession, pRootDefaultNs, pSession, pRootNs);
            }
        }
        if (hRes == WBEM_E_NOT_FOUND)
        {
            //Something bad happened!  This error has a special meaning
            //later on, so remapping so something safer!
            hRes = WBEM_E_FAILED;
        }

        //Finally we work on the ROOT\SECURITY namespace
        //-----------------------------------------------
        if (SUCCEEDED(hRes))
        {
            hRes = OpenEseNs(pSession,  L"ROOT\\SECURITY", &pRootSecurityNs);
        }
        if (hRes == WBEM_E_NOT_FOUND)
        {
            //The namespace is not there so create it
            hRes = CreateEseNs(pSession, L"ROOT\\SECURITY", &pRootSecurityNs);

            if (SUCCEEDED(hRes))
            {
                //Store system instances that exist in all namespaces
                hRes = EnsureNsSystemInstances(pSession, pRootSecurityNs, pSession, pRootNs);
            }
            if (SUCCEEDED(hRes))
            {
                //Store the security objects into the namespace.  These only reside in this
                //namespace
                hRes = EnsureNsSystemSecurityObjects(pSession, pRootSecurityNs, pSession, pRootNs);
            }
        }
    }
    catch (...) // not sure about this one
    {
        ExceptionCounter c;    
        ERRORTRACE((LOG_WBEMCORE, "Creation of empty repository caused a very critical error!\n"));
        hRes = WBEM_E_CRITICAL_ERROR;
    }


    if (SUCCEEDED(hRes))
    {
        //Commit the transaction
        if (pSessionEx)
        {
            hRes = pSessionEx->CommitTransaction(0);
        }
    }
    else
    {
        ERRORTRACE((LOG_WBEMCORE, "Creation of empty repository failed with error <0x%X>!\n", hRes));
        if (pSessionEx)
            pSessionEx->AbortTransaction(0);
    }

    if (pRootNs)
        pRootNs->Release();
    if (pRootDefaultNs)
        pRootDefaultNs->Release();
    if (pRootSecurityNs)
        pRootSecurityNs->Release();

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CRepository::Shutdown(BOOL bIsSystemShutDown)
{
    if (m_pEseController)
        m_pEseController->Shutdown(bIsSystemShutDown?WMIDB_SHUTDOWN_MACHINE_DOWN:0);

    if (m_pEseRoot)
    {
        m_pEseRoot->Release();
        m_pEseRoot = NULL;
    }

    if (m_pEseSession)
    {
        m_pEseSession->Release();
        m_pEseSession = NULL;
    }

    if (m_pEseController)
    {
        m_pEseController->Release();
        m_pEseController = NULL;
    }

    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************
// ok

HRESULT CRepository::GetDefaultSession(
    OUT IWmiDbSession **pSession
    )
{
    if (m_pEseSession == 0)
        return WBEM_E_CRITICAL_ERROR;

    *pSession = m_pEseSession;
    (*pSession)->AddRef();

    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//  CRepository::OpenNs
//
//  ESE only
//
//***************************************************************************
//
HRESULT CRepository::OpenEseNs(
    IN IWmiDbSession *pSession,
    IN  LPCWSTR pszNamespace,
    OUT IWmiDbHandle **pHandle
    )
{
    if (pHandle == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (pSession == NULL)
        pSession = m_pEseSession;

    *pHandle = 0;

    // Check for virtual root ns (one level up from ROOT).
    // ===================================================
    if (pszNamespace == 0)
    {
        if (m_pEseRoot == 0)
            return WBEM_E_CRITICAL_ERROR;

        *pHandle = m_pEseRoot;
        (*pHandle)->AddRef();

        return WBEM_S_NO_ERROR;
    }

    // Loop through the nested namespaces until we get to the last one.
    // ================================================================

    wchar_t* pszSource = new wchar_t[wcslen(pszNamespace)+1];
    CVectorDeleteMe<wchar_t> vdm1(pszSource);
    if (pszSource == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    wcscpy(pszSource, pszNamespace);
    LPCWSTR pszDelimit = L"\\";
    LPWSTR pszTok = wcstok(LPWSTR(pszSource), pszDelimit);  // First ns token
    HRESULT hRes = 0;
    IWmiDbHandle *pCurrent = m_pEseRoot;
    IWmiDbHandle *pTmp = 0;
    if (pCurrent)
        pCurrent->AddRef();
    else
        return WBEM_E_CRITICAL_ERROR;

    while (pszTok)
    {
        // Current namespace is <pszTok>
        // =============================

        IWbemPath *pPath = ConfigMgr::GetNewPath();
        if (pPath == 0)
        {
            pCurrent->Release();
            return WBEM_E_OUT_OF_MEMORY;
        }
        CReleaseMe _1(pPath);

        WString sPath;
        try 
        {
	        sPath = "__namespace='";
	        sPath += pszTok;
	        sPath += "'";
        } 
        catch (CX_MemoryException &)
        {
            return WBEM_E_OUT_OF_MEMORY;
        };
        
        pPath->SetText(WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , sPath);

        hRes = pSession->GetObject(pCurrent, pPath, 0, WMIDB_HANDLE_TYPE_COOKIE, &pTmp);

        pszTok = wcstok(NULL, pszDelimit);
        pCurrent->Release();

        if (FAILED(hRes))
            return hRes;

        // If here, we got it.  So either we are done, or we need to keep going.
        // =====================================================================
        if (pszTok)
            pCurrent = pTmp;
        else
        {
            // All done
            *pHandle = pTmp;
            break;
        }
    }


    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
// Executed; seems to work

HRESULT CRepository::GetObject(
    IN IWmiDbSession *pSession,
    IN IWmiDbHandle *pNs,
    IN LPCWSTR pszObjectPath,           // NS relative only for now
    IN ULONG uFlags,
    OUT IWbemClassObject **pObj
    )
{
    HRESULT hRes;

    //
    // Check if the session supports faster interface
    //

    IWmiDbSessionEx* pEx = NULL;
    hRes = pSession->QueryInterface(IID_IWmiDbSessionEx, (void**)&pEx);
    if(SUCCEEDED(hRes))
    {
        CReleaseMe rm1(pEx);

        hRes = pEx->GetObjectByPath(pNs, pszObjectPath, uFlags,
                                    IID_IWbemClassObject, (void**)pObj);
    }
    else
    {
        // Path to object.
        // ===============
        IWbemPath *pPath = ConfigMgr::GetNewPath();
        if (pPath == 0)
            return WBEM_E_OUT_OF_MEMORY;
        CReleaseMe _1(pPath);
        pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, pszObjectPath);


        // Get it.
        // =======

        hRes = pSession->GetObjectDirect(pNs, pPath, uFlags, IID_IWbemClassObject, (void **)pObj);
    }

    if (FAILED(hRes))
    {
//      DEBUGTRACE((LOG_REPDRV, "Failed with 0x%X\n", hRes));
        return hRes;
    }
    else
    {
#ifdef TESTONLY
        BSTR str = 0;
        (*pObj)->GetObjectText(0, &str);
        DEBUGTRACE((LOG_REPDRV, "  GetObject() Text = \n%S\n\n", str));
        SysFreeString(str);
#endif
    }

    return hRes;
}

//***************************************************************************
//
//  Does not support nesting yet
//
//***************************************************************************
// ok

HRESULT CRepository::CreateEseNs(
    IN  IWmiDbSession *pSession,
    IN  LPCWSTR pszNamespace,
    OUT IWmiDbHandle **pHandle
    )
{
    HRESULT hRes = 0;

    if (pszNamespace == 0 || pHandle == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (pSession == NULL)
    {
        pSession = m_pEseSession;
    }

    // Loop through each namespace and try to open it.  If we can
    // keep going.  If we fail, create it at the current level and
    // return the handle.
    // ===========================================================

    wchar_t* pszSource = new wchar_t[wcslen(pszNamespace)+1];
    CVectorDeleteMe<wchar_t> vdm1(pszSource);
    if (pszSource == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    wcscpy(pszSource, pszNamespace);
    LPCWSTR pszDelimit = L"\\";
    LPWSTR pszTok = wcstok(LPWSTR(pszSource), pszDelimit);  // First ns token
    IWmiDbHandle *pCurrent = m_pEseRoot;
    IWmiDbHandle *pTmp = 0;
    pCurrent->AddRef();

    while (pszTok)
    {
        // Current namespace is <pszTok>
        // =============================

        IWbemPath *pPath = ConfigMgr::GetNewPath();
        if (pPath == 0)
        {
            pCurrent->Release();
            return WBEM_E_OUT_OF_MEMORY;
        }
        CReleaseMe _1(pPath);

        WString sPath = "__namespace='";
        sPath += pszTok;
        sPath += "'";

        pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, sPath);

        hRes = pSession->GetObject(pCurrent, pPath, 0, WMIDB_HANDLE_TYPE_COOKIE, &pTmp);

        wchar_t* TmpStr = new wchar_t[wcslen(pszTok)+1];
        if (TmpStr == NULL)
        {
            pCurrent->Release();
            return WBEM_E_OUT_OF_MEMORY;
        }
        CVectorDeleteMe<wchar_t> vdm1(TmpStr);
        *TmpStr = 0;

        if (pszTok)
            wcscpy(TmpStr, pszTok);

        pszTok = wcstok(NULL, pszDelimit);

        if (FAILED(hRes))
        {
            // If here, we try to create the namespace.
            // ========================================

            // Get a copy of class __Namespace
            // ================================
            IWbemClassObject *pNsClass = 0;

            hRes = GetObject(pSession, pCurrent, L"__Namespace", 0,
                                &pNsClass);
            if (FAILED(hRes))
            {
                pCurrent->Release();
                return hRes;
            }

            CReleaseMe _1(pNsClass);

            IWbemClassObject *pNs;
            pNsClass->SpawnInstance(0, &pNs);
            CReleaseMe _(pNs);

            CVARIANT v;
            v.SetStr(TmpStr);
            pNs->Put(L"Name", 0, &v, 0);

            hRes = pSession->PutObject(pCurrent, IID_IWbemClassObject, pNs, WBEM_FLAG_CREATE_ONLY, WMIDB_HANDLE_TYPE_VERSIONED, &pTmp);
            if (FAILED(hRes))
            {
                pCurrent->Release();
                return hRes;
            }
            pCurrent->Release();
            pCurrent = pTmp;
            if (pszTok)
                continue;
            *pHandle = pTmp;
            break;
        }

        // If here, we got it.  So either we are done, or we need to keep going.
        // =====================================================================

        else if (pszTok)
        {
            pCurrent->Release();
            pCurrent = pTmp;
        }
        else
        {
            // All done
            *pHandle = pTmp;
            break;
        }
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
// Executed; seems to work

HRESULT CRepository::PutObject(
    IN IWmiDbSession *pSession,
    IN IWmiDbHandle *pNs,
    IN REFIID riid,
    IN LPVOID pObj,
    IN DWORD dwFlags
    )
{
    if (pNs == 0 || pObj == 0)
        return WBEM_E_INVALID_PARAMETER;

    if(dwFlags & WBEM_FLAG_NO_EVENTS)
    {
        dwFlags |= WMIDB_DISABLE_EVENTS;
    }

    // Mask out unrecognized flags
    dwFlags &=  (WBEM_FLAG_OWNER_UPDATE | WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_UPDATE_SAFE_MODE | WBEM_FLAG_UPDATE_FORCE_MODE
                 | WBEM_FLAG_USE_SECURITY_DESCRIPTOR | WMIDB_FLAG_ADMIN_VERIFIED | WMIDB_DISABLE_EVENTS);

    HRESULT hRes;
    try
    {
        /*
        // BEGIN TEMP CODE Check for stress test class.
            BOOL bRetry = FALSE;

            VARIANT v;
            VariantInit(&v);
            IWbemClassObject *pWmiObj = (IWbemClassObject *) pObj;
            hRes = pWmiObj->Get(L"__CLASS", 0, &v, 0, 0);
            if (SUCCEEDED(hRes))
            {
                if (_wcsicmp(V_BSTR(&v), L"eStressStatus") == 0)
                    bRetry = TRUE;
            }
            VariantClear(&v);

        // END TEMP CODE
        */

        hRes = pSession->PutObject(pNs, riid, pObj, dwFlags, 0, 0);

        /*
        // MORE TEMP CODE
            if (FAILED(hRes) && bRetry)
            {
                DebugBreak();
                while (1)
                {
                    BOOL bRes = RevertToSelf();
                    hRes = pSession->PutObject(pNs, riid, pObj, dwFlags, 0, 0);
                    Sleep(5000);
                }
            }
        // END TEMP CDOE
        */
    }
    catch(...)
    {
        ExceptionCounter c;    
        hRes = WBEM_E_CRITICAL_ERROR;
    }

//    DEBUGTRACE((LOG_REPDRV, "CRepository::PutObject() Result = 0x%X\n", hRes));

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
// inspected; no execution history

HRESULT CRepository::ExecQuery(
    IN IWmiDbSession *pSession,
    IN IWmiDbHandle *pNs,
    IN LPCWSTR pszQuery,
    IN IWbemObjectSink *pSink,
    IN LONG lFlags
    )
{
    HRESULT hRes = 0;

    IWbemQuery *pQuery = NULL;
    hRes = CoCreateInstance(CLSID_WbemQuery, NULL, CLSCTX_INPROC_SERVER, IID_IWbemQuery, (void **)&pQuery);

    if (FAILED(hRes))
    {
        pSink->SetStatus(0, WBEM_E_CRITICAL_ERROR, 0, 0);
        return WBEM_E_CRITICAL_ERROR;
    }

    CReleaseMe _1(pQuery);

    hRes = pQuery->Parse(L"SQL", pszQuery, 0);
    if (FAILED(hRes))
    {
        pSink->SetStatus(0, WBEM_E_INVALID_QUERY, 0, 0);
        return WBEM_E_INVALID_QUERY;
    }

    // Now, execute the query.
    // =======================

    IWmiDbIterator *pIterator = NULL;

    try
    {
        hRes = pSession->ExecQuery(pNs, pQuery, lFlags, WMIDB_HANDLE_TYPE_COOKIE, NULL, &pIterator);
    }
    catch(...)
    {
        ExceptionCounter c;    
        hRes = WBEM_E_CRITICAL_ERROR;
    }

    // If this is a "delete" query, there
    // will be no iterator.
    // ==================================

    if (FAILED(hRes) || !pIterator)
    {
        pSink->SetStatus(0, hRes, 0, 0);
        return hRes;
    }

    // If here, there are results, I guess.
    // ====================================

    REFIID riid = IID_IWbemClassObject;
    DWORD dwObjects = 0;

    // Convert current thread to a fiber
    // =================================

    // First, uncovert the thread to prevent a leak if we are already 
    // converted.  There is no way of checking, sadly.

    void* pFiber = NULL;

	_TEB *pTeb = NtCurrentTeb();
    BOOL bIsThisThreadAlreadyAFiber = (pTeb->HasFiberData != 0);

    if (!bIsThisThreadAlreadyAFiber)
        pFiber = ConvertThreadToFiber(NULL);
    else
        pFiber = GetCurrentFiber();

    if(pFiber == NULL)
    {
        if (pIterator)
            pIterator->Release();

        pSink->SetStatus(0, WBEM_E_OUT_OF_MEMORY, 0, 0);
        return WBEM_E_OUT_OF_MEMORY;
    }

    // Extract everything from the iterator
    // ====================================

    while (1)
    {
        IWbemClassObject *pObj = 0;
        DWORD dwReturned = 0;

        hRes = pIterator->NextBatch(
            1,                        // one at a time for now
            5,                        // Timeout seconds(or milliseconds? who knows...)
            0,                        // Flags
            WMIDB_HANDLE_TYPE_COOKIE,
            riid,
            pFiber,
            &dwReturned,
            (LPVOID *) &pObj
            );

        if (dwReturned == 0 || pObj == 0 || FAILED(hRes))
            break;

        dwObjects += dwReturned;
        hRes = pSink->Indicate(1, &pObj);
        pObj->Release();
        if (FAILED(hRes))   // Allow an early cancellation
            break;
    }

    if (pIterator)
    {
        pIterator->Cancel(hRes, pFiber);
        pIterator->Release();
    }

    if (!bIsThisThreadAlreadyAFiber)
        ConvertFiberToThread();

    if (SUCCEEDED(hRes))
        hRes = WBEM_S_NO_ERROR;
    hRes = pSink->SetStatus(0, hRes, 0, 0);

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
// inspected; no execution history

HRESULT CRepository::QueryClasses(
    IN IWmiDbSession *pSession,
    IN IWmiDbHandle *pNs,
    IN ULONG uFlags,                //  WBEM_FLAG_DEEP = 0,  WBEM_FLAG_SHALLOW = 1,
    IN LPCWSTR pszSuperclass,
    IN IWbemObjectSink *pSink
    )
{
    HRESULT hRes;

    // Build the query required for simple class operations.
    // =====================================================

    WString sQuery = L"select * from meta_class";

    if (pszSuperclass)
    {
        if (uFlags & WBEM_FLAG_SHALLOW)
        {
            sQuery += " where ";
            sQuery += " __SuperClass = '";
            sQuery += pszSuperclass;
            sQuery += "'";

        }
        else
        {
            if (wcslen(pszSuperclass) > 0)
            {
                sQuery += " where ";
                sQuery += "__this isa '";
                sQuery += pszSuperclass;
                sQuery += "'";
                sQuery += " and __class <> '";
                sQuery += pszSuperclass;
                sQuery += "'";
            }
        }
    }


    // Ship it to the more general query function.
    // ===========================================

    hRes = CRepository::ExecQuery(pSession, pNs, sQuery, pSink, uFlags);
    return hRes;
}

//***************************************************************************
//
//***************************************************************************
// inspected; no execution history

HRESULT CRepository::DeleteObject(
    IN IWmiDbSession *pSession,
    IN IWmiDbHandle *pNs,
    IN REFIID riid,
    IN LPVOID pObj,
    IN DWORD dwFlags
    )
{
    return pSession->DeleteObject(pNs, dwFlags, riid, pObj);
}

//***************************************************************************
//
//***************************************************************************

HRESULT CRepository::DeleteByPath(
    IN IWmiDbSession *pSession,
    IN IWmiDbHandle *pNs,
    IN LPCWSTR pszPath,
    IN DWORD uFlags
    )
{
    HRESULT hRes;

    if(uFlags & WBEM_FLAG_NO_EVENTS)
    {
        uFlags |= WMIDB_DISABLE_EVENTS;
    }

    //
    // Check if the session supports faster interface
    //

    IWmiDbSessionEx* pEx = NULL;
    hRes = pSession->QueryInterface(IID_IWmiDbSessionEx, (void**)&pEx);
    if(SUCCEEDED(hRes))
    {
        CReleaseMe rm1(pEx);

        hRes = pEx->DeleteObjectByPath(pNs, pszPath, uFlags);
    }
    else
    {
        IWmiDbHandle *pHandle = NULL;

        // Path to object.
        // ===============
        IWbemPath *pPath = ConfigMgr::GetNewPath();
        if (pPath == 0)
            return WBEM_E_OUT_OF_MEMORY;
        CReleaseMe _1(pPath);
        pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, pszPath);

        hRes = pSession->GetObject(pNs, pPath, 0, WMIDB_HANDLE_TYPE_COOKIE|WMIDB_HANDLE_TYPE_EXCLUSIVE, &pHandle);
        if (FAILED(hRes))
            return hRes;
        hRes = DeleteObject(pSession, pNs, IID_IWmiDbHandle, pHandle, uFlags);
        pHandle->Release();
    }

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
// visually ok

HRESULT CRepository::InheritsFrom(
    IN IWmiDbSession *pSession,
    IN IWmiDbHandle *pNs,
    IN LPCWSTR pszSuperclass,
    IN LPCWSTR pszSubclass
    )
{
    IWbemClassObject *pObj = 0;

    HRESULT hRes = GetObject(pSession, pNs, pszSubclass, 0, &pObj);
    if (FAILED(hRes))
        return hRes;

    CReleaseMe _(pObj);

    hRes = pObj->InheritsFrom(pszSuperclass);

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CRepository::GetRefClasses(
    IN IWmiDbSession *pSession,
    IN IWmiDbHandle *pNs,
    IN LPCWSTR pszClass,
    IN BOOL bIncludeSubclasses,
    OUT CWStringArray &aClasses
    )
{
    WString sQuery = "references of {";
    sQuery +=pszClass;
    sQuery += "}";

    CSynchronousSink* pRefClassSink = 0;
    pRefClassSink = new CSynchronousSink;
    if (pRefClassSink == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pRefClassSink->AddRef();
    CReleaseMe _1(pRefClassSink);

    HRESULT hRes = CRepository::ExecQuery(pSession, pNs, sQuery, pRefClassSink, 0);

    if (FAILED(hRes) && hRes != WBEM_E_NOT_FOUND)
        return WBEM_E_CRITICAL_ERROR;

    pRefClassSink->GetStatus(&hRes, NULL, NULL);

    CRefedPointerArray<IWbemClassObject>& raObjects = pRefClassSink->GetObjects();

    for (int i = 0; i < raObjects.GetSize(); i++)
    {
        IWbemClassObject *pClsDef = (IWbemClassObject *) raObjects[i];

        CVARIANT vGenus;
        hRes = pClsDef->Get(L"__GENUS", 0, &vGenus, 0, 0);
        if (FAILED(hRes))
            return hRes;
        if(V_VT(&vGenus) == VT_I4 && V_I4(&vGenus) == 1)
        {
            CVARIANT v;
            if(SUCCEEDED(pClsDef->Get(L"__CLASS", 0, &v, 0, 0)))
                aClasses.Add(v.GetStr());
        }
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CRepository::GetInstanceRefs(
    IN IWmiDbSession *pSession,
    IN IWmiDbHandle *pNs,
    IN LPCWSTR pszTargetObject,
    IN IWbemObjectSink *pSink
    )
{
    WString sQuery = "references of {";
    sQuery += pszTargetObject;
    sQuery += "}";

    HRESULT hRes = ExecQuery(pSession, pNs, sQuery, pSink, 0);

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CRepository::GetClassesWithRefs(
    IN IWmiDbSession *pSession,
    IN IWmiDbHandle *pNs,
    IN IWbemObjectSink *pSink
    )
{
    // TBD: Jet Blue
    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//  CRepository::BuildClassHierarchy
//
//  Notes:
//  Builds a decorated class hierarchy tree.  Doesn't use dyn classes yet.
//
//  <pNs>
//      The namespace to use for classes.
//
//  <pBaseClassName>
//      May not be null.
//
//  <lFlags>
//      Not used yet.
//
//  <pDynasty>
//      Receives the class dynasty tree.
//
//  Verification:
//  (a) Verifies that pBaseClassName is a class which has a key or inherits one.
//
//******************************************************************************
//

HRESULT CRepository::BuildClassHierarchy(
    IN  IWmiDbSession *pSession,
    IN  IWmiDbHandle *pNs,
    IN  LPCWSTR pBaseClassName,
    IN  LONG lFlags,
    OUT CDynasty **pDynasty
    )
{
    if (pNs == 0 || pBaseClassName == 0 || pDynasty == 0)
        return WBEM_E_INVALID_PARAMETER;

    // First, execute a schema query for all the classes in the dynasty.
    // We verify that the base as a key, or else it is an error.
    //
    // TBD: Dynamic classes are not merged in yet
    //
    // ================================================================

    WString sQuery = "select * from meta_class where __this isa '";
    sQuery += pBaseClassName;
    sQuery += "'";

    CSynchronousSink* pRefClassSink = 0;
    pRefClassSink = new CSynchronousSink;
    if (pRefClassSink == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pRefClassSink->AddRef();
    CReleaseMe _1(pRefClassSink);

    HRESULT hRes = CRepository::ExecQuery(pSession, pNs, sQuery, pRefClassSink, 0);

    if (FAILED(hRes))
        return hRes;

    pRefClassSink->GetStatus(&hRes, NULL, NULL);

    CRefedPointerArray<IWbemClassObject>& raObjects =
                                            pRefClassSink->GetObjects();

    // Find root class amongst all those relatives.
    // ============================================

    CFlexArray aClasses;
    IWbemClassObject *pRoot = 0;

    for (int i = 0; i < raObjects.GetSize(); i++)
    {
        IWbemClassObject *pClsDef = (IWbemClassObject *) raObjects[i];

        CVARIANT v;
        hRes = pClsDef->Get(L"__CLASS", 0, &v, 0, 0);
        if (FAILED(hRes))
            return hRes;

        if (_wcsicmp(v.GetStr(), pBaseClassName) == 0)
            pRoot = pClsDef;
        else
        {
            aClasses.Add(pClsDef);
        }
    }

    if (pRoot == 0)                     // Did we find it?
        return WBEM_E_NOT_FOUND;

    // Algorithm:
    // Add root class first, enqueue the ptr.
    //
    // (a) Dequeue ptr into pCurrentClass
    // (b) Find all classes which have pCurrentClass as the parent
    //     For each, create a CDynasty, add it to the current dynasty
    //     and enqueue each.  Remove enqueued class from array.
    // (c) Goto (a)

    CFlexQueue Q;
    CDynasty *p = new CDynasty(pRoot);
    if (p == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    *pDynasty = p;
    Q.Enqueue(p);

    while (aClasses.Size())
    {
        CDynasty *pCurrent = (CDynasty *) Q.Dequeue();
        if (pCurrent == 0)
            break;

        CVARIANT vClassName;
        hRes = pCurrent->m_pClassObj->Get(L"__CLASS", 0, &vClassName, 0, 0);
        if (FAILED(hRes))
            return hRes;

        for (int i = 0; i < aClasses.Size(); i++)
        {
            IWbemClassObject *pCandidate = (IWbemClassObject *) aClasses[i];

            VARIANT vSuperClass;
            hRes = pCandidate->Get(L"__SUPERCLASS", 0, &vSuperClass, 0, 0);
            if (FAILED(hRes))
                return hRes;

            if (vSuperClass.vt == VT_BSTR && _wcsicmp(vSuperClass.bstrVal, vClassName.GetStr()) == 0)
            {
                CDynasty *pNewChild = new CDynasty(pCandidate);
                if (pNewChild == NULL)
                    return WBEM_E_OUT_OF_MEMORY;
                pCurrent->AddChild(pNewChild);      // no ref count change
                Q.Enqueue(pNewChild);
                aClasses.RemoveAt(i);
                i--;
            }
            VariantClear(&vSuperClass);
        }
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CRepository::FindKeyRoot(
    IN IWmiDbSession *pSession,
    IN IWmiDbHandle *pNs,
    IN LPCWSTR wszClassName,
    OUT IWbemClassObject** ppKeyRootClass
    )
{
    if (pNs == 0 || wszClassName == 0 || ppKeyRootClass == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Work through derivation until we find the class with the key.
    // =============================================================

    *ppKeyRootClass = 0;

    HRESULT hRes;
    IWbemClassObject*   pLastClass = NULL;
    WString sNextClass = wszClassName;

    while (1)
    {
        IWbemClassObject *pNextClass = 0;

        hRes = GetObject(pSession, pNs, sNextClass, 0, &pNextClass);
        CReleaseMe  rm(pNextClass);

        if (FAILED(hRes))
            break;

        CVARIANT v;
        hRes = pNextClass->Get(L"__SUPERCLASS", 0, &v, 0, 0);

        // Something is REALLY wrong if this fails
        if ( FAILED(hRes) )
        {
            break;
        }
        else if ( V_VT(&v) == VT_NULL )
        {
            sNextClass.Empty();
        }
        else
        {
            sNextClass = v.GetStr();
        }

        BSTR strProp = 0;
        LONG lFlavor = 0;
        pNextClass->BeginEnumeration(WBEM_FLAG_KEYS_ONLY);
        hRes = pNextClass->Next(0, &strProp, 0, 0, &lFlavor);

        // WBEM_S_NO_ERROR means we got a property that was defined as a key
        if (hRes == WBEM_S_NO_ERROR)
        {
            if (strProp)
                SysFreeString(strProp);

            // Release last class if appropriate
            if ( NULL != pLastClass )
            {
                pLastClass->Release();
            }

            // Hold onto the last class
            pLastClass = pNextClass;
            pLastClass->AddRef();

        }
        else if ( hRes == WBEM_S_NO_MORE_DATA )
        {
            // If we don't have a last class, then we didn't find anything.  Otherwise,
            // since we found no key's here, the last class was the one that defined the
            // keys

            if ( NULL != pLastClass )
            {
                *ppKeyRootClass = pLastClass;
                return WBEM_S_NO_ERROR;
            }
            else
            {
                break;
            }
        }
        else
        {
            // Otherwise something is just plain wrong
            break;
        }

    }

    return WBEM_E_NOT_FOUND;
}

//***************************************************************************
//
//***************************************************************************
// visually ok

HRESULT CRepository::TableScanQuery(
    IN IWmiDbSession *pSession,
    IN IWmiDbHandle *pNs,
    IN LPCWSTR pszClassName,
    IN QL_LEVEL_1_RPN_EXPRESSION *pExp,     // NOT USED
    IN DWORD dwFlags,
    IN IWbemObjectSink *pSink
    )
{
    WString sQuery = "select * from ";
    sQuery += pszClassName;
    HRESULT hRes = ExecQuery(pSession, pNs, sQuery, pSink, 0);
    return hRes;
}



//***************************************************************************
//
//***************************************************************************
//
HRESULT CRepository::InitDriver(
    IN  ULONG uFlags,
    IN  IWbemClassObject *pMappedNs,
    OUT IWmiDbController **pResultController,
    OUT IWmiDbSession **pResultRootSession,
    OUT IWmiDbHandle  **pResultVirtualRoot
    )
{
    HRESULT hRes;
    IWmiDbController *pSql = 0;
    IWmiDbSession *pSession = 0;
    IWmiDbHandle *pRoot = 0;
    WMIDB_LOGON_TEMPLATE *pTemplate = 0;

    *pResultController = 0;
    *pResultRootSession = 0;
    *pResultVirtualRoot = 0;

    // Get the COM CLSID.
    // ===================
    CVARIANT v;
    hRes = pMappedNs->Get(L"CLSID", 0, &v, 0, 0);
    if (FAILED(hRes))
        return hRes;

    CLSID RepClsId;
    hRes= CLSIDFromString(v.GetStr(), &RepClsId);
    if (FAILED(hRes))
        return hRes;

    hRes = CoCreateInstance(
        RepClsId,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IWmiDbController,
        (void **) &pSql
        );

    if (FAILED(hRes))
        return hRes;

    CReleaseMe _1(pSql);

    // Extract logon info from Ctx.
    // ============================

    hRes = pSql->GetLogonTemplate(0x409, 0, &pTemplate);

    if (FAILED(hRes))
        return hRes;

    for (DWORD i = 0; i < pTemplate->dwArraySize; i++)
    {
        if (!_wcsicmp(pTemplate->pParm[i].strParmDisplayName, L"Server"))
        {
            CVARIANT v;
            hRes = pMappedNs->Get(L"Server", 0, &v, 0, 0);
            if (SUCCEEDED(hRes))
            {
                pTemplate->pParm[i].Value.bstrVal = SysAllocString(v.GetStr());
                pTemplate->pParm[i].Value.vt = VT_BSTR;
            }
        }
        else if (!_wcsicmp(pTemplate->pParm[i].strParmDisplayName, L"Database"))
        {
            CVARIANT v;
            hRes = pMappedNs->Get(L"Database", 0, &v, 0, 0);
            if (SUCCEEDED(hRes))
            {
                pTemplate->pParm[i].Value.bstrVal = SysAllocString(v.GetStr());
                pTemplate->pParm[i].Value.vt = VT_BSTR;
            }
        }
        else if (!_wcsicmp(pTemplate->pParm[i].strParmDisplayName, L"UserID"))
        {
            CVARIANT v;
            hRes = pMappedNs->Get(L"UserID", 0, &v, 0, 0);
            if (SUCCEEDED(hRes))
            {
                pTemplate->pParm[i].Value.bstrVal = SysAllocString(v.GetStr());
                pTemplate->pParm[i].Value.vt = VT_BSTR;
            }
        }
        else if (!_wcsicmp(pTemplate->pParm[i].strParmDisplayName, L"Password"))
        {
            CVARIANT v;
            hRes = pMappedNs->Get(L"Password", 0, &v, 0, 0);
            if (SUCCEEDED(hRes))
            {
                pTemplate->pParm[i].Value.bstrVal = SysAllocString(v.GetStr());
                pTemplate->pParm[i].Value.vt = VT_BSTR;
            }
        }
        else if (!_wcsicmp(pTemplate->pParm[i].strParmDisplayName, L"Config"))
        {
            CVARIANT v;
            hRes = pMappedNs->Get(L"Config", 0, &v, 0, 0);
            if (SUCCEEDED(hRes))
            {
                pTemplate->pParm[i].Value.bstrVal = SysAllocString(v.GetStr());
                pTemplate->pParm[i].Value.vt = VT_BSTR;
            }
        }
    }

    // Logon
    // =====

    hRes = pSql->Logon(pTemplate, 0, WMIDB_HANDLE_TYPE_VERSIONED, &pSession, &pRoot);
    pSql->FreeLogonTemplate(&pTemplate);

    if (SUCCEEDED(hRes))
    {
        *pResultController = pSql;
//        pSql->AddRef();
        *pResultRootSession = pSession;
        *pResultVirtualRoot = pRoot;
    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CRepository::EnsureNsSystemInstances(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN IWmiDbSession *pParentSession,
        IN IWmiDbHandle *pParentNs
        )
{
    HRESULT hRes;

    // Do a get and see if __WmiMappedDriverNamespace is there.
    // ========================================================

    IWbemClassObject *pTestObj = 0;
    hRes = GetObject(pSession, pNs, L"__systemsecurity=@", 0, &pTestObj);
    if (SUCCEEDED(hRes))
    {
        pTestObj->Release();
        return WBEM_S_NO_ERROR;
    }

    // If here, it's a new namespace that has to be populated with system classes.
    // ===========================================================================

    CCoreServices *pSvc = CCoreServices::CreateInstance();
    if (pSvc == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    _IWmiObject *Objects[256];
    ULONG uSize = 256;
    hRes = pSvc->GetSystemObjects(GET_SYSTEM_STD_INSTANCES, &uSize, Objects);

    if (SUCCEEDED(hRes))
    {
        for (int i = 0; i < uSize; i++)
        {
            IWbemClassObject *pObj;
            if (SUCCEEDED(hRes))
            {
                hRes = Objects[i]->QueryInterface(IID_IWbemClassObject, (LPVOID *) &pObj);
                if (SUCCEEDED(hRes))
                {
                    hRes = PutObject(pSession, pNs, IID_IWbemClassObject, pObj, WMIDB_DISABLE_EVENTS);
                    pObj->Release();
                    if (FAILED(hRes))
                    {
                        ERRORTRACE((LOG_WBEMCORE, "Creation of system instances failed during repository creation <0x%X>!\n", hRes));
                    }
                }
            }
            Objects[i]->Release();
        }
    }

    if (SUCCEEDED(hRes))
    {
        hRes = SetSecurityForNS(pSession, pNs, pParentSession, pParentNs);
        if (FAILED(hRes))
        {
            ERRORTRACE((LOG_WBEMCORE, "Setting of security on namespace failed during repository creation <0x%X>!\n", hRes));
        }
    }

    pSvc->Release();
    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CRepository::EnsureNsSystemRootObjects(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN IWmiDbSession *pParentSession,
        IN IWmiDbHandle *pParentNs
        )
{
    HRESULT hRes;

    // Do a get and see if __EventSinkCacheControl=@ is there.
    // ========================================================

    IWbemClassObject *pTestObj = 0;
    hRes = GetObject(pSession, pNs, L"__EventSinkCacheControl=@", 0, &pTestObj);
    if (SUCCEEDED(hRes))
    {
        pTestObj->Release();
        return WBEM_S_NO_ERROR;
    }

    // If here, it's a new namespace that has to be populated with system classes.
    // ===========================================================================

    CCoreServices *pSvc = CCoreServices::CreateInstance();
    if (pSvc == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    CReleaseMe _rm(pSvc);
    _IWmiObject *Objects[256];
    ULONG uSize = 256;
    hRes = pSvc->GetSystemObjects(GET_SYSTEM_ROOT_OBJECTS, &uSize, Objects);

    if (SUCCEEDED(hRes))
    {
        for (int i = 0; i < uSize; i++)
        {
            IWbemClassObject *pObj;
            if (SUCCEEDED(hRes))
            {
                hRes = Objects[i]->QueryInterface(IID_IWbemClassObject, (LPVOID *) &pObj);
                if (SUCCEEDED(hRes))
                {
                    hRes = PutObject(pSession, pNs, IID_IWbemClassObject, pObj, WMIDB_DISABLE_EVENTS);
                    pObj->Release();
                    if (FAILED(hRes))
                    {
                        ERRORTRACE((LOG_WBEMCORE, "Creation of system root objects failed during repository creation <0x%X>!\n", hRes));
                    }
                }
            }
            Objects[i]->Release();
        }
    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CRepository::EnsureNsSystemSecurityObjects(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN IWmiDbSession *pParentSession,
        IN IWmiDbHandle *pParentNs
        )
{
    HRESULT hRes;

    // Do a get and see if __User is there.
    // ========================================================

    IWbemClassObject *pTestObj = 0;
    hRes = GetObject(pSession, pNs, L"__User", 0, &pTestObj);
    if (SUCCEEDED(hRes))
    {
        pTestObj->Release();
        return WBEM_S_NO_ERROR;
    }

    // If here, it's a new namespace that has to be populated with system classes.
    // ===========================================================================

    CCoreServices *pSvc = CCoreServices::CreateInstance();
    if (pSvc == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    _IWmiObject *Objects[256];
    ULONG uSize = 256;
    hRes = pSvc->GetSystemObjects(GET_SYSTEM_SECURITY_OBJECTS, &uSize, Objects);

    if (SUCCEEDED(hRes))
    {
        for (int i = 0; i < uSize; i++)
        {
            IWbemClassObject *pObj;
            if (SUCCEEDED(hRes))
            {
                hRes = Objects[i]->QueryInterface(IID_IWbemClassObject, (LPVOID *) &pObj);
                if (SUCCEEDED(hRes))
                {
                    hRes = PutObject(pSession, pNs, IID_IWbemClassObject, pObj, WMIDB_DISABLE_EVENTS);
                    pObj->Release();
                    if (FAILED(hRes))
                    {
                        ERRORTRACE((LOG_WBEMCORE, "Creation of system security objects failed during repository creation <0x%X>!\n", hRes));
                    }
                }
            }
            Objects[i]->Release();
        }
    }


    pSvc->Release();
    return hRes;
}
//***************************************************************************
//
//***************************************************************************
//
static HRESULT IsObjectMappedNs(IN IWbemClassObject *pObj)
{
    CVARIANT v;

    HRESULT hRes = pObj->Get(L"__CLASS", 0, &v, 0, 0);
    if (FAILED(hRes))
        return hRes;
    if (_wcsicmp(v.GetStr(), L"__WmiMappedDriverNamespace") != 0)
        return E_FAIL;

    return S_OK;
}

//***************************************************************************
//
//  Adjusted for all repository drivers.  Works for scopes or namespaces.
//  If a scope is being opened, <pScope> will be set on return and
//  <pbIsNamespace> will point to FALSE.  Otherwise, <pScope> is set to
//  point to NULL and <pbIsNamespace> points to TRUE.
//
//  If <pszScope> is NULL, a pointer to the virtual ROOT in ESE
//  is returned.
//
//***************************************************************************
//
HRESULT CRepository::OpenScope(
    IN  IWmiDbSession *pParentSession,        //Parent session to use to
    IN  LPWSTR pszTargetScope,              // NS or scope
    IN  GUID *pTransGuid,                   // Transaction GUID for connection
    OUT IWmiDbController **pDriver,         // Driver
    OUT IWmiDbSession **pSession,           // Session
    OUT IWmiDbHandle  **pScope,             // Scope
    OUT IWmiDbHandle  **pNs                 // Nearest NS
    )
{
    HRESULT hRes;
    ULONG uNsCount = 0;
    // uScopeCount = 0;

    if (pNs == 0 || pSession == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Default settings.
    // =================

    if (pScope)
        *pScope = 0;

    *pNs = 0;
    *pSession = 0;
    if (pDriver)
      *pDriver = 0;

    // Check for virtual root ns (the parent to ROOT).
    // ===============================================

    if (pszTargetScope == 0)
    {
        if (m_pEseRoot == 0)
            return WBEM_E_CRITICAL_ERROR;

        if (pDriver)
        {
            m_pEseController->AddRef();
            *pDriver = m_pEseController;
        }

        m_pEseSession->AddRef();
        *pSession = m_pEseSession;

        m_pEseRoot->AddRef();
        *pNs = m_pEseRoot;

        return WBEM_S_NO_ERROR;
    }

    // Parse the path.
    // ===============

    IWbemPath *pPath = ConfigMgr::GetNewPath();
    if (pPath == 0)
        return WBEM_E_OUT_OF_MEMORY;
    CReleaseMe _1(pPath);

    hRes = pPath->SetText(WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , pszTargetScope);
    if (FAILED(hRes))
        return WBEM_E_INVALID_NAMESPACE;

    // Analyze it.  Is it just a namespace?
    // Build the namespace string and normalize it.
    // ============================================

    hRes = pPath->GetNamespaceCount(&uNsCount);
    //hRes = pPath->GetScopeCount(&uScopeCount);

    // Starting handles at ROOT.
    // =========================

    IWmiDbHandle *pTempNs = 0;
    IWmiDbHandle *pMostRecent = 0;
    IWmiDbHandle *pMostRecentScope = 0;

    IWmiDbSession    *pTempSession   = m_pEseSession;            // Default virtual root
    IWmiDbController *pTempDriver    = m_pEseController;         // Default driver

    //Use the override if available
    if (pParentSession)
        pTempSession = pParentSession;

    pTempSession->AddRef();     // For later release
    pTempDriver->AddRef();      // For later release

    hRes = OpenEseNs(pTempSession, L"ROOT", &pMostRecent);
    if (FAILED(hRes))
    {
        pTempSession->Release();
        pTempDriver->Release();
        return WBEM_E_CRITICAL_ERROR;
    }

    // Starting driver.
    // ================


    WString sNsDecoration = "ROOT";

    // open up each namespace successively, mapping it.
    // ===============================================

    for (ULONG u = 0; u < uNsCount; u++)
    {
        IWbemClassObject *pNsRep = 0;

        ULONG uLen = 0;
        // Get next namespace token name.
        // ==============================
        hRes = pPath->GetNamespaceAt(u, &uLen, NULL);
        if(FAILED(hRes))
            goto Error;

        WCHAR* Buf = new WCHAR[uLen+1];
        if (Buf == NULL)
        {
            hRes = WBEM_E_OUT_OF_MEMORY;
            goto Error;
        }
        CVectorDeleteMe<WCHAR> vdm(Buf);
        hRes = pPath->GetNamespaceAt(u, &uLen, Buf);
        if (FAILED(hRes) || *Buf == 0)
            goto Error;

        if ((u == 0) && (wbem_wcsicmp(L"root", Buf) != 0))
        {
            hRes = WBEM_E_INVALID_NAMESPACE;
            goto Error;
        }
        else if (u == 0)
            continue;

        // Build a relative scope path.
        // ============================
        WString sPath = "__namespace='";
        sPath += Buf;
        sPath += "'";

        sNsDecoration += "\\";
        sNsDecoration += Buf;

        IWbemPath *pNewPath = ConfigMgr::GetNewPath();
        if (pNewPath == 0)
        {
            hRes = WBEM_E_OUT_OF_MEMORY;
            goto Error;
        }
        CReleaseMe rm1(pNewPath);

        hRes = pNewPath->SetText(WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , sPath);
        if (FAILED(hRes))
            goto Error;

        // Get the reprsentation object.
        // =============================

        hRes = pTempSession->GetObjectDirect(pMostRecent, pNewPath, 0, IID_IWbemClassObject, (void **) &pNsRep);
        if (hRes == WBEM_E_NOT_FOUND)
        {
            //If a namespace does not exist it should return a different namespace...
            hRes = WBEM_E_INVALID_NAMESPACE;
            goto Error;
        }
        else if (FAILED(hRes))
            goto Error;
        CReleaseMe _(pNsRep);

        // See if object is an ESE namespace or a custom one.
        // ==================================================

/*
        hRes = IsObjectMappedNs(pNsRep);
        if (hRes == S_OK)
        {        
            ReleaseIfNotNULL(pMostRecent);
            ReleaseIfNotNULL(pTempNs);
            ReleaseIfNotNULL(pTempDriver);
            ReleaseIfNotNULL(pTempSession);

            pMostRecent = 0;
            pTempNs = 0;
            pTempDriver = 0;
            pTempSession = 0;

            hRes = InitDriver(0, pNsRep, &pTempDriver, &pTempSession, &pMostRecent);
            if (FAILED(hRes))
                goto Error;                
            continue;
        }
*/

        // Now move down one namespace.
        // =============================

        hRes = pTempSession->GetObject(pMostRecent, pNewPath, 0, WMIDB_HANDLE_TYPE_COOKIE, &pTempNs);

        ReleaseIfNotNULL(pMostRecent);
        pMostRecent = pTempNs;
        pTempNs = 0;

        if (FAILED(hRes))
            goto Error;
    }

/*
    // LEVN: not really sure that this does the trick, but it cannot hurt
    pTempSession->SetDecoration(L".", sNsDecoration);

    // Now we have the NS or we have failed and we start on the scopes.
    // If zero scopes, the scope pointer is not used and <pbIsNamespace>
    // is set to TRUE.
    // =================================================================

    if (uScopeCount > 0)
    {
        pMostRecentScope = pMostRecent;
        pMostRecentScope->AddRef();

        for (u = 0; u < uScopeCount; u++)
        {
            ULONG uLen = 0;
            hRes = pPath->GetScopeAsText(u, &uLen, NULL);
            if (FAILED(hRes))
                goto Error;

            wchar_t* Buf = new wchar_t[uLen+1];
            if (Buf == NULL)
            {
                hRes = WBEM_E_OUT_OF_MEMORY;
                goto Error;
            }
            CVectorDeleteMe<wchar_t> vdm1(Buf);

            *Buf = 0;
            IWbemClassObject *pNsRep = 0;
            IWmiDbHandle *pTempScope = 0;

            // Get next namespace token name.
            // ==============================
            hRes = pPath->GetScopeAsText(u, &uLen, Buf);
            if (FAILED(hRes) || *Buf == 0)
                goto Error;

            IWbemPath *pNewPath = ConfigMgr::GetNewPath();
            if (pPath == 0)
            {
                hRes = WBEM_E_OUT_OF_MEMORY;
                goto Error;
            }
            CReleaseMe _(pNewPath);

            hRes = pNewPath->SetText(WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , Buf);
            if (FAILED(hRes))
                goto Error;

            hRes = pTempSession->GetObject(pMostRecentScope, pNewPath, 0, WMIDB_HANDLE_TYPE_COOKIE, &pTempScope);

            ReleaseIfNotNULL(pMostRecentScope);
            pMostRecentScope = pTempScope;
            pTempScope = 0;

            if (FAILED(hRes))
                goto Error;
        }
    }
*/

    // Final.
    // ======
    ReleaseIfNotNULL(pTempNs);

    if (pScope)
        *pScope = pMostRecentScope;

    *pNs = pMostRecent;
    *pSession = pTempSession;
    if (pDriver)
        *pDriver = pTempDriver;


    return WBEM_S_NO_ERROR;

Error:
    ReleaseIfNotNULL(pMostRecent);
    ReleaseIfNotNULL(pTempNs);
    ReleaseIfNotNULL(pTempDriver);
    ReleaseIfNotNULL(pTempSession);

    return hRes;
}

/*
void Test()
{
    IWmiDbController *pDriver = 0;
    IWmiDbSession *pSession = 0;
    IWmiDbHandle *pScope = 0;
    IWmiDbHandle *pNs = 0;
    BOOL bIsNs = FALSE;

    HRESULT hRes = CRepository::OpenScope(L"root", 0, &pDriver, &pSession, &pScope, &pNs);

    ReleaseIfNotNULL(pDriver);
    ReleaseIfNotNULL(pSession);
    ReleaseIfNotNULL(pScope);
    ReleaseIfNotNULL(pNs);

    for (int i = 0; i < 100; i++)
    {
        hRes = CRepository::OpenScope(L"root\\cimv2", 0, &pDriver, &pSession, &pScope, &pNs);

        ReleaseIfNotNULL(pDriver);
        ReleaseIfNotNULL(pSession);
        ReleaseIfNotNULL(pScope);
        ReleaseIfNotNULL(pNs);
    }

    hRes = CRepository::OpenScope(L"root\\cimv2", 0, &pDriver, &pSession, &pScope, &pNs);

    ReleaseIfNotNULL(pDriver);
    ReleaseIfNotNULL(pSession);
    ReleaseIfNotNULL(pScope);
    ReleaseIfNotNULL(pNs);

    hRes = CRepository::OpenScope(L"root\\default", 0, &pDriver, &pSession, &pScope, &pNs, &bIsNs);
    ReleaseIfNotNULL(pDriver);
    ReleaseIfNotNULL(pSession);
    ReleaseIfNotNULL(pScope);
    ReleaseIfNotNULL(pNs);

    hRes = CRepository::OpenScope(L"root\\default", 0, &pDriver, &pSession, &pScope, &pNs, &bIsNs);
    ReleaseIfNotNULL(pDriver);
    ReleaseIfNotNULL(pSession);
    ReleaseIfNotNULL(pScope);
    ReleaseIfNotNULL(pNs);

    hRes = CRepository::OpenScope(L"root\\default", 0, &pDriver, &pSession, &pScope, &pNs, &bIsNs);
    ReleaseIfNotNULL(pDriver);
    ReleaseIfNotNULL(pSession);
    ReleaseIfNotNULL(pScope);
    ReleaseIfNotNULL(pNs);

    hRes = CRepository::OpenScope(L"root\\cimv2", 0, &pDriver, &pSession, &pScope, &pNs, &bIsNs);

    ReleaseIfNotNULL(pDriver);
    ReleaseIfNotNULL(pSession);
    ReleaseIfNotNULL(pScope);
    ReleaseIfNotNULL(pNs);

    hRes = CRepository::OpenScope(L"root\\sqltest", 0, &pDriver, &pSession, &pScope, &pNs, &bIsNs);
    ReleaseIfNotNULL(pDriver);
    ReleaseIfNotNULL(pSession);
    ReleaseIfNotNULL(pScope);
    ReleaseIfNotNULL(pNs);


    hRes = CRepository::OpenScope(L"root\\default\\sqltest", 0, &pDriver, &pSession, &pScope, &pNs);
    ReleaseIfNotNULL(pDriver);
    ReleaseIfNotNULL(pSession);
    ReleaseIfNotNULL(pScope);
    ReleaseIfNotNULL(pNs);

    hRes = CRepository::OpenScope(L"root\\sqltest", 0, &pDriver, &pSession, &pScope, &pNs);
    ReleaseIfNotNULL(pDriver);
    ReleaseIfNotNULL(pSession);
    ReleaseIfNotNULL(pScope);
    ReleaseIfNotNULL(pNs);

}
*/
HRESULT CRepository::GetNewSession(IWmiDbSession **ppSession)
{
    HRESULT hRes;
    IWmiDbController *pController = 0;
    WMIDB_LOGON_TEMPLATE *pTemplate = 0;
    IWmiDbSession *pSession= 0;
    IWmiDbHandle *pRoot = 0;

    // Retrieve the CLSID of the default driver.
    // =========================================
    CLSID clsid;
    hRes = ConfigMgr::GetDefaultRepDriverClsId(clsid);
    if (FAILED(hRes))
        return hRes;

    hRes = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IWmiDbController, (void **)&pController);

    if (FAILED(hRes))
        return hRes;

    CReleaseMe _1(pController);

    hRes = pController->GetLogonTemplate(0x409, 0, &pTemplate);

    if (FAILED(hRes))
        return hRes;

    hRes = pController->Logon(pTemplate, 0, WMIDB_HANDLE_TYPE_VERSIONED, &pSession, &pRoot);

    if (SUCCEEDED(hRes))
    {
        *ppSession = pSession;
        pRoot->Release();
    }

    pController->FreeLogonTemplate(&pTemplate);
    return hRes;
}

HRESULT CRepository::UpgradeSystemClasses()
{
    DWORD dwOldVer = 0;
    DWORD dwNewVer = 0;
    HRESULT hRes;
    
    hRes = m_pEseController->GetRepositoryVersions(&dwOldVer, &dwNewVer);

    if (FAILED(hRes))
        return hRes;

    if (dwOldVer < 4)
    {
        //Lower versions stored system classes in every namespace!  We
        //should delete them!
        CWStringArray aListRootSystemClasses;
        
        //Retrieve the list...
        hRes = GetListOfRootSystemClasses(aListRootSystemClasses);

        if (SUCCEEDED(hRes))
        {
            //Create a new session...
            IWmiDbSession *pSession = NULL;
            IWmiDbSessionEx *pSessionEx = NULL;
            hRes = CRepository::GetNewSession(&pSession);
            if (FAILED(hRes))
                return hRes;

            //Get an EX version that supports transactioning...
            pSession->QueryInterface(IID_IWmiDbSessionEx, (void**)&pSessionEx);
            if (pSessionEx)
            {
                pSession->Release();
                pSession = pSessionEx;
            }
            CReleaseMe relMe1(pSession);

            //If we have transactionable session, use it!
            if (pSessionEx)
            {
                hRes = pSessionEx->BeginWriteTransaction(0);
                if (FAILED(hRes))
                {
                    return hRes;
                }
            }
            try
            {
                //Recursively do the deletion, starting at root, however don't delete
                //the ones in root itself!
                hRes = RecursiveDeleteClassesFromNamespace(pSession, L"root", aListRootSystemClasses, false);
            }
            catch (...) // Only WStringArray should throw
            {
		        ExceptionCounter c;            
                hRes = WBEM_E_CRITICAL_ERROR;
            }
            if (SUCCEEDED(hRes))
            {
                //Commit the transaction
                if (pSessionEx)
                {
                    hRes = pSessionEx->CommitTransaction(0);
                }
            }
            else
            {
                ERRORTRACE((LOG_WBEMCORE, "Removal of ROOT ONLY system classes from non-ROOT namespace failed during repository upgrade <0x%X>!\n", hRes));
                if (pSessionEx)
                    pSessionEx->AbortTransaction(0);
            }

        }
    }

    return hRes;
}

HRESULT CRepository::GetListOfRootSystemClasses(CWStringArray &aListRootSystemClasses)
{
    CCoreServices *pSvc = CCoreServices::CreateInstance();
    if (pSvc == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    _IWmiObject *Objects[256];
    ULONG uSize = 256;
    HRESULT hRes;
    hRes = pSvc->GetSystemObjects(GET_SYSTEM_ROOT_OBJECTS, &uSize, Objects);

    if (SUCCEEDED(hRes))
    {
        for (int i = 0; i < uSize; i++)
        {
            _IWmiObject *pObj;
            if (SUCCEEDED(hRes))
            {
                hRes = Objects[i]->QueryInterface(IID__IWmiObject, (LPVOID *) &pObj);
                if (SUCCEEDED(hRes))
                {
                    if (pObj->IsObjectInstance() != S_OK)
                    {
                        VARIANT var;
                        VariantInit(&var);
                        hRes = pObj->Get(L"__CLASS", 0, &var, 0, 0);
                        if (SUCCEEDED(hRes) && (V_VT(&var) == VT_BSTR))
                        {
                            if (aListRootSystemClasses.Add(V_BSTR(&var)) != CWStringArray::no_error)
                                hRes = WBEM_E_OUT_OF_MEMORY;
                        }
                        VariantClear(&var);
                    }
                    pObj->Release();
                }
            }
            Objects[i]->Release();
        }
    }

    pSvc->Release();

    return hRes;
}

class CNamespaceListSink : public CUnkBase<IWbemObjectSink, &IID_IWbemObjectSink>
{
    CWStringArray &m_aNamespaceList;
public:
    CNamespaceListSink(CWStringArray &aNamespaceList)
        : m_aNamespaceList(aNamespaceList)
    {
    }
    ~CNamespaceListSink()
    {
    }
    STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects)
    {
        HRESULT hRes;
        for (int i = 0; i != lNumObjects; i++)
        {
            if (apObjects[i] != NULL)
            {
                _IWmiObject *pInst = NULL;
                hRes = apObjects[i]->QueryInterface(IID__IWmiObject, (void**)&pInst);
                if (FAILED(hRes))
                    return hRes;
                CReleaseMe rm(pInst);

                BSTR strKey = NULL;
                hRes = pInst->GetKeyString(0, &strKey);
                if(FAILED(hRes))
                    return hRes;
                CSysFreeMe sfm(strKey);
                if (m_aNamespaceList.Add(strKey) != CWStringArray::no_error)
                    return WBEM_E_OUT_OF_MEMORY;
            }
        }

        return WBEM_S_NO_ERROR;
    }
    STDMETHOD(SetStatus)(long lFlags, HRESULT hresResult, BSTR, IWbemClassObject*)
    {
        return WBEM_S_NO_ERROR;
    }

};

//
//
//  throws because of  the WStringArray
//
//
HRESULT CRepository::RecursiveDeleteClassesFromNamespace(IWmiDbSession *pSession,
                                                         const wchar_t *wszNamespace,
                                                         CWStringArray &aListRootSystemClasses,
                                                         bool bDeleteInThisNamespace)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    IWmiDbHandle *pNs = NULL;
    //Open Namespace
    hRes = OpenEseNs(pSession, wszNamespace, &pNs);

    //Delete classes from this namespace if necessary
    if (SUCCEEDED(hRes) && bDeleteInThisNamespace)
    {
        for (int i = 0; i != aListRootSystemClasses.Size(); i++)
        {
            hRes = DeleteByPath(pSession, pNs, aListRootSystemClasses[i], 0);
            if (hRes == WBEM_E_NOT_FOUND)
                hRes = WBEM_S_NO_ERROR;
            else if (FAILED(hRes))
                break;

        }
    }

    //Special class that needs to be deleted is the __classes, and needs to go from all
    //namespaces
    if (SUCCEEDED(hRes))
    {
        hRes = DeleteByPath(pSession, pNs, L"__classes", 0);
        if (hRes == WBEM_E_NOT_FOUND)
            hRes = WBEM_S_NO_ERROR;
    }

    //Enumerate child namespaces...
    CWStringArray aListNamespaces;
    CNamespaceListSink *pSink = NULL;
    
    if (SUCCEEDED(hRes))
    {
        pSink = new CNamespaceListSink(aListNamespaces);
        if (pSink == NULL)
            hRes = WBEM_E_OUT_OF_MEMORY;
        else
            pSink->AddRef();
    }

    if (SUCCEEDED(hRes))
    {
        hRes = ExecQuery(pSession, pNs, L"select * from __namespace", pSink, 0);
    }

    //Work through list and call ourselves with that namespace name...
    if (SUCCEEDED(hRes))
    {
        for (int i = 0; i != aListNamespaces.Size(); i++)
        {
            //Build the full name of this namespace
            wchar_t *wszChildNamespace = new wchar_t[wcslen(wszNamespace) + wcslen(aListNamespaces[i]) + wcslen(L"\\") + 1];
            if (wszChildNamespace == NULL)
            {
                hRes = WBEM_E_OUT_OF_MEMORY;
                break;
            }
            wcscpy(wszChildNamespace, wszNamespace);
            wcscat(wszChildNamespace, L"\\");
            wcscat(wszChildNamespace, aListNamespaces[i]);

            //Do the deletion...
            hRes = RecursiveDeleteClassesFromNamespace(pSession, wszChildNamespace, aListRootSystemClasses, true);
            if (FAILED(hRes))
            {
                delete [] wszChildNamespace;
                break;
            }

            delete [] wszChildNamespace;
        }
    }

    //Tidy up
    if (pSink)
        pSink->Release();
    if (pNs)
        pNs->Release();

    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\dynasty.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/
//***************************************************************************
//
//  DYNASTY.H
//
//  raymcc      24-Apr-00       Created
//
//***************************************************************************

#ifndef _DYNASTY_H_
#define _DYNASTY_H_

class CDynasty
{
public:
    LPWSTR              m_wszClassName;
    IWbemClassObject*   m_pClassObj;        // AddRef'ed, Released
    CFlexArray          *m_pChildren;       // Child classes
    LPWSTR              m_wszKeyScope;

    BOOL                m_bKeyed;
    BOOL                m_bDynamic;
    BOOL                m_bAbstract;
    BOOL                m_bAmendment;

    CDynasty();
    CDynasty(IWbemClassObject* pClassObj);
    ~CDynasty();

    BOOL IsKeyed() {return m_bKeyed;}
    BOOL IsDynamic() {return m_bDynamic;}
    BOOL IsAbstract() {return m_bAbstract;}
    BOOL IsAmendment() {return m_bAbstract;}

    LPCWSTR GetKeyScope() { return m_wszKeyScope; }
    void AddChild(CDynasty* pChild);
    void SetKeyScope(LPCWSTR wszKeyScope);
};

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\dynasty.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//***************************************************************************
//
//  DYNASTY.H
//
//  raymcc      24-Apr-00       Created
//
//***************************************************************************


#include "precomp.h"
#include <windows.h>
#include <stdio.h>
#include <wbemcore.h>

//***************************************************************************
//
//***************************************************************************
// ok

CDynasty::CDynasty(IWbemClassObject* pClassObj)
{
    m_wszClassName = 0;
    m_pClassObj = 0;
    m_bKeyed = 0;
    m_bDynamic = 0;
    m_bAbstract = 0;
    m_bAmendment = 0;

    m_pClassObj = pClassObj;

    m_pChildren = new CFlexArray;
    if (NULL == m_pChildren)
        throw CX_MemoryException();
        
    m_wszKeyScope = 0;

    if (m_pClassObj)
    {
        m_pClassObj->AddRef();

        // Get class name from the object
        // ===============================

        CVar v;
        HRESULT hres = ((CWbemObject *) m_pClassObj)->GetClassName(&v);
        if (hres == WBEM_E_OUT_OF_MEMORY)
            throw CX_MemoryException();
        else if(FAILED(hres) || v.GetType() != VT_BSTR)
        {
            m_wszClassName = NULL;
            if(m_pClassObj)
                m_pClassObj->Release();
            m_pClassObj = NULL;
            return;
        }
        m_wszClassName = new WCHAR[wcslen(v.GetLPWSTR())+1];
        if (m_wszClassName == 0)
        {
            throw CX_MemoryException();
        }
        wcscpy(m_wszClassName, v.GetLPWSTR());
    }

    // Get Dynamic and Keyed bits
    // ==========================

    m_bKeyed = ((CWbemClass *) m_pClassObj)->IsKeyed();
    m_bDynamic = ((CWbemClass*)m_pClassObj)->IsDynamic();
    m_bAbstract = ((CWbemClass*)m_pClassObj)->IsAbstract();
    m_bAmendment = ((CWbemClass*)m_pClassObj)->IsAmendment();
}


//***************************************************************************
//
//***************************************************************************
// ok

CDynasty::~CDynasty()
{
    delete m_wszClassName;

    if (m_pClassObj)
        m_pClassObj->Release();

    if (m_pChildren)
        for (int i = 0; i < m_pChildren->Size(); i++)
            delete (CDynasty *) m_pChildren->GetAt(i);

    delete m_pChildren;

    if (m_wszKeyScope)
        delete m_wszKeyScope;
}

//***************************************************************************
//
//***************************************************************************
// ok

void CDynasty::AddChild(CDynasty* pChild)
{
    if (m_pChildren->Add(pChild) == CFlexArray::out_of_memory)
        throw CX_MemoryException();
}

//***************************************************************************
//
//***************************************************************************
// ok
void CDynasty::SetKeyScope(LPCWSTR wszKeyScope)
{
    // If no key scope is provided and we are keyed, we are it.
    // ========================================================

    if (wszKeyScope == NULL && m_bKeyed)
    {
        wszKeyScope = m_wszClassName; // aliasing!
    }

    m_wszKeyScope = new WCHAR[wcslen(wszKeyScope)+1];
    if (m_wszKeyScope == 0)
        throw CX_MemoryException();

    wcscpy(m_wszKeyScope, wszKeyScope);

    if (m_pChildren)
        for (int i = 0; i < m_pChildren->Size(); i++)
            ((CDynasty *) m_pChildren->GetAt(i))->SetKeyScope(wszKeyScope);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\crep.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//***************************************************************************
//
//  CREP.H
//
//  Wrappers for repository drivers
//
//  raymcc  27-Apr-00       WMI Repository init & mapping layer
//
//***************************************************************************

#ifndef _CREP_H_
#define _CREP_H_


class CRepository
{
    static IWmiDbSession    *m_pEseSession;
    static IWmiDbHandle     *m_pEseRoot;
    static IWmiDbController *m_pEseController;

    static HRESULT EnsureDefault();
	static HRESULT UpgradeSystemClasses();
	static HRESULT GetListOfRootSystemClasses(CWStringArray &aListRootSystemClasses);
	static HRESULT RecursiveDeleteClassesFromNamespace(IWmiDbSession *pSession, 
														 const wchar_t *wszNamespace, 
														 CWStringArray &aListRootSystemClasses, 
														 bool bDeleteInThisNamespace);

public:
    static HRESULT GetObject(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN LPCWSTR pszObjectPath,
        IN ULONG uFlags,
        OUT IWbemClassObject **pObj
        );

    static HRESULT PutObject(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN REFIID riid,
        IN LPVOID pObj,
        IN DWORD dwFlags
        );

    static HRESULT DeleteObject(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN REFIID riid,
        IN LPVOID pObj,
        IN DWORD dwFlags
        );

    static HRESULT DeleteByPath(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN LPCWSTR pszPath,
        IN DWORD uFlags
        );

    static HRESULT ExecQuery(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN LPCWSTR pszQuery,
        IN IWbemObjectSink *pSink,
		IN LONG lFlags
        );

    static HRESULT QueryClasses(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN ULONG uFlags,                //  WBEM_FLAG_DEEP = 0,  WBEM_FLAG_SHALLOW = 1,
        IN LPCWSTR pszSuperclass,
        IN IWbemObjectSink *pSink
        );

    static HRESULT InheritsFrom(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN LPCWSTR pszSuperclass,
        IN LPCWSTR pszSubclass
        );

    static HRESULT GetRefClasses(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN LPCWSTR pszClass,
        IN BOOL bIncludeSubclasses,
        OUT CWStringArray &aClasses
        );

    static HRESULT GetInstanceRefs(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN LPCWSTR pszTargetObject,
        IN IWbemObjectSink *pSink
        );

    static HRESULT GetClassesWithRefs(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN IWbemObjectSink *pSink
        );
        // Gets all classes which have a [HasClassRefs] class qualifier

    static HRESULT BuildClassHierarchy(
        IN IWmiDbSession *pSession,
        IN  IWmiDbHandle *pNs,
        IN  LPCWSTR pBaseClassName,
        IN  LONG lFlags,
        OUT CDynasty **pDynasty           // use operator delete
        );
         // WBEM_E_NOT_FOUND has special meaning; check lFlags too

    static HRESULT FindKeyRoot(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN LPCWSTR wszClassName,
        OUT IWbemClassObject** ppKeyRootClass
        );

    static HRESULT TableScanQuery(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN LPCWSTR pszClassName,
        IN QL_LEVEL_1_RPN_EXPRESSION *pExp,
        IN DWORD dwFlags,
        IN IWbemObjectSink *pSink
        );

    // Setup, startup, init, etc.
    // ==========================

    static HRESULT InitDriver(
        IN  ULONG uFlags,
        IN  IWbemClassObject *pMappedNs,
        OUT IWmiDbController **pResultController,
        OUT IWmiDbSession **pResultRootSession,
        OUT IWmiDbHandle  **pResultVirtualRoot
        );

    static HRESULT OpenScope(
        IN  IWmiDbSession *pParentSession,      //Parent session to use to 
        IN  LPWSTR pszTargetScope,              // NS or scope
        IN  GUID *pTransGuid,                   // Transaction GUID for connection
        OUT IWmiDbController **pDriver,         // Driver
        OUT IWmiDbSession **pSession,           // Session
        OUT IWmiDbHandle  **pScope,             // Scope
        OUT IWmiDbHandle  **pNs                 // Nearest NS
        );

    static HRESULT EnsureNsSystemInstances(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN IWmiDbSession *pParentSession,
        IN IWmiDbHandle *pParentNs
        );

	static HRESULT CRepository::EnsureNsSystemRootObjects(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN IWmiDbSession *pParentSession,
        IN IWmiDbHandle *pParentNs
        );

	static HRESULT CRepository::EnsureNsSystemSecurityObjects(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN IWmiDbSession *pParentSession,
        IN IWmiDbHandle *pParentNs
        );

    static HRESULT Init();
    static HRESULT Shutdown(BOOL bIsSystemShutDown);

    static HRESULT GetDefaultSession(
        OUT IWmiDbSession **pSession
        );

    static HRESULT OpenEseNs(
        IN IWmiDbSession *pSession,
        IN  LPCWSTR pszNamespace,
        OUT IWmiDbHandle **pHandle
        );

    static HRESULT CreateEseNs(
        IN  IWmiDbSession *pSession,
        IN  LPCWSTR pszNamespace,
        OUT IWmiDbHandle **pHandle
        );

    //Get a new session from the database that can hold transactioning states and anything else
    //needed for a particular session
    static HRESULT GetNewSession(OUT IWmiDbSession **ppSession);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\coretask.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//***************************************************************************
//
//  CORETASK.CPP
//
//  raymcc  23-Apr-00       First draft for Whistler
//
//***************************************************************************

#include "precomp.h"
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <wbemcore.h>

#include <thrpool.h>

//***************************************************************************
//
//***************************************************************************

CCritSec CWmiCoreTask::m_cs;
CFlexArray CWmiCoreTask::m_aTaskList;
ULONG CWmiCoreTask::m_uNextId = 1;
ULONG CWmiCoreTask::m_uFreeId = 0;
ULONG CWmiCoreTask::m_bShutdown = FALSE;
_IWmiCoreServices *CWmiCoreTask::m_pSvc = 0;
_IWmiCallSec *CWmiCoreTask::m_pCallSec = 0;
CThreadPool *CWmiCoreTask::m_pThreadPool = 0;


//***************************************************************************
//
//***************************************************************************

HRESULT CWmiCoreTask::Startup(ULONG uFlags)
{
    HRESULT hRes;

    m_uNextId = 1;
    m_uFreeId = 0;
    m_bShutdown = FALSE;

    m_pThreadPool = new CThreadPool;

    if (NULL == m_pThreadPool)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    m_pSvc = CCoreServices::CreateInstance();
    if (!m_pSvc)
        return WBEM_E_CRITICAL_ERROR;

    hRes = m_pSvc->GetCallSec(0, &m_pCallSec);
    if (FAILED(hRes))
        return hRes;

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
// *

HRESULT CWmiCoreTask::PreventNewTasks()
{
    m_bShutdown = TRUE;
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
// *

HRESULT CWmiCoreTask::FinalCleanup()
{
    {
        CInCritSec ics(&m_cs);

	    for (int i = 0; i < m_aTaskList.Size(); i++)
	    {
	        _IWmiCoreHandle *p = (_IWmiCoreHandle *) m_aTaskList[i];
	        ReleaseIfNotNULL(p);
	    }
    }

	if ( m_pCallSec )
	{
		m_pCallSec->Release();
	}

	if ( m_pSvc )
	{
	    m_pSvc->Release();
	}

    delete m_pThreadPool;

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
// *
CWmiCoreTask::CWmiCoreTask()
{
    m_uRefCount = 0;

    // API parameters.
    // ===============

    m_uTaskType = WMICORE_TASK_NULL;
    m_pszPath1 = 0;                     // Path in user's call
    m_pPath1 = 0;                       // Parsed form
    m_pszPath2 = 0;                     // Second path in user's call
    m_pPath2 = 0;                       // Parsed form

    m_pTrasaction = 0;                   // Transaction ID
    m_uTransactionState = 0;            // Transaction state

    m_pszQueryLang = 0;                  // Query language
    m_pszQuery = 0;                      // Query text
    m_pQuery = 0;                        // Parsed query
    m_pszStrParam = 0;                   // String parameter
    m_uApiFlags = 0;                     // Copy of caller's flags

    m_pUserContext = 0;         // Copy of caller's context
    m_pCtx = 0;                 // Internal context
    m_pCallResult = 0;          // Call result from finalizer
    m_pUserSink = 0;            // Original user's sink
    m_pUserSinkEx = 0;          // Original user's sink
    m_pInboundObject = 0;       // User-supplied object (as for PutInstance)
    m_pHook = 0;                // Wrapper for callback hooks

    // Task Info.
    // ==========

    m_uTaskId = 0;                 // Read-only
    m_uTaskStatus = 0;             // WMICORE_TASK_STATUS_
    m_uStartTime = 0;              // Tick count
    m_uStopTime = 0;               // Tick count
    m_hFinalResult = 0;

    m_pszNamespace = 0;            // Namespace
    m_pszScope = 0;                // Current scope in namespace
    m_pNsPath = 0;                 // Parsed namespace
    m_pNsScopePath = 0;            // Parsed scope

    m_pOwningScope = 0;          // Current scope

    m_uClientType = 0;        // WMICORE_CLIENT_TYPE_
    m_pUser = 0;              // User info
    m_pFinalizer = 0;         // Destination
    m_pNsHandle = 0;          // Current repository ns
    m_pNsScope = 0;           // Current repository scope
    m_pProvFact = 0;          // Provider factory for ns
    m_pCallSecurity = 0;      // Caller's security context

    m_pClassTree = 0;              // Relevant class tree
    m_pSuperTask = 0;
}

//***************************************************************************
//
//***************************************************************************
// *
CWmiCoreTask::~CWmiCoreTask()
{
    delete [] m_pszPath1;
    ReleaseIfNotNULL(m_pPath1);

    delete []  m_pszPath2;
    ReleaseIfNotNULL(m_pPath2);

    delete [] m_pTrasaction;
    delete [] m_pszQueryLang;
    delete [] m_pszQuery;

    ReleaseIfNotNULL(m_pQuery);

    delete [] m_pszStrParam;

    ReleaseIfNotNULL(m_pUserContext);
    ReleaseIfNotNULL(m_pCtx);
    ReleaseIfNotNULL(m_pCallResult);
    ReleaseIfNotNULL(m_pUserSink);
    ReleaseIfNotNULL(m_pUserSinkEx);
    ReleaseIfNotNULL(m_pInboundObject);
    ReleaseIfNotNULL(m_pHook);

    delete [] m_pszNamespace;
    delete [] m_pszScope;                // Current scope in namespace

    ReleaseIfNotNULL(m_pNsPath);                 // Parsed namespace
    ReleaseIfNotNULL(m_pNsScopePath);            // Parsed scope
    ReleaseIfNotNULL(m_pOwningScope);          // Current scope

    ReleaseIfNotNULL(m_pUser);              // User info
    ReleaseIfNotNULL(m_pFinalizer);         // Destination
    ReleaseIfNotNULL(m_pNsHandle);          // Default repository access
    ReleaseIfNotNULL(m_pNsScope);
    ReleaseIfNotNULL(m_pProvFact);          // Provider factory for ns
    ReleaseIfNotNULL(m_pCallSecurity);      // Caller's security context

    ReleaseIfNotNULL(m_pSuperTask);

    delete m_pClassTree;              // Relevant class tree

    for (int i = 0; i < m_aSubTasks.Size(); i++)
    {
        _IWmiCoreHandle *p = (_IWmiCoreHandle *) m_aSubTasks[i];
        ReleaseIfNotNULL(p);
    }

    // Find this task on the main list and kill it.
    // ============================================

    //EnterCriticalSection(&m_cs);
    //LeaveCriticalSection(&m_cs);
}

//***************************************************************************
//
//***************************************************************************
// *
ULONG CWmiCoreTask::AddRef()
{
    InterlockedIncrement((LONG *) &m_uRefCount);
    return m_uRefCount;
}

//***************************************************************************
//
//***************************************************************************
// *
ULONG CWmiCoreTask::Release()
{
    ULONG uNewCount = InterlockedDecrement((LONG *) &m_uRefCount);
    if (0 != uNewCount)
        return uNewCount;
    delete this;
    return 0;
}

//***************************************************************************
//
//***************************************************************************
// *
HRESULT CWmiCoreTask::QueryInterface(
    IN REFIID riid,
    OUT LPVOID *ppvObj
    )
{
    *ppvObj = 0;

    if (IID_IUnknown==riid || IID__IWmiCoreHandle==riid)
    {
        *ppvObj = (IWbemServicesEx*)this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//***************************************************************************
//
//***************************************************************************
// *
HRESULT CWmiCoreTask::GetHandleType(
    ULONG *puType
    )
{
    *puType = WMI_HANDLE_TASK;
    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiCoreTask::CreateTask(
    IN CWmiCoreApi *pScope,
    OUT CWmiCoreTask **pNewTask
    )
{
    HRESULT hRes;

    if (pScope == 0 || pNewTask == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Clone calling context
    // ======================

    _IWmiThreadSecHandle *phThreadTok = 0;

    hRes = m_pCallSec->GetThreadSecurity(WMI_ORIGIN_RPC, &phThreadTok);
    if (FAILED(hRes))
        return hRes;

    CReleaseMe _(phThreadTok);

    // Create the task.
    // ================

    CWmiCoreTask *pNew = new CWmiCoreTask();
    if (!pNew)
        return WBEM_E_OUT_OF_MEMORY;

    pNew->AddRef();
    pNew->m_pCallSecurity = phThreadTok;
    pNew->m_pCallSecurity->AddRef();

    pNew->m_pOwningScope = pScope;
    pNew->m_pOwningScope->AddRef();

    *pNewTask = pNew;


    return WBEM_S_NO_ERROR;
}



//***************************************************************************
//
//***************************************************************************
// *
CWmiCoreTask *CWmiCoreTask::GetTaskFromId(IN ULONG uTaskId)
{   
    CInCritSec ics(&m_cs);

    for (int i = 0; i < m_aTaskList.Size(); i++)
    {
        CWmiCoreTask *p = (CWmiCoreTask *) m_aTaskList[i];
        if (p->m_uTaskId == uTaskId)
        {
            p->AddRef();            
            return p;
        }
    }

    return 0;
}

//***************************************************************************
//
//***************************************************************************
//
_IWmiCoreHandle *CWmiCoreTask::GetTaskHandleFromId(IN ULONG uTaskId)
{
    CWmiCoreTask *p = GetTaskFromId(uTaskId);
    _IWmiCoreHandle *ph = (_IWmiCoreHandle *) p;
    return ph;
}

//***************************************************************************
//
//  Statistical check.  For truly atomic check, call GetTaskList
//
//***************************************************************************
//
ULONG CWmiCoreTask::GetNumTasks()
{
    CInCritSec ics(&m_cs);
    unsigned u = m_aTaskList.Size();
    return u;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiCoreTask::GetTaskListCopy(CFlexArray **ppTaskList)
{
    CFlexArray *pNewList = new CFlexArray;
    if (!pNewList)
        return WBEM_E_OUT_OF_MEMORY;

    {
        CInCritSec ics(&m_cs);

	    for (int i = 0; i < m_aTaskList.Size(); i++)
	    {
	        CWmiCoreTask *p = (CWmiCoreTask *) m_aTaskList[i];
	        if (p->AddRef())
	        {
	            pNewList->Add(p);
	        }
	    }
    }

    *ppTaskList = pNewList;

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiCoreTask::FreeTaskListCopy(CFlexArray *pTaskList)
{
    if (pTaskList == 0)
        return WBEM_E_INVALID_PARAMETER;

    for (int i = 0; i < pTaskList->Size(); i++)
    {
        CWmiCoreTask *p = (CWmiCoreTask *) pTaskList->GetAt(i);
        p->Release();
    }

    delete pTaskList;
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiCoreTask::DumpTaskList(LPWSTR pszTextFile)
{
    return E_NOTIMPL;
}


//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::Init_OpenNamespace(
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::Init_GetObject(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::Init_GetObjectAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::Init_PutClass(
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::Init_PutClassAsync(
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::Init_DeleteClass(
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::Init_DeleteClassAsync(
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::Init_CreateClassEnum(
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::Init_CreateClassEnumAsync(
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::Init_PutInstance(
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::Init_PutInstanceAsync(
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::Init_DeleteInstance(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::Init_DeleteInstanceAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            )
{
    return 0;
}


//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::Init_CreateInstanceEnum(
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::Init_CreateInstanceEnumAsync(
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::Init_ExecQuery(
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::Init_ExecQueryAsync(
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::Init_ExecMethod(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            _IWmiFinalizer *pFnz
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::Init_ExecMethodAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            _IWmiFinalizer *pFnz
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::Init_Open(
            /* [in] */ const BSTR strScope,
            /* [in] */ const BSTR strParam,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::Init_OpenAsync(
            /* [in] */ const BSTR strScope,
            /* [in] */ const BSTR strParam,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::Init_Add(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::Init_AddAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::Init_Remove(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::Init_RemoveAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::Init_RefreshObject(
            /* [out][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pTarget,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::Init_RefreshObjectAsync(
            /* [out][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pTarget,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::Init_RenameObject(
            /* [in] */ const BSTR strOldObjectPath,
            /* [in] */ const BSTR strNewObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            )
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::Init_RenameObjectAsync(
            /* [in] */ const BSTR strOldObjectPath,
            /* [in] */ const BSTR strNewObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            )
{
    return 0;
}


//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::TaskExec_OpenNamespace()
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::TaskExec_GetObject()
{
    // Determine if the object is class or instance via parsing.

    // Do a get class task

    //
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::TaskExec_PutClass()
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::TaskExec_DeleteClass()
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::TaskExec_EnumClasses()
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::TaskExec_PutInstance()
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::TaskExec_DeleteInstance()
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::TaskExec_EnumInstances()
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::TaskExec_ExecQuery()
{
    return 0;
};


//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::TaskExec_ExecMethod()
{
    // Merge in __GET_EXT_KEYS_ONLY to locate object

    // Special case L"__SystemSecurity"

    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::TaskExec_Open()
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::TaskExec_Add()
{
    return 0;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiCoreTask::TaskExec_Remove()
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::TaskExec_RefreshObject()
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiCoreTask::TaskExec_RenameObject()
{
    return 0;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiCoreTask::DispatchTask(_IWmiCoreHandle *phTask)
{
    // Reapply security to thread after thread is determined

    // Check with Arbitrator to see if task can proceed.

    // If task cannot proceed due to quota limitations, fail now.

    // If task cannot proceed but is synchronous, wait and retry.

    // If task is asynchronous

    // Briefly check the task pool and see if any new threads are needed.

    return 0;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiCoreTask::BranchToHandler(CWmiCoreTask *pTask)
{
    HRESULT hRes;

    ULONG uBasicType = pTask->m_uTaskType & 0xFFFF;

    switch (uBasicType)
    {
        // Open namespaces, scopes, collections
        case WMICORE_TASK_OPEN:
            hRes = pTask->TaskExec_Open();
            break;
        case WMICORE_TASK_OPEN_SCOPE:
            hRes = pTask->TaskExec_OpenScope();
            break;
        case WMICORE_TASK_OPEN_NAMESPACE:
            hRes = pTask->TaskExec_OpenNamespace();
            break;
        case WMICORE_TASK_OPEN_COLLECTION:
            hRes = pTask->TaskExec_OpenCollection();
            break;

        // Get an object
        case WMICORE_TASK_GET_OBJECT:
            hRes = pTask->TaskExec_GetObject();
            break;

        // Instances
        case WMICORE_TASK_GET_INSTANCE:
            hRes = pTask->TaskExec_GetInstance();
            break;
        case WMICORE_TASK_PUT_INSTANCE:
            hRes = pTask->TaskExec_PutInstance();
            break;
        case WMICORE_TASK_DELETE_INSTANCE:
            hRes = pTask->TaskExec_DeleteInstance();
            break;
        case WMICORE_TASK_ENUM_INSTANCES:
            hRes = pTask->TaskExec_EnumInstances();
            break;

        // Classes
        case WMICORE_TASK_GET_CLASS:
            hRes = pTask->TaskExec_GetClass();
            break;
        case WMICORE_TASK_PUT_CLASS:
            hRes = pTask->TaskExec_PutClass();
            break;
        case WMICORE_TASK_DELETE_CLASS:
            hRes = pTask->TaskExec_DeleteClass();
            break;
        case WMICORE_TASK_ENUM_CLASSES:
            hRes = pTask->TaskExec_EnumClasses();
            break;

        // Methods
        case WMICORE_TASK_EXEC_METHOD:
            hRes = pTask->TaskExec_ExecMethod();
            break;

        // Collections
        case WMICORE_TASK_ADD:
            hRes = pTask->TaskExec_Add();
            break;
        case WMICORE_TASK_REMOVE:
            hRes = pTask->TaskExec_Remove();
            break;
        case WMICORE_TASK_REFRESH_OBJECT:
            hRes = pTask->TaskExec_RefreshObject();
            break;
        case WMICORE_TASK_RENAME_OBJECT:
            hRes = pTask->TaskExec_RenameObject();
            break;

        // Provider access
        case WMICORE_TASK_ATOMIC_DYN_INST_ENUM:
            hRes = pTask->TaskExec_AtomicDynInstEnum();
            break;
        case WMICORE_TASK_ATOMIC_DYN_INST_QUERY:
            hRes = pTask->TaskExec_AtomicDynInstQuery();
            break;
        case WMICORE_TASK_ATOMIC_DYN_INST_PUT:
            hRes = pTask->TaskExec_AtomicDynInstPut();
            break;

        // Bad cases.

        case WMICORE_TASK_NULL:
        default:
            return WBEM_E_INVALID_PARAMETER;
    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//
DWORD WINAPI CWmiCoreTask::ThreadEntry(LPVOID pArg)
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiCoreTask::TaskExec_AtomicDynInstGet()
{
    return 0;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiCoreTask::TaskExec_AtomicDynInstEnum()
{
    // Check Task

    // Assume the class has been idenfied as dynamic

    // Call up provider factory and get provider for class

    // Enumerate

    return 0;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiCoreTask::TaskExec_AtomicDynInstQuery()
{
    // Check Task

    // Assume class is dynamic

    // Adjust primary query for this provider

    // Create and attach sink to task

    // Hand it to provider

    return 0;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWmiCoreTask::TaskExec_GetInstance()
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWmiCoreTask::TaskExec_GetClass()
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWmiCoreTask::TaskExec_OpenScope()
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWmiCoreTask::TaskExec_OpenCollection()
{
    return 0;
}

HRESULT CWmiCoreTask::MarkTaskAsFailed(HRESULT hRes)
{
    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiCoreTask::TaskExec_AtomicDynInstPut()
{
    HRESULT hRes = 0;

    // Check Task
    // ==========

//    hRes = m_pArb->CheckTask(this);
    if (FAILED(hRes))
        return MarkTaskAsFailed(hRes);

    // Prehook.
    // ========


    // Call provider factory for class
    // ================================
    if (m_pProvFact == 0)
        return MarkTaskAsFailed(WBEM_E_INVALID_PARAMETER);

    IWbemServices *pProv = 0;

    hRes = m_pProvFact->GetInstanceProvider(
            0,                  // lFlags
            m_pUserContext,
            0,
            m_pszUserName,          // User
            m_pszLocale,            // Locale
            0,                      // IWbemPath pointer
            m_pClassDef,            // Class definition
            IID_IWbemServices,
            (LPVOID *) &pProv
            );

    if (FAILED(hRes))
        return MarkTaskAsFailed(hRes);

//    hRes = pProv->PutInstance();

    if (FAILED(hRes))
        return MarkTaskAsFailed(hRes);

    return WBEM_S_NO_ERROR;
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\coretask.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//***************************************************************************
//
//  CORETASK.H
//
//  raymcc  23-Apr-00       First draft for Whistler
//
//***************************************************************************

#ifndef _CORETASK_H_
#define _CORETASK_H_

class CWmiCoreApi;
class CThreadPool;


typedef enum
{
    WMICORE_CLIENT_TYPE_SYSTEM = 1,
    WMICORE_CLIENT_TYPE_PROVIDER,
    WMICORE_CLIENT_TYPE_REMOTE,
    WMICORE_CLIENT_TYPE_LOCAL,
    WMICORE_CLIENT_TYPE_INPROC,
    WMICORE_CLIENT_TYPE_USER

}   WMICORE_CLIENT_TYPE;



class CWmiCoreTask : public _IWmiCoreHandle
{
    // this == _IWmiCoreHandle
    // =======================

    ULONG        m_uRefCount;                    // COM ref count

    // API parameters.
    // ===============

    ULONG        m_uTaskType;                    // WMICORE_TASK_TYPE

    LPWSTR       m_pszPath1;                     // Path in user's call
    IWbemPath   *m_pPath1;                       // Parsed form
    LPWSTR       m_pszPath2;                     // Second path in user's call
    IWbemPath   *m_pPath2;                       // Parsed form

    GUID        *m_pTrasaction;                   // Transaction ID
    ULONG        m_uTransactionState;            // Transaction state

    LPWSTR      m_pszQueryLang;                  // Query language
    LPWSTR      m_pszQuery;                      // Query text
    IWbemQuery *m_pQuery;                        // Parsed query
    LPWSTR      m_pszStrParam;                   // String parameter
    ULONG       m_uApiFlags;                     // Copy of caller's flags

    IWbemContext        *m_pUserContext;         // Copy of caller's context
    _IWmiContext        *m_pCtx;                 // Internal context
    IWbemCallResult     *m_pCallResult;          // Call result from finalizer
    IWbemObjectSink     *m_pUserSink;            // Original user's sink
    IWbemObjectSinkEx   *m_pUserSinkEx;          // Original user's sink
    IWbemClassObject    *m_pInboundObject;       // User-supplied object (as for PutInstance)
    _IWmiCoreWriteHook  *m_pHook;                // Hook wrapper

    // Task Info.
    // ==========

    ULONG            m_uTaskId;                 // Read-only
    ULONG            m_uTaskStatus;             // WMICORE_TASK_STATUS_
    ULONG            m_uStartTime;              // Tick count
    ULONG            m_uStopTime;               // Tick count
    HRESULT          m_hFinalResult;            // HRESULT for user
    _IWmiObject     *m_pClassDef;               // Class associated with simple requests
    LPWSTR           m_pszNamespace;            // Namespace
    LPWSTR           m_pszScope;                // Current scope in namespace
    IWbemPath       *m_pNsPath;                 // Parsed namespace
    IWbemPath       *m_pNsScopePath;            // Parsed scope

    CWmiCoreApi     *m_pOwningScope;            // Current scope

    ULONG                 m_uClientType;        // WMICORE_CLIENT_TYPE_
    _IWmiUserHandle      *m_pUser;              // User info
    LPWSTR                m_pszUserName;        // User name
    LPWSTR                m_pszLocale;          // Locale
    _IWmiFinalizer       *m_pFinalizer;         // Destination
    IWmiDbHandle         *m_pNsHandle;          // Default repository access
    IWmiDbHandle         *m_pNsScope;           // Current scope in NS
    _IWmiProviderFactory *m_pProvFact;          // Provider factory for ns
    _IWmiThreadSecHandle *m_pCallSecurity;      // Caller's security context
    _IWmiArbitrator      *m_pArb;               // Arbitrator

    CDynasty        *m_pClassTree;              // Relevant class tree
    CFlexArray       m_aSubTasks;               // Subtask list
    CWmiCoreTask    *m_pSupervisingTask;        // If this task is dependent
    CWmiCoreTask    *m_pSuperTask;              // Supertask

    IWbemServicesEx *m_pProvider;               // Provider pointer

    ///////////////////////

    CWmiCoreTask();
   ~CWmiCoreTask();


    static CCritSec m_cs;
    static CFlexArray m_aTaskList;

    static ULONG m_uNextId;  // For ID reuse control
    static ULONG m_uFreeId;
    static ULONG m_bShutdown;
    static _IWmiCoreServices *m_pSvc;
    static _IWmiCallSec *m_pCallSec;
    static CThreadPool  *m_pThreadPool;

    ULONG AssignNewTaskId();

public:
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    HRESULT STDMETHODCALLTYPE QueryInterface(
        IN REFIID riid,
        OUT LPVOID *ppvObj
        );

    HRESULT STDMETHODCALLTYPE GetHandleType(ULONG *puType);

    //////////////////////////////////////////////////////////////////


    static HRESULT CreateTask(
        IN  CWmiCoreApi  *pCallingScope,
        OUT CWmiCoreTask **pNewTask
        );

    static HRESULT DispatchTask(_IWmiCoreHandle *phTask);
    static HRESULT BranchToHandler(CWmiCoreTask *pTask);

    static DWORD WINAPI ThreadEntry(LPVOID pArg);

    ULONG GetTaskId() { return m_uTaskId; }

    static HRESULT Startup(ULONG uFlags);
    static HRESULT PreventNewTasks();
    static HRESULT FinalCleanup();

    HRESULT MarkTaskAsFailed(HRESULT);

    static CWmiCoreTask *GetTaskFromHandle(IN _IWmiCoreHandle *phTask)
    {
        phTask->AddRef();
        return (CWmiCoreTask *) phTask;
    }

    static ULONG GetTaskIdFromHandle(IN _IWmiCoreHandle *phTask)
    {
        return ((CWmiCoreTask *) phTask)->m_uTaskId;
    }

    static _IWmiCoreHandle *GetHandleFromTask(CWmiCoreTask *pTask)
    {
        pTask->AddRef();
        return (_IWmiCoreHandle *) pTask;
    }

    static CWmiCoreTask *GetTaskFromId(IN ULONG uTaskId);
    static _IWmiCoreHandle *GetTaskHandleFromId(IN ULONG uTaskId);

    // Debugging, diagnostic.

    static ULONG   GetNumTasks();
    static HRESULT GetTaskListCopy(CFlexArray **ppTaskList);
    static HRESULT FreeTaskListCopy(CFlexArray *pTaskList);
    static HRESULT DumpTaskList(LPWSTR pszTextFile);


    //////////////////////////////////////////////////////////////////
    //
    // Task Initializers


    HRESULT Init_OpenNamespace(
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            );

    HRESULT Init_GetObject(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            );

    HRESULT Init_GetObjectAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            );

    HRESULT Init_PutClass(
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            );

    HRESULT Init_PutClassAsync(
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            );

    HRESULT Init_DeleteClass(
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            );

    HRESULT Init_DeleteClassAsync(
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            );

    HRESULT Init_CreateClassEnum(
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            );

    HRESULT Init_CreateClassEnumAsync(
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            );

    HRESULT Init_PutInstance(
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            );

    HRESULT Init_PutInstanceAsync(
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            );

    HRESULT Init_DeleteInstance(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            );

    HRESULT Init_DeleteInstanceAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            );

    HRESULT Init_CreateInstanceEnum(
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            );

    HRESULT Init_CreateInstanceEnumAsync(
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            );

    HRESULT Init_ExecQuery(
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            );

    HRESULT Init_ExecQueryAsync(
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            );

    HRESULT Init_ExecMethod(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            _IWmiFinalizer *pFnz
            );

    HRESULT Init_ExecMethodAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            _IWmiFinalizer *pFnz
            );

    // IWbemServicesEx

    HRESULT Init_Open(
            /* [in] */ const BSTR strScope,
            /* [in] */ const BSTR strParam,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            );

    HRESULT Init_OpenAsync(
            /* [in] */ const BSTR strScope,
            /* [in] */ const BSTR strParam,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            );

    HRESULT Init_Add(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            );

    HRESULT Init_AddAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            );

    HRESULT Init_Remove(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            );

    HRESULT Init_RemoveAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            );

    HRESULT Init_RefreshObject(
            /* [out][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pTarget,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            );

    HRESULT Init_RefreshObjectAsync(
            /* [out][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pTarget,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            );

    HRESULT Init_RenameObject(
            /* [in] */ const BSTR strOldObjectPath,
            /* [in] */ const BSTR strNewObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            );

    HRESULT Init_RenameObjectAsync(
            /* [in] */ const BSTR strOldObjectPath,
            /* [in] */ const BSTR strNewObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            _IWmiFinalizer *pFnz
            );

    //////////////////////////////////////////////////////////////////
    //
    // Task Executors

    HRESULT TaskExec_GetObject();
    HRESULT TaskExec_PutClass();
    HRESULT TaskExec_DeleteClass();
    HRESULT TaskExec_EnumClasses();
    HRESULT TaskExec_PutInstance();
    HRESULT TaskExec_DeleteInstance();
    HRESULT TaskExec_EnumInstances();
    HRESULT TaskExec_ExecQuery();
    HRESULT TaskExec_ExecMethod();
    HRESULT TaskExec_Open();
    HRESULT TaskExec_Add();
    HRESULT TaskExec_Remove();
    HRESULT TaskExec_RefreshObject();
    HRESULT TaskExec_RenameObject();

    HRESULT TaskExec_GetInstance();
    HRESULT TaskExec_GetClass();
    HRESULT TaskExec_OpenScope();
    HRESULT TaskExec_OpenNamespace();
    HRESULT TaskExec_OpenCollection();

    HRESULT TaskExec_BuildDynasty();

    // Separately schedulable atomic tasks
    HRESULT TaskExec_AtomicRepositoryQuery();

    HRESULT TaskExec_AtomicDynInstGet();
    HRESULT TaskExec_AtomicDynInstEnum();
    HRESULT TaskExec_AtomicDynInstQuery();
    HRESULT TaskExec_AtomicDynInstPut();
    HRESULT TaskExec_AtomicDynInstDelete();

    HRESULT TaskExec_AtomicDynClassEnum();
    HRESULT TaskExec_AtomicDynClassQuery();
    HRESULT TaskExec_AtomicDynClassGet();
    HRESULT TaskExec_AtomicDynClassPut();
    HRESULT TaskExec_AtomicDynClassDelete();
};



#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\exportv5.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    EXPORTV5.CPP

Abstract:

    Exporting

History:

--*/

#include "precomp.h"
#ifdef _MMF

#include "corepol.h"
#include "Export.h"

void CRepExporterV5::DumpMMFHeader()
{
    MMF_ARENA_HEADER *pMMFHeader = m_pDbArena->GetMMFHeader();
    DumpRootBlock(Fixup((DBROOT*)pMMFHeader->m_dwRootBlock));

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\exportv1.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    EXPORTV1.CPP

Abstract:

    Exporting

History:

--*/

#include "precomp.h"
#ifdef _MMF
#include "corepol.h"
#include "Export.h"

struct DBROOT;

void CRepExporterV1::DumpMMFHeader()
{
#if !defined(_MMF)
    DWORD *pdwArena = (DWORD*) Fixup(0);
    DBROOT* pRootBlock = (DBROOT*)pdwArena[9];

    DumpRootBlock(Fixup(pRootBlock));
#endif
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\export.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    EXPORT.H

Abstract:

    Exporting

History:

--*/
#ifdef _MMF
#ifndef __export_h__
#define __export_h__

/*================================================================================
 *
 * EXPORT FILE FORMAT
 * ==================
 *
 * File Header Block:
 *		wchar_t wszFileHeader								= REP_EXPORT_FILE_START_TAG ("repexp2")
 *
 * Namespace Block:
 *		DWORD   dwObjectType								= REP_EXPORT_NAMESPACE_TAG (0x00000001)
 *		DWORD   dwNamespaceNameSize
 *		wchar_t wszNamespaceName[dwNamespaceNameSize]		= Full namespace name
 *															  (\root\default\fred)
 *
 * Class Block:
 *		DWORD   dwObjectType								= REP_EXPORT_CLASS_TAG (0x00000002)
 *		DWORD   dwClassNameSize
 *		wchar_t wszClassName[dwClassNameSize]				= Class name (my_class_name)
 *		DWORD   dwClassObjectSize
 *		DWORD	adwClassObject[dwClassObjectSize]
 *
 * Instance Block - key of type int:
 *		DWORD   dwObjectType								= REP_EXPORT_INST_INT_TAG (0x00000003)
 *		DWORD   dwInstanceKey
 *		DWORD	dwInstanceObjectSize
 *		DWORD	adwInstanceObject[dwInstanceObjectSize]
 *
 * Instance Block - key of type string
 *		DWORD	dwObjectType								= REP_EXPORT_INST_STR_TAG (0x00000004)
 *		DWORD	dwInstanceKeySize
 *		DWORD	dwInstanceKey[dwInstanceKeySize]			= Instance key (MyKeyValue)
 *		DWORD	dwInstanceObjectSize
 *		DWORD	adwInstanceObject[dwInstanceObjectSize]
 *		
 * End of class block
 *		DWORD	dwObjectType								= REP_EXPORT_CLASS_END_TAG (0x00000005)
 *		DWORD	dwEndOfBlockSize							= REP_EXPORT_END_TAG_SIZE (0x00000010)
 *		DWORD	adwEndOfBlock[dwEndOfBlockSize]				= REP_EXPORT_END_TAG_MARKER * 16
 *															  (0xFF, 0xFF, 0xFF, 0xFF,
 *															   0xFF, 0xFF, 0xFF, 0xFF,
 *															   0xFF, 0xFF, 0xFF, 0xFF,
 *															   0xFF, 0xFF, 0xFF, 0xFF)
 *
 * End of namespace block
 *		DWORD	dwObjectType								= REP_EXPORT_NAMESPACE_END_TAG (0x00000006)
 *		DWORD	dwEndOfBlockSize							= REP_EXPORT_END_TAG_SIZE (0x00000010)
 *		DWORD	adwEndOfBlock[dwEndOfBlockSize]				= REP_EXPORT_END_TAG_MARKER * 16
 *															  (0xFF, 0xFF, 0xFF, 0xFF,
 *															   0xFF, 0xFF, 0xFF, 0xFF,
 *															   0xFF, 0xFF, 0xFF, 0xFF,
 *															   0xFF, 0xFF, 0xFF, 0xFF)
 *
 * Namespace security block
 *		DWORD	dwObjectType								= REP_EXPORT_NAMESPACE_SEC_TAG (0x00000007)
 *		DWORD	dwSecurityBlobSize
 *		DWORD	dwSecurityBlob[dwSecurityBlobSize]			= Security blob
 *		
 * End of file block
 *		DWORD	dwObjectType								= REP_EXPORT_FILE_END_TAG (0xFFFFFFFF)
 *		DWORD	dwEndOfBlockSize							= REP_EXPORT_END_TAG_SIZE (0x00000010)
 *		DWORD	adwEndOfBlock[dwEndOfBlockSize]				= REP_EXPORT_END_TAG_MARKER * 16
 *															  (0xFF, 0xFF, 0xFF, 0xFF,
 *															   0xFF, 0xFF, 0xFF, 0xFF,
 *															   0xFF, 0xFF, 0xFF, 0xFF,
 *															   0xFF, 0xFF, 0xFF, 0xFF)
 *
 * Ordering:
 *		File Header Block
 *			(one or more)
 *			Namespace Block
 *              Namespace security block
 *				(zero or more)
 *				{
 *					Namespace Block
 *	                  Namespace security block
 *						etc...
 *					End namespace block
 *					(or)
 *					Class Block
 *						(zero or more)
 *						{
 *							Instance Block
 *							(or)
 *							Class Block
 *								etc...
 *							End class block
 *						}
 *					End class block
 *				}
 *			End namespace block
 *		End of file block
 *
 *================================================================================
 */


#define FAILURE_DIRTY 1
#define FAILURE_WRITE 2

#define REP_EXPORT_FILE_START_TAG	 "repexp3"
#define REP_EXPORT_NAMESPACE_TAG	 0x00000001
#define REP_EXPORT_CLASS_TAG		 0x00000002
#define REP_EXPORT_INST_INT_TAG		 0x00000003
#define REP_EXPORT_INST_STR_TAG		 0x00000004
#define REP_EXPORT_CLASS_END_TAG	 0x00000005
#define REP_EXPORT_NAMESPACE_END_TAG 0x00000006
#define REP_EXPORT_NAMESPACE_SEC_TAG 0x00000007
#define REP_EXPORT_FILE_END_TAG		 0xFFFFFFFF

#define REP_EXPORT_END_TAG_SIZE		 0x00000010
#define REP_EXPORT_END_TAG_MARKER	 0xFF

#include "MMFArena2.h"

class CDbAvlTree;
struct DBROOT;
struct NSREP;
struct INSTDEF;
struct CLASSDEF;
struct AVLNode;
struct RepCollection;

class CRepExporter
{
protected:
	CMMFArena2 *m_pDbArena;
	HANDLE g_hFile;

	virtual void DumpInstanceString(INSTDEF* pInstDef, const wchar_t *wszKey, const wchar_t *pszClass);
	virtual void DumpInstanceInt(INSTDEF* pInstDef, INT_PTR nKey, const wchar_t *pszClass);
	virtual void IterateKeyTree(const wchar_t *wszClassName, CLASSDEF *pOwningClass, AVLNode *pInstNode, BOOL bStringKey);
	virtual void DumpClass(CLASSDEF* pClassDef, const wchar_t *wszClassName);
	virtual void IterateClassNodes(AVLNode *pClassNode, CLASSDEF *poParentClass);
	virtual void IterateChildNamespaceTree(AVLNode *pNsNode);
	virtual void IterateChildNamespaces(RepCollection *childNamespaces);
	virtual void DumpNamespace(NSREP *pNsRep);
	virtual void DumpNamespaceSecurity(NSREP *pNsRep);
	virtual void DumpRootBlock(DBROOT *pRootBlock);
	virtual void DumpMMFHeader();

	virtual DWORD GetMMFBlockOverhead() = 0;
	virtual int GetAvlTreeNodeType(CDbAvlTree *pTree) = 0;

public:
	virtual int Export(CMMFArena2 *pDbArena, const TCHAR *pszFilename);
	CRepExporter(){}
	virtual ~CRepExporter() {};
};

class  CRepExporterV1 : public CRepExporter
{
protected:
	//This is different from the standard base-class definition!
	DWORD GetMMFBlockOverhead() { return sizeof(MMF_BLOCK_HEADER); }
	virtual int GetAvlTreeNodeType(CDbAvlTree *pTree) { return ((int*)pTree)[1]; }
	void DumpMMFHeader();
};

class  CRepExporterV5 : public CRepExporterV1
{
protected:
	//This works in the same way as the standard base-class definition!
	virtual DWORD GetMMFBlockOverhead() { return (sizeof(MMF_BLOCK_HEADER) + sizeof(MMF_BLOCK_TRAILER)); }
	void DumpMMFHeader();
};

class  CRepExporterV7 : public CRepExporterV5
{
protected:
	//This is different from the standard base-class definition!
	int GetAvlTreeNodeType(CDbAvlTree *pTree) { return ((int*)pTree)[3]; }
};

class  CRepExporterV9 : public CRepExporterV7
{
protected:
	void DumpNamespaceSecurity(NSREP *pNsRep);
};
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\exportv7.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    EXPORTV7.CPP

Abstract:

    Exporting

History:

--*/

#include "precomp.h"

//There is nothing different here from the base class.  All changes are in-line to the class definition!
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\event.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    EVENT.H

Abstract:

	C++ wrapper for NT events.

	Classes defined:

	CEvent

History:

	23-Jul-96   a-raymcc    Created.
	3/10/97     a-levn      Fully documented

--*/

#ifndef _EVENT_H_
#define _EVENT_H_

//******************************************************************************
//******************************************************************************
//
//  class CEvent
//
//  This class is a thin wrapper around NT events.
//
//******************************************************************************
//
//  Constructor
//
//  Creates an unnamed, unsecured, non-signaled, automatic-reset event.
//
//******************************************************************************
//
//  Destructor
//
//  Deletes the event
//
//******************************************************************************
//
//  SetDWORD
//
//  Associates a DWORD with this object.
//
//  Parameters:
//
//      DWORD dwVal
//
//******************************************************************************
//
//  GetDWORD
//
//  Retrieves the associated DWORD (See SetDWORD)
//
//  Returns:
//
//      DWORD: set with SetDWORD
//
//******************************************************************************
//
//  SetPtr
//
//  Associates a void pointer with this object.
//
//  Parameters:
//
//      LPVOID pVal The pointer to store
//
//******************************************************************************
//
//  GetPtr
//
//  Retrieves the associated pointer (see SetPtr)
//
//  Returns:
//
//      LPVOID: set with SetPtr.
//
//******************************************************************************
//
//  Signal
//
//  Signals the NT event. This will release a single thread waiting on this
//  event after which the event will go back to non-signaled.
//
//******************************************************************************
//
//  Block
//
//  Wait for this event to become signaled or for a timeout to occur. Uses
//  CExecQueue waiting function (see execq.h).
//
//  Parameters:
//
//      DWORD dwTimeout     Timeout in milliseconds
//
//  Returns:
//
//      Same return codes as WaitForSingleObject:
//          WAIT_OBJECT_0:  event was signaled
//          WAIT_TIMEOUT:   timed out.
//
//******************************************************************************
class CEvent
{
    HANDLE m_hEvent;
    LPVOID m_pData;
    DWORD  m_dwData;

public:
    CEvent()
        { m_hEvent = CreateEvent(0,0,0,0); }

   ~CEvent() { CloseHandle(m_hEvent); }

    DWORD GetDWORD() { return m_dwData; }
    void SetDWORD(DWORD dwVal)  { m_dwData = dwVal; }
    LPVOID GetPtr() { return m_pData; }
    void SetPtr(LPVOID pVal) { m_pData = pVal; }
    void Signal() { SetEvent(m_hEvent); }
    DWORD Block(DWORD dwTime)
        { return CCoreQueue::QueueWaitForSingleObject(m_hEvent, dwTime); }
};

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\export.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    EXPORT.CPP

Abstract:

    Exporting

History:

--*/

#include "precomp.h"
#ifdef _MMF
#include "Time.h"
#include "WbemCli.h"
#include "DbRep.h"
#include "Export.h"
#include "WbemUtil.h"


void CRepExporter::DumpInstanceString(INSTDEF* pInstDef, const wchar_t *wszKey, const wchar_t *pszClass)
{
    if (wszKey)
    {
        //Dump an instance block header
        DWORD dwSize = 0;
        DWORD adwBuffer[2];
        adwBuffer[0] = REP_EXPORT_INST_STR_TAG;
        adwBuffer[1] = (wcslen(wszKey) + 1) * sizeof (wchar_t);
        if ((WriteFile(g_hFile, adwBuffer, 8, &dwSize, NULL) == 0) || (dwSize != 8))
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to write instance %S for class %S header.\n", wszKey, pszClass));
            throw FAILURE_WRITE;
        }
        if ((WriteFile(g_hFile, wszKey, (wcslen(wszKey) + 1) * sizeof (wchar_t), &dwSize, NULL) == 0) || (dwSize != (wcslen(wszKey) + 1) * sizeof (wchar_t)))
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to write instance %S for class %S.\n", wszKey, pszClass));
            throw FAILURE_WRITE;
        }
    }

    {
        //Dump the block
        DWORD dwSize = 0;
        DWORD *pdwObjectStream = Fixup((DWORD*)pInstDef->m_poObjectStream);
        DWORD dwCurSize = *(pdwObjectStream - 1);
        dwCurSize -= GetMMFBlockOverhead();
        if ((WriteFile(g_hFile, &dwCurSize, 4, &dwSize, NULL) == 0) || (dwSize != 4))
        {
            if (wszKey)
            {
                DEBUGTRACE((LOG_WBEMCORE, "Failed to write data header of instance %S for class %S.\n", wszKey, pszClass));
            }
            else
            {
                DEBUGTRACE((LOG_WBEMCORE, "Failed to write data header of class definition for class %S.\n", pszClass));
            }
            throw FAILURE_WRITE;
        }
        if ((WriteFile(g_hFile, pdwObjectStream, dwCurSize, &dwSize, NULL) == 0) || (dwSize != dwCurSize))
        {
            if (wszKey)
            {
                DEBUGTRACE((LOG_WBEMCORE, "Failed to write instance %S for class %S.\n", wszKey, pszClass));
            }
            else
            {
                DEBUGTRACE((LOG_WBEMCORE, "Failed to write class definition for class %S.\n", pszClass));
            }
            throw FAILURE_WRITE;
        }
    }
}
void CRepExporter::DumpInstanceInt(INSTDEF* pInstDef, INT_PTR nKey, const wchar_t *pszClass)
{
    {
        //Dump an instance block header
        DWORD dwSize = 0;
        DWORD dwBuffer;
        dwBuffer = REP_EXPORT_INST_INT_TAG;
        if ((WriteFile(g_hFile, &dwBuffer, 4, &dwSize, NULL) == 0) || (dwSize != 8))
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to write instance %d for class %S object and header.\n", nKey, pszClass));
            throw FAILURE_WRITE;
        }
        if ((WriteFile(g_hFile, &nKey, sizeof(INT_PTR), &dwSize, NULL) == 0) || (dwSize != 8))
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to write instance %d for class %S object and header.\n", nKey, pszClass));
            throw FAILURE_WRITE;
        }
    }
    {
        //Dump the block
        DWORD dwSize = 0;
        DWORD *pObjectStream = Fixup((DWORD*)pInstDef->m_poObjectStream);
        DWORD dwCurSize = *(pObjectStream - 1);
        dwCurSize -= GetMMFBlockOverhead();
        if ((WriteFile(g_hFile, &dwCurSize, 4, &dwSize, NULL) == 0) || (dwSize != 4))
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to write data header of instance %%d for class %S.\n", nKey, pszClass));
            throw FAILURE_WRITE;
        }
        if ((WriteFile(g_hFile, pObjectStream, dwCurSize, &dwSize, NULL) == 0) || (dwSize != dwCurSize))
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to write instance %d for class %S.\n", nKey, pszClass));
            throw FAILURE_WRITE;
        }
    }
}
void CRepExporter::IterateKeyTree(const wchar_t *wszClassName, CLASSDEF *pOwningClass, AVLNode *pInstNode, BOOL bStringKey)
{
    if (pInstNode->poLeft)
    {
        IterateKeyTree(wszClassName, pOwningClass, Fixup(pInstNode->poLeft), bStringKey);
    }

    //If this is a top-level class then we dump the class, otherwise the class dump will get child classes...
    INSTDEF *pInstDef = Fixup((INSTDEF*)pInstNode->poData);
    if (Fixup(pInstDef->m_poOwningClass) == pOwningClass)
    {
        if (bStringKey)
            DumpInstanceString(pInstDef, Fixup((wchar_t*)pInstNode->nKey), wszClassName);
        else
            DumpInstanceInt(pInstDef, pInstNode->nKey, wszClassName);
    }

    if (pInstNode->poRight)
    {
        IterateKeyTree(wszClassName, pOwningClass, Fixup(pInstNode->poRight), bStringKey);
    }
}

void CRepExporter::DumpClass(CLASSDEF* pClassDef, const wchar_t *wszClassName)
{
    DWORD dwSize = 0;
    DWORD adwBuffer[6];
    adwBuffer[0] = REP_EXPORT_CLASS_TAG;
    adwBuffer[1] = (wcslen(wszClassName) + 1) * sizeof (wchar_t);
    if ((WriteFile(g_hFile, adwBuffer, 8, &dwSize, NULL) == 0) || (dwSize != 8))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write clas %S header.\n", wszClassName));
        throw FAILURE_WRITE;
    }
    if ((WriteFile(g_hFile, wszClassName, (wcslen(wszClassName) + 1) * sizeof (wchar_t), &dwSize, NULL) == 0) || (dwSize != (wcslen(wszClassName) + 1) * sizeof (wchar_t)))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write clas %S class name.\n", wszClassName));
        throw FAILURE_WRITE;
    }

    DumpInstanceString(Fixup(pClassDef->m_poClassDef), NULL, wszClassName);

    //Dump the children classes...
    AVLNode *pTreeNode = Fixup((AVLNode*)(((DWORD*)Fixup(Fixup(pClassDef->m_poOwningNs)->m_poClassTree))[0]));
    IterateClassNodes(pTreeNode, Fixdown(pClassDef));

    //Special cases!  We do not dump instances for the following classes...
    if ((_wcsicmp(wszClassName, L"__CIMOMIdentification") != 0))
    {
        //If we own the key tree, then we need to iterate through this...
        if (pClassDef->m_poKeyTree)
        {
            DWORD_PTR dwTreeNode = (((DWORD*)Fixup(pClassDef->m_poKeyTree))[0]);
            if (dwTreeNode)
            {
                AVLNode *pTreeNode = Fixup((AVLNode*)dwTreeNode);
                int keyType = GetAvlTreeNodeType(Fixup(pClassDef->m_poKeyTree));
                IterateKeyTree(wszClassName, pClassDef, pTreeNode, (keyType == 0x1f));
            }

        }
    }
    adwBuffer[0] = REP_EXPORT_CLASS_END_TAG;
    adwBuffer[1] = REP_EXPORT_END_TAG_SIZE;
    memset(&(adwBuffer[2]), REP_EXPORT_END_TAG_MARKER, REP_EXPORT_END_TAG_SIZE);
    if ((WriteFile(g_hFile, adwBuffer, 24, &dwSize, NULL) == 0) || (dwSize != 24))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write class %S end marker.\n", wszClassName));
        throw FAILURE_WRITE;
    }
}

void CRepExporter::IterateClassNodes(AVLNode *pClassNode, CLASSDEF *poParentClass)
{
    if (pClassNode->poLeft)
    {
        IterateClassNodes(Fixup((AVLNode *)pClassNode->poLeft), poParentClass);
    }

    //If this is a top-level class then we dump the class, otherwise the class dump will get child classes...
    CLASSDEF *pClassDef = Fixup((CLASSDEF*)pClassNode->poData);
    if (pClassDef->m_poSuperclass == poParentClass)
    {
        DumpClass(pClassDef, Fixup((wchar_t*)pClassNode->nKey));
    }

    if (pClassNode->poRight)
    {
        IterateClassNodes(Fixup((AVLNode *)pClassNode->poRight), poParentClass);
    }
}
void CRepExporter::IterateChildNamespaceTree(AVLNode *pNsNode)
{
    if (pNsNode->poLeft)
    {
        IterateChildNamespaceTree(Fixup((AVLNode *)pNsNode->poLeft));
    }

    //If this is a top-level class then we dump the class, otherwise the class dump will get child classes...
    NSREP *pNsDef = Fixup((NSREP*)pNsNode->poData);
    DumpNamespace(pNsDef);

    if (pNsNode->poRight)
    {
        IterateChildNamespaceTree(Fixup((AVLNode *)pNsNode->poRight));
    }
}

void CRepExporter::IterateChildNamespaces(RepCollection *childNamespaces)
{
    DWORD dwType;
    DWORD dwSize;
    DWORD_PTR dwItems;

    dwType = ((DWORD*)childNamespaces)[0];
    dwSize = ((DWORD*)childNamespaces)[1];
    dwItems = ((DWORD*)childNamespaces)[2];

    if ((dwType == 0) || (dwSize == 0))
        return;
    else if (dwType == 1)
    {
        //This is a pointer to a RepCollectionItem!
        RepCollectionItem *pRepCollectionItem = Fixup((RepCollectionItem*)dwItems);
        DumpNamespace(Fixup((NSREP*)pRepCollectionItem->poItem));
    }
    else if (dwType == 2)
    {
        CDbArray *pDbArray = Fixup((CDbArray*)dwItems);
        RepCollectionItem** apNsRepItem;
        apNsRepItem = Fixup((RepCollectionItem**)(((DWORD*)pDbArray)[3]));
        for (DWORD i = 0; i != dwSize; i++)
        {
            DumpNamespace(Fixup((NSREP*)(Fixup(apNsRepItem[i])->poItem)));
        }
    }
    else if (dwType == 3)
    {
        //This is a tree
        AVLNode *pTreeNode = Fixup((AVLNode*)(((DWORD*)Fixup(dwItems))[0]));
        IterateChildNamespaceTree(pTreeNode);
    }
    else
    {
        //this is a bug!
    }
}

void CRepExporter::DumpNamespace(NSREP *pNsRep)
{
    wchar_t *pszCurNs = Fixup(pNsRep->m_poName);

    DWORD dwSize = 0;
    DWORD dwBuffer[6];
    dwBuffer[0] = REP_EXPORT_NAMESPACE_TAG;
    dwBuffer[1] = (wcslen(pszCurNs) + 1) * sizeof(wchar_t);

    if ((WriteFile(g_hFile, dwBuffer, 8, &dwSize, NULL) == 0) || (dwSize != 8))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write namespace %S header.\n", pszCurNs));
        throw FAILURE_WRITE;
    }
    if ((WriteFile(g_hFile, pszCurNs, (wcslen(pszCurNs) + 1) * sizeof(wchar_t), &dwSize, NULL) == 0) || (dwSize != (wcslen(pszCurNs) + 1) * sizeof(wchar_t)))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write namespace %S.\n", pszCurNs));
        throw FAILURE_WRITE;
    }

    DumpNamespaceSecurity(pNsRep);

    AVLNode *pTreeNode = Fixup((AVLNode*)(((DWORD*)Fixup(pNsRep->m_poClassTree))[0]));

    IterateClassNodes(pTreeNode, 0);

    IterateChildNamespaces(Fixup(pNsRep->m_poNamespaces));

    dwBuffer[0] = REP_EXPORT_NAMESPACE_END_TAG;
    dwBuffer[1] = REP_EXPORT_END_TAG_SIZE;
    memset(&(dwBuffer[2]), REP_EXPORT_END_TAG_MARKER, REP_EXPORT_END_TAG_SIZE);
    if ((WriteFile(g_hFile, dwBuffer, 24, &dwSize, NULL) == 0) || (dwSize != 24))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write namespace %S end marker.\n", pszCurNs));
        throw FAILURE_WRITE;
    }
}

void CRepExporter::DumpNamespaceSecurity(NSREP *pNsRep)
{
    //Default version does not have a security descriptor, so we need to
    //just dump a blank entry.
    DWORD dwSize = 0;
    DWORD dwBuffer[2];
    dwBuffer[0] = REP_EXPORT_NAMESPACE_SEC_TAG;
    dwBuffer[1] = dwSize;

    if ((WriteFile(g_hFile, dwBuffer, 8, &dwSize, NULL) == 0) || (dwSize != 8))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write namespace security, %S.\n", Fixup(pNsRep->m_poName)));
        throw FAILURE_WRITE;
    }
}

void CRepExporter::DumpRootBlock(DBROOT *pRootBlock)
{
    if (pRootBlock->m_dwFlags & DB_ROOT_INUSE)
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write file header block.\n"));
        throw FAILURE_DIRTY;
    }
    char *pBuffer = REP_EXPORT_FILE_START_TAG;
    DWORD dwSizeBuffer = strlen(pBuffer);
    DWORD dwSize = 0;

    if ((WriteFile(g_hFile, pBuffer, dwSizeBuffer, &dwSize, NULL) == 0) || (dwSize != dwSizeBuffer))
    {
        throw(FAILURE_WRITE);
    }
    DumpNamespace(Fixup((NSREP*)pRootBlock->m_poRootNs));

    DWORD dwBuffer[6];
    dwBuffer[0] = REP_EXPORT_FILE_END_TAG;
    dwBuffer[1] = REP_EXPORT_END_TAG_SIZE;
    memset(&(dwBuffer[2]), REP_EXPORT_END_TAG_MARKER, REP_EXPORT_END_TAG_SIZE);
    if ((WriteFile(g_hFile, dwBuffer, 24, &dwSize, NULL) == 0) || (dwSize != 24))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write file trailer block.\n"));
        throw FAILURE_WRITE;
    }

}

void CRepExporter::DumpMMFHeader()
{
    MMF_ARENA_HEADER *pMMFHeader = m_pDbArena->GetMMFHeader();
    DumpRootBlock(Fixup((DBROOT*)pMMFHeader->m_dwRootBlock));

}

int CRepExporter::Export(CMMFArena2 *pDbArena, const TCHAR *pszFilename)
{
    DWORD dwVersion = NULL;
    HMODULE hModule = NULL;
    const char *pszDllName = NULL;
    int nRet = 0;

    m_pDbArena = pDbArena;

    g_hFile = CreateFile(pszFilename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (g_hFile != INVALID_HANDLE_VALUE)
    {
        try
        {
            DumpMMFHeader();
            CloseHandle(g_hFile);
        }
        catch (int dProblem)
        {
            switch(dProblem)
            {
            case FAILURE_DIRTY:
                DEBUGTRACE((LOG_WBEMCORE, "Repository is marked as corrupt, therefore cannot export it.\n"));
                break;
            case FAILURE_WRITE:
                DEBUGTRACE((LOG_WBEMCORE, "Failure writing to the export file.  May be out of disk space, or may not have write access to this directory.\n"));
                break;
            default:
                DEBUGTRACE((LOG_WBEMCORE, "An unknown problem happened while traversing the repository.\n"));
                break;
            }
            CloseHandle(g_hFile);
            nRet = 1;
        }
        catch (...)
        {
            DEBUGTRACE((LOG_WBEMCORE, "Traversal of repository file failed.  It may be corrupt.\n"));
            CloseHandle(g_hFile);
            DeleteFile(pszFilename);
            nRet = 1;
        }

    }
    else
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to create file %s to export the repository.\n", pszFilename));
        nRet = 1;
    }
    return nRet;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\import.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    IMPORT.CPP

Abstract:

History:

--*/

#include "precomp.h"
#ifdef _MMF
#include <StdIo.h>
#include <ConIo.h>
#include "ObjDb.h"
#include "Import.h"
#include "export.h"
#include <WbemUtil.h>
#include <FastAll.h>
#include "Sinks.h"
#include <corex.h>
#include <reg.h>
template <class T> class CMyRelMe
{
    T m_p;
    public:
        CMyRelMe(T p) : m_p(p) {};
        ~CMyRelMe() { if (m_p) m_p->Release(); }
        void Set(T p) { m_p = p; }
};

void CRepImporter::DecodeTrailer()
{
    DWORD dwTrailerSize = 0;
    DWORD dwTrailer[4];
    DWORD dwSize = 0;
    if ((ReadFile(m_hFile, &dwTrailerSize, 4, &dwSize, NULL) == 0) || (dwSize != 4))
    {
        DEBUGTRACE((LOG_WBEMCORE, LOG_WBEMCORE,"Failed to decode a block trailer\n"));
        throw FAILURE_READ;
    }
    if (dwTrailerSize != REP_EXPORT_END_TAG_SIZE)
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to decode a block trailer\n"));
        throw FAILURE_INVALID_TRAILER;
    }
    if ((ReadFile(m_hFile, dwTrailer, REP_EXPORT_END_TAG_SIZE, &dwSize, NULL) == 0) || (dwSize != REP_EXPORT_END_TAG_SIZE))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to decode a block trailer\n"));
        throw FAILURE_READ;
    }
    for (int i = 0; i < 4; i++)
    {
        if (dwTrailer[i] != REP_EXPORT_FILE_END_TAG)
        {
            DEBUGTRACE((LOG_WBEMCORE, "Block trailer has invalid contents.\n"));
            throw FAILURE_INVALID_TRAILER;
        }
    }

}

void CRepImporter::DecodeInstanceInt(CObjDbNS *pNs, const wchar_t *pszParentClass, CWbemObject *pClass, CWbemClass *pNewParentClass)
{
    //Read the key and object size
    INT_PTR dwKey = 0;
    DWORD dwSize = 0;
    if ((ReadFile(m_hFile, &dwKey, sizeof(INT_PTR), &dwSize, NULL) == 0) || (dwSize != sizeof(INT_PTR)))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to retrieve instance key for class %S.\n", pszParentClass));
        throw FAILURE_READ;
    }
    DWORD dwHeader;
    if ((ReadFile(m_hFile, &dwHeader, 4, &dwSize, NULL) == 0) || (dwSize != 4))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to retrieve instance information for class %S.\n", pszParentClass));
        throw FAILURE_READ;
    }

    char *pObjectBlob = new char[dwHeader];
    if (pObjectBlob == 0)
    {
        throw FAILURE_OUT_OF_MEMORY;
    }
    CDeleteMe<char> delMe(pObjectBlob);

    //Read the blob
    if ((ReadFile(m_hFile, pObjectBlob, dwHeader, &dwSize, NULL) == 0) || (dwSize != dwHeader))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to retrieve instance information for class %S.\n", pszParentClass));
        throw FAILURE_READ;
    }

    if (pNewParentClass == (CWbemClass *)-1)
    {
        //We are working with a class which has problems... we need to ignore this instance...
        return;
    }

    CWbemInstance *pThis = (CWbemInstance *) CWbemInstance::CreateFromBlob((CWbemClass *) pClass,(LPMEMORY) pObjectBlob);
    if (pThis == 0)
        throw FAILURE_OUT_OF_MEMORY;
    CMyRelMe<CWbemInstance*> relMe(pThis);

    if (pNewParentClass)
    {
        // The parent class changed (probably system class derivative), so we need to
        // reparent the instance....

        CWbemInstance * pNewInstance = 0;

        //Now we need to merge the instance bits...
        HRESULT hRes = pThis->Reparent(pNewParentClass, &pNewInstance);
        if (hRes == WBEM_E_OUT_OF_MEMORY)
            throw FAILURE_OUT_OF_MEMORY;
        else if (hRes != WBEM_NO_ERROR)
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to create a new instance for a system class because the fixing up of the instance and class failed, %S.%d\n", pszParentClass, dwKey));
            throw FAILURE_CANNOT_CREATE_INSTANCE;
        }

        CMyRelMe<CWbemObject*> relMe3(pNewInstance);

        //Now we need to write it...
        if (m_pDb->CreateObject(pNs, (CWbemObject*)pNewInstance, 0) != CObjectDatabase::no_error)
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to create instance %S.%d\n", pszParentClass, dwKey));
            throw FAILURE_CANNOT_CREATE_INSTANCE;
        }
    }
    else if (m_pDb->CreateObject(pNs, (CWbemObject*)pThis, 0) != CObjectDatabase::no_error)
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to create instance %S.%d\n", pszParentClass, dwKey));
        throw FAILURE_CANNOT_CREATE_INSTANCE;
    }
}

void CRepImporter::DecodeInstanceString(CObjDbNS *pNs, const wchar_t *pszParentClass, CWbemObject *pClass, CWbemClass *pNewParentClass )
{
    //Read the key and object size
    DWORD dwKeySize;
    DWORD dwSize = 0;
    if ((ReadFile(m_hFile, &dwKeySize, 4, &dwSize, NULL) == 0) || (dwSize != 4))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to retrieve instance information for class %S.\n", pszParentClass));
        throw FAILURE_READ;
    }

    wchar_t *wszKey = new wchar_t[dwKeySize];
    if (wszKey == NULL)
    {
        throw FAILURE_OUT_OF_MEMORY;
    }
    CDeleteMe<wchar_t> delMe(wszKey);
    if ((ReadFile(m_hFile, wszKey, dwKeySize, &dwSize, NULL) == 0) || (dwSize != dwKeySize))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to retrieve instance information for class %S.\n", pszParentClass));
        throw FAILURE_READ;
    }

    DWORD dwBlobSize;
    if ((ReadFile(m_hFile, &dwBlobSize, 4, &dwSize, NULL) == 0) || (dwSize != 4))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to retrieve instance %S.%S from import file.\n", pszParentClass, wszKey));
        throw FAILURE_READ;
    }

    char *pObjectBlob = new char[dwBlobSize];
    if (pObjectBlob == NULL)
    {
        throw FAILURE_OUT_OF_MEMORY;
    }
    CDeleteMe<char> delMe2(pObjectBlob);

    //Read the blob
    if ((ReadFile(m_hFile, pObjectBlob, dwBlobSize, &dwSize, NULL) == 0) || (dwSize != dwBlobSize))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to retrieve instance %S.%S from import file.\n", pszParentClass, wszKey));
        throw FAILURE_READ;
    }

    if (pNewParentClass == (CWbemClass *)-1)
    {
        //We are working with a class which has problems... we need to ignore this instance...
        return;
    }

    CWbemInstance *pThis = (CWbemInstance *) CWbemInstance::CreateFromBlob((CWbemClass *) pClass,(LPMEMORY) pObjectBlob);
    if (pThis == 0)
        throw FAILURE_OUT_OF_MEMORY;
    CMyRelMe<CWbemInstance*> relMe(pThis);
    //If this is a namespace we need to do something different!
    BSTR bstrClassName = SysAllocString(L"__namespace");
    CSysFreeMe delMe3(bstrClassName);
    HRESULT hRes = pThis->InheritsFrom(bstrClassName);
    if (hRes == S_OK)
    {
        if (wbem_wcsicmp(wszKey, L"default") != 0 && wbem_wcsicmp(wszKey, L"security") != 0)
        {
            if (m_pDb->AddNamespace(pNs, wszKey, pThis) != CObjectDatabase::no_error)
            {
                DEBUGTRACE((LOG_WBEMCORE, "Failed to create namespace %S.%S in repository.\n", pszParentClass, wszKey));
                throw FAILURE_CANNOT_ADD_NAMESPACE;
            }
        }
        else
        {
            //WE don't need to do anything with the default or security namespace!!!
        }
    }
    else if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw FAILURE_OUT_OF_MEMORY;
    else
    {
        if (pNewParentClass)
        {
            // The parent class changed (probably system class derivative), so we ned to
            // reparent the instance....

            CWbemInstance * pNewInstance = 0;

            //Now we need to merge the instance bits...
            HRESULT hRes = pThis->Reparent(pNewParentClass, &pNewInstance);
            if (hRes == WBEM_E_OUT_OF_MEMORY)
                throw FAILURE_OUT_OF_MEMORY;
            else if (hRes != WBEM_NO_ERROR)
            {
                DEBUGTRACE((LOG_WBEMCORE, "Failed to create a new instance for a system class because the fixing up of the instance and class failed, %S.%S\n", pszParentClass, wszKey));
                throw FAILURE_CANNOT_CREATE_INSTANCE;
            }

            CMyRelMe<CWbemObject*> relMe3(pNewInstance);

            //Now we need to write it...
            if (m_pDb->CreateObject(pNs, (CWbemObject*)pNewInstance, 0) != CObjectDatabase::no_error)
            {
                DEBUGTRACE((LOG_WBEMCORE, "Failed to create instance %S.%S\n", pszParentClass, wszKey));
                throw FAILURE_CANNOT_CREATE_INSTANCE;
            }
        }
        else if (m_pDb->CreateObject(pNs, (CWbemObject*)pThis, 0))
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to create instance %S.%S in repository.\n", pszParentClass, wszKey));
            throw FAILURE_CANNOT_CREATE_INSTANCE;
        }
    }
}

void CRepImporter::DecodeClass(CObjDbNS *pNs, const wchar_t *wszParentClass, CWbemObject *pParentClass, CWbemClass *pNewParentClass)
{
    //Read our current class from the file...
    DWORD dwClassSize = 0;
    DWORD dwSize = 0;
    CWbemObject *pClass = 0;
    CMyRelMe<CWbemObject*> relMe(pClass);
    CWbemClass *pNewClass = 0;
    CMyRelMe<CWbemClass*> relMe2(pNewClass);

    if ((ReadFile(m_hFile, &dwClassSize, 4, &dwSize, NULL) == 0) || (dwSize != 4))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to retrieve class information for class with parent class %S.\n", wszParentClass));
        throw FAILURE_READ;
    }
    wchar_t *wszClass = new wchar_t[dwClassSize];
    if (wszClass == NULL)
    {
        throw FAILURE_OUT_OF_MEMORY;
    }
    CDeleteMe<wchar_t> delMe(wszClass);
    if ((ReadFile(m_hFile, wszClass, dwClassSize, &dwSize, NULL) == 0) || (dwSize != dwClassSize))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to retrieve class information for class with parent class %S.\n", wszParentClass));
        throw FAILURE_READ;
    }

    //Now we have the class blob...
    if ((ReadFile(m_hFile, &dwClassSize, 4, &dwSize, NULL) == 0) || (dwSize != 4))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to retrieve class information for class %S.\n", wszClass));
        throw FAILURE_READ;
    }

    if (dwClassSize)
    {
        char *pClassBlob = new char[dwClassSize];
        if (pClassBlob == NULL)
        {
            throw FAILURE_OUT_OF_MEMORY;
        }
        CDeleteMe<char> delMe2(pClassBlob);
        if ((ReadFile(m_hFile, pClassBlob, dwClassSize, &dwSize, NULL) == 0) || (dwSize != dwClassSize))
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to retrieve class information for class %S.\n", wszClass));
            throw FAILURE_READ;
        }
        pClass = CWbemClass::CreateFromBlob((CWbemClass*)pParentClass,(LPMEMORY) pClassBlob);
        if (pClass == 0)
            throw FAILURE_OUT_OF_MEMORY;
        relMe.Set(pClass);

        //Is there a new parent class?  If so we need to create a new class based on that...
        if (pNewParentClass && (pNewParentClass != (CWbemClass *)-1))
        {
            if (FAILED(pNewParentClass->Update((CWbemClass*)pClass, WBEM_FLAG_UPDATE_FORCE_MODE, &pNewClass)))
            {
                DEBUGTRACE((LOG_WBEMCORE, "Failed to update the class based on an undated parent class, class %S.\n", wszClass));
            }
            relMe2.Set(pNewClass);

        }
        else if ((pNewParentClass != (CWbemClass *)-1) && (wcsncmp(wszClass, L"__", 2) == 0))
        {
            //This is a system class... see if this has changed...
            CWbemObject *pTmpNewClass = 0;
            if (m_pDb->GetObject(pNs, CObjectDatabase::flag_class, wszClass, &pTmpNewClass) == CObjectDatabase::no_error)
            {
                pNewClass = (CWbemClass*)pTmpNewClass;
                relMe2.Set(pNewClass);

                if (pNewClass->CompareMostDerivedClass((CWbemClass*)pClass))
                {
                    //These are the same, so we do not need to do anything with this.
                    relMe2.Set(NULL);
                    pNewClass->Release();
                    pNewClass = 0;
                }
            }
            else
            {
                //If this does not exist then it cannot be important!
                pNewClass = (CWbemClass *)-1;
            }
        }
        else if (pNewParentClass == (CWbemClass *)-1)
        {
            pNewClass = (CWbemClass *)-1;
        }

        //If the class is a system class then we do not write it... it may have changed for starters,
        //but also we create all system classes when a new database/namespace is created...

        bool bOldSecurityClass = false;
        if(m_bSecurityMode)
        {
            if(!_wcsicmp(wszClass, L"__SecurityRelatedClass"))
                bOldSecurityClass = true;
            else if(!_wcsicmp(wszClass, L"__Subject"))
                bOldSecurityClass = true;
            else if(!_wcsicmp(wszClass, L"__User"))
                bOldSecurityClass = true;
            else if(!_wcsicmp(wszClass, L"__NTLMUser"))
                bOldSecurityClass = true;
            else if(!_wcsicmp(wszClass, L"__Group"))
                bOldSecurityClass = true;
            else if(!_wcsicmp(wszClass, L"__NTLMGroup"))
                bOldSecurityClass = true;
            if(bOldSecurityClass)
                m_bSecurityClassesWritten = true;
        }

        if (_wcsnicmp(wszClass, L"__", 2) != 0)
        {
            if (pNewClass && (pNewClass != (CWbemClass *)-1))
            {
                //Store new class...
                if (m_pDb->CreateObject(pNs, pNewClass, 0) != CObjectDatabase::no_error)
                {
                    DEBUGTRACE((LOG_WBEMCORE, "Failed to create class for class %S.\n", wszClass));
                }
                //Once put, we need to re-get it as class comparisons may fail to see that
                //this class is in fact the same as the one in the database!
                pNewClass->Release();
                pNewClass = 0;
                relMe2.Set(NULL);

                CWbemObject *pTmpClass = 0;
                if (m_pDb->GetObject(pNs, CObjectDatabase::flag_class, wszClass, &pTmpClass) != CObjectDatabase::no_error)
                {
                    DEBUGTRACE((LOG_WBEMCORE, "Failed to retrieve class %S from the repository after creating it.\n", wszClass));
                    throw FAILURE_CANNOT_GET_PARENT_CLASS;
                }
                pNewClass = (CWbemClass*)pTmpClass;
                relMe2.Set(pNewClass);
            }
            else if (pNewClass != (CWbemClass *)-1)
            {
                //Store the old one...
                if (m_pDb->CreateObject(pNs, pClass, 0) != CObjectDatabase::no_error)
                {
                    DEBUGTRACE((LOG_WBEMCORE, "Failed to create class for class %S.\n", wszClass));
                }
            }
        }
    }
    else
    {
        if (m_pDb->GetObject(pNs, CObjectDatabase::flag_class, wszClass, &pClass) != CObjectDatabase::no_error)
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to retrieve class %S from the repository.\n", wszClass));
            throw FAILURE_CANNOT_GET_PARENT_CLASS;
        }
        relMe.Set(pClass);
    }

    //Now we iterate through all child classes and instances until we get
    //and end of class marker...
    while (1)
    {
        DWORD dwType = 0;
        if ((ReadFile(m_hFile, &dwType, 4, &dwSize, NULL) == 0) || (dwSize != 4))
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to next block type from import file.\n"));
            throw FAILURE_READ;
        }
        if (dwType == REP_EXPORT_CLASS_TAG)
        {
            DecodeClass(pNs, wszClass, pClass, pNewClass);
        }
        else if (dwType == REP_EXPORT_INST_INT_TAG)
        {
            DecodeInstanceInt(pNs, wszClass, pClass, pNewClass);
        }
        else if (dwType == REP_EXPORT_INST_STR_TAG)
        {
            DecodeInstanceString(pNs, wszClass, pClass, pNewClass);
        }
        else if (dwType == REP_EXPORT_CLASS_END_TAG)
        {
            //That's the end of this class...
            DecodeTrailer();
            break;
        }
        else
        {
            DEBUGTRACE((LOG_WBEMCORE, "Next block type is invalid in import file.\n"));
            throw FAILURE_INVALID_TYPE;
        }
    }
}

void CRepImporter::DecodeNamespace(const wchar_t *wszParentNamespace)
{
    //Read our current namespace from the file...
    DWORD dwNsSize = 0;
    DWORD dwSize = 0;
    if ((ReadFile(m_hFile, &dwNsSize, 4, &dwSize, NULL) == 0) || (dwSize != 4))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to retrieve a namespace whose parent namespace is %S.\n", wszParentNamespace));
        throw FAILURE_READ;
    }
    wchar_t *wszNs = new wchar_t[dwNsSize];
    if (wszNs == NULL)
    {
        throw FAILURE_OUT_OF_MEMORY;
    }
    CDeleteMe<wchar_t> delMe(wszNs);
    if ((ReadFile(m_hFile, wszNs, dwNsSize, &dwSize, NULL) == 0) || (dwSize != dwNsSize))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to retrieve a namespace whose parent namespace is %S.\n", wszParentNamespace));
        throw FAILURE_READ;
    }
    if (wbem_wcsicmp(wszNs, L"security") == 0)
    {
        m_bSecurityMode = true;
    }

    wchar_t *wszFullPath = new wchar_t[wcslen(wszParentNamespace) + 1 + wcslen(wszNs) + 1];
    if (wszFullPath == NULL)
    {
        throw FAILURE_OUT_OF_MEMORY;
    }
    CDeleteMe<wchar_t> delMe2(wszFullPath);
    wcscpy(wszFullPath, wszParentNamespace);
    if (wcslen(wszParentNamespace) != 0)
    {
        wcscat(wszFullPath, L"\\");
    }
    wcscat(wszFullPath, wszNs);

    CObjDbNS *pNs;
    if (m_pDb->GetNamespace(wszFullPath, &pNs) != CObjectDatabase::no_error)
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to retrieve namespace %S from the repository.\n", wszFullPath));
        throw FAILURE_CANNOT_FIND_NAMESPACE;
    }

    //Get and set the namespace security...
    DWORD dwBuffer[2];
    if ((ReadFile(m_hFile, dwBuffer, 8, &dwSize, NULL) == 0) || (dwSize != 8))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to retrieve a namespace security header for  namespace %S.\n", wszFullPath));
        throw FAILURE_READ;
    }
    if (dwBuffer[0] != REP_EXPORT_NAMESPACE_SEC_TAG)
    {
        DEBUGTRACE((LOG_WBEMCORE, "Expecting a namespace security blob and did not find it.\n"));
        throw FAILURE_INVALID_TYPE;
    }
    if (dwBuffer[1] != 0)
    {
        char *pNsSecurity = new char[dwBuffer[1]];
        if (pNsSecurity == NULL)
        {
            throw FAILURE_OUT_OF_MEMORY;
        }
        CDeleteMe<char> delMe(pNsSecurity);
        if ((ReadFile(m_hFile, pNsSecurity, dwBuffer[1], &dwSize, NULL) == 0) || (dwSize != dwBuffer[1]))
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to retrieve a namespace security blob for namespace %S.\n", wszFullPath));
            throw FAILURE_READ;
        }
        if (m_pDb->SetSecurityOnNamespace(pNs, pNsSecurity, dwBuffer[1]) != CObjectDatabase::no_error)
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to add security to namespace %S.\n", wszFullPath));
            throw FAILURE_CANNOT_ADD_NAMESPACE_SECURITY;
        }
    }


    //Now we need to iterate through the next set of blocks of namespace or class
    //until we get to and end of NS marker
    while (1)
    {
        DWORD dwType = 0;
        if ((ReadFile(m_hFile, &dwType, 4, &dwSize, NULL) == 0) || (dwSize != 4))
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to next block type from import file.\n"));
            throw FAILURE_READ;
        }
        if (dwType == REP_EXPORT_NAMESPACE_TAG)
        {
            DecodeNamespace(wszFullPath);
        }
        else if (dwType == REP_EXPORT_CLASS_TAG)
        {
            DecodeClass(pNs, L"", NULL, NULL);
        }
        else if (dwType == REP_EXPORT_NAMESPACE_END_TAG)
        {
            //That's the end of this namespace...
            DecodeTrailer();
            break;
        }
        else
        {
            DEBUGTRACE((LOG_WBEMCORE, "Next block type is invalid in import file.\n"));
            throw FAILURE_INVALID_TYPE;
        }
    }
    m_pDb->CloseNamespace(pNs);

    m_bSecurityMode = false;
}

void CRepImporter::Decode()
{
    char pszBuff[7];
    DWORD dwSize = 0;
    if ((ReadFile(m_hFile, pszBuff, 7, &dwSize, NULL) == 0) || (dwSize != 7))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to retrieve the import file header information\n"));
        throw FAILURE_READ;
    }
    if (strncmp(pszBuff, REP_EXPORT_FILE_START_TAG, 7) != 0)
    {
        DEBUGTRACE((LOG_WBEMCORE, "The import file specified is not an import file.\n"));
        throw FAILURE_INVALID_FILE;
    }

    //We should have a tag for a namespace...
    DWORD dwType = 0;
    if ((ReadFile(m_hFile, &dwType, 4, &dwSize, NULL) == 0) || (dwSize != 4))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to next block type from import file.\n"));
        throw FAILURE_READ;
    }
    if (dwType != REP_EXPORT_NAMESPACE_TAG)
    {
        DEBUGTRACE((LOG_WBEMCORE, "Next block type is invalid in import file.\n"));
        throw FAILURE_INVALID_TYPE;
    }
    DecodeNamespace(L"");

    //Now we should have the file trailer
    if ((ReadFile(m_hFile, &dwType, 4, &dwSize, NULL) == 0) || (dwSize != 4))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to next block type from import file.\n"));
        throw FAILURE_READ;
    }
    if (dwType != REP_EXPORT_FILE_END_TAG)
    {
        DEBUGTRACE((LOG_WBEMCORE, "Next block type is invalid in import file.\n"));
        throw FAILURE_INVALID_TYPE;
    }
    DecodeTrailer();

}

int CRepImporter::ImportRepository(const TCHAR *pszFromFile)
{
    int nRet = CObjectDatabase::no_error;
    m_hFile = CreateFile(pszFromFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (m_hFile != INVALID_HANDLE_VALUE)
    {
        m_pDb = new CObjectDatabase();
        if (m_pDb == NULL)
        {
            nRet = CObjectDatabase::out_of_memory;
        }
        else
        {
            m_pDb->Open();
            try
            {
                Decode();
            }
            catch (char nProblem)
            {
                switch (nProblem)
                {
                case FAILURE_READ:
                    DEBUGTRACE((LOG_WBEMCORE, "IMPORT: Failed to read the required amount from the import file.\n"));
                    break;
                case FAILURE_INVALID_FILE:
                    DEBUGTRACE((LOG_WBEMCORE, "IMPORT: The file header is not correct.\n"));
                    break;
                case FAILURE_INVALID_TYPE:
                    DEBUGTRACE((LOG_WBEMCORE, "IMPORT: An invalid block type was found in the export file.\n"));
                    break;
                case FAILURE_INVALID_TRAILER:
                    DEBUGTRACE((LOG_WBEMCORE, "IMPORT: An invalid block trailer was found in the export file.\n"));
                    break;
                case FAILURE_CANNOT_FIND_NAMESPACE:
                    DEBUGTRACE((LOG_WBEMCORE, "IMPORT: Could not open a namespace in the repository.\n"));
                    break;
                case FAILURE_CANNOT_GET_PARENT_CLASS:
                    DEBUGTRACE((LOG_WBEMCORE, "IMPORT: Could not retrieve parent class from repository.\n"));
                    break;
                case FAILURE_CANNOT_CREATE_INSTANCE:
                    DEBUGTRACE((LOG_WBEMCORE, "IMPORT: Could not create instance.\n"));
                    break;
                case FAILURE_CANNOT_ADD_NAMESPACE:
                    DEBUGTRACE((LOG_WBEMCORE, "IMPORT: Could not add namespace.\n"));
                    break;
                case FAILURE_OUT_OF_MEMORY:
                    DEBUGTRACE((LOG_WBEMCORE, "IMPORT: Out of memory.\n"));
                    break;
                default:
                    DEBUGTRACE((LOG_WBEMCORE, "IMPORT: An unknown problem happened while traversing the import file.  Import file may be corrupt.\n"));
                    break;
                }
                DEBUGTRACE((LOG_WBEMCORE, "The file may not be an exported repository file, or it may be corrupt.\n"));
                nRet = CObjectDatabase::failed;
            }
            catch (CX_MemoryException)
            {
                nRet = CObjectDatabase::out_of_memory;
            }
            catch (...)
            {
                DEBUGTRACE((LOG_WBEMCORE, "Traversal of import file failed.  It may be corrupt.\n"));
                nRet = CObjectDatabase::critical_error;
            }
            m_pDb->Shutdown(TRUE);
            delete m_pDb;
        }
        CloseHandle(m_hFile);

        if (nRet == CObjectDatabase::no_error)
            DEBUGTRACE((LOG_WBEMCORE, "Import succeeded.\n"));
        else
            DEBUGTRACE((LOG_WBEMCORE, "Import failed.\n"));
    }
    else
    {
        DEBUGTRACE((LOG_WBEMCORE, "Could not open the import file \"%s\" for reading.\n", pszFromFile));
        nRet = CObjectDatabase::critical_error;
    }

    return nRet;
}

int CRepImporter::RestoreRepository(const TCHAR *pszFromFile, CObjectDatabase *pDb)
{
    int nRet = CObjectDatabase::no_error;
    m_hFile = CreateFile(pszFromFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (m_hFile != INVALID_HANDLE_VALUE)
    {
        m_pDb = pDb;
        try
        {
            Decode();
        }
        catch (int nProblem)
        {
            nRet = CObjectDatabase::critical_error;
            switch (nProblem)
            {
            case FAILURE_READ:
                DEBUGTRACE((LOG_WBEMCORE, "IMPORT: Failed to read the required amount from the import file.\n"));
                break;
            case FAILURE_INVALID_FILE:
                DEBUGTRACE((LOG_WBEMCORE, "IMPORT: The file header is not correct.\n"));
                break;
            case FAILURE_INVALID_TYPE:
                DEBUGTRACE((LOG_WBEMCORE, "IMPORT: An invalid block type was found in the export file.\n"));
                break;
            case FAILURE_INVALID_TRAILER:
                DEBUGTRACE((LOG_WBEMCORE, "IMPORT: An invalid block trailer was found in the export file.\n"));
                break;
            case FAILURE_CANNOT_FIND_NAMESPACE:
                DEBUGTRACE((LOG_WBEMCORE, "IMPORT: Could not open a namespace in the repository.\n"));
                break;
            case FAILURE_CANNOT_GET_PARENT_CLASS:
                DEBUGTRACE((LOG_WBEMCORE, "IMPORT: Could not retrieve parent class from repository.\n"));
                break;
            case FAILURE_CANNOT_CREATE_INSTANCE:
                DEBUGTRACE((LOG_WBEMCORE, "IMPORT: Could not create instance.\n"));
                break;
            case FAILURE_CANNOT_ADD_NAMESPACE:
                DEBUGTRACE((LOG_WBEMCORE, "IMPORT: Could not add namespace.\n"));
                break;
            case FAILURE_OUT_OF_MEMORY:
                DEBUGTRACE((LOG_WBEMCORE, "IMPORT: Out of memory.\n"));
                throw CX_MemoryException();
                break;
            default:
                DEBUGTRACE((LOG_WBEMCORE, "IMPORT: An unknown problem happened while traversing the import file.  Import file may be corrupt.\n"));
                break;
            }
        }
        catch (CX_MemoryException)
        {
            nRet = CObjectDatabase::out_of_memory;
        }
        catch (...)
        {
            DEBUGTRACE((LOG_WBEMCORE, "IMPORT: Traversal of import file failed.  It may be corrupt.\n"));
            nRet =CObjectDatabase::critical_error;
        }
        CloseHandle(m_hFile);

        if (nRet == CObjectDatabase::no_error)
            DEBUGTRACE((LOG_WBEMCORE, "Import succeeded.\n"));
        else
            DEBUGTRACE((LOG_WBEMCORE, "Import failed.\n"));
    }
    else
    {
        DEBUGTRACE((LOG_WBEMCORE, "Could not open the import file \"%s\" for reading.\n", pszFromFile));
        nRet = CObjectDatabase::critical_error;
    }

    return nRet;
}

CRepImporter::~CRepImporter()
{
    // If there were some old security classes, set a registry flag so that they will be
    // converted to ACE entries later on by the security code

    if(m_bSecurityClassesWritten)
    {
        Registry r(WBEM_REG_WINMGMT);
        r.SetDWORDStr(__TEXT("OldSecurityClassesNeedConverting"), 4);
    }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\exportv9.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    EXPORTV9.CPP

Abstract:

    Exporting

History:

--*/

#include "precomp.h"
#ifdef _MMF
#include "Time.h"
#include "WbemCli.h"
#include "DbRep.h"
#include "Export.h"
#include "WbemUtil.h"


void CRepExporterV9::DumpNamespaceSecurity(NSREP *pNsRep)
{
    //Default version does not have a security descriptor, so we need to
    //just dump a blank entry.
    DWORD dwSize = 0;
    DWORD dwBuffer[2];
    dwBuffer[0] = REP_EXPORT_NAMESPACE_SEC_TAG;
    if (pNsRep->m_poSecurity)
        dwBuffer[1] = g_pDbArena->Size(pNsRep->m_poSecurity);
    else
        dwBuffer[1] = 0;

    if ((WriteFile(g_hFile, dwBuffer, 8, &dwSize, NULL) == 0) || (dwSize != 8))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write namespace security header, %S.\n", Fixup(pNsRep->m_poName)));
        throw FAILURE_WRITE;
    }

    if (dwBuffer[1] != 0)
    {
        if ((WriteFile(g_hFile, (void*)Fixup(pNsRep->m_poSecurity), dwBuffer[1], &dwSize, NULL) == 0) || (dwSize != dwBuffer[1]))
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to write namespace security block, %S.\n", Fixup(pNsRep->m_poName)));
            throw FAILURE_WRITE;
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\import.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    IMPORT.H

Abstract:

History:

--*/
#ifdef _MMF
#ifndef __wmi_import_h__
#define __wmi_import_h__

class CObjectDatabase;

/*================================================================================
 *
 * EXPORT FILE FORMAT
 * ==================
 *
 * File Header Block:
 *		wchar_t wszFileHeader								= "repexp1"
 *
 * Namespace Block:
 *		DWORD   dwObjectType								= 0x00000001
 *		DWORD   dwNamespaceNameSize
 *		wchar_t wszNamespaceName[dwNamespaceNameSize]		= Full namespace name
 *															  (\root\default\fred)
 *
 * Class Block:
 *		DWORD   dwObjectType								= 0x00000002
 *		DWORD   dwClassNameSize
 *		wchar_t wszClassName[dwClassNameSize]				= Class name (my_class_name)
 *		DWORD   dwClassObjectSize
 *		DWORD	adwClassObject[dwClassObjectSize]
 *
 * Instance Block - key of type int:
 *		DWORD   dwObjectType								= 0x00000003
 *		DWORD   dwInstanceKey
 *		DWORD	dwInstanceObjectSize
 *		DWORD	adwInstanceObject[dwInstanceObjectSize]
 *
 * Instance Block - key of type string
 *		DWORD	dwObjectType								= 0x00000004
 *		DWORD	dwInstanceKeySize
 *		DWORD	dwInstanceKey[dwInstanceKeySize]			= Instance key (MyKeyValue)
 *		DWORD	dwInstanceObjectSize
 *		DWORD	adwInstanceObject[dwInstanceObjectSize]
 *		
 * End of class block
 *		DWORD	dwObjectType								= 0x00000005
 *		DWORD	dwEndOfBlockSize							= 0x00000010
 *		DWORD	adwEndOfBlock[dwEndOfBlockSize]				= 0xFFFFFFFF,
 *															  0xFFFFFFFF,
 *															  0xFFFFFFFF,
 *															  0xFFFFFFFF
 *
 * End of namespace block
 *		DWORD	dwObjectType								= 0x00000006
 *		DWORD	dwEndOfBlockSize							= 0x00000010
 *		DWORD	adwEndOfBlock[dwEndOfBlockSize]				= 0xFFFFFFFF,
 *															  0xFFFFFFFF,
 *															  0xFFFFFFFF,
 *															  0xFFFFFFFF
 *
 * End of file block
 *		DWORD	dwObjectType								= 0xFFFFFFFF
 *		DWORD	dwEndOfBlockSize							= 0x00000010
 *		DWORD	adwEndOfBlock[dwEndOfBlockSize]				= 0xFFFFFFFF,
 *															  0xFFFFFFFF,
 *															  0xFFFFFFFF,
 *															  0xFFFFFFFF
 *
 * Ordering:
 *		File Header Block
 *			(one or more)
 *			Namespace Block
 *				(zero or more)
 *				{
 *					Namespace Block
 *						etc...
 *					End namespace block
 *					(or)
 *					Class Block
 *						(zero or more)
 *						{
 *							Instance Block
 *							(or)
 *							Class Block
 *								etc...
 *							End class block
 *						}
 *					End class block
 *				}
 *			End namespace block
 *		End of file block
 *
 *================================================================================
 */

class CRepImporter
{
private:
	HANDLE m_hFile ;
	CObjectDatabase *m_pDb ;
	bool m_bSecurityMode;
    bool m_bSecurityClassesWritten;

	void DecodeTrailer();
	void DecodeInstanceInt(CObjDbNS *pNs, const wchar_t *pszParentClass, CWbemObject *pClass, CWbemClass *pNewParentClass);
	void DecodeInstanceString(CObjDbNS *pNs, const wchar_t *pszParentClass, CWbemObject *pClass, CWbemClass *pNewParentClass);
	void DecodeClass(CObjDbNS *pNs, const wchar_t *wszParentClass, CWbemObject *pParentClass, CWbemClass *pNewParentClass);
	void DecodeNamespace(const wchar_t *wszParentNamespace);
	void Decode();

public:
	enum { FAILURE_READ = 1,
		   FAILURE_INVALID_FILE = 2,
		   FAILURE_INVALID_TYPE = 3,
		   FAILURE_INVALID_TRAILER = 4,
		   FAILURE_CANNOT_FIND_NAMESPACE = 5,
		   FAILURE_CANNOT_GET_PARENT_CLASS = 6,
		   FAILURE_CANNOT_CREATE_INSTANCE  = 7,
		   FAILURE_CANNOT_ADD_NAMESPACE = 8,
		   FAILURE_CANNOT_ADD_NAMESPACE_SECURITY = 9,
		   FAILURE_OUT_OF_MEMORY = 10
	};
	CRepImporter() : m_hFile(INVALID_HANDLE_VALUE), m_pDb(NULL), m_bSecurityMode(false),
                        m_bSecurityClassesWritten(false){}

	int RestoreRepository(const TCHAR *pszFromFile, CObjectDatabase *pDb);
	int ImportRepository(const TCHAR *pszFromFile);
    ~CRepImporter();
};

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\localloc.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "precomp.h"
#include <arena.h>

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\lock.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    LOCK.H

Abstract:

	Generic class for obtaining read and write locks to some resource. 

	See lock.h for all documentation.

	Classes defined:

	CLock

History:

	a-levn  5-Sept-96       Created.
	3/10/97     a-levn      Fully documented

--*/

#ifndef __GATEWAY__LOCK__H_
#define __GATEWAY__LOCK__H_

#include <flexarry.h>

//*****************************************************************************
//
//	class CLock
//
//	Generic class for obtaining read and write locks to some resource. 
//	Simultaneous reads are allowed, but no concurrent writes or concurrent 
//	read and write accesses are.
//
//	NOTE: this class is for in-process sinchronization only!
//
//	Usage: create an instance of this class and share it among the accessing
//	threads.  Threads must call member functions of the same instance to 
//	obtain and release locks.
//
//*****************************************************************************
//
//	ReadLock
//
//	Use this function to request read access to the resource. Access will be
//	granted once no threads are writing on the resource. You must call 
//	ReadUnlock once you are done reading.
//
//	Parameters:
//
//		DWORD dwTimeout		The number of milliseconds to wait for access.
//							If access is still unavailable after this time,
//							an error is returned.
//	Returns:
//
//		NoError		On Success
//		TimedOut	On timeout.
//		Failed		On system error
//
//*****************************************************************************
//
//	ReadUnlock
//
//	Use this function to release a read lock on the resource. No check is 
//	performed to assertain that this thread holds a lock. Unmatched calls to
//	ReadUnlock may lead to lock integrity violations!
//
//	Returns:
//
//		NoError		On success
//		Failed		On system error or unmatched call.
//
//*****************************************************************************
//
//	WriteLock
//
//	Use this function to request write access to the resource. Access will be
//	granted once no threads are reading or writing on the resource. You must 
//	call WriteUnlock once you are done writing.
//
//	Parameters:
//
//		DWORD dwTimeout		The number of milliseconds to wait for access.
//							If access is still unavailable after this time,
//							an error is returned.
//	Returns:
//
//		NoError		On Success
//		TimedOut	On timeout.
//		Failed		On system error
//
//*****************************************************************************
//
//	WriteUnlock
//
//	Use this function to release a write lock on the resource. No check is 
//	performed to assertain that this thread holds a lock. Unmatched calls to
//	WriteUnlock may lead to lock integrity violations!
//
//	Returns:
//
//		NoError		On success
//		Failed		On system error or unmatched call.
//
//*****************************************************************************
//
//  DowngradeLock
//
//  Use this function to "convert" a Write lock into a Read lock. That is, if
//  you are currently holding a write lock and call DowngradeLock, you will 
//  be holding a read lock with the guarantee that no one wrote anything between
//  the unlock and the lock
//
//  Returns:
//
//      NoError     On Success
//      Failed      On system error or unmatched call
//
//******************************************************************************
class CLock
{
public:
	enum { NoError = 0, TimedOut, Failed };

	int ReadLock(DWORD dwTimeout = INFINITE);
	int ReadUnlock();
	int WriteLock(DWORD dwTimeout = INFINITE);
	int WriteUnlock();
    int DowngradeLock();

	CLock();
	~CLock();

    BOOL IsHoldingReadLock();

protected:
	int WaitFor(HANDLE hEvent, DWORD dwTimeout);

protected:
    CFlexArray m_adwReaders;
	int m_nWriting;
	int m_nReading;
	int m_nWaitingToWrite;
	int m_nWaitingToRead;

	CRITICAL_SECTION m_csEntering;
	CRITICAL_SECTION m_csAll;
	HANDLE m_hCanWrite;
	HANDLE m_hCanRead;
};

class CAutoReadLock
{
public:
	CAutoReadLock(CLock *lock, BOOL bLock = TRUE) : m_lock(lock), m_bLocked(FALSE) { if (bLock) Lock(); }
	~CAutoReadLock() { Unlock(); }
	void Unlock() {if ( m_bLocked) { m_lock->ReadUnlock(); m_bLocked = FALSE; } }
	void Lock()   {if (!m_bLocked) { m_lock->ReadLock()  ; m_bLocked = TRUE; } }

private:
	CLock *m_lock;
	BOOL m_bLocked;
};
class CAutoWriteLock
{
public:
	CAutoWriteLock(CLock *lock, BOOL bLock = TRUE) : m_lock(lock), m_bLocked(FALSE) { if (bLock) Lock(); }
	~CAutoWriteLock() { Unlock(); }
	void Unlock() {if ( m_bLocked) { m_lock->WriteUnlock(); m_bLocked = FALSE; } }
	void Lock()   {if (!m_bLocked) { m_lock->WriteLock()  ; m_bLocked = TRUE; } }

private:
	CLock *m_lock;
	BOOL m_bLocked;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\internalmerger.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    INTERNALMERGER.H

Abstract:

    CInternalMerger class.

History:

	30-Nov-00   sanjes    Created.

--*/

#ifndef _INTERNALMERGER_H_
#define _INTERNALMERGER_H_

#include "mergerthrottling.h"
#include "wstlallc.h"

// Forward class definitions
class CWmiMergerRecord;

// Base class for merger sinks - all of these will be created by the
// merger and will AddRef() the merger.  The merger class will be used
// to create the sinks.  When the Merger is destroyed, it will delete
// all of the sink.  Internal Merger objects MUST NOT AddRef these sinks
// so we don't create a circular dependency.

typedef enum
{
	eMergerFinalSink,
	eMergerOwnSink,
	eMergerChildSink,
	eMergerOwnInstanceSink
} MergerSinkType;

class CMergerSink : public CBasicObjectSink
{
protected:
	CWmiMerger*	m_pMerger;
	long		m_lRefCount;

	virtual HRESULT OnFinalRelease( void ) = 0;

public:
	CMergerSink( CWmiMerger* pMerger );
	virtual ~CMergerSink();

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

	virtual HRESULT Indicate(long lObjectCount, IWbemClassObject** pObjArray, bool bLowestLevel, long* plNumIndicated ) = 0L;
};

class CMergerTargetSink : public CMergerSink
{
protected:
	IWbemObjectSink*	m_pDest;

	virtual HRESULT OnFinalRelease( void );

public:
	CMergerTargetSink( CWmiMerger* pMerger, IWbemObjectSink* pDest );
	~CMergerTargetSink();

    HRESULT STDMETHODCALLTYPE Indicate(long lObjectCount, IWbemClassObject** pObjArray);
    HRESULT STDMETHODCALLTYPE SetStatus( long lFlags, long lParam, BSTR strParam,
                             IWbemClassObject* pObjParam );

	// Function allows us to track the lowest level call in the merger so we can decide
	// if we need to automagically report all indicated objects to the arbitrator
	HRESULT Indicate(long lObjectCount, IWbemClassObject** pObjArray, bool bLowestLevel, long* plNumIndicated  );

};

// Causes the stl Map to use our allocator instead of the default

struct CInternalMergerRecord
{
    CWbemInstance* m_pData;
	DWORD m_dwObjSize;
    BOOL m_bOwn;
};

// Defines an allocator so we can throw exceptions
class CKeyToInstRecordAlloc : public wbem_allocator<CInternalMergerRecord>
{
};

inline bool operator==(const CKeyToInstRecordAlloc&, const CKeyToInstRecordAlloc&)
    { return (true); }
inline bool operator!=(const CKeyToInstRecordAlloc&, const CKeyToInstRecordAlloc&)
    { return (false); }

typedef	std::map<WString, CInternalMergerRecord, WSiless, CKeyToInstRecordAlloc>			MRGRKEYTOINSTMAP;
typedef	std::map<WString, CInternalMergerRecord, WSiless, CKeyToInstRecordAlloc>::iterator	MRGRKEYTOINSTMAPITER;

// This is the actual workhorse class for merging instances returned from
// queries.

class CInternalMerger
{
protected:

	// Helper class for scoped cleanup of memory usage
	class CScopedMemoryUsage
	{
		CInternalMerger*	m_pInternalMerger;
		bool				m_bCleanup;
		long				m_lMemUsage;

	public:
		CScopedMemoryUsage( CInternalMerger* pInternalMerger )
			: m_pInternalMerger( pInternalMerger ), m_bCleanup( false ), m_lMemUsage( 0L ) {};
		~CScopedMemoryUsage();

		HRESULT ReportMemoryUsage( long lMemUsage );
		HRESULT Cleanup( void );
	};

    class CMemberSink : public CMergerSink
    {
    protected:
        CInternalMerger*	m_pInternalMerger;

    public:
        CMemberSink( CInternalMerger* pMerger, CWmiMerger* pWmiMerger )
		: CMergerSink( pWmiMerger ), m_pInternalMerger( pMerger )
        {}

		STDMETHOD_(ULONG, AddRef)(THIS);

        STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);
    };
    friend CMemberSink;

    class COwnSink : public CMemberSink
    {
	protected:
		virtual HRESULT OnFinalRelease( void );

    public:
        COwnSink(CInternalMerger* pMerger, CWmiMerger* pWmiMerger) : CMemberSink(pMerger, pWmiMerger){};
        ~COwnSink();

        STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);

		// Function allows us to track the lowest level call in the merger so we can decide
		// if we need to automagically report all indicated objects to the arbitrator
		HRESULT Indicate(long lObjectCount, IWbemClassObject** pObjArray, bool bLowestLevel, long* plNumIndicated  );


    };
    friend COwnSink;

    class CChildSink : public CMemberSink
    {
	protected:
		virtual HRESULT OnFinalRelease( void );

    public:
        CChildSink(CInternalMerger* pMerger, CWmiMerger* pWmiMerger) : CMemberSink(pMerger, pWmiMerger){};
        ~CChildSink();

        STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);

		// Function allows us to track the lowest level call in the merger so we can decide
		// if we need to automagically report all indicated objects to the arbitrator
		HRESULT Indicate(long lObjectCount, IWbemClassObject** pObjArray, bool bLowestLevel, long* plNumIndicated );

    };

    class COwnInstanceSink : public CMemberSink
    {
		CCritSec			m_cs;
		WString				m_wsInstPath;
		IWbemClassObject*	m_pMergedInstance;
		bool				m_bTriedRetrieve;
		HRESULT				m_hFinalStatus;

	protected:
		virtual HRESULT OnFinalRelease( void );

    public:
        COwnInstanceSink(CInternalMerger* pMerger, CWmiMerger* pWmiMerger)
			:	CMemberSink(pMerger, pWmiMerger), m_pMergedInstance( NULL ), m_wsInstPath(),
				m_cs(), m_bTriedRetrieve( false ), m_hFinalStatus( WBEM_S_NO_ERROR )
		{};
        ~COwnInstanceSink();

        STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
        STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);

		// This should never be called here
		HRESULT Indicate(long lObjectCount, IWbemClassObject** pObjArray, bool bLowestLevel, long* plNumIndicated  );

		HRESULT	SetInstancePath( LPCWSTR pwszPath );
		HRESULT GetObject( IWbemClassObject** ppMergedInst );
		void SetFinalStatus( HRESULT hRes )
			{ if ( SUCCEEDED( m_hFinalStatus ) ) m_hFinalStatus = hRes; };
    };

    friend CChildSink;

public:

	// Helpers for creating sinks
	static HRESULT CreateMergingSink( MergerSinkType eType, CInternalMerger* pMerger, CWmiMerger* pWmiMerger, CMergerSink** ppSink );

	// 2 stage initialization
	HRESULT Initialize( void );

protected:
    COwnSink* m_pOwnSink;
    CChildSink* m_pChildSink;
    CMergerSink* m_pDest;

    BOOL m_bDerivedFromTarget;
    CWbemClass* m_pOwnClass;
    CWbemNamespace* m_pNamespace;
    IWbemContext* m_pContext;
	CWmiMergerRecord*	m_pWmiMergerRecord;

    MRGRKEYTOINSTMAP m_map;

    BOOL m_bOwnDone;
    BOOL m_bChildrenDone;
    WString m_wsClass;
    long m_lRef;

    IServerSecurity* m_pSecurity;

	// This is set when we encounter an error condition and are cancelled
	HRESULT	m_hErrorRes;

	// m_Throttler - sounds like a Supervillain...hmmm...
	CMergerThrottling	m_Throttler;

	// Helps debug how much data this internal merger is consuming
	long	m_lTotalObjectData;

	// Iterator which may require state to be kept
	MRGRKEYTOINSTMAPITER	m_DispatchOwnIter;

protected:
    HRESULT AddOwnObjects(long lObjectCount, IWbemClassObject** pObjArray, bool bLowestLevel, long* plNumIndicated  );
    HRESULT AddChildObjects(long lObjectCount, IWbemClassObject** pObjArray, bool bLowestLevel, long* plNumIndicated  );
	HRESULT AddOwnInstance( IWbemClassObject* pObj, LPCWSTR wszTargetKey,
							IWbemClassObject** ppMergedInstance);
	HRESULT	RemoveInstance( LPCWSTR pwszInstancePath );

	HRESULT GetObjectLength( IWbemClassObject* pObj, long* plObjectSize );

	// inline helper - adjusts throttler totals, then allows it to release itself if
	// apropriate
	void AdjustThrottle( long lNumParentObjects, long lNumChildObjects )
	{
		// Adjust the throttler now.
		m_Throttler.AdjustNumParentObjects( lNumParentObjects );
		m_Throttler.AdjustNumChildObjects( lNumChildObjects );

		// Let the Throttler release itself if it can
		m_Throttler.ReleaseThrottle();
	}

	// Helper function to perform Indicating and throttling - a lot of the code is more or
	// less the same so this at least attempts to encapsulate it.
	HRESULT IndicateArrayAndThrottle( long lObjectCount, CRefedPointerArray<IWbemClassObject>* pObjArray,
									CWStringArray* pwsKeyArray, long lMapAdjustmentSize, long lNewObjectSize, bool bThrottle,
									bool bParent, long* plNumIndicated );

    void Enter() { m_Throttler.Enter(); }
    void Leave() { m_Throttler.Leave(); }

    long AddRef();
    long Release();

    void OwnIsDone();
    void ChildrenAreDone();

    void DispatchChildren();
    void DispatchOwn();
    void GetKey(IWbemClassObject* pInst, WString& wsKey);
    HRESULT GetOwnInstance(LPCWSTR wszKey, IWbemClassObject** ppMergedInstance);
    BOOL IsDone() {return m_bOwnDone && m_bChildrenDone;}

	void AdjustLocalObjectSize( long lAdjust )
	{ 
		m_lTotalObjectData += lAdjust;
		_DBG_ASSERT( m_lTotalObjectData >= 0L );
	}

	HRESULT	ReportMemoryUsage( long lMemUsage );

public:
    CInternalMerger(CWmiMergerRecord*	pWmiMergerRecord, CMergerSink* pDest, CWbemClass* pOwnClass,
                CWbemNamespace* pNamespace = NULL,
                IWbemContext* pContext = NULL);
    ~CInternalMerger();

    void SetIsDerivedFromTarget(BOOL bIs);

	void Cancel( HRESULT hRes = WBEM_E_CALL_CANCELLED );

    CMergerSink* GetOwnSink() { if ( NULL != m_pOwnSink ) m_pOwnSink->AddRef(); return m_pOwnSink;}
    CMergerSink* GetChildSink() { if ( NULL != m_pChildSink ) m_pChildSink->AddRef(); return m_pChildSink; }

	CWmiMerger*	GetWmiMerger( void );

	// Helper to cancel a child sink when we don't need one (i.e. if we're fully static).
	void CancelChildSink( void )	{ ChildrenAreDone(); }
};

#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\internalmerger.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    INTERNALMERGER.CPP

Abstract:

    CInternalMerger class.

History:

	30-Nov-00   sanjes    Created.

--*/

#include "precomp.h"

#pragma warning (disable : 4786)
#include <wbemcore.h>
#include <map>
#include <vector>
#include <perfhelp.h>
#include <genutils.h>
#include <oahelp.inl>
#include <wqllex.h>
#include "wmimerger.h"
#include "internalmerger.h"

static	long	g_lNumMergers = 0L;

//***************************************************************************
//
//  class CInternalMerger
//
//  This class is a 'reverse fork'.  It consumes two sinks and outputs
//  one.  Its purpose is to merge instances of the same key in a given
//  dynasty.  Each CInternalMerger has two inputs, (a) instances of the class
//  in question, (b) instances of from another Merger representing
//  instances of subclasses.  Given classes A,B:A,C:B, for example,
//  where "<--" is a sink:
//
//      | own:Instances of A
//  <---|                 | own:Instances of B
//      | child: <--------|
//                        | child:Instances of C
//
//
//  The two input sinks for CInternalMerger are <m_pOwnSink> which receives
//  instances from the provider for "A", for example, and the <m_pChildSink>
//  which receives instances from the underyling Merger.
//
//  The mergers operate asynchronously to each other.  Therefore,
//  the instances for A may arrive in its CInternalMerger sink before instances
//  of the child classes have arrived in theirs.
//
//  As objects arrive in the owning CInternalMerger for a class, AddOwnObject()
//  is called.  As objects arrive from a child sink, AddChildObject()
//  is called.  In either case, if the object with a given key
//  arrives for the first time, it is simply added to the map. If
//  it is already there (via a key lookup), then a merge is performed
//  via CWbemInstance::AsymmetricMerge.  Immediately after this merge,
//  the object is dispatched up to the next parent sink via the parent's
//  AddChildObject and removed from the map.
//
//  Note that in a class hierarchy {A,B:A,C:B} an enumeration/query is
//  performed only against the classes in the CDynasty referenced in
//  the query. This logic occurs in CQueryEngine::EvaluateSubQuery.
//  For example, if "select * from B" is the query, only queries
//  for B and C are performed.  The CInternalMerger logic will do individual
//  'get object' calls for any instances needed in A to complete
//  the merged B/C instances while merging is taking place.
//
//***************************************************************************


#pragma warning(disable:4355)

static long g_lNumInternalMergers = 0L;

CInternalMerger::CInternalMerger(
	CWmiMergerRecord*	pWmiMergerRecord,
    CMergerSink* pDest,
    CWbemClass* pOwnClass,
    CWbemNamespace* pNamespace,
    IWbemContext* pContext
    )
    :   m_pDest(pDest), m_bOwnDone(FALSE),
        m_bChildrenDone(FALSE), m_pNamespace(pNamespace), m_pContext(pContext),
        m_pOwnClass(pOwnClass), m_bDerivedFromTarget(TRUE), m_lRef(0),
        m_pSecurity(NULL), m_pWmiMergerRecord( pWmiMergerRecord ),
		m_pOwnSink( NULL ), m_pChildSink( NULL ), m_hErrorRes( WBEM_S_NO_ERROR ),
		m_lTotalObjectData( 0L ), m_Throttler()
{
	// We do want to AddRef() in this case, since we will potentially be the only ones holding
	// onto the destination sink.  In this case, our child and owner sink will AddRef() us.  When
	// they perform a final release on us, we will release the destination sink.  If, on the other
	// hand we are outright deleted if this value is non-NULL we will clean up there as well
    m_pDest->AddRef();

    if(m_pContext)
        m_pContext->AddRef();
    if(m_pNamespace)
        m_pNamespace->AddRef();

    if(m_pOwnClass)
    {
        m_pOwnClass->AddRef();
        CVar v;
        if (SUCCEEDED(pOwnClass->GetClassName(&v)))
            m_wsClass = v.GetLPWSTR();
        // delegate Initialzie to check
    }

    // Retrieve call security. Need to create a copy for use on another thread
    // =======================================================================

    m_pSecurity = CWbemCallSecurity::MakeInternalCopyOfThread();

	// Keep the count up to date
	InterlockedIncrement( &g_lNumInternalMergers );
}

//***************************************************************************
//
//***************************************************************************

CInternalMerger::~CInternalMerger()
{
    if ( NULL != m_pDest )
	{
		m_pDest->Release();
		m_pDest = NULL;
	}

	// Map should be empty whenever we destruct
	_DBG_ASSERT( m_map.size() == 0 );
	_DBG_ASSERT( m_lTotalObjectData == 0L );

    if(m_pNamespace)
        m_pNamespace->Release();
    if(m_pContext)
        m_pContext->Release();
    if(m_pOwnClass)
        m_pOwnClass->Release();

    if(m_pSecurity)
        m_pSecurity->Release();

	// Keep the count up to date
	InterlockedDecrement( &g_lNumInternalMergers );
}
//***************************************************************************
//
//***************************************************************************

long CInternalMerger::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

//***************************************************************************
//
//***************************************************************************

long CInternalMerger::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);

	// On Final Release, we will clear up the actual destination sink
    if(lRef == 0)
	{
		// Enter the critical section, save off the sink pointer in a
		// temporary variable, set the member to NULL and then release
		// the sink.  This will prevent reentrancy issues with the merger
		// (e.g. during a Cancel).

		Enter();

		CMergerSink*	pSink = m_pDest;
		m_pDest = NULL;

		Leave();

		pSink->Release();
	}
    return lRef;
}

HRESULT CInternalMerger::Initialize( void )
{
    if (m_pOwnClass)
        if (NULL == (WCHAR *)m_wsClass)
            return WBEM_E_OUT_OF_MEMORY;
    
	HRESULT	hr = m_Throttler.Initialize();
	
	if ( SUCCEEDED( hr ) )
	{
		hr = m_pWmiMergerRecord->GetWmiMerger()->CreateMergingSink( eMergerOwnSink, NULL, this, (CMergerSink**) &m_pOwnSink );

		if ( SUCCEEDED( hr ) )
		{
			hr = m_pWmiMergerRecord->GetWmiMerger()->CreateMergingSink( eMergerChildSink, NULL, this, (CMergerSink**) &m_pChildSink );
		}

	}	// IF throttler initialized

	return hr;
}

//***************************************************************************
//
//***************************************************************************

void CInternalMerger::GetKey(IWbemClassObject* pObj, WString& wsKey)
{
    LPWSTR wszRelPath = ((CWbemInstance*)pObj)->GetRelPath();
    if (wszRelPath == NULL)
    {
        ERRORTRACE((LOG_WBEMCORE, "Object with no path submitted to a "
                        "merge\n"));
        wsKey.Empty();
        return;
    }

    WCHAR* pwcDot = wcschr(wszRelPath, L'.');
    if (pwcDot == NULL)
    {
        ERRORTRACE((LOG_WBEMCORE, "Object with invalid path %S submitted to a "
                        "merge\n", wszRelPath));
        wsKey.Empty();

        // Clean up the path
        delete [] wszRelPath;

        return;
    }

    wsKey = pwcDot+1;
    delete [] wszRelPath;
}

//***************************************************************************
//
//***************************************************************************

void CInternalMerger::SetIsDerivedFromTarget(BOOL bIs)
{
    m_bDerivedFromTarget = bIs;

    if (!bIs)
    {
        // We will need our OwnSink for GetObject calls
        // ============================================

        m_pOwnSink->AddRef();
    }
}

//
//	The algorithm for reporting memory usage is as follows:
//
//	Lowest level indicate (i.e. the one coming in from a provider), will iterate
//	all objects sent down by the provider and report them to the arbitrator.  At
//	the end of processing we will report the negative of this value.  Reason for
//	this is that we will be holding onto all of these objects for the length of
//	the function, and may get throttled at any time.
//
//	During processing, we will account for objects added to the map, and removed
//	from the map.  When we remove objects from the map, we add them to an array
//	which we indicate.  Usually we merge objects, sometimes we pass the objects
//	straight down.  We need to account for these objects during the call to
//	indicate, so we will total these and report usage BEFORE calling Indicate.
//	After Indicate returns we will remove their usage, since we will be releasing
//	them and hence no longer care about them.
//
//	Except for the case of the lowest level indicate, we will not account for
//	pass-through objects - those that are sent in and sent out.  It is assumed
//	that the calling function has accounted for these objects.
//
//	There will be small windows where a single object may get reported multiple
//	times.  This would occur if we reported a new object prior to indicate,
//	then in the call to indicate the merger added to the map, or the finalizer
//	added to its list.  When the call returns, we will report removal.  The object
//	may actually get removed on another thread, but if we get throttled, we
//	still need to account for it.  In tight memory conditions if multiple threads
//	cause addition/removal at jus tthe right times and are then throttled, we will
//	get stuck sleeping and each could report an object multiple times. However, this
//	should only occur in relatively stressful conditions, and should be rare.
//

//***************************************************************************
//
//***************************************************************************

HRESULT CInternalMerger::IndicateArrayAndThrottle(
	long lObjectCount, CRefedPointerArray<IWbemClassObject>* pObjArray,
	CWStringArray* pwsKeyArray, long lMapAdjustmentSize, long lNewObjectSize, bool bThrottle,
	bool bParent, long* plNumIndicated )
{
	// In this case, we report the size of the objects as they were adjusted in the map
	// in addition to new objects we created. The new objects will be released after
	// we indicate, so we will account for them post-indicate, since we will no longer
	// be holding onto them
	HRESULT	hRes = ReportMemoryUsage( lMapAdjustmentSize);

	// Use scoped memory cleanup to handle the new objects
	// Note that in the event of an exception this will cleanup properly
	CScopedMemoryUsage	scopedMemUsage( this );

	if ( SUCCEEDED( hRes ) )
	{
		hRes = scopedMemUsage.ReportMemoryUsage( lNewObjectSize );
	}

	// If the value is > 0L, and we succeeded, we can go ahead indicate the objects now.
	// The refed pointer array should properly clean up.

	if ( SUCCEEDED( hRes ) )
	{
		// If we have "own instances" in the array, we need to retrieve those objects.
		// Each is retrieved individually
		if ( NULL != pwsKeyArray && pwsKeyArray->Size() > 0 )
		{

			for ( int x = 0; SUCCEEDED( hRes ) && x < pwsKeyArray->Size(); x++ )
			{
				IWbemClassObject*	pMergedInstance = NULL;
				hRes = GetOwnInstance( pwsKeyArray->GetAt( x ), &pMergedInstance );
				CReleaseMe	rm( pMergedInstance );

				// If we retrieved a merged instance at this time, we should place it in
				// the array for indicating
				if ( SUCCEEDED( hRes ) && NULL != pMergedInstance )
				{
					// Handle object size here.  This is a merged object, so we must
					// account for it in the size variable

					long	lObjSize = 0L;
					hRes = GetObjectLength( pMergedInstance, &lObjSize );

					if ( SUCCEEDED( hRes ) )
					{
						if ( pObjArray->Add( pMergedInstance ) < 0L )
						{
							hRes = WBEM_E_OUT_OF_MEMORY;
							ERRORTRACE((LOG_WBEMCORE, "Add to array failed in IndicateArrayAndThrottle, hresult is 0x%x",
								hRes));
							continue;
						}

						lNewObjectSize += lObjSize;

						lObjectCount++;

						// Report size now, since each call to GetOwnInstance() may take some time
						hRes = scopedMemUsage.ReportMemoryUsage( lObjSize );

					}	// IF SUCCEEDED( hRes )

				}	// IF we retrieved an object

			}	// FOR enum WStringArray

		}	// IF need to retrieve OWN instances

		if ( SUCCEEDED( hRes ) )
		{
			// If we have stuff to indicate, we will trust that indicate to do
			// proper throttling.  Otherwise, the buck stops here, so we will
			// request throttling
			if ( lObjectCount > 0L )
			{
				// Not a lowest level indicate
				hRes = m_pDest->Indicate( lObjectCount, pObjArray->GetArrayPtr(), false, plNumIndicated );
			}

		}	// IF success after retrieving parent instances

	}	// IF SUCCESS after reporting memory usage

	// Release all Indicated objects here in order to reduce memory overhead in case
	// we sleep.
	pObjArray->RemoveAll();

	// Finally, since we are no longer really responsible for new objects, we
	// will report removal to the arbitrator now if appropriate, and catch any
	// errors as they come up.  We do this manually since we may end up
	// throttling for awhile

	HRESULT	hrTemp = scopedMemUsage.Cleanup();

	// If this failed and we previously had a success code, record the
	// failure

	if ( SUCCEEDED( hRes ) && FAILED( hrTemp ) )
	{
		hRes = hrTemp;
	}

	// Now, if we're *still* successful, and it is appropriate to
	// throttle, we should do merger specific throttling now if it
	// is enabled.
	if ( SUCCEEDED( hRes ) && bThrottle && m_pWmiMergerRecord->GetWmiMerger()->MergerThrottlingEnabled() )
	{
		hRes = m_Throttler.Throttle( bParent, m_pWmiMergerRecord );
	}

	return hRes;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CInternalMerger::AddOwnObjects(long lObjectCount, IWbemClassObject** pObjArray, bool bLowestLevel, long* plNumIndicated  )
{
	HRESULT hRes = S_OK ;

	// Ping the throttler
	m_Throttler.Ping( true, m_pWmiMergerRecord->GetWmiMerger() );

	// On the lowest level indicate, we will walk all of the objects and log them to the arbitrator
	// since we will effectively be holding them for the duration of this operation
	long		lIndicateSize = 0L;

	// Use scoped memory cleanup to handle the new objects
	// Note that in the event of an exception this will cleanup properly
	CScopedMemoryUsage	scopedMemUsage( this );

	if ( bLowestLevel )
	{
		for ( long lCtr = 0L; lCtr < lObjectCount; lCtr++ )
		{
			lIndicateSize += ((CWbemObject*) pObjArray[lCtr])->GetBlockLength();
		}

		// If we're going further, we also report the total size of the indicate, since we
		// may be sitting on the memory for awhile what with throttling and all.
		hRes = scopedMemUsage.ReportMemoryUsage( lIndicateSize );
	}

	// Used to track dispersion of objects so we can keep the throttler adjusted
	// properly
	long	lNumChildObjAdjust = 0L;
	long	lNumOwnObjAdjust = 0L;

	CRefedPointerArray<IWbemClassObject> objArray;
	long		lNumToIndicate = 0L;

	// Following variables track the memory size adjustments for the arbitrator and
	// batching
	long		lMapAdjustmentSize = 0L;
	long		lSizeMergedObjects = 0L;
	long		lBatchSize = 0L;

	// Scoped for proper cleanup if anything bad happens
    CCheckedInCritSec	ics( m_Throttler.GetCritSec() );

	// If we've been cancelled, then we should bail out.
	if ( SUCCEEDED( hRes ) )
	{
		if ( FAILED ( m_hErrorRes ) ) 
		{
			hRes = m_hErrorRes;
		}
		else
		{
			// We shouldn't be here if m_bOwnDone is set!
			_DBG_ASSERT( !m_bOwnDone );
			if ( m_bOwnDone )
			{
				hRes = WBEM_E_INVALID_OPERATION;
			}

		}
	}	// IF still in a success State

	try
	{

		for ( long	x = 0; SUCCEEDED( hRes ) && x < lObjectCount; x++ )
		{
			// If we've been cancelled, then we should bail out.
			// We need to do the check in here, since this loop can
			// exit and reeenter the critical section in the middle
			// of processing.
			if ( FAILED( m_hErrorRes ) )
			{
				hRes = m_hErrorRes;
				continue;
			}

			IWbemClassObject*	pObj = pObjArray[x];
			WString wsKey;

			// Track the size for batching
			lBatchSize += ((CWbemObject*) pObj)->GetBlockLength();

			GetKey(pObj, wsKey);

			MRGRKEYTOINSTMAPITER it = m_map.find(wsKey);
			if (it == m_map.end())
			{
				// Not there. Check if there is any hope for children
				// ==================================================

				if (m_bChildrenDone)
				{
					if (m_bDerivedFromTarget)
					{
						// We queue up all results for the ensuing indicate into a single batch we will
						// send down the line after we exit our critical section.  This is especially
						// important since we may get blocked during the call to indicate by the
						// finalizer.

						if ( objArray.Add( pObj ) < 0L )
						{
							hRes = WBEM_E_OUT_OF_MEMORY;
							ERRORTRACE((LOG_WBEMCORE, "Add to array failed in AddOwnObject, hresult is 0x%x",
								hRes));
							continue;
						}
						lNumToIndicate++;

					}
					else
					{
						// ignore
					}
				}
				else
				{
					// Insert
					CInternalMergerRecord& rRecord = m_map[wsKey];
					rRecord.m_pData = (CWbemInstance*) pObj;
					pObj->AddRef();
					rRecord.m_bOwn = TRUE;
					rRecord.m_dwObjSize = ((CWbemObject*)pObj)->GetBlockLength();

					// We just added a parent object to the map, so reflect that in the totals
					lNumOwnObjAdjust++;

					// Add since we are adding to the map
					lMapAdjustmentSize += rRecord.m_dwObjSize;

				}
			}
			else if(it->second.m_bOwn)
			{
				ERRORTRACE((LOG_WBEMCORE, "Provider supplied duplicate "
								"instances for key %S\n", wsKey));
			}
			else
			{
				// Attempt to merge
				// ================

				hRes = CWbemInstance::AsymmetricMerge(
									(CWbemInstance*)pObj,
									(CWbemInstance*)it->second.m_pData);
				if(FAILED(hRes))
				{
					ERRORTRACE((LOG_WBEMCORE, "Merge conflict for instances with "
						"key %S\n", wsKey));
					continue;
				}

				// We queue up all results for the ensuing indicate into a single batch we will
				// send down the line after we exit our critical section.  This is especially
				// important since we may get blocked during the call to indicate by the
				// finalizer.

				if ( objArray.Add( (IWbemClassObject*) it->second.m_pData ) < 0L )
				{
					hRes = WBEM_E_OUT_OF_MEMORY;
					ERRORTRACE((LOG_WBEMCORE, "Add to array failed in AddOwnObject, hresult is 0x%x",
						hRes));
					continue;
				}

				// Account for objects we have created/modified on the fly
				lSizeMergedObjects += ((CWbemObject*)it->second.m_pData)->GetBlockLength();
				lNumToIndicate++;

				// Subtract since we are removing from the map
				lMapAdjustmentSize -= it->second.m_dwObjSize;

				// Tricky
				// If Children are done and the DispatchOwnIter happens to be pointing
				// at the object we are about to erase, we should point it to the result
				// of the call to erase so we won't potentially access released memory
				// when DispatchOwn reenters its critical section

				bool	bSaveErase = false;

				if ( m_bChildrenDone )
				{
					bSaveErase = ( m_DispatchOwnIter == it );
				}

				it->second.m_pData->Release();

				if ( bSaveErase )
				{
					m_DispatchOwnIter = m_map.erase(it);
				}
				else
				{
					m_map.erase(it);
				}

				// We just removed a child object from the map, so reflect that in the totals
				lNumChildObjAdjust--;

			}

			if ( SUCCEEDED( hRes ) )
			{
				// If we have reached a complete batch, or reached the last object we need to
				// send stuff down the wire.
				if ( m_Throttler.IsCompleteBatch( lBatchSize ) || x == ( lObjectCount - 1 ) )
				{
					// Adjust total object size now.  Actual Arbitrator adjustment should occur outside a critical
					// section.  Note that we may not be in a critical section here, but that would be if something
					// happened when trying to retrieve an instance.  In that case, we'll be returning an error, so
					// the adjustment should be 0L anyway.
					_DBG_ASSERT( SUCCEEDED( hRes ) || lMapAdjustmentSize == 0L );
					AdjustLocalObjectSize( lMapAdjustmentSize );

					if ( SUCCEEDED( hRes ) )
					{
						// Adjust the throttler now.
						AdjustThrottle( lNumOwnObjAdjust, lNumChildObjAdjust );
					}

					// This object is smart enough to recognize if we've already left and not do
					// so again, if we have.
					ics.Leave();

					// Now go ahead and perform the indicate we've been leading ourselves up to
					if ( SUCCEEDED( hRes ) )
					{
						hRes = IndicateArrayAndThrottle( lNumToIndicate,
														&objArray, 
														NULL, 
														lMapAdjustmentSize,
														lSizeMergedObjects,
														true,
														true,	// Child
														plNumIndicated );

						// If we are in a success state and we have not enumerated all objects
						// we should reset the size counters and reenter the critical section
						if ( SUCCEEDED( hRes ) && x < ( lObjectCount ) - 1 )
						{
							lMapAdjustmentSize = 0L;
							lSizeMergedObjects = 0L;
							lBatchSize = 0L;
							lNumToIndicate = 0L;
							lNumOwnObjAdjust = 0L;
							lNumChildObjAdjust = 0L;

							ics.Enter();
						}
					}

				}	// IF we should send the objects out

			}	// IF we are in a success state

		}	// FOR enum objects

	}
	catch( CX_MemoryException )
	{
		hRes = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
        ExceptionCounter c;	
		hRes = WBEM_E_CRITICAL_ERROR;
	}

	// Check error one last time
	if ( FAILED( m_hErrorRes ) )
	{
		hRes = m_hErrorRes;
	}

	// We may have looped, entered the critical section and exited, so make
	// sure we force our way out in case we're about to cancel
	ics.Leave();

	// If we are the lowest level and no objects made it out of the merger
	// we will ask the arbitrator to throttle this call
	if ( SUCCEEDED( hRes ) && bLowestLevel && *plNumIndicated == 0L )
	{
		// Since we don't want the fact we're sleeping in the arbitrator to
		// cause the merger to cancel operations, we'll increase the count
		// of threads throttling, and decrement when we return
		m_pWmiMergerRecord->GetWmiMerger()->IncrementArbitratorThrottling();

		// If we get an error indicating we were throttled, that is okay
		hRes = m_pWmiMergerRecord->GetWmiMerger()->Throttle();

		m_pWmiMergerRecord->GetWmiMerger()->DecrementArbitratorThrottling();


		if ( WBEM_E_ARB_THROTTLE == hRes || WBEM_S_ARB_NOTHROTTLING == hRes )
		{
			hRes = WBEM_S_NO_ERROR;
		}
	}

	if ( hRes == WBEM_E_ARB_CANCEL )
	{
		hRes = WBEM_E_CALL_CANCELLED ;
	}
	
	// If we are in a failed state, nothing is going to matter from this point on,
	// so tell the merger to cancel all underlying sinks.
	if ( FAILED( hRes ) )
	{
		m_pWmiMergerRecord->GetWmiMerger()->Cancel( hRes );
	}

	return hRes;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CInternalMerger::AddChildObjects(long lObjectCount, IWbemClassObject** pObjArray, bool bLowestLevel, long* plNumIndicated )
{
	HRESULT hRes = S_OK ;

	// Ping the throttler
	m_Throttler.Ping( false, m_pWmiMergerRecord->GetWmiMerger() );

	// On the lowest level indicate, we will walk all of the objects and log them to the arbitrator
	// since we will effectively be holding them for the duration of this operation
	long		lIndicateSize = 0L;
	long		lTotalIndicated = 0L;

	// Use scoped memory cleanup to handle the new objects
	// Note that in the event of an exception this will cleanup properly
	CScopedMemoryUsage	scopedMemUsage( this );

	if ( bLowestLevel )
	{
		for ( long lCtr = 0L; lCtr < lObjectCount; lCtr++ )
		{
			lIndicateSize += ((CWbemObject*) pObjArray[lCtr])->GetBlockLength();
		}

		// If we're going further, we also report the total size of the indicate, since we
		// may be sitting on the memory for awhile what with throttling and all.
		hRes = scopedMemUsage.ReportMemoryUsage( lIndicateSize );
	}


	// Used to track dispersion of objects so we can keep the throttler adjusted
	// properly
	long	lNumChildObjAdjust = 0L;
	long	lNumOwnObjAdjust = 0L;

	CRefedPointerArray<IWbemClassObject> objArray;
	long		lNumToIndicate = 0L;

	// Following variables track the memory size adjustments for the arbitrator and
	// batching
	long		lMapAdjustmentSize = 0L;
	long		lSizeMergedObjects = 0L;
	long		lBatchSize = 0L;

	// Used to keep track of instance keys we need to retrieve using
	// GetOwnInstance
	CWStringArray	wsOwnInstanceKeyArray;

	// Scoped for proper cleanup if anything bad happens
    CCheckedInCritSec	ics( m_Throttler.GetCritSec() );

	// If we've been cancelled, then we should bail out.
	if ( SUCCEEDED( hRes ) )
	{
		if ( FAILED ( m_hErrorRes ) ) 
		{
			hRes = m_hErrorRes;
		}
		else
		{
			// We shouldn't be here if m_bChildrenDone is set!
			_DBG_ASSERT( !m_bChildrenDone );
			if ( m_bChildrenDone )
			{
				hRes = WBEM_E_INVALID_OPERATION;
			}

		}
	}	// IF still in a success State

	try
	{
		for ( long	x = 0; SUCCEEDED( hRes ) && x < lObjectCount; x++ )
		{

			// If we've been cancelled, then we should bail out.
			// We need to do the check in here, since this loop can
			// exit and reeenter the critical section in the middle
			// of processing.
			if ( FAILED( m_hErrorRes ) )
			{
				hRes = m_hErrorRes;
				continue;
			}

			IWbemClassObject*	pObj = pObjArray[x];
			
			// Track the size for batching
			lBatchSize += ((CWbemObject*) pObj)->GetBlockLength();

			WString wsKey;

			GetKey(pObj, wsKey);

			MRGRKEYTOINSTMAPITER it = m_map.find(wsKey);

			if (it == m_map.end())
			{
				// Check if there is any hope for parent
				// =====================================

				if(m_bOwnDone)
				{
	//				BSTR str = NULL;
	//				pObj->GetObjectText(0, &str);

					// The following was commented out because it actually incorrectly logs
					// an error if the child provider enumerates when the parent provider
					// interprets a query and returns fewer instances.  Neither provider is wrong,
					// but this error message causes needless worry.  In Quasar, we have to fix
					// this whole merger thing to be smarter anyway.
					//
					// ERRORTRACE((LOG_WBEMCORE, "[Chkpt_1] [%S] Orphaned object %S returned by "
					//    "provider\n", LPWSTR(m_wsClass), str));
	//				SysFreeString(str);
					// m_pDest->Add(pObj);
				}
				else
				{
					// insert

					CInternalMergerRecord& rRecord = m_map[wsKey];
					rRecord.m_pData = (CWbemInstance*)pObj;
					pObj->AddRef();
					rRecord.m_bOwn = FALSE;
					rRecord.m_dwObjSize = ((CWbemObject*)pObj)->GetBlockLength();

					// We just added a child object to the map, so reflect that in the totals
					lNumChildObjAdjust++;

					// Add since we are adding to the map
					lMapAdjustmentSize += rRecord.m_dwObjSize;

					// Check if parent's retrieval is needed
					// =====================================

					if (!m_bDerivedFromTarget)
					{

						// Add the instance name to the key array.  We will perform retrieval
						// of these parent instances *outside* of our critical section
						if ( wsOwnInstanceKeyArray.Add( wsKey ) != CFlexArray::no_error )
						{
							hRes = WBEM_E_OUT_OF_MEMORY;
						}

					}	// IF !m_bDerivedFromTarget

				 }
			}
			else if(!it->second.m_bOwn)
			{
				ERRORTRACE((LOG_WBEMCORE, "Two providers supplied conflicting "
								"instances for key %S\n", wsKey));
			}
			else
			{
				// Attempt to merge
				// ================

				hRes = CWbemInstance::AsymmetricMerge(
											(CWbemInstance*)it->second.m_pData,
											(CWbemInstance*)pObj
											);
				if (FAILED(hRes))
				{
					ERRORTRACE((LOG_WBEMCORE, "Merge conflict for instances with "
						"key %S\n", wsKey));
					continue;
				}

				// We queue up all results for the ensuing indicate into a single batch we will
				// send down the line after we exit our critical section.  This is especially
				// important since we may get blocked during the call to indicate by the
				// finalizer.

				if ( objArray.Add( pObj ) < 0L )
				{
					hRes = WBEM_E_OUT_OF_MEMORY;
					ERRORTRACE((LOG_WBEMCORE, "Add to array failed in AddChildObject, hresult is 0x%x",
						hRes));
					continue;
				}

				// Account for objects we have created on the fly
				lSizeMergedObjects += ((CWbemObject*) pObj)->GetBlockLength();
				lNumToIndicate++;

				// Subtract since we are removing from the map
				lMapAdjustmentSize -= it->second.m_dwObjSize;

				it->second.m_pData->Release();
				m_map.erase(it);

				// We just removed a parent object from the map, so reflect that in the totals
				lNumOwnObjAdjust--;

			}

			if ( SUCCEEDED( hRes ) )
			{
				// If we have reached a complete batch, or reached the last object we need to
				// send stuff down the wire.
				if ( m_Throttler.IsCompleteBatch( lBatchSize ) || x == ( lObjectCount - 1 ) )
				{
					// Adjust total object size now.  Actual Arbitrator adjustment should occur outside a critical
					// section.  Note that we may not be in a critical section here, but that would be if something
					// happened when trying to retrieve an instance.  In that case, we'll be returning an error, so
					// the adjustment should be 0L anyway.
					_DBG_ASSERT( SUCCEEDED( hRes ) || lMapAdjustmentSize == 0L );
					AdjustLocalObjectSize( lMapAdjustmentSize );

					if ( SUCCEEDED( hRes ) )
					{
						// Adjust the throttler now.
						AdjustThrottle( lNumOwnObjAdjust, lNumChildObjAdjust );
					}

					// This object is smart enough to recognize if we've already left and not do
					// so again, if we have.
					ics.Leave();

					// Now go ahead and perform the indicate we've been leading ourselves up to
					if ( SUCCEEDED( hRes ) )
					{
						hRes = IndicateArrayAndThrottle( lNumToIndicate,
														&objArray, 
														&wsOwnInstanceKeyArray, 
														lMapAdjustmentSize,
														lSizeMergedObjects,
														true,
														false,	// Child
														plNumIndicated
														);

						// If we are in a success state and we have not enumerated all objects
						// we should reset the size counters and reenter the critical section
						if ( SUCCEEDED( hRes ) && x < ( lObjectCount ) - 1 )
						{
							lMapAdjustmentSize = 0L;
							lSizeMergedObjects = 0L;
							lBatchSize = 0L;
							lNumToIndicate = 0L;
							lNumOwnObjAdjust = 0L;
							lNumChildObjAdjust = 0L;

							// Clear out the array
							wsOwnInstanceKeyArray.Empty();

							ics.Enter();
						}
					}

				}	// IF we should send the objects out

			}	// IF we are in a success state

		}	// FOR Enum Objects

	}
	catch( CX_MemoryException )
	{
		hRes = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
        ExceptionCounter c;	
		hRes = WBEM_E_CRITICAL_ERROR;
	}


	// Check error one last time
	if ( FAILED( m_hErrorRes ) )
	{
		hRes = m_hErrorRes;
	}

	// We may have looped, entered the critical section and exited, so make
	// sure we force our way out in case we're about to cancel
	ics.Leave();

	// If we are the lowest level and no objects made it out of the merger
	// we will ask the arbitrator to throttle this call
	if ( SUCCEEDED( hRes ) && bLowestLevel && *plNumIndicated == 0L )
	{
		// Since we don't want the fact we're sleeping in the arbitrator to
		// cause the merger to cancel operations, we'll increase the count
		// of threads throttling, and decrement when we return
		m_pWmiMergerRecord->GetWmiMerger()->IncrementArbitratorThrottling();

		// If we get an error indicating we were throttled, that is okay
		hRes = m_pWmiMergerRecord->GetWmiMerger()->Throttle();

		m_pWmiMergerRecord->GetWmiMerger()->DecrementArbitratorThrottling();


		if ( WBEM_E_ARB_THROTTLE == hRes || WBEM_S_ARB_NOTHROTTLING == hRes )
		{
			hRes = WBEM_S_NO_ERROR;
		}
	}

	if ( hRes == WBEM_E_ARB_CANCEL )
	{
		hRes = WBEM_E_CALL_CANCELLED ;
	}

	// If we are in a failed state, nothing is going to matter from this point on,
	// so tell the merger to cancel all underlying sinks.
	if ( FAILED( hRes ) )
	{
		m_pWmiMergerRecord->GetWmiMerger()->Cancel( hRes );
	}

    return hRes;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CInternalMerger::AddOwnInstance( IWbemClassObject* pObj, LPCWSTR pwszTargetPath, IWbemClassObject** ppMergedInstance)
{
	HRESULT hRes = S_OK ;
	WString wsKey;

	// Ping the throttler
	m_Throttler.Ping( true, m_pWmiMergerRecord->GetWmiMerger() );

	// Scoped for proper cleanup if anything bad happens
    CCheckedInCritSec	ics( m_Throttler.GetCritSec() );

	// If we've been cancelled, then we should bail out.
	if ( FAILED( m_hErrorRes ) )
	{
		hRes = m_hErrorRes;
	}

	GetKey(pObj, wsKey);

	// Find the instance - it should already be in the map.  If not, we shouldn't be
	// here

	long		lArbitratorAdjust = 0L;
	long		lNumChildObjAdjust = 0L;

	MRGRKEYTOINSTMAPITER it = m_map.find(wsKey);
	if (it != m_map.end())
	{
		// Attempt to merge
		// ================

		hRes = CWbemInstance::AsymmetricMerge(
							(CWbemInstance*)pObj,
							(CWbemInstance*)it->second.m_pData);

		if ( SUCCEEDED( hRes ) )
		{
			*ppMergedInstance = (IWbemClassObject*) it->second.m_pData;
			(*ppMergedInstance)->AddRef();

			// Subtract since we are removing from the map
			lArbitratorAdjust -= it->second.m_dwObjSize;

			it->second.m_pData->Release();
			m_map.erase(it);

			// We just removed a child object from the map, so reflect that in the totals
			lNumChildObjAdjust--;
		}
		else
		{
			ERRORTRACE((LOG_WBEMCORE, "Merge conflict for instances with "
				"key %S\n", wsKey));
		}

	}
	else
	{
		BSTR str = NULL;
		pObj->GetObjectText(0, &str);
		CSysFreeMe	sfm( str );

		// The provider has indicated an improper instance to an OwnInstance request.
		// We should always be able to find an instance in here.  We'll toss the instance
		// but we should output something to the error log since it sounds like
		// we have a broken provider
		//
		 ERRORTRACE((LOG_WBEMCORE, "Provider responded to request for instance %S, with object %S  not in map\n", pwszTargetPath, str ));
	}

	// Adjust total object size now.  Actual Arbitrator adjustment should occur outside a critical
	// section
	AdjustLocalObjectSize( lArbitratorAdjust );

	if ( SUCCEEDED( hRes ) )
	{
		// Adjust the throttler now.
		AdjustThrottle( 0L, lNumChildObjAdjust );
	}

	// This object is smart enough to recognize if we've already left and not do
	// so again, if we have.
	ics.Leave();

	// Always report adjustments
	hRes = ReportMemoryUsage( lArbitratorAdjust );

	// If we are in a failed state, nothing is going to matter from this point on,
	// so tell the merger to cancel all underlying sinks.
	if ( FAILED( hRes ) )
	{
		m_pWmiMergerRecord->GetWmiMerger()->Cancel( hRes );
	}

    return hRes;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CInternalMerger::RemoveInstance( LPCWSTR pwszTargetPath )
{
	HRESULT hRes = S_OK ;
	WString wsKey;

	// Track what we clean up
	long	lNumChildObjAdjust = 0L;
	long	lArbitratorAdjust = 0L;

	// Scoped for proper cleanup if anything bad happens
    CCheckedInCritSec	ics( m_Throttler.GetCritSec() );

	// If we've been cancelled, then we should bail out.
	if ( FAILED( m_hErrorRes ) )
	{
		hRes = m_hErrorRes;
	}

	// If the instance path is in our map, we should remove it
	MRGRKEYTOINSTMAPITER it = m_map.find( pwszTargetPath );
	if (it != m_map.end())
	{
		
		// Subtract since we are removing from the map
		lArbitratorAdjust -= it->second.m_dwObjSize;

		it->second.m_pData->Release();
		m_map.erase(it);

		// We just removed a child object from the map, so reflect that in the totals
		lNumChildObjAdjust--;
	}
	// Adjust total object size now.  Actual Arbitrator adjustment should occur outside a critical
	// section
	AdjustLocalObjectSize( lArbitratorAdjust );

	if ( SUCCEEDED( hRes ) )
	{
		// Adjust the throttler now.
		AdjustThrottle( 0L, lNumChildObjAdjust );
	}

	// This object is smart enough to recognize if we've already left and not do
	// so again, if we have.
	ics.Leave();

	// Always report adjustments (this should be negative).
	hRes = ReportMemoryUsage( lArbitratorAdjust );

	// If we are in a failed state, nothing is going to matter from this point on,
	// so tell the merger to cancel all underlying sinks.
	if ( FAILED( hRes ) )
	{
		m_pWmiMergerRecord->GetWmiMerger()->Cancel( hRes );
	}

    return hRes;
}

//***************************************************************************
//
//***************************************************************************

void CInternalMerger::DispatchChildren()
{
	long	lNumChildObjAdjust = 0L;
	long	lArbitratorAdjust = 0L;

	// Scoped for proper cleanup if anything bad happens
    CCheckedInCritSec	ics( m_Throttler.GetCritSec() );

    MRGRKEYTOINSTMAPITER it = m_map.begin();

    while (it != m_map.end())
    {
        if (!it->second.m_bOwn)
        {
//            BSTR str = NULL;
//            it->second.m_pData->GetObjectText(0, &str);

            // The following was commented out because it actually incorrectly logs
            // an error if the child provider enumerates when the parent provider
            // interprets a query and returns fewer instances.  Neither provider is wrong,
            // but this error message causes needless worry.  In Quasar, we have to fix
            // this whole merger thing to be smarter anyway.
            //

//            ERRORTRACE((LOG_WBEMCORE, "Chkpt2 [%S] Orphaned object %S returned by "
//                "provider\n", LPWSTR(m_wsClass), str));

//            SysFreeString(str);

            // m_pDest->Add(it->second.m_pData);

			// Subtract since we are removing from the map
			lArbitratorAdjust -= it->second.m_dwObjSize;

			// Tricky
			// If Children are done and the DispatchOwnIter happens to be pointing
			// at the object we are about to erase, we should point it to the result
			// of the call to erase so we won't potentially access released memory
			// when DispatchOwn reenters its critical section

			bool	bSaveErase = false;

			if ( m_bChildrenDone )
			{
				bSaveErase = ( m_DispatchOwnIter == it );
			}

			it->second.m_pData->Release();
			it = m_map.erase(it);

			if ( bSaveErase )
			{
				m_DispatchOwnIter = it;
			}

			// We are removing child objects, so we need to adjust the throttling
			// totals appropriately

			lNumChildObjAdjust--;
        }
        else it++;
    }

	// Adjust total object size now.  Actual Arbitrator adjustment should occur outside a critical
	// section
	AdjustLocalObjectSize( lArbitratorAdjust );

	// Apply the adjustment now.
	m_Throttler.AdjustNumChildObjects( lNumChildObjAdjust );

	// Mark the appropriate flags now this will also release throttling
    OwnIsDone();

	ics.Leave();

	// Always report adjustments
	HRESULT hrArbitrate = ReportMemoryUsage( lArbitratorAdjust );

	// If we get a failure we're over, the function will filter out noise, such as
	// requests to throttle (we're should actually *always* decrease the value here)
	if ( FAILED( hrArbitrate ) )
	{
		m_pWmiMergerRecord->GetWmiMerger()->Cancel( hrArbitrate );
	}

}

//***************************************************************************
//
//***************************************************************************

void CInternalMerger::DispatchOwn()
{
/*
	HRESULT	hRes = S_OK;
	long	lNumOwnObjAdjust = 0L;

	CRefedPointerArray<IWbemClassObject> objArray;
	long		lNumToIndicate = 0L;

	// Used for tracking object sizes
	long		lMapAdjust = 0L;
	long		lBatchSize = 0L;

	// Used to track full cleanup in case an error occurs
	// after we transferred objects out of the map and into
	// the tempArray.  This way, we will ensure that we
	// fully account for objects that were in the map.
	long		lTotalObjSizeAdjust = 0L;
	long		lTotalMapAdjust = 0L;

	// Scoped for proper cleanup if anything bad happens
    CCheckedInCritSec	ics( m_Throttler.GetCritSec() );

	// Temporary storage for elements when we remove them from
	// the array
	CRefedPointerArray<IWbemClassObject> tempArray;
	long*	plSizeArray = NULL;

	// Only need this if we will be storing values
	if ( m_bDerivedFromTarget )
	{
		plSizeArray = new long[m_map.size()];

		// Check for OOM
		if ( NULL == plSizeArray )
		{
			hRes = WBEM_E_OUT_OF_MEMORY;
		}

	}
	CVectorDeleteMe<long>	vdm1( plSizeArray );

	try
	{

		// Walk the map, and for all own objects, store the pointer and record the size, then
		// clear the element from the map.  None of these objects should be merged, but we want
		// them out of the map before we start batch processing them
		MRGRKEYTOINSTMAPITER it = m_map.begin();
		int	x = 0;
		int y = 0;

		while ( it != m_map.end())
		{
			// If we are not derived from the target class, this more or less
			// just cleans up the array.  Otherwise, instances left in the map
			// are instances provided at this level, but not by children, so we
			// need to send them up the line with an Indicate

			if(it->second.m_bOwn)
			{
				// If we are not derived from the target class, this more or less
				// just cleans up the array.  Otherwise, instances left in the map
				// are instances provided at this level, but not by children, so we
				// need to send them up the line with an Indicate

				if ( m_bDerivedFromTarget )
				{
					// Place the totals in the array
					plSizeArray[y++] = it->second.m_dwObjSize;

					// We queue up all results for the ensuing indicate into a single batch we will
					// send down the line after we exit our critical section.  This is especially
					// important since we may get blocked during the call to indicate by the
					// finalizer.
					if ( tempArray.Add( it->second.m_pData ) < 0L )
					{
						if ( SUCCEEDED( hRes ) )
						{
							hRes = WBEM_E_OUT_OF_MEMORY;
							ERRORTRACE((LOG_WBEMCORE, "Add to array failed in AddChildObject, hresult is 0x%x",
								hRes));
							continue;
						}
					}

				}	// IF m_bDerivedFromTarget

				// Adjust both sizes (we keep it as a negative)
				lTotalObjSizeAdjust -= it->second.m_dwObjSize;
				lTotalMapAdjust -= it->second.m_dwObjSize;

				it->second.m_pData->Release();
				it = m_map.erase(it);

				// We are removing "Own" objects, so we need to adjust the throttler accordingly
				lNumOwnObjAdjust--;

			}	// IF !m_bOwn
			else
			{
				it++;
			}
		}

		// If anything failed, or we are just cleaning up, account for it now
		if ( FAILED( hRes ) || !m_bDerivedFromTarget )
		{
			// Adjust total object size now.  Actual Arbitrator adjustment should occur outside a critical
			// section
			AdjustLocalObjectSize( lTotalObjSizeAdjust );

			// Apply the adjustment now.
			m_Throttler.AdjustNumParentObjects( lTotalObjSizeAdjust );
		}

		// Mark the appropriate flags now this will also release throttling
		ChildrenAreDone();

		// No need to continue if we didn't stash any objects
		if ( FAILED( hRes ) || !m_bDerivedFromTarget )
		{
			// Any further code MUST be executed outside of a critical
			// section
			ics.Leave();

			if ( lTotalObjSizeAdjust != 0L )
			{
				ReportMemoryUsage( lTotalObjSizeAdjust );
			}

			return;
		}

		// Start this again
		lMapAdjust = 0L;
		lNumOwnObjAdjust = 0L;

		for ( x = 0; SUCCEEDED( hRes ) && x < tempArray.GetSize(); x++ )
		{
			// If we've been cancelled, then we should bail out.
			// We need to do the check in here, since this loop can
			// exit and reeenter the critical section in the middle
			// of processing.
			if ( FAILED( m_hErrorRes ) )
			{
				hRes = m_hErrorRes;
			}

			// Adjust for the size of the object
			lMapAdjust -= plSizeArray[x];
			lBatchSize += plSizeArray[x];

			// We queue up all results for the ensuing indicate into a single batch we will
			// send down the line after we exit our critical section.  This is especially
			// important since we may get blocked during the call to indicate by the
			// finalizer.
			if ( objArray.Add( tempArray[x] ) < 0L )
			{
				hRes = WBEM_E_OUT_OF_MEMORY;
				ERRORTRACE((LOG_WBEMCORE, "Add to array failed in AddChildObject, hresult is 0x%x",
					hRes));
				continue;
			}
			else
			{
				// Clear the element in the temporary array
				tempArray.SetAt( x, NULL );
			}
			lNumToIndicate++;

			// Subtract here
			lNumOwnObjAdjust--;

			// If we have reached a complete batch, or reached the last object we need to
			// send stuff down the wire.
			if ( m_Throttler.IsCompleteBatch( lBatchSize ) || x == ( tempArray.GetSize() - 1 ) )
			{

				// Adjust total object size now.  Actual Arbitrator adjustment should occur outside a critical
				// section
				AdjustLocalObjectSize( lMapAdjust );

				// Keep this guy in sync since we reported it now, we don't want to overreport
				// if the call to the actual arbitrator fails.
				lTotalMapAdjust -= lMapAdjust;

				// Apply the adjustment now.
				m_Throttler.AdjustNumParentObjects( lNumOwnObjAdjust );

				// This object is smart enough to recognize if we've already left and not do
				// so again, if we have.
				ics.Leave();

				// Now go ahead and perform the indicate we've been leading ourselves up to, adjustment
				// will be negative, but conversely, we'll be holding onto that size of objects if anything
				// is indicated, so call as follows...oh yeah, and don't throttle explicitly
				if ( SUCCEEDED( hRes ) )
				{
					hRes = IndicateArrayAndThrottle( lNumToIndicate,
													&objArray, 
													NULL, 
													lMapAdjust,
													-lMapAdjust,
													false,
													false,	// no throttling here
													NULL
													);

					// This will subtract the reported adjustment from the total object
					// size.  If any errors occur, we will report the total remaining object
					// size to the arbitrator to ensure all memory is acounted for.
					lTotalObjSizeAdjust -= lMapAdjust;

					// If we are in a success state and we have not enumerated all objects
					// we should reset the size counters and reenter the critical section
					if ( SUCCEEDED( hRes ) && x < ( tempArray.GetSize() - 1 ) )
					{
						lMapAdjust = 0L;
						lBatchSize = 0L;
						lNumToIndicate = 0L;
						lNumOwnObjAdjust = 0L;

						ics.Enter();
					}

				}

			}	// IF SUCCEEDED()


		}	// FOR enum objects

	}	// try
	catch(...)
	{
        ExceptionCounter c;	
	}

	// If we're here, something went wrong.  Ensure that we cleanup unreported 
	// sizes at this time.
	if ( FAILED( hRes ) )
	{
		if ( lTotalMapAdjust != 0L )
		{
			AdjustLocalObjectSize( lTotalMapAdjust );
		}

		// Any further code MUST be executed outside of a critical
		// section
		ics.Leave();

		if ( lTotalObjSizeAdjust != 0L )
		{
			ReportMemoryUsage( lTotalObjSizeAdjust );
		}

		// If we are in a failed state, nothing is going to matter from this point on,
		// so tell the merger to cancel all underlying sinks.
		m_pWmiMergerRecord->GetWmiMerger()->Cancel( hRes );

	}
*/

	HRESULT	hRes = S_OK;
	long	lNumOwnObjAdjust = 0L;

	// Temporary object storage
	CRefedPointerArray<IWbemClassObject> objArray;

	// Used for tracking object sizes
	long		lTotalMapAdjust = 0L;

	// Scoped for proper cleanup if anything bad happens
    CCheckedInCritSec	ics( m_Throttler.GetCritSec() );

	// Mark the appropriate flags now this will also release throttling
	ChildrenAreDone();

	try
	{

		// Walk the map, and for all own objects, store the pointer and record the size, then
		// clear the element from the map.  None of these objects should be merged, but we want
		// them out of the map before we start batch processing them

		// We use a member variable since we may leave a critical section while iterating
		// and it is possible for AddOwnObject or Cancel to cause the iterator to be cleared
		// before we reenter the critical section - This is the only please we have code
		// like this
		m_DispatchOwnIter = m_map.begin();
		int	x = 0;
		int y = 0;

		while ( SUCCEEDED( hRes ) && m_DispatchOwnIter != m_map.end())
		{
			// If we are not derived from the target class, this more or less
			// just cleans up the array.  Otherwise, instances left in the map
			// are instances provided at this level, but not by children, so we
			// need to send them up the line with an Indicate

			if(m_DispatchOwnIter->second.m_bOwn)
			{
				IWbemClassObject*	pObjToIndicate = NULL;
				long				lMapAdjust = 0L;

				// If we are not derived from the target class, this more or less
				// just cleans up the array.  Otherwise, instances left in the map
				// are instances provided at this level, but not by children, so we
				// need to send them up the line with an Indicate

				if ( m_bDerivedFromTarget )
				{
					// We will actually just go one object at a time.
					if ( objArray.Add( m_DispatchOwnIter->second.m_pData ) < 0L )
					{
						hRes = WBEM_E_OUT_OF_MEMORY;
						ERRORTRACE((LOG_WBEMCORE, "Add to array failed in AddChildObject, hresult is 0x%x",
							hRes));
						continue;
					}

					lMapAdjust -= m_DispatchOwnIter->second.m_dwObjSize;

					// Store the actual adjustment size
				}	// IF m_bDerivedFromTarget

				// Adjust the total map size (this is in case we are not derived from
				// target and are just removing objects).
				lTotalMapAdjust -= m_DispatchOwnIter->second.m_dwObjSize;

				m_DispatchOwnIter->second.m_pData->Release();
				m_DispatchOwnIter = m_map.erase(m_DispatchOwnIter);

				// Apply the object adjustment now.
				m_Throttler.AdjustNumParentObjects( -1 );

				if ( objArray.GetSize() > 0L )
				{
					// Adjust total object size now.  Actual Arbitrator adjustment should occur outside a critical
					// section
					AdjustLocalObjectSize( lMapAdjust );

					// This object is smart enough to recognize if we've already left and not do
					// so again, if we have.
					ics.Leave();

					// Now go ahead and perform the indicate we've been leading ourselves up to, adjustment
					// will be negative, but conversely, we'll be holding onto that size of objects if anything
					// is indicated, so call as follows...oh yeah, and don't throttle explicitly
					if ( SUCCEEDED( hRes ) )
					{
						hRes = IndicateArrayAndThrottle( 1,
														&objArray, 
														NULL, 
														lMapAdjust,
														-lMapAdjust,
														false,
														false,	// no throttling here
														NULL
														);

						// If we are in a success state we should reenter the critical section
						if ( SUCCEEDED( hRes ) )
						{
							ics.Enter();
						}
					}

				}	// IF NULL != pObjToIndicate

			}	// IF !m_bOwn
			else
			{
				m_DispatchOwnIter++;
			}

		}	// WHILE enuming objects


	}	// try
	catch(...)
	{
        ExceptionCounter c;	
	}

	if ( !m_bDerivedFromTarget )
	{
		// Adjust total object size now.  Actual Arbitrator adjustment should occur outside a critical
		// section.
		AdjustLocalObjectSize( lTotalMapAdjust );
	}

	// Any further code MUST be executed outside of a critical
	// section
	ics.Leave();

	if ( !m_bDerivedFromTarget )
	{
		// Report to the arbitrator now.

		if ( 0L != lTotalMapAdjust )
		{
			ReportMemoryUsage( lTotalMapAdjust );
		}
	}

	// If something went wrong, we need to cancel at this point.
	if ( FAILED( hRes ) )
	{
		// If we are in a failed state, nothing is going to matter from this point on,
		// so tell the merger to cancel all underlying sinks.
		m_pWmiMergerRecord->GetWmiMerger()->Cancel( hRes );

	}

}

//***************************************************************************
//
//***************************************************************************

HRESULT CInternalMerger::GetOwnInstance(LPCWSTR wszKey, IWbemClassObject** ppMergedInstance)
{
	HRESULT	hRes = WBEM_S_NO_ERROR;

	if (NULL == wszKey)
		return WBEM_E_OUT_OF_MEMORY;
    
    LPWSTR wszPath = new WCHAR[wcslen(wszKey) + m_wsClass.Length() + 2];
    if (NULL == wszPath)
		return WBEM_E_OUT_OF_MEMORY;

    if (wcslen(wszKey))
    {
        swprintf(wszPath, L"%s.%s", (LPCWSTR)m_wsClass, wszKey);


        {

			CAutoImpersonate ai;

			COwnInstanceSink*	pOwnInstanceSink = NULL;

			hRes = m_pWmiMergerRecord->GetWmiMerger()->CreateMergingSink( eMergerOwnInstanceSink,
						NULL, this, (CMergerSink**) &pOwnInstanceSink );

			if ( SUCCEEDED( hRes ) )
			{
				// Scoped release
				pOwnInstanceSink->AddRef();
				CReleaseMe	rm( pOwnInstanceSink );

				hRes = pOwnInstanceSink->SetInstancePath( wszKey );

				if ( SUCCEEDED( hRes ) )
				{
					// Impersonate original client
					// ===========================
					IUnknown* pOld;
					WbemCoSwitchCallContext(m_pSecurity, &pOld);
        

					hRes = m_pNamespace->DynAux_GetSingleInstance(m_pOwnClass, 0, wszPath,
																m_pContext, pOwnInstanceSink
																);

					// Revert to self
					// ==============
					IUnknown* pThis;
					WbemCoSwitchCallContext(pOld, &pThis);

					if ( SUCCEEDED( hRes ) )
					{
						hRes = pOwnInstanceSink->GetObject( ppMergedInstance );

						// Means there was no object to retrieve
						if ( WBEM_S_FALSE == hRes )
						{
							hRes = WBEM_S_NO_ERROR;
						}
					}
					else if ( WBEM_E_NOT_FOUND == hRes )
					{
						// In this case, this is really not an error
						hRes = WBEM_S_NO_ERROR;
					}
				}

			}	// If created sink

			if ( FAILED ( ai.Impersonate ( ) ) )
			{
				hRes = WBEM_E_FAILED ;
			}
		}	// AutoImpersonate

    }

    delete [] wszPath;

	return hRes;
}

//***************************************************************************
//
//***************************************************************************

void CInternalMerger::OwnIsDone()
{
	// Let the throttler know what's up
	m_Throttler.SetParentDone();

    m_bOwnDone = TRUE;
    m_pOwnSink = NULL;
}

//***************************************************************************
//
//***************************************************************************

void CInternalMerger::ChildrenAreDone()
{
	// Let the throttler know what's up
	m_Throttler.SetChildrenDone();

    m_bChildrenDone = TRUE;
    m_pChildSink = NULL;

    if(!m_bDerivedFromTarget)
    {
        // Don't need that ref count on pOwnSink anymore
        // =============================================

        m_pOwnSink->Release();
    }
}


//***************************************************************************
//
//***************************************************************************

HRESULT CInternalMerger::GetObjectLength( IWbemClassObject* pObj, long* plObjectSize )
{
	_IWmiObject*	pWmiObject = NULL;

	HRESULT			hr = pObj->QueryInterface( IID__IWmiObject, (void**) &pWmiObject );

	if ( SUCCEEDED( hr ) )
	{
		CReleaseMe		rm1( pWmiObject );
		CWbemObject*	pWbemObj = NULL;

		hr = pWmiObject->_GetCoreInfo( 0L, (void**) &pWbemObj );

		if ( SUCCEEDED( hr ) )
		{
			CReleaseMe	rm2( (IWbemClassObject*) pWbemObj );
			*plObjectSize = pWbemObj->GetBlockLength();
		}
	}

	return hr;
}

//***************************************************************************
//
//***************************************************************************
//
ULONG CInternalMerger::CMemberSink::AddRef()
{
	// We keep an internal ref count and also pass up to the
	// merger

	// On first reference we AddRef() the internal merger as well

	// Note that our internal ref count is really a bookkeeping count on
	// the sink.  The actual ref count that controls the destruction is
	// that on the merger.  When the merger hits zero the sink will be deleted
	if ( InterlockedIncrement( &m_lRefCount ) == 1 )
	{
		m_pInternalMerger->AddRef();
	}

    return m_pMerger->AddRef();
}

//***************************************************************************
//
//***************************************************************************


STDMETHODIMP CInternalMerger::CMemberSink::
SetStatus(long lFlags, long lParam, BSTR strParam, IWbemClassObject* pObjParam)
{

    if(lFlags == 0 && lParam == WBEM_E_NOT_FOUND)
        lParam = WBEM_S_NO_ERROR;

    // Propagate error to error combining sink
    // =======================================

    HRESULT	hRes =  m_pInternalMerger->m_pDest->SetStatus(lFlags, lParam, strParam,
													pObjParam);

	if ( FAILED ( hRes ) || !SUCCEEDED( lParam ) )
	{
		HRESULT	hrSet = ( FAILED( hRes ) ? hRes : lParam );
		m_pInternalMerger->m_pWmiMergerRecord->GetWmiMerger()->Cancel( hrSet );
	}

	return hRes;
}

//***************************************************************************
//
//***************************************************************************

CInternalMerger::COwnSink::~COwnSink()
{
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CInternalMerger::COwnSink::
Indicate(long lNumObjects, IWbemClassObject** apObjects)
{
	long	lNumIndicated = 0L;

	// Internal calls don't use this, so we know we're the lowest level
	return m_pInternalMerger->AddOwnObjects( lNumObjects, apObjects, true, &lNumIndicated );
}

//***************************************************************************
//
//***************************************************************************

HRESULT CInternalMerger::COwnSink::
Indicate(long lObjectCount, IWbemClassObject** pObjArray, bool bLowestLevel, long* plNumIndicated  )
{
	// Really just a place holder here.  Just call the standard version
	return m_pInternalMerger->AddOwnObjects( lObjectCount, pObjArray, bLowestLevel, plNumIndicated  );
}

//***************************************************************************
//
//***************************************************************************

HRESULT CInternalMerger::COwnSink::OnFinalRelease( void )
{
	// Final cleanup occurs here.

    m_pInternalMerger->DispatchChildren();
	m_pInternalMerger->Release();

	return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

CInternalMerger::CChildSink::~CChildSink()
{
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CInternalMerger::CChildSink::
Indicate(long lNumObjects, IWbemClassObject** apObjects)
{
	long	lNumIndicated = 0L;

	// Internal calls don't use this, so we know we're the lowest level
	return m_pInternalMerger->AddChildObjects( lNumObjects, apObjects, true, &lNumIndicated );
}

//***************************************************************************
//
//***************************************************************************

HRESULT CInternalMerger::CChildSink::
Indicate(long lObjectCount, IWbemClassObject** pObjArray, bool bLowestLevel, long* plNumIndicated  )
{
	// Pass the lowest level parameter on
	return m_pInternalMerger->AddChildObjects( lObjectCount, pObjArray, bLowestLevel, plNumIndicated );
}

//***************************************************************************
//
//***************************************************************************

HRESULT CInternalMerger::CChildSink::OnFinalRelease( void )
{
	// Final cleanup occurs here.

    m_pInternalMerger->DispatchOwn();
	m_pInternalMerger->Release();

	return WBEM_S_NO_ERROR;

}

//***************************************************************************
//
//***************************************************************************

HRESULT CInternalMerger::CreateMergingSink( MergerSinkType eType, CInternalMerger* pMerger, CWmiMerger* pWmiMerger, CMergerSink** ppSink )
{
	if ( eType == eMergerOwnSink )
	{
		*ppSink = new COwnSink( pMerger, pWmiMerger );
	}
	else if ( eType == eMergerChildSink )
	{
		*ppSink = new CChildSink( pMerger, pWmiMerger );
	}
	else if ( eType == eMergerOwnInstanceSink )
	{
		*ppSink = new COwnInstanceSink( pMerger, pWmiMerger );
	}

	return ( NULL == *ppSink ? WBEM_E_OUT_OF_MEMORY : WBEM_S_NO_ERROR );
}

// Sets our error state, and cleans up objects we're holding onto -
// no further objects should get in.  When we cancel the throttler,
// it will release any threads it is holding onto.

void CInternalMerger::Cancel( HRESULT hRes /* = WBEM_E_CALL_CANCELLED */ )
{
	long	lArbitratorAdjust = 0L;

	// Scoped for proper cleanup if anything bad happens
    CCheckedInCritSec	ics( m_Throttler.GetCritSec() );

	// Only cancel if we're not already cancelled
	if ( WBEM_S_NO_ERROR == m_hErrorRes )
	{
		m_hErrorRes = hRes;

		// Dump the map
		MRGRKEYTOINSTMAPITER it = m_map.begin();

		while ( it != m_map.end())
		{
			// Subtract since we are removing from the map
			lArbitratorAdjust -= it->second.m_dwObjSize;

			// Inform the arbitrator of the removed object size
			it->second.m_pData->Release();
			it = m_map.erase(it);
		}	// WHILE dumping map

		// Adjust total object size now.  Actual Arbitrator adjustment should occur outside a critical
		// section
		AdjustLocalObjectSize( lArbitratorAdjust );

		// This will prevent DispatchOwn() from continuing with a now bogus
		// iteration
		m_DispatchOwnIter = m_map.end();

		m_Throttler.Cancel();

		ics.Leave();

		// Always report adjustments
		HRESULT hrArbitrate = ReportMemoryUsage( lArbitratorAdjust );

		// No sense reporting errors here, since we've just told the arbitrator to cancel anyway

	}	// IF not already cancelled

}

HRESULT	CInternalMerger::ReportMemoryUsage( long lMemUsage )
{
	// Always report adjustments
	HRESULT hRes = m_pWmiMergerRecord->GetWmiMerger()->ReportMemoryUsage( lMemUsage );

	// An indication we *should* throttle is not considered an error for purposes
	// of this function.
	if ( WBEM_E_ARB_THROTTLE == hRes || WBEM_S_ARB_NOTHROTTLING == hRes )
	{
		hRes = WBEM_S_NO_ERROR;
	}

	return hRes;
}

//***************************************************************************
//
//  CMergerSink::QueryInterface
//
//  Exports IWbemOnjectSink interface.
//
//***************************************************************************

STDMETHODIMP CMergerSink::QueryInterface(
    IN REFIID riid,
    OUT LPVOID *ppvObj
    )
{
    *ppvObj = 0;

    if (IID_IUnknown==riid || IID_IWbemObjectSink==riid)
    {
        *ppvObj = (IWbemObjectSink*)this;
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}

//***************************************************************************
//
//***************************************************************************
//
ULONG CMergerSink::AddRef()
{
	// We keep an internal ref count and also pass up to the
	// merger
	InterlockedIncrement( &m_lRefCount );

    return m_pMerger->AddRef();
}

//***************************************************************************
//
//***************************************************************************
//
ULONG CMergerSink::Release()
{
	// We keep an internal ref count and also pass up to the
	// merger
	long	lRef = InterlockedDecrement( &m_lRefCount );

	// Ref Count should never go below 0L
	_DBG_ASSERT( lRef >= 0 );

	// If we are at the final release for the sink, we will perform cleanup.
	// otherwise, the sink is more or less dead and just waiting for the WMI
	// Merger object to be destructed so we get cleaned up.
	if ( lRef == 0 )
	{
		OnFinalRelease();
	}

    return m_pMerger->Release();
}

CMergerTargetSink::CMergerTargetSink( CWmiMerger* pMerger, IWbemObjectSink* pDest )
:	CMergerSink( pMerger ),
	m_pDest( pDest )
{
	if ( NULL != m_pDest )
	{
		m_pDest->AddRef();
	}
}

CMergerTargetSink::~CMergerTargetSink()
{
	if ( NULL != m_pDest )
	{
		m_pDest->Release();
	}
}

HRESULT STDMETHODCALLTYPE CMergerTargetSink::Indicate(long lObjectCount, IWbemClassObject** pObjArray)
{
	// Since we don't want the fact we're sleeping in the arbitrator to
	// cause the merger to cancel operations, we'll increase the count
	// of threads throttling, and decrement when we return.

	// We do this here because the call to Indicate goes outside the scope
	// of the merger, and this call may end up throttling.

	m_pMerger->IncrementArbitratorThrottling();

	HRESULT	hr = m_pDest->Indicate( lObjectCount, pObjArray );

	m_pMerger->DecrementArbitratorThrottling();

	return hr;
}

HRESULT STDMETHODCALLTYPE CMergerTargetSink::SetStatus( long lFlags, long lParam, BSTR strParam,
														IWbemClassObject* pObjParam )
{
	return m_pDest->SetStatus( lFlags, lParam, strParam, pObjParam );
}

HRESULT CMergerTargetSink::Indicate(long lObjectCount, IWbemClassObject** pObjArray, bool bLowestLevel, long* plNumIndicated )
{
	// Well, we're indicating this number of objects, aren't we?
	if ( NULL != plNumIndicated )
	{
		*plNumIndicated = lObjectCount;
	}

	// Really just a place holder here.  Just call the standard version
	return Indicate( lObjectCount, pObjArray );
}

HRESULT CMergerTargetSink::OnFinalRelease( void )
{
	// This is where we will send the actual status *and* tell the merger we're done
	return m_pMerger->Shutdown();
}

long	g_lNumMergerSinks = 0L;

CMergerSink::CMergerSink( CWmiMerger* pMerger )
: m_pMerger( pMerger ), m_lRefCount( 0L )
{
	InterlockedIncrement( &g_lNumMergerSinks );
}

CMergerSink::~CMergerSink( void )
{
	InterlockedDecrement( &g_lNumMergerSinks );
}

// OwnInstance Sink
CInternalMerger::COwnInstanceSink::~COwnInstanceSink()
{
	if ( NULL != m_pMergedInstance )
	{
		m_pMergedInstance->Release();
	}
}

// Called in response to a request for GetObject().  In this case, there should be only
// one object indicated.  Additionally, it should match the requested path.
HRESULT STDMETHODCALLTYPE CInternalMerger::COwnInstanceSink::Indicate(long lObjectCount, IWbemClassObject** pObjArray )
{
	HRESULT	hRes = WBEM_S_NO_ERROR;

	if ( lObjectCount > 0L )
	{
		CCheckedInCritSec	ics( &m_cs );

		// Only do this if we don't have a merged instance
		if ( NULL == m_pMergedInstance )
		{
			if ( !m_bTriedRetrieve )
			{
				// This call doesn't throttle, so don't worry about crit secs here
				for ( long x = 0; SUCCEEDED( hRes ) && x < lObjectCount; x++ )
				{
					hRes = m_pInternalMerger->AddOwnInstance( pObjArray[x], m_wsInstPath, &m_pMergedInstance );
				}

				// Record the final status if we need to
				if ( FAILED( hRes ) )
				{
					SetFinalStatus( hRes );
				}

			}
			else
			{
				// The following call can and will throttle, so do it
				// outside of our critical section
				ics.Leave();

				// Clearly a lowest level indicate
				hRes = m_pInternalMerger->AddOwnObjects( lObjectCount, pObjArray, true, NULL );

				// We beefed - reflect this in the final status
				if ( FAILED( hRes ) )
				{
					ics.Enter();
					SetFinalStatus( hRes );
				}
			}
		}
		else
		{
			hRes = WBEM_E_INVALID_OPERATION;
		}
	}

	return hRes;
}

HRESULT STDMETHODCALLTYPE CInternalMerger::COwnInstanceSink::SetStatus( long lFlags, long lParam, BSTR strParam,
														IWbemClassObject* pObjParam )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// If we got a complete, remove the instance if it was never merged
	if ( lFlags == WBEM_STATUS_COMPLETE )
	{
		CCheckedInCritSec	ics( &m_cs );

		if ( SUCCEEDED( lParam ) )
		{
			if ( NULL == m_pMergedInstance )
			{
				hr = m_pInternalMerger->RemoveInstance( m_wsInstPath );

				// If we tanked here, we are so busted.
				if ( FAILED( hr ) )
				{
					lParam = hr;
				}

			}	// IF NULL == m_pMergedInstance

		}
		else
		{
			// Remove the Instance now as well
			hr = m_pInternalMerger->RemoveInstance( m_wsInstPath );

			// If we tanked here, we are so busted.
			if ( FAILED( hr ) )
			{
				lParam = hr;
			}

			// We should record the final status if it is not WBEM_E_NOT_FOUND
			if ( WBEM_E_NOT_FOUND != lParam )
			{
				SetFinalStatus( lParam );
			}

			// If we got a failure status, axe the instance now
			if ( NULL != m_pMergedInstance )
			{
				m_pMergedInstance->Release();
				m_pMergedInstance = NULL;
			}
		}

		ics.Leave();

		// Always pass down to the base class
		hr = CMemberSink::SetStatus( lFlags, lParam, strParam, pObjParam );

	}
	else
	{
		// Always pass down to the base class
		hr = CMemberSink::SetStatus( lFlags, lParam, strParam, pObjParam );
	}

	return hr;
}

HRESULT CInternalMerger::COwnInstanceSink::Indicate(long lObjectCount, IWbemClassObject** pObjArray, bool bLowestLevel, long* plNumIndicated  )
{
	// This should Never be called
	_DBG_ASSERT( 0 );
	return WBEM_E_INVALID_OPERATION;
}

HRESULT CInternalMerger::COwnInstanceSink::SetInstancePath( LPCWSTR pwszPath )
{
	HRESULT	hRes = WBEM_S_NO_ERROR;

	try
	{
		m_wsInstPath = pwszPath;
	}
	catch( CX_MemoryException )
	{
		hRes = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
        ExceptionCounter c;	
		hRes = WBEM_E_FAILED;
	}

	return hRes;
}

HRESULT CInternalMerger::COwnInstanceSink::GetObject( IWbemClassObject** ppMergedInst )
{
	HRESULT	hRes = WBEM_S_NO_ERROR;

	CInCritSec	ics( &m_cs );

	// If final status on this sink shows a failure, then we should return that failure
	// mostly cause we're doomed anyway at this point
	if ( SUCCEEDED( m_hFinalStatus ) )
	{
		if ( NULL != m_pMergedInstance )
		{
			m_pMergedInstance->AddRef();
			*ppMergedInst = m_pMergedInstance;
		}
		else
		{
			hRes = WBEM_S_FALSE;
		}

	}
	else
	{
		hRes = m_hFinalStatus;
	}

	// We tried to retrieve it once - so if further indicates come in,
	// they will be passed off to AddOwnObjects
	m_bTriedRetrieve = true;

	return hRes;
}

HRESULT CInternalMerger::COwnInstanceSink::OnFinalRelease( void )
{
	// Wer should clean this up
	m_pInternalMerger->Release();

	return WBEM_S_NO_ERROR;
}

// Only reports negative memory usage if the original number was positive
CInternalMerger::CScopedMemoryUsage::~CScopedMemoryUsage( void )
{
	Cleanup();
}

// Reports memory usage and accounts for errors as deemed appropriate
HRESULT CInternalMerger::CScopedMemoryUsage::ReportMemoryUsage( long lMemUsage )
{
	_DBG_ASSERT( m_lMemUsage >= 0L );

	HRESULT	hr = m_pInternalMerger->ReportMemoryUsage( lMemUsage );

	// If we get a suceess code or WBEM_E_ARB_CANCEL, we need to cleanup
	// the memory usage when we go out of scope.

	if ( ( SUCCEEDED( hr ) || hr == WBEM_E_ARB_CANCEL ) )
	{
		m_lMemUsage += lMemUsage;
		m_bCleanup = true;
	}

	return hr;
}

// Cleans up any memory usage as we deemed appropriate
HRESULT CInternalMerger::CScopedMemoryUsage::Cleanup( void )
{
	_DBG_ASSERT( m_lMemUsage >= 0L );

	HRESULT	hr = WBEM_S_NO_ERROR;

	// Cleanup as appropriate
	if ( m_bCleanup && m_lMemUsage > 0L )
	{
		hr = m_pInternalMerger->ReportMemoryUsage( -m_lMemUsage );
	}

	m_bCleanup = false;
	m_lMemUsage = 0L;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\intprov.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    INTPROV.H

Abstract:

History:

	raymcc        06-May-97       Created.
	raymcc        17-Jul-97       NTLM authentication support

--*/

#ifndef _INTPROV_H_
#define _INTPROV_H_

#ifndef PPVOID
#define PPVOID void **
#endif

// generally useful utilities

BSTR GetBSTR(char * pInput);
HRESULT GetDateTime(FILETIME * ft, bool bLocalTime, LPWSTR pBuff);

class CIntProv : public IWbemServices, public IWbemProviderInit
    {
    protected:
        ULONG              m_cRef;         //Object reference count
        IWbemServices *  m_pNamespace;
     public:
        CIntProv();
        ~CIntProv(void);

//		operator struct IUnknown * (){return (IWbemServices*)this;};
        //Non-delegating object IUnknown

        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

                //IWbemProviderInit

        HRESULT STDMETHODCALLTYPE Initialize(
             /* [in] */ LPWSTR pszUser,
             /* [in] */ LONG lFlags,
             /* [in] */ LPWSTR pszNamespace,
             /* [in] */ LPWSTR pszLocale,
             /* [in] */ IWbemServices *pNamespace,
             /* [in] */ IWbemContext *pCtx,
             /* [in] */ IWbemProviderInitSink *pInitSink
                        );

		SCODE CreateWMISetting(IWbemClassObject FAR* FAR* ppObj, IWbemContext  *pCtx);
		SCODE CreateWMIElementSetting(IWbemClassObject FAR* FAR* ppObj, IWbemContext  *pCtx);

		SCODE SaveWMISetting(IWbemClassObject FAR*);
		SCODE CreateInstance(LPWSTR pwcClassName, IWbemClassObject FAR* FAR* ppObj, IWbemContext  *pCtx);
		SCODE GetRegStrProp(Registry & reg, LPTSTR pRegValueName, LPWSTR pwsPropName, 
															CWbemObject * pObj);
		SCODE GetRegUINTProp(Registry & reg, LPTSTR pRegValueName, LPWSTR pwsPropName, 
															CWbemObject * pObj);
		SCODE PutRegStrProp(Registry & reg, LPTSTR pRegValueName, LPWSTR pwsPropName, 
															CWbemObject * pObj);
		SCODE PutRegUINTProp(Registry & reg, LPTSTR pRegValueName, LPWSTR pwsPropName, 
															CWbemObject * pObj);
        SCODE ReadAutoMofs(CWbemObject * pObj);
        SCODE ReadLastBackup(Registry & reg, CWbemObject * pObj);

        //IWbemServices  

		  HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
            IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) {return WBEM_E_NOT_SUPPORTED;}

        HRESULT STDMETHODCALLTYPE ExecMethodAsync( const BSTR, const BSTR, long, 
            IWbemContext*, IWbemClassObject*, IWbemObjectSink*) {return WBEM_E_NOT_SUPPORTED;}

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\intprov.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    INTPROV.CPP

Abstract:

    Defines the CIntProv class.  An object of this class is
           created by the class factory for each connection.

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <time.h>
#include <locale.h>
#include <wbemcore.h>
#include <intprov.h>
#include <objpath.h>
#include <reg.h>
#include <genutils.h>
#include <safearry.h>


void _ObjectCreated(DWORD);
void _ObjectDestroyed(DWORD);


//***************************************************************************
//
// BSTR GetBSTR(char * pInput)
//
// Creates a bstr based on the narrow character string.
//
// Return:  NULL if failure, otherwise the caller must call SysFreeString.
//
//***************************************************************************

BSTR GetBSTR(TCHAR* pInput)
{
    if(pInput == NULL)
        return NULL;
#ifdef UNICODE
    WCHAR * pTemp = pInput;
#else
    int iLen = strlen(pInput) + 1;
    WCHAR * pTemp = new WCHAR[iLen];
    if(pTemp == NULL)
        return NULL;
    mbstowcs(pTemp, pInput, iLen);
    CDeleteMe<WCHAR> delMe(pTemp);
#endif
    BSTR bstr = SysAllocString(pTemp); 
    return bstr;
}

//***************************************************************************
//
// HRESULT GetDateTime(FILETIME * pft, bool bLocalTime, LPWSTR Buff)
//
// Converts a FILETIME date to CIM_DATA representation.
//
// Parameters:
//  pft         FILETIME to be converted.
//  bLocalTime  If true, then the conversion is to local, 
//                  ex 19990219112222:000000+480.  Otherwise it returns gmt
//  Buff        WCHAR buffer to be passed by the caller.  Should be 30 long
//
//***************************************************************************

HRESULT GetDateTime(FILETIME * pft, bool bLocalTime, LPWSTR Buff)
{
    if(pft == NULL || Buff == NULL)
        return WBEM_E_INVALID_PARAMETER;

    SYSTEMTIME st;
    int Bias=0;
    char cOffsetSign = '+';

    if(bLocalTime)
    {
        FILETIME lft;       // local file time
        TIME_ZONE_INFORMATION ZoneInformation;

        // note that win32 and the DMTF interpret bias differently.
        // For example, win32 would give redmond a bias of 480 while
        // dmtf would have -480

        DWORD dwRet = GetTimeZoneInformation(&ZoneInformation);
        if(dwRet != TIME_ZONE_ID_UNKNOWN)
            Bias = -ZoneInformation.Bias;

        if(Bias < 0)
        {
            cOffsetSign = '-';
            Bias = -Bias;
        }

        FileTimeToLocalFileTime(
            pft,   // pointer to UTC file time to convert
            &lft);                 // pointer to converted file time);    
        if(!FileTimeToSystemTime(&lft, &st))
            return WBEM_E_FAILED;
    }
    if(!FileTimeToSystemTime(pft, &st))
        return WBEM_E_FAILED;

    swprintf(Buff, L"%4d%02d%02d%02d%02d%02d.%06d%c%03d", 
                st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, 
                st.wSecond, st.wMilliseconds*1000, cOffsetSign, Bias); 
    return S_OK;
}

//***************************************************************************
//
// CIntProv::CIntProv
// CIntProv::~CIntProv
//
//***************************************************************************

CIntProv::CIntProv()
{
    m_pNamespace = NULL;
    m_cRef=0;
    _ObjectCreated(OBJECT_TYPE_PROVIDER);
    return;
}

CIntProv::~CIntProv(void)
{
    if(m_pNamespace)
        m_pNamespace->Release();
    _ObjectDestroyed(OBJECT_TYPE_PROVIDER);
    return;
}

//***************************************************************************
//
// CIntProv::QueryInterface
// CIntProv::AddRef
// CIntProv::Release
//
// Purpose: IUnknown members for CIntProv object.
//***************************************************************************


STDMETHODIMP CIntProv::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;

    // Since we have dual inheritance, it is necessary to cast the return type

    if(riid== IID_IWbemServices)
       *ppv=(IWbemServices*)this;

    if(IID_IUnknown==riid || riid== IID_IWbemProviderInit)
       *ppv=(IWbemProviderInit*)this;
    

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
  
}

STDMETHODIMP_(ULONG) CIntProv::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CIntProv::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

/***********************************************************************
*                                                                      *
*   CIntProv::Initialize                                                *
*                                                                      *
*   Purpose: This is the implementation of IWbemProviderInit. The method  *
*   is need to initialize with CIMOM.                                    *
*                                                                      *
***********************************************************************/

STDMETHODIMP CIntProv::Initialize(LPWSTR pszUser, LONG lFlags,
                                    LPWSTR pszNamespace, LPWSTR pszLocale,
                                    IWbemServices *pNamespace, 
                                    IWbemContext *pCtx,
                                    IWbemProviderInitSink *pInitSink)
{
    if(pNamespace)
        pNamespace->AddRef();
    m_pNamespace = pNamespace;

    //Let CIMOM know you are initialized
    //==================================
    
    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
// CIntProv::CreateInstanceEnumAsync
//
// Purpose: Asynchronously enumerates the instances.  
//
//***************************************************************************

SCODE CIntProv::CreateInstanceEnumAsync( const BSTR RefStr, long lFlags, IWbemContext *pCtx,
       IWbemObjectSink FAR* pHandler)
{
    SCODE sc = WBEM_E_FAILED;
    IWbemClassObject FAR* pObj = NULL;
    if(RefStr == NULL || pHandler == NULL)
        return WBEM_E_INVALID_PARAMETER;

    ParsedObjectPath * pOutput = 0;
    CObjectPathParser p;
    int nStatus = p.Parse(RefStr, &pOutput);
    if(nStatus != 0)
        return WBEM_E_INVALID_PARAMETER;

    if(IsNT() && IsDcomEnabled())
	{
		sc = WbemCoImpersonateClient ( ) ;
		if ( FAILED ( sc ) )
		{
			return sc ;
		}
	}

    // if the path and class are for the setting object, go get it.

    if(pOutput->IsClass() && !wbem_wcsicmp(pOutput->m_pClass, L"Win32_WMISetting"))
    {
        sc = CreateWMISetting(&pObj, pCtx);
    }
    else if(pOutput->IsClass() && !wbem_wcsicmp(pOutput->m_pClass, L"Win32_WMIElementSetting"))
    {
        sc = CreateWMIElementSetting(&pObj, pCtx);
    }
    else
        sc = WBEM_E_INVALID_PARAMETER;
 
    p.Free(pOutput);

    if(pObj)
    {
        pHandler->Indicate(1,&pObj);
        pObj->Release();
    }

    // Set status

    pHandler->SetStatus(0,sc,NULL, NULL);
    return S_OK;
}


//***************************************************************************
//
// CIntProv::GetObjectAsync
//
// Purpose: Creates an instance given a particular path value.
//
//***************************************************************************



SCODE CIntProv::GetObjectAsync(const BSTR ObjectPath, long lFlags,IWbemContext  *pCtx,
                    IWbemObjectSink FAR* pHandler)
{

    SCODE sc = WBEM_E_FAILED;
    IWbemClassObject FAR* pObj = NULL;
    BOOL bOK = FALSE;

    // Do a check of arguments and make sure we have pointer to Namespace

    if(ObjectPath == NULL || pHandler == NULL || m_pNamespace == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // do the get, pass the object on to the notify
  
    ParsedObjectPath * pOutput = 0;
    CObjectPathParser p;
    int nStatus = p.Parse(ObjectPath, &pOutput);
    if(nStatus != 0)
        return WBEM_E_INVALID_PARAMETER;

    if(IsNT() && IsDcomEnabled())
    {
		sc = WbemCoImpersonateClient ( ) ;
		if ( FAILED ( sc ) )
		{
			return sc ;
		}
	}

    // if the path and class are for the setting object, go get it.

    if(pOutput->m_bSingletonObj && !wbem_wcsicmp(pOutput->m_pClass, L"Win32_WMISetting"))
    {
        sc = CreateWMISetting(&pObj, pCtx);
    }
    if(!pOutput->m_bSingletonObj && !wbem_wcsicmp(pOutput->m_pClass, L"Win32_WMIElementSetting")
        && pOutput->m_dwNumKeys == 2)
    {
        WCHAR * pKey = pOutput->GetKeyString();
        if(pKey)
        {
            WCHAR * pTest = L"Win32_Service=\"winmgmt\"\xffffWin32_WMISetting=@";
            if(!wbem_wcsicmp(pKey, pTest))
                sc = CreateWMIElementSetting(&pObj, pCtx);
            delete [] pKey;
        }
    }
    
    if(pObj) 
    {
        pHandler->Indicate(1,&pObj);
        pObj->Release();
        bOK = TRUE;
    }

    sc = (bOK) ? S_OK : WBEM_E_NOT_FOUND;

    // Set Status

    pHandler->SetStatus(0,sc, NULL, NULL);
    p.Free(pOutput);
    return sc;
}

//***************************************************************************
//
// CIntProv::PutInstanceAsync
//
// Purpose: Creates an instance given a particular path value.
//
//***************************************************************************

SCODE CIntProv::PutInstanceAsync(IWbemClassObject __RPC_FAR *pInst, long lFlags,IWbemContext  *pCtx,
                    IWbemObjectSink FAR* pHandler)
{

    SCODE sc = WBEM_E_FAILED;

    // Do a check of arguments and make sure we have pointer to Namespace

    if(pInst == NULL || pHandler == NULL || m_pNamespace == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // Get the rel path and parse it;

    VARIANT var;
    VariantInit(&var);
    sc = pInst->Get(L"__relPath", 0, &var, NULL, NULL);
    if(sc != S_OK)
        return WBEM_E_INVALID_PARAMETER;

    // do the get, pass the object on to the notify
  
    ParsedObjectPath * pOutput = 0;
    CObjectPathParser p;

    int nStatus = p.Parse(var.bstrVal, &pOutput);
    VariantClear(&var);
    if(nStatus != 0)
        return WBEM_E_FAILED;

    if(IsNT() && IsDcomEnabled())
    {
		sc = WbemCoImpersonateClient ( ) ;
		if ( FAILED ( sc ) )
		{
			return sc ;
		}
	}

    // if the path and class are for the setting object, go get it.

    if(pOutput->m_bSingletonObj && !wbem_wcsicmp(pOutput->m_pClass, L"Win32_WMISetting"))
    {
        sc = SaveWMISetting(pInst);
    }

    p.Free(pOutput);

    // Set Status

    pHandler->SetStatus(0,sc, NULL, NULL);

    return S_OK;
}




//***************************************************************************
//
// CIntProv::CreateInstance
//
// Purpose: Creates an instance given a particular Path value.
//
//***************************************************************************

SCODE CIntProv::CreateInstance(LPWSTR pwcClassName, IWbemClassObject FAR* FAR* ppObj, 
                               IWbemContext  *pCtx)
{
    SCODE sc;
    IWbemClassObject * pClass = NULL;
    sc = m_pNamespace->GetObject(pwcClassName, 0, pCtx, &pClass, NULL);
    if(sc != S_OK)
        return WBEM_E_FAILED;
    sc = pClass->SpawnInstance(0, ppObj);
    pClass->Release();
    return sc;
}

//***************************************************************************
//
// CIntProv::GetRegStrProp
//
// Retrieves a string property from the registry and puts it into the object.
//
//***************************************************************************
 
SCODE CIntProv::GetRegStrProp(Registry & reg, LPTSTR pRegValueName, LPWSTR pwsPropName, 
                                                            CWbemObject * pObj)
{

    SCODE sc;
    
    TCHAR *pszData = NULL;
    if (reg.GetStr(pRegValueName, &pszData))
        return WBEM_E_FAILED;
    CDeleteMe<TCHAR> del1(pszData);

    BSTR bstr = GetBSTR(pszData);

    if(bstr == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    CVar var;
    var.SetBSTR(bstr, TRUE);    // this acquires and frees the bstr

    sc = pObj->SetPropValue(pwsPropName, &var, CIM_STRING);

    return sc;
}

//***************************************************************************
//
// CIntProv::GetRegUINTProp
//
// Retrieves a DWORD property from the registry and puts it into the object.
//
//***************************************************************************

SCODE CIntProv::GetRegUINTProp(Registry & reg, LPTSTR pRegValueName, LPWSTR pwsPropName, 
                                                            CWbemObject * pObj)
{
    DWORD dwVal;
    if (reg.GetDWORDStr(pRegValueName, &dwVal))
        return WBEM_E_FAILED;

    VARIANT var;
    var.vt = VT_I4;
    var.lVal = dwVal;
    return pObj->Put(pwsPropName, 0, &var, 0);
}

//***************************************************************************
//
// CIntProv::PutRegStrProp
//
// Retrieves a string from the object and writes it to the registry.
//
//***************************************************************************

SCODE CIntProv::PutRegStrProp(Registry & reg, LPTSTR pRegValueName, LPWSTR pwsPropName, 
                                                            CWbemObject * pObj)
{

    VARIANT var;
    VariantInit(&var);
    CClearMe me(&var);
    SCODE sc = pObj->Get(pwsPropName, 0, &var, 0, NULL);
    if(sc != S_OK || var.vt != VT_BSTR)
        return sc;
    
    if(var.bstrVal == NULL || wcslen(var.bstrVal) < 1)
    {
        if (reg.SetStr(pRegValueName, __TEXT("")))
            return WBEM_E_FAILED;
        return S_OK;
    }
#ifdef UNICODE
    TCHAR *tVal = var.bstrVal;
#else
	int iLen = 2 * wcslen(var.bstrVal) + 1;
    TCHAR *tVal = new TCHAR[iLen];
    wcstombs(tVal, var.bstrVal, iLen);
    CDeleteMe<TCHAR> delMe(tVal);
#endif

    if (reg.SetStr(pRegValueName, tVal))
        return WBEM_E_FAILED;
    return S_OK;

}

//***************************************************************************
//
// CIntProv::PutRegUINTProp
//
// Retrieves a DWORD from the object and writes it to the registry.
//
//***************************************************************************

SCODE CIntProv::PutRegUINTProp(Registry & reg, LPTSTR pRegValueName, LPWSTR pwsPropName, 
                                                            CWbemObject * pObj)
{
    CVar var;
    SCODE sc = pObj->Get(pwsPropName, 0, (struct tagVARIANT *)&var, 0, NULL);
    if(sc != S_OK || var.GetType() != VT_I4)
        return sc;
    if (reg.SetDWORDStr(pRegValueName, var.GetDWORD()))
        return WBEM_E_FAILED;
    return S_OK;
}

//***************************************************************************
//
// CIntProv::ReadAutoMofs
//
// Reads the autocompile list from the registry
//
//***************************************************************************

SCODE CIntProv::ReadAutoMofs(CWbemObject * pObj)
{
    Registry r(WBEM_REG_WINMGMT);
    DWORD dwSize;
    TCHAR * pMulti = r.GetMultiStr(__TEXT("Autorecover MOFs"), dwSize);
    if(pMulti == NULL)
        return S_OK;        // Not a problem 

    CDeleteMe<TCHAR> del1(pMulti);

    CSafeArray csa(VT_BSTR, CSafeArray::auto_delete);

    TCHAR * pNext;
    int i;
    for(pNext = pMulti, i=0; *pNext; pNext += lstrlen(pNext) + 1, i++)
    {
        BSTR bstr = GetBSTR(pNext);
        if(bstr == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        csa.SetBSTRAt(i, bstr);     // A copy of the BSTR is made
        SysFreeString(bstr);
    }
    csa.Trim();

    // put the data

    VARIANT var;
    var.vt = VT_BSTR | VT_ARRAY;
    var.parray = csa.GetArray();
    return pObj->Put( L"AutorecoverMofs", 0, &var, 0);

}

//***************************************************************************
//
// CIntProv::ReadLastBackup
//
// Gets the time of the last auto backup.
//
//***************************************************************************

SCODE CIntProv::ReadLastBackup(Registry & reg, CWbemObject * pObj)
{

    // Create the path to the auto backup file.

    LPTSTR pszData = NULL;
    if (reg.GetStr(__TEXT("Repository Directory"), &pszData))
        return WBEM_E_FAILED;
    CDeleteMe<TCHAR> del1(pszData);
    TCHAR * pFullPath =  new TCHAR[lstrlen(pszData)+10];
    if(pFullPath == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CDeleteMe<TCHAR> del2(pFullPath);
    lstrcpy(pFullPath,pszData);
    lstrcat(pFullPath,__TEXT("\\cim.rec"));


    BY_HANDLE_FILE_INFORMATION bh;  

    HANDLE hFile = CreateFile(pFullPath,          // pointer to name of the file
                        0,       // access (read-write) mode
                        FILE_SHARE_READ|FILE_SHARE_WRITE,           // share mode
                        NULL,
                        OPEN_EXISTING,0, NULL);
    if(hFile == INVALID_HANDLE_VALUE)
        return S_OK;
    CCloseHandle cm(hFile);
    if(!GetFileInformationByHandle(hFile, &bh))
        return S_OK;    // probably not a problem since the file may not exist
    WCHAR Date[35];
    SCODE sc = GetDateTime(&bh.ftLastWriteTime, false, Date);
    if(sc != S_OK)
        return sc;

    CVar var;
    var.SetBSTR(Date, FALSE);    // this acquires and frees the bstr

    sc = pObj->SetPropValue(L"BackupLastTime", &var, CIM_DATETIME);
    return sc;    
}
//***************************************************************************
//
// CIntProv::CreateWMIElementSetting
//
// Purpose: Creates an instance given a particular Path value.
//
//***************************************************************************

SCODE CIntProv::CreateWMIElementSetting(IWbemClassObject FAR* FAR* ppObj, IWbemContext  *pCtx)
{
    SCODE sc;
    sc = CreateInstance(L"Win32_WMIElementSetting", ppObj, pCtx);
    if(sc != S_OK)
        return sc;

    CVar var;
    var.SetBSTR(L"Win32_WMISetting=@");
    CWbemObject * pWbemObj = (CWbemObject *)*ppObj;

    sc |= pWbemObj->Put(L"Setting",0, (VARIANT *)&var,  0);
    CVar var2;
    var2.SetBSTR(L"Win32_Service=\"winmgmt\"");
    sc |= pWbemObj->Put(L"Element",0,  (VARIANT *)&var2, 0);

    return sc;
}
 
//***************************************************************************
//
// CIntProv::CreateWMISetting
//
// Purpose: Creates an instance given a particular Path value.
//
//***************************************************************************

SCODE CIntProv::CreateWMISetting(IWbemClassObject FAR* FAR* ppObj, IWbemContext  *pCtx)
{
    SCODE sc, scTemp;
    sc = CreateInstance(L"Win32_WMISetting", ppObj, pCtx);
    if(sc != S_OK)
        return sc;

    // Fill in the properties

    Registry rWbem(HKEY_LOCAL_MACHINE, 0, KEY_READ, WBEM_REG_WBEM);          // Top level wbem key
    Registry rCIMOM(HKEY_LOCAL_MACHINE, 0, KEY_READ, WBEM_REG_WINMGMT);      // The cimom key
    Registry rScripting(HKEY_LOCAL_MACHINE, 0, KEY_READ, __TEXT("Software\\Microsoft\\WBEM\\scripting"));

    CWbemObject * pWbemObj = (CWbemObject *)*ppObj;

    scTemp = GetRegStrProp(rWbem, __TEXT("Installation Directory"), L"InstallationDirectory", pWbemObj);
    scTemp = GetRegStrProp(rWbem, __TEXT("Build"), L"BuildVersion", pWbemObj);
    scTemp = GetRegStrProp(rWbem, __TEXT("MOF Self-Install Directory"), L"MofSelfInstallDirectory", pWbemObj);
    if(!IsNT()) 
    {
        scTemp = GetRegUINTProp(rCIMOM, __TEXT("AutostartWin9X"), L"AutoStartWin9X", pWbemObj);
        scTemp = GetRegUINTProp(rCIMOM, __TEXT("EnableAnonConnections"), L"EnableAnonWin9xConnections", pWbemObj);
    }

    scTemp = GetRegUINTProp(rCIMOM, __TEXT("Log File Max Size"), L"MaxLogFileSize", pWbemObj);
    scTemp = GetRegUINTProp(rCIMOM, __TEXT("Logging"), L"LoggingLevel", pWbemObj);
    scTemp = GetRegStrProp(rCIMOM, __TEXT("Logging Directory"), L"LoggingDirectory", pWbemObj);
    scTemp = GetRegStrProp(rCIMOM, __TEXT("Repository Directory"), L"DatabaseDirectory", pWbemObj);
     scTemp = GetRegUINTProp(rCIMOM, __TEXT("Max DB Size"), L"DatabaseMaxSize", pWbemObj);
    scTemp = GetRegUINTProp(rCIMOM, __TEXT("Backup interval threshold"), L"BackupInterval", pWbemObj);

    scTemp = ReadAutoMofs(pWbemObj);
    scTemp = ReadLastBackup(rCIMOM, pWbemObj);

    DWORD dwScriptingEnabled;
    if(0 == rScripting.GetDWORD(__TEXT("Enable for ASP"), &dwScriptingEnabled))
    {
        CVar var;
        var.SetBool((dwScriptingEnabled == 0) ? VARIANT_FALSE : VARIANT_TRUE);
        scTemp = pWbemObj->SetPropValue(L"ASPScriptEnabled", &var, CIM_BOOLEAN);
    }
    scTemp = GetRegStrProp(rScripting, __TEXT("Default Namespace"), L"ASPScriptDefaultNamespace", pWbemObj);

    scTemp = GetRegUINTProp(rCIMOM, __TEXT("EnableEvents"), L"EnableEvents", pWbemObj);

    scTemp = GetRegUINTProp(rCIMOM, __TEXT("High Threshold On Client Objects (b)"), L"HighThresholdOnClientObjects", pWbemObj);
    scTemp = GetRegUINTProp(rCIMOM, __TEXT("Low Threshold On Client Objects (b)"), L"LowThresholdOnClientObjects", pWbemObj);
    scTemp = GetRegUINTProp(rCIMOM, __TEXT("Max Wait On Client Objects (ms)"), L"MaxWaitOnClientObjects", pWbemObj);

    scTemp = GetRegUINTProp(rCIMOM, __TEXT("High Threshold On Events (b)"), L"HighThresholdOnEvents", pWbemObj);
    scTemp = GetRegUINTProp(rCIMOM, __TEXT("Low Threshold On Events (b)"), L"LowThresholdOnEvents", pWbemObj);
    scTemp = GetRegUINTProp(rCIMOM, __TEXT("Max Wait On Events (ms)"), L"MaxWaitOnEvents", pWbemObj);

    // not considered to be an error if the next one isnt there

    GetRegUINTProp(rCIMOM, __TEXT("LastStartupHeapPreallocation"), L"LastStartupHeapPreallocation", pWbemObj);

    DWORD dwEnablePreallocate = 0;
    rCIMOM.GetDWORD(__TEXT("EnableStartupHeapPreallocation"), &dwEnablePreallocate);
    CVar var;
    var.SetBool((dwEnablePreallocate == 1) ?  VARIANT_TRUE : VARIANT_FALSE);
    scTemp = pWbemObj->SetPropValue(L"EnableStartupHeapPreallocation", &var, CIM_BOOLEAN);


    return sc;
}
 
//***************************************************************************
//
// CIntProv::SaveWMISetting
//
// Purpose: Outputs the last values back to the registry.
//
//***************************************************************************

SCODE CIntProv::SaveWMISetting(IWbemClassObject FAR* pInst)
{
    SCODE sc = S_OK;
    Registry rCIMOM(WBEM_REG_WINMGMT);      // The cimom key
    Registry rScripting(__TEXT("Software\\Microsoft\\WBEM\\scripting"));
    CWbemObject * pWbemObj = (CWbemObject *)pInst;

    // verify that the backup interval is valid

    CVar var;
    sc = pInst->Get(L"BackupInterval", 0, (struct tagVARIANT *)&var, 0, NULL);
    if(sc != S_OK)
        return sc;
    if((var.GetDWORD() < 5 || var.GetDWORD() > 60*24) && var.GetDWORD() != 0)
        return WBEM_E_INVALID_PARAMETER;

    // Write the "writeable properties back into the registry

    sc |= PutRegUINTProp(rCIMOM, __TEXT("Backup interval threshold"), L"BackupInterval", pWbemObj);
    ConfigMgr::ReadBackupConfiguration();

    if(!IsNT()) 
    {
        sc |= PutRegUINTProp(rCIMOM, __TEXT("AutostartWin9X"), L"AutoStartWin9X", pWbemObj);
        sc = pWbemObj->Get(L"EnableAnonWin9XConnections", 0, (struct tagVARIANT *)&var, 0, NULL);
        if(sc == S_OK)
        {
            rCIMOM.SetDWORDStr(__TEXT("EnableAnonConnections"), var.GetBool() ? 1 : 0);
        }
    }

    sc |= PutRegUINTProp(rCIMOM, __TEXT("Log File Max Size"), L"MaxLogFileSize", pWbemObj);
    sc |= PutRegUINTProp(rCIMOM, __TEXT("Logging"), L"LoggingLevel", pWbemObj);
    sc |= PutRegStrProp(rCIMOM, __TEXT("Logging Directory"), L"LoggingDirectory", pWbemObj);

    ConfigMgr::ReadBackupConfiguration();

    sc |= pWbemObj->Get(L"ASPScriptEnabled", 0, (struct tagVARIANT *)&var, 0, NULL);
    if(sc == S_OK)
    {
        rScripting.SetDWORD(__TEXT("Enable for ASP"), var.GetBool() ? 1 : 0);
    }
    sc |= PutRegStrProp(rScripting, __TEXT("Default Namespace"), L"ASPScriptDefaultNamespace", pWbemObj);

    sc |= pWbemObj->Get(L"EnableEvents", 0, (struct tagVARIANT *)&var, 0, NULL);
    if(sc == S_OK)
    {
        rCIMOM.SetDWORDStr(__TEXT("EnableEvents"), var.GetBool() ? 1 : 0);
    }

    sc |= PutRegUINTProp(rCIMOM, __TEXT("High Threshold On Client Objects (b)"), L"HighThresholdOnClientObjects", pWbemObj);
    sc |= PutRegUINTProp(rCIMOM, __TEXT("Low Threshold On Client Objects (b)"), L"LowThresholdOnClientObjects", pWbemObj);
    sc |= PutRegUINTProp(rCIMOM, __TEXT("Max Wait On Client Objects (ms)"), L"MaxWaitOnClientObjects", pWbemObj);

    sc |= PutRegUINTProp(rCIMOM, __TEXT("High Threshold On Events (b)"), L"HighThresholdOnEvents", pWbemObj);
    sc |= PutRegUINTProp(rCIMOM, __TEXT("Low Threshold On Events (b)"), L"LowThresholdOnEvents", pWbemObj);
    sc |= PutRegUINTProp(rCIMOM, __TEXT("Max Wait On Events (ms)"), L"MaxWaitOnEvents", pWbemObj);

    sc |= pWbemObj->Get(L"EnableStartupHeapPreallocation", 0, (struct tagVARIANT *)&var, 0, NULL);
    if(sc == S_OK)
    {
        rCIMOM.SetDWORD(__TEXT("EnableStartupHeapPreallocation"), var.GetBool() ? 1 : 0);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\login.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    LOGIN.H

Abstract:

	WinMgmt Secure Login Module

History:

	raymcc        06-May-97       Created.
	raymcc        28-May-97       Updated for NT5/Memphis beta releases.
	raymcc        07-Aug-97       Group support and NTLM fixes.

--*/

#ifndef _LOGIN_H_
#define _LOGIN_H_

#include "lmaccess.h"


class CWbemLocator : public IWbemLocator, public IWbemConnection
{
    ULONG m_uRefCount;

public:
    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    CWbemLocator();
   ~CWbemLocator();

    HRESULT GetNamespace(LPCWSTR wszNetworkResource, LPCWSTR wszUser,
                            LPCWSTR wszLocale,IWbemContext *pCtx,
                            DWORD dwSecFlags, DWORD dwPermission, 
                            REFIID riid, void **pInterface, bool bAddToClientList, 
                            long lClientFlags);
};

// This is used when a provider need a pointer to another namespace.  The access is always granted
// and the client count is not incremented

class CWbemAdministrativeLocator : public CWbemLocator
{
public:
    HRESULT STDMETHODCALLTYPE ConnectServer( 
             const BSTR NetworkResource, const BSTR User, const BSTR Password, const BSTR Locale,
             LONG lSecurityFlags, const BSTR Authority, IWbemContext *pCtx,
             IWbemServices **ppNamespace
            );
    HRESULT STDMETHODCALLTYPE Open( 
        /* [in] */ const BSTR strObject,
        /* [in] */ const BSTR strUser,
        /* [in] */ const BSTR strPassword,
        /* [in] */ const BSTR strLocale,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pInterface,
        /* [out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *pCallRes);
    
    HRESULT STDMETHODCALLTYPE OpenAsync( 
        /* [in] */ const BSTR strObject,
        /* [in] */ const BSTR strUser,
        /* [in] */ const BSTR strPassword,
        /* [in] */ const BSTR strLocale,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ REFIID riid,
        /* [in] */ IWbemObjectSinkEx __RPC_FAR *pResponseHandler){return WBEM_E_NOT_AVAILABLE;};
    
    HRESULT STDMETHODCALLTYPE Cancel( 
        /* [in] */ long lFlags,
        /* [in] */ IWbemObjectSinkEx __RPC_FAR *pHandler){return WBEM_E_NOT_AVAILABLE;};

};

// This is used by non dcom transports who have verified the clients identity.  The client count is 
// incremented.

class CWbemAuthenticatedLocator : public CWbemLocator
{
public:
    HRESULT STDMETHODCALLTYPE ConnectServer( 
             const BSTR NetworkResource, const BSTR User, const BSTR Password, const BSTR Locale,
             LONG lSecurityFlags, const BSTR Authority, IWbemContext *pCtx,
             IWbemServices **ppNamespace );

    HRESULT STDMETHODCALLTYPE Open( 
        /* [in] */ const BSTR strObject,
        /* [in] */ const BSTR strUser,
        /* [in] */ const BSTR strPassword,
        /* [in] */ const BSTR strLocale,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pInterface,
        /* [out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *pCallRes);
    
    HRESULT STDMETHODCALLTYPE OpenAsync( 
        /* [in] */ const BSTR strObject,
        /* [in] */ const BSTR strUser,
        /* [in] */ const BSTR strPassword,
        /* [in] */ const BSTR strLocale,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ REFIID riid,
        /* [in] */ IWbemObjectSinkEx __RPC_FAR *pResponseHandler){return WBEM_E_NOT_AVAILABLE;};
    
    HRESULT STDMETHODCALLTYPE Cancel( 
        /* [in] */ long lFlags,
        /* [in] */ IWbemObjectSinkEx __RPC_FAR *pHandler){return WBEM_E_NOT_AVAILABLE;};
};

// This is used by providers to get access to other namespaces for the benefit of a client which 
// may or may not have access.  Therefore, access is checked and may be denied and furthermore the
// client count is not incremented.

class CWbemUnauthenticatedLocator : public CWbemLocator
{
public:
    HRESULT STDMETHODCALLTYPE ConnectServer( 
             const BSTR NetworkResource, const BSTR User, const BSTR Password, const BSTR Locale,
             LONG lSecurityFlags, const BSTR Authority, IWbemContext *pCtx,
             IWbemServices **ppNamespace
            );
    HRESULT STDMETHODCALLTYPE Open( 
        /* [in] */ const BSTR strObject,
        /* [in] */ const BSTR strUser,
        /* [in] */ const BSTR strPassword,
        /* [in] */ const BSTR strLocale,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pInterface,
        /* [out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *pCallRes);
    
    HRESULT STDMETHODCALLTYPE OpenAsync( 
        /* [in] */ const BSTR strObject,
        /* [in] */ const BSTR strUser,
        /* [in] */ const BSTR strPassword,
        /* [in] */ const BSTR strLocale,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ REFIID riid,
        /* [in] */ IWbemObjectSinkEx __RPC_FAR *pResponseHandler){return WBEM_E_NOT_AVAILABLE;};
    
    HRESULT STDMETHODCALLTYPE Cancel( 
        /* [in] */ long lFlags,
        /* [in] */ IWbemObjectSinkEx __RPC_FAR *pHandler){return WBEM_E_NOT_AVAILABLE;};
};
class CWbemLevel1Login : public IWbemLevel1Login, public IWbemLoginHelper , 
        public IWbemConnectorLogin, public IWbemLoginClientID
{
    LPWSTR         m_pszUser;               // User
    LPWSTR         m_pszDomain;             // Domain (NTLM only)
    LPWSTR         m_pszNetworkResource;    // Namespace name
    LPWSTR         m_pwszClientMachine;
    long           m_lClientProcId;
    ULONG m_uRefCount;

    BOOL IsValidLocale(LPCWSTR wszLocale);
    HRESULT LoginUser(
        LPWSTR pNetworkResource,
        LPWSTR pPreferredLocale,
        long lFlags,
        IWbemContext* pCtx,
        bool bAlreadyAuthenticated,
		REFIID riid,
        void **pInterface, 
        bool bInProc);
    void GetWin9XUserName();

public:

    CWbemLevel1Login();
    ~CWbemLevel1Login();

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    STDMETHOD(EstablishPosition)(LPWSTR wszMachineName,
                                DWORD dwProcessId,
                                DWORD* phAuthEventHandle);
    STDMETHOD(RequestChallenge)( 
             LPWSTR pNetworkResource,
             LPWSTR pUser,
             WBEM_128BITS Nonce
            );


    STDMETHOD(WBEMLogin)( 
        LPWSTR pPreferredLocale,
        WBEM_128BITS AccessToken,
        LONG lFlags,
        IN  IWbemContext *pCtx,             
        IWbemServices **ppNamespace
        );

    STDMETHOD(NTLMLogin)( 
        LPWSTR pNetworkResource,
        LPWSTR pPreferredLocale,
        LONG lFlags,
        IN  IWbemContext *pCtx,             
        IWbemServices **ppNamespace
        );

    STDMETHOD(SetEvent)(LPCSTR sEventToSet);

    HRESULT STDMETHODCALLTYPE ConnectorLogin( 
            /* [string][unique][in] */ LPWSTR wszNetworkResource,
            /* [string][unique][in] */ LPWSTR wszPreferredLocale,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pInterface);
   
    HRESULT STDMETHODCALLTYPE SetClientInfo( 
            /* [string][unique][in] * */ LPWSTR wszClientMachine,
            /* [in] */ LONG lClientProcId,
            /* [in] */ LONG lReserved);

};

#define IsSlash(x) ((x) == L'\\' || (x) == L'/')

const WCHAR * FindSlash(LPCWSTR pTest);
LPWSTR GetDefaultLocale();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\lock.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    LOCK.CPP

Abstract:

    Implements the generic class for obtaining read and write locks to some 
    resource. 

    See lock.h for all documentation.

    Classes defined:

    CLock

History:

    a-levn  5-Sept-96       Created.
    3/10/97     a-levn      Fully documented

--*/

#include "precomp.h"
#include <stdio.h>
#include "lock.h"
#include <stdio.h>

#include <cominit.h>

// debugging.
#define PRINTF

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

CLock::CLock() : m_nReading(0), m_nWriting(0), m_nWaitingToRead(0),
            m_nWaitingToWrite(0)
{
    // Initialize the critical sections
    // ================================

    InitializeCriticalSection(&m_csAll);
    InitializeCriticalSection(&m_csEntering);

    // Create unnamed events for reading and writing
    // =============================================

    m_hCanRead = CreateEvent(NULL, TRUE, TRUE, NULL);
    m_hCanWrite = CreateEvent(NULL, TRUE, TRUE, NULL);
}

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************
CLock::~CLock()
{
    CloseHandle(m_hCanWrite);
    CloseHandle(m_hCanRead);
    DeleteCriticalSection(&m_csAll);
    DeleteCriticalSection(&m_csEntering);
}

BOOL CLock::IsHoldingReadLock()
{
    // Check if this thread already owns this lock
    // ===========================================

    EnterCriticalSection(&m_csAll);
    DWORD_PTR dwThreadId = GetCurrentThreadId();
    for(int i = 0; i < m_adwReaders.Size(); i++)
    {
        if(dwThreadId == (DWORD_PTR)m_adwReaders[i])
        {
            LeaveCriticalSection(&m_csAll);
            return TRUE;
        }
    }

    LeaveCriticalSection(&m_csAll);
    return FALSE;
}
    

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************
int CLock::ReadLock(DWORD dwTimeout)
{
    PRINTF("%d wants to read\n", GetCurrentThreadId());

    // Check if this thread already owns this lock
    // ===========================================

    EnterCriticalSection(&m_csAll);
    DWORD_PTR dwThreadId = GetCurrentThreadId();
    for(int i = 0; i < m_adwReaders.Size(); i++)
    {
        if(dwThreadId == (DWORD_PTR)m_adwReaders[i])
        {
            // We already have it --- add it to the list and return
            // ====================================================

            m_adwReaders.Add((void*)dwThreadId);
            m_nReading++;
            LeaveCriticalSection(&m_csAll);
            return NoError;
        }
    }

    // Don't have it already
    // =====================
        
    LeaveCriticalSection(&m_csAll);

    // Get in line for getting any kind of lock (those unlocking don't go into
    // this line)
    // =======================================================================

    EnterCriticalSection(&m_csEntering);

    // We are the only ones allowed to get any kind of lock now. Wait for the
    // event indicating that reading is enabled to become signaled
    // ======================================================================

    PRINTF("%d next to enter\n", GetCurrentThreadId());
    if(m_nWriting != 0)
    {
        int nRes = WaitFor(m_hCanRead, dwTimeout);
        if(nRes != NoError)
        {
            LeaveCriticalSection(&m_csEntering);
            return nRes;
        }
    }

    // Enter inner critical section (unlockers use it too), increment the
    // number of readers and disable writing.
    // ==================================================================

    PRINTF("%d got event\n", GetCurrentThreadId());
    EnterCriticalSection(&m_csAll);
    m_nReading++;
    m_adwReaders.Add((void*)dwThreadId);
    PRINTF("Reset write\n");
    ResetEvent(m_hCanWrite);
    PRINTF("Done\n");

    // Get out of all critical sections and return
    // ===========================================

    LeaveCriticalSection(&m_csAll);
    LeaveCriticalSection(&m_csEntering);
    PRINTF("%d begins to read\n", GetCurrentThreadId());

    return NoError;
}

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

int CLock::ReadUnlock()
{
    PRINTF("%d wants to unlock reading\n", GetCurrentThreadId());

    // Enter internal ciritcal section and decrement the number of readers
    // ===================================================================

    EnterCriticalSection(&m_csAll);

    m_nReading--;
    if(m_nReading < 0) return Failed;

    // Remove it from the list of threads
    // ==================================

    DWORD_PTR dwThreadId = GetCurrentThreadId();
    for(int i = 0; i < m_adwReaders.Size(); i++)
    {
        if((DWORD_PTR)m_adwReaders[i] == dwThreadId)
        {
            m_adwReaders.RemoveAt(i);
            break;
        }
    }

    // If all reasders are gone, allow writers in
    // ==========================================

    if(m_nReading == 0)
    {
            PRINTF("%d is the last reader\n", GetCurrentThreadId());
            PRINTF("Set write\n");
            if(!SetEvent(m_hCanWrite))
            {
                    LeaveCriticalSection(&m_csAll);
                    return Failed;
            }
            PRINTF("Done\n");
    }
    else PRINTF("%d sees %d still reading\n", GetCurrentThreadId(), m_nReading);

    // Get out and return
    // ==================

    LeaveCriticalSection(&m_csAll);
    return NoError;
}

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

int CLock::WriteLock(DWORD dwTimeout)
{
    PRINTF("%d wants to write\n", GetCurrentThreadId());

    // Get in line for getting any kind of lock. Those unlocking don't use this
    // critical section.
    // ========================================================================

    EnterCriticalSection(&m_csEntering);

    // We are the only ones allowed to get any kind of lock now
    // ========================================================

    PRINTF("%d next to enter\n", GetCurrentThreadId());

    // Wait for the event allowing writing to become signaled
    // ======================================================

    int nRes = WaitFor(m_hCanWrite, dwTimeout);
    PRINTF("%d got event\n", GetCurrentThreadId());
    if(nRes != NoError)
    {
            LeaveCriticalSection(&m_csEntering);
            return nRes;
    }

    // Enter internal critical section (unlockers use it too), increment the
    // number of writers (from 0 to 1) and disable both reading and writing
    // from now on.
    // ======================================================================

    EnterCriticalSection(&m_csAll);
    m_nWriting++;
    PRINTF("Reset both\n");
    ResetEvent(m_hCanWrite);
    ResetEvent(m_hCanRead);
    PRINTF("Done\n");

    // Get out and return
    // ==================

    LeaveCriticalSection(&m_csAll);
    LeaveCriticalSection(&m_csEntering);
    PRINTF("%d begins to write\n", GetCurrentThreadId());

    return NoError;
}

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

int CLock::WriteUnlock()
{
    PRINTF("%d wants to release writing\n", GetCurrentThreadId());

    // Enter lock determination critical section
    // =========================================

    EnterCriticalSection(&m_csAll);

    m_nWriting--;
    if(m_nWriting < 0) return Failed;

    // Allow readers and writers in
    // ============================

    PRINTF("%d released writing\n", GetCurrentThreadId());

    PRINTF("Set both\n");
    if(!SetEvent(m_hCanRead))
    {
            LeaveCriticalSection(&m_csAll);
            return Failed;
    }
    else if(!SetEvent(m_hCanWrite))
    {
            LeaveCriticalSection(&m_csAll);
            return Failed;
    }
    else
    {
            PRINTF("Done\n");
            LeaveCriticalSection(&m_csAll);
            return NoError;
    }
}

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

int CLock::DowngradeLock()
{
    // Enter lock determination critical section
    // =========================================

    EnterCriticalSection(&m_csAll);

    if(!SetEvent(m_hCanRead))
    {
        LeaveCriticalSection(&m_csAll);
        return Failed;
    }

    m_nReading++;

    LeaveCriticalSection(&m_csAll);

    return NoError;
}
    
    
    
//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

int CLock::WaitFor(HANDLE hEvent, DWORD dwTimeout)
{
    DWORD dwRes;
    dwRes = WbemWaitForSingleObject(hEvent, dwTimeout);

    // Analyze the error code and convert to ours
    // ==========================================

    if(dwRes == WAIT_OBJECT_0) return NoError;
    else if(dwRes == WAIT_TIMEOUT) return TimedOut;
    else return Failed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\mergerreq.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MERGERREQ.CPP

Abstract:

    Implementations of the various merger request classes.

History:

    sanjes    28-Feb-01  Created.

--*/

#include "precomp.h"

#pragma warning (disable : 4786)
#include <wbemcore.h>
#include <map>
#include <vector>
#include <perfhelp.h>
#include <genutils.h>
#include <oahelp.inl>
#include <wqllex.h>
#include "wmimerger.h"

//
// Merger Request implementations.
//

CMergerClassReq::CMergerClassReq( CWmiMerger* pMerger, CWmiMergerRecord* pParentRecord,
			CWbemNamespace* pNamespace, CBasicObjectSink* pHandler, 
			IWbemContext* pContext)
			:	CMergerReq( pNamespace, pHandler, pContext ),
				m_pMerger( pMerger ),
				m_pParentRecord( pParentRecord ),
				m_pSink( pHandler )
{
	if ( NULL != m_pMerger )
	{
		m_pMerger->AddRef();
	}

	if ( NULL != m_pSink )
	{
		m_pSink->AddRef();
	}
	SetForceRun ( 1 ) ;
}

CMergerClassReq::~CMergerClassReq()
{
	if ( NULL != m_pMerger )
	{
		m_pMerger->Release();
	}

	if ( NULL != m_pSink )
	{
		m_pSink->Release();
	}
}

void CMergerClassReq::DumpError()
{
    // none
}

// Pass off execution to the merger
HRESULT CMergerParentReq::Execute ()
{	
	try 
	{
	    return  m_pMerger->Exec_MergerParentRequest( m_pParentRecord, m_pSink );
	} 
	catch (CX_MemoryException &)
	{
        return WBEM_E_OUT_OF_MEMORY;
    }
}

HRESULT CMergerChildReq::Execute ()
{
	HRESULT hRes = m_pMerger->Exec_MergerChildRequest( m_pParentRecord, m_pSink );
    return hRes;
}

// Merger Requests
CMergerDynReq::CMergerDynReq( CWbemObject* pClassDef, CWbemNamespace* pNamespace, IWbemObjectSink* pHandler,
          IWbemContext* pContext )
		  : CMergerReq( pNamespace, pHandler, pContext )
{
	HRESULT	hr = pClassDef->GetClassName( &m_varClassName );

	// BUGBUG:TODO what if var is VT_NULL?
	_DBG_ASSERT( !m_varClassName.IsNull() );

	// We're toast
	if ( FAILED( hr ) )
	{
		throw CX_MemoryException();
	}

}

HRESULT CMergerDynReq_DynAux_GetInstances :: Execute ()
{
    HRESULT hRes = m_pNamespace->Exec_DynAux_GetInstances (

        m_pClassDef ,
        m_lFlags ,
        m_pContext ,
        m_pSink
    ) ;

    return hRes;
}

void CMergerDynReq_DynAux_GetInstances ::DumpError()
{
    // none
}

HRESULT CMergerDynReq_DynAux_ExecQueryAsync :: Execute ()
{
    HRESULT hRes = m_pNamespace->Exec_DynAux_ExecQueryAsync (

        m_pClassDef ,
        m_Query,
        m_QueryFormat,
        m_lFlags ,
        m_pContext ,
        m_pSink
    ) ;

    return hRes;
}

void CMergerDynReq_DynAux_ExecQueryAsync ::DumpError()
{
    // none
}

// Static Requests
CMergerDynReq_Static_GetInstances::CMergerDynReq_Static_GetInstances (

	CWbemNamespace *pNamespace ,
	CWbemObject *pClassDef ,
	long lFlags ,
	IWbemContext *pCtx ,
	CBasicObjectSink *pSink ,
	QL_LEVEL_1_RPN_EXPRESSION* pParsedQuery

) :	CMergerDynReq (
		pClassDef ,
		pNamespace , 
		pSink , 
		pCtx
	) ,
    m_pClassDef(pClassDef), 
	m_pCtx(pCtx), 
	m_pSink(pSink),
	m_lFlags(lFlags),
	m_pParsedQuery( pParsedQuery )
{
	if ( m_pParsedQuery )
	{
		m_pParsedQuery->AddRef();
	}

	if (m_pClassDef)
	{
		m_pClassDef->AddRef () ;
	}

	if (m_pCtx)
	{
		m_pCtx->AddRef () ;
	}

	if (m_pSink)
	{
		m_pSink->AddRef () ;
	}

}

CMergerDynReq_Static_GetInstances::~CMergerDynReq_Static_GetInstances ()
{
	if (m_pClassDef)
	{
		m_pClassDef->Release () ;
	}

	if (m_pCtx)
	{
		m_pCtx->Release () ;
	}

	if (m_pSink)
	{
		m_pSink->Release () ;
	}

	if ( NULL != m_pParsedQuery )
	{
		m_pParsedQuery->Release();
	}
}

// Calls into the query engine
HRESULT CMergerDynReq_Static_GetInstances :: Execute ()
{

	int nRes = CQueryEngine::ExecAtomicDbQuery(
				m_pNamespace->GetNsSession(),
				m_pNamespace->GetNsHandle(),
				m_pNamespace->GetScope(),
				GetName(),
				m_pParsedQuery,
				m_pSink,
				m_pNamespace );

	HRESULT	hr = WBEM_S_NO_ERROR;
    if (nRes == CQueryEngine::invalid_query)
		hr = WBEM_E_INVALID_QUERY;
    else if(nRes != 0)
		hr = WBEM_E_FAILED;

	m_pSink->SetStatus( 0L, hr, 0L, NULL );

    return hr;
}

void CMergerDynReq_Static_GetInstances ::DumpError()
{
    // none
}

//
// CWmiMergerRequestMgr implementation.
//

CWmiMergerRequestMgr::CWmiMergerRequestMgr( CWmiMerger* pMerger )
:	m_pMerger( pMerger ),
	m_HierarchyArray(),
	m_dwNumRequests( 0 ),
	m_dwMinLevel( 0xFFFFFFFF ),
	m_dwMaxLevel( 0 )
{
}

CWmiMergerRequestMgr::~CWmiMergerRequestMgr()
{
	Clear();
}

// Clears the manager of ALL arrays
HRESULT CWmiMergerRequestMgr::Clear( void )
{
	for ( int x = 0; x < m_HierarchyArray.Size(); x++ )
	{
		CSortedUniquePointerArray<CMergerDynReq>* pArray =
			(CSortedUniquePointerArray<CMergerDynReq>*) m_HierarchyArray[x];

		if ( NULL != pArray )
		{
			delete pArray;
			m_HierarchyArray.SetAt( x, NULL );
		}
	}

	// Set to 0
	m_dwNumRequests = 0L;

	return WBEM_S_NO_ERROR;
}

// Adds a new request to the manager
HRESULT CWmiMergerRequestMgr::AddRequest( CMergerDynReq* pReq, DWORD dwLevel )
{
	// Locate the array for the level.  If we need to allocate one, do so.
	HRESULT	hr = WBEM_S_NO_ERROR;
	CSortedUniquePointerArray<CMergerDynReq>* pArray = NULL;

	// Check first if we have built out to this level, then if so, do we have
	// an array for the level.
	if ( dwLevel >= m_HierarchyArray.Size() || NULL == m_HierarchyArray[dwLevel] )
	{
		pArray = new CSortedUniquePointerArray<CMergerDynReq>;

		if ( NULL != pArray )
		{
			// First, if we're not built out to the required size,
			// NULL out the elements from size to our level

			if ( dwLevel >= m_HierarchyArray.Size() )
			{
				for ( int x = m_HierarchyArray.Size(); SUCCEEDED( hr ) && x <= dwLevel; x++ )
				{
					if ( m_HierarchyArray.Add( NULL ) != CFlexArray::no_error )
					{
						hr = WBEM_E_OUT_OF_MEMORY;
					}
					else
					{
						if ( dwLevel < m_dwMinLevel )
						{
							m_dwMinLevel = dwLevel;
						}
						else if ( dwLevel > m_dwMaxLevel )
						{
							m_dwMaxLevel = dwLevel;
						}

					}
				}	// FOR enum elements

			}	// IF dwLevel >= Array size

			if ( SUCCEEDED( hr ) )
			{
				m_HierarchyArray.SetAt( dwLevel, pArray );
			}

			if ( FAILED( hr ) )
			{
				delete pArray;
			}
		}
		else
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}
	else
	{
		// This should NEVER be NULL
		pArray = (CSortedUniquePointerArray<CMergerDynReq>*) m_HierarchyArray[dwLevel];

		_DBG_ASSERT( pArray != NULL );

		if ( NULL == pArray )
		{
			hr = WBEM_E_FAILED;
		}
	}

	// Finally, add the request to the array.  Subsequent worker threads
	// will locate requests and execute them.

	if ( SUCCEEDED( hr ) )
	{
		if ( pArray->Insert( pReq ) < 0 )
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
		else
		{
			++m_dwNumRequests;
		}
	}

	return hr;

}

// Removes a request from the manager and returns it to the caller.
// The caller is responsible for cleaning up the request.

HRESULT CWmiMergerRequestMgr::RemoveRequest( DWORD dwLevel, LPCWSTR pwszName, CMergerReq** ppReq )
{
	// Locate the array for the level.  If we need to allocate one, do so.
	HRESULT	hr = WBEM_S_NO_ERROR;

	// Check that the level is valid
	_DBG_ASSERT( dwLevel < m_HierarchyArray.Size() );

	if ( dwLevel < m_HierarchyArray.Size() )
	{
		CSortedUniquePointerArray<CMergerDynReq>* pArray =
			(CSortedUniquePointerArray<CMergerDynReq>*) m_HierarchyArray[dwLevel];

		// This should NEVER be NULL
		_DBG_ASSERT( pArray != NULL );

		if ( NULL != pArray )
		{
			int	nIndex;

			// Under certain race conditions, another thread
			// can actually remove a request before one thread
			// processes it, so if it's not there, the assumption
			// is that it was already removed.
			*ppReq = pArray->Find( pwszName, &nIndex );

			if ( NULL != *ppReq )
			{
				// Now remove the element from the array, the caller
				// is responsible for deleting it
				pArray->RemoveAtNoDelete( nIndex );
				--m_dwNumRequests;
			}
			else
			{
				hr = WBEM_E_NOT_FOUND;
			}
		}
		else
		{
			hr = WBEM_E_FAILED;
		}
	}
	else
	{
		hr = WBEM_E_FAILED;
	}

	return hr;
}

HRESULT CWmiMergerRequestMgr::GetTopmostParentReqName( WString& wsClassName )
{
	HRESULT hr = WBEM_E_NOT_FOUND;

	if ( m_dwNumRequests > 0 )
	{
		for ( int x = 0; WBEM_E_NOT_FOUND == hr && x < m_HierarchyArray.Size(); x++ )
		{
			CSortedUniquePointerArray<CMergerDynReq>* pArray =
				(CSortedUniquePointerArray<CMergerDynReq>*) m_HierarchyArray[x];

			// The Array must exist and have elements
			if ( NULL != pArray && pArray->GetSize() > 0 )
			{
				// Get the class name from the first request
				try
				{
					wsClassName = pArray->GetAt( 0 )->GetName();
					hr = WBEM_S_NO_ERROR;
				}
				catch(...)
				{
			        ExceptionCounter c;				
					hr = WBEM_E_OUT_OF_MEMORY;
				}
			}

		}	// For enum arrays
	}

	return hr;
}

BOOL CWmiMergerRequestMgr::HasSingleStaticRequest( void )
{
	BOOL	fRet = FALSE;

	if ( 1 == m_dwNumRequests )
	{
		HRESULT	hr = WBEM_E_NOT_FOUND;

		for ( int x = 0; WBEM_E_NOT_FOUND == hr && x < m_HierarchyArray.Size(); x++ )
		{
			CSortedUniquePointerArray<CMergerDynReq>* pArray =
				(CSortedUniquePointerArray<CMergerDynReq>*) m_HierarchyArray[x];

			// The Array must exist and have elements
			if ( NULL != pArray && pArray->GetSize() > 0 )
			{
				// Get the class name from the first request
				fRet = pArray->GetAt(0)->IsStatic();
				hr = WBEM_S_NO_ERROR;
			}

		}	// For enum arrays

	}	// Must be 1 and only 1 request

	return fRet;
}

#ifdef __DEBUG_MERGER_THROTTLING
void CWmiMergerRequestMgr::DumpRequestHierarchy( void )
{
	HRESULT hr = WBEM_E_NOT_FOUND;

	if ( m_dwNumRequests > 0 )
	{
		for ( int x = 0; FAILED( hr ) && x < m_HierarchyArray.Size(); x++ )
		{
			CSortedUniquePointerArray<CMergerDynReq>* pArray =
				(CSortedUniquePointerArray<CMergerDynReq>*) m_HierarchyArray[x];

			// The Array must exist and have elements
			if ( NULL != pArray && pArray->GetSize() > 0 )
			{
				for ( int y = 0; y < pArray->GetSize(); y++ )
				{
					WCHAR	wszTemp[256];
					wsprintf( wszTemp, L"Merger Request, Level %d, Class Name: %s\n", x, pArray->GetAt(y)->GetName() );
					OutputDebugStringW( wszTemp );
				}
			}

		}	// For enum arrays
	}

}
#else
void CWmiMergerRequestMgr::DumpRequestHierarchy( void )
{
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\mergerreq.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MERGERREQ.H

Abstract:

    Definitions of Merger Request classes

History:

	28-Feb-01   sanjes    Created.

--*/

#ifndef _MERGERREQ_H_
#define _MERGERREQ_H_

// forward class definitions
class CWmiMerger;
class CWmiMergerRecord;

//
// Merger Requests
//
// In previous releases, when the query engine analyzed a query, it enqueued
// a large number of requests, one for each dynamically provided class.  Each
// of these could be handled on a separate thread, which could cause a
// significant thread explosion as each request was handed to a separate thread.
//
// In order to better control the threads, we are using the merger to perform
// a more intelligent analysis of a query and then spin off threads only when
// we reach throttling conditions.  Now, instead of enqueing a large number of
// requests, the merger maintains hierarchical information regarding parents and
// their children in its record classes, and stores necessary requests in a
// manager which doles out requests as we need them.
//
// The idea is, is that we will spin off a single request which will begin
// executing the first topmost request, say "ClassA:.  As we execute the request
// for instances of "ClassA" if the request is throttled in the merger, we check
// if we have submitted a request to handle children of "ClassA".  If not, then
// prior to throttling, we will schedule a "Children of ClassA" request.  This
// request will use the merger record for "ClassA" to determine what child classes
// there are for "ClassA", and then we will walk the child classes, pulling the
// appropriate requests from the merger request manager.
//
// As we process each request, it in turn may be throttled, at which point we will
// spin off another child request.  In this way, we limit the number of threads
// required to service the query to at most one per level of a hierarchy.  In each
// case, once all children are processed, we will return the thread back to the
// threadpool.
//
// Note that we are absolutely reliant on the threadpool recognizing that these
// requests are all dependent requests and ensuring that they WILL be processed.
//


//
// CMergerReq
//
// Base class for all merger requests.
//

class CMergerReq : public CNamespaceReq
{
private:

public:
	CMergerReq( CWbemNamespace* pNamespace, IWbemObjectSink* pHandler,
              IWbemContext* pContext)
			  : CNamespaceReq( pNamespace, pHandler, pContext, true )
	{};

	~CMergerReq() {};

	virtual BOOL IsStatic( void ) { return FALSE; }
};

//
// Class Request Base Class
//

class CMergerClassReq : public CMergerReq
{
protected:
	CWmiMerger*			m_pMerger;
	CWmiMergerRecord*	m_pParentRecord;
	CBasicObjectSink*	m_pSink;


public:
	CMergerClassReq( CWmiMerger* pMerger, CWmiMergerRecord* pParentRecord,
				CWbemNamespace* pNamespace, CBasicObjectSink* pHandler, 
				IWbemContext* pContext);

	~CMergerClassReq();

    virtual BOOL IsLongRunning() {return TRUE;}

    void DumpError();

};

//
// Parent Class Request
//

class CMergerParentReq : public CMergerClassReq
{
public:
	CMergerParentReq( CWmiMerger* pMerger, CWmiMergerRecord* pParentRecord,
				CWbemNamespace* pNamespace, CBasicObjectSink* pHandler, 
				IWbemContext* pContext)
				: CMergerClassReq( pMerger, pParentRecord, pNamespace, pHandler, pContext )
	{};

	~CMergerParentReq() {};

    HRESULT Execute ();

};

//
// Child Class Request
//

class CMergerChildReq : public CMergerClassReq
{

public:
	CMergerChildReq( CWmiMerger* pMerger, CWmiMergerRecord* pParentRecord,
				CWbemNamespace* pNamespace, CBasicObjectSink* pHandler, 
				IWbemContext* pContext)
				: CMergerClassReq( pMerger, pParentRecord, pNamespace, pHandler, pContext )
	{};

	~CMergerChildReq() {};

    HRESULT Execute ();
};


// Base class for Dynamic requests
class CMergerDynReq : public CMergerReq
{
private:
	CVar	m_varClassName;

public:
	CMergerDynReq(CWbemObject* pClassDef, CWbemNamespace* pNamespace, IWbemObjectSink* pHandler,
              IWbemContext* pContext);

	~CMergerDynReq() {};

	LPCWSTR GetName( void )	{ return m_varClassName.GetLPWSTR(); }
};

//
// CMergerDynReq_DynAux_GetInstances
//
// This request processes CreateInstanceEnum calls to providers.
//

class CMergerDynReq_DynAux_GetInstances : public CMergerDynReq
{
private:

	CWbemObject *m_pClassDef ;
	IWbemContext *m_pCtx ;
    long m_lFlags ;
    CBasicObjectSink *m_pSink ;

public:

    CMergerDynReq_DynAux_GetInstances (

		CWbemNamespace *pNamespace ,
		CWbemObject *pClassDef ,
		long lFlags ,
		IWbemContext *pCtx ,
		CBasicObjectSink *pSink

	) :	CMergerDynReq (
			pClassDef ,
			pNamespace , 
			pSink , 
			pCtx
		) ,
        m_pClassDef(pClassDef), 
		m_pCtx(pCtx), 
		m_pSink(pSink),
		m_lFlags(lFlags)
	{
		if (m_pClassDef)
		{
			m_pClassDef->AddRef () ;
		}

		if (m_pCtx)
		{
			m_pCtx->AddRef () ;
		}

		if (m_pSink)
		{
			m_pSink->AddRef () ;
		}
	}

	~CMergerDynReq_DynAux_GetInstances ()
	{
		if (m_pClassDef)
		{
			m_pClassDef->Release () ;
		}

		if (m_pCtx)
		{
			m_pCtx->Release () ;
		}

		if (m_pSink)
		{
			m_pSink->Release () ;
		}
	}

    HRESULT Execute ();

    virtual BOOL IsLongRunning() {return TRUE;}

    void DumpError();
};

//
// CMergerDynReq_DynAux_ExecQueryAsync
//
// This request processes ExecQuery calls to providers.
//

class CMergerDynReq_DynAux_ExecQueryAsync : public CMergerDynReq
{
private:

	CWbemObject *m_pClassDef ;
    LPWSTR m_Query ;
    LPWSTR m_QueryFormat ;
	IWbemContext *m_pCtx ;
    long m_lFlags ;
    CBasicObjectSink *m_pSink ;
	HRESULT m_Result ;

public:

    CMergerDynReq_DynAux_ExecQueryAsync (

		CWbemNamespace *pNamespace ,
		CWbemObject *pClassDef ,
		long lFlags ,
		LPCWSTR Query,
		LPCWSTR QueryFormat,
		IWbemContext *pCtx ,
		CBasicObjectSink *pSink

	) :	CMergerDynReq (
			pClassDef,
			pNamespace , 
			pSink , 
			pCtx
		) ,
        m_pClassDef(pClassDef), 
		m_pCtx(pCtx), 
		m_pSink(pSink),
		m_lFlags(lFlags),
		m_Query(NULL),
		m_QueryFormat(NULL),
		m_Result (S_OK)
	{
		if (m_pClassDef)
		{
			m_pClassDef->AddRef () ;
		}

		if (m_pCtx)
		{
			m_pCtx->AddRef () ;
		}

		if (m_pSink)
		{
			m_pSink->AddRef () ;
		}

		if (Query)
		{
			m_Query = SysAllocString ( Query ) ;
			if ( m_Query == NULL )
			{
				m_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		if (QueryFormat)
		{
			m_QueryFormat = SysAllocString ( QueryFormat ) ;
			if ( m_QueryFormat == NULL )
			{
				m_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	HRESULT Initialize () 
	{
		return m_Result ;
	}

	~CMergerDynReq_DynAux_ExecQueryAsync ()
	{
		if (m_pClassDef)
		{
			m_pClassDef->Release () ;
		}

		if (m_pCtx)
		{
			m_pCtx->Release () ;
		}

		if (m_pSink)
		{
			m_pSink->Release () ;
		}

		if (m_Query)
		{
			SysFreeString ( m_Query ) ;
		}

		if (m_QueryFormat)
		{
			SysFreeString ( m_QueryFormat ) ;
		}
	}

    HRESULT Execute ();

    virtual BOOL IsLongRunning() {return TRUE;}

    void DumpError();
};

//
// CMergerDynReq_Static_GetInstances
//
// This request processes CreateInstanceEnum calls to the repository.
//

class CMergerDynReq_Static_GetInstances : public CMergerDynReq
{
private:

	CWbemObject *m_pClassDef ;
	IWbemContext *m_pCtx ;
    long m_lFlags ;
    CBasicObjectSink *m_pSink ;
	QL_LEVEL_1_RPN_EXPRESSION* m_pParsedQuery;

public:

    CMergerDynReq_Static_GetInstances (

		CWbemNamespace *pNamespace ,
		CWbemObject *pClassDef ,
		long lFlags ,
		IWbemContext *pCtx ,
		CBasicObjectSink *pSink ,
		QL_LEVEL_1_RPN_EXPRESSION* pParsedQuery

	);
	
	~CMergerDynReq_Static_GetInstances ();

    HRESULT Execute ();

    virtual BOOL IsLongRunning() {return TRUE;}

    void DumpError();

	BOOL IsStatic( void ) { return TRUE; }

};


//
// CWmiMergerRequestMgr
//
// Manager class for Merger Requests.  It keeps an array of sorted arrays
// corresponding to the actual requests we will be performing.  The sorted
// arrays contain merger requests for handling calls to the various
// dynamic instance providers.
//

class CWmiMergerRequestMgr
{
	CWmiMerger*		m_pMerger;
	CFlexArray		m_HierarchyArray;
	DWORD			m_dwNumRequests;
	DWORD			m_dwMinLevel;
	DWORD			m_dwMaxLevel;
	DWORD			m_dwLevelMask;
	DWORD*			m_pdwLevelMask;

public:
	CWmiMergerRequestMgr( CWmiMerger* pMerger );
	~CWmiMergerRequestMgr();

	HRESULT AddRequest( CMergerDynReq* pReq, DWORD dwLevel );
	HRESULT RemoveRequest( DWORD dwLevel, LPCWSTR pwszName, CMergerReq** ppReq );
	HRESULT GetTopmostParentReqName( WString& wsClassName );
	BOOL	HasSingleStaticRequest( void );
	HRESULT Clear();
	void DumpRequestHierarchy( void );

	DWORD GetNumRequests( void ) { return m_dwNumRequests; }
};

#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\login.cpp ===
//depot/private/wmi_branch2/admin/wmi/wbem/Winmgmt/coredll/login.cpp#3 - edit change 16081 (text)
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    LOGIN.CPP

Abstract:

    WinMgmt Secure Login Module

History:

    raymcc        06-May-97       Created.
    raymcc        28-May-97       Updated for NT5/Memphis beta releases.
    raymcc        07-Aug-97       Group support and NTLM fixes.

--*/

#include "precomp.h"
#include <arena.h>
#include <stdio.h>
#include <wbemcore.h>
#include <genutils.h>
#include <winntsec.h>
#include <objidl.h>

#define ACCESS_DENIED_DELAY 5000
#include "md5wbem.h"
#include "sechelp.h"

#include <memory>
#include <lmerr.h>
#include <scopeguard.h>

void _ObjectCreated(DWORD);
void _ObjectDestroyed(DWORD);


static LPCWSTR LocateNamespaceSubstring(LPWSTR pSrc);

#define MAX_LANG_SIZE 255

void PossiblySetLocale(REFIID riid, void ** pInterface,LPCWSTR  pLocale)
{
    if(riid == IID_IWbemServices || riid == IID_IWbemServicesEx)
        if(pLocale)
        {
            CWbemNamespace * pProv = (CWbemNamespace *)*pInterface;
            pProv->SetLocale(pLocale);
        }
}

HRESULT EnsureInitialized();

HRESULT InitAndWaitForClient()
{
    HRESULT hr = EnsureInitialized();
    if(FAILED(hr)) 
        return hr;
    hr = ConfigMgr::WaitUntilClientReady();
        if(FAILED(hr)) return hr;
    return hr;
}
//***************************************************************************
//
//  GetDefaultLocale
//
//  Returns the user default locale ID, formatted correctly.
//
//***************************************************************************

LPWSTR GetDefaultLocale()
{
    LCID lcid;
    IServerSecurity * pSec = NULL;
    HRESULT hr = CoGetCallContext(IID_IServerSecurity, (void**)&pSec);
    if(SUCCEEDED(hr))
    {
        BOOL bImpersonating = pSec->IsImpersonating();
        if(bImpersonating == FALSE)
            hr = pSec->ImpersonateClient();
        lcid = GetUserDefaultLCID();
        if(bImpersonating == FALSE && SUCCEEDED(hr))
            pSec->RevertToSelf();
        pSec->Release();
    }
    else
        lcid = GetUserDefaultLCID();
    
    if(lcid == 0)
    {
        ERRORTRACE((LOG_WBEMCORE, "GetUserDefaultLCID failed, restorting to system verion"));
        lcid = GetSystemDefaultLCID();
    }
    if(lcid == 0)
    {
        ERRORTRACE((LOG_WBEMCORE, "GetSystemDefaultLCID failed, restorting hard coded 0x409"));
        lcid = 0x409;
    }

    wchar_t *pwName = NULL;
    if (lcid)
    {
        TCHAR szNew[MAX_LANG_SIZE + 1];
        TCHAR *pszNew = szNew;
        int iRet;
        iRet = GetLocaleInfo(lcid, LOCALE_IDEFAULTLANGUAGE, pszNew, MAX_LANG_SIZE);

        if (iRet > 0)
        {

            // Strip off initial zeros.
            while (pszNew[0] == __TEXT('0'))
            {
                pszNew++;
                iRet--;
            }

            pwName = new wchar_t[iRet + 4];
            if (pwName)
            {
#ifdef UNICODE
                wsprintf(pwName, __TEXT("ms_%s"), pszNew);
#else
                swprintf(pwName, L"ms_%S", pszNew);
#endif
                iRet += 3;
                pwName[iRet] = L'\0';
            }
        }

    }
    return pwName;
}

//***************************************************************************
//
//  FindSlash
//
//  A local for finding the first '\\' or '/' in a string.  Returns null
//  if it doesnt find one.
//
//***************************************************************************
// ok


const WCHAR * FindSlash(LPCWSTR pTest)
{
    if(pTest == NULL)
        return NULL;
    for(;*pTest;pTest++)
        if(IsSlash(*pTest))
            return pTest;
    return NULL;
}

//***************************************************************************
//
//  CWbemLocator::CWbemLocator
//
//  Constructor.
//
//***************************************************************************
// ok
CWbemLocator::CWbemLocator()
{
    _ObjectCreated(OBJECT_TYPE_LOCATOR);
    m_uRefCount = 0;
}


//***************************************************************************
//
//  CWbemLocator::~CWbemLocator
//
//  Destructor.
//
//***************************************************************************
// ok
CWbemLocator::~CWbemLocator()
{
    _ObjectDestroyed(OBJECT_TYPE_LOCATOR);
}

//***************************************************************************
//
//  CWbemLocator::QueryInterface, AddREf, Release
//
//  Standard IUnknown implementation.
//
//***************************************************************************
// ok
SCODE CWbemLocator::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = 0;

    if (IID_IUnknown==riid || IID_IWbemLocator==riid)
    {
        *ppvObj = (IWbemLocator*)this;
        AddRef();
        return NOERROR;
    }
    else if (IID_IWbemConnection==riid)
    {
        *ppvObj = (IWbemConnection*)this;
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

//***************************************************************************
//
//***************************************************************************
// ok

ULONG CWbemLocator::AddRef()
{
    return ++m_uRefCount;
}

//***************************************************************************
//
//***************************************************************************
// ok

ULONG CWbemLocator::Release()
{
    ULONG uNewCount = InterlockedDecrement((LONG *) &m_uRefCount);
    if (0 == uNewCount)
        delete this;
    return uNewCount;
}

//***************************************************************************
//
//***************************************************************************
// ok
HRESULT CWbemLocator::GetNamespace(
    IN  READONLY   LPCWSTR ObjectPath,
    IN  READONLY   LPCWSTR User,
    IN  READONLY   LPCWSTR Locale,
    IWbemContext *pCtx,
    IN  READONLY   DWORD dwSecFlags,
    IN  READONLY   DWORD dwPermission,
    REFIID riid, void **pInterface,
    bool bAddToClientList, long lClientFlags)
{
    bool bIsLocal = false;
    bool bIsImpersonating = WbemIsImpersonating();

    LPWSTR pLocale = (LPWSTR)Locale;

    // Parameter validation.
    // =====================

    if (ObjectPath == 0 || pInterface == 0)
        return WBEM_E_INVALID_PARAMETER;

    *pInterface = NULL;

    // Check if there is a server name in front.  If so,
    // we skip past it, because by definition any call
    // reaching us was intended for us anyway.
    // =================================================

    LPCWSTR wszNamespace;
    if (IsSlash(ObjectPath[0]) && IsSlash(ObjectPath[1]))
    {
        // Find the next slash
        // ===================

        const WCHAR* pwcNextSlash = FindSlash(ObjectPath+2);

        if (pwcNextSlash == NULL)
            return WBEM_E_INVALID_PARAMETER;

        // Dont allow server names when using Admin, Authen, or UnAuthen locators

        if(pwcNextSlash != ObjectPath+3 || ObjectPath[2] != L'.')
            return WBEM_E_INVALID_PARAMETER;

        wszNamespace = pwcNextSlash+1;
    }
    else
    {
        wszNamespace = ObjectPath;
    }

    WCHAR TempUser[MAX_PATH];
    bool bGetUserName = (bIsImpersonating && User == NULL);

    // If the user name was not specified and the thread is impersonating, get the user
    // name.  This is used for things like the provider cache.

    if(bGetUserName)
    {
        CNtSid sid(CNtSid::CURRENT_THREAD);
        TempUser[0] = 0;
        LPWSTR pRetAccount, pRetDomain;
        DWORD dwUse;
        if(0 == sid.GetInfo(&pRetAccount, &pRetDomain, &dwUse))
        {
            if(wcslen(pRetDomain) + wcslen(pRetAccount) < MAX_PATH-2)
            {
                wcscpy(TempUser, pRetDomain);
                wcscat(TempUser, L"\\");
                wcscat(TempUser, pRetAccount);
            }
            delete [] pRetAccount;
            delete [] pRetDomain;
        }
    }

    // Try to locate the namespace and bind an object to it.
    // =====================================================

    CCoreServices *pSvc = CCoreServices::CreateInstance();
	if(pSvc == NULL)
		return WBEM_E_OUT_OF_MEMORY;

	CReleaseMe rm(pSvc);

    long lIntFlags = WMICORE_CLIENT_ORIGIN_INPROC;
    if(bAddToClientList)
        lIntFlags |= WMICORE_CLIENT_TYPE_ALT_TRANSPORT;


    HRESULT hr;
    
    {
        CAutoImpersonate ai;

	    hr = pSvc->GetServices2(
            ObjectPath,
            User,
            pCtx,
            lClientFlags, //* [in] */ ULONG uClientFlags,
            0, ///* [in] */ DWORD dwSecFlags,
            0, //* [in] */ DWORD dwPermissions,
            lIntFlags, ///* [in] */ ULONG uInternalFlags,
            NULL,
            0XFFFFFFFF,
            riid,
            pInterface);

		if ( FAILED ( ai.Impersonate ( ) ) )
		{
			hr = WBEM_E_FAILED ;
		}
    }

	if(FAILED(hr))
		return hr;

    if(riid == IID_IWbemServices || riid == IID_IWbemServicesEx)
    {
        CWbemNamespace * pProv = (CWbemNamespace *)*pInterface;
        pProv->SetIsProvider(TRUE);
    }

    //////// todo, security check???

    if (!Locale || !wcslen(Locale))
    {
        pLocale = GetDefaultLocale();
        PossiblySetLocale(riid, pInterface,pLocale);
        delete pLocale;
    }
    else
        PossiblySetLocale(riid, pInterface,Locale);

    return WBEM_NO_ERROR;
}





STDMETHODIMP CWbemAdministrativeLocator::ConnectServer(
         const BSTR NetworkResource, const BSTR User, const BSTR Password, const BSTR Locale,
         LONG lSecurityFlags, const BSTR Authority, IWbemContext *pCtx,
         IWbemServices **ppNamespace
        )
{
    HRESULT hr = EnsureInitialized();
    if(FAILED(hr)) 
        return hr;
    return GetNamespace(NetworkResource,  ADMINISTRATIVE_USER, Locale, pCtx,
            0, FULL_RIGHTS,IID_IWbemServices, (void **)ppNamespace, false, lSecurityFlags);
}

HRESULT CWbemAdministrativeLocator::Open( 
        /* [in] */ const BSTR strObject,
        /* [in] */ const BSTR strUser,
        /* [in] */ const BSTR strPassword,
        /* [in] */ const BSTR strLocale,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pInterface,
        /* [out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *pCallRes)
{
    HRESULT hr = EnsureInitialized();
    if(FAILED(hr)) 
        return hr;
    return GetNamespace(strObject,  ADMINISTRATIVE_USER, strLocale, pCtx,
            0, FULL_RIGHTS,riid, pInterface, false, lFlags);
}

STDMETHODIMP CWbemAuthenticatedLocator::ConnectServer(
         const BSTR NetworkResource, const BSTR User, const BSTR Password, const BSTR Locale,
         LONG lSecurityFlags, const BSTR Authority, IWbemContext *pCtx,
         IWbemServices **ppNamespace
        )
{

    HRESULT hr = InitAndWaitForClient();
    if(FAILED(hr)) 
        return hr;

    return GetNamespace(NetworkResource,  User, Locale,  pCtx,
            0, FULL_RIGHTS, IID_IWbemServices, (void **)ppNamespace, true, lSecurityFlags);
}

HRESULT CWbemAuthenticatedLocator::Open( 
        /* [in] */ const BSTR strObject,
        /* [in] */ const BSTR strUser,
        /* [in] */ const BSTR strPassword,
        /* [in] */ const BSTR strLocale,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pInterface,
        /* [out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *pCallRes)
{
    HRESULT hr = InitAndWaitForClient();
    if(FAILED(hr)) 
        return hr;
    return GetNamespace(strObject,  strUser, strLocale, pCtx,
            0, FULL_RIGHTS, riid, (void **)pInterface, true, lFlags);
}

STDMETHODIMP CWbemUnauthenticatedLocator::ConnectServer(
         const BSTR NetworkResource, const BSTR User, const BSTR Password, const BSTR Locale,
         LONG lSecurityFlags, const BSTR Authority, IWbemContext *pCtx,
         IWbemServices **ppNamespace
        )
{
    HRESULT hr = InitAndWaitForClient();
    if(FAILED(hr)) 
        return hr;

    // If this is not nt and the user is not remote, give full access.
    // To determine if a 9x user is local, the user name is examined for
    // a backslash. (ex redmond\user).  The presense of a backslash indicates
    // a non local user

    BOOL bNT = IsNT();
    BOOL b9XLocalUser = FALSE;
    if(!bNT && User)
    {
        WCHAR * pTemp;
        for(pTemp = User; *pTemp; pTemp++)
            if(*pTemp == L'\\')
                break;

        if(*pTemp == 0)
            b9XLocalUser = TRUE;

    }
    else if(!bNT && User == NULL)
            b9XLocalUser = TRUE;


    return GetNamespace(NetworkResource,  User, Locale, pCtx,
            0,
            (b9XLocalUser) ? FULL_RIGHTS : 0,
            IID_IWbemServices, (void **)ppNamespace, false, lSecurityFlags);
}

HRESULT CWbemUnauthenticatedLocator::Open( 
        /* [in] */ const BSTR strObject,
        /* [in] */ const BSTR strUser,
        /* [in] */ const BSTR strPassword,
        /* [in] */ const BSTR strLocale,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pInterface,
        /* [out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *pCallRes)
{
    HRESULT hr = InitAndWaitForClient();
    if(FAILED(hr)) 
        return hr;
    return GetNamespace(strObject,  strUser, strLocale, pCtx,
            0, 0, riid, (void **)pInterface, false, lFlags);
}


//***************************************************************************
//
//  CWbemLevel1Login::CWbemLevel1Login
//
//***************************************************************************
// ok

CWbemLevel1Login::CWbemLevel1Login()
{
    m_pszUser = 0;
    m_pszDomain = 0;
    m_uRefCount = 0;
    m_pwszClientMachine = 0;
    m_lClientProcId = -1;         // never been set
    _ObjectCreated(OBJECT_TYPE_WBEMLOGIN);
    gClientCounter.AddClientPtr((IWbemLevel1Login*)this, LOGIN);
}


//***************************************************************************
//
//  CWbemLevel1Login::~CWbemLevel1Login
//
//  Destructor
//
//***************************************************************************
// ok

CWbemLevel1Login::~CWbemLevel1Login()
{
    delete [] m_pszUser;
    delete [] m_pszDomain;
    delete [] m_pwszClientMachine;
    _ObjectDestroyed(OBJECT_TYPE_WBEMLOGIN);
    gClientCounter.RemoveClientPtr((IWbemLevel1Login*)this);
}

//***************************************************************************
//
//  CWbemLevel1Login::QueryInterface, AddREf, Release
//
//  Standard IUnknown implementation.
//
//***************************************************************************
// ok
SCODE CWbemLevel1Login::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = 0;

    if (IID_IUnknown==riid || IID_IWbemLevel1Login==riid)
    {
        *ppvObj = (IWbemLevel1Login*)this;
        AddRef();
        return NOERROR;
    }
    else if(IID_IWbemLoginHelper==riid)
    {
        *ppvObj = (IWbemLoginHelper*)this;
        AddRef();
        return NOERROR;
    }
    else if(IID_IWbemConnectorLogin==riid)
    {
        *ppvObj = (IWbemConnectorLogin*)this;
        AddRef();
        return NOERROR;
    }
    else if(IID_IWbemLoginClientID==riid)
    {
        *ppvObj = (IWbemLoginClientID*)this;
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

//***************************************************************************
//
//***************************************************************************
// ok

ULONG CWbemLevel1Login::AddRef()
{
    return ++m_uRefCount;
}

//***************************************************************************
//
//***************************************************************************
// ok

ULONG CWbemLevel1Login::Release()
{
    ULONG uNewCount = InterlockedDecrement((LONG *) &m_uRefCount);
    if (0 == uNewCount)
        delete this;
    return uNewCount;
}

//***************************************************************************
//
//  CWbemLevel1Login::EstablishPosition
//
//  Initiates proof of locality.
//
//***************************************************************************
// ok
HRESULT CWbemLevel1Login::EstablishPosition(
                                LPWSTR wszMachineName,
                                DWORD dwProcessId,
                                DWORD* phAuthEventHandle)
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//  CWbemLevel1Login::RequestChallenge
//
//  Requests a WBEM Level 1 challenge.
//
//***************************************************************************
// ok

HRESULT CWbemLevel1Login::RequestChallenge(
                            LPWSTR wszNetworkResource,
                            LPWSTR pUser,
                            WBEM_128BITS Nonce
    )
{
    return WBEM_E_NOT_SUPPORTED;
}

//***************************************************************************
//
//  CWbemLevel1Login::WBEMLogin
//
//  Logs the user in to WBEM using WBEM authentication
//
//***************************************************************************
// ok

HRESULT CWbemLevel1Login::WBEMLogin(
    LPWSTR pPreferredLocale,
    WBEM_128BITS AccessToken,
    LONG lFlags,
    IWbemContext *pCtx,
    IWbemServices **ppNamespace
    )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//  CWbemLevel1Login::IsValidLocale
//
//  Checks if the supplied locale string is valid
//
//***************************************************************************
BOOL CWbemLevel1Login::IsValidLocale(LPCWSTR wszLocale)
{
    if(wszLocale && *wszLocale)
    {
        // This has to be temporary - this eventually
        // will support non-MS locales?
        // ==========================================

        if(_wcsnicmp(wszLocale, L"ms_", 3))
            return FALSE;

        WCHAR* pwcEnd = NULL;
        wcstoul(wszLocale+3, &pwcEnd, 16);
        if(pwcEnd == NULL || *pwcEnd != 0)
        {
            return FALSE;
        }
    }

    return TRUE;
}

//***************************************************************************
//
//  CWbemLevel1Login::SetEvent(LPCSTR sEventToSet)
//
//  Used to prove local access
//
//***************************************************************************

HRESULT CWbemLevel1Login::SetEvent(LPCSTR sEventToSet)
{
    HRESULT hr = CoImpersonateClient();
    if (FAILED(hr)) return hr;

    ON_BLOCK_EXIT(CoRevertToSelf);
    wchar_t *pEventName = new wchar_t[strlen(sEventToSet) + 1];
    if (pEventName == 0)
        return WBEM_E_OUT_OF_MEMORY;

    mbstowcs(pEventName, sEventToSet, strlen(sEventToSet) + 1);
    CDeleteMe<wchar_t> delMe(pEventName);



    HANDLE hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, pEventName);
    if(hEvent == NULL)
        return WBEM_E_FAILED;
    ::SetEvent(hEvent);
    CloseHandle(hEvent);
    return S_OK;
}

HRESULT CWbemLevel1Login::SetClientInfo( 
            /* [string][unique][in] **/ LPWSTR wszClientMachine,
            /* [in] */ LONG lClientProcId,
            /* [in] */ LONG lReserved)
{

    if(wszClientMachine)
    {
        int iLen = wcslen(wszClientMachine) + 1;
        m_pwszClientMachine = new WCHAR[iLen];
        if(m_pwszClientMachine == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        wcscpy(m_pwszClientMachine, wszClientMachine);
    }
    m_lClientProcId = lClientProcId;
    return S_OK;
}


HRESULT CWbemLevel1Login::ConnectorLogin( 
            /* [string][unique][in] */ LPWSTR wszNetworkResource,
            /* [string][unique][in] */ LPWSTR wszPreferredLocale,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pInterface)
{
    HRESULT hRes;

    HRESULT hr = InitAndWaitForClient();
    if(FAILED(hr)) 
        return hr;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL ConnectionLogin::NTLMLogin\n"
        "   wszNetworkResource = %S\n"
        "   pPreferredLocale = %S\n"
        "   lFlags = 0x%X\n",
        wszNetworkResource,
        wszPreferredLocale,
        lFlags
        ));

    if(pInterface == NULL || wszNetworkResource == NULL)
        return WBEM_E_INVALID_PARAMETER;

	if(lFlags != 0 && lFlags != WBEM_FLAG_CONNECT_REPOSITORY_ONLY)
        return WBEM_E_INVALID_PARAMETER;

    *pInterface = 0;       // default

    if(!CWin32DefaultArena::ValidateMemSize())
    {
        ERRORTRACE((LOG_WBEMCORE, "NTLM authentication was rejected due to low memory"));
        return WBEM_E_OUT_OF_MEMORY;
    }

    try
    {
	    // Retrieve DCOM security context
	    // ==============================

	    IServerSecurity* pSec;
	    hRes = WbemCoGetCallContext(IID_IServerSecurity, (void**)&pSec);
	    if(FAILED(hRes))
	    {
	        //
	        // Not a problem --- just somebody coming from in-proc.  Use
	        // unauthenticated locator
	        //

		    return LoginUser(wszNetworkResource, wszPreferredLocale, lFlags,
	                                    pCtx, true, riid, pInterface, true);

	    }

	    // Release this pointer when we go out of scope.

	    CReleaseMe  rm( pSec );

	    // Check connection settings
	    // =========================

	    DWORD dwAuthnSvc, dwAuthzSvc, dwAuthnLevel, dwCapabilities;
	    LPWSTR wszClientName;

	    // Ensures auto release of the mutex if we crash
	    CAutoSecurityMutex  autosm;

	    hRes = pSec->QueryBlanket(&dwAuthnSvc, &dwAuthzSvc, NULL, &dwAuthnLevel,
	                            NULL, (void**)&wszClientName, &dwCapabilities);
	    if(FAILED(hRes))
	    {

	        // In some cases, we cant get the name, but the rest is ok.  In particular
	        // the temporary SMS accounts have that property.

	        hRes = pSec->QueryBlanket(&dwAuthnSvc, &dwAuthzSvc, NULL, &dwAuthnLevel,
	                                NULL, NULL, &dwCapabilities);
	        wszClientName = NULL;
	    }

	    // We don't need this anymore.
	    autosm.Release();

	    if(FAILED(hRes))
	    {
	        ERRORTRACE((LOG_WBEMCORE, "Unable to retrieve NTLM connection settings."
	                        " Error code: 0x%X\n", hRes));
	        Sleep(ACCESS_DENIED_DELAY);
	        return WBEM_E_ACCESS_DENIED;
	    }

	    BOOL bGotName = (wszClientName && (wcslen(wszClientName) > 0));

	    char* szLevel = NULL;
	    switch(dwAuthnLevel)
	    {
	    case RPC_C_AUTHN_LEVEL_NONE:
	        DEBUGTRACE((LOG_WBEMCORE, "DCOM connection which is unathenticated "
	                    ". NTLM authentication failing.\n"));
	        Sleep(ACCESS_DENIED_DELAY);
	        return WBEM_E_ACCESS_DENIED;
	    case RPC_C_AUTHN_LEVEL_CONNECT:
	        szLevel = "Connect";
	        break;
	    case RPC_C_AUTHN_LEVEL_CALL:
	        szLevel = "Call";
	        break;
	    case RPC_C_AUTHN_LEVEL_PKT:
	        szLevel = "Packet";
	        break;
	    case RPC_C_AUTHN_LEVEL_PKT_INTEGRITY:
	        szLevel = "Integrity";
	        break;
	    case RPC_C_AUTHN_LEVEL_PKT_PRIVACY:
	        szLevel = "Privacy";
	        break;
	    };

	    DEBUGTRACE((LOG_WBEMCORE, "DCOM connection from %S at authentiction level "
	                    "%s, AuthnSvc = %d, AuthzSvc = %d, Capabilities = %d\n",
	        wszClientName, szLevel, dwAuthnSvc, dwAuthzSvc, dwCapabilities));

	    // Parse the user name
	    // ===================

	    if(bGotName)
	    {
	        WCHAR* pwcSlash = wcschr(wszClientName, '\\');
	        if(pwcSlash == NULL)
	        {
	            ERRORTRACE((LOG_WBEMCORE, "Misformed username %S received from DCOM\n",
	                            wszClientName));
	            Sleep(ACCESS_DENIED_DELAY);
	            return WBEM_E_ACCESS_DENIED;
	        }

	        WCHAR* pszDomain = new WCHAR[pwcSlash - wszClientName + 1];
	        if(pszDomain == NULL)
	            return WBEM_E_OUT_OF_MEMORY;
	        wcsncpy(pszDomain, wszClientName, pwcSlash - wszClientName);
	        pszDomain[pwcSlash - wszClientName] = 0;

	        m_pszUser = Macro_CloneLPWSTR(wszClientName);

	         delete [] pszDomain;
	    }
	    else
	    {
	        m_pszUser = Macro_CloneLPWSTR(L"<unknown>");
	    }

	    // User authenticated. Proceed
	    // ============================

	    return LoginUser(wszNetworkResource, wszPreferredLocale, lFlags,
	                                    pCtx,  false, riid, pInterface, false);
    }
    catch(...) // COM interfaces do not throw
    {
        ExceptionCounter c;    
        return WBEM_E_CRITICAL_ERROR;
    }

}

//***************************************************************************
//
//  CWbemLevel1Login::NTLMLogin
//
//  Logs the user in to WBEM using NTLM authentication
//
//***************************************************************************
// ok

HRESULT CWbemLevel1Login::NTLMLogin(
    LPWSTR wszNetworkResource,
    LPWSTR pPreferredLocale,
    LONG lFlags,
    IWbemContext *pCtx,
    IWbemServices **ppNamespace
    )
{
	return ConnectorLogin(wszNetworkResource, pPreferredLocale, lFlags, pCtx,
							IID_IWbemServices, (void **)ppNamespace);
}

//***************************************************************************
//
//  CWbemLevel1Login::LoginUser
//
//  Logs the user in to WBEM who may or may not have already been authenticated.
//
//***************************************************************************
// ok

HRESULT CWbemLevel1Login::LoginUser(
    LPWSTR wszNetworkResource,
    LPWSTR pPreferredLocale,
    long lFlags,
    IWbemContext* pCtx,
    bool bAlreadyAuthenticated,
	REFIID riid,
    void **pInterface, bool bInProc)
{

    LPWSTR pLocale = pPreferredLocale;
    LPWSTR pToDelete = NULL;

    // Verify locale validity
    // Set default if not provided.
    // ============================

    if (!pLocale || !wcslen(pLocale))
    {
        pLocale = GetDefaultLocale();
        if (pLocale == 0)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        pToDelete = pLocale;
    }

    CDeleteMe<WCHAR> del1(pToDelete);

    if(!IsValidLocale(pLocale))
        return WBEM_E_INVALID_PARAMETER;

    // Locate the requested namespace.
    // ===============================

//    LPCWSTR pszNamespace = LocateNamespaceSubstring(wszNetworkResource);
//    if (pszNamespace == 0)
//        return WBEM_E_INVALID_NAMESPACE;

    // Grab the ns and hand it back to the caller.
    // ===========================================

    CCoreServices *pSvc = CCoreServices::CreateInstance();
	if(pSvc == NULL)
		return WBEM_E_OUT_OF_MEMORY;

	CReleaseMe rm(pSvc);

    long lIntFlags = 0;
    if(bInProc)
        lIntFlags = WMICORE_CLIENT_ORIGIN_INPROC;
    else
        lIntFlags = WMICORE_CLIENT_ORIGIN_LOCAL;


	HRESULT hr;
	if (lIntFlags & WMICORE_CLIENT_ORIGIN_INPROC)
	{
	    CAutoImpersonate ai;
		hr = pSvc->GetServices2(
	            wszNetworkResource,
	            m_pszUser,
	            pCtx,
	            lFlags, //* [in] */ ULONG uClientFlags,
	            0, ///* [in] */ DWORD dwSecFlags,
	            0, //* [in] */ DWORD dwPermissions,
	            lIntFlags, ///* [in] */ ULONG uInternalFlags,
                m_pwszClientMachine,
                m_lClientProcId,
	            riid,
	            pInterface);
		
		if ( FAILED ( ai.Impersonate ( ) ) )
		{
			hr = WBEM_E_FAILED ;
		}
    } 
    else 
    {
		hr = pSvc->GetServices2(
	            wszNetworkResource,
	            m_pszUser,
	            pCtx,
	            lFlags, //* [in] */ ULONG uClientFlags,
	            0, ///* [in] */ DWORD dwSecFlags,
	            0, //* [in] */ DWORD dwPermissions,
	            lIntFlags, ///* [in] */ ULONG uInternalFlags,
                m_pwszClientMachine,
                m_lClientProcId,
	            riid,
	            pInterface);    
    }

	if(FAILED(hr))
    {
        if(hr == WBEM_E_ACCESS_DENIED)
            Sleep(ACCESS_DENIED_DELAY);
		return hr;
    }
    PossiblySetLocale(riid, pInterface, pLocale);

    // Do a security check

    if(riid == IID_IWbemServices || riid == IID_IWbemServicesEx)
    {
        CWbemNamespace * pProv = (CWbemNamespace *)*pInterface;
        DWORD dwAccess = pProv->GetUserAccess();
        if((dwAccess  & WBEM_ENABLE) == 0)
        {
            pProv->Release();
            *pInterface = NULL;
            Sleep(ACCESS_DENIED_DELAY);
            return WBEM_E_ACCESS_DENIED;
        }
        pProv->SetPermissions(dwAccess);
    }
    else        // access check for object is done in universal connect
    {
        return S_OK;
    }
/*    CWbemNamespace *pProv = CWbemNamespace::CreateInstance();
    if (pProv == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    pProv->Initialize((LPWSTR)pszNamespace, m_pszUser,
                                    (bAlreadyAuthenticated) ? SecFlagWin9XLocal : 0,
                                    (bAlreadyAuthenticated) ? FULL_RIGHTS : 0, true, false);

    if (pProv->GetStatus())
    {
        HRESULT hRes = pProv->GetStatus();
        pProv->Release();
        return hRes;
    }
*/
    // Usually the user has not been authenticated
/*
    if(!bAlreadyAuthenticated)
    {
        DWORD dwAccess = pProv->GetUserAccess();
        if((dwAccess  & WBEM_ENABLE) == 0)
        {
            pProv->Release();
            Sleep(ACCESS_DENIED_DELAY);
            return WBEM_E_ACCESS_DENIED;
        }
        pProv->SetPermissions(dwAccess);
    }

    pProv->AddRef();
    pProv->SetLocale(pLocale);

    // Success. Return the pointer to the caller.
    // ==========================================
    *ppNamespace = pProv;
*/
    return WBEM_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

static LPCWSTR LocateNamespaceSubstring(LPWSTR pSrc)
{
    LPCWSTR pszNamespace;
    if (IsSlash(pSrc[0]) && IsSlash(pSrc[1]))
    {
          // Find the next slash
          // ===================

          const WCHAR* pwcNextSlash = FindSlash(pSrc+2);

          if (pwcNextSlash == NULL)
              return 0;

          pszNamespace = pwcNextSlash+1;
    }
    else
    {
        pszNamespace = pSrc;
    }

    return pszNamespace;
}


//***************************************************************************
//
//***************************************************************************

void CWbemLevel1Login::GetWin9XUserName()

{
    wchar_t wcUserName[256];
    TCHAR cUserName[256];
    DWORD dwSize = 256;
    if(GetUserName(cUserName, &dwSize))
    {
#ifdef UNICODE
        lstrcpy(wcUserName, cUserName);
#else
        mbstowcs(wcUserName, cUserName, 255);
#endif

        // Generally, user names dont have domain prefixes.  Make sure
        // that if it does, then the backslash is changed to a forward
        // slash.  This is important for the case where a provider loops
        // back to the unauthenticated login and it uses the user name to
        // differentiate between a local vs a remote account

        WCHAR * pTemp;
        for(pTemp = wcUserName; *pTemp; pTemp++)
            if(*pTemp == L'\\')
                *pTemp = L'/';
        m_pszUser = Macro_CloneLPWSTR(wcUserName);


    }
    else
        m_pszUser = Macro_CloneLPWSTR(L"<unknown>");
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\mergerthrottling.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MERGERTHROTTLING.CPP

Abstract:

    CMergerThrottling clas

History:

	30-Nov-00   sanjes    Created.

--*/


#include "precomp.h"

#pragma warning (disable : 4786)
#include <wbemcore.h>
#include <map>
#include <vector>
#include <perfhelp.h>
#include <genutils.h>
#include <oahelp.inl>
#include <wqllex.h>
#include "wmimerger.h"
#include "mergerthrottling.h"

static	long	g_lNumMergers = 0L;

//***************************************************************************
//
//***************************************************************************
//
CMergerThrottling::CMergerThrottling( void )
:	m_hParentThrottlingEvent( NULL ), m_hChildThrottlingEvent( NULL ), m_dwNumChildObjects( 0 ),
	m_dwNumParentObjects( 0 ), m_dwNumThrottledThreads( 0 ), m_bParentThrottled( false ),
	m_bChildThrottled( true ), m_bChildDone( false ), m_bParentDone( false ),
	m_dwThrottlingThreshold( 0 ), m_dwReleaseThreshold( 0 ), m_dwLastParentPing( 0 ),
	m_dwLastChildPing( 0 ), m_dwProviderDeliveryTimeout( 0xFFFFFFFF ), m_dwBatchingThreshold( 0 ),
	m_cs()
{
}

//***************************************************************************
//
//***************************************************************************
//
CMergerThrottling::~CMergerThrottling( void )
{
	_DBG_ASSERT( m_dwNumChildObjects == 0 && m_dwNumParentObjects == 0 );

	if ( NULL != m_hParentThrottlingEvent )
	{
		CloseHandle( m_hParentThrottlingEvent );
	}

	if ( NULL != m_hChildThrottlingEvent )
	{
		CloseHandle( m_hChildThrottlingEvent );
	}

}


// Two step initialization.  This retrieves values from registry to configure the
// behavior of our throttling mechanisms
HRESULT	CMergerThrottling::Initialize( void )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	ConfigMgr::GetMergerThresholdValues( &m_dwThrottlingThreshold, &m_dwReleaseThreshold,
										&m_dwBatchingThreshold );

	// Hold off on this until we work our way through
//	m_dwProviderDeliveryTimeout = ConfigMgr::GetProviderDeliveryTimeout();

	return hr;
}

// Call this function to perform proper throttling based on our registry
// configured values.
HRESULT CMergerThrottling::Throttle( bool bParent, CWmiMergerRecord* pMergerRecord )
{

	bool	bContinue = true;
	bool	bTimedOut = false;
	HRESULT	hr = WBEM_S_NO_ERROR;

	while ( bContinue && SUCCEEDED( hr ) )
	{
		// Scoped for proper cleanup if anything bad happens
		CCheckedInCritSec	ics( &m_cs );

		DWORD	dwAdjust = 0L;
		DWORD	dwWait = 0L;

		// If the timed out flag is set, we need to check if we are
		// really timed out
		if ( bTimedOut )
		{
			bTimedOut = VerifyTimeout( pMergerRecord->GetWmiMerger()->GetLastDeliveryTime(),
						pMergerRecord->GetWmiMerger()->NumArbitratorThrottling(), &dwAdjust );
		}

		if ( !bTimedOut )
		{
			HANDLE hEvent = ( bParent ? m_hParentThrottlingEvent : m_hChildThrottlingEvent );

			bool	bThrottle = ShouldThrottle( bParent );

			// These should NEVER both be TRUE
			_DBG_ASSERT( !( m_bParentThrottled && m_bChildThrottled ) );

			if ( m_bParentThrottled && m_bChildThrottled )
			{
				hr = WBEM_E_FAILED;
			}
			else if ( bThrottle )
			{
				hr = PrepareThrottle( bParent, &hEvent );

				// The wait on the throttle is the configured timeout minus dwAdjust
				if ( SUCCEEDED( hr ) )
				{
					dwWait = m_dwProviderDeliveryTimeout - dwAdjust;
				}
			}

			// Since we will wait if we choose to throttle, we should do
			// this OUTSIDE of our critical section

			ics.Leave();

			// Throttle only if appropriate
			if ( SUCCEEDED( hr ) )
			{
				if ( bThrottle )
				{

					// If we are about to throttle a parent, then we need to ensure a
					// child delivery request is scheduled
					if ( bParent )
					{
						hr = pMergerRecord->GetWmiMerger()->ScheduleMergerChildRequest( pMergerRecord );
					}

					if ( SUCCEEDED( hr ) )
					{
						InterlockedIncrement( (long*) &m_dwNumThrottledThreads );

	#ifdef __DEBUG_MERGER_THROTTLING
						WCHAR	wszTemp[128];
						wsprintf( wszTemp, L"Thread 0x%x throttled in merger 0x%x for 0x%x ms.\nParent Objects: %d, Child Objects: %d, Num Throttled Threads: %d\n", GetCurrentThreadId(),
							(DWORD_PTR) pMergerRecord->GetWmiMerger(), dwWait, m_dwNumParentObjects, m_dwNumChildObjects, m_dwNumThrottledThreads );
						OutputDebugStringW( wszTemp );
	#endif

						DEBUGTRACE((LOG_WBEMCORE, "Thread 0x%x throttled in merger for 0x%x ms.\nParent Objects: %d, Child Objects: %d, Num Throttled Threads: %d\n", GetCurrentThreadId(), dwWait, m_dwNumParentObjects, m_dwNumChildObjects, m_dwNumThrottledThreads ) );

						DWORD dwRet = CCoreQueue::QueueWaitForSingleObject( hEvent, dwWait );

						DEBUGTRACE((LOG_WBEMCORE, "Thread 0x%x woken up in merger.\n", GetCurrentThreadId() ) );

	#ifdef __DEBUG_MERGER_THROTTLING
						wsprintf( wszTemp, L"Thread 0x%x woken up in merger 0x%x.\n", GetCurrentThreadId(), (DWORD_PTR) pMergerRecord->GetWmiMerger() );
						OutputDebugStringW( wszTemp );
	#endif

						InterlockedDecrement( (long*) &m_dwNumThrottledThreads );

						// What to do here?
						_DBG_ASSERT( dwRet == WAIT_OBJECT_0 );
						if ( dwRet != WAIT_OBJECT_0 )
						{
							if ( dwRet == WAIT_TIMEOUT )
							{
								bTimedOut = true;
							}
							else
							{
								hr = WBEM_E_FAILED;
							}

						}	// IF event not signalled
						else
						{
							bContinue = false;
						}

					}	// IF OK

				}
				else
				{
					bContinue = false;
				}

			}	// IF we need to throttle

		}	// IF !bTimedOut
		else
		{
			hr = WBEM_E_PROVIDER_TIMED_OUT;
		}

	}	// WHILE check for throttling

	return hr;
}

// Call this to release any actual throttled threads.
bool CMergerThrottling::ReleaseThrottle( bool bForce /* = false */ )
{
	bool	bRelease = bForce;

	// Scoped for proper cleanup if anything bad happens
    CCheckedInCritSec	ics( &m_cs );

	if ( !bForce && ( m_bParentThrottled || m_bChildThrottled ) )
	{
		// These should NEVER both be TRUE
		_DBG_ASSERT( !( m_bParentThrottled && m_bChildThrottled ) );

		if ( !( m_bParentThrottled && m_bChildThrottled ) )
		{
			if ( m_bParentThrottled )
			{
				// We only release if we have exceeded the threshold.
				if ( m_dwNumParentObjects > m_dwNumChildObjects )
				{
					DWORD dwDiff = m_dwNumParentObjects - m_dwNumChildObjects;
					bRelease = ( dwDiff < m_dwReleaseThreshold );
				}
				else
				{
					// Always release if we are not greater than number of
					// child objects
					bRelease = true;
				}

			}
			else if ( m_bChildThrottled )
			{
				// We only release if we have exceeded the threshold.
				if ( m_dwNumChildObjects > m_dwNumParentObjects )
				{
					DWORD dwDiff = m_dwNumChildObjects - m_dwNumParentObjects;
					bRelease = ( dwDiff < m_dwReleaseThreshold );
				}
				else
				{
					// Always release if we are not greater than number of
					// child objects
					bRelease = true;
				}

			}

		}	// Only if NOT both
		else
		{
			// looks like both are throttled - we shouldn't be here, but go ahead and
			// release anyway
			bRelease = true;
		}


	}	// IF not bForce and something is throttled

	if ( bRelease )
	{
		m_bParentThrottled = false;
		m_bChildThrottled = false;
		
		// Should release everyone
		if ( NULL != m_hParentThrottlingEvent )
		{
			SetEvent( m_hParentThrottlingEvent );
		}

		// Should release everyone
		if ( NULL != m_hChildThrottlingEvent )
		{
			SetEvent( m_hChildThrottlingEvent );
		}

	}	// IF bRelease

	return bRelease;
}

// Called to log the fact that children instances are done
void CMergerThrottling::SetChildrenDone( void )
{
	// Scoped for proper cleanup if anything bad happens
    CCheckedInCritSec	ics( &m_cs );

	// Child is done - we should release throttling as well
	m_bChildDone = true;
	ReleaseThrottle( true );
}

// Called to log the fact that parent instances are done
void CMergerThrottling::SetParentDone( void )
{
	// Scoped for proper cleanup if anything bad happens
    CCheckedInCritSec	ics( &m_cs );

	// Parent is done - we should release throttling as well
	m_bParentDone = true;
	ReleaseThrottle( true );
}

// Causes us to clear any throttling we are doing
void CMergerThrottling::Cancel( void )
{
	// Scoped for proper cleanup if anything bad happens
    CCheckedInCritSec	ics( &m_cs );

	// Everything is just over with - release the throttle as well
	m_bChildDone = true;
	m_bParentDone = true;

	// No point in tracking these anymore.
	m_dwNumChildObjects = 0;
	m_dwNumParentObjects = 0;

	ReleaseThrottle( true );
}

// Helper function to check if we should throttle
bool CMergerThrottling::ShouldThrottle( bool bParent )
{
	bool	bThrottle = false;

	if ( bParent )
	{
		// If the child is done, no point in throttling
		if ( !m_bChildDone )
		{

			// If for some reason parent objects are coming in on multiple threads,
			// we *could* theoretically have to throttle multiple threads.  If we're
			// not already throttling, we should check if we need to.

			if ( !m_bParentThrottled )
			{
				// We only throttle if we have exceeded the threshold.
				if ( m_dwNumParentObjects > m_dwNumChildObjects )
				{
					DWORD dwDiff = m_dwNumParentObjects - m_dwNumChildObjects;
					bThrottle = ( dwDiff > m_dwThrottlingThreshold );
					m_bParentThrottled = bThrottle;
				}
			}
			else
			{
				bThrottle = true;;
			}

		}	// IF !m_bChildDone

	}
	else
	{
		// No point in continuing if the parent is done
		if ( !m_bParentDone )
		{
			// More likely that multiple child threads could be coming in (e.g. multiple
			// classes inheriting from a base class).

			if ( !m_bChildThrottled )
			{
				// We only throttle if we have exceeded the threshold.
				if ( m_dwNumChildObjects > m_dwNumParentObjects )
				{
					DWORD dwDiff = m_dwNumChildObjects - m_dwNumParentObjects;
					bThrottle = ( dwDiff > m_dwThrottlingThreshold );
					m_bChildThrottled = bThrottle;
				}
			}
			else
			{
				bThrottle = true;
			}

		}	// IF !m_bParentDone

	}

	return bThrottle;
}

// Helper function to prepare us for throttling
HRESULT CMergerThrottling::PrepareThrottle( bool bParent, HANDLE* phEvent )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// Create the event if we have to, otherwise reset it
	if ( NULL == *phEvent )
	{
		// Creates in an unsignalled state
		*phEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

		if ( NULL == *phEvent )
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
		else if ( bParent )
		{
			m_hParentThrottlingEvent = *phEvent;
		}
		else
		{
			m_hChildThrottlingEvent = *phEvent;
		}

	}
	else
	{
		// Make sure the event is reset
		BOOL	fSuccess = ResetEvent( *phEvent );

		// What to do here?
		_DBG_ASSERT( fSuccess );
		if ( !fSuccess )
		{
			hr = WBEM_E_FAILED;
		}
	}

	return hr;
}

// Helper function to verify if we timed out.  For example, we may have timed out on throttling
// but, actually be receiving (albeit slowly) objects from a child or parent.  Since we are getting
// stuff, we aren't really timed out, but we should adjust our wait time based on the difference
// since the last ping.

bool CMergerThrottling::VerifyTimeout( DWORD dwLastTick, long lNumArbThrottledThreads, DWORD* pdwAdjust )
{
	// We only do this of no threads are throttled in the arbitrator - since we may actually
	// just be slow.  So if there are throttled threads, we just return that we are not timed
	//out

	_DBG_ASSERT( lNumArbThrottledThreads >= 0 );
	if ( lNumArbThrottledThreads > 0 )
	{
		return false;
	}

	DWORD	dwCurrent = GetTickCount();

	// We must deal with the fact that a rollover *can* occur
	if ( dwCurrent >= dwLastTick )
	{
		*pdwAdjust = dwCurrent - dwLastTick;
	}
	else
	{
		// Accounts for rollover - 0xFFFFFFFF minus the last tick, plus the current
		// plus 1 will give us the number of elapsed ticks
		*pdwAdjust = dwCurrent + ( 0xFFFFFFFF - dwLastTick );
	}

	// If the difference is greater
	return ( *pdwAdjust > m_dwProviderDeliveryTimeout );
}

// Sets the proper ping variable and sends it to the main merger
DWORD CMergerThrottling::Ping( bool bParent, CWmiMerger* pWmiMerger )
{
	DWORD	dwTick = GetTickCount();

	if ( bParent )
	{
		m_dwLastParentPing = dwTick;
	}
	else
	{
		m_dwLastChildPing = dwTick;
	}

	// Sets the ping delivery
	pWmiMerger->PingDelivery( dwTick );

	return dwTick;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\objenum.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    OBJENUM.H

Abstract:

	Defines the class implementing IEnumWbemClassObject interface.

	Classes defined:

		CEnumWbemClassObject

History:

	a-raymcc        16-Jul-96       Created.

--*/

#ifndef _OBJENUM_H_
#define _OBJENUM_H_

// Forward class definitions
class CWbemGuidToClassMap;

//******************************************************************************
//******************************************************************************
//
//  class CEnumWbemClassObject
//
//  This class implements IEnumWbemClassObject interface 
//
//******************************************************************************
//
//  Constructor
//
//  PARAMETERS:
//
//      ULONG uInitialialRefCount              Initialize reference count of
//                                             the object. Defaults to 0.
//  
//  This function AddRefs the collection object.
//
//******************************************************************************
//
//  Destructor
//
//******************************************************************************
//*************************** interface IEnumWbemClassObject *******************
//
//  These methods are described in help.
//
//******************************************************************************

class CBasicEnumWbemClassObject : public IEnumWbemClassObject, public IWbemFetchSmartEnum
{
protected:
    LONG m_lRefCount;

public:
    CBasicEnumWbemClassObject(long lRef = 1) : m_lRefCount(lRef){}
    virtual ~CBasicEnumWbemClassObject(){}

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);
};

class CDataAccessor
{
    DWORD	m_dwTotal;
	DWORD	m_dwNumObjects;
public:
    CDataAccessor();
    virtual ~CDataAccessor();

    virtual BOOL Add(IWbemClassObject*) = 0;
    virtual BOOL Next(DWORD& rdwPos, IWbemClassObject*&) = 0;
    virtual BOOL IsResettable() = 0;
	virtual BOOL IsDone( DWORD dwPos ) = 0;
	virtual void Clear( void ) = 0;

    DWORD GetTotalSize(){ return m_dwTotal;}
	DWORD GetNumObjects(){ return m_dwNumObjects; }

protected:
    BOOL RecordAdd(IWbemClassObject* p);
    void ReportRemove(IWbemClassObject* p);
};

class CEnumeratorCommon
{
protected:

    long m_lRef;

    IErrorInfo* m_pErrorInfo;
    IWbemClassObject* m_pErrorObj;
    HRESULT m_hres;
    BOOL m_bComplete;
    IWbemServices* m_pNamespace;

    CRITICAL_SECTION m_cs;
    CWbemCriticalSection m_csNext;
    HANDLE	m_hReady;
	BOOL	m_fGotFirstObject;
	bool	m_fCheckMinMaxControl;
    DWORD m_dwNumDesired;
    CDataAccessor* m_pData;
    long	m_lFlags;
	long	m_lEntryCount;

	// These are so we can reset the enumeration if necessary
	WString	m_wstrQueryType;
	WString m_wstrQuery;
	IWbemContext*	m_pContext;
	long	m_lEnumType;

    class CEnumSink : public CObjectSink
    {
        CEnumeratorCommon*	m_pEnum;
        CCritSec m_cs;
    public:
        CEnumSink(CEnumeratorCommon* pEnum);
		~CEnumSink();

        STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects);
        STDMETHOD(SetStatus)(long, long, BSTR, IWbemClassObject*);

        void Detach();
    };
    friend CEnumSink;

    CEnumSink* m_pSink;

    IWbemObjectSink* m_pForwarder;
    DWORD* m_pdwForwarderPos;

public:

	enum { enumtypeFirst = 0, enumtypeClassEnum, enumtypeInstanceEnum, enumtypeQuery, enumtypeNotification,
			enumTypeLast };

    CEnumeratorCommon( long lFlags, IWbemServices* pNamespace, LPCWSTR pwszQueryType,
						LPCWSTR pwszQuery, long lEnumType, IWbemContext* pContext );

    virtual ~CEnumeratorCommon();
    void AddRef();
    void Release();

    INTERNAL CBasicObjectSink* GetSink() {return m_pSink;}
    INTERNAL IErrorInfo* GetErrorInfo() {return m_pErrorInfo;}

    HRESULT Next(DWORD& rdwPos, long lTimeout, ULONG uCount,  
        IWbemClassObject** apObj, ULONG FAR* puReturned);
    HRESULT NextAsync(DWORD& rdwPos, ULONG uCount, IWbemObjectSink* pSink);
    HRESULT Skip(DWORD& rdwPos, long lTimeout, ULONG nNum);
	HRESULT Reset( DWORD& rdwPos );
    HRESULT GetCallResult(long lTimeout, HRESULT* phres);

    HRESULT Indicate(long lNumObjects, IWbemClassObject** apObjects, long* plNumUsed );
    HRESULT SetStatus(long, long, IWbemClassObject*);

    void Cancel( HRESULT hres, BOOL fSetStatus );
	IWbemServices*	GetNameSpace( void ) { return m_pNamespace; }
	long GetFlags( void ) { return m_lFlags; }
    BOOL IsResettable()	{ return !( m_lFlags & WBEM_FLAG_FORWARD_ONLY ); }
	BOOL IsComplete( void ) { return m_bComplete; }

};


#pragma warning(disable : 4355)

class CAsyncEnumerator : public CBasicEnumWbemClassObject
{
protected:
    CEnumeratorCommon*	m_pCommon;
    DWORD				m_dwPos;
	CRITICAL_SECTION	m_cs;
    CDerivedObjectSecurity m_Security;


	// For Smart Enumerations
	CWbemGuidToClassMap*	m_pGuidToClassMap;

	class XSmartEnum : public IWbemWCOSmartEnum
	{
	private:
		CAsyncEnumerator*	m_pOuter;

	public:

		XSmartEnum( CAsyncEnumerator* pOuter ) : m_pOuter( pOuter ) {};
		~XSmartEnum(){};

		STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
		STDMETHOD_(ULONG, AddRef)(THIS);
		STDMETHOD_(ULONG, Release)(THIS);

		// IWbemWCOSmartEnum Methods
		STDMETHOD(Next)( REFGUID proxyGUID, LONG lTimeout,
			ULONG uCount, ULONG* puReturned, ULONG* pdwBuffSize,
			BYTE** pBuffer);
	} m_XSmartEnum;

	friend XSmartEnum;

public:
    CAsyncEnumerator(long lFlags, IWbemServices* pNamespace, LPCWSTR pwszQueryType,
						LPCWSTR pwszQuery, long lEnumType, IWbemContext* pContext );
    CAsyncEnumerator( const CAsyncEnumerator& async );
    ~CAsyncEnumerator();

    STDMETHOD(Reset)();
    STDMETHOD(Next)(long lTimeout, ULONG uCount,  
        IWbemClassObject** apObj, ULONG FAR* puReturned);
    STDMETHOD(NextAsync)(ULONG uCount, IWbemObjectSink* pSink);
    STDMETHOD(Clone)(IEnumWbemClassObject** pEnum);
    STDMETHOD(Skip)(long lTimeout, ULONG nNum);

    HRESULT GetCallResult(long lTimeout, HRESULT* phres);

	// IWbemFetchSmartEnum Methods
	STDMETHOD(GetSmartEnum)( IWbemWCOSmartEnum** ppSmartEnum );

    INTERNAL CBasicObjectSink* GetSink() {return m_pCommon->GetSink();}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\objenum.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    OBJENUM.CPP

Abstract:

    Implements the class implementing IEnumWbemClassObject interface.

    Classes defined:

        CEnumWbemClassObject

History:

    a-raymcc        16-Jul-96       Created.

--*/

#include "precomp.h"
#include <wbemcore.h>

// Read in by the config manager.  Controls our cache and overflow buffer sizes as
// well as timeouts
extern DWORD g_dwMaxEnumCacheSize;
extern DWORD g_dwMaxEnumOverflowSize;
extern DWORD g_dwEnumOverflowTimeout;

// Marshaling Packet definitions
#include <wbemclasstoidmap.h>
#include <wbemguidtoclassmap.h>
#include <smartnextpacket.h>

//***************************************************************************
//
//  See objenum.h for documentation.
//
//***************************************************************************

SCODE CBasicEnumWbemClassObject::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = 0;

    if (IID_IUnknown==riid || IID_IEnumWbemClassObject == riid)
    {
        *ppvObj = (IEnumWbemClassObject*)this;
        AddRef();
        return NOERROR;
    }
    else if ( IID_IWbemFetchSmartEnum == riid )
    {
        *ppvObj = (IWbemFetchSmartEnum*) this;
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

//***************************************************************************
//
//  See objenum.h for documentation.
//
//***************************************************************************

ULONG CBasicEnumWbemClassObject::AddRef()
{
    return InterlockedIncrement(&m_lRefCount);
}

//***************************************************************************
//
//  See objenum.h for documentation.
//
//***************************************************************************

ULONG CBasicEnumWbemClassObject::Release()
{
    _ASSERT(m_lRefCount > 0, "Release() called with no matching AddRef()");
    long lRef = InterlockedDecrement(&m_lRefCount);

    if (0 != lRef)
        return lRef;

    delete this;
    return 0;
}

//***************************************************************************
//***************************************************************************
//
//                             ASYNC
//
//***************************************************************************
//***************************************************************************

CDataAccessor::CDataAccessor() : m_dwTotal( 0 ), m_dwNumObjects( 0 )
{
    ConfigMgr::AddCache();
}

CDataAccessor::~CDataAccessor()
{
    ConfigMgr::RemoveCache();
}

BOOL CDataAccessor::RecordAdd(IWbemClassObject* p)
{
    DWORD dwSize = ((CWbemObject*)p)->GetBlockLength();
    m_dwTotal += dwSize;
    ++m_dwNumObjects;
    return TRUE;
}

void CDataAccessor::ReportRemove(IWbemClassObject* p)
{
    DWORD dwSize = ((CWbemObject*)p)->GetBlockLength();
    m_dwTotal -= dwSize;
    --m_dwNumObjects;
    ConfigMgr::RemoveFromCache(dwSize);
}



class CForwardAccessor : public CDataAccessor
{
protected:
    CFlexQueue m_q;
public:
    CForwardAccessor(){}
    virtual ~CForwardAccessor();

    BOOL Add(IWbemClassObject* p)
    {
        RecordAdd(p);
        if(m_q.Enqueue(p)) {p->AddRef(); return TRUE;}
        else return FALSE;
    }
    BOOL Next(DWORD& rdwPos, IWbemClassObject*& rp)
    {
        if((rp = (IWbemClassObject*)m_q.Dequeue()) != NULL)
        {
            rdwPos++;
            ReportRemove(rp);
            return TRUE;
        }
        else return FALSE;
    }
    BOOL IsResettable() {return FALSE;}

    void Clear( void );

    // Return whether or not the queue is empty
    BOOL IsDone( DWORD dwPos ) { return m_q.GetQueueSize() == 0; }
};

class CBiAccessor : public CDataAccessor
{
protected:
    CFlexArray m_a;

public:
    ~CBiAccessor();
    BOOL Add(IWbemClassObject* p)
    {
        RecordAdd(p);
        if ( m_a.Add(p) == CFlexArray::no_error )
        {
            p->AddRef();
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    BOOL Next(DWORD& rdwPos, IWbemClassObject*& rp)
    {
        if(rdwPos < m_a.Size())
        {
            rp = (IWbemClassObject*)m_a.GetAt(rdwPos++);
            rp->AddRef();
            return TRUE;
        }
        else return FALSE;
    }
    BOOL IsResettable() {return TRUE;}

    void Clear( void );

    // Return whether or not the position is at our max
    BOOL IsDone( DWORD dwPos ) { return !( dwPos < m_a.Size() ); }

};


CForwardAccessor::~CForwardAccessor()
{
    // Tell the accessor to clear itself
    Clear();
}

void CForwardAccessor::Clear( void )
{
    IWbemClassObject* p;
    while((p = (IWbemClassObject*)m_q.Dequeue()) != NULL)
    {
        ReportRemove(p);
        p->Release();
    }
}

CBiAccessor::~CBiAccessor()
{
    // Tell the accessor to clear itself
    Clear();
}

void CBiAccessor::Clear()
{
    for(int i = 0; i < m_a.Size(); i++)
    {
        IWbemClassObject* p = (IWbemClassObject*)m_a[i];
        ReportRemove(p);
        p->Release();
    }

    m_a.Empty();
}

CEnumeratorCommon::CEnumeratorCommon( long lFlags, IWbemServices* pNamespace, LPCWSTR pwszQueryType,
                        LPCWSTR pwszQuery, long lEnumType, IWbemContext* pContext )
    : m_pErrorInfo(NULL), m_dwNumDesired(0xFFFFFFFF), m_lFlags(lFlags),
        m_pErrorObj(NULL), m_hres(WBEM_S_TIMEDOUT),
        m_bComplete(FALSE), m_pNamespace(pNamespace), m_pForwarder(NULL),
        m_lRef(0),m_fGotFirstObject( FALSE ), m_csNext(), m_lEntryCount( 0 ),
        m_wstrQueryType( pwszQueryType ), m_wstrQuery( pwszQuery ),
        m_lEnumType( lEnumType ), m_pContext( pContext ), m_fCheckMinMaxControl( g_dwMaxEnumCacheSize != 0 )
{
    InitializeCriticalSection(&m_cs);

    // One event indicating that we are ready
    m_hReady = CreateEvent(NULL, TRUE, FALSE, NULL);

    if ( NULL == m_hReady )
    {
        throw CX_MemoryException();
    }

    pNamespace->AddRef();

    m_pSink = new CEnumSink(this);

    if ( NULL == m_pSink )
    {
        throw CX_MemoryException();
    }

    // Allocate the approprioate accessor

    if ( !( m_lFlags & WBEM_FLAG_FORWARD_ONLY ) )
    {
        m_pData = new CBiAccessor;
    }
    else
    {
        m_pData = new CForwardAccessor;
    }

    if ( NULL == m_pData )
    {
        throw CX_MemoryException();
    }

    if ( NULL != m_pContext )
    {
        m_pContext->AddRef();
    }
}

CEnumeratorCommon::~CEnumeratorCommon()
{
    m_lRef = 100;

    // This will detach the sink from us
    Cancel(WBEM_E_CALL_CANCELLED, TRUE);

    EnterCriticalSection(&m_cs);

    // Cleanup the event handles
    if ( NULL != m_hReady )
    {
        CloseHandle(m_hReady);
        m_hReady = NULL;
    }

    // Cleanup
    if(m_pErrorInfo)
        m_pErrorInfo->Release();
    if(m_pErrorObj)
        m_pErrorObj->Release();
    if(m_pNamespace)
        m_pNamespace->Release();
    if(m_pForwarder)
        m_pForwarder->Release();

    if ( NULL != m_pContext )
    {
        m_pContext->Release();
        m_pContext = NULL;
    }

    delete m_pData;

    LeaveCriticalSection(&m_cs);
    DeleteCriticalSection(&m_cs);

}

void CEnumeratorCommon::Cancel( HRESULT hres, BOOL fSetStatus )
{
    CEnumSink*  pEnumSink = NULL;

    // This can happen on multiple threads, so let's clear
    // m_pSink with a critical section.  After that point we can
    // actually schedule the cancel and detach the sink.

    EnterCriticalSection( &m_cs );

    // AddRef it now.  We will release it
    // outside the critical section when we
    // are done with it.

    pEnumSink = m_pSink;

    // Check that the sink is not NULL before we AddRef/Release it
    if ( NULL != m_pSink )
    {
        pEnumSink->AddRef();
        m_pSink->Release();
        m_pSink = NULL;
    }

    // Next, clear out our object
    LeaveCriticalSection( &m_cs );

    // Do this outside of a critical section.

    // Cancel the asynchrnous call
    // ===========================

    if ( NULL != pEnumSink )
    {
        if(!m_bComplete)
        {
            CAsyncReq_CancelAsyncCall *pReq = new
                CAsyncReq_CancelAsyncCall(pEnumSink, NULL);

            if ( NULL != pReq )
            {
                ConfigMgr::EnqueueRequest(pReq);
            }
        }

        // This ensures that no further objects will be indicated through this sink
        // By detaching outside of m_cs, we guarantee that we will not deadlock, since
        // detach enters another critical section inside of which it again reenters
        // m_cs (whew!)

        pEnumSink->Detach();

        // Gone daddy gone
        pEnumSink->Release();
    }

    // Finally, since the call has been cancelled, let's clean up
    // any latent objects (of course, this has to be done in a
    // critical section)
    EnterCriticalSection( &m_cs );

    // We must clear both the data and the object cache
    m_pData->Clear();

    LeaveCriticalSection( &m_cs );

    if ( fSetStatus )
    {
        SetStatus(WBEM_STATUS_COMPLETE, hres, NULL);
    }
}


void CEnumeratorCommon::AddRef()
{
    InterlockedIncrement(&m_lRef);
}
void CEnumeratorCommon::Release()
{
    if(InterlockedDecrement(&m_lRef) == 0)
        delete this;
}

HRESULT CEnumeratorCommon::NextAsync(DWORD& rdwPos, ULONG uCount,
                                                IWbemObjectSink* pSink)
{

    if(pSink == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // This function MUST block around the actual Next Critical Section.
    // Therefore if any nexts are occurring, we should at least have the
    // good taste to give them a chance to finish what they are doing.

    // On Next operations, we MUST enter this critical section BEFORE m_cs, because
    // we want to block other Next operations, but not operations that will cause
    // a Next operation to complete.  For example, the Indicate operation MUST be
    // allowed to place objects into our arrays, or pass them down to the forwarding
    // sink, or we will definitely deadlock.

    // Below, you will see that if we get all of the requested data out, we will
    // leave the critical section.  If not, then the operation actually hasn't
    // completed and we will want the m_csNext critical section to remain blocked.
    // When the operation completes (either when an object completing the requested
    // block is indicated, or the SetStatus() function is called), the critical
    // section will actually be released.

    m_csNext.Enter();

    EnterCriticalSection(&m_cs);

    // Controls how many objects we will let pile up in the enumerator
    m_dwNumDesired = uCount;

    ULONG uReturned = 0;

    while (uReturned < uCount)
    {
        IWbemClassObject *pSrc;
        if(m_pData->Next(rdwPos, pSrc))
        {
            /*
            pSrc->Clone(pUsrArray + nUsrIx++);
            */
            pSink->Indicate(1, &pSrc);
            pSrc->Release();
            uReturned++;
            m_dwNumDesired--;
        }
        else break;
    }

    if(uReturned < uCount && !m_bComplete)
    {
        CBasicObjectSink* pWrapper = NULL;
        CCountedSink* pCountedSink = NULL;

        try
        {
            pWrapper = new CWrapperSink(pSink);

            if ( NULL == pWrapper )
            {
                throw CX_MemoryException();
            }

            pWrapper->AddRef();
            pCountedSink =
                new CCountedSink(pWrapper, uCount-uReturned);

            if ( NULL == pCountedSink )
            {
                throw CX_MemoryException();
            }

            pWrapper->Release();
            m_pForwarder = pCountedSink;
            m_pdwForwarderPos = &rdwPos;
            pCountedSink->AddRef();

            LeaveCriticalSection(&m_cs);

            // We are intentionally staying in m_csNext.  Another thread will be responsible for
            // unlocking the critical section.  This is a cross we have to bear because we support
            // NextAsync

            return WBEM_S_NO_ERROR;
        }
        catch(...)
        {

            // Cleanup
            if ( NULL != pWrapper )
            {
                pWrapper->Release();
            }

            if ( NULL != pCountedSink )
            {
                pCountedSink->Release();
            }

            // The Next Operation is complete so we should release the critical section
            m_csNext.Leave();

            LeaveCriticalSection(&m_cs);


            return WBEM_E_OUT_OF_MEMORY;
        }


    }
    else
    {
        HRESULT hReturn = WBEM_S_NO_ERROR;

        pSink->SetStatus(0, ( WBEM_S_TIMEDOUT == m_hres ? WBEM_S_NO_ERROR : m_hres ), NULL, m_pErrorObj);

        // If the complete flag is set, check if the data accessor is really done.  If so, then
        // return WBEM_S_FALSE.  In all other cases return WBEM_S_NO_ERROR.

        if ( m_bComplete )
        {
            if ( m_pData->IsDone( rdwPos ) )
            {
                hReturn = WBEM_S_FALSE;
            }
        }

        // The Next Operation is complete so we should release the critical section
        m_csNext.Leave();

        LeaveCriticalSection(&m_cs);

        return hReturn;

    }
}

HRESULT CEnumeratorCommon::Skip(DWORD& rdwPos, long lTimeout, ULONG nNum)
{

    // We just turn this around into a Next command, except we tell Next to
    // skip the objects (on each next it just releases them)
    return Next(rdwPos, lTimeout, nNum, NULL, NULL);
}

HRESULT CEnumeratorCommon::Next(
    DWORD& rdwPos,
    long lTimeout,
    ULONG uCount,
    IWbemClassObject **pUsrArray,
    ULONG* puReturned
    )
{

    // This function MUST block around the actual Next Critical Section.
    // Therefore if any nexts are occurring, we should at least have the
    // good taste to give them a chance to finish what they are doing.

    // On Next operations, we MUST enter this critical section BEFORE m_cs, because
    // we want to block other Next operations, but not operations that will cause
    // a Next operation to complete.  For example, the Indicate operation MUST be
    // allowed to place objects into our arrays, or pass them down to the forwarding
    // sink, or we will definitely deadlock.

    m_csNext.Enter();

    EnterCriticalSection(&m_cs);

    // Controls how many objects we will let pile up in the enumerator
    m_dwNumDesired = uCount;

    ULONG uReturned = 0;
    HRESULT hres = S_OK;
    DWORD dwStart = GetTickCount();

    // Start grabbing elements and cloning them to the user's array.
    // =============================================================

    int nUsrIx = 0;
    while (uReturned < uCount)
    {
        IWbemClassObject *pSrc;
        if(m_pData->Next(rdwPos, pSrc))
        {
            // Skip the object or store it in
            // the user's array
            if ( NULL == pUsrArray )
            {
                pSrc->Release();
            }
            else
            {
                pUsrArray[nUsrIx++] = pSrc;
            }

            // Increment this so we know how many objects
            // we've processed (skipping or not).
            uReturned++;

        }
        else
        {
            // Check if we've reached the end
            // ==============================

            if(m_bComplete)
            {
                // The end
                // =======

                SetErrorInfo(0, m_pErrorInfo);
                hres = m_hres;
                if (hres == WBEM_S_NO_ERROR)
                {
                    hres = WBEM_S_FALSE;
                }
                else if ( FAILED( hres ) )
                {
                    // If the array is not NULL we need to make sure we release any
                    // objects we set and clear the array.
                    if ( NULL != pUsrArray )
                    {

                        for ( DWORD dwCtr = 0; dwCtr < uReturned; dwCtr++ )
                        {
                            if ( NULL != pUsrArray[dwCtr] )
                            {
                                pUsrArray[dwCtr]->Release();
                                pUsrArray[dwCtr] = NULL;
                            }
                        }

                    }

                    // The number returned is actually 0
                    uReturned = 0;

                }

                break;
            }

            // Check if we've still got time
            // =============================

            DWORD dwTimeSpent = GetTickCount() - dwStart;
            if((DWORD)lTimeout < dwTimeSpent)
            {
                // Out of time
                // ===========

                hres = WBEM_S_TIMEDOUT;
                break;
            }

            // Calculate how many more we need
            // ===============================

            m_dwNumDesired = uCount - uReturned;
            ResetEvent(m_hReady);

            // Wait for them to arrive
            // =======================

            // By doing this, we will force other Next operations to block (we still own
            // that critical section), but we allow objects to be indicated in, and SetStatus
            // to be called so m_hReady can actually become signalled.  Once it is signalled,
            // we DO want to pull objects out, so we will turn right around and grab hold
            // of m_cs.

            // Boy, that was obvious, huh?

            LeaveCriticalSection(&m_cs);
            DWORD dwRes = CCoreQueue::QueueWaitForSingleObject(m_hReady,
                                              (DWORD)lTimeout - dwTimeSpent);
            EnterCriticalSection(&m_cs);
        }
    }

    // We ALWAYS release m_csNext on the way out of this function.
    m_csNext.Leave();

    LeaveCriticalSection(&m_cs);

    // Set info for the caller.
    // ========================

    if (puReturned)
        *puReturned = uReturned;

    return hres;
}


HRESULT CEnumeratorCommon::Indicate(long lNumObjects,
                                    IWbemClassObject** apObjects,
                                    long* plNumUsed )
{
    HRESULT hres = S_OK;

    // Check whether or not we're OOM.  If we are, dump the whole connection
    if ( !m_fCheckMinMaxControl )
    {
        if ( !CWin32DefaultArena::ValidateMemSize() )
        {
            // we are out of memory
            // ====================

            Cancel(WBEM_E_OUT_OF_MEMORY, TRUE);
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    // We MUST be in this critical section  to change the data.
    // We do NOT want m_csNext, since that will be owned by another
    // thread (although see below where we release it)...
    EnterCriticalSection(&m_cs);

    // We haven't used any objects yet.
    *plNumUsed = lNumObjects;

    // If this is the first object, then set the ready event (sort of like doing a semi-synch under everyone's
    // noses).
//  if ( lNumObjects > 0 && !m_fGotFirstObject )
//  {
//      m_fGotFirstObject = TRUE;
//      m_hres = WBEM_S_NO_ERROR;   // We're ready to go
//      SetEvent( m_hReady );
//  }

    DWORD   dwThisSize = 0;

    // This time actually add the objects to the appropriate arrays
    for(long l = 0; SUCCEEDED(hres) && l < *plNumUsed; l++)
    {
        if ( !m_pData->Add(apObjects[l]) )
        {
            hres = WBEM_E_OUT_OF_MEMORY;
        }
        else
        {
            dwThisSize += ((CWbemObject*)apObjects[l])->GetBlockLength();
        }
    }

    // Check for failures, if so, leave m_cs and dump the enumerator
    if ( FAILED(hres) )
    {
        LeaveCriticalSection( &m_cs );
        Cancel( hres, TRUE );
        return hres;
    }

    // Inform memory control of this addition
    // ======================================

    DWORD dwTotalSize = m_pData->GetTotalSize();

    DWORD dwSleep = 0;

    if ( m_fCheckMinMaxControl )
    {
        hres = ConfigMgr::AddToCache(dwThisSize, dwTotalSize, &dwSleep);
    }

    // If we have a forwarder, pass-through any objects we can get away with
    // We get this from calling NextAsync().

    if ( NULL != m_pForwarder )
    {

        bool    fCheckMemory = m_fCheckMinMaxControl;

        for ( l = 0; NULL != m_pForwarder && l < *plNumUsed; l++ )
        {
            IWbemClassObject* p;

            // We know that we just added the objects to the accessor
            // so no need to check return codes here.
            m_pData->Next(*m_pdwForwarderPos, p);

            if(m_pForwarder->Indicate(1, &p) == WBEM_S_FALSE)
            {
                m_pForwarder->Release();
                m_pForwarder = NULL;

                // Since we completed the request here, no sense in checking for
                // OOM conditions.

                fCheckMemory = false;

                // By releasing m_csNext here, we are effectively telling the code
                // that a NextAsync call has completed.  Remember, NextAsync() will
                // Enter m_csNext, but if not all objects are available, leave the
                // critical section hanging.

                m_csNext.Leave();

            }

            p->Release();

        }   // Pass through all of the available objects

        // At this point, if we had an error from before, try going into the cache
        // again, since the calls to ::Next may have released out some of the objects

        if ( fCheckMemory && hres != S_OK )
        {
            dwTotalSize = m_pData->GetTotalSize();
            dwSleep = 0;

            // See how the memory's doing now.  By specifying 0, we won't cause
            // the size to grow.
            hres = ConfigMgr::AddToCache( 0, dwTotalSize, &dwSleep );
        }

    }   // IF we have a forwarder

    // Don't update anything if we're going to dump the enumerator
    // Check if we have satisfied the reader's requirement
    if(lNumObjects >= m_dwNumDesired)
    {
        SetEvent(m_hReady);
        m_dwNumDesired = 0;
    }
    else
    {
        m_dwNumDesired -= lNumObjects;
    }

    LeaveCriticalSection(&m_cs);

    // Finally, if we were checking the min/max control and we got a failure, we need to
    // cancel the transaction

    if ( m_fCheckMinMaxControl )
    {
        // No sense in sleeping
        // ====================

        if((m_lFlags & WBEM_FLAG_RETURN_IMMEDIATELY) == 0)
        {
            if(hres != S_OK)
            {
                // we are out of memory
                // ====================

                Cancel(WBEM_E_OUT_OF_MEMORY, TRUE);
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
        else
        {
            if(dwSleep)
               Sleep(dwSleep);
        }

    }

    return hres;
}

HRESULT CEnumeratorCommon::SetStatus(long lFlags, HRESULT hresParam,
                                    IWbemClassObject* pStatusObj)
{

    if(lFlags != WBEM_STATUS_COMPLETE)
        return WBEM_S_NO_ERROR;

    EnterCriticalSection(&m_cs);

    if(pStatusObj)
    {
        pStatusObj->QueryInterface(IID_IErrorInfo,
                                   (void**)&m_pErrorInfo);
    }

    m_hres = hresParam;

    m_bComplete = TRUE;

    if(m_pForwarder)
    {
        m_pForwarder->SetStatus(lFlags, hresParam, NULL, pStatusObj);
        m_pForwarder->Release();
        m_pForwarder = NULL;

        // By releasing m_csNext here, we are effectively telling the code
        // that a NextAsync call has completed.  Remember, NextAsync() will
        // Enter m_csNext, but if not all objects are available, leave the
        // critical section hanging.

        m_csNext.Leave();

    }

    // Signal the event last
    SetEvent(m_hReady);

    LeaveCriticalSection(&m_cs);

    return WBEM_S_NO_ERROR;
}

HRESULT CEnumeratorCommon::GetCallResult(long lTimeout, HRESULT* phres)
{

    if(lTimeout < 0 && lTimeout != -1)
        return WBEM_E_INVALID_PARAMETER;

    // ALWAYS enter m_csNext first, since we will release m_cs before we release
    // m_csNext.  This will block anyone else from getting access to m_csNext until
    // m_hReady is signalled
    m_csNext.Enter();

    EnterCriticalSection(&m_cs);

    if(m_bComplete)
    {
        *phres = m_hres;
        LeaveCriticalSection(&m_cs);

        // If we're in here, we completed BEFORE this function got hold of
        // m_cs (cool, huh?)
        m_csNext.Leave();

        return WBEM_S_NO_ERROR;
    }

    // Since we didn't complete, we should wait on m_hReady to
    // become signalled, which will happen when the first object
    // arrives.

    LeaveCriticalSection(&m_cs);

    DWORD dwRes = CCoreQueue::QueueWaitForSingleObject(m_hReady, lTimeout);

    // Well, at least we can ascertain that something happened.  Now we can
    // release our lock on m_csNext.
    m_csNext.Leave();

    if(dwRes != WAIT_OBJECT_0)
    {
        return WBEM_S_TIMEDOUT;
    }
    *phres = m_hres;
    SetErrorInfo(0, m_pErrorInfo);
    return WBEM_S_NO_ERROR;
}

HRESULT CEnumeratorCommon::Reset( DWORD& rdwPos )
{

    // If they said forwards-only, well that's just tough...
    if(!IsResettable())
    {
        return WBEM_E_INVALID_OPERATION;
    }

    // Something's is really messed up!
    if ( m_lEnumType <= enumtypeFirst || m_lEnumType >= enumTypeLast )
    {
        return WBEM_E_FAILED;
    }

    HRESULT hr = WBEM_S_NO_ERROR;

    // We need access to m_csNext before we can properly reset the enumeration.  This
    // way we won't stomp all over any executing Next or Skip operations.  We also want to
    // ensure that no Next operations step in while we are resubmitting the request
    CEnterWbemCriticalSection   entercsNext( &m_csNext );

    // This shouldn't fail, since we're basically infinite
    if ( entercsNext.IsEntered() )
    {

        // First, check if we've actually got the full set of objects in the cache.  If we do,
        // empty the data accessor and reload it with the objects in the cache.

        EnterCriticalSection( &m_cs );

        // Reset the enumerator position reference
        rdwPos = 0;

        LeaveCriticalSection( &m_cs );

    }   // IF we got into m_csNext
    else
    {
        hr = WBEM_S_TIMEDOUT;
    }

    return hr;
}

CEnumeratorCommon::CEnumSink::CEnumSink(CEnumeratorCommon* pEnum)
    : CObjectSink(1), m_pEnum(pEnum)
{
}


CEnumeratorCommon::CEnumSink::~CEnumSink()
{
}

void CEnumeratorCommon::CEnumSink::Detach()
{
    CInCritSec ics(&m_cs);
    m_pEnum = NULL;
}

HRESULT CEnumeratorCommon::CEnumSink::
Indicate(long lNumObjects, IWbemClassObject** apObjects)
{

    CInCritSec ics(&m_cs);

    long lNumUsed = 0;

    if ( NULL == m_pEnum )
    {
        return WBEM_S_NO_ERROR;
    }
    else
    {
        return m_pEnum->Indicate( lNumObjects, apObjects, &lNumUsed );
    }

}

STDMETHODIMP CEnumeratorCommon::CEnumSink::
SetStatus(long lFlags, HRESULT hresParam, BSTR, IWbemClassObject* pStatusObj)
{
    CInCritSec ics(&m_cs);
    if(m_pEnum == NULL) return WBEM_S_NO_ERROR;

    HRESULT hres = m_pEnum->SetStatus(lFlags, hresParam, pStatusObj);
    return hres;
}



CAsyncEnumerator::CAsyncEnumerator(long lFlags, IWbemServices* pNamespace, LPCWSTR pwszQueryType,
                        LPCWSTR pwszQuery, long lEnumType, IWbemContext* pContext )
:   m_XSmartEnum( this )
{
    // Explicit cast to get to IUnknown, since compiler can't get us there.
    gClientCounter.AddClientPtr( (IEnumWbemClassObject*) this, ENUMERATOR);
    m_pCommon = new CEnumeratorCommon( lFlags, pNamespace, pwszQueryType, pwszQuery,
                                        lEnumType, pContext );
    m_pCommon->AddRef();
    m_dwPos = 0;
    m_pGuidToClassMap = NULL;

    InitializeCriticalSection( &m_cs );
}

CAsyncEnumerator::CAsyncEnumerator( const CAsyncEnumerator& async )
:   m_XSmartEnum( this )
{
    // Explicit cast to get to IUnknown, since compiler can't get us there.
    gClientCounter.AddClientPtr( (IEnumWbemClassObject*) this, ENUMERATOR);

    m_pCommon = async.m_pCommon;
    m_pCommon->AddRef();

    // Preserve the last position
    m_dwPos = async.m_dwPos;
    m_pGuidToClassMap = NULL;

    InitializeCriticalSection( &m_cs );
}

CAsyncEnumerator::~CAsyncEnumerator()
{
    // Explicit cast to get to IUnknown, since compiler can't get us there.
    gClientCounter.RemoveClientPtr((IEnumWbemClassObject*) this);
    m_pCommon->Release();

    // Cleanup the map
    if ( NULL != m_pGuidToClassMap )
    {
        delete m_pGuidToClassMap;
    }

    DeleteCriticalSection( &m_cs );
}

STDMETHODIMP CAsyncEnumerator::Reset()
{
    if(!m_Security.AccessCheck())
        return WBEM_E_ACCESS_DENIED;

    // Handoff to the common enumerator
    return m_pCommon->Reset( m_dwPos );
}

STDMETHODIMP CAsyncEnumerator::Next(long lTimeout, ULONG uCount,
                IWbemClassObject** apObj, ULONG* puReturned)
{
    *puReturned = 0;
    if(!m_Security.AccessCheck())
        return WBEM_E_ACCESS_DENIED;

    if(lTimeout < 0 && lTimeout != -1)
        return WBEM_E_INVALID_PARAMETER;

    return m_pCommon->Next(m_dwPos, lTimeout, uCount, apObj, puReturned);
}

STDMETHODIMP CAsyncEnumerator::NextAsync(ULONG uCount, IWbemObjectSink* pSink)
{
    if(!m_Security.AccessCheck())
        return WBEM_E_ACCESS_DENIED;

    return m_pCommon->NextAsync(m_dwPos, uCount, pSink);
}

STDMETHODIMP CAsyncEnumerator::Clone(IEnumWbemClassObject** ppEnum)
{
    *ppEnum = NULL;
    if(!m_Security.AccessCheck())
        return WBEM_E_ACCESS_DENIED;

    if(m_pCommon->IsResettable())
    {
        CAsyncEnumerator*   pEnum = new CAsyncEnumerator( *this );

        if ( NULL != pEnum )
        {
            // We're good to go
            *ppEnum = pEnum;
            return WBEM_S_NO_ERROR;
        }

        return WBEM_E_OUT_OF_MEMORY;
    }
    else
    {
        *ppEnum = NULL;
        return WBEM_E_INVALID_OPERATION;
    }
}

STDMETHODIMP CAsyncEnumerator::Skip(long lTimeout, ULONG nNum)
{
    if(!m_Security.AccessCheck())
        return WBEM_E_ACCESS_DENIED;

    if(lTimeout < 0 && lTimeout != -1)
        return WBEM_E_INVALID_PARAMETER;

    return m_pCommon->Skip(m_dwPos, lTimeout, nNum);
}

HRESULT CAsyncEnumerator::GetCallResult(long lTimeout, HRESULT* phres)
{
    if(lTimeout < 0 && lTimeout != -1)
        return WBEM_E_INVALID_PARAMETER;

    return m_pCommon->GetCallResult(lTimeout, phres);
}

// IWbemFetchSmartEnum Methods
STDMETHODIMP CAsyncEnumerator::GetSmartEnum( IWbemWCOSmartEnum** ppSmartEnum )
{
    *ppSmartEnum = NULL;
    if(!m_Security.AccessCheck())
        return WBEM_E_ACCESS_DENIED;

    return m_XSmartEnum.QueryInterface( IID_IWbemWCOSmartEnum, (void**) ppSmartEnum );
};

SCODE CAsyncEnumerator::XSmartEnum::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = 0;

    if ( IID_IUnknown==riid || IID_IWbemWCOSmartEnum == riid)
    {
        *ppvObj = (IWbemWCOSmartEnum*)this;
        AddRef();
        return NOERROR;
    }
    else
    {
        return m_pOuter->QueryInterface( riid, ppvObj );
    }
}

ULONG CAsyncEnumerator::XSmartEnum::AddRef( void )
{
    return m_pOuter->AddRef();
}

ULONG CAsyncEnumerator::XSmartEnum::Release( void )
{
    return m_pOuter->Release();
}

// IWbemWCOSmartEnum Methods!

STDMETHODIMP CAsyncEnumerator::XSmartEnum::
Next( REFGUID proxyGUID, long lTimeout, ULONG uCount,
                ULONG* puReturned, ULONG* pdwBuffSize, BYTE** pBuffer)
{
    *puReturned = 0;
    *pdwBuffSize = 0;
    *pBuffer = NULL;

    if(!m_pOuter->m_Security.AccessCheck())
        return WBEM_E_ACCESS_DENIED;

    // Use a critical section to guard this operation.
    CInCritSec(&m_pOuter->m_cs);

    // Todo: The proxyGUID needs to be mapped to a per PROXY WbemClassToIdMap
    // object so we ensure that data is lobotomized properly.

    // Allocate a map if we need one
    // Allocate a map if we need one
    if ( NULL == m_pOuter->m_pGuidToClassMap )
    {
        m_pOuter->m_pGuidToClassMap = new CWbemGuidToClassMap;
    }

    // Look for the GUID in the cache.  If we don't find it, it's new so add it
    CWbemClassToIdMap*      pClassToId = NULL;
    CGUID                   guid( proxyGUID );

    HRESULT hr = m_pOuter->m_pGuidToClassMap->GetMap( guid, &pClassToId );

    if ( FAILED( hr ) )
    {
        hr = m_pOuter->m_pGuidToClassMap->AddMap( guid, &pClassToId );
    }

    // Only continue if we have a cache to work with
    if ( SUCCEEDED( hr ) )
    {

        // Allocate a transient array to copy objects into
        IWbemClassObject**  apObj = new IWbemClassObject*[uCount];

        if ( NULL != apObj )
        {
            // Clear the object array
            ZeroMemory( apObj, uCount * sizeof(IWbemClassObject*) );

            // Pass through to the regular next function
            hr = m_pOuter->Next( lTimeout, uCount, apObj, puReturned );

            if ( SUCCEEDED( hr ) )
            {
                // Only marshal data if we need to
                if ( *puReturned > 0 )
                {
                    // hr contains the actual proper return code, so let's not overwrite
                    // that valu unless something goes wrong during marshaling.

                    HRESULT hrMarshal = WBEM_S_NO_ERROR;

                    // Caluclate data length first
                    DWORD dwLength;
                    GUID* pguidClassIds = new GUID[*puReturned];
                    BOOL* pfSendFullObject = new BOOL[*puReturned];
                    CWbemSmartEnumNextPacket packet;
                    if(pguidClassIds && pfSendFullObject)
                    {
                        hrMarshal = packet.CalculateLength(*puReturned, apObj, &dwLength,
                            *pClassToId, pguidClassIds, pfSendFullObject );
                    }
                    else
                    {
                        hrMarshal = WBEM_E_OUT_OF_MEMORY;
                    }

                    if ( SUCCEEDED( hrMarshal ) )
                    {

                        // As we could be going cross process/machine, use the
                        // COM memory allocator
                        LPBYTE pbData = (LPBYTE) CoTaskMemAlloc( dwLength );

                        if ( NULL != pbData )
                        {
                            // hr contains the actual proper return code, so let's not overwrite
                            // that valu unless something goes wrong during marshaling.

                            // Write the objects out to the buffer
                            HRESULT hrMarshal = packet.MarshalPacket( pbData, dwLength, *puReturned, apObj,
                                                                     pguidClassIds, pfSendFullObject);

                            // Copy the values, we're golden.
                            if ( SUCCEEDED( hr ) )
                            {
                                *pdwBuffSize = dwLength;
                                *pBuffer = pbData;
                            }
                            else
                            {
                                // Store the new error code
                                hr = hrMarshal;

                                // Clean up the memory --- something went wrong
                                CoTaskMemFree( pbData );
                            }
                        }
                        else
                        {
                            hr = WBEM_E_OUT_OF_MEMORY;
                        }

                    }   // IF CalculateLength()
                    else
                    {
                        // Set the error code
                        hr = hrMarshal;
                    }

                    // Clean up the guid and flag arrays
                    if ( NULL != pguidClassIds )
                    {
                        delete [] pguidClassIds;
                    }

                    if ( NULL != pfSendFullObject )
                    {
                        delete [] pfSendFullObject;
                    }

                }   // IF *puReturned > 0
                else
                {
                    // NULL these out
                    *pdwBuffSize = 0;
                    *pBuffer = NULL;
                }

            }   // IF SUCCEEDED IEnumWbemClassObject::Next

            // We need to Release all the objects in the array, since we have
            // inherited ownership from the old Next.
            // ==============================================================

            for(int i = 0; i < *puReturned; i++)
                apObj[i]->Release();

            delete [] apObj;

        }   // IF NULL != apObj
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }

    }   // IF Cache obtained

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\mergerthrottling.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MERGERTHROTTLING.H

Abstract:

    CMergerThrottling clas

History:

	30-Nov-00   sanjes    Created.

--*/

#ifndef _MERGERTHROTTLING_H_
#define _MERGERTHROTTLING_H_

// Enables debug messages for additional info.
#ifdef DBG
//#define __DEBUG_MERGER_THROTTLING
#endif

// Defaults - can be overridden from the registry
#define	DEFAULT_THROTTLE_THRESHOLD			10
#define	DEFAULT_THROTTLE_RELEASE_THRESHOLD	4

// Forward Class Definitions
class CInternalMerger;
class CWmiMergerRecord;

//	This class encapsulates the throttling behavior which will be used by the internal
//	merger in order to control delivery of parent and child objects.

class CMergerThrottling
{
	// Following members are used for throttling incoming objects so that our
	// parent and child objects don't get wildly out of control.  Note that we
	// use separate throttling events, since the decision to throttle is made in
	// a critsec, but the actual throttling occurs outside.  This can have the
	// unpleasant side effect of a race condition in which for example, the parent
	// decides to throttle, steps out of the critsec, and a context switch occurs,
	// in which the child gets a large number of objects, releases the throttle, but
	// then causes child throttling to occur, resetting the event.  If the parent
	// thread switches in at this point, we're hosed, since we will now wait on the
	// parent and the child.

	HANDLE	m_hParentThrottlingEvent;
	HANDLE	m_hChildThrottlingEvent;

	DWORD	m_dwNumChildObjects;
	DWORD	m_dwNumParentObjects;
	DWORD	m_dwNumThrottledThreads;

	// Contains the time of the last ping from a parent or child.
	// Used to calculate whether or not we timeout
	DWORD	m_dwLastParentPing;
	DWORD	m_dwLastChildPing;

	// These should NEVER both be TRUE
	bool	m_bParentThrottled;
	bool	m_bChildThrottled;

	// Stop us from throttling if one side or the other is done
	bool	m_bParentDone;
	bool	m_bChildDone;

	// This controls the point where we determine that we need to perform throttling
	// Once parent or children are > m_dwThrottlingThreshold objects apart, one or the
	// other will be throttled
	DWORD	m_dwThrottlingThreshold;

	// This controls the threshold where we will release currently throttled threads
	// Once we are throttled, we will remain throttled until parent or children are <
	// m_dwReleaseThreshold objects out of sync with each other.
	DWORD	m_dwReleaseThreshold;

	// This controls the amount of memory we will allow Indicates to process before
	// forcing them to send objects further down the line
	DWORD	m_dwBatchingThreshold;

	// This controls the timeout value we wait for.  If we timeout and a provider has
	// not pinged us in the specified timeout, then we will cancel the merger with
	// a provider timed out error.
	DWORD m_dwProviderDeliveryTimeout;

	// We will expose this for other synchronization activities
	CCritSec	m_cs;

	// Helper functions to control throttling
	bool ShouldThrottle( bool bParent );
	HRESULT PrepareThrottle( bool bParent, HANDLE* phEvent );
	bool VerifyTimeout( DWORD dwLastTick, long lNumArbThrottledThreads, DWORD* pdwAdjust );

public:

	CMergerThrottling();
	~CMergerThrottling();

	// Two stage initialization
	HRESULT	Initialize( void );

	// Returns TRUE if throttling occurred
	HRESULT Throttle( bool bParent, CWmiMergerRecord* pMergerRecord );

	// Returns TRUE if we released throttled threads.
	bool ReleaseThrottle( bool bForce = false );

	// Informs us that we are in fact, done with Child and/or Parent
	void SetChildrenDone( void );
	void SetParentDone( void );
	void Cancel( void );

	// Helpers to control the number of current parent and child objects
	// which we will then use to make decisions as to whether or not
	// we should block a thread or not
	DWORD AdjustNumParentObjects( long lNumParentObjects )
		{ return ( m_dwNumParentObjects += lNumParentObjects ); }
	DWORD AdjustNumChildObjects( long lNumChildObjects )
		{ return ( m_dwNumChildObjects += lNumChildObjects ); }

	// Access to our critical section
	void Enter( void ) { m_cs.Enter(); }
	void Leave( void ) { m_cs.Leave(); }

	// Adjusts ping times
	DWORD Ping( bool bParent, CWmiMerger* pWmiMerger );

	CCritSec* GetCritSec( void ) { return &m_cs; }

	// Checks batch size against our limit
	bool IsCompleteBatch( long lBatchSize ) { return lBatchSize >= m_dwBatchingThreshold; }


};

#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\oldsec.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    OLDSEC.CPP

Abstract:

    contains various routines and classes used providing backward security support.

History:

    a-davj    02-sept-99  Created.

--*/

#include "precomp.h"
#include <wbemcore.h>
#include <oleauto.h>
#include <genutils.h>
#include <safearry.h>
#include <oahelp.inl>
#include "secure.h"
#include <flexarry.h>
#include <secure.h>
#include <objpath.h>
#include "oldsec.h"

//***************************************************************************
//
//  CreateTheInstance
//
//  Takes a class object, and a CCombined entry and creates an instance.
//
//  PARAMETERS:
///
//  ppObj           used to pass back the created instance
//  pClass          Class object used for spawning
//  pCombinedEntry  Has the combined values for all the aces which mach
//                  the user or group.
//  RETURN VALUES:
//
//  S_OK if all is well, else an error code
//
//***************************************************************************

HRESULT CreateTheInstance(IWbemClassObject ** ppObj, IWbemClassObject * pClass,
                                             CCombinedAce * pCombinedEntry)
{

    if(ppObj == NULL || pCombinedEntry == NULL || pClass == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // spawn the instance

    SCODE sc = pClass->SpawnInstance(0, ppObj);
    if(FAILED(sc))
        return sc;
    CReleaseMe rm(*ppObj);       // we addref at end if all is well

    // populate the instance

    bool bEnabled=false, bEditSecurity=false, bExecMethods=false;

    DWORD dwMask = pCombinedEntry->m_dwDeny;
    if(dwMask == 0)
        dwMask = pCombinedEntry->m_dwAllow;

    if( (dwMask & WBEM_ENABLE) &&
        (dwMask & WBEM_REMOTE_ACCESS) &&
        (dwMask & WBEM_WRITE_PROVIDER) &&
        pCombinedEntry->m_dwAllow)
            bEnabled = true;

    if(dwMask & READ_CONTROL)
        bEditSecurity = true;

    if(dwMask & WBEM_METHOD_EXECUTE)
       bExecMethods = true;

    DWORD dwPermission = 0;     // start at read

    if(dwMask & WBEM_PARTIAL_WRITE_REP)
        dwPermission = 1;

    if(dwMask & WBEM_FULL_WRITE_REP)
        dwPermission = 2;

    VARIANT var;
    var.vt = VT_I4;

    var.lVal = dwPermission;
    sc = (*ppObj)->Put(L"Permissions", 0, &var, 0);

    var.vt = VT_BOOL;

    var.boolVal = (bEnabled) ? VARIANT_TRUE : VARIANT_FALSE;
    sc = (*ppObj)->Put(L"Enabled", 0, &var, 0);

    var.boolVal = (bEditSecurity) ? VARIANT_TRUE : VARIANT_FALSE;
    sc = (*ppObj)->Put(L"EditSecurity", 0, &var, 0);

    var.boolVal = (bExecMethods) ? VARIANT_TRUE : VARIANT_FALSE;
    sc = (*ppObj)->Put(L"ExecuteMethods", 0, &var, 0);

    // Get the account and domain info

    LPWSTR pwszAccount = NULL;
    LPWSTR pwszDomain = NULL;

    sc = pCombinedEntry->GetNames(pwszAccount, pwszDomain);
    if(FAILED(sc))
        return sc;

    CDeleteMe<WCHAR> dm1(pwszAccount);
    CDeleteMe<WCHAR> dm2(pwszDomain);

    var.vt = VT_BSTR;
    if(pwszAccount && wcslen(pwszAccount) > 0)
    {
        BSTR bstr = SysAllocString(pwszAccount);
        if(bstr == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        var.bstrVal = bstr;
        sc = (*ppObj)->Put(L"Name", 0, &var, 0);
        SysFreeString(bstr);
    }
    if(pwszDomain)
    {
        BSTR bstr = SysAllocString(pwszDomain);
        if(bstr == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        var.bstrVal = bstr;
        sc = (*ppObj)->Put(L"Authority", 0, &var, 0);
        SysFreeString(bstr);
    }
    (*ppObj)->AddRef();     // make up for the releaseme
    return S_OK;
}

//***************************************************************************
//
//  GetAceStylePath
//
//  Takes a parsed object path and converts it into "authority|name"
//  format.
//
//  PARAMETERS:
//
//  pOutput         parsed path object
//  pToBeDeleted    Set to newly allocated string.  Call must free if
//                  this routine return S_OK
//
//  RETURN VALUES:
//
//  S_OK if all is well, else an error code
//
//***************************************************************************

HRESULT GetAceStylePath(ParsedObjectPath* pOutput, LPWSTR *pToBeDeleted)
{
    LPWSTR pRet;
    int iLen;
    int iAuthLen = 0;
    int iNameLen = 0;
    KeyRef* pAuth;
    KeyRef* pName;

    if(pOutput == NULL || pToBeDeleted == NULL)
        return WBEM_E_INVALID_PARAMETER;

    if(wbem_wcsicmp(pOutput->m_pClass, L"__ntlmuser") &&
       wbem_wcsicmp(pOutput->m_pClass, L"__ntlmgroup"))
        return WBEM_E_INVALID_OBJECT_PATH;

    if(pOutput->m_bSingletonObj || pOutput->m_dwNumKeys < 1 ||
                                   pOutput->m_dwNumKeys > 2)
        return WBEM_E_INVALID_OBJECT_PATH;

    // The authority key is optional

    if(pOutput->m_dwNumKeys == 1)
    {
        pAuth = NULL;
        pName = pOutput->m_paKeys[0];

    }
    else
    {

        // Determine which order the keys are in

        pAuth = pOutput->m_paKeys[0];
        pName = pOutput->m_paKeys[1];
        if(wbem_wcsicmp(pAuth->m_pName, L"Authority"))
        {
            pAuth = pOutput->m_paKeys[1];
            pName = pOutput->m_paKeys[0];
        }
    }
    // do some more checking

    if((pAuth && wbem_wcsicmp(pAuth->m_pName, L"Authority")) ||
       wbem_wcsicmp(pName->m_pName, L"Name"))
        return WBEM_E_INVALID_OBJECT_PATH;

    if(pAuth && pAuth->m_vValue.vt == VT_BSTR && pAuth->m_vValue.bstrVal != 0)
        iAuthLen = wcslen(pAuth->m_vValue.bstrVal);
    else
        iAuthLen = 1;               // assume a "."
    if(pName->m_vValue.vt == VT_BSTR && pName->m_vValue.bstrVal != 0)
        iNameLen = wcslen(pName->m_vValue.bstrVal);

    if(iNameLen == 0 || iAuthLen == 0)
        return WBEM_E_INVALID_OBJECT_PATH;

    // allocate some memory

    iLen = 2 + iNameLen + iAuthLen;

    pRet = new WCHAR[iLen];
    if(pRet == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    if(pAuth && pAuth->m_vValue.vt == VT_BSTR && pAuth->m_vValue.bstrVal != 0)
        wcscpy(pRet, pAuth->m_vValue.bstrVal);
    else
        wcscpy(pRet, L".");
    wcscat(pRet, L"|");
    wcscat(pRet, pName->m_vValue.bstrVal);
    *pToBeDeleted = pRet;
    return S_OK;

}

//***************************************************************************
//
//  CCombinedAce::CCombinedAce
//
//  Constructor.  Since there might be several ACEs for a single user or
//  group in the ACL, this structure is used to combine all the aces for a
//  sid into one.
//
//  PARAMETERS:
//
//  pwszName            User/group name.
//
//***************************************************************************

CCombinedAce::CCombinedAce(WCHAR *pwszName)
{
    m_dwAllow = 0;
    m_dwDeny = 0;
    m_BadAce = false;
    m_wcFullName =  NULL;
    if(pwszName)
    {
        m_wcFullName = new WCHAR[wcslen(pwszName) + 1];
        if(m_wcFullName)
            wcscpy(m_wcFullName, pwszName);
    }
}

//***************************************************************************
//
//  CCombinedAce::AddToMasks
//
//  Since this class is used to combine possibly many ACEs into a single
//  entry, this is called each time an ACE needs to be "OR"ed in.
//
//  PARAMETERS:
//
//  pAce                Pointer to the ace to be combined.
//
//***************************************************************************

void CCombinedAce::AddToMasks(CBaseAce * pAce)
{
    if(pAce == NULL)
        return;

    // Only aces with the container inherit bit can
    // be translated back.

    if(pAce->GetFlags() != CONTAINER_INHERIT_ACE)
        m_BadAce = true;
    if(pAce->GetType() == ACCESS_ALLOWED_ACE_TYPE)
        m_dwAllow |= pAce->GetAccessMask();
    else
        m_dwDeny |= pAce->GetAccessMask();
    return;
}

//***************************************************************************
//
//  CCombinedAce::IsValidOldEntry
//
//  Checks a combined ace and determines if it could be converted into
//  an old style object.
//
//  PARAMETERS:
//
//  bIsGroup            Set to true if the entry is for a group.
//
//  RETURN VALUES:
//
//  TRUE if the entry would make a valid instance
//
//***************************************************************************

bool CCombinedAce::IsValidOldEntry(bool bIsGroup)
{
    // If we have detected incompatible flags, all is done!

    if(m_BadAce)
        return false;
    if(bIsGroup && m_dwDeny)
        return false;   // group denies were not supported
    if(m_dwDeny && m_dwAllow)
        return false;   // can not mix allows and denies in old system

    if(m_dwDeny)
    {
        return true;
    }
    DWORD dwOldAllow = WBEM_ENABLE | WBEM_REMOTE_ACCESS | WBEM_WRITE_PROVIDER;
    DWORD dwMask = m_dwDeny;
    if(dwMask == 0)
        dwMask = m_dwAllow;

    // all these must be set if it is an allow.

    DWORD dwTemp = dwMask;
    dwTemp &= dwOldAllow;
    if(m_dwAllow != 0 && dwTemp != dwOldAllow)
        return false;

    // cant have full repository write without partial

    if((dwMask & WBEM_FULL_WRITE_REP) != 0 && (dwMask & WBEM_PARTIAL_WRITE_REP) == 0)
        return false;

    return true;
}

//***************************************************************************
//
//  CCombinedAce::GetNames
//
//  Retrieves the account name and authority
//
//  PARAMETERS:
//
//  pwszAccount     Set to newly allocated string, Caller must free if success
//  pwszDomain      Set to newly allocated string, Caller must free if success
//
//  RETURN VALUES:
//
//  S_OK if all is well, else an error code
//
//***************************************************************************

HRESULT CCombinedAce::GetNames(LPWSTR & pwszAccount, LPWSTR &pwszDomain)
{
    pwszAccount = 0;
    pwszDomain = 0;

    // find the position of the '|'

    if(m_wcFullName == 0)
        return WBEM_E_FAILED;

    WCHAR * pwcSeparator;
    for(pwcSeparator = m_wcFullName; *pwcSeparator && *pwcSeparator != L'|'; pwcSeparator++);
    DWORD dwLenDomain;
    DWORD dwLenUser;
    bool bUseDotDomain = false;

    if(*pwcSeparator == 0)
    {
        return WBEM_E_FAILED;
    }
    if(pwcSeparator == m_wcFullName)
    {
        bUseDotDomain = true;
        dwLenDomain = 2;
    }
    else
    {
        dwLenDomain = pwcSeparator - m_wcFullName + 1;
    }
    dwLenUser = wcslen(pwcSeparator);
    if(dwLenUser == 0)
        return WBEM_E_INVALID_OBJECT_PATH;

    // Allocate space for the two strings

    pwszAccount = new WCHAR[dwLenUser];
    if(pwszAccount == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    wcscpy(pwszAccount, pwcSeparator+1);

    pwszDomain = new WCHAR[dwLenDomain];
    if(pwszDomain == NULL)
    {
        delete pwszAccount;
        pwszAccount = 0;
        return WBEM_E_OUT_OF_MEMORY;
    }
    if(bUseDotDomain)
        wcscpy(pwszDomain, L".");
    else
    {
        wcsncpy(pwszDomain, m_wcFullName, dwLenDomain);
        pwszDomain[dwLenDomain-1] = 0;
    }
    return S_OK;
}

//***************************************************************************
//
//  RootSD::RootSD
//
//  Constructor.  This class contains a pointer to the root namespace and the
//  flex array of aces.
//
//***************************************************************************

RootSD::RootSD()
{
    m_bOK = false;
    m_pFlex = NULL;
    m_pRoot = CWbemNamespace::CreateInstance();

    if(m_pRoot == NULL)
        return;
    HRESULT hRes = m_pRoot->Initialize(L"root", L"Administrator",
                                    (IsNT()) ? 0 : SecFlagWin9XLocal,
                                    FULL_RIGHTS, true, false, NULL, 0xFFFFFFFF,
                                    FALSE, NULL);

	if (FAILED(hRes))
	{
        m_pRoot->Release();
        m_pRoot = NULL;
        return;
	}
    else if (m_pRoot->GetStatus() != 0)
    {
        m_pRoot->Release();
        m_pRoot = NULL;
        return;
    }
    m_pRoot->AddRef();

    // Get the security descriptor

    m_pFlex = NULL;
    SCODE sc = m_pRoot->GetAceList(&m_pFlex);
    if(!FAILED(sc))
        m_bOK = true;
}

//***************************************************************************
//
//  RootSD::~RootSD
//
//  Destructor.
//
//***************************************************************************

RootSD::~RootSD()
{
    if(m_pRoot)
        m_pRoot->Release();
    if(m_pFlex)
        delete m_pFlex;
}


//***************************************************************************
//
//  RootSD::StoreAceList()
//
//  Stores the Ace list back into the db.
//
//  RETURN VALUES:
//
//  S_OK if all is well, else an error code
//
//***************************************************************************

HRESULT RootSD::StoreAceList()
{
    if(m_bOK && m_pFlex && m_pRoot)
        m_pRoot->PutAceList(m_pFlex);
    return S_OK;
}


//***************************************************************************
//
//  RootSD::RemoveMatchingEntries
//
//  Goes through the ACE list and removes all entries that match the name
//
//  PARAMETERS:
//
//  pwszAccountName     Name of the account to be deleted
//
//  RETURN VALUES:
//
//  S_OK if all is well, else an error code
//
//***************************************************************************

HRESULT RootSD::RemoveMatchingEntries(LPWSTR pwszAccountName)
{

    if(!m_bOK || m_pFlex == NULL)
        return WBEM_E_FAILED;

    for(int iPos = m_pFlex->Size()-1; iPos >= 0; iPos--)
    {
        CBaseAce * pListAce = (CBaseAce *)m_pFlex->GetAt(iPos);
        WCHAR * pwszAceListUserName;
        if(pListAce == NULL)
            continue;
        HRESULT hr = pListAce->GetFullUserName2(&pwszAceListUserName);
        if(FAILED(hr))
            return hr;
        CDeleteMe<WCHAR> dm1(pwszAceListUserName);

        if(wbem_wcsicmp(pwszAceListUserName, pwszAccountName) == 0)
        {
            delete pListAce;
            m_pFlex->RemoveAt(iPos);
        }
    }
    return S_OK;
}

//***************************************************************************
//
//  OldSecList::OldSecList
//
//  Constructor.  This class contains the list of combined entries for the
//  aces in the root namespace.  Note that the list is of just the users,
//  or just the groups.
//
//***************************************************************************

OldSecList::OldSecList(bool bGroups)
{

    // Attach up to the root namespace

    RootSD rsd;
    if(!rsd.IsOK())
        return;         // empty list

    // Get the Security namespace

    CFlexAceArray * pRootNsAceList =  rsd.GetAceList();

    if(pRootNsAceList == NULL)
        return;

    // For each ACE in the root namespace list

    for(int iAce = 0; iAce < pRootNsAceList->Size(); iAce++)
    {

        // Search the entries in the combined list to see if there is already one for
        // this ace

        CBaseAce * pAce = (CBaseAce *)pRootNsAceList->GetAt(iAce);

        WCHAR * pwszAceListUserName;
        if(pAce == NULL)
            continue;

        // nt can have groups as well users, filter out one or the other

        if(IsNT())
        {
            CNtAce * pNtAce = (CNtAce *)pAce;
            CNtSid sid;
            pNtAce->GetSid(sid);
            DWORD dwUsage;
            LPWSTR pAccount = NULL;
            LPWSTR pDomain = NULL;
            if(sid.GetInfo(&pAccount, &pDomain, &dwUsage))
                continue;
            delete pAccount;
            delete pDomain;
            if(dwUsage == SidTypeUser && bGroups)
                continue;
            if(dwUsage != SidTypeUser && !bGroups)
                continue;
        }


        HRESULT hr = pAce->GetFullUserName2(&pwszAceListUserName);
        if(FAILED(hr))
            continue;
        CDeleteMe<WCHAR> dm1(pwszAceListUserName);

        bool bExisting = false;
        for(int iMergedEntry = 0; iMergedEntry < m_MergedAceList.Size(); iMergedEntry++)
        {
            CCombinedAce * pCombinedEntry = (CCombinedAce *)m_MergedAceList.GetAt(iMergedEntry);
            if(pCombinedEntry)
            {
                if(wbem_wcsicmp(pwszAceListUserName, pCombinedEntry->m_wcFullName) == 0 )
                {
                    bExisting = true;
                    pCombinedEntry->AddToMasks(pAce);
                    break;
                }
            }
        }

        // If necessary add a new entry

        if(!bExisting)
        {
            CCombinedAce * pCombinedEntry = new CCombinedAce(pwszAceListUserName);
            if(pCombinedEntry == NULL)
                return;
            pCombinedEntry->AddToMasks(pAce);
            m_MergedAceList.Add((void *)pCombinedEntry);
        }
    }
}

//***************************************************************************
//
//  OldSecList::~OldSecList()
//
//  Destructor.
//
//***************************************************************************

OldSecList::~OldSecList()
{

    // Delete the stuff used in the entry list.

    for(int iCnt = m_MergedAceList.Size() - 1; iCnt >= 0; iCnt--)
    {
        CCombinedAce * pCombinedEntry = (CCombinedAce *)m_MergedAceList.GetAt(iCnt);
        delete pCombinedEntry;
    }
}

//***************************************************************************
//
//  OldSecList::GetValidCombined
//
//  Returns a combined entry at the specified index, but only if it is valid.
//
//  PARAMETERS:
//
//  iIndex          Index into the array, 0 is the first
//  bGroup          true if a group entry is desired.
//
//  RETURN VALUES:
//
//  If all is well, a pointer to the combined entry.  NULL indicates failure.
//
//***************************************************************************

CCombinedAce * OldSecList::GetValidCombined(int iIndex, bool bGroup)
{

    if(iIndex < 0 || iIndex >= m_MergedAceList.Size())
        return NULL;

    // Get the entry

    CCombinedAce * pCombinedEntry = (CCombinedAce *)m_MergedAceList.GetAt(iIndex);
    if(pCombinedEntry == NULL)
        return NULL;

    // verify that the entry can be translated back into an old security setting

    if(pCombinedEntry->IsValidOldEntry(bGroup))
        return pCombinedEntry;
    else
    {
        DEBUGTRACE((LOG_WBEMCORE, "Invalid ace entry combination encountered, name = %S, "
            "allow=0x%x, deny=0x%x, flag validity=&d", pCombinedEntry->m_wcFullName,
            pCombinedEntry->m_dwAllow, pCombinedEntry->m_dwDeny, pCombinedEntry->m_BadAce));
        return NULL;
    }
}

//***************************************************************************
//
//  OldSecList::GetValidCombined
//
//  Returns a combined entry which matches the name, but only if it is valid.
//
//  PARAMETERS:
//
//  pName           Name to be found.  It is of the format "authority|name"
//  bGroup          true if a group entry is desired.
//
//  RETURN VALUES:
//
//  If all is well, a pointer to the combined entry.  NULL indicates failure.
//
//***************************************************************************

CCombinedAce * OldSecList::GetValidCombined(LPWSTR pName, bool bGroup)
{

    if(pName == NULL)
        return NULL;

    // Go through the list and look for the matching entry

    int iCnt;
    CCombinedAce * pCombinedEntry;
    for(iCnt = 0; iCnt < m_MergedAceList.Size(); iCnt++)
    {
        pCombinedEntry = (CCombinedAce *)m_MergedAceList.GetAt(iCnt);
        if(pCombinedEntry && !wbem_wcsicmp(pCombinedEntry->m_wcFullName, pName))
            break;
    }

    if(iCnt == m_MergedAceList.Size())
        return NULL;

    // verify that the entry can be translated back into an old security setting

    if(pCombinedEntry->IsValidOldEntry(bGroup))
        return pCombinedEntry;
    else
    {
        DEBUGTRACE((LOG_WBEMCORE, "Invalid ace entry combination encountered, name = %S, "
            "allow=0x%x, deny=0x%x, flag validity=&d", pCombinedEntry->m_wcFullName,
            pCombinedEntry->m_dwAllow, pCombinedEntry->m_dwDeny, pCombinedEntry->m_BadAce));
        return NULL;
    }
}

//***************************************************************************
//
//  CWbemNamespace::EnumerateSecurityClassInstances
//
//  Equivalent the a CreateInstanceEnumAsync call.
//
//  PARAMETERS:
//
//  wszClassName    class name
//  pSink           Where to indicate the value
//  pContext        pointer to the context object.
//  lFlags          flags.
//
//  RETURN VALUES:
//
//  S_OK if all is well, else an error code
//
//***************************************************************************

HRESULT CWbemNamespace::EnumerateSecurityClassInstances(LPWSTR wszClassName,
                    IWbemObjectSink* pSink, IWbemContext* pContext, long lFlags)
{

    SCODE sc = WBEM_E_FAILED;
    IWbemClassObject FAR* pObj = NULL;

    // Do sanity check of arguments.

    if(pSink == NULL || wszClassName == NULL )    // Should not happen
        return WBEM_E_INVALID_PARAMETER;

    // Get the class object

    IWbemClassObject * pClass = NULL;
    sc = GetObject(wszClassName, 0, pContext, &pClass, NULL);
    if(sc != S_OK)
    {
        return sc;
    }

    CReleaseMe rm(pClass);


    bool bGroup = false;
    if(wbem_wcsicmp(L"__ntlmgroup", wszClassName) == 0)
        bGroup = true;
    if(bGroup && !IsNT())
        return WBEM_E_INVALID_CLASS;
    OldSecList osl(bGroup);
    for(int i = 0; i < osl.Size(); i++)
    {
        IWbemClassObject * pObj = NULL;
        CCombinedAce * pCombinedEntry = osl.GetValidCombined(i, bGroup);
        if(pCombinedEntry)
        {
            sc = CreateTheInstance(&pObj, pClass, pCombinedEntry);
            if(sc == S_OK)
            {
                DecorateObject(pObj);
                pSink->Indicate(1,&pObj);
                pObj->Release();
            }
        }
    }

    // Set status, all done
    return S_OK;
}

//***************************************************************************
//
//  CWbemNamespace::PutSecurityClassInstances
//
//  Equivalent to a PutInstanceAsync call.
//
//  PARAMETERS:
//
//  wszClassName    class name
//  pObj            Object to be "put"
//  pSink           where to SetStatus
//  pContext        pointer to the context object
//  lFlags          flags
//
//  RETURN VALUES:
//
//  S_OK if all is well, else an error code
//
//***************************************************************************

HRESULT CWbemNamespace::PutSecurityClassInstances(LPWSTR wszClassName,  IWbemClassObject * pObj,
                    IWbemObjectSink* pSink, IWbemContext* pContext, long lFlags)
{
    // Check the args

    if(wszClassName == NULL || pObj == NULL || pSink == NULL)
    {
        pSink->SetStatus(0,WBEM_E_INVALID_PARAMETER,NULL,NULL);
        return S_OK;
    }

    RootSD rsd;
    if(!rsd.IsOK())
    {
        pSink->SetStatus(0,WBEM_E_FAILED,NULL,NULL);
        return S_OK;
    }

    // Get the Security namespace

    CFlexAceArray * pRootNsAceList =  rsd.GetAceList();
    bool bGroup = false;
    if(wbem_wcsicmp(L"__ntlmgroup", wszClassName) == 0)
        bGroup = true;
    if(bGroup && !IsNT())
    {
        pSink->SetStatus(0,WBEM_E_INVALID_CLASS,NULL,NULL);
        return S_OK;
    }

    // Convert to new sid

    CBaseAce * pAce = ConvertOldObjectToAce(pObj, bGroup);
    if(pAce == NULL)
    {
        pSink->SetStatus(0,WBEM_E_INVALID_OBJECT,NULL,NULL);
        return S_OK;
    }


    // Delete all entries with the same name

    WCHAR * pwszAccountName;
    HRESULT hr = pAce->GetFullUserName2(&pwszAccountName);
    if(FAILED(hr))
    {
        pSink->SetStatus(0,hr,NULL,NULL);
        return S_OK;
    }

    CDeleteMe<WCHAR> dm1(pwszAccountName);

    rsd.RemoveMatchingEntries(pwszAccountName);

    // Add the new entries

    pRootNsAceList->Add(pAce);

    // Put Sid back

    hr = rsd.StoreAceList();
    pSink->SetStatus(0,hr,NULL,NULL);
    return S_OK;
}

//***************************************************************************
//
//  CWbemNamespace::DeleteSecurityClassInstances
//
//  Equivalent to a DeleteInstanceAsync routine
//
//  PARAMETERS:
//
//  pParsedPath     parsed object path
//  pSink           where to SetStatus
//  pContext        pointer to the context object
//  lFlags          flags
//
//  RETURN VALUES:
//
//  S_OK if all is well, else an error code
//
//***************************************************************************

HRESULT CWbemNamespace::DeleteSecurityClassInstances(ParsedObjectPath* pParsedPath,
                    IWbemObjectSink* pSink, IWbemContext* pContext, long lFlags)
{
    // Check the args

    if(pParsedPath == NULL || pSink == NULL || pSink == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // Parse the path and contruct the domain|user string

    LPWSTR pAcePath = NULL;
    HRESULT hr = GetAceStylePath(pParsedPath, &pAcePath);
    if(FAILED(hr))
    {
        pSink->SetStatus(0,hr,NULL,NULL);
        return S_OK;
    }

    CDeleteMe<WCHAR> dm(pAcePath);

    // Delete the entries

    RootSD rsd;
    if(!rsd.IsOK())
        hr = WBEM_E_FAILED;
    else
    {
        CFlexAceArray * pRootNsAceList =  rsd.GetAceList();
        int iOriginalSize = pRootNsAceList->Size();

        // Delete all entries with the same name

        rsd.RemoveMatchingEntries(pAcePath);

        int iNewSize = pRootNsAceList->Size();
        if(iNewSize < iOriginalSize)
            hr = rsd.StoreAceList();
        else
            hr = WBEM_E_NOT_FOUND;
    }
    pSink->SetStatus(0,hr,NULL,NULL);
    return S_OK;

}

//***************************************************************************
//
//  CWbemNamespace::GetSecurityClassInstances
//
//  Equivalent to a GetObjectAsync call.
//
//  PARAMETERS:
//
//  pParsedPath     parsed object path
//  pSink           where to SetStatus
//  pContext        pointer to the context object
//  lFlags          flags
//
//  RETURN VALUES:
//
//  S_OK if all is well, else an error code
//
//***************************************************************************

HRESULT CWbemNamespace::GetSecurityClassInstances(ParsedObjectPath* pParsedPath, CBasicObjectSink* pSink,
                    IWbemContext* pContext,long lFlags)
{
    // Check the args

    if(pParsedPath == NULL|| pSink == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // Parse the path and contruct the domain|user string

    LPWSTR pAcePath = NULL;
    HRESULT hr = GetAceStylePath(pParsedPath, &pAcePath);
    if(FAILED(hr))
    {
        pSink->SetStatus(0,hr,NULL,NULL);
        return S_OK;
    }

    CDeleteMe<WCHAR> dm(pAcePath);

    IWbemClassObject * pClass = NULL;
    SCODE sc = GetObject(pParsedPath->m_pClass, 0, pContext, &pClass, NULL);
    if(sc != S_OK)
    {
        pSink->SetStatus(0,sc,NULL, NULL);
        return S_OK;
    }

    CReleaseMe rm(pClass);


    bool bGroup = false;
    if(wbem_wcsicmp(L"__ntlmgroup", pParsedPath->m_pClass) == 0)
        bGroup = true;
    if(bGroup && !IsNT())
        return WBEM_E_INVALID_CLASS;
    OldSecList osl(bGroup);

    IWbemClassObject * pObj = NULL;
    CCombinedAce * pCombinedEntry = osl.GetValidCombined(pAcePath, bGroup);
    if(pCombinedEntry == NULL)
    {
        pSink->SetStatus(0, WBEM_E_INVALID_OBJECT_PATH, NULL, NULL);
        return S_OK;
    }
    sc = CreateTheInstance(&pObj, pClass, pCombinedEntry);
    if(sc == S_OK)      // not all entries make for valid old entries, so failure is common
    {

        DecorateObject(pObj);
        pSink->Indicate(1,&pObj);
        pObj->Release();
    }

    // Set status, all done

    pSink->SetStatus(0,sc,NULL, NULL);
    return S_OK;

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/
#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>

#define COREPOL_HEADERFILE_IS_INCLUDED

#define COREPROX_POLARITY __declspec( dllimport )
#define ESSLIB_POLARITY __declspec( dllimport )

#define COREPOL_HEADERFILE_IS_INCLUDED
#define POLARITY_HEADERFILE_IS_INCLUDED
#define POLARITY __declspec( dllimport )

#include "arena.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\protoq.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    PROTOQ.H

Abstract:

	Prototype query support for WinMgmt Query Engine.
    This was split out from QENGINE.CPP for better source
    organization.

History:

    raymcc   04-Jul-99   Created.
    raymcc   14-Aug-99   Resubmit due to VSS problem.

--*/

#ifndef _PROTOQ_H_
#define _PROTOQ_H_

HRESULT ExecPrototypeQuery(
    IN CWbemNamespace *pNs,
    IN LPWSTR pszQuery,
    IN IWbemContext* pContext,
    IN CBasicObjectSink *pSink
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\prvcache.inl ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    PRVCACHE.INL

Abstract:

	Provider Cache inlines

History:

--*/

template<class TProvider>
void CTypedProviderCache<TProvider>::Purge()
{
    CInCritSec ics(&m_cs);

    m_aCache.RemoveAll();
    if(m_pUnloadInst)
    {
        m_pUnloadInst->Terminate();
        m_pUnloadInst->Release();
        m_pUnloadInst = NULL;
    }
}

template<class TProvider>
HRESULT CTypedProviderCache<TProvider>::Remove(LPCWSTR wszNamespace, 
                                                LPCWSTR wszName)
{
    CInCritSec ics(&m_cs);

    for(int i = 0; i < m_aCache.GetSize(); i++)
    {
        TProvider* pEl = m_aCache[i];
        if(!wbem_wcsicmp(pEl->GetNamespaceName(), wszNamespace) && 
            !wbem_wcsicmp(pEl->GetProviderName(), wszName))
        {
            m_aCache.RemoveAt(i);
            return WBEM_S_NO_ERROR;
        }
    }

    return WBEM_S_FALSE;
}

template<class TProvider>
HRESULT CTypedProviderCache<TProvider>::Schedule(CWbemNamespace* pNamespace, 
                            LPCWSTR wszProvName, CProviderRequest* pReq, 
                            CBasicObjectSink* pSink)
{
    CInCritSec ics(&m_cs);

    // Find the provider in question
    // =============================

    TProvider* pRecord;
    HRESULT hres = FindProvider(pNamespace, wszProvName, pReq->GetContext(),
                                    pRecord);
    if(FAILED(hres)) 
    {
        pSink->SetStatus(0, hres, NULL, NULL);
        delete pReq;
        return hres;
    }
    
    // Enqueue it, if provider supports this kind of requests
    // ======================================================

    if(pReq->CanExecuteOnProvider(pRecord))
    {
        // Create a wrapper sink
        // =====================
        
        CFullProviderSink* pWrapper = 
            new CFullProviderSink(pSink, wszProvName, pNamespace, 
                        pRecord->GetServices(), pReq->GetContext(),
                        pReq->ShouldSuppressProgress());
        pWrapper->AddRef();
       
        // Make sure it is still current
        // =============================

        hres = pWrapper->GetCancelStatus();
        if(FAILED(hres))
        {
            pWrapper->Cancel(hres);
            pWrapper->Release();
            return hres;
        }
        pReq->SetSink(pWrapper);
        pWrapper->Release();

        pRecord->Touch();
        return pRecord->Enqueue(pReq);
    }
    else 
    {
        pSink->SetStatus(0, WBEM_E_PROVIDER_NOT_CAPABLE, NULL, NULL);
        delete pReq;
        return WBEM_E_PROVIDER_NOT_CAPABLE;
    }
}

template<class TProvider>
HRESULT CTypedProviderCache<TProvider>::FindProvider(CWbemNamespace* pNamespace,
                LPCWSTR wszProvName, IWbemContext* pContext, 
                TProvider*& rpRecord)
{
    HRESULT hres;
    rpRecord = NULL;

    CInCritSec ics(&m_cs);

    // Search the primary cache
    // ========================

    for (int i = 0; i < m_aCache.GetSize(); i++)
    {
        rpRecord = m_aCache[i];
        if (wbem_wcsicmp(rpRecord->GetProviderName(), wszProvName))
            continue;
        if(wbem_wcsicmp(pNamespace->GetName(), rpRecord->GetNamespaceName()))
            continue;
        if(rpRecord->IsPerUser())
        {
            if(pNamespace->GetUserName() == NULL)
            {
                if(wcslen(rpRecord->GetUserName()) > 0)
                    continue;
            }
            else
            {
                if(wbem_wcsicmp(pNamespace->GetUserName(), rpRecord->GetUserName()))
                    continue;
            }
        }

        if(rpRecord->IsPerLocale())
        {
			// by default, the local is set to ms_409
			
            if(pNamespace->GetLocale() && rpRecord->GetLocale())
            {
                if(wbem_wcsicmp(pNamespace->GetLocale(), rpRecord->GetLocale()))
                    continue;
            }
        }
        return WBEM_S_NO_ERROR;
    }

    // Create provider record
    // ======================

    rpRecord = new TProvider(pNamespace, wszProvName);

    // Initialize it
    // =============
    
    hres = rpRecord->LoadRegistrationData();
    if(FAILED(hres))
    {
        delete rpRecord;
        return WBEM_E_INVALID_PROVIDER_REGISTRATION;
    }

    m_aCache.Add(rpRecord);

    // Make sure unload instruction is active
    // ======================================

    if(m_aCache.GetSize() == 1 && m_pUnloadInst == NULL)
    {
        m_pUnloadInst = 
            new CTypedProviderWatchInstruction<TProvider>(this, pContext);
        m_pUnloadInst->AddRef();

        ConfigMgr::GetTimerGenerator()->Set(m_pUnloadInst);
    }

    return WBEM_S_NO_ERROR;
}

template<class TProvider>
HRESULT CTypedProviderCache<TProvider>::UnloadProviders(
                                CWbemInterval m_Timeout)
{
    BOOL bFound = FALSE;

    {
        CInCritSec ics(&m_cs);
        int i;
    
        for(i = 0; i < m_aCache.GetSize(); i++)
        {
            TProvider* pEl = m_aCache[i];
            if(pEl->GetRefCount() == 1 && // 1 is held by the cache!
                CWbemTime::GetCurrentTime() - pEl->GetLastAccess() > m_Timeout)
            {
                // Timeout
                // =======
    
                DEBUGTRACE((LOG_WBEMCORE, "Unloading provider %S in namespace "
                    "%S\n", pEl->GetProviderName(), pEl->GetNamespaceName()));
                m_aCache.RemoveAt(i);
                i--;
                bFound = TRUE;
            }
        }

        if(m_aCache.GetSize() == 0)
        {
            if(m_pUnloadInst)
            {
                m_pUnloadInst->Terminate();
                m_pUnloadInst->Release();
            }
            m_pUnloadInst = NULL;
        }
    }

    if(bFound)
        ConfigMgr::GetTimerGenerator()->ScheduleFreeUnusedLibraries();

    return WBEM_S_NO_ERROR;
}

template<class TProvider>
BOOL CTypedProviderCache<TProvider>::MayInitialize(TProvider* pInitRecord,
                                                    CProviderRequest* pReq)
{
    CInCritSec ics(&m_cs);

    for(int i = 0; i < m_aCache.GetSize(); i++)
    {
        TProvider* pRecord = m_aCache[i];
        if(pRecord->GetClsid() == pInitRecord->GetClsid())
        {
            // Same provider. Check dependency
            // ===============================

            IWbemContext* pRecContext = pRecord->GetConnectContext();
            if(pRecContext && pReq->IsChildOf(pRecContext))
                return FALSE;
        }
    }

    return TRUE;
}

template<class TProvider>
HRESULT CTypedProviderCache<TProvider>::PurgeNamespace(LPCWSTR wszNamespace)
{
    CInCritSec ics(&m_cs);

    // Search the primary cache
    // ========================

    for (int i = 0; i < m_aCache.GetSize(); i++)
    {
        TProvider* pRecord = m_aCache[i];
        if(!wbem_wcsicmp(wszNamespace, pRecord->GetNamespaceName()))
        {
            m_aCache.RemoveAt(i);
            i--;
        }
    }

    return WBEM_S_NO_ERROR;
}

template<class TProvider>
HRESULT CTypedProviderCache<TProvider>::PurgeProvider(LPCWSTR wszNamespace,
                                                    LPCWSTR wszName)
{
    CInCritSec ics(&m_cs);

    // Search the primary cache
    // ========================

    for (int i = 0; i < m_aCache.GetSize(); i++)
    {
        TProvider* pRecord = m_aCache[i];
        if(!wbem_wcsicmp(wszNamespace, pRecord->GetNamespaceName()) &&
            !wbem_wcsicmp(wszName, pRecord->GetProviderName()))
        {
            m_aCache.RemoveAt(i);
            i--;
        }
    }

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\qengine.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    QENGINE.H

Abstract:

	WinMgmt Query Engine

History:

    raymcc  20-Dec-96   Created
    raymcc   14-Aug-99   Resubmit due to VSS problem.

--*/



#ifndef _QENGINE_H_
#define _QENGINE_H_

class CWbemNamespace;
class CWQLParser;
class CWmiMerger;

class CMergerSink;

//***************************************************************************
//
//***************************************************************************

class CQueryEngine
{
    static int QueryOptimizationTest(
        IN  IWmiDbSession *pSession,
        IN  IWmiDbHandle *pNsHandle,
        IN IWmiDbHandle *pScopeHandle,
        IN  LPCWSTR wszClassName,
        IN  QL_LEVEL_1_RPN_EXPRESSION *pExp,
        OUT CWbemObject **pClassDef,
        OUT LPWSTR *pPropToUse,
        OUT CVar **pValToUse,
        OUT int *pnType
        );

    static BOOL IsConjunctiveQuery(
        IN  QL_LEVEL_1_RPN_EXPRESSION *pExp
        );

    static BOOL QueryKeyTest(
        IN  QL_LEVEL_1_RPN_EXPRESSION *pExp,
        IN  CWbemObject *pClassDef,
        IN  CWStringArray &aKeyProps
        );

    static BOOL QueryIndexTest(
        IN  QL_LEVEL_1_RPN_EXPRESSION *pExp,
        IN  CWbemObject *pClsDef,
        IN  CWStringArray &aIndexedProps,
        OUT LPWSTR *pPropToUse,
        OUT CVar **pValToUse,
        OUT int *pnType
        );

    static int KeyedQuery(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNsHandle,
        IN QL_LEVEL_1_RPN_EXPRESSION *pExp,
        IN CWbemObject *pClassDef,
        IN DWORD dwFlags,
        IN CBasicObjectSink* pDest, // no status
		IN CWbemNamespace * pNs
        );

    static LPWSTR GetObjectPathFromQuery(
        IN CWbemObject *pClassDef,
        IN QL_LEVEL_1_RPN_EXPRESSION *pExp,
		IN CWbemNamespace * pNs
        );


    static HRESULT ExecQlQuery(
        IN CWbemNamespace *pNs,
        IN LPWSTR pszQuery,
        IN LONG lFlags,
        IN IWbemContext* pContext,
        IN CBasicObjectSink* pSink
        );

    static HRESULT ExecRepositoryQuery(
        IN CWbemNamespace *pNs,
        IN LPWSTR pszQuery,
        IN LONG lFlags,
        IN IWbemContext* pContext,
        IN CBasicObjectSink* pSink
        );

    static HRESULT ExecComplexQuery(
        IN CWbemNamespace *pNs,
        IN LPWSTR pszQuery,
        IN LONG lFlags,
        IN IWbemContext* pContext,
        IN CBasicObjectSink* pSink
        );

	// New Function
    static  HRESULT EvaluateSubQuery(
        IN CWbemNamespace *pNs,
        IN CDynasty *pCurrentDyn,
        IN LPWSTR pszTextQuery,
        IN QL_LEVEL_1_RPN_EXPRESSION *pParsedQuery,
        IN IWbemContext* pContext,
        IN BOOL bSuppressStaticChild,
		IN CWmiMerger* pMerger,
		IN CMergerSink* pSink,
        long lFlags,
		bool bHasRightSibling = false
        );

	// Old Function
    static  HRESULT EvaluateSubQuery(
        IN CWbemNamespace *pNs,
        IN CDynasty *pCurrentDyn,
        IN LPWSTR pszTextQuery,
        IN QL_LEVEL_1_RPN_EXPRESSION *pParsedQuery,
        IN IWbemContext* pContext,
        IN BOOL bSuppressStaticChild,
        IN CBasicObjectSink* pSink, // must have combining semantics
        long lFlags,
		bool bHasRightSibling = false
        );

    static HRESULT ExecAtomicDynQlQuery(
        IN CWbemNamespace *pNs,
        IN CDynasty* pDyn,
        IN LPWSTR pszQueryFormat,
        IN LPWSTR pszQuery,
        IN QL_LEVEL_1_RPN_EXPRESSION *pParsedQuery,
        IN LONG lFlags,
        IN IWbemContext* pContext,
        IN CBasicObjectSink* pDest, // must support selective filtering ,
		IN BOOL bHasChildren
        );

    static HRESULT DirectRead(
        IN CWbemNamespace *pNs,
        IN CDynasty *pCurrentDyn,
        IN LPWSTR wszTextQuery,
        IN QL_LEVEL_1_RPN_EXPRESSION *pParsedQuery,
        IN IWbemContext* pContext,
        IN CBasicObjectSink* pSink,
        IN long lFlags
        );


    static LPWSTR ConstructReferenceProviderQuery(
            CWbemNamespace* pNamespace, IWbemContext* pContext,
            LPCWSTR wszRefClass, CWbemClass* pRefClass, CWbemObject* pTargetObj,
            LPCWSTR wszTargetPathQ,
            LPCWSTR wszTargetClass, LPCWSTR wszTargetRole,
            LPCWSTR wszResultClass, LPCWSTR wszRequiredQualifier,
            LPCWSTR wszEndpointClass, LPCWSTR wszEndpointRole,
            CWStringArray& awsPossibleRoles
            );


    static HRESULT ExecReferencesQuery(CWbemNamespace* pNs,
            IWbemContext* pContext,
            LPCWSTR wszTargetPath,  LPCWSTR wszTargetRole,
            LPCWSTR wszResultClass, LPCWSTR wszRequiredQualifier,
            LPCWSTR wszEndpointClass, LPCWSTR wszEndpointRole,
            CBasicObjectSink* pSink,
			DWORD dwQueryType
            );

    static HRESULT ExecSchemaReferencesQuery(CWbemNamespace* pNs,
            IWbemContext* pContext, CWbemClass* pClass,
            LPCWSTR wszRealClassName,  LPCWSTR wszTargetRole,
            LPCWSTR wszResultClass, LPCWSTR wszRequiredQualifier,
            LPCWSTR wszEndpointClass, LPCWSTR wszEndpointRole,
            CBasicObjectSink* pSink
            );

    static HRESULT ExecNormalReferencesQuery(CWbemNamespace* pNs,
            IWbemContext* pContext, CWbemObject* pObj,
            LPCWSTR wszTargetPath,  LPCWSTR wszTargetRole,
            LPCWSTR wszResultClass, LPCWSTR wszRequiredQualifier,
            LPCWSTR wszEndpointClass, LPCWSTR wszEndpointRole,
            BOOL bClassDefsOnly,
            CBasicObjectSink* pSink
            );

    static HRESULT EliminateDerivedProperties(
            IN  QL_LEVEL_1_RPN_EXPRESSION* pOrigQuery,
            IN  CWbemClass* pClass,
            IN  BOOL bRelax,
            OUT QL_LEVEL_1_RPN_EXPRESSION** ppNewQuery
            );

    static BOOL IsTokenAboutClass(IN QL_LEVEL_1_TOKEN& Token,
                                       IN CWbemClass* pClass);

    static HRESULT AndQueryExpressions(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pFirst,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSecond,
                                OUT QL_LEVEL_1_RPN_EXPRESSION** ppNew
                                );

    static HRESULT OrQueryExpressions(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pFirst,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSecond,
                                OUT QL_LEVEL_1_RPN_EXPRESSION** ppNew
                                );

    static void AppendQueryExpression(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pDest,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSource
                                );

    static BSTR GetParentPath(CWbemInstance* pInst, LPCWSTR wszClassName);

	static HRESULT ExecSchemaQuery(
        IN CWbemNamespace *pNs,
		IN LPWSTR pszQuery,
		QL_LEVEL_1_RPN_EXPRESSION *pExp,
		IN IWbemContext* pContext,
		IN CBasicObjectSink* pSink
        );

    static HRESULT ValidateQuery(IN QL_LEVEL_1_RPN_EXPRESSION *pExp,
                                 IN CWbemClass *pClassDef
                                 );

    static HRESULT FindOverridenProperties(CDynasty* pDyn,
                                                CWStringArray& awsOverriden,
                                                bool bIncludeThis = false);

public:
    enum { no_error, failed, syntax_error,
           invalid_query, invalid_query_language,
           use_key, use_table_scan, use_index,
           invalid_parameter, invalid_class,
           not_found
         };

    static int ExecAtomicDbQuery(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNsHandle,
        IN IWmiDbHandle *pScopeHandle,
        IN LPCWSTR wszClassName,
        IN QL_LEVEL_1_RPN_EXPRESSION *pExp,
        IN CBasicObjectSink* pDest, // no status!
		IN CWbemNamespace * pNs
        );

    static HRESULT QueryAllClasses(
        IN CWbemNamespace *pNs,
        IN LPWSTR pszParent,
        OUT IEnumWbemClassObject **ppEnum
        );

    static HRESULT QueryImmediateClasses(
        IN CWbemNamespace *pNs,
        IN LPWSTR pszParent,
        OUT IEnumWbemClassObject **ppEnum
        );

    static HRESULT ExecQuery(
        IN CWbemNamespace *pNs,
        IN LPWSTR pQueryFormat,
        IN LPWSTR pQuery,
        IN LONG lFlags,
        IN IWbemContext* pContext,
        IN CBasicObjectSink* pSink
        );
    static BSTR AdjustPathToClass(LPCWSTR wszRelPath, LPCWSTR wszClassName);
    static LPWSTR NormalizePath(LPCWSTR wszObjectPath, CWbemNamespace * pNs);
    static LPWSTR GetSimplePropertyName(WBEM_PROPERTY_NAME& Name);
    static LPWSTR GetPrimaryName(WBEM_PROPERTY_NAME& Name);

    static BOOL IsAReferenceToClass(
        IN CWbemNamespace* pNamespace,
        IWbemContext* pContext,
        IN CWbemObject* pObj,
        IN LPCWSTR wszPropName,
        IN CWbemObject* pTargetClass,
        IN bool bCheckPropValue
        );

    static BOOL AreClassesRelated(
        IN CWbemNamespace* pNamespace,
        IWbemContext* pContext,
        CWbemObject* pClass1,
        LPCWSTR wszClass2
        );

protected:
    static HRESULT EliminateDuplications(
                    CRefedPointerArray<CWbemClass>& apClasses,
                    LPCWSTR wszResultClass);
};

//***************************************************************************
//
//***************************************************************************

class CQueryExpression
{
protected:
    QL_LEVEL_1_RPN_EXPRESSION* m_pExpr;
    long m_lRef;

protected:
    virtual ~CQueryExpression()
    {
        delete m_pExpr;
    }
public:
    CQueryExpression(QL_LEVEL_1_RPN_EXPRESSION* pExpr)
        : m_pExpr(pExpr), m_lRef(1)
    {
    }
    void AddRef() {InterlockedIncrement(&m_lRef);}
    void Release() {if(InterlockedDecrement(&m_lRef) == 0) delete this;}
    INTERNAL QL_LEVEL_1_RPN_EXPRESSION* GetExpr() { return m_pExpr;}
};

//***************************************************************************
//
//***************************************************************************

class CQlFilteringSink : public CFilteringSink
{
protected:
    QL_LEVEL_1_RPN_EXPRESSION* m_pExpr;
    BOOL m_bFilterNow;
	CWbemNamespace * m_pNs;
public:
    CQlFilteringSink(CBasicObjectSink* pDest,
                    ADDREF QL_LEVEL_1_RPN_EXPRESSION* pExp,
                    CWbemNamespace * pNamespace, BOOL bFilterNow = TRUE
                    );
    ~CQlFilteringSink();

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);

    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam
                         );

    virtual IWbemObjectSink* GetIndicateSink() {return this;}
    virtual IWbemObjectSink* GetStatusSink() {return this;}

    static BOOL Test(CWbemObject* pObj, QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                        CWbemNamespace * pNs
                        );

    BOOL Test(CWbemObject* pObj) {return Test(pObj, m_pExpr, m_pNs);}

    static int EvaluateToken(IWbemPropertySource *pTestObj,
                                QL_LEVEL_1_TOKEN& Tok,
                                CWbemNamespace * pNs
                                );
};

//***************************************************************************
//
//***************************************************************************

class CProjectingSink : public CForwardingSink
{
protected:
    CLimitationMapping m_Map;
    BOOL m_bValid;
    BOOL m_bProjecting;
    WString m_wsError;
    CCritSec m_cs;

public:
    CProjectingSink(CBasicObjectSink* pDest,
                    CWbemClass* pClassDef,
                    READONLY QL_LEVEL_1_RPN_EXPRESSION* pExp,
                    long lQueryFlags);
    BOOL IsValid() {return m_bValid;}

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    virtual IWbemObjectSink* GetIndicateSink() {return this;}
};

//***************************************************************************
//
//***************************************************************************

class CClassDefsOnlyCancelSink : public CForwardingSink
{
protected:
    CCritSec m_cs;
    CWbemNamespace* m_pNamespace;
    WString m_wsTargetObj;
    CWStringArray* m_pawsRemainingRoles;
    BOOL m_bCancelled;

public:
    CClassDefsOnlyCancelSink(CBasicObjectSink* pDest,
            CWbemNamespace* pNamespace,
            LPCWSTR wszTargetObj, CWStringArray* pawsPossibleRoles);
    ~CClassDefsOnlyCancelSink();

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    virtual IWbemObjectSink* GetIndicateSink() {return this;}

    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);
    virtual IWbemObjectSink* GetStatusSink() {return this;}
protected:
    BOOL DoHaveEnough(CWbemObject* pObj);
};

//***************************************************************************
//
//***************************************************************************

class CMerger
{
protected:
    class CMemberSink : public CObjectSink
    {
    protected:
        CMerger* m_pMerger;
    public:
        CMemberSink(CMerger* pMerger) : CObjectSink(0), m_pMerger(pMerger)
        {}

        STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);
        virtual BOOL IsTrusted()
            {return m_pMerger->m_pDest->IsTrusted();}
        virtual BOOL IsApartmentSpecific()
            {return m_pMerger->m_pDest->IsApartmentSpecific();}
    };
    friend CMemberSink;

    class COwnSink : public CMemberSink
    {
    public:
        COwnSink(CMerger* pMerger) : CMemberSink(pMerger)
        {
            m_pMerger->AddRef();
        }
        ~COwnSink();

        STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);

    };
    friend COwnSink;

    class CChildSink : public CMemberSink
    {
    public:
        CChildSink(CMerger* pMerger) : CMemberSink(pMerger)
        {
            m_pMerger->AddRef();
        }
        ~CChildSink();

        STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);

    };
    friend CChildSink;

public:
    struct CRecord
    {
        CWbemInstance* m_pData;
        BOOL m_bOwn;
    };
protected:
    COwnSink* m_pOwnSink;
    CChildSink* m_pChildSink;
    CBasicObjectSink* m_pDest;

    BOOL m_bDerivedFromTarget;
    CWbemClass* m_pOwnClass;
    CWbemNamespace* m_pNamespace;
    IWbemContext* m_pContext;

    CCritSec m_cs;

    std::map<WString, CRecord, WSiless, wbem_allocator<CRecord> > m_map;

    BOOL m_bOwnDone;
    BOOL m_bChildrenDone;
    WString m_wsClass;
    long m_lRef;

    IServerSecurity* m_pSecurity;

protected:
    HRESULT AddOwnObject(IWbemClassObject* pObj);
    HRESULT AddChildObject(IWbemClassObject* pObj);

    void Enter() {EnterCriticalSection(&m_cs);}
    void Leave() {LeaveCriticalSection(&m_cs);}

    long AddRef();
    long Release();

    void OwnIsDone();
    void ChildrenAreDone();

    void DispatchChildren();
    void DispatchOwn();
    void GetKey(IWbemClassObject* pInst, WString& wsKey);
    void GetOwnInstance(LPCWSTR wszKey);
    BOOL IsDone() {return m_bOwnDone && m_bChildrenDone;}
public:
    CMerger(CBasicObjectSink* pDest, CWbemClass* pOwnClass,
                CWbemNamespace* pNamespace = NULL,
                IWbemContext* pContext = NULL);
    ~CMerger();

    BOOL IsValid(){ return (m_pOwnSink && m_pChildSink); };

    void SetIsDerivedFromTarget(BOOL bIs);
    CBasicObjectSink* GetOwnSink() {return m_pOwnSink;}
    CBasicObjectSink* GetChildSink() {return m_pChildSink;}
};



//***************************************************************************
//
//***************************************************************************

struct CProjectionRule
{
    WString m_wsPropName;
    enum {e_Invalid, e_TakeAll, e_TakePart} m_eType;
    CUniquePointerArray<CProjectionRule> m_apPropRules;

public:
    CProjectionRule() : m_eType(e_TakePart)
    {}
    CProjectionRule(LPCWSTR wszPropName)
        : m_wsPropName(wszPropName), m_eType(e_TakePart)
    {}

    CProjectionRule* Find(LPCWSTR wszName);
    int GetNumElements(){return m_apPropRules.GetSize();};
};

//***************************************************************************
//
//***************************************************************************

class CComplexProjectionSink : public CForwardingSink
{
protected:
    CProjectionRule m_TopRule;
    WString m_FirstTable;
    WString m_FirstTableAlias;

protected:
    void AddColumn(CFlexArray& aFields, LPCWSTR wszPrefix);
    HRESULT Project(IWbemClassObject* pObj, CProjectionRule* pRule,
                                         IWbemClassObject** ppProj);
public:
    CComplexProjectionSink(CBasicObjectSink* pDest, CWQLScanner* pParser);
    ~CComplexProjectionSink();

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    virtual IWbemObjectSink* GetIndicateSink() {return this;}
};


#endif




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\qengine.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    QENGINE.CPP

Abstract:

    WinMgmt Query Engine

History:

    raymcc   20-Dec-96  Created
    levn     97-98-99   Modified beyond comprehension
    raymcc   14-Aug-99  Ripped out and relocated assocs to happy new home
    raymcc   22-Apr-00  First mutations for new ProvSS

--*/

#include "precomp.h"

#include <stdio.h>
#include <stdlib.h>

#include <wbemcore.h>
#include <perfhelp.h>
#include <wbemstr.h>
#include <stack>

#include <wbemmeta.h>
#include <analyser.h>
#include <genutils.h>
#include <DateTimeParser.h>
#include "stack.h"
#include <like.h>
#include "wmimerger.h"
#include <autoptr.h>
#include <wmiarbitrator.h>

//***************************************************************************
//
//  Local defs
//
//***************************************************************************

#define WBEM_OPTIMIZATION_FLAG_DONT_ENUMERATE 1

#define INVALID     0x3


class CX_ImpersonationFailure { } ;


//***************************************************************************
//
//***************************************************************************

CQlFilteringSink::CQlFilteringSink(
    CBasicObjectSink* pDest,
    ADDREF QL_LEVEL_1_RPN_EXPRESSION* pExpr,
    CWbemNamespace *pNamespace, BOOL bFilterNow
    )
    : CFilteringSink(pDest), m_pExpr(pExpr), m_bFilterNow(bFilterNow),
            m_pNs(pNamespace)
{
    // TBD: consider the query
    m_pExpr->AddRef();
}

//***************************************************************************
//
//***************************************************************************

CQlFilteringSink::~CQlFilteringSink()
{
    m_pExpr->Release();
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CQlFilteringSink::Indicate(
    long lObjectCount,
    IWbemClassObject** pObjArray
    )
{
    if(!m_bFilterNow)
        return m_pDest->Indicate(lObjectCount, pObjArray);

    return CFilteringSink::Indicate(lObjectCount, pObjArray);
}

//***************************************************************************
//
//***************************************************************************

BOOL CQlFilteringSink::Test(
    CWbemObject* pObj,
    QL_LEVEL_1_RPN_EXPRESSION* pExpr,
    CWbemNamespace * pNs
    )
{
    CStack Stack;

    // If a pure 'select' with no 'where' clause, we always
    // return TRUE.
    // ====================================================
    if (pExpr->nNumTokens == 0)
        return TRUE;

    for (int i = 0; i < pExpr->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN& Tok = pExpr->pArrayOfTokens[i];

        if (Tok.nTokenType == QL_LEVEL_1_TOKEN::TOKEN_AND)
        {
            BOOL b1 = (BOOL) Stack.Pop();
            BOOL b2 = (BOOL) Stack.Pop();
            if (b1 == TRUE && b2 == TRUE)
                Stack.Push(TRUE);
            else if (b1 == INVALID || b2 == INVALID)
                Stack.Push(INVALID);
            else
                Stack.Push(FALSE);
        }
        else if (Tok.nTokenType == QL_LEVEL_1_TOKEN::TOKEN_OR)
        {
            BOOL b1 = (BOOL) Stack.Pop();
            BOOL b2 = (BOOL) Stack.Pop();
            if (b1 == TRUE || b2 == TRUE)
                Stack.Push(TRUE);
            else if (b1 == INVALID || b2 == INVALID)
                Stack.Push(INVALID);
            else
                Stack.Push(FALSE);
        }
        else if (Tok.nTokenType == QL_LEVEL_1_TOKEN::TOKEN_NOT)
        {
            BOOL b1 = (BOOL) Stack.Pop();
            if (b1 == TRUE)
                Stack.Push(FALSE);
            else if (b1 == INVALID)
                Stack.Push(INVALID);
            else
                Stack.Push(TRUE);
        }
        else if (Tok.nTokenType == QL_LEVEL_1_TOKEN::OP_EXPRESSION)
        {
            Stack.Push(EvaluateToken(pObj, Tok, pNs));
        }
    }

    // Pop top element, which becomes the return value.
    // ================================================

    int nRes = Stack.Pop();

    if (nRes == INVALID)
        return FALSE;

    return (BOOL) nRes;
}


//***************************************************************************
//
//***************************************************************************

class CWbemStringFree
{
    WBEM_WSTR m_wsz;
public:
    CWbemStringFree(WBEM_WSTR wsz) : m_wsz(wsz){}
    ~CWbemStringFree() {WbemStringFree(m_wsz);}
};

//***************************************************************************
//
//***************************************************************************

int CQlFilteringSink::EvaluateToken(
    IWbemPropertySource *pTestObj,
    QL_LEVEL_1_TOKEN& Tok,
    CWbemNamespace * pNs
    )
{
    _variant_t PropVal, CompVal;

    WBEM_WSTR wszCimType, wszCimType2;
    HRESULT hRes;

    // Special-case 'this'
    // ===================

    if(Tok.PropertyName.GetNumElements() == 1 &&
        !wbem_wcsicmp(Tok.PropertyName.GetStringAt(0), L"__THIS"))
    {
        wszCimType = WbemStringCopy(L"object");
        V_VT(&PropVal) = VT_UNKNOWN;
        hRes = pTestObj->QueryInterface(IID_IWbemClassObject,
                                            (void**)&V_UNKNOWN(&PropVal));
    }
    else
    {
        hRes = pTestObj->GetPropertyValue(&Tok.PropertyName, 0,
                                                &wszCimType, &PropVal);
    }
    if (FAILED(hRes))
        return FALSE;
    CWbemStringFree wsf(wszCimType);

    // Handle a property-to-property comparison,

    if (Tok.m_bPropComp != FALSE)
    {
        hRes = pTestObj->GetPropertyValue(&Tok.PropertyName2, 0,
                                                &wszCimType2, &CompVal);
        if (FAILED(hRes))
            return FALSE;
    }
    else
    {
        if ( FAILED (VariantCopy(&CompVal, &Tok.vConstValue)) )
			return FALSE;
    }

    // Handle NULLs
    // ============

    if(V_VT(&PropVal) == VT_NULL)
    {
        if(V_VT(&CompVal) == VT_NULL)
        {
            if(Tok.nOperator == QL_LEVEL_1_TOKEN::OP_EQUAL)
                return TRUE;
            else if(Tok.nOperator == QL_LEVEL_1_TOKEN::OP_NOT_EQUAL)
                return FALSE;
            else
                return INVALID;
        }
        else
        {
            if(Tok.nOperator == QL_LEVEL_1_TOKEN::OP_EQUAL)
                return FALSE;
            else if(Tok.nOperator == QL_LEVEL_1_TOKEN::OP_NOT_EQUAL)
                return TRUE;
            else
                return INVALID;
        }
    }
    else if(V_VT(&CompVal) == VT_NULL)
    {
        if(Tok.nOperator == QL_LEVEL_1_TOKEN::OP_EQUAL)
            return FALSE;
        else if(Tok.nOperator == QL_LEVEL_1_TOKEN::OP_NOT_EQUAL)
            return TRUE;
        else
            return INVALID;
    }

    // Handle references
    // =================

    if(wszCimType &&
        _wcsnicmp(wszCimType, L"ref", 3) == 0 &&
        (wszCimType[3] == 0 || wszCimType[3] == L':'))
    {
        // This is a reference. The only operators allowed are = and !=
        // ============================================================

        if(PropVal.vt != VT_BSTR || PropVal.bstrVal == NULL)
            return INVALID;
        if(CompVal.vt != VT_BSTR || CompVal.bstrVal == NULL)
            return INVALID;
        LPWSTR va = CQueryEngine::NormalizePath(V_BSTR(&PropVal), pNs);
        LPWSTR vb = CQueryEngine::NormalizePath(V_BSTR(&CompVal), pNs);
        if(va == NULL || vb == NULL)
        {
            if(va)
                delete [] va;
            if(vb)
                delete [] vb;
            ERRORTRACE((LOG_WBEMCORE, "Invalid path %S or %S specified in an "
                "association\n", V_BSTR(&PropVal), V_BSTR(&CompVal)));
            return INVALID;
        }

        int nRet;
        switch (Tok.nOperator)
        {
        case QL_LEVEL_1_TOKEN::OP_EQUAL:
            nRet = (wbem_wcsicmp(va,vb) == 0);
            break;
        case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
            nRet = (wbem_wcsicmp(va, vb) != 0);
            break;
        default:
            nRet = INVALID;
            break;
        }

        delete [] va;
        delete [] vb;


        return nRet;
    }


    // Check if ISA is used
    // ====================

    if(Tok.nOperator == QL1_OPERATOR_ISA ||
       Tok.nOperator == QL1_OPERATOR_ISNOTA ||
       Tok.nOperator == QL1_OPERATOR_INV_ISA ||
       Tok.nOperator == QL1_OPERATOR_INV_ISNOTA)
    {
        // Account for inversion
        // =====================

        VARIANT* pv1;
        VARIANT* pv2;
        int bNeedDerived;

        if(Tok.nOperator == QL1_OPERATOR_ISA ||
           Tok.nOperator == QL1_OPERATOR_ISNOTA)
        {
            pv2 = &CompVal;
            pv1 = &PropVal;
            bNeedDerived = (Tok.nOperator == QL1_OPERATOR_ISA);
        }
        else
        {
            pv1 = &CompVal;
            pv2 = &PropVal;
            bNeedDerived = (Tok.nOperator == QL1_OPERATOR_INV_ISA);
        }

        // The second argument has to be a string
        // ======================================

        if(V_VT(pv2) != VT_BSTR)
        {
            return INVALID;
        }

        BSTR strParentClass = V_BSTR(pv2);

        // The first argument has to be an object or a string
        // ==================================================

        BOOL bDerived;
        if(V_VT(pv1) == VT_EMBEDDED_OBJECT)
        {
            IWbemClassObject* pObj = (IWbemClassObject*)V_EMBEDDED_OBJECT(pv1);
            bDerived = (pObj->InheritsFrom(strParentClass) == WBEM_S_NO_ERROR);
        }
        else if(V_VT(pv1) == VT_BSTR)
        {
            // TBD
            // ===

            return INVALID;
        }
        else
        {
            return INVALID;
        }

        // Now that we have bDerived, see if it matches the requirement
        // ============================================================

        if(bDerived == bNeedDerived)
            return TRUE;
        else
            return FALSE;

    }

    // Perform UINT32 workaround
    // =========================

    if(wszCimType && !wbem_wcsicmp(wszCimType, L"uint32") &&
        V_VT(&PropVal) == VT_I4)
    {
        DWORD dwVal = (DWORD)V_I4(&PropVal);
        WCHAR wszVal[20];
        swprintf(wszVal, L"%lu", dwVal);
        BSTR bstrTmp = SysAllocString(wszVal);
        if (bstrTmp)
        {
            V_VT(&PropVal) = VT_BSTR;
            V_BSTR(&PropVal) = bstrTmp;
        }
        else
        {
            V_VT(&PropVal) = VT_NULL;
        }
    }

    if(wszCimType &&
            (!wbem_wcsicmp(wszCimType, L"sint64") ||
             !wbem_wcsicmp(wszCimType, L"uint64") ||
             !wbem_wcsicmp(wszCimType, L"uint32")) &&
        V_VT(&CompVal) != VT_NULL && V_VT(&PropVal) != VT_NULL)
    {
        BOOL bUnsigned = (wbem_wcsicmp(wszCimType, L"uint64") == 0);

        // We have a 64-bit comparison where both sides are present.
        // =========================================================

        hRes = VariantChangeType(&CompVal, &CompVal, 0,
                                    VT_BSTR);
        if(FAILED(hRes))
        {
            return INVALID;
        }

        if(bUnsigned)
        {
            unsigned __int64 ui64Prop, ui64Const;

            if(!ReadUI64(V_BSTR(&PropVal), ui64Prop))
                return INVALID;

            if(!ReadUI64(V_BSTR(&CompVal), ui64Const))
                return INVALID;

            switch (Tok.nOperator)
            {
                case QL_LEVEL_1_TOKEN::OP_EQUAL: return (ui64Prop == ui64Const);
                case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
                    return (ui64Prop != ui64Const);
                case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
                    return (ui64Prop >= ui64Const);
                case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
                    return (ui64Prop <= ui64Const);
                case QL_LEVEL_1_TOKEN::OP_LESSTHAN:
                    return (ui64Prop < ui64Const);
                case QL_LEVEL_1_TOKEN::OP_GREATERTHAN:
                    return (ui64Prop > ui64Const);
                case QL_LEVEL_1_TOKEN::OP_LIKE: return (ui64Prop == ui64Const);
            }
            return INVALID;
        }
        else
        {
            __int64 i64Prop, i64Const;

            if(!ReadI64(V_BSTR(&PropVal), i64Prop))
                return INVALID;

            if(!ReadI64(V_BSTR(&CompVal), i64Const))
                return INVALID;

            switch (Tok.nOperator)
            {
                case QL_LEVEL_1_TOKEN::OP_EQUAL: return (i64Prop == i64Const);
                case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
                    return (i64Prop != i64Const);
                case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
                    return (i64Prop >= i64Const);
                case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
                    return (i64Prop <= i64Const);
                case QL_LEVEL_1_TOKEN::OP_LESSTHAN:
                    return (i64Prop < i64Const);
                case QL_LEVEL_1_TOKEN::OP_GREATERTHAN:
                    return (i64Prop > i64Const);
                case QL_LEVEL_1_TOKEN::OP_LIKE: return (i64Prop == i64Const);
            }
            return INVALID;
        }
    }

    if(wszCimType && !wbem_wcsicmp(wszCimType, L"char16") &&
        V_VT(&CompVal) == VT_BSTR && V_VT(&PropVal) != VT_NULL)
    {
        // Coerce strings correctly
        // ========================

        BSTR str = V_BSTR(&Tok.vConstValue);
        if(wcslen(str) != 1)
            return INVALID;

        short va = V_I2(&PropVal);
        short vb = str[0];

        switch (Tok.nOperator)
        {
            case QL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
            case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
            case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
            case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
            case QL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
            case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
            case QL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
        }

        return INVALID;
    }

    if(wszCimType &&
            (!wbem_wcsicmp(wszCimType, L"datetime")) &&
        V_VT(&CompVal) == VT_BSTR && V_VT(&PropVal) == VT_BSTR)
    {
        // Parse the constant specified in the query according to the
        // SQL rules
        // ==========================================================

        TCHAR *tszBuffer;
#ifdef UNICODE
	tszBuffer = V_BSTR(&CompVal);
#else
        BSTR strConstVal = V_BSTR(&CompVal);
        tszBuffer = new char[wcslen(strConstVal) * 4 + 1];
        sprintf(tszBuffer, "%S", strConstVal);
        CDeleteMe<char> delMe(tszBuffer);
#endif
        CDateTimeParser dtConst(tszBuffer);

        if(!dtConst.IsValidDateTime())
            return INVALID;

        WCHAR wszConstValDMTF[26];
        dtConst.FillDMTF(wszConstValDMTF);

        // Read both DMTF values and parse them
        // ====================================

        CWbemTime wtConst, wtProp;
        if(!wtConst.SetDMTF(wszConstValDMTF))
            return INVALID;
        if(!wtProp.SetDMTF(V_BSTR(&PropVal)))
            return INVALID;

        __int64 i64Const = wtConst.Get100nss();
        __int64 i64Prop = wtProp.Get100nss();

        switch (Tok.nOperator)
        {
            case QL_LEVEL_1_TOKEN::OP_EQUAL: return (i64Prop == i64Const);
            case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
                return (i64Prop != i64Const);
            case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
                return (i64Prop >= i64Const);
            case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
                return (i64Prop <= i64Const);
            case QL_LEVEL_1_TOKEN::OP_LESSTHAN:
                return (i64Prop < i64Const);
            case QL_LEVEL_1_TOKEN::OP_GREATERTHAN:
                return (i64Prop > i64Const);
            case QL_LEVEL_1_TOKEN::OP_LIKE: return (i64Prop == i64Const);
        }
    }

    // Coerce types to match.
    // ======================


    if(V_VT(&CompVal) != VT_NULL && V_VT(&PropVal) != VT_NULL)
    {
	// Compensate for VT_UI1 > VT_I4
	//
      	if (V_VT(&CompVal) == VT_UI1 && V_VT(&PropVal) !=VT_UI1)
	  hRes = VariantChangeType(&CompVal,&CompVal,0, VT_I4);

	if (V_VT(&PropVal) == VT_UI1 && V_VT(&CompVal) !=VT_UI1)
	  hRes = VariantChangeType(&PropVal,&PropVal,0, VT_I4);

	if (V_VT(&PropVal) > V_VT(&CompVal))
            hRes = VariantChangeType(&CompVal, &CompVal, 0, V_VT(&PropVal));
        else
            hRes = VariantChangeType(&PropVal, &PropVal, 0, V_VT(&CompVal));
        if(FAILED(hRes))
        {
            return INVALID;
        }
    }


    switch (V_VT(&CompVal))
    {
        case VT_NULL:
            return INVALID; // handled above

        case VT_I4:
            {
                if(V_VT(&PropVal) == VT_NULL)
                    return INVALID;

                LONG va = V_I4(&PropVal);
                LONG vb = V_I4(&CompVal);

                switch (Tok.nOperator)
                {
                    case QL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
                    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
                    case QL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
                    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
                    case QL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
                }
            }
            break;

        case VT_I2:
            {
                if(V_VT(&PropVal) == VT_NULL)
                    return INVALID;

                short va = V_I2(&PropVal);
                short vb = V_I2(&CompVal);

                switch (Tok.nOperator)
                {
                    case QL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
                    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
                    case QL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
                    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
                    case QL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
                }
            }
            break;

        case VT_UI1:
            {
                if(V_VT(&PropVal) == VT_NULL)
                    return INVALID;

                BYTE va = V_I1(&PropVal);
                BYTE vb = V_I1(&CompVal);

                switch (Tok.nOperator)
                {
                    case QL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
                    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
                    case QL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
                    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
                    case QL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
                }
            }
            break;

        case VT_BSTR:
            {
                if(V_VT(&PropVal) == VT_NULL)
                    return INVALID;

                LPWSTR va = (LPWSTR) V_BSTR(&PropVal);
                LPWSTR vb = (LPWSTR) V_BSTR(&CompVal);

                int retCode = 0;
                BOOL bDidIt = TRUE;

                switch (Tok.nOperator)
                {
                    case QL_LEVEL_1_TOKEN::OP_EQUAL:
                        retCode = ( wbem_wcsicmp(va,vb) == 0);
                        break;
                    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
                        retCode = (wbem_wcsicmp(va, vb) != 0);
                        break;
                    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
                        retCode = (wbem_wcsicmp(va, vb) >= 0);
                        break;
                    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
                        retCode = (wbem_wcsicmp(va, vb) <= 0);
                        break;
                    case QL_LEVEL_1_TOKEN::OP_LESSTHAN:
                        retCode = (wbem_wcsicmp(va, vb) < 0);
                        break;
                    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN:
                        retCode = (wbem_wcsicmp(va, vb) > 0);
                        break;
                    case QL_LEVEL_1_TOKEN::OP_LIKE:
                        {
                            CLike l (vb);
                            retCode = (int)l.Match(va);
                        }
                        break;
                    default:
                        bDidIt = FALSE;
                        break;
                }
                VariantClear(&CompVal);
                if (bDidIt)
                {
                    return retCode;
                }
            }
            break;

        case VT_R8:
            {
                if(V_VT(&PropVal) == VT_NULL)
                    return INVALID;

                double va = V_R8(&PropVal);
                double vb = V_R8(&CompVal);

                switch (Tok.nOperator)
                {
                    case QL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
                    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
                    case QL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
                    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
                    case QL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
                }
            }
            break;

        case VT_R4:
            {
                if(V_VT(&PropVal) == VT_NULL)
                    return INVALID;

                float va = V_R4(&PropVal);
                float vb = V_R4(&CompVal);

                switch (Tok.nOperator)
                {
                    case QL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
                    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
                    case QL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
                    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
                    case QL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
                }
            }
            break;

        case VT_BOOL:
            {
                if(V_VT(&PropVal) == VT_NULL)
                    return INVALID;

                VARIANT_BOOL va = V_BOOL(&PropVal);
                if(va != VARIANT_FALSE) va = VARIANT_TRUE;
                VARIANT_BOOL vb = V_BOOL(&CompVal);
                if(vb != VARIANT_FALSE) vb = VARIANT_TRUE;

                switch (Tok.nOperator)
                {
                    case QL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
                    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return INVALID;
                    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return INVALID;
                    case QL_LEVEL_1_TOKEN::OP_LESSTHAN: return INVALID;
                    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: return INVALID;
                    case QL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
                }
            }
            break;
    }

    return FALSE;
}


//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CQlFilteringSink::SetStatus(
    long lFlags,
    long lParam,
    BSTR strParam,
    IWbemClassObject* pObjParam
    )
{
    if(lFlags == WBEM_STATUS_REQUIREMENTS)
    {
        m_bFilterNow = (lParam == S_OK);
        return WBEM_S_NO_ERROR;
    }
    else
    {
        return CFilteringSink::SetStatus(lFlags, lParam, strParam, pObjParam);
    }
}



//***************************************************************************
//
//***************************************************************************

CProjectingSink::CProjectingSink(
    CBasicObjectSink* pDest,
    CWbemClass* pClassDef,
    READONLY QL_LEVEL_1_RPN_EXPRESSION* pExp,
    long lQueryFlags
    )
    : CForwardingSink(pDest, 0), m_bValid(FALSE), m_bProjecting(FALSE)
{
    // Extract the properties selected by the user.
    // ============================================

    CWStringArray awsPropList;
    for (int i = 0; i < pExp->nNumberOfProperties; i++)
    {
        CPropertyName& PropName = pExp->pRequestedPropertyNames[i];
        LPWSTR wszPrimaryName = CQueryEngine::GetPrimaryName(PropName);

        if (wszPrimaryName && !_wcsicmp(wszPrimaryName, L"count(*)"))
        {
            m_bValid = TRUE;
            m_bProjecting = FALSE;
            return;
        }

        // Check for complexity
        // ====================

        if(PropName.GetNumElements() > 1)
        {
            // Complex --- make sure the property is an object
            // ===============================================

            CIMTYPE ct;
            if(FAILED(pClassDef->GetPropertyType(wszPrimaryName, &ct)) ||
                ct != CIM_OBJECT)
            {
                m_wsError = wszPrimaryName;
                return;
            }
        }

        awsPropList.Add(wszPrimaryName);
    }

    if (awsPropList.Size() == 0)
    {
        m_bValid = TRUE;
        return;
    }

    if(lQueryFlags & WBEM_FLAG_ENSURE_LOCATABLE)
    {
        awsPropList.Add(L"__PATH");
    }


    // Verify that the projection will succeed.
    // ========================================

    m_wsError = pClassDef->FindLimitationError(0, &awsPropList);
    if(m_wsError.Length() > 0)
        return;

    // Check for *
    // ===========

    if(pExp->bStar)
    {
        m_bValid = TRUE;
        return;
    }

    // Map the limitaiton
    // ==================

    m_bValid = pClassDef->MapLimitation(0, &awsPropList, &m_Map);
    m_bProjecting = TRUE;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CProjectingSink::Indicate(
    long lObjectCount,
    IWbemClassObject** pObjArray
    )
{
    if(!m_bProjecting)
        return m_pDest->Indicate(lObjectCount, pObjArray);

    IWbemClassObject** apNewArray = new IWbemClassObject*[lObjectCount];
    if (NULL == apNewArray)
        return WBEM_E_OUT_OF_MEMORY;
    HRESULT hres;
    int i;

    {
        CInCritSec ics(&m_cs);

        for(i = 0; i < lObjectCount; i++)
        {
            CWbemInstance* pInst = (CWbemInstance*)pObjArray[i];
            CWbemInstance* pNewInst;

            hres = pInst->GetLimitedVersion(&m_Map, &pNewInst);
            if(FAILED(hres))
            {
                for(int j = 0; j < i; j++)
                    apNewArray[j]->Release();
                delete [] apNewArray;
                return hres;
            }
            apNewArray[i] = pNewInst;
        }
    }

    hres = m_pDest->Indicate(lObjectCount, apNewArray);

    for(i = 0; i < lObjectCount; i++)
        apNewArray[i]->Release();
    delete [] apNewArray;

    return hres;
}




//***************************************************************************
//
//  class CMerger
//
//  This class is a 'reverse fork'.  It consumes two sinks and outputs
//  one.  Its purpose is to merge instances of the same key in a given
//  dynasty.  Each CMerger has two inputs, (a) instances of the class
//  in question, (b) instances of from another Merger representing
//  instances of subclasses.  Given classes A,B:A,C:B, for example,
//  where "<--" is a sink:
//
//      | own:Instances of A
//  <---|                 | own:Instances of B
//      | child: <--------|
//                        | child:Instances of C
//
//
//  The two input sinks for CMerger are <m_pOwnSink> which receives
//  instances from the provider for "A", for example, and the <m_pChildSink>
//  which receives instances from the underyling Merger.
//
//  The mergers operate asynchronously to each other.  Therefore,
//  the instances for A may arrive in its CMerger sink before instances
//  of the child classes have arrived in theirs.
//
//  As objects arrive in the owning CMerger for a class, AddOwnObject()
//  is called.  As objects arrive from a child sink, AddChildObject()
//  is called.  In either case, if the object with a given key
//  arrives for the first time, it is simply added to the map. If
//  it is already there (via a key lookup), then a merge is performed
//  via CWbemInstance::AsymmetricMerge.  Immediately after this merge,
//  the object is dispatched up to the next parent sink via the parent's
//  AddChildObject and removed from the map.
//
//  Note that in a class hierarchy {A,B:A,C:B} an enumeration/query is
//  performed only against the classes in the CDynasty referenced in
//  the query. This logic occurs in CQueryEngine::EvaluateSubQuery.
//  For example, if "select * from B" is the query, only queries
//  for B and C are performed.  The CMerger logic will do individual
//  'get object' calls for any instances needed in A to complete
//  the merged B/C instances while merging is taking place.
//
//***************************************************************************


typedef map<WString, CMerger::CRecord, WSiless, wbem_allocator<CMerger::CRecord> >::iterator TMapIterator;

#pragma warning(disable:4355)

CMerger::CMerger(
    CBasicObjectSink* pDest,
    CWbemClass* pOwnClass,
    CWbemNamespace* pNamespace,
    IWbemContext* pContext
    )
    :   m_pDest(pDest), m_bOwnDone(FALSE),
        m_bChildrenDone(FALSE), m_pNamespace(pNamespace), m_pContext(pContext),
        m_pOwnClass(pOwnClass), m_bDerivedFromTarget(TRUE), m_lRef(0),
        m_pSecurity(NULL)
{

    m_pOwnSink = new COwnSink(this);
    m_pChildSink = new CChildSink(this);

	// IsValid will check for these allocation failures
  
    m_pDest->AddRef();
    if(m_pContext)
        m_pContext->AddRef();
    if(m_pNamespace)
        m_pNamespace->AddRef();

    if(m_pOwnClass)
    {
        m_pOwnClass->AddRef();
        CVar v;
        pOwnClass->GetClassName(&v);
        m_wsClass = v.GetLPWSTR();
    }

    // Retrieve call security. Need to create a copy for use on another thread
    // =======================================================================

    m_pSecurity = CWbemCallSecurity::MakeInternalCopyOfThread();
}

//***************************************************************************
//
//***************************************************************************

CMerger::~CMerger()
{
    m_pDest->Release();
    if(m_pNamespace)
        m_pNamespace->Release();
    if(m_pContext)
        m_pContext->Release();
    if(m_pOwnClass)
        m_pOwnClass->Release();
    delete m_pOwnSink;
    delete m_pChildSink;

    if(m_pSecurity)
        m_pSecurity->Release();
}
//***************************************************************************
//
//***************************************************************************

long CMerger::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

//***************************************************************************
//
//***************************************************************************

long CMerger::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

//***************************************************************************
//
//***************************************************************************

void CMerger::GetKey(IWbemClassObject* pObj, WString& wsKey)
{
    LPWSTR wszRelPath = ((CWbemInstance*)pObj)->GetRelPath();
    if (wszRelPath == NULL)
    {
        ERRORTRACE((LOG_WBEMCORE, "Object with no path submitted to a "
                        "merge\n"));
        wsKey.Empty();
        return;
    }

    WCHAR* pwcDot = wcschr(wszRelPath, L'.');
    if (pwcDot == NULL)
    {
        ERRORTRACE((LOG_WBEMCORE, "Object with invalid path %S submitted to a "
                        "merge\n", wszRelPath));
        wsKey.Empty();

        // Clean up the path
        delete [] wszRelPath;

        return;
    }

    wsKey = pwcDot+1;
    delete [] wszRelPath;
}

//***************************************************************************
//
//***************************************************************************

void CMerger::SetIsDerivedFromTarget(BOOL bIs)
{
    m_bDerivedFromTarget = bIs;

    if (!bIs)
    {
        // We will need our OwnSink for GetObject calls
        // ============================================

        m_pOwnSink->AddRef();
    }
}

//***************************************************************************
//
//***************************************************************************

HRESULT CMerger::AddOwnObject(IWbemClassObject* pObj)
{
    WString wsKey;
    GetKey(pObj, wsKey);

    CInCritSec ics(&m_cs);

    TMapIterator it = m_map.find(wsKey);
    if (it == m_map.end())
    {
        // Not there. Check if there is any hope for children
        // ==================================================

        if (m_bChildrenDone)
        {
            if (m_bDerivedFromTarget)
            {
                // forward
                m_pDest->Add(pObj);
            }
            else
            {
                // ignore
            }
        }
        else
        {
            try
            {
                // Insert
                CRecord& rRecord = m_map[wsKey];
                rRecord.m_pData = (CWbemInstance*) pObj;
                pObj->AddRef();
                rRecord.m_bOwn = TRUE;
            }
            catch( CX_MemoryException )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
            catch(...)
            {
		        ExceptionCounter c;            
                return WBEM_E_FAILED;
            }
        }
    }
    else
    {
        // Attempt to merge
        // ================

        HRESULT hres = CWbemInstance::AsymmetricMerge(
                            (CWbemInstance*)pObj,
                            (CWbemInstance*)it->second.m_pData);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_WBEMCORE, "Merge conflict for instances with "
                "key %S\n", wsKey));
        }

        // Dispatch the result!
        // ====================

        m_pDest->Add(it->second.m_pData);
        it->second.m_pData->Release();
        m_map.erase(it);
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CMerger::AddChildObject(IWbemClassObject* pObj)
{
	HRESULT hRes = S_OK ;

    WString wsKey;
    GetKey(pObj, wsKey);

    CInCritSec ics(&m_cs);

    TMapIterator it = m_map.find(wsKey);

    if (it == m_map.end())
    {
        // Check if there is any hope for parent
        // =====================================

        if(m_bOwnDone)
        {
            BSTR str = NULL;
            pObj->GetObjectText(0, &str);

            // The following was commented out because it actually incorrectly logs
            // an error if the child provider enumerates when the parent provider
            // interprets a query and returns fewer instances.  Neither provider is wrong,
            // but this error message causes needless worry.  In Quasar, we have to fix
            // this whole merger thing to be smarter anyway.
            //
            // ERRORTRACE((LOG_WBEMCORE, "[Chkpt_1] [%S] Orphaned object %S returned by "
            //    "provider\n", LPWSTR(m_wsClass), str));
            SysFreeString(str);
            // m_pDest->Add(pObj);
        }
        else
        {
            // insert

            try
            {
                CRecord& rRecord = m_map[wsKey];
                rRecord.m_pData = (CWbemInstance*)pObj;
                pObj->AddRef();
                rRecord.m_bOwn = FALSE;

                // Check if parent's retrieval is needed
                // =====================================

                if (!m_bDerivedFromTarget)
                {

					try
					{
	                    GetOwnInstance(wsKey);
					}
					catch( CX_MemoryException &)
					{
		                hRes = WBEM_E_OUT_OF_MEMORY;
					}
					catch (...)
					{
				        ExceptionCounter c;					
						hRes = WBEM_E_CRITICAL_ERROR;
					}

/*
 *	return here because exclusion area has already been exited.
 */
					return hRes ;
                }
            }
            catch( CX_MemoryException &)
            {
                hRes = WBEM_E_OUT_OF_MEMORY;
            }
            catch(...)
            {   
			    ExceptionCounter c;
                hRes = WBEM_E_CRITICAL_ERROR;
            }
         }
    }
    else if(!it->second.m_bOwn)
    {
        ERRORTRACE((LOG_WBEMCORE, "Two providers supplied conflicting "
                        "instances for key %S\n", wsKey));
    }
    else
    {
        // Attempt to merge
        // ================

        IWbemClassObject* pClone;
        HRESULT hres = pObj->Clone(&pClone);
        if (FAILED(hres))
        {
            ERRORTRACE((LOG_WBEMCORE, "Clone failed in AddChildObject, hresult is 0x%x",
                hres));
            return hres;
        }
        hres = CWbemInstance::AsymmetricMerge(
                                    (CWbemInstance*)it->second.m_pData,
                                    (CWbemInstance*)pClone
                                    );
        if (FAILED(hres))
        {
            ERRORTRACE((LOG_WBEMCORE, "Merge conflict for instances with "
                "key %S\n", wsKey));
        }

        // Dispatch the result!
        // ====================

        m_pDest->Add(pClone);
        pClone->Release();
        it->second.m_pData->Release();
        m_map.erase(it);
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

void CMerger::DispatchChildren()
{
    TMapIterator it = m_map.begin();

    while (it != m_map.end())
    {
        if (!it->second.m_bOwn)
        {
            BSTR str = NULL;
            it->second.m_pData->GetObjectText(0, &str);

            // The following was commented out because it actually incorrectly logs
            // an error if the child provider enumerates when the parent provider
            // interprets a query and returns fewer instances.  Neither provider is wrong,
            // but this error message causes needless worry.  In Quasar, we have to fix
            // this whole merger thing to be smarter anyway.
            //

//            ERRORTRACE((LOG_WBEMCORE, "Chkpt2 [%S] Orphaned object %S returned by "
//                "provider\n", LPWSTR(m_wsClass), str));

            SysFreeString(str);

            // m_pDest->Add(it->second.m_pData);

            it->second.m_pData->Release();
            it = m_map.erase(it);
        }
        else it++;
    }
}

//***************************************************************************
//
//***************************************************************************

void CMerger::DispatchOwn()
{
    if(!m_bDerivedFromTarget)
        return;

	try
	{

		TMapIterator it = m_map.begin();

		while (it != m_map.end())
		{
			if(it->second.m_bOwn)
			{
				m_pDest->Add(it->second.m_pData);
				it->second.m_pData->Release();
				it = m_map.erase(it);
			}
			else it++;
		}
	}
	catch(...)
	{
        ExceptionCounter c;	
	}
}

//***************************************************************************
//
//***************************************************************************

void CMerger::GetOwnInstance(LPCWSTR wszKey)
{
    LPWSTR wszPath = new WCHAR[wcslen(wszKey) + m_wsClass.Length() + 2];
    if (wszPath && wcslen(wszKey))
    {
        swprintf(wszPath, L"%s.%s", (LPCWSTR)m_wsClass, wszKey);


        {

			CAutoImpersonate ai;

			// Impersonate original client
			// ===========================
			IUnknown* pOld;
			WbemCoSwitchCallContext(m_pSecurity, &pOld);
        

			m_pNamespace->DynAux_GetSingleInstance(m_pOwnClass, 0, wszPath,
							m_pContext, m_pOwnSink
							);

			// Revert to self
			// ==============
			IUnknown* pThis;
			WbemCoSwitchCallContext(pOld, &pThis);                        

			if ( FAILED ( ai.Impersonate ( ) ) )
			{
				throw CX_ImpersonationFailure ( ) ;
			}
        }

    }

    delete [] wszPath;
}

//***************************************************************************
//
//***************************************************************************

void CMerger::OwnIsDone()
{
    m_bOwnDone = TRUE;
    m_pOwnSink = NULL;
}

//***************************************************************************
//
//***************************************************************************

void CMerger::ChildrenAreDone()
{
    m_bChildrenDone = TRUE;
    m_pChildSink = NULL;
    if(!m_bDerivedFromTarget)
    {
        // Don't need that ref count on pOwnSink anymore
        // =============================================

        m_pOwnSink->Release();
    }
}

//***************************************************************************
//
//***************************************************************************


STDMETHODIMP CMerger::CMemberSink::
SetStatus(long lFlags, long lParam, BSTR strParam, IWbemClassObject* pObjParam)
{
    if(lFlags == 0 && lParam == WBEM_E_NOT_FOUND)
        lParam = WBEM_S_NO_ERROR;

    // Propagate error to error combining sink
    // =======================================

    return m_pMerger->m_pDest->SetStatus(lFlags, lParam, strParam,
                                                pObjParam);
}

//***************************************************************************
//
//***************************************************************************

CMerger::COwnSink::~COwnSink()
{
    m_pMerger->Enter();
    m_pMerger->DispatchChildren();
    m_pMerger->OwnIsDone();
    if (m_pMerger->Release())
        m_pMerger->Leave();
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CMerger::COwnSink::
Indicate(long lNumObjects, IWbemClassObject** apObjects)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    for(long l = 0; SUCCEEDED( hr ) && l < lNumObjects; l++)
    {
        hr = m_pMerger->AddOwnObject(apObjects[l]);
    }

    return hr;
}

//***************************************************************************
//
//***************************************************************************

CMerger::CChildSink::~CChildSink()
{
    m_pMerger->Enter();
    m_pMerger->DispatchOwn();
    m_pMerger->ChildrenAreDone();
    if(m_pMerger->Release())
        m_pMerger->Leave();
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CMerger::CChildSink::
Indicate(long lNumObjects, IWbemClassObject** apObjects)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    for (long l = 0; SUCCEEDED( hr ) && l < lNumObjects; l++)
    {
        hr = m_pMerger->AddChildObject(apObjects[l]);
    }

    return hr;
}


//***************************************************************************
//
//***************************************************************************

CProjectionRule* CProjectionRule::Find(LPCWSTR wszName)
{
    for(int i = 0; i < m_apPropRules.GetSize(); i++)
    {
        if(!wbem_wcsicmp(m_apPropRules[i]->m_wsPropName, wszName))
            return m_apPropRules[i];
    }
    return NULL;
}

//***************************************************************************
//
//***************************************************************************

CComplexProjectionSink::CComplexProjectionSink(CBasicObjectSink* pDest,
                        CWQLScanner * pParser)
        : CForwardingSink(pDest)
{
    m_TopRule.m_eType = CProjectionRule::e_TakePart;

    bool bFirstTableEntry = true;

    CWStringArray awsTables;
    pParser->GetReferencedAliases(awsTables);
    WString wsPrefix;
    if(awsTables.Size() == 0)
    {
        m_TopRule.m_eType = CProjectionRule::e_TakeAll;
        return;
    }
    else if(awsTables.Size() == 1)
    {
        wsPrefix = awsTables[0];
    }

    // Extract projection rules from the parser
    // ========================================

    const CFlexArray* papColumns = pParser->GetSelectedColumns();
    if(papColumns == NULL)
        return;

    for(int i = 0; i < papColumns->Size(); i++)
    {
        SWQLColRef* pColRef = (SWQLColRef*)papColumns->GetAt(i);
        if(pColRef->m_dwFlags & WQL_FLAG_ASTERISK)
        {
            m_TopRule.m_eType = CProjectionRule::e_TakeAll;
        }
        else
        {
            LPWSTR pPrefix = NULL;
            if(pColRef->m_dwFlags & WQL_FLAG_TABLE || pColRef->m_dwFlags & WQL_FLAG_ALIAS)
            {
                if(bFirstTableEntry)
                    if(pColRef->m_dwFlags & WQL_FLAG_ALIAS)
                    {
                        m_FirstTable = pParser->AliasToTable(pColRef->m_pTableRef);
                        m_FirstTableAlias = pColRef->m_pTableRef;
                    }
                    else
                        m_FirstTable = pColRef->m_pTableRef;

                pPrefix = pColRef->m_pTableRef;
                bFirstTableEntry = false;
            }
            else if(wsPrefix.Length())
                pPrefix = (LPWSTR)wsPrefix;
            AddColumn(pColRef->m_pQName->m_aFields, pPrefix);
        }
    }

    if(pParser->CountQuery())
    {
        // Add the rule for 'count'
        // ========================

        CProjectionRule* pCountRule = new CProjectionRule(L"count");
        if (pCountRule)
        {
	        pCountRule->m_eType = CProjectionRule::e_TakeAll;
    	    m_TopRule.m_apPropRules.Add(pCountRule);
        }
    }
};

//***************************************************************************
//
//***************************************************************************

void CComplexProjectionSink::AddColumn(CFlexArray& aFields, LPCWSTR wszPrefix)
{
    CProjectionRule* pCurrentRule = &m_TopRule;

    for(int i = 0; i < aFields.Size(); i++)
    {
        SWQLQualifiedNameField* pField = (SWQLQualifiedNameField*)aFields[i];

        if(!wcscmp(pField->m_pName, L"*"))
        {
            pCurrentRule->m_eType = CProjectionRule::e_TakeAll;
            return;
        }

        if(i == 0 && wszPrefix && !wbem_wcsicmp(pField->m_pName, wszPrefix) && aFields.Size() ==1)
        {
            // Skip this part because it is nothing more that a class name
            // in a single-class query
            // ===========================================================
            continue;
        }

        // Look this column up in the rule
        // ===============================

        CProjectionRule* pNewRule = pCurrentRule->Find(pField->m_pName);
        if(pNewRule == NULL)
        {
            pNewRule = new CProjectionRule(pField->m_pName);
            if (pNewRule)
            {
                pNewRule->m_eType = CProjectionRule::e_TakePart;
                pCurrentRule->m_apPropRules.Add(pNewRule);
            }
        }

        pCurrentRule = pNewRule; // possible assign to NULL
    }

    // Mark this rule as take-all
    // ==========================
    if (pCurrentRule)
        pCurrentRule->m_eType = CProjectionRule::e_TakeAll;
}

//***************************************************************************
//
//***************************************************************************

CComplexProjectionSink::~CComplexProjectionSink()
{
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CComplexProjectionSink::Indicate(long lObjectCount,
                                                IWbemClassObject** pObjArray)
{
    HRESULT hres;
    IWbemClassObject** apProjected = new IWbemClassObject*[lObjectCount];

    if (NULL == apProjected)
        return WBEM_E_OUT_OF_MEMORY;
    
    int i;
    for(i = 0; i < lObjectCount; i++)
    {
        hres = Project(pObjArray[i], &m_TopRule, apProjected + i);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_WBEMCORE, "Unable to perform a projection of an "
                "object returned by a complex query: 0x%X\n", hres));
            pObjArray[i]->Clone(apProjected + i);
        }
    }

    hres = CForwardingSink::Indicate(lObjectCount, apProjected);


    for(i = 0; i < lObjectCount; i++)
        apProjected[i]->Release();
    delete [] apProjected;

    return hres;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CComplexProjectionSink::Project(IWbemClassObject* pObj,
                                         CProjectionRule* pRule,
                                         IWbemClassObject** ppProj)
{
    // Make a copy
    // ===========

    pObj->Clone(ppProj);

    CWbemInstance* pProj = (CWbemInstance*)*ppProj;

    // Take care of the case where the object being returned is a product of a join, but is of single
    // class.  Ex; Select Site.sitenmame from Site, NotUsed.
    // This a a problem since we would normally expect a generic object as a result of a join and instead
    // get one of the objects that make up the join.

    CVar v;
    pProj->GetClassName(&v);
    bool Override = !wbem_wcsicmp(m_FirstTable, v.GetLPWSTR());
    if(Override && pRule->GetNumElements() == 1)
    {
        CProjectionRule* pNewRule = NULL;
        if(m_FirstTableAlias.Length())
            pNewRule = pRule->Find(m_FirstTableAlias);
        else
            pNewRule = pRule->Find(m_FirstTable);
        if(pNewRule)
            pRule = pNewRule;
    }

    // If take all, just return
    // ========================

    if(pRule->m_eType == CProjectionRule::e_TakeAll)
        return WBEM_S_NO_ERROR;


    // Go through all its properties
    // =============================

    for(int i = 0; i < pProj->GetNumProperties(); i++)
    {
        CVar vName;
        pProj->GetPropName(i, &vName);

        // Search for this name
        // ====================

        CProjectionRule* pPropRule = pRule->Find(vName.GetLPWSTR());

        if(pPropRule == NULL)
        {
            // Remove the property
            // ===================

            pProj->DeleteProperty(i);
            i--;
        }
        else if(pPropRule->m_eType == CProjectionRule::e_TakePart)
        {
            // Apply the same procedure
            // ========================

            CVar vValue;
            pProj->GetProperty(vName.GetLPWSTR(), &vValue);
            if(vValue.GetType() == VT_EMBEDDED_OBJECT)
            {
                // Project it
                // ==========

                IWbemClassObject* pEmb =
                    (IWbemClassObject*)vValue.GetEmbeddedObject();
                IWbemClassObject* pEmbProj;

                HRESULT hres = Project(pEmb, pPropRule, &pEmbProj);
                pEmb->Release();

                // Store it back
                // =============

                if(SUCCEEDED(hres))
                {
                    vValue.Empty();
                    vValue.SetEmbeddedObject(pEmbProj);
                    pProj->SetPropValue(vName.GetLPWSTR(), &vValue, 0);
                    pEmbProj->Release();
                }
            }
        }
    }

    pProj->CompactClass();
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//  CQueryEngine::ExecQuery
//
//  Primary entry point for execution of all queries supported by
//  the query engine.
//
//***************************************************************************
// ok

HRESULT CQueryEngine::ExecQuery(
    IN CWbemNamespace *pNs,
    IN LPWSTR pszQueryFormat,
    IN LPWSTR pszQuery,
    IN LONG lFlags,
    IN IWbemContext* pContext,
    IN CBasicObjectSink* pSink
    )
{
    try
    {
        if (ConfigMgr::ShutdownInProgress())
        {
            pSink->SetStatus(0, WBEM_E_SHUTTING_DOWN, 0, 0);
            return WBEM_E_SHUTTING_DOWN;
        }

        COperationError OpInfo(pSink, L"ExecQuery", pszQuery);

        // Check query language
        // ====================

        if(wbem_wcsicmp(pszQueryFormat, L"WQL") != 0)
        {
            return OpInfo.ErrorOccurred(WBEM_E_INVALID_QUERY_TYPE);
        }

        // If a prototype query is requested, get the synthesized
        // class definition.
        // ======================================================

        if (lFlags & WBEM_FLAG_PROTOTYPE)
        {
            HRESULT hRes = ExecPrototypeQuery(
                pNs,
                pszQuery,
                pContext,
                pSink
                );

            return hRes;
        }


        // Get the first token of the query to see if it is SQL1 or TEMPQL
        // ===============================================================

        WCHAR * wszBuffer = new WCHAR[wcslen(pszQuery)+1];
        wmilib::auto_buffer<WCHAR> dm_(wszBuffer);

        if ( NULL == wszBuffer )
        {
            return OpInfo.ErrorOccurred(WBEM_E_OUT_OF_MEMORY);
        }

        wcscpy(wszBuffer, pszQuery);
        WCHAR* pwcFirstTok = wcstok(wszBuffer, L" \t\n");
        if(pwcFirstTok == NULL)
        {
            return OpInfo.ErrorOccurred(WBEM_E_INVALID_QUERY);
        }

        BOOL bSelect = (wbem_wcsicmp(pwcFirstTok, L"select") == 0);
        BOOL bDelete = (wbem_wcsicmp(pwcFirstTok, L"delete") == 0);

        CBasicObjectSink *pNewSink = OpInfo.GetSink();

        if ( NULL == pNewSink )
        {
            return OpInfo.ErrorOccurred(WBEM_E_OUT_OF_MEMORY);
        }
        
        CLocaleMergingSink *pLocaleSink = NULL;
        if (lFlags & WBEM_FLAG_USE_AMENDED_QUALIFIERS)
        {
            pLocaleSink = new CLocaleMergingSink(pNewSink, pNs->GetLocale(), pNs->GetName());

            if ( NULL == pLocaleSink )
            {
                return OpInfo.ErrorOccurred(WBEM_E_OUT_OF_MEMORY);
            }

            pLocaleSink->AddRef();
            pNewSink = pLocaleSink;
        }

        CFinalizingSink* pFinalSink = new CFinalizingSink(pNs, pNewSink);

        if ( NULL == pFinalSink )
        {
            return OpInfo.ErrorOccurred(WBEM_E_OUT_OF_MEMORY);
        }

        pFinalSink->AddRef();

        if (bSelect)
        {
            ExecQlQuery(pNs, pszQuery, lFlags, pContext, pFinalSink);
        }
        else if (bDelete)
        {
            ExecRepositoryQuery(pNs, pszQuery, lFlags, pContext, pFinalSink);
        }
        else    // ASSOCIATORS OF or REFERENCES OF query
        {
            CAssocQuery *pAssocQuery = CAssocQuery::CreateInst();

            // If we didn't get one, then the heap is overheaped.
            // ==================================================
            if (!pAssocQuery)
                pFinalSink->Return(WBEM_E_OUT_OF_MEMORY);

            // Execute the query and see what happens.
            // The object AddRefs and Releases itself as required.
            // We only need to do a Release right after Execute.
            // ===================================================
            else
            {
                HRESULT hRes = pAssocQuery->Execute(pNs, pszQuery, pContext, pFinalSink);
                pAssocQuery->Release();
            }
        }

        if (pLocaleSink)
            pLocaleSink->Release();

        pFinalSink->Release();
    }
    catch (CX_Exception &)
    {
        pSink->SetStatus(0, WBEM_E_OUT_OF_MEMORY, 0, 0);
        return WBEM_E_OUT_OF_MEMORY;

    }
    catch (...) //:-(
    {
        ExceptionCounter c;    
        pSink->SetStatus(0, WBEM_E_CRITICAL_ERROR, 0, 0);
        return WBEM_E_CRITICAL_ERROR;
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CQueryEngine::ExecComplexQuery(
    IN CWbemNamespace *pNs,
    IN LPWSTR pszQuery,
    IN LONG lFlags,
    IN IWbemContext* pContext,
    IN CBasicObjectSink* pSink
    )
{
    // Try to parse it
    // ===============

    CTextLexSource src(pszQuery);
    CWQLScanner Parser(&src);
    int nRes = Parser.Parse();
    if(nRes != CWQLScanner::SUCCESS)
    {
        return WBEM_E_INVALID_QUERY;
    }

    // Successfully parsed. Go to the list of tables involved
    // ======================================================

    CWStringArray awsTables;
    Parser.GetReferencedTables(awsTables);

    // Go through them and check their providers
    // =========================================

    WString wsProvider;
    for(int i = 0; i < awsTables.Size(); i++)
    {
        // Get the class
        // =============

        IWbemClassObject* pObj = NULL;
        IWbemClassObject* pErrorObj = NULL;

        HRESULT hres = pNs->Exec_GetObjectByPath(awsTables[i], lFlags, pContext,
                            &pObj, &pErrorObj);
        if(FAILED(hres))
        {
            if(hres == WBEM_E_NOT_FOUND)
            {
                if(!wbem_wcsicmp(awsTables[i], L"meta_class"))
                    hres = WBEM_E_INVALID_QUERY;
                else
                    hres = WBEM_E_INVALID_CLASS;
            }

            if(pErrorObj)
                pErrorObj->Release();
            return hres;
        }

        if(pErrorObj)
            pErrorObj->Release();

        // Check the qualifier
        // ===================

        CWbemClass* pClass = (CWbemClass*)pObj;
        CVar vProvider;
        hres = pClass->GetQualifier(L"provider", &vProvider);
        pClass->Release();
        if(FAILED(hres) || vProvider.GetType() != VT_BSTR ||
            wcslen(vProvider.GetLPWSTR()) == 0)
        {
            // no provider --- can't execute
            // =============================

            return WBEM_E_INVALID_QUERY;
        }

        if(i == 0)
        {
            wsProvider = vProvider.GetLPWSTR();
        }
        else
        {
            if(!wsProvider.EqualNoCase(vProvider.GetLPWSTR()))
            {
                // mismatched providers!
                // =====================

                return WBEM_E_INVALID_QUERY;
            }
        }
    }

    // All the classes have the same provider: wsProvider
    // ==================================================


// PROVSS SMS HOOK:

    CComplexProjectionSink* pProjSink =
        new CComplexProjectionSink(pSink, &Parser);

    if (NULL == pProjSink)
        return WBEM_E_OUT_OF_MEMORY;
        
    pProjSink->AddRef();
    CReleaseMe rm1(pProjSink);

    // All the classes have the same provider: wsProvider
    // ==================================================


	HRESULT hRes = pNs->DynAux_ExecQueryExtendedAsync (

		wsProvider,
		pszQuery,
		L"WQL" ,
		lFlags,
		pContext,
		pProjSink
    ) ;

    return hRes ;

/*
    return WBEM_E_NOT_AVAILABLE;

    if(ConfigMgr::GetProviderCache()->DoesProviderSupportExtentions(
        pNs, wsProvider, pContext))
    {

        // PROVSS : SMS hook

        //ConfigMgr::GetProviderCache()->ExecComplexQueryAsync(pNs,
        //    wsProvider, L"WQL", pszQuery, lFlags, pContext, pProjSink);
        //return WBEM_S_NO_ERROR;
        return WBEM_E_NOT_AVAILABLE;
    }
    else return WBEM_E_INVALID_QUERY;
*/

}

//***************************************************************************
//
//  CQueryEngine::ExecQlQuery
//
//***************************************************************************
// error objects dealt with

HRESULT CQueryEngine::ExecQlQuery(
    IN CWbemNamespace *pNs,
    IN LPWSTR pszQuery,
    IN LONG lFlags,
    IN IWbemContext* pContext,
    IN CBasicObjectSink* pSink
    )
{
    HRESULT hRes;
    BOOL bDirectQuery = FALSE;

    BOOL bShallow = (lFlags & WBEM_FLAG_SHALLOW);

    // First, try to push it off to providers, like SMS
    // that can handle the query it its entirety.
    // ================================================

    if(!bShallow)
    {
        hRes = ExecComplexQuery(pNs, pszQuery, lFlags, pContext, pSink);
        if(SUCCEEDED(hRes))
            return hRes;
    }

    // Parse the query.
    // ================

    CTextLexSource src(pszQuery);
    QL1_Parser parser(&src);
    QL_LEVEL_1_RPN_EXPRESSION *pExp = 0;
    int nRes = parser.Parse(&pExp);
	if (nRes || !pExp)
	{
		delete pExp;
        return pSink->Return(WBEM_E_INVALID_QUERY);
	}
    pExp->AddRef();
	CTemplateReleaseMe<QL_LEVEL_1_RPN_EXPRESSION> trm99(pExp);

    // Check if the repository for this namespace
    // supports queries.  If so, we can pawn off
    // the entire query on it (with the exception
    // of provider-backed subclasses)
    // ===========================================

    bDirectQuery = pNs->GetNsSession()->SupportsQueries(NULL) == WBEM_S_NO_ERROR ? TRUE : FALSE;

    if (!bDirectQuery)
    {
        // Check for failure, or that pExp->bAggregated is TRUE, in which
        // case we got a "GROUP BY" query which we do not support
        if ( nRes || !pExp || pExp->bAggregated || !pExp->bsClassName )
        {
            return pSink->Return(WBEM_E_INVALID_QUERY);
        }
    }
    else
    {
        // This is strictly to allow order by clauses to squeak through,
        // until we replace this parser with IWbemQuery.

        if (!pExp || !pExp->bsClassName || pExp->bAggregated)
        {
            return pSink->Return(WBEM_E_INVALID_QUERY);
        }
    }

    // We should make a check to see if we are doing a schema search.  This is
    // the case if we are doing a select against the "meta_class" class.
    // =======================================================================
    if (wbem_wcsicmp(pExp->bsClassName, L"meta_class") == 0)
    {
        if(pExp->nNumberOfProperties > 0 || !pExp->bStar)
        {
            return pSink->Return(WBEM_E_INVALID_QUERY);
        }
        HRESULT hRes = ExecSchemaQuery(pNs, pszQuery, pExp, pContext, pSink);
        return hRes;
    }

    // Build the dynasty
    // =================

    CDynasty *pDynasty = 0;
    IWbemClassObject* pErrorObj = NULL;
    HRESULT hres = pNs->DynAux_BuildClassHierarchy(pExp->bsClassName,
        0, // removed the flags
        pContext, &pDynasty, &pErrorObj);
    if (FAILED(hres))
    {
        CReleaseMe rm1(pErrorObj);
        if(hres == WBEM_E_NOT_FOUND || hres == WBEM_E_INVALID_CLASS)
            return pSink->Return(WBEM_E_INVALID_CLASS, pErrorObj);
        else
            return pSink->Return(WBEM_E_INVALID_QUERY, pErrorObj);
    }
	CDeleteMe<CDynasty> cdm99(pDynasty);

    // Construct a post-filtering (if needed) and projecting sink
    // ==========================================================

    IWbemClassObject* pClass = NULL;
    if (!pExp->bCount)
    {
        hres = pNs->Exec_GetObjectByPath(pExp->bsClassName, lFlags, pContext, &pClass, NULL);
        if(FAILED(hres))
        {
            return pSink->Return(WBEM_E_INVALID_CLASS);
        }
    }
    else
    {
        if (bDirectQuery)
        {
            hres = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER,
                    IID_IWbemClassObject, (void **)&pClass);
            if (SUCCEEDED(hres))
            {
                BSTR bstrName = SysAllocString(L"__Generic");
                if (bstrName)
                {            
	                VARIANT vTemp;
	                VariantInit(&vTemp);
	                vTemp.bstrVal = bstrName;
	                vTemp.vt = VT_BSTR;
	                pClass->Put(L"__Class", 0, &vTemp, CIM_STRING);
	                VariantClear(&vTemp);
	                pClass->Put(L"Count", 0, NULL, CIM_UINT32);
                }
                else
                {
                    return pSink->Return(WBEM_E_OUT_OF_MEMORY);
                }
            }
            else
            {
                return pSink->Return(WBEM_E_OUT_OF_MEMORY);
            }
        }
        else
        {
            return pSink->Return(WBEM_E_NOT_SUPPORTED);
        }
    }

    CReleaseMe rm1(pClass);

    CBasicObjectSink* pPreFilterSink = NULL;

    if(lFlags & WBEM_FLAG_KEEP_SHAPE)
    {
        //
        // We must not project the results, otherwise we will destroy the shape
        // of the instance.  Remove the flag, though, lest we confuse providers
        //

        lFlags &= ~WBEM_FLAG_KEEP_SHAPE;
        pPreFilterSink = pSink;
    }
    else
    {
        CProjectingSink* pProjectingSink =
            new CProjectingSink(pSink, (CWbemClass*)pClass, pExp, lFlags);

        if (NULL == pProjectingSink)
            return pSink->Return(WBEM_E_OUT_OF_MEMORY);

        if(!pProjectingSink->IsValid())
        {
            delete pProjectingSink;
            return pSink->Return(WBEM_E_INVALID_QUERY);
        }
        pPreFilterSink = pProjectingSink;
    }

    CQlFilteringSink* pFilteringSink =
        new CQlFilteringSink(pPreFilterSink, pExp, pNs, TRUE);

    if (NULL == pFilteringSink)
        return pSink->Return(WBEM_E_OUT_OF_MEMORY);

    // If shallow, force post-filtering
    // ================================

    if(bShallow)
        pFilteringSink->SetStatus(WBEM_STATUS_REQUIREMENTS, S_OK, NULL, NULL);

    CCombiningSink* pCombiningSink =
        new CCombiningSink(pFilteringSink, WBEM_E_NOT_FOUND);

    if (NULL == pCombiningSink)
        return pSink->Return(WBEM_E_OUT_OF_MEMORY);

    CDynPropsSink * pDynSink = new CDynPropsSink(pCombiningSink, pNs);

    if (NULL == pDynSink)
        return pSink->Return(WBEM_E_OUT_OF_MEMORY);
    
    pDynSink->AddRef();
	CReleaseMe rm99(pDynSink);

    // We simplify the query if our repository ain't too bright.
    // Otherwise, it will reject count queries.
    // Again, temporary until we get IWbemQuery plugged in.

    if (!bDirectQuery)
    {
        // "Simplify" the query (TBD: think about doing it at each level)
        // ==============================================================

        QL_LEVEL_1_RPN_EXPRESSION* pSimpleExp = NULL;
        CStandardMetaData* pRawMeta = new CStandardMetaData(pNs);
        if (NULL == pRawMeta)
        {
            pDynSink->Return(WBEM_E_OUT_OF_MEMORY);
            return WBEM_S_NO_ERROR;        
        }
            
        CContextMetaData* pMeta = new CContextMetaData(pRawMeta, pContext);
        if (NULL == pMeta)
        {
            delete pRawMeta;
            pDynSink->Return(WBEM_E_OUT_OF_MEMORY);
            return WBEM_S_NO_ERROR;        
        }
        

        hres = CQueryAnalyser::SimplifyQueryForChild(pExp,
                pExp->bsClassName, (CWbemClass*)pClass, pMeta, pSimpleExp);
        delete pMeta;

        if(FAILED(hres))
        {
            pDynSink->Return(WBEM_E_INVALID_QUERY);
            return WBEM_S_NO_ERROR;
        }

        if(pSimpleExp == NULL)
        {
            // Query violated intergrity constraint
            // ====================================

            pDynSink->Return(WBEM_S_NO_ERROR); // ?? WBEM_S_IMPOSSIBLE
            return WBEM_S_NO_ERROR;
        }

        // Substitute the simplified where clause into the query
        // =====================================================

        delete [] pExp->pArrayOfTokens;
        pExp->pArrayOfTokens = pSimpleExp->pArrayOfTokens;
        pExp->nNumTokens = pSimpleExp->nNumTokens;
        pSimpleExp->pArrayOfTokens = NULL;
        delete pSimpleExp;
    }

    // Now make a final pass to make sure this query is valid
    // ======================================================

    hres = ValidateQuery(pExp, (CWbemClass *)pClass);
    if (FAILED(hres))
    {
        pDynSink->Return(hres);
        return WBEM_S_NO_ERROR;
    }

    LPWSTR pszNewQuery = NULL;

    // Preserve the original query if
    // it contains count, order by
    // (or other unparsable stuff)

    if (pExp->bCount || nRes)
        pszNewQuery = Macro_CloneLPWSTR(pszQuery);
    else
        pszNewQuery = pExp->GetText();
	if (NULL == pszNewQuery)
	{
        pDynSink->Return(WBEM_E_OUT_OF_MEMORY);
		return WBEM_S_NO_ERROR;
	}
	CVectorDeleteMe<wchar_t> cdm98(pszNewQuery);

    // If direct access was requested, then don't walk
    // the dynasty. Go right to the repository or the provider.
    // ========================================================

    if (lFlags & WBEM_FLAG_DIRECT_READ)
    {
        DirectRead(pNs, pDynasty, pszNewQuery, pExp, pContext,
            pDynSink, lFlags & ~WBEM_FLAG_ENSURE_LOCATABLE
            );
    }

    // Recursively execute for all classes in the dynasty
    // ==================================================

    else
    {
		BOOL	fUseOld = !ConfigMgr::GetMergerThrottlingEnabled();
		// Check the Registry

#ifdef __DEBUG_MERGER_THROTTLING
		// Allows us to quickly swap back and forth between new merger and the old one.
		// for testing purposes
		DWORD dwVal = 0;
		Registry rCIMOM(WBEM_REG_WINMGMT);
		if (rCIMOM.GetDWORDStr( L"DebugMerger", &dwVal ) == Registry::no_error)
		{

			fUseOld = !dwVal;
		}
#endif

		if ( fUseOld )
		{
			EvaluateSubQuery(
				pNs, pDynasty, pszNewQuery, pExp, pContext, FALSE,
				pDynSink, lFlags & ~WBEM_FLAG_ENSURE_LOCATABLE
				);
		}
		else
		{

			// Allocate a new merger and pass it down the line
			CWmiMerger*	pMerger = new CWmiMerger( pNs );

			if ( NULL != pMerger )
			{
				pMerger->AddRef();
				CReleaseMe	rmMerger( (_IWmiArbitratee*) pMerger );

				CMergerSink*	pDestSink = NULL;

				// Task handle will be available if we have an executing request,
				// if not, don't worry about it right now.  Nobody's really able
				// to give a straight answer on this, so we will simply add an assert
				// if a merger is created and no task handle is associated with the
				// main merger.

				_IWmiCoreHandle*	pTask = NULL;
				_IWmiArbitrator*	pArbitrator = CWmiArbitrator::GetRefedArbitrator();
				CWbemRequest*		pReq = CWbemQueue::GetCurrentRequest();

				if ( NULL != pReq )
				{
					pTask = pReq->m_phTask;
				}

				HRESULT	hr = WBEM_E_CRITICAL_ERROR;
				if (pArbitrator)
					hr = WBEM_S_NO_ERROR;
				CReleaseMe	rmArb( pArbitrator );

				if ( SUCCEEDED( hr ) )
				{
						
					hr = pMerger->Initialize( pArbitrator, pTask, pExp->bsClassName, pDynSink, &pDestSink );
					CReleaseMe	rm( pDestSink );

					if ( SUCCEEDED( hr ) )
					{
						// If something goes wrong in this function, it will set the
						// error in the sink
						hr = EvaluateSubQuery(
								pNs, pDynasty, pszNewQuery, pExp, pContext, FALSE,
								pMerger, pDestSink, lFlags & ~WBEM_FLAG_ENSURE_LOCATABLE
								);

						if ( SUCCEEDED( hr ) )
						{
							// Schedule a parent request if appropriate
							hr = pMerger->ScheduleMergerParentRequest( pContext );

							if ( FAILED( hr ) )
							{
								return pDestSink->Return( hr );
							}

						}	// IF EvaluateSubQuery
					}
					else
					{
						pDynSink->Return( hr );
						return hr;
					}

				}
				else
				{
					pDynSink->Return( hr );
					return hr;
				}
			}
			else
			{
				pDynSink->Return( WBEM_E_OUT_OF_MEMORY );
				return WBEM_E_OUT_OF_MEMORY;
			}

		}

    }

    return hres;
}

//***************************************************************************
//
//  CQueryEngine::DirectRead
//
//  Called to directly read the instances of a class, whether
//  from the repository or a provider.
//
//***************************************************************************

HRESULT CQueryEngine::DirectRead(
    IN CWbemNamespace *pNs,
    IN CDynasty *pCurrentDyn,
    IN LPWSTR wszTextQuery,
    IN QL_LEVEL_1_RPN_EXPRESSION *pParsedQuery,
    IN IWbemContext* pContext,
    IN CBasicObjectSink* pSink,
    IN long lFlags
    )
{
    // SJS - Amendment is the same as Abstract
    if( ( pCurrentDyn->IsAbstract() || pCurrentDyn->IsAmendment() ) && (lFlags & WBEM_FLAG_SHALLOW))
    {
        // No instances
        // ============

        return pSink->Return(WBEM_S_NO_ERROR);
    }

    // The class has its own instances if it has a key and is either dynamic
    // or the first static class in the inheritance chain (otherwise these
    // instances have been handled in the parent)
    // =====================================================================

    BOOL bHasOwnInstances = pCurrentDyn->IsKeyed() && !pCurrentDyn->IsAbstract()
        && !pCurrentDyn->IsAmendment();

    // The class has children that we need to look at if it has children.
    // ==================================================================

    BOOL bHasChildren = pCurrentDyn->m_pChildren &&
        (pCurrentDyn->m_pChildren->Size() > 0);

    // Determine if the current query actually asks for instances of the
    // current CDynasty class.  This is used for WBEM_FLAG_DIRECT_READ type
    // access.
    // =======================================================================

    BOOL bQueryMatchesCurrentNode = FALSE;
    if (_wcsicmp(pParsedQuery->bsClassName, pCurrentDyn->m_wszClassName) == 0)
        bQueryMatchesCurrentNode = TRUE;

    // If we are at the node we need, we can stop.
    // ===========================================

    if (bHasOwnInstances && bQueryMatchesCurrentNode)
    {
        // If a provider backs this class, then call it.
        // ==============================================

        if (pCurrentDyn->IsDynamic())
        {
            ExecAtomicDynQlQuery(
                    pNs,
                    pCurrentDyn,
                    L"WQL",
                    wszTextQuery,
                    pParsedQuery,
                    lFlags,                                      // Flags
                    pContext,
                    pSink,
					FALSE 
                    );
        }
        // Try the repository.
        // ===================
        else
        {
            int nRes = ExecAtomicDbQuery(pNs->GetNsSession(), pNs->GetNsHandle(), pNs->GetScope(), pCurrentDyn->m_wszClassName,
                        pParsedQuery, pSink, pNs
                        );

            if (nRes == invalid_query)
                pSink->Return(WBEM_E_INVALID_QUERY);
            else if(nRes != 0)
                pSink->Return(WBEM_E_FAILED);
            else
                pSink->Return(WBEM_S_NO_ERROR);
        }
    }

    // If here, we must keep looking for the target in the child classes.
    // ==================================================================

    else if (bHasChildren)
    {
        for (int i = 0; i < pCurrentDyn->m_pChildren->Size(); i++)
        {
            CDynasty *pSubDyn =
                (CDynasty *) pCurrentDyn->m_pChildren->GetAt(i);

            DirectRead(
                pNs,
                pSubDyn,
                wszTextQuery,
                pParsedQuery,
                pContext,
                pSink,
                lFlags
                );
        }
    }

    return WBEM_S_NO_ERROR;
}

// New implementation

//***************************************************************************
//
//  CQueryEngine::EvaluateSubQuery
//
//  Walks through a class hierarchy and executes smaller queries against
//  the individual classes in the dynasty.
//
//  Note that in a class hierarchy A,B:A,C:B, an enumeration/query is
//  performed only against the classes in the CDynasty referenced in
//  the query. For example, if "select * from B" is the query, only queries
//  for B and C are performed.  The CMerger logic will do individual
//  'get object' calls for any instances needed in A to complete
//  the merged B/C instances while merging is taking place.
//
//  Return values:
//  WBEM_NO_ERROR
//  WBEM_E_FAILED
//
//***************************************************************************
// error objects dealt with

HRESULT CQueryEngine::EvaluateSubQuery(
    IN CWbemNamespace *pNs,
    IN CDynasty *pCurrentDyn,
    IN LPWSTR wszTextQuery,
    IN QL_LEVEL_1_RPN_EXPRESSION *pParsedQuery,
    IN IWbemContext* pContext,
    IN BOOL bSuppressStaticChild,
    IN CWmiMerger* pMerger, // must have combining semantics
	IN CMergerSink* pSink,
    IN long lFlags,
	IN bool bHasRightSibling
)
{
    // SJS - Amendment is the same as Abstract
    if( ( pCurrentDyn->IsAbstract() || pCurrentDyn->IsAmendment() ) && (lFlags & WBEM_FLAG_SHALLOW))
    {
        // No instances
        // ============

        pSink->SetStatus( 0L, WBEM_S_NO_ERROR, 0L, NULL);
		return WBEM_S_NO_ERROR;
    }

    // The class has its own instances if it has a key and is either dynamic
    // or the first static class in the inheritance chain (otherwise these
    // instances have been handled in the parent)
    // =====================================================================

    BOOL bHasOwnInstances = pCurrentDyn->IsKeyed() && !pCurrentDyn->IsAbstract()
        && !pCurrentDyn->IsAmendment() && (pCurrentDyn->IsDynamic() || !bSuppressStaticChild);

    // The class has children that we need to look at if it has children.
    // ==================================================================

    BOOL bHasChildren = pCurrentDyn->m_pChildren &&
        (pCurrentDyn->m_pChildren->Size() > 0);

    // The class hierarchy was built down from the class of the query, as
    // well as up the inheritance chain, since parents may need to be used to
    // build complete instances. However, parents are treated very different
    // then classes derived from the class of the query (see below)
    // ======================================================================

    BOOL bDerivedFromTarget = (pCurrentDyn->m_pClassObj->InheritsFrom(
        pParsedQuery->bsClassName) == S_OK);


    // Next, see if the query is executing out of a scope or the primary
    // namespace.  We exclude providers if the query is executing from
    // a scope.
    // ==================================================================

    BOOL bInScope = pNs->IsSubscope();

    // Now we have enough info to start getting the instances.
    // =======================================================

    CMergerSink* pOwnSink = NULL;
	CMergerSink* pChildSink = NULL;

	HRESULT	hr = pMerger->RegisterSinkForClass( pCurrentDyn->m_wszClassName, (_IWmiObject*) pCurrentDyn->m_pClassObj, pContext,
											  bHasChildren, bHasOwnInstances, bDerivedFromTarget,
											  !pCurrentDyn->IsDynamic(), pSink, &pOwnSink, &pChildSink );
	CReleaseMe	rm1( pOwnSink );
	CReleaseMe	rm2( pChildSink );

	if ( FAILED(hr) )
	{
		pSink->SetStatus( 0L, hr, 0L, NULL );
		return hr;
	}

    if(bHasOwnInstances)
    {
	    if(bHasChildren)
        {
            // In order for the merge to succeed, we need to make sure that all
            // keys are provided, whether or not we are asked for them
            // ================================================================

            if(!pParsedQuery->bStar)
            {
                CPropertyName Name;
                Name.AddElement(L"__RELPATH");
                pParsedQuery->AddProperty(Name);
            }

            // We need to figure out what to ask of the provider. If the
            // provider is "downstream" from the original query, i.e. the query
            // was asked against a class that is an ancestor of this one or is
            // this one, we are fine --- this provider must understand the
            // query. If not, we don't ask any query, just wait and then call
            // GetObjectByPath.
            // ================================================================

            //pMerger->SetIsDerivedFromTarget(bDerivedFromTarget);
        }
    }
    else if(!bHasChildren)
    {
        // No instances or children
        // ============

        pSink->SetStatus( 0L, WBEM_S_NO_ERROR, 0L, NULL );
		return WBEM_S_NO_ERROR;
    }

    // If this is an old security class, use the internal provider.
    // ====================================================================

    if((wbem_wcsicmp(pCurrentDyn->m_wszClassName, L"__ntlmgroup") == 0 ||
        wbem_wcsicmp(pCurrentDyn->m_wszClassName, L"__ntlmuser") == 0) &&
        (lFlags & WBEM_FLAG_ONLY_STATIC) == 0)
    {
            HRESULT hres = pNs->EnumerateSecurityClassInstances(pCurrentDyn->m_wszClassName,
                    pOwnSink, pContext, lFlags);
            pOwnSink->SetStatus( 0L, hres, 0L, NULL );
    }
    // If the current subclass is the first keyed statically instanced subclass.
    // =========================================================================
    else if (bHasOwnInstances && !pCurrentDyn->IsDynamic())
    {
        // Execute the query against the static portion of the database.
        // =============================================================

        int nRes = 0;

        if (pNs->GetNsSession()->SupportsQueries(NULL) == WBEM_S_NO_ERROR)
        {
            // The underlying repository automatically handles inheritance.

            if (!bSuppressStaticChild)
                nRes = ExecRepositoryQuery(pNs, wszTextQuery, lFlags, pContext, pSink);

			if (nRes == invalid_query)
				pOwnSink->SetStatus( 0L, WBEM_E_INVALID_QUERY, 0L, NULL );
			else if(nRes != 0)
				pOwnSink->SetStatus( 0L, WBEM_E_FAILED, 0L, NULL );
			else
				pOwnSink->SetStatus( 0L, WBEM_S_NO_ERROR, 0L, NULL );


        }
        else
        {
			hr = pNs->Static_QueryRepository( (CWbemObject *) pCurrentDyn->m_pClassObj, 
					0L, pContext, pOwnSink, pParsedQuery, pCurrentDyn->m_wszClassName,
					pMerger );
        }

    }
    else if (bHasOwnInstances && pCurrentDyn->IsDynamic() && !bInScope)
    {
        if (bDerivedFromTarget)
        {
            // Ask the provider.
            // =================

            ExecAtomicDynQlQuery(

				pNs,
				pCurrentDyn,
				L"WQL",
				wszTextQuery,
				pParsedQuery,
				lFlags,                                      // Flags
				pContext,
				pOwnSink,
				bHasChildren || bHasRightSibling
            );
        }
        else
        {
            pOwnSink->SetStatus( 0L, WBEM_S_NO_ERROR, 0L, NULL );
        }
    }

	// Manually release pOwnSink if appropriate - use the method on CReleaseMe() so
	// as not to interfere with the auto-release functionality.  We should do
	// this here so as to relinquish any unnecessary locks we may be holding on data
	// and/or results before we start spinning off child requests - it's all about
	// throughput boyo!
    if(pOwnSink)
        rm1.release();

    // If the current subclass is the first keyed statically instanced subclass.
    // =========================================================================

    if (bHasOwnInstances && !pCurrentDyn->IsDynamic())
    {
        bSuppressStaticChild = TRUE;
    }

    // Evaluate child classes.
    // =======================

    if (bHasChildren)
    {
        for (int i = 0; i < pCurrentDyn->m_pChildren->Size(); i++)
        {
            CDynasty *pSubDyn = (CDynasty *) pCurrentDyn->m_pChildren->GetAt(i);

            EvaluateSubQuery (

                pNs,
                pSubDyn,
                wszTextQuery,
                pParsedQuery,
                pContext,
                bSuppressStaticChild,
                pMerger,
				pChildSink,
                lFlags,
				bHasRightSibling || ( ( i != ( pCurrentDyn->m_pChildren->Size () - 1 )) ? true : false )
			) ;
        }
    }

    return WBEM_S_NO_ERROR;
}

// Old implementation

//***************************************************************************
//
//  CQueryEngine::EvaluateSubQuery
//
//  Walks through a class hierarchy and executes smaller queries against
//  the individual classes in the dynasty.
//
//  Note that in a class hierarchy A,B:A,C:B, an enumeration/query is
//  performed only against the classes in the CDynasty referenced in
//  the query. For example, if "select * from B" is the query, only queries
//  for B and C are performed.  The CMerger logic will do individual
//  'get object' calls for any instances needed in A to complete
//  the merged B/C instances while merging is taking place.
//
//  Return values:
//  WBEM_NO_ERROR
//  WBEM_E_FAILED
//
//***************************************************************************
// error objects dealt with

HRESULT CQueryEngine::EvaluateSubQuery(
    IN CWbemNamespace *pNs,
    IN CDynasty *pCurrentDyn,
    IN LPWSTR wszTextQuery,
    IN QL_LEVEL_1_RPN_EXPRESSION *pParsedQuery,
    IN IWbemContext* pContext,
    IN BOOL bSuppressStaticChild,
    IN CBasicObjectSink* pSink, // must have combining semantics
    IN long lFlags,
	IN bool bHasRightSibling
)
{
    // SJS - Amendment is the same as Abstract
    if( ( pCurrentDyn->IsAbstract() || pCurrentDyn->IsAmendment() ) && (lFlags & WBEM_FLAG_SHALLOW))
    {
        // No instances
        // ============

        return pSink->Return(WBEM_S_NO_ERROR);
    }

    // The class has its own instances if it has a key and is either dynamic
    // or the first static class in the inheritance chain (otherwise these
    // instances have been handled in the parent)
    // =====================================================================

    BOOL bHasOwnInstances = pCurrentDyn->IsKeyed() && !pCurrentDyn->IsAbstract()
        && !pCurrentDyn->IsAmendment() && (pCurrentDyn->IsDynamic() || !bSuppressStaticChild);

    // The class has children that we need to look at if it has children.
    // ==================================================================

    BOOL bHasChildren = pCurrentDyn->m_pChildren &&
        (pCurrentDyn->m_pChildren->Size() > 0);

    // The class hierarchy was built down from the class of the query, as
    // well as up the inheritance chain, since parents may need to be used to
    // build complete instances. However, parents are treated very different
    // then classes derived from the class of the query (see below)
    // ======================================================================

    BOOL bDerivedFromTarget = (pCurrentDyn->m_pClassObj->InheritsFrom(
        pParsedQuery->bsClassName) == S_OK);


    // Next, see if the query is executing out of a scope or the primary
    // namespace.  We exclude providers if the query is executing from
    // a scope.
    // ==================================================================

    BOOL bInScope = pNs->IsSubscope();

    // Now we have enough info to start getting the instances.
    // =======================================================

    CBasicObjectSink* pChildSink = NULL;
    CBasicObjectSink* pOwnSink = NULL;

    if(bHasOwnInstances)
    {
	        if(bHasChildren)
        {
            // Has instances and children have instances
            // =========================================

            CMerger* pMerger = new CMerger(pSink,
                (CWbemClass*)pCurrentDyn->m_pClassObj, pNs, pContext);
            if (pMerger && pMerger->IsValid())
            {
                pOwnSink = pMerger->GetOwnSink();
                pOwnSink->AddRef();
                pChildSink = pMerger->GetChildSink();
                pChildSink->AddRef();

                // In order for the merge to succeed, we need to make sure that all
                // keys are provided, whether or not we are asked for them
                // ================================================================

                if(!pParsedQuery->bStar)
                {
                    CPropertyName Name;
                    Name.AddElement(L"__RELPATH");
                    pParsedQuery->AddProperty(Name);
                }

                // We need to figure out what to ask of the provider. If the
                // provider is "downstream" from the original query, i.e. the query
                // was asked against a class that is an ancestor of this one or is
                // this one, we are fine --- this provider must understand the
                // query. If not, we don't ask any query, just wait and then call
                // GetObjectByPath.
                // ================================================================

                pMerger->SetIsDerivedFromTarget(bDerivedFromTarget);
            }
            else
            {
                return pSink->Return(WBEM_E_OUT_OF_MEMORY);
            }
        }
        else
        {
            // No children --- own instances are it
            // ====================================

            pOwnSink = pSink;
            pSink->AddRef();
        }
    }
    else if(bHasChildren)
    {
        // Our children are it
        // ===================

        pChildSink = pSink;
        pSink->AddRef();
    }
    else
    {
        // No instances
        // ============

        return pSink->Return(WBEM_S_NO_ERROR);
    }

    // If this is an old security class, use the internal provider.
    // ====================================================================

    if((wbem_wcsicmp(pCurrentDyn->m_wszClassName, L"__ntlmgroup") == 0 ||
        wbem_wcsicmp(pCurrentDyn->m_wszClassName, L"__ntlmuser") == 0) &&
        (lFlags & WBEM_FLAG_ONLY_STATIC) == 0)
    {
            HRESULT hres = pNs->EnumerateSecurityClassInstances(pCurrentDyn->m_wszClassName,
                    pOwnSink, pContext, lFlags);
            pOwnSink->Return(hres);
    }
    // If the current subclass is the first keyed statically instanced subclass.
    // =========================================================================
    else if (bHasOwnInstances && !pCurrentDyn->IsDynamic())
    {
        // Execute the query against the static portion of the database.
        // =============================================================

        int nRes = 0;

        if (pNs->GetNsSession()->SupportsQueries(NULL) == WBEM_S_NO_ERROR)
        {
            // The underlying repository automatically handles inheritance.

            if (!bSuppressStaticChild)
                nRes = ExecRepositoryQuery(pNs, wszTextQuery, lFlags, pContext, pSink);
        }
        else
        {
            nRes = ExecAtomicDbQuery(pNs->GetNsSession(), pNs->GetNsHandle(), pNs->GetScope(), pCurrentDyn->m_wszClassName,
                        pParsedQuery, pOwnSink, pNs);
        }

        if (nRes == invalid_query)
            pOwnSink->Return(WBEM_E_INVALID_QUERY);
        else if(nRes != 0)
            pOwnSink->Return(WBEM_E_FAILED);
        else
            pOwnSink->Return(WBEM_S_NO_ERROR);

    }
    else if (bHasOwnInstances && pCurrentDyn->IsDynamic() && !bInScope)
    {
        if (bDerivedFromTarget)
        {
            // Ask the provider.
            // =================

            ExecAtomicDynQlQuery(

				pNs,
				pCurrentDyn,
				L"WQL",
				wszTextQuery,
				pParsedQuery,
				lFlags,                                      // Flags
				pContext,
				pOwnSink,
				bHasChildren || bHasRightSibling
            );
        }
        else
        {
            pOwnSink->Return(WBEM_S_NO_ERROR);
        }
    }

    if(pOwnSink)
        pOwnSink->Release();

    // If the current subclass is the first keyed statically instanced subclass.
    // =========================================================================

    if (bHasOwnInstances && !pCurrentDyn->IsDynamic())
    {
        bSuppressStaticChild = TRUE;
    }

    // Evaluate child classes.
    // =======================

    if (bHasChildren)
    {
        for (int i = 0; i < pCurrentDyn->m_pChildren->Size(); i++)
        {
            CDynasty *pSubDyn = (CDynasty *) pCurrentDyn->m_pChildren->GetAt(i);

            EvaluateSubQuery (

                pNs,
                pSubDyn,
                wszTextQuery,
                pParsedQuery,
                pContext,
                bSuppressStaticChild,
                pChildSink,
                lFlags,
				bHasRightSibling || ( ( i != ( pCurrentDyn->m_pChildren->Size () - 1 )) ? true : false )
			) ;
        }
    }

    if(pChildSink)
        pChildSink->Release();

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CQueryEngine::EliminateDerivedProperties(
                            IN  QL_LEVEL_1_RPN_EXPRESSION* pOrigQuery,
                            IN  CWbemClass* pClass,
                            IN  BOOL bRelax,
                            OUT QL_LEVEL_1_RPN_EXPRESSION** ppNewQuery)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Set up the new query to talk about this class
    // =============================================

    CVar vClassName;
    hres = pClass->GetClassName(&vClassName);
    if (FAILED(hres))
    	return hres;
    
    (*ppNewQuery)->bsClassName = SysAllocString(vClassName.GetLPWSTR());

    if (0==(*ppNewQuery)->bsClassName)
    	return WBEM_E_OUT_OF_MEMORY;
    	
    	

    if(pOrigQuery->nNumTokens == 0)
    {
        *ppNewQuery = new QL_LEVEL_1_RPN_EXPRESSION;
        if (*ppNewQuery)
            return WBEM_S_NO_ERROR;
        else
            return WBEM_E_OUT_OF_MEMORY;
    }

    // Set up a stack of expressions
    // =============================

    std::stack<QL_LEVEL_1_RPN_EXPRESSION*, deque <QL_LEVEL_1_RPN_EXPRESSION*, wbem_allocator<QL_LEVEL_1_RPN_EXPRESSION*> > > ExprStack;

    // Recursively "evaluate" the original query
    // =========================================

    for(int i = 0; i < pOrigQuery->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN& Token = pOrigQuery->pArrayOfTokens[i];
        QL_LEVEL_1_RPN_EXPRESSION* pNew = NULL;
        QL_LEVEL_1_RPN_EXPRESSION* pFirst = NULL;
        QL_LEVEL_1_RPN_EXPRESSION* pSecond = NULL;

        switch(Token.nTokenType)
        {
        case QL1_OP_EXPRESSION:
            if(IsTokenAboutClass(Token, pClass))
            {
                QL_LEVEL_1_RPN_EXPRESSION* pNew = new QL_LEVEL_1_RPN_EXPRESSION;
                if (pNew)
                    pNew->AddToken(Token);
                else
                {
                    // force exit
                    i = pOrigQuery->nNumTokens;
                }
            }
            else
            {
                if(bRelax)
                {
                    QL_LEVEL_1_RPN_EXPRESSION* pNew =
                        new QL_LEVEL_1_RPN_EXPRESSION;
                    if (pNew)
                        ExprStack.push(pNew);
                    else
                    {
                        // force exit
                        i = pOrigQuery->nNumTokens;
                    }
                }
                else
                {
                    ExprStack.push(NULL);
                }
            }
            break;

        case QL1_AND:
            if(ExprStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();
            pSecond = ExprStack.top(); ExprStack.pop();

            hres = AndQueryExpressions(pFirst, pSecond, &pNew);

            ExprStack.push(pNew);
            delete pFirst;
            delete pSecond;
            break;

        case QL1_OR:
            if(ExprStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();
            pSecond = ExprStack.top(); ExprStack.pop();

            hres = OrQueryExpressions(pFirst, pSecond, &pNew);

            ExprStack.push(pNew);
            delete pFirst;
            delete pSecond;
            break;

        case QL1_NOT:
            if(ExprStack.size() < 1)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();

            if(bRelax)
            {
                QL_LEVEL_1_RPN_EXPRESSION* pNew = new QL_LEVEL_1_RPN_EXPRESSION;
                if (pNew)
                    ExprStack.push(pNew);
                else
                {
                    // force exit
                    i = pOrigQuery->nNumTokens;
                }
            }
            else
            {
                ExprStack.push(NULL);
            }

            delete pFirst;
            break;

        default:
            hres = WBEM_E_CRITICAL_ERROR;
            delete pNew;
        }

        if(FAILED(hres))
        {
            // An error occurred, break out of the loop
            // ========================================

            break;
        }
    }

    if(SUCCEEDED(hres) && ExprStack.size() != 1)
    {
        hres = WBEM_E_CRITICAL_ERROR;
    }

    if(FAILED(hres))
    {
        // An error occurred. Clear the stack
        // ==================================

        while(!ExprStack.empty())
        {
            delete ExprStack.top();
            ExprStack.pop();
        }

        return hres;
    }

    // All is good
    // ===========

    *ppNewQuery = ExprStack.top();
    return S_OK;
}

//***************************************************************************
//
//***************************************************************************

BOOL CQueryEngine::IsTokenAboutClass(IN QL_LEVEL_1_TOKEN& Token,
                                       IN CWbemClass* pClass)
{
    CPropertyName& TokenPropName = Token.PropertyName;

    if(TokenPropName.GetNumElements() != 1)
        return FALSE;

    LPWSTR wszPropName = (LPWSTR)TokenPropName.GetStringAt(0);
    return SUCCEEDED(pClass->GetPropertyType(wszPropName, NULL, NULL));
}
//***************************************************************************
//
//***************************************************************************

HRESULT CQueryEngine::AndQueryExpressions(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pFirst,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSecond,
                                OUT QL_LEVEL_1_RPN_EXPRESSION** ppNew)
{
    // If either one is false, the result is false
    // ===========================================

    if(pFirst == NULL || pSecond == NULL)
    {
        *ppNew = NULL;
        return WBEM_S_NO_ERROR;
    }

    *ppNew = new QL_LEVEL_1_RPN_EXPRESSION;

    if (NULL == *ppNew)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    // If either one is empty, take the other
    // ======================================

    if(pFirst->nNumTokens == 0)
    {
        AppendQueryExpression(*ppNew, pSecond);
        return WBEM_S_NO_ERROR;
    }

    if(pSecond->nNumTokens == 0)
    {
        AppendQueryExpression(*ppNew, pFirst);
        return WBEM_S_NO_ERROR;
    }

    // Both are there --- and together
    // ===============================

    AppendQueryExpression(*ppNew, pFirst);
    AppendQueryExpression(*ppNew, pSecond);

    QL_LEVEL_1_TOKEN Token;
    Token.nTokenType = QL1_AND;
    (*ppNew)->AddToken(Token);

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CQueryEngine::OrQueryExpressions(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pFirst,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSecond,
                                OUT QL_LEVEL_1_RPN_EXPRESSION** ppNew)
{
    // If both are false, so is the resulkt
    // ====================================

    if(pFirst == NULL && pSecond == NULL)
    {
        *ppNew = NULL;
        return WBEM_S_NO_ERROR;
    }

    *ppNew = new QL_LEVEL_1_RPN_EXPRESSION;

    if (NULL == *ppNew)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }    

    // If either one is empty, so is the result
    // ========================================

    if(pFirst->nNumTokens == 0 || pSecond->nNumTokens == 0)
    {
        return WBEM_S_NO_ERROR;
    }

    // If either one is false, return the other
    // ========================================

    if(pFirst == NULL)
    {
        AppendQueryExpression(*ppNew, pSecond);
        return WBEM_S_NO_ERROR;
    }

    if(pSecond == NULL)
    {
        AppendQueryExpression(*ppNew, pFirst);
        return WBEM_S_NO_ERROR;
    }
    // Both are there --- or together
    // ==============================

    AppendQueryExpression(*ppNew, pFirst);
    AppendQueryExpression(*ppNew, pSecond);

    QL_LEVEL_1_TOKEN Token;
    Token.nTokenType = QL1_OR;
    (*ppNew)->AddToken(Token);

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

void CQueryEngine::AppendQueryExpression(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pDest,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSource)
{
    for(int i = 0; i < pSource->nNumTokens; i++)
    {
        pDest->AddToken(pSource->pArrayOfTokens[i]);
    }
}

//***************************************************************************
//
//***************************************************************************

BSTR CQueryEngine::GetParentPath(CWbemInstance* pInst, LPCWSTR wszClassName)
{
    // Get the relative path of the instance
    // =====================================

    LPWSTR wszRelPath = pInst->GetRelPath();
    if(wszRelPath == NULL)
        return NULL;

    BSTR str = AdjustPathToClass(wszRelPath, wszClassName);
    delete [] wszRelPath;
    return str;
}

//***************************************************************************
//
//***************************************************************************

BSTR CQueryEngine::AdjustPathToClass(LPCWSTR wszRelPath, LPCWSTR wszClassName)
{
    // Skip the absolute path
    // ======================

    if(wszRelPath[0] == '\\')
    {
        wszRelPath = wcschr(wszRelPath, ':');
        if(wszRelPath == NULL)
            return NULL;
        else
            wszRelPath++;
    }

    // Find the "post-classname" part
    // ==============================

    WCHAR* pwcDot = wcschr(wszRelPath, L'.');
    WCHAR* pwcEquals = wcschr(wszRelPath, L'=');
    LPWSTR wszPostClassPart;
    if(pwcDot == NULL)
        wszPostClassPart = pwcEquals;
    else if(pwcEquals == NULL)
        wszPostClassPart = pwcDot;
    else if(pwcDot < pwcEquals)
        wszPostClassPart = pwcDot;
    else
        wszPostClassPart = pwcEquals;

    // Allocate the BSTR for the real thing
    // ====================================

    BSTR strNewPath;
    if(wszPostClassPart)
    {
        strNewPath = SysAllocStringLen(NULL, wcslen(wszClassName) +
                                                wcslen(wszPostClassPart));
        if (strNewPath)
            swprintf(strNewPath, L"%s%s", wszClassName, wszPostClassPart);
    }
    else
    {
        strNewPath = SysAllocStringLen(NULL, wcslen(wszClassName));
        if (strNewPath)
            swprintf(strNewPath, L"%s", wszClassName);
    }

    return strNewPath;
}

//***************************************************************************
//
//  CQueryEngine::ExecAtomicDbQuery
//
//  General purpose query driver for QL LEVEL 1.  This method parses
//  and executes the query against the database engine.  The optimizer
//  is contained within this function and its auxiliaries.
//
//  Preconditions:
//  (1) All classes involved in the query are known to have
//  only static instances in the database.  No interface to dynamic
//  classes is provided.
//  (2) This method cannot resolve queries against abstract base classes.
//
//  Parameters:
//  <dwNs>          The target namespace.
//  <pQueryText>    The QL1 query, unparsed.
//  <pEnum>         Receives the enumerator containing the result set.
//
//  Return values:
//  <no_error>
//  <invalid_query>
//  <failed>
//  <out_of_memory>
//
//***************************************************************************
// ok / no error objects required

int CQueryEngine::ExecAtomicDbQuery(
    IN IWmiDbSession *pSession,
    IN IWmiDbHandle *pNsHandle,
    IN IWmiDbHandle *pScopeHandle,
    IN LPCWSTR wszClassName,
    IN QL_LEVEL_1_RPN_EXPRESSION *pExp,
    IN CBasicObjectSink* pDest, // no status
    IN CWbemNamespace * pNs)
{
    int nRetVal = 0;
    int nRes;

    // Examine the query and see if we can execute it
    // in any kind of optimized fashion.
    // ==============================================

    CWbemObject *pClassDef = 0;
    LPWSTR pPropToUse = 0;
    CVar *pValToUse = 0;
    int nType = 0;

    nRes = QueryOptimizationTest(
        pSession,
        pNsHandle,
        pScopeHandle,
        wszClassName,
        pExp,
        &pClassDef,
        &pPropToUse,
        &pValToUse,
        &nType
        );

    if (nRes == use_key)
    {
        nRes = KeyedQuery(
            pSession,
            pNsHandle,
            pExp,
            pClassDef,
            0,
            pDest,
            pNs
            );

        if (nRes != 0)
            nRetVal = failed;
    }
    else if (nRes == use_table_scan || nRes == use_index)
    {
        HRESULT hRes = CRepository::TableScanQuery(
            pSession,
            pScopeHandle,
            (LPWSTR)wszClassName,
            pExp,
            0,
            pDest
            );

        if (FAILED(hRes))
            nRetVal = failed;
        else
            nRetVal = 0;
    }

    delete pValToUse;
    delete pPropToUse;
    if (pClassDef)
        pClassDef->Release();

    return nRetVal;
}


//***************************************************************************
//
//  CQueryEngine::QueryOptimizationTest
//
//  Examines a query and its associated class definition.  It determines
//  what optimizations, if any, can be applied to speed up the query.
//  If the query is conjunctive and there is some form of primary or
//  secondary indexing which can be used, this method selects the
//  appropriate property to use for a retrieval by key or an indexed query.
//  If <table_scan> is returned, then a table scan is required.
//
//  Parameters:
//  <dwNs>              The relevant namespace.
//  <pExp>              A valid QL1 expression.
//  <pClassDef>         Always receives the deserialized class definition, as long
//                      as <invalid_class> is not returned.  Use operator
//                      delete to deallocate.
//
//  <pPropToUse>        If <use_index> is returned, this is assigned to point
//                      to an indexed property.  Use operator delete to deallocate
//                      This always refers to a non-key property name.
//                      Set to NULL if <table_scan> is returned.
//
//  <pValToUse>         The value to use if <use_index> is returned.
//                      Set to NULL if <use_index> is not returned.
//
//  <pnType>            Receives the VT_ type of the relevant property.
//                      Set to NULL if <use_index> is not returned.
//
//  Return values:
//  <invalid_class>     The class did not appear to exist.
//  <use_index>         The value returned via <pPropToUse> is a property
//                      with a secondary index which can beused to limit
//                      the query.
//  <use_key>           The query is such that all of the key properties
//                      were specified with equality tests.
//  <use_table_scan>    A table scan is required.
//
//***************************************************************************
// ok

int CQueryEngine::QueryOptimizationTest(
    IN  IWmiDbSession *pSession,
    IN  IWmiDbHandle *pNsHandle,
    IN  IWmiDbHandle *pScopeHandle,
    IN  LPCWSTR wszClassName,
    IN  QL_LEVEL_1_RPN_EXPRESSION *pExp,
    OUT CWbemObject **pClassDef,
    OUT LPWSTR *pPropToUse,
    OUT CVar **pValToUse,
    OUT int *pnType
    )
{
    int nRes;

    if (pNsHandle == 0 || pExp == 0 || pClassDef == 0 || pPropToUse == 0 ||
        pValToUse == 0 || pnType == 0)
            return invalid_parameter;

    // Defaults.
    // =========

    *pClassDef = 0;
    *pPropToUse = 0;
    *pValToUse = 0;
    *pnType = 0;

    // Look up the class definition.
    // =============================
    IWbemClassObject *pCls = 0;

    HRESULT hRes = CRepository::GetObject(pSession, pNsHandle, wszClassName, 0, &pCls);
    if (FAILED(hRes))
        return invalid_class;

    CWbemClass *pClsDef = (CWbemClass *) pCls;

    *pClassDef = pClsDef;

    // Test query for conjunctiveness.
    // ===============================
    if (!IsConjunctiveQuery(pExp))
        return use_table_scan;

    // If here, the query is conjunctive.  However, a table scan
    // may still be required if the only relational tests are on
    // non-indexed or non-keyed properties.

    // First, get the key properties.  If all of the keys
    // are used with equality tests, then we could simply retrieve
    // the object by key and test it.
    // ===========================================================
    CWStringArray aKeyProps;
    pClsDef->GetKeyProps(aKeyProps);

    if (QueryKeyTest(pExp, pClsDef, aKeyProps))
    {
        return use_key;
    }

    // If here, the keys were not adequate for limiting
    // the query. We next try to see if any indexed properties
    // were used.
    // =======================================================

    CWStringArray aIndexedProps;
    pClsDef->GetIndexedProps(aIndexedProps);

    if (QueryIndexTest(pExp, pClsDef, aIndexedProps, pPropToUse,
        pValToUse, pnType))
    {
        if (*pValToUse == 0)
            return use_table_scan;

        // Try to coerce
        // =============
        if ((*pValToUse)->ChangeTypeTo(CType::GetVARTYPE(*pnType)))
        {
            return use_index;
        }
        return use_table_scan;
    }

    // If here, we have to use a table scan after all.
    // ===============================================

    return use_table_scan;
}

//***************************************************************************
//
//  CQueryEngine::IsConjunctiveQuery
//
//  Does an initial screen of a query to see if it clearly not optimizable.
//
//  If the query contains an OR or NOT operator, it cannot currently be
//  optimized.
//
//***************************************************************************
// ok

BOOL CQueryEngine::IsConjunctiveQuery(
    IN  QL_LEVEL_1_RPN_EXPRESSION *pExp
    )
{
    for (int i2 = 0; i2 < pExp->nNumTokens; i2++)
    {
        QL_LEVEL_1_TOKEN& Tok = pExp->pArrayOfTokens[i2];

        if (Tok.nTokenType == QL_LEVEL_1_TOKEN::TOKEN_OR ||
            Tok.nTokenType == QL_LEVEL_1_TOKEN::TOKEN_NOT
            )
            return FALSE;
    }

    return TRUE;
}

//***************************************************************************
//
//  CQueryEngine::QueryKeyTest
//
//  Examines a query to see if the result set must be a single instance
//  due to use of the key in the 'where' clause.  Not only must the
//  key(s) be tested for equality, there must be only a single token or
//  else all operators must be AND operators.
//
//  This also performs type checking on the key(s).
//
//***************************************************************************
// ok

BOOL CQueryEngine::QueryKeyTest(
    IN  QL_LEVEL_1_RPN_EXPRESSION *pExp,
    IN  CWbemObject *pClassDef,
    IN  CWStringArray &aKeyProps
    )
{
    if (aKeyProps.Size() == 0)
        return FALSE;

    for (int i = 0; i < aKeyProps.Size(); i++)
    {
        // Check for unsupported key types
        // ===============================

        CIMTYPE ct;
        pClassDef->GetPropertyType(aKeyProps[i], &ct);
        if(ct == CIM_CHAR16 || ct == CIM_REFERENCE || ct== CIM_DATETIME)
            return FALSE;

        BOOL bFound = FALSE;

        for (int i2 = 0; i2 < pExp->nNumTokens; i2++)
        {
            QL_LEVEL_1_TOKEN& Tok = pExp->pArrayOfTokens[i2];

            if (Tok.nTokenType == QL_LEVEL_1_TOKEN::OP_EXPRESSION)
            {
                // If there is a matching property, check the rest
                // of the expression to ensure type compatibility
                // and that an equality test is used.
                // ===============================================

                LPWSTR wszPropName = GetSimplePropertyName(Tok.PropertyName);
                if (wszPropName && wbem_wcsicmp(wszPropName, aKeyProps[i]) == 0)
                {
                    if (Tok.nOperator == QL_LEVEL_1_TOKEN::OP_EQUAL)
                    {
                        // TBD: Do a type check test here.
                        if(bFound)
                            return FALSE;       // Duplicate, probably not a good query for keys!
                        bFound = TRUE;
                    }
                    else
                    {
                        return FALSE;   // The key is being used in a non-equality comparison!! (Bug #43969)
                    }

                }
            }
        }

        if (!bFound)
            return FALSE;
    }

    return TRUE;
}

//***************************************************************************
//
//  CQueryEngine::QueryIndexTest
//
//  Examines a query to see if the result set can be limited by use
//  of a secondary index.
//
//***************************************************************************
// ok

BOOL CQueryEngine::QueryIndexTest(
    IN  QL_LEVEL_1_RPN_EXPRESSION *pExp,
    IN  CWbemObject *pClsDef,
    IN  CWStringArray &aIndexedProps,
    OUT LPWSTR *pPropToUse,
    OUT CVar **pValToUse,
    OUT int *pnType
    )
{
    for (int i = 0; i < pExp->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN& Tok = pExp->pArrayOfTokens[i];

        if (Tok.nTokenType == QL_LEVEL_1_TOKEN::OP_EXPRESSION &&
            Tok.nOperator == QL_LEVEL_1_TOKEN::OP_EQUAL)
        {
            for (int i2 = 0; i2 < aIndexedProps.Size(); i2++)
            {
                LPWSTR wszPropName = GetSimplePropertyName(Tok.PropertyName);
                if (wszPropName &&
                    wbem_wcsicmp(wszPropName, aIndexedProps[i2]) == 0)
                {
                    CIMTYPE ctType;
                    HRESULT hRes = pClsDef->GetPropertyType(aIndexedProps[i2],
                                                            &ctType);
                    if ((ctType != CIM_SINT8) &&
                        (ctType != CIM_UINT8) &&
                        (ctType != CIM_SINT16) &&
                        (ctType != CIM_UINT16) &&
                        (ctType != CIM_SINT32) &&
                        (ctType != CIM_UINT32) &&
                        (ctType != CIM_CHAR16) &&
                        (ctType != CIM_STRING))
                        continue;

                    // If here, we have a match.
                    // =========================
                    *pPropToUse = Macro_CloneLPWSTR(aIndexedProps[i2]);
                    *pValToUse = new CVar(&Tok.vConstValue);

                    // a-levn: added support for NULLs
                    *pnType = (int)ctType;

                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}



//***************************************************************************
//
//***************************************************************************

LPWSTR CQueryEngine::NormalizePath(LPCWSTR wszObjectPath, CWbemNamespace * pNs)
{
    CObjectPathParser Parser;
    ParsedObjectPath* pParsedPath;
    LPWSTR pReturnString = NULL;

    if(Parser.Parse((LPWSTR)wszObjectPath, &pParsedPath) !=
                        CObjectPathParser::NoError ||
        !pParsedPath->IsObject())
    {
        return NULL;
    }

    if(pParsedPath->m_pClass == NULL)
    {
        return NULL;
    }

    // Start off with the server and namespace part

    WString wsNormal;
    try 
    {
	    wsNormal += L"\\\\";

	    if(bAreWeLocal(pParsedPath->m_pServer))
	        wsNormal += L".";
	    else
	        wsNormal += pParsedPath->m_pServer;
	    wsNormal += L"\\";
	    
	    WCHAR * pPath = pParsedPath->GetNamespacePart();
	    CVectorDeleteMe<WCHAR> dm1(pPath);
	    
	    if(pPath)
	        wsNormal += pPath;
	    else
	        wsNormal += pNs->GetName();
	    wsNormal += L":";


	    // Find the parent that defined the key
	    // ====================================

	    CWbemClass* pRootClass = NULL;
	    IWbemClassObject *pCls = 0;

	    HRESULT hRes = CRepository::FindKeyRoot(pNs->GetNsSession(), pNs->GetScope(), pParsedPath->m_pClass, &pCls);
	    pRootClass = (CWbemClass *) pCls;

	    if (hRes == WBEM_E_NOT_FOUND)
	    {
	        wsNormal += pParsedPath->m_pClass;
	    }
	    else if (SUCCEEDED(hRes))
	    {	        
	        CVar vName;
	        HRESULT getClassResult = pRootClass->GetClassName(&vName);
	        pRootClass->Release();

	        if (FAILED(getClassResult))
	        	return NULL;
	        wsNormal += vName.GetLPWSTR();
	    }

	    // Convert this part to upper-case
	    // ===============================

	    LPWSTR wsz = (wchar_t*)wsNormal;
	    for(int i = 0; i < wsNormal.Length(); i++)
	    {
	        wsz[i] = wbem_towupper(wsz[i]);
	    }

	    WCHAR * wszKey = pParsedPath->GetKeyString();
	    if (wszKey)
	    {
	        CVectorDeleteMe<WCHAR> dm2(wszKey);
		    
		    wsNormal += L"=";
		    wsNormal += wszKey;
	    
			pReturnString = wsNormal.UnbindPtr();
		}
    }
    catch (CX_MemoryException &)
    {
        // pReturnString is already NULL here
    }

    Parser.Free(pParsedPath);
    return pReturnString; 
}

//***************************************************************************
//
//***************************************************************************

BOOL CQueryEngine::AreClassesRelated(CWbemNamespace* pNamespace,
                                     IWbemContext* pContext,
                                     CWbemObject* pClass1, LPCWSTR wszClass2)
{
    HRESULT hres;

    // First check if class 1 inherits from class 2
    // ============================================

    if(pClass1->InheritsFrom((LPWSTR)wszClass2) == S_OK)
        return TRUE;

    // Now, unfortunately, we have to go get the second class
    // ======================================================

    CSynchronousSink* pSink = new CSynchronousSink;
    if (NULL == pSink)
        return FALSE;
    pSink->AddRef();
    CReleaseMe rm1(pSink);

    pNamespace->Exec_GetClass(wszClass2, 0, pContext, pSink);
    pSink->Block();
    pSink->GetStatus(&hres, NULL, NULL);

    if(FAILED(hres))
        return FALSE;

    CWbemClass* pClass2 = (CWbemClass*)(pSink->GetObjects()[0]);

    // Get the first class's name
    // ==========================

    CVar vFirstName;
    pClass1->GetClassName(&vFirstName);

    // Check if the second class is derived from the first one
    // =======================================================

    if(pClass2->InheritsFrom(vFirstName.GetLPWSTR()) == S_OK)
        return TRUE;

    return FALSE;
}

//***************************************************************************
//
//  Determines if property <wszPropName> in object <pObj>
//  is a reference to <pTargetClass>
//
//***************************************************************************

BOOL CQueryEngine::IsAReferenceToClass(
    CWbemNamespace* pNamespace,
    IWbemContext* pContext,
    CWbemObject* pObj,
    LPCWSTR wszPropName,
    CWbemObject* pTargetClass,
    bool bCheckPropValue
    )
{
    // Get the cimtype
    // ===============

    CIMTYPE ct;
    if(FAILED(pObj->GetPropertyType((LPWSTR)wszPropName, &ct)) ||
        ct != CIM_REFERENCE)
    {
        return FALSE;
    }

    CVar vCimType;
    if(FAILED(pObj->GetPropQualifier((LPWSTR)wszPropName, TYPEQUAL,
                                                    &vCimType)))
    {
        return FALSE;
    }

    // See if it is a reference
    // ========================

    if (!wbem_wcsicmp(vCimType.GetLPWSTR(), L"ref"))
    {
        // Special case of object refs which only refer to class definitions.
        // ==================================================================

        if (bCheckPropValue)
        {
            CVar vClassPath;
            CVar vClassName;
            int nRes = pObj->GetProperty(wszPropName, &vClassPath);
            nRes = pTargetClass->GetClassName(&vClassName);
            if (!vClassPath.IsNull() && !vClassPath.IsNull())
            {
                if (_wcsicmp(vClassName.GetLPWSTR(), vClassPath.GetLPWSTR()) == 0)
                    return TRUE;
            }
        }
        else
            return TRUE;
    }

    if(_wcsnicmp(vCimType.GetLPWSTR(), L"ref:", 4) == 0)
    {
        LPWSTR wszClass = vCimType.GetLPWSTR() + 4;

        return CQueryEngine::AreClassesRelated(pNamespace, pContext,
                                pTargetClass, wszClass);
    }


    return FALSE;
}

//***************************************************************************
//
//  CQueryEngine::KeyedQuery
//
//  Preconditions:
//  The query is known to contain all key properties with equality
//  tests such that the object can be retrieved using
//  CObjectDatabase::GetObjectByPath and subsequently filtered.
//
//***************************************************************************
// ok
int CQueryEngine::KeyedQuery(
    IN IWmiDbSession *pSession,
    IN IWmiDbHandle *pNsHandle,
    IN QL_LEVEL_1_RPN_EXPRESSION *pExp,
    IN CWbemObject *pClassDef,
    IN DWORD dwFlags,
    IN CBasicObjectSink* pDest, // no status
    IN CWbemNamespace * pNs
    )
{
    int nRet = no_error;

    // Convert the query into an object path.
    // ======================================

    LPWSTR pObjPath = GetObjectPathFromQuery(pClassDef, pExp, pNs);
    if (pObjPath == 0)
        return invalid_query;

    // Now get the object by path.
    // ===========================
    IWbemClassObject *pObj = 0;
    HRESULT hRes = CRepository::GetObject(pSession, pNsHandle, pObjPath, 0, &pObj);

    // If there was an object, test it against the 'rest' of the query.
    // ================================================================
    if (SUCCEEDED(hRes))
    {
        CQlFilteringSink* pFilteringSink =
                            new CQlFilteringSink(pDest, pExp, pNs);
        if (pFilteringSink)
        {
	        pFilteringSink->AddRef();
    	    pFilteringSink->Add(pObj);
        	pFilteringSink->Release();
        }
        else
        {
            nRet = failed;
        }
        pObj->Release();
    }

    delete pObjPath;

    return nRet;
}


//***************************************************************************
//
//  CQueryEngine::GetObjectPathFromQuery
//
//  Converts the relevant parts of a QL query to an equivalent object
//  path.  This assumes that the query contains equality tests on all
//  key properties such that an object path would generate the same
//  single instance as the query.
//
//***************************************************************************
// ok

LPWSTR CQueryEngine::GetObjectPathFromQuery(
    IN CWbemObject *pClassDef,
    IN QL_LEVEL_1_RPN_EXPRESSION *pExp,
    IN CWbemNamespace * pNs
    )
{
    CWStringArray aKeys;
    WString ObjPath;

    CVar v;
    HRESULT hr = pClassDef->GetClassName(&v);
    if (FAILED(hr))
    	return 0;
    ObjPath += v.GetLPWSTR();
    ObjPath += L".";

    pClassDef->GetKeyProps(aKeys);

    BOOL bFirst = TRUE;

    for (int i = 0; i < aKeys.Size(); i++)
    {
        if (!bFirst)
            ObjPath += L",";

        bFirst = FALSE;
        ObjPath += aKeys[i];
        ObjPath += L"=";

        // Now find the property value.
        // ============================
        for (int i2 = 0; i2 < pExp->nNumTokens; i2++)
        {
            QL_LEVEL_1_TOKEN& Tok = pExp->pArrayOfTokens[i2];
            LPWSTR wszPropName = GetSimplePropertyName(Tok.PropertyName);

            if (Tok.nTokenType == QL_LEVEL_1_TOKEN::OP_EXPRESSION &&
                wszPropName && wbem_wcsicmp(aKeys[i], wszPropName) == 0)
            {
                if (V_VT(&Tok.vConstValue) == VT_BSTR)
                {
                    ObjPath += L"\"";
                    WString nonEscaped(V_BSTR(&Tok.vConstValue));
                    WString escaped = nonEscaped.EscapeQuotes();
                    ObjPath += escaped;
                    ObjPath += L"\"";
                }
                else if (V_VT(&Tok.vConstValue) == VT_BOOL)
                {
                    short bValue = V_I2(&Tok.vConstValue);
                    if(bValue == VARIANT_TRUE)
                        ObjPath+= L"1";
                    else
                        ObjPath += L"0";
                }
                else
                {
                    VARIANT varTo;
                    VariantInit(&varTo);
                    SCODE sc = VariantChangeType(&varTo, &Tok.vConstValue, 0, VT_BSTR);
                    if(sc == S_OK)
                    {
                        wchar_t buf[64];
                        swprintf(buf, L"%s", varTo.bstrVal);
                        ObjPath += buf;
                        VariantClear(&varTo);
                    }
                }
            }
        }
    }

    return ObjPath.UnbindPtr();
}

HRESULT CQueryEngine::FindOverridenProperties(CDynasty* pDyn,
                                                CWStringArray& awsOverriden,
                                                bool bIncludeThis)
{
    //
    // If this class is included (not top-level), add all the properties
    // it overrides to the array
    //

    if(bIncludeThis)
    {
        CWbemObject *pTmp = (CWbemObject *) pDyn->m_pClassObj;

        for(int i = 0; i < pTmp->GetNumProperties(); i++)
        {
            CVar vPropName;
            pTmp->GetPropName(i, &vPropName);

            CVar vOverride;
            if(FAILED(pTmp->GetPropQualifier(vPropName.GetLPWSTR(),
                                            L"OVERRIDEVALUE",
                                             &vOverride)))
                continue;

            //
            // Overriden property --- add
            //

            awsOverriden.Add(vPropName.GetLPWSTR());
        }
    }

    //
    // Recurse through all the children
    //

    if(pDyn->m_pChildren)
    {
        for(int i = 0; i < pDyn->m_pChildren->Size(); i++)
        {
            CDynasty* pSubDyn = (CDynasty*)(pDyn->m_pChildren->GetAt(i));
            HRESULT hres = FindOverridenProperties(pSubDyn, awsOverriden, true);
            if(FAILED(hres))
                return hres;
        }
    }

    return WBEM_S_NO_ERROR;
}



//***************************************************************************
//
//  CQueryEngine::ExecAtomicDynQlQuery
//
//***************************************************************************
// ok

HRESULT CQueryEngine::ExecAtomicDynQlQuery(
    IN CWbemNamespace *pNs,
    IN CDynasty* pDyn,
    IN LPWSTR pszQueryFormat,
    IN LPWSTR pszQuery,
    IN QL_LEVEL_1_RPN_EXPRESSION *pParsedQuery,
    IN LONG lFlags,
    IN IWbemContext* pContext,
    IN CBasicObjectSink* pDest, // must support selective filtering ,
	IN BOOL bComplexQuery
    )
{
    HRESULT hres;

    DEBUGTRACE((LOG_WBEMCORE,"Query Engine request: querying dyn provider with <%S>\n", pszQuery));

    //
    // Find all the properties that are overriden by derived classes.
    // We must remove all references to those properties from the query, since
    // otherwise this provider might not return the parent instances needed to
    // merge with the child instances with the overriden property values.
    //

    CWStringArray awsOverriden;
    hres = FindOverridenProperties(pDyn, awsOverriden);
    if(FAILED(hres))
        return pDest->Return(hres);

    //
    // Get the query analyzer to remove all the properties that are overriden
    // or not members of this class (not possible right now anyway)
    //

    QL_LEVEL_1_RPN_EXPRESSION* pNewParsedQuery = NULL;
    hres = CQueryAnalyser::GetNecessaryQueryForClass(pParsedQuery,
                pDyn->m_pClassObj, awsOverriden, pNewParsedQuery);
    if(FAILED(hres))
        return pDest->Return(hres);

    CDeleteMe<QL_LEVEL_1_RPN_EXPRESSION> dm1(pNewParsedQuery);

    //
    // Get the new text to give to provider
    //

    LPWSTR pszNewQuery = pNewParsedQuery->GetText();
    if(pszNewQuery == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<WCHAR> vdm(pszNewQuery);

    DEBUGTRACE((LOG_WBEMCORE,"Query Engine actual: querying dyn provider with <%S>\n", pszNewQuery));

    // Check if the query is empty
    // ===========================

    BOOL bEmpty = FALSE;
    if(lFlags & WBEM_FLAG_SHALLOW)
    {
        // We know that the query is actually a shallow enumeration
        // ========================================================

        bEmpty = TRUE;
    }
    else if(pNewParsedQuery == NULL ||
        (pNewParsedQuery->nNumTokens == 0 &&
         pNewParsedQuery->nNumberOfProperties == 0))
    {
        bEmpty = TRUE;
    }

    if(bEmpty)
    {
        pNs->DynAux_GetInstances (

			(CWbemObject *) pDyn->m_pClassObj,       // class def
			lFlags & ~WBEM_FLAG_SHALLOW,             // used for WBEM_FLAG_SEND_STATUS
			pContext,
			pDest,
			bComplexQuery
		);
    }
    else
    {
        pNs->DynAux_ExecQueryAsync (

			(CWbemObject *) pDyn->m_pClassObj,
			pszNewQuery,
			pszQueryFormat,
			lFlags & ~WBEM_FLAG_SHALLOW,
			pContext,
			pDest,
			bComplexQuery
		) ;
    }

    return WBEM_S_NO_ERROR;
}



HRESULT CQueryEngine::EliminateDuplications(
                        CRefedPointerArray<CWbemClass>& apClasses,
                        LPCWSTR wszResultClass)
{
    int i;

    if(wszResultClass)
    {
        // Eliminate all classes not derived from wszResultClass
        // =====================================================

        for(i = 0; i < apClasses.GetSize(); i++)
        {
            if(apClasses[i]->InheritsFrom((LPWSTR)wszResultClass) !=
                                        WBEM_S_NO_ERROR)
            {
                // Not derived
                apClasses.RemoveAt(i);
                i--;
            }
        }
    }

    for(i = 0; i < apClasses.GetSize(); i++)
    {
        // Check if this class is abstract. There is no reason asking abstract
        // classes for their objects
        // ===================================================================

        CVar vAbstract;
        if(SUCCEEDED(apClasses[i]->GetQualifier(L"abstract", &vAbstract))
            && vAbstract.GetType() == VT_BOOL && vAbstract.GetBool())
        {
            apClasses.RemoveAt(i);
            i--;
        }
    }

    // Search for pairs // TBD: can be done more efficiently!!
    // =======================================================

    for(i = 0; i < apClasses.GetSize(); i++)
    {
        CWbemClass* pClass1 = apClasses[i];
        if(pClass1 == NULL)
            continue;

        CVar vName;
        apClasses[i]->GetClassName(&vName);

        for (int j = 0; j < apClasses.GetSize(); j++)
        {
            if(j == i) continue;

            CWbemClass* pClass2 = apClasses[j];
            if(pClass2 == NULL)
                continue;

            if (pClass2->InheritsFrom(vName.GetLPWSTR()) == WBEM_S_NO_ERROR)
            {
                // Eliminate class 2 --- it's parent is listed
                // ===========================================

                apClasses.SetAt(j, NULL);
            }
        }
    }

    return WBEM_S_NO_ERROR;
}




//***************************************************************************
//
//***************************************************************************

LPWSTR CQueryEngine::GetPrimaryName(WBEM_PROPERTY_NAME& Name)
{
    if(Name.m_lNumElements < 1 ||
        Name.m_aElements[0].m_nType != WBEM_NAME_ELEMENT_TYPE_PROPERTY)
    {
        return NULL;
    }

    return Name.m_aElements[0].Element.m_wszPropertyName;
}

//***************************************************************************
//
//***************************************************************************

LPWSTR CQueryEngine::GetSimplePropertyName(WBEM_PROPERTY_NAME& Name)
{
    if(Name.m_lNumElements != 1 ||
        Name.m_aElements[0].m_nType != WBEM_NAME_ELEMENT_TYPE_PROPERTY)
    {
        return NULL;
    }

    return Name.m_aElements[0].Element.m_wszPropertyName;
}


//***************************************************************************
//
//***************************************************************************



HRESULT CQueryEngine::ExecSchemaQuery(  IN CWbemNamespace *pNs,
                                        IN LPWSTR pszQuery,
                                        QL_LEVEL_1_RPN_EXPRESSION *pExp,
                                        IN IWbemContext* pContext,
                                        IN CBasicObjectSink* pSink)
{
    HRESULT hres = WBEM_S_NO_ERROR;
    
    if (pExp->nNumTokens == 0)
    {
        //This means we want all classes...
        pNs->Exec_CreateClassEnum(NULL, 0, pContext, pSink);
        return WBEM_S_NO_ERROR;
    }
    else if ((pExp->nNumTokens == 1) &&
             (pExp->pArrayOfTokens[0].nOperator == QL_LEVEL_1_TOKEN::OP_EQUAL))
    {
        //This means we have a simple expression (hopefully)

        //Now we need to check which type of retrieval we are looking for...
        LPCWSTR szPropName = pExp->pArrayOfTokens[0].PropertyName.GetStringAt(0);
        VARIANT& vValue = pExp->pArrayOfTokens[0].vConstValue;

        if (szPropName == 0)
            return pSink->Return(WBEM_E_INVALID_QUERY);

        if (_wcsicmp(szPropName, L"__CLASS") == 0)
        {
            if ((V_VT(&vValue) == VT_BSTR) && (wcslen(V_BSTR(&vValue))))
            {
                //Single class retrieval

                CErrorChangingSink Err(pSink, WBEM_E_NOT_FOUND, 0);
                Err.AddRef();
                pNs->Exec_GetObject(V_BSTR(&vValue), 0, pContext, &Err);
                return WBEM_S_NO_ERROR;
            }
            else if((V_VT(&vValue) == VT_NULL) ||
                ((V_VT(&vValue) == VT_BSTR) && (wcslen(V_BSTR(&vValue))==0)))
            {
                // __CLASS = NULL
                return pSink->Return(WBEM_S_NO_ERROR);
            }
            else
            {
                return pSink->Return(WBEM_E_INVALID_QUERY);
            }

        }
        else if (_wcsicmp(szPropName, L"__SUPERCLASS") == 0)
        {
            if(V_VT(&vValue) == VT_BSTR)
            {
                CErrorChangingSink Err(pSink, WBEM_E_INVALID_CLASS, 0);
                Err.AddRef();

                //Get things which are hanging off these items
                pNs->Exec_CreateClassEnum(V_BSTR(&vValue), WBEM_FLAG_SHALLOW,
                                            pContext, &Err);
            }
            else if(V_VT(&vValue) == VT_NULL)
            {
                // get things which are hanging off root
                pNs->Exec_CreateClassEnum(L"", WBEM_FLAG_SHALLOW,
                                            pContext, pSink);
            }
            else
            {
                pSink->Return(WBEM_E_INVALID_QUERY);
            }

            return WBEM_S_NO_ERROR;
        }
        else if (_wcsicmp(szPropName, L"__DYNASTY") == 0)
        {
            if(V_VT(&vValue) == VT_BSTR)
            {
                //Get things which are hanging off these items as well as the item itself
                BSTR strClassName = V_BSTR(&vValue);
                IWbemClassObject* pClass = NULL;
                hres = pNs->Exec_GetObjectByPath(strClassName, 0, pContext,
                                                    &pClass, NULL);
                if(FAILED(hres))
                {
                    if(hres == WBEM_E_NOT_FOUND)
                        hres = S_OK;
                    return pSink->Return(hres);
                }
                else // restore the value
                {
                    hres = WBEM_S_NO_ERROR;
                }
                
                // Check that this is the root of the dynasty
                CVar vDyn;
                if(FAILED(((CWbemObject*)pClass)->GetDynasty(&vDyn)))
                    return pSink->Return(WBEM_E_FAILED);
                if (vDyn.IsNull())
                    return pSink->Return(WBEM_S_NO_ERROR);
                if(wbem_wcsicmp(vDyn.GetLPWSTR(), strClassName))
                    return pSink->Return(WBEM_S_NO_ERROR);

                pSink->Add(pClass);

                pNs->Exec_CreateClassEnum(strClassName, 0, pContext, pSink);
            }
            else if(V_VT(&vValue) == VT_NULL)
            {
                pSink->Return(WBEM_S_NO_ERROR);
            }
            else
            {
                pSink->Return(WBEM_E_INVALID_QUERY);
            }

            return WBEM_S_NO_ERROR;
        }
        else
        {
            return pSink->Return(WBEM_E_INVALID_QUERY);
        }
    }
    else if ((pExp->nNumTokens == 1) &&
             (pExp->pArrayOfTokens[0].nOperator == QL1_OPERATOR_ISA) &&
             (_wcsicmp(pExp->pArrayOfTokens[0].PropertyName.GetStringAt(0), L"__THIS") == 0))
    {
        //With the isa, we return everything which is derived from this, as well
        //as the class in question...


        VARIANT & var = pExp->pArrayOfTokens[0].vConstValue;
        if(var.vt != VT_BSTR || var.bstrVal == 0)
            return pSink->Return(WBEM_E_INVALID_QUERY);

        CCombiningSink* pCombiningSink = new CCombiningSink(pSink, WBEM_E_NOT_FOUND);
        if (pCombiningSink)
        {
	        pCombiningSink->AddRef();

	        pNs->Exec_GetObject(V_BSTR(&(pExp->pArrayOfTokens[0].vConstValue)), 0, pContext, pCombiningSink);

	        pNs->Exec_CreateClassEnum(V_BSTR(&(pExp->pArrayOfTokens[0].vConstValue)), 0, pContext, pCombiningSink);

	        pCombiningSink->Release();
	        return WBEM_S_NO_ERROR;
        }
        else
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        
    }
    // OK, so all the simple cases are dealt with here.  We should now check everything is
    // valid and process it in the best possible way.  If this is a conjunctive query
    // we can also do a little optimisation!

    //Lets validate all of the properties to make sure they are all valid.  If we
    //did not do this, there are scenarios where we would get inconsistencies
    //based on the different code paths.
    BOOL bError = FALSE;

    //While we are at it, we can do a check for the first location of each type of property
    //name (this is used for optimisation!)
    BOOL bConjunctive = IsConjunctiveQuery(pExp);
    QL_LEVEL_1_TOKEN *pThisToken = NULL,
                     *pClassToken = NULL,
                     *pSuperclassToken = NULL,
                     *pDynastyToken = NULL;

    for (int i = 0; i != pExp->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN* pCurrentToken = pExp->pArrayOfTokens + i;
        if (pCurrentToken->PropertyName.GetNumElements() > 1)
        {
            //This is probably an error!
            bError = TRUE;
            break;
        }
        else if (pCurrentToken->PropertyName.GetNumElements() == 1)
        {
            //We need to validate it...
            //If it is an isa, it can only be a "__this", otherwise it has to be one
            //of the "__superclass", "__dynasty" or "__class"

            LPCWSTR wszCurrentPropName = pCurrentToken->PropertyName.GetStringAt(0);
            if (wszCurrentPropName == 0)
            {
                bError = TRUE;
                break;
            }

            if (pCurrentToken->nOperator == QL1_OPERATOR_ISA)
            {
                if(_wcsicmp(wszCurrentPropName, L"__THIS"))
                {
                    bError = TRUE;
                    break;
                }
            }
            else
            {
                if(_wcsicmp(wszCurrentPropName, L"__CLASS") &&
                   _wcsicmp(wszCurrentPropName, L"__SUPERCLASS") &&
                   _wcsicmp(wszCurrentPropName, L"__DYNASTY"))
                {
                    bError = TRUE;
                    break;
                }
            }

            if (bConjunctive)
            {
                VARIANT* pCurrentValue = &(pCurrentToken->vConstValue);

                if (_wcsicmp(wszCurrentPropName, L"__THIS") == 0)
                {
                    if(V_VT(pCurrentValue) != VT_BSTR)
                        bError = TRUE;
                    else if (!pThisToken)
                        pThisToken = pCurrentToken;
                }
                else if (_wcsicmp(wszCurrentPropName, L"__CLASS") == 0)
                {
                    if(V_VT(pCurrentValue) != VT_BSTR && V_VT(pCurrentValue) != VT_NULL)
                        bError = TRUE;
                    else if (pCurrentToken->nOperator != QL_LEVEL_1_TOKEN::OP_EQUAL)
                        bConjunctive = FALSE;
                    else if (!pClassToken)
                        pClassToken = pCurrentToken;

                }
                else if (_wcsicmp(wszCurrentPropName, L"__SUPERCLASS") == 0)
                {
                    if(V_VT(pCurrentValue) != VT_BSTR && V_VT(pCurrentValue) != VT_NULL)
                        bError = TRUE;
                    else if (pCurrentToken->nOperator != QL_LEVEL_1_TOKEN::OP_EQUAL)
                        bConjunctive = FALSE;
                    else if (!pSuperclassToken)
                        pSuperclassToken = pCurrentToken;

                }
                else // DYNASTY
                {
                    if(V_VT(pCurrentValue) != VT_BSTR)
                        bError = TRUE;
                    else if (pCurrentToken->nOperator != QL_LEVEL_1_TOKEN::OP_EQUAL)
                        bConjunctive = FALSE;
                    else if (!pDynastyToken)
                        pDynastyToken = pCurrentToken;

                }
            }
        }

    }

    if (bError == TRUE)
    {
        return pSink->Return(WBEM_E_INVALID_QUERY);
    }

    //We need to create a filter sink to deal with this query....
    CQlFilteringSink* pFilteringSink =
        new CQlFilteringSink(pSink, pExp, pNs, TRUE);

    if (NULL == pFilteringSink)
    {
        return pSink->Return(WBEM_E_OUT_OF_MEMORY);
    }

    //If this is conjunctive we can just retrieve a single item based on a set of
    //rules and pass this through the filter
    if (bConjunctive)
    {
        //We can pick a single item to retrieve and pass this through the filter rather
        //than retrieve all of them

        if (pClassToken)
        {
            //Single class retrieval
            pFilteringSink->AddRef();
            if(V_VT(&(pClassToken->vConstValue)) == VT_NULL)
            {
                // null class --- no such thing
                pFilteringSink->Return(WBEM_S_NO_ERROR);
            }
            else // VT_BSTR
            {
                pNs->Exec_GetObject(V_BSTR(&(pClassToken->vConstValue)), 0,
                    pContext, pFilteringSink);
            }
            pFilteringSink->Release();
        }
        else if (pSuperclassToken)
        {
            //Get things which are hanging off these items
            pFilteringSink->AddRef();
            BSTR strParent = NULL;
            if(V_VT(&(pSuperclassToken->vConstValue)) == VT_NULL)
            {
                // null superclass
                strParent = NULL;
            }
            else // VT_BSTR
            {
                strParent = V_BSTR(&(pSuperclassToken->vConstValue));
            }

            pNs->Exec_CreateClassEnum(strParent, 0, pContext, pFilteringSink);
            pFilteringSink->Release();
        }
        else if (pDynastyToken)
        {
            //Get things which are hanging off these items and the item itself
            CCombiningSink* pCombiningSink = new CCombiningSink(pFilteringSink, WBEM_E_NOT_FOUND);
            if (pCombiningSink)
            {
	            pCombiningSink->AddRef();
	            // Guaranteed to be VT_BSTR
	            pNs->Exec_GetObject(V_BSTR(&(pDynastyToken->vConstValue)), 0, pContext, pCombiningSink);
	            pNs->Exec_CreateClassEnum(V_BSTR(&(pDynastyToken->vConstValue)), 0, pContext, pCombiningSink);
	            pCombiningSink->Release();
            }
            else
            {
                hres = WBEM_E_OUT_OF_MEMORY;
            }
        }
        else if (pThisToken)
        {
            CCombiningSink* pCombiningSink = new CCombiningSink(pFilteringSink, WBEM_E_NOT_FOUND);
            if (pCombiningSink)
            {
	            pCombiningSink->AddRef();

	            // Guaranteed to be VT_BSTR
	            pNs->Exec_GetObject(V_BSTR(&(pThisToken->vConstValue)), 0, pContext, pCombiningSink);
	            pNs->Exec_CreateClassEnum(V_BSTR(&(pThisToken->vConstValue)), 0, pContext, pCombiningSink);

	            pCombiningSink->Release();
            }
            else
            {
                hres = WBEM_E_OUT_OF_MEMORY;
            }            
        }
        else
        {
            //Something strange here!
            pFilteringSink->AddRef();
            pNs->Exec_CreateClassEnum(NULL, 0, pContext, pFilteringSink);
            pFilteringSink->Release();
        }
    }
    else
    {
        //We need to retrieve all of them and pass through the filter.
        pFilteringSink->AddRef();
        pNs->Exec_CreateClassEnum(NULL, 0, pContext, pFilteringSink);
        pFilteringSink->Release();
    }

    return hres;
}

// ****************************************************************************
//
//  CQueryEngine::ValidateQuery
//
//  This function makes sure that the data type of the property matches
//  that of the const.
//
// ****************************************************************************

HRESULT CQueryEngine::ValidateQuery(IN QL_LEVEL_1_RPN_EXPRESSION *pExpr,
                             IN CWbemClass *pClassDef)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    for(int i = 0; i < pExpr->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN Token = pExpr->pArrayOfTokens[i];
        if (Token.nTokenType == QL1_OP_EXPRESSION)
        {
            WBEM_WSTR wszCimType;
            VARIANT PropVal;
            VariantInit(&PropVal);

            // Make sure this property exists.
            // ===============================
            hr = pClassDef->GetPropertyValue(&Token.PropertyName, 0,
                                                    &wszCimType, &PropVal);

            // If we haven't found it, that's OK... it could
            // be a weakly-typed embedded object.

            if (FAILED(hr))
            {
                hr = WBEM_S_NO_ERROR;
                continue;
            }

            switch(Token.nOperator)
            {
                // These only apply to embedded objects.
            case QL1_OPERATOR_ISA:
            case QL1_OPERATOR_ISNOTA:
            case QL1_OPERATOR_INV_ISA:
            case QL1_OPERATOR_INV_ISNOTA:
                if(V_VT(&PropVal)!= VT_EMBEDDED_OBJECT)
                {
                    if (wszCimType != NULL)
                    {
                        wchar_t wszTemp[7];
                        wcsncpy(wszTemp, wszCimType, 6);
                        wszTemp[6] = '\0';
                        if (wcscmp(wszTemp, L"object"))
                            hr = WBEM_E_INVALID_QUERY;
                    }
                    else
                        hr = WBEM_E_INVALID_QUERY;

                    if (Token.vConstValue.vt == VT_NULL ||
                        Token.vConstValue.vt == VT_EMPTY)
                        hr = WBEM_E_INVALID_QUERY;
                }
                break;

            default:
                break;
            }

            VariantClear(&PropVal);
            WbemStringFree(wszCimType);

        }

        if (hr != WBEM_S_NO_ERROR)
            break;
    }

    // We don't support WITHIN!

    if (pExpr->Tolerance.m_bExact == FALSE)
    {
        hr = WBEM_E_INVALID_QUERY;
    }

    return hr;

}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CQueryEngine::ExecRepositoryQuery(
    IN CWbemNamespace *pNs,
    IN LPWSTR pszQuery,
    IN LONG lFlags,
    IN IWbemContext* pContext,
    IN CBasicObjectSink* pSink
    )
{
    HRESULT hRes;

    // Also, add check hierarchy for dynamic instances which need deleting
    // Should we simulate by a prior enum and then executing individual delete instance
    // calls?  Would be a big performance drain, possibly.

    hRes = CRepository::ExecQuery(pNs->GetNsSession(), pNs->GetScope(), pszQuery, pSink, 0);

    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\oldsec.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    OLDSEC.H

Abstract:

	defines various routines and classes used providing backward security support.

History:

	a-davj    02-sept-99  Created.

--*/

#ifndef _OLDSEC_H_
#define _OLDSEC_H_

//***************************************************************************
//
//  CCombinedAce
//
//  Since there might be several ACEs for a single user or group in the ACL, 
//  this structure is used to combine all the aces for a sid into one.
//
//***************************************************************************

struct CCombinedAce
{
    CCombinedAce(WCHAR *pwszName);
    ~CCombinedAce(){delete m_wcFullName;};
    void AddToMasks(CBaseAce * pAce);
    bool IsValidOldEntry(bool bIsGroup);
    HRESULT GetNames(LPWSTR & pwszAccount, LPWSTR &pwszDomain);

    DWORD m_dwAllow;
    DWORD m_dwDeny;
    bool m_BadAce;
    WCHAR  *m_wcFullName;
};

//***************************************************************************
//
//  OldSecList
//
//  The list of combined entries for the aces in the root namespace.  Note
//  that the list is of just the users, or just the groups.
//
//***************************************************************************

class OldSecList 
{
private:
    CFlexArray m_MergedAceList;
public:
    OldSecList(bool bGroupsOnly);    
    ~OldSecList();    
    int Size(){return m_MergedAceList.Size();};
    CCombinedAce * GetValidCombined(int iIndex, bool bGroup);
    CCombinedAce * GetValidCombined(LPWSTR pName, bool bGroup);

};

//***************************************************************************
//
//  RootSD
//
//  Holds a pointer to the root namespace and the flex array of aces.
//
//***************************************************************************

class RootSD
{
private:
    CWbemNamespace * m_pRoot;
    CFlexAceArray * m_pFlex;
    bool m_bOK;
public:
    RootSD();
    ~RootSD();
    bool IsOK(){return m_bOK;};
    CFlexAceArray * GetAceList(){return m_pFlex;};
    HRESULT StoreAceList();
    HRESULT RemoveMatchingEntries(LPWSTR pwszObjUserName);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\protoq.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    PROTOQ.CPP

Abstract:

    Prototype query support for WinMgmt Query Engine.
    This was split out from QENGINE.CPP for better source
    organization.

History:

    raymcc   04-Jul-99   Created.
    raymcc   14-Aug-99   Resubmit due to VSS problem.

--*/


#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>

#include <wbemcore.h>


//***************************************************************************
//
//  Local defs
//
//***************************************************************************


static HRESULT SelectColForClass(
    IN CWQLScanner & Parser,
    IN CFlexArray *pClassDefs,
    IN SWQLColRef *pColRef,
    IN int & nPosition
    );

static HRESULT AdjustClassDefs(
    IN  CFlexArray *pClassDefs,
    OUT IWbemClassObject **pRetNewClass
    );

static HRESULT GetUnaryPrototype(
    IN CWQLScanner & Parser,
    IN LPWSTR pszClass,
    IN LPWSTR pszAlias,
    IN CWbemNamespace *pNs,
    IN IWbemContext *pContext,
    IN CBasicObjectSink *pSink
    );

static HRESULT RetrieveClassDefs(
    IN CWQLScanner & Parser,
    IN CWbemNamespace *pNs,
    IN IWbemContext *pContext,
    IN CWStringArray & aAliasNames,
    OUT CFlexArray *pDefs
    );

static HRESULT ReleaseClassDefs(
    IN CFlexArray *pDefs
    );


//***************************************************************************
//
//  ExecPrototypeQuery
//
//  Called by CQueryEngine::ExecQuery for SMS-style prototypes.
//
//  Executes the query and returns only the class definition implied
//  by the query, whether a join or a simple class def.
//
//***************************************************************************

HRESULT ExecPrototypeQuery(
    IN CWbemNamespace *pNs,
    IN LPWSTR pszQuery,
    IN IWbemContext* pContext,
    IN CBasicObjectSink *pSink
    )
{
    HRESULT hRes;
    int nRes;
    CFlexArray aClassDefs;
    int i;

    if (pNs == NULL || pszQuery == NULL || wcslen(pszQuery) == 0 ||
        pSink == NULL)
            return pSink->Return(WBEM_E_INVALID_PARAMETER);

    // Parse the query and determine if it is a single class.
    // ======================================================

    CTextLexSource src(pszQuery);
    CWQLScanner Parser(&src);
    nRes = Parser.Parse();
    if (nRes != CWQLScanner::SUCCESS)
        return pSink->Return(WBEM_E_INVALID_QUERY);

    // If a single class definition, branch, since we don't
    // want to create a __GENERIC object.
    // ====================================================

    CWStringArray aAliases;
    Parser.GetReferencedAliases(aAliases);

    if (aAliases.Size() == 1)
    {
        LPWSTR pszClass = Parser.AliasToTable(aAliases[0]);
        return GetUnaryPrototype(Parser, pszClass, aAliases[0], pNs, pContext, pSink);
    }

    // If here, a join must have occurred.
    // ===================================

    hRes = RetrieveClassDefs(
        Parser,
        pNs,
        pContext,
        aAliases,
        &aClassDefs
        );

    if (hRes)
    {
        ReleaseClassDefs(&aClassDefs);
        return pSink->Return(WBEM_E_INVALID_QUERY);
    }

    // Iterate through all the properties selected.
    // ============================================

    const CFlexArray *pSelCols = Parser.GetSelectedColumns();

    if (pSelCols == 0)
    {
        ReleaseClassDefs(&aClassDefs);
        return pSink->Return(WBEM_E_FAILED);
    }

    int nPosSoFar = 0;
    for (i = 0; i < pSelCols->Size(); i++)
    {
        SWQLColRef *pColRef = (SWQLColRef *) pSelCols->GetAt(i);
        hRes = SelectColForClass(Parser, &aClassDefs, pColRef, nPosSoFar);

        if (hRes)
        {
            ReleaseClassDefs(&aClassDefs);
            return pSink->Return(hRes);
        }
    }

    // If here, we have the class definitions.
    // =======================================

    IWbemClassObject *pProtoInst = 0;
    AdjustClassDefs(&aClassDefs, &pProtoInst);

    pSink->Add(pProtoInst);
    pProtoInst->Release();

    ReleaseClassDefs(&aClassDefs);

    return pSink->Return(WBEM_NO_ERROR);
}

//***************************************************************************
//
//***************************************************************************

struct SelectedClass
{
    IWbemClassObject *m_pClassDef;
    WString           m_wsAlias;
    WString           m_wsClass;
    CWStringArray     m_aSelectedCols;
    BOOL              m_bAll;
    CFlexArray        m_aSelectedColsPos;

    void SetNamed(LPWSTR pName, int & nPos)
    {
        m_aSelectedCols.Add(pName);
#ifdef _WIN64
        m_aSelectedColsPos.Add(IntToPtr(nPos++));      // ok since we are really using safearray for dword 
#else
        m_aSelectedColsPos.Add((void *)nPos++);
#endif        
    };

    void SetAll(int & nPos);
    SelectedClass() { m_pClassDef = 0; m_bAll = FALSE; }
   ~SelectedClass() { if (m_pClassDef) m_pClassDef->Release(); }
};


void SelectedClass::SetAll(int & nPos)
{
    m_bAll = TRUE;

    // For each property, add an entry

    CWbemClass *pCls = (CWbemClass *)m_pClassDef;
    pCls->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);
    BSTR PropName;
    while (S_OK == pCls->Next(0, &PropName, NULL, NULL, NULL))
    {
        SetNamed(PropName, nPos);
        SysFreeString(PropName);
    }
    pCls->EndEnumeration();

};

//***************************************************************************
//
//***************************************************************************

static HRESULT RetrieveClassDefs(
    IN CWQLScanner & Parser,
    IN CWbemNamespace *pNs,
    IN IWbemContext *pContext,
    IN CWStringArray & aAliasNames,
    OUT CFlexArray *pDefs
    )
{
    for (int i = 0; i < aAliasNames.Size(); i++)
    {
        // Retrieve the class definition.
        // ==============================

        IWbemClassObject *pClassDef = 0;
        LPWSTR pszClass = Parser.AliasToTable(aAliasNames[i]);
        if (pszClass == 0)
            continue;

        HRESULT hRes = pNs->Exec_GetObjectByPath(pszClass, 0, pContext,
            &pClassDef, 0);

        if (FAILED(hRes))
            return hRes;

        SelectedClass *pSelClass = new SelectedClass;
        if (pSelClass == 0)
            return WBEM_E_OUT_OF_MEMORY;

        pSelClass->m_pClassDef = pClassDef;
        pSelClass->m_wsClass = pszClass;
        pSelClass->m_wsAlias = aAliasNames[i];

        pDefs->Add(pSelClass);
    }

    return WBEM_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

static HRESULT ReleaseClassDefs(
    IN CFlexArray *pDefs
    )
{
    for (int i = pDefs->Size()-1; i >= 0 ; i--)
    {
        SelectedClass *pSelClass = (SelectedClass *) pDefs->GetAt(i);
        delete pSelClass;
    }
    return WBEM_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************

static HRESULT SelectColForClass(
    IN CWQLScanner & Parser,
    IN CFlexArray *pClassDefs,
    IN SWQLColRef *pColRef,
    IN int & nPosition
    )
{
    int i;
    HRESULT hRes;

    if (!pColRef)
        return WBEM_E_FAILED;

    // If the column reference contains the class referenced
    // via an alias and there is no asterisk, we are all set.
    // ======================================================

    if (pColRef->m_pTableRef)
    {
        // We now have the class name. Let's find it and add
        // the referenced column for that class!
        // =================================================

        for (i = 0; i < pClassDefs->Size(); i++)
        {
            SelectedClass *pSelClass = (SelectedClass *) pClassDefs->GetAt(i);

            if (wbem_wcsicmp(LPWSTR(pSelClass->m_wsAlias), pColRef->m_pTableRef) != 0)
                continue;

            CWbemClass *pCls = (CWbemClass *) pSelClass->m_pClassDef;

            // See if the asterisk was used for this class.
            // =============================================

            if (pColRef->m_pColName[0] == L'*' && pColRef->m_pColName[1] == 0)
            {
                pSelClass->SetAll(nPosition);
                return WBEM_NO_ERROR;
            }

            // If here, a property was mentioned by name.
            // Verify that it exists.
            // ==========================================

            CVar Prop;
            hRes = pCls->GetProperty(pColRef->m_pColName, &Prop);
            if (hRes)
                return WBEM_E_INVALID_QUERY;

            // Mark it as seleted.
            // ===================

            pSelClass->SetNamed(pColRef->m_pColName, nPosition);

            return WBEM_NO_ERROR;
        }

        // If here, we couldn't locate the property in any class.
        // ======================================================

        return WBEM_E_INVALID_QUERY;
    }


    // Did we select * from all tables?
    // ================================

    if (pColRef->m_dwFlags & WQL_FLAG_ASTERISK)
    {
        for (i = 0; i < pClassDefs->Size(); i++)
        {
            SelectedClass *pSelClass = (SelectedClass *) pClassDefs->GetAt(i);
            pSelClass->SetAll(nPosition);
        }

        return WBEM_NO_ERROR;
    }


    // If here, we have an uncorrelated property and we have to find out
    // which class it belongs to.  If it belongs to more than one, we have
    // an ambiguous query.
    // ===================================================================

    DWORD dwTotalMatches = 0;

    for (i = 0; i < pClassDefs->Size(); i++)
    {
        SelectedClass *pSelClass = (SelectedClass *) pClassDefs->GetAt(i);
        CWbemClass *pCls = (CWbemClass *) pSelClass->m_pClassDef;

        // Try to locate the property in this class.
        // =========================================

        CVar Prop;
        hRes = pCls->GetProperty(pColRef->m_pColName, &Prop);

        if (hRes == 0)
        {
            pSelClass->SetNamed(pColRef->m_pColName, nPosition);
            dwTotalMatches++;
        }
    }

    // If more than one match occurred, we have an ambiguous query.
    // ============================================================

    if (dwTotalMatches != 1)
        return WBEM_E_INVALID_QUERY;

    return WBEM_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

HRESULT AddOrderQualifiers(
    CWbemClass *pCls,
    BSTR PropName,
    CFlexArray Matches
    )
{
    IWbemQualifierSet * pQual;
    SCODE sc = pCls->GetPropertyQualifierSet(PropName, &pQual);
    if(sc != S_OK)
        return sc;


    // Create a safe array

    SAFEARRAYBOUND aBounds[1];
    aBounds[0].lLbound = 0;
    aBounds[0].cElements = Matches.Size();

    SAFEARRAY* pArray = SafeArrayCreate(VT_I4, 1, aBounds);

    // Stuff the individual data pieces
    // ================================

    for(int nIndex = 0; nIndex < Matches.Size(); nIndex++)
    {
        long lPos = PtrToLong(Matches.GetAt(nIndex));
        sc = SafeArrayPutElement(pArray, (long*)&nIndex, &lPos);
    }

    VARIANT var;
    var.vt = VT_ARRAY | VT_I4;
    var.parray = pArray;

    BSTR Name = SysAllocString(L"Order");
    if (Name == 0)
        return WBEM_E_OUT_OF_MEMORY;
    sc = pQual->Put(Name, &var, 0);
    SysFreeString(Name);
    VariantClear(&var);
    pQual->Release();
    return sc;
}

//***************************************************************************
//
//***************************************************************************

HRESULT SetPropertyOrderQualifiers(
    SelectedClass *pSelClass
    )
{


    CWbemClass *pCls = (CWbemClass *) pSelClass->m_pClassDef;

    // Go through each property

    pCls->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);
    BSTR PropName;
    while (S_OK == pCls->Next(0, &PropName, NULL, NULL, NULL))
    {

        // Build up a list of properties that Match

        CFlexArray Matches;
        bool bAtLeastOne = false;
        for(int iCnt = 0; iCnt < pSelClass->m_aSelectedCols.Size(); iCnt++)
            if(!wbem_wcsicmp(pSelClass->m_aSelectedCols.GetAt(iCnt), PropName))
            {
                Matches.Add(pSelClass->m_aSelectedColsPos.GetAt(iCnt));
                bAtLeastOne = true;
            }

        if(bAtLeastOne)
            AddOrderQualifiers(pCls, PropName, Matches);

        SysFreeString(PropName);
    }
    pCls->EndEnumeration();
    return S_OK;
}


//***************************************************************************
//
//  AdjustClassDefs
//
//  After all class definitions have been retrieved, they are adjusted
//  to only have the properties required and combined into a __GENERIC
//  instance.
//
//***************************************************************************

static HRESULT AdjustClassDefs(
    IN  CFlexArray *pClassDefs,
    OUT IWbemClassObject **pRetNewClass
    )
{
    int i;
    HRESULT hRes;

    for (i = 0; i < pClassDefs->Size(); i++)
    {
        SelectedClass *pSelClass = (SelectedClass *) pClassDefs->GetAt(i);
        CWbemClass *pCls = (CWbemClass *) pSelClass->m_pClassDef;

        if (pSelClass->m_bAll)
        {
            SetPropertyOrderQualifiers(pSelClass);
            continue;
        }

        WString wsError = pCls->FindLimitationError(0, &pSelClass->m_aSelectedCols);

        if (wsError.Length() > 0)
            return WBEM_E_FAILED;

        // Map the limitaiton
        // ==================

        CLimitationMapping Map;
        BOOL bValid = pCls->MapLimitation(0, &pSelClass->m_aSelectedCols, &Map);

        if (!bValid)
            return WBEM_E_FAILED;

        CWbemClass* pStrippedClass = 0;
        hRes = pCls->GetLimitedVersion(&Map, &pStrippedClass);
        if(!FAILED(hRes))
        {
            pSelClass->m_pClassDef = pStrippedClass;
            SetPropertyOrderQualifiers(pSelClass);
            pCls->Release();
        }
    }

    // Count the number of objects that actually have properties

    int iNumObj = 0;
    for (i = 0; i < pClassDefs->Size(); i++)
    {
        SelectedClass *pSelClass = (SelectedClass *) pClassDefs->GetAt(i);
        CWbemObject *pObj = (CWbemObject *) pSelClass->m_pClassDef;
        if (pObj->GetNumProperties() > 0)
            iNumObj++;
    }

    // If there is just one object with properties, return it rather than the generic object

    if(iNumObj == 1)
        for (i = 0; i < pClassDefs->Size(); i++)
        {
            SelectedClass *pSelClass = (SelectedClass *) pClassDefs->GetAt(i);
            CWbemObject *pObj = (CWbemObject *) pSelClass->m_pClassDef;
            if (pObj->GetNumProperties() == 0)
                continue;
            // Return it.
            // ==========

            *pRetNewClass = pObj;
            pObj->AddRef();
            return WBEM_NO_ERROR;
        }


    // Prepare a __GENERIC class def.  We construct a dummy definition which
    // has properties named for each of the aliases used in the query.
    // =====================================================================

    CGenericClass *pNewClass = new CGenericClass;
    if (pNewClass == 0)
        return WBEM_E_OUT_OF_MEMORY;

    pNewClass->Init();

    for (i = 0; i < pClassDefs->Size(); i++)
    {
        SelectedClass *pSelClass = (SelectedClass *) pClassDefs->GetAt(i);
        CWbemObject *pObj = (CWbemObject *) pSelClass->m_pClassDef;

        if (pObj->GetNumProperties() == 0)
            continue;

        CVar vEmbeddedClass;
        vEmbeddedClass.SetAsNull();

        pNewClass->SetPropValue(pSelClass->m_wsAlias, &vEmbeddedClass,
            CIM_OBJECT);

        CVar vClassName;
        if (FAILED(pObj->GetClassName(&vClassName)))
        	throw CX_MemoryException();

        WString wsCimType = L"object:";
        wsCimType += vClassName.GetLPWSTR();
        CVar vCimType(VT_BSTR, wsCimType);

        pNewClass->SetPropQualifier(pSelClass->m_wsAlias, L"cimtype", 0,
                                            &vCimType);
    };

    // Spawn an instance of this class.
    // ================================

    CWbemInstance* pProtoInst = 0;
    pNewClass->SpawnInstance(0, (IWbemClassObject **) &pProtoInst);
    pNewClass->Release();

    // Now assign the properties to the embedded instances.
    // ====================================================

    for (i = 0; i < pClassDefs->Size(); i++)
    {
        SelectedClass *pSelClass = (SelectedClass *) pClassDefs->GetAt(i);
        CWbemClass *pCls = (CWbemClass *) pSelClass->m_pClassDef;

        if (pCls->GetNumProperties() == 0)
            continue;

        CVar vEmbedded;
        vEmbedded.SetEmbeddedObject((IWbemClassObject *) pCls);

        pProtoInst->SetPropValue(pSelClass->m_wsAlias, &vEmbedded, 0);
    };

    // Return it.
    // ==========

    *pRetNewClass = pProtoInst;

    return WBEM_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

static HRESULT GetUnaryPrototype(
    IN CWQLScanner & Parser,
    IN LPWSTR pszClass,
    IN LPWSTR pszAlias,
    IN CWbemNamespace *pNs,
    IN IWbemContext *pContext,
    IN CBasicObjectSink *pSink
    )
{
    int i;

    // Retrieve the class definition.
    // ==============================

    IWbemClassObject *pClassDef = 0;
    IWbemClassObject *pErrorObj = 0;

    HRESULT hRes = pNs->Exec_GetObjectByPath(pszClass, 0, pContext,
        &pClassDef, &pErrorObj);

    if (FAILED(hRes))
    {
        pSink->SetStatus(0, hRes, NULL, pErrorObj);
        if (pErrorObj)
            pErrorObj->Release();
        return S_OK;
    }

    if (pErrorObj)
        pErrorObj->Release();

    CWbemClass *pCls = (CWbemClass *) pClassDef;
    BOOL bKeepAll = FALSE;

    // This keeps track of the order in which columns are selected

    SelectedClass sel;
    int nPosition = 0;
    sel.m_pClassDef = pClassDef;
    pClassDef->AddRef();
    sel.m_wsClass = pszClass;

    // Go through all the columns and make sure that the properties are valid
    // ======================================================================

    const CFlexArray *pSelCols = Parser.GetSelectedColumns();
    if (pSelCols == 0)
        return pSink->Return(WBEM_E_FAILED);

    for (i = 0; i < pSelCols->Size(); i++)
    {
        SWQLColRef *pColRef = (SWQLColRef *) pSelCols->GetAt(i);

        if (pColRef->m_dwFlags & WQL_FLAG_ASTERISK)
        {
            bKeepAll = TRUE;
            sel.SetAll(nPosition);
            continue;
        }

        if (pColRef->m_pColName)
        {

            // check for the "select x.* from x" case

            if(pColRef->m_pColName[0] == L'*' && pColRef->m_pColName[1] == 0)
            {
                if (!_wcsicmp(pColRef->m_pTableRef, pszAlias))
                {
                    bKeepAll = TRUE;
                    sel.SetAll(nPosition);
                    continue;
                }
                else
                {
                    return pSink->Return(WBEM_E_INVALID_QUERY);
                }
            }

            // Verify that the class has it
            // ============================

            CIMTYPE ct;
            if(FAILED(pCls->GetPropertyType(pColRef->m_pColName, &ct)))
            {
                // No such property
                // ================

                return pSink->Return(WBEM_E_INVALID_QUERY);
            }
            sel.SetNamed(pColRef->m_pColName, nPosition);
        }
    }

    // Eliminate unreferenced columns from the query.
    // ==============================================

    CWStringArray aPropsToKeep;

    if(!bKeepAll)
    {
        // Move through each property in the class and
        // see if it is referenced.  If not, remove it.
        // ============================================

        int nNumProps = pCls->GetNumProperties();
        for (i = 0; i < nNumProps; i++)
        {
            CVar Prop;
            pCls->GetPropName(i, &Prop);

            // See if this name is used in the query.
            // ======================================

            for (int i2 = 0; i2 < pSelCols->Size(); i2++)
            {
                SWQLColRef *pColRef = (SWQLColRef *) pSelCols->GetAt(i2);

                if (pColRef->m_pColName && wbem_wcsicmp(Prop,
                    pColRef->m_pColName) == 0)
                    {
                        aPropsToKeep.Add((LPWSTR) Prop);
                        break;
                    }
            }
        }
    }

    // Now we have a list of properties to remove.
    // ===========================================

    if (!bKeepAll && aPropsToKeep.Size())
    {
        WString wsError = pCls->FindLimitationError(0, &aPropsToKeep);

        if (wsError.Length() > 0)
        {
            pClassDef->Release();
            return pSink->Return(WBEM_E_FAILED);
        }

        // Map the limitaiton
        // ==================

        CLimitationMapping Map;
        BOOL bValid = pCls->MapLimitation(0, &aPropsToKeep, &Map);

        if (!bValid)
        {
            pClassDef->Release();
            return pSink->Return(WBEM_E_FAILED);
        }

        CWbemClass* pNewStrippedClass = 0;
        hRes = pCls->GetLimitedVersion(&Map, &pNewStrippedClass);
        if(!FAILED(hRes))
        {
            pClassDef->Release();       // Once for creation
            pClassDef->Release();       // Once for for the copy in sel
            pClassDef = pNewStrippedClass;
            sel.m_pClassDef = pClassDef;
            pClassDef->AddRef();

        }
    }

    // Add the Order qualifier

    SetPropertyOrderQualifiers(&sel);

    // Return it.
    // ==========

    pSink->Add(pClassDef);

    pClassDef->Release();

    return pSink->Return(WBEM_NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\olesrvr.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    OLESRVR.CPP

Abstract:

    "Main" file for wbemcore.dll: implements all DLL entry points.

    Classes defined and implemeted:

        CWbemLocator

History:

    raymcc        16-Jul-96       Created.
    raymcc        05-May-97       Security extensions

--*/

#include "precomp.h"
#include <stdio.h>
#include <time.h>
#include <tchar.h>
#include <initguid.h>
#include <wbemcore.h>
#include <intprov.h>
#include <genutils.h>
#include <wbemint.h>
#include <windows.h>

// {A83EF168-CA8D-11d2-B33D-00104BCC4B4A}
DEFINE_GUID(CLSID_IntProv,
0xa83ef168, 0xca8d, 0x11d2, 0xb3, 0x3d, 0x0, 0x10, 0x4b, 0xcc, 0x4b, 0x4a);

LPTSTR g_pWorkDir = 0;
LPTSTR g_pDbDir = 0;
BOOL g_bDebugBreak = FALSE;
BOOL g_bLogging = FALSE;
LPTSTR g_szHotMofDirectory = 0;
DWORD g_dwQueueSize = 1;
HINSTANCE g_hInstance;
BOOL g_bDontAllowNewConnections = FALSE;
IWbemEventSubsystem_m4* g_pEss_m4 = NULL;
bool g_bDefaultMofLoadingNeeded = false;
IClassFactory* g_pContextFac = NULL;
IClassFactory* g_pPathFac = NULL;

void ShowObjectCounts();
bool IsNtSetupRunning();
extern "C" HRESULT APIENTRY Shutdown(BOOL bProcessShutdown, BOOL bIsSystemShutdown);
extern "C" HRESULT APIENTRY Reinitialize(DWORD dwReserved);


BOOL IsWhistlerPersonal ( ) ;
BOOL IsWhistlerProfessional ( ) ;
void UpdateArbitratorValues ( ) ;

//***************************************************************************
//
//  DllMain
//
//  Dll entry point function. Called when wbemcore.dll is loaded into memory.
//  Performs basic system initialization on startup and system shutdown on
//  unload. See ConfigMgr::InitSystem and ConfigMgr::Shutdown in cfgmgr.h for
//  more details.
//
//  PARAMETERS:
//
//      HINSTANCE hinstDLL      The handle to our DLL.
//      DWORD dwReason          DLL_PROCESS_ATTACH on load,
//                              DLL_PROCESS_DETACH on shutdown,
//                              DLL_THREAD_ATTACH/DLL_THREAD_DETACH otherwise.
//      LPVOID lpReserved       Reserved
//
//  RETURN VALUES:
//
//      TRUE is successful, FALSE if a fatal error occured.
//      NT behaves very ugly if FALSE is returned.
//
//***************************************************************************
BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hInstance = hinstDLL;
		DisableThreadLibraryCalls ( hinstDLL ) ;
     }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        DEBUGTRACE((LOG_WBEMCORE, "Core physically unloaded!\n"));
        HANDLE hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("WINMGMT_COREDLL_UNLOADED"));
        if(hEvent)
        {
            SetEvent(hEvent);
            CloseHandle(hEvent);
        }
    }

    return TRUE;
}



//***************************************************************************
//
//  class CFactory
//
//  Generic implementation of IClassFactory for CWbemLocator.
//
//  See Brockschmidt for details of IClassFactory interface.
//
//***************************************************************************

enum InitType {ENSURE_INIT, ENSURE_INIT_WAIT_FOR_CLIENT, OBJECT_HANDLES_OWN_INIT};

template<class TObj>
class CFactory : public IClassFactory
{

public:

    CFactory(BOOL bUser, InitType it);
    ~CFactory();

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IClassFactory members
    //
    STDMETHODIMP     CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP     LockServer(BOOL);
private:
    ULONG           m_cRef;
    InitType        m_it;
	BOOL            m_bUser;
};

/////////////////////////////////////////////////////////////////////////////
//
// Count number of objects and number of locks on this DLL.
//

static ULONG g_cObj = 0;
static ULONG g_cLock = 0;
long g_lInitCount = -1;  // 0 DURING INTIALIZATION, 1 OR MORE LATER ON!
static CWbemCriticalSection g_csInit;
bool g_bPreviousFail = false;
HRESULT g_hrLastEnsuredInitializeError = WBEM_S_NO_ERROR;

HRESULT EnsureInitialized()
{
    if(g_bPreviousFail)
        return g_hrLastEnsuredInitializeError;

	g_csInit.Enter();

    // If we have been shut down by WinMgmt, bail out.
    if(g_bDontAllowNewConnections)
    {
		g_csInit.Leave();
        return CO_E_SERVER_STOPPING;
    }

	//Check again!  Previous connection could have been holding us off, and
	//may have failed!
    if(g_bPreviousFail)
    {
        g_csInit.Leave();
        return g_hrLastEnsuredInitializeError;
    }


    HRESULT hres;

    if(InterlockedIncrement(&g_lInitCount) == 0)
    {
        // Initialize WINMGMT enough to exit the critical section
        // ====================================================

        try 
        {
            hres = ConfigMgr::InitSystem();
        } 
        catch (...) // this is OK :-(, it happened that bad repository got to here
        {
            ExceptionCounter c;        
            hres = WBEM_E_FAILED;
        }

        

        if(FAILED(hres))
        {
            g_bPreviousFail = true;
            ConfigMgr::FatalInitializationError(hres);
            g_hrLastEnsuredInitializeError = hres;
			g_csInit.Leave();
            return hres;
        }        
		g_csInit.Leave();

        // Get WINMGMT to run
        // ================

        hres = ConfigMgr::SetReady();
        if(FAILED(hres))
        {
            g_bPreviousFail = true;
            ConfigMgr::FatalInitializationError(hres);
            g_hrLastEnsuredInitializeError = hres;
            return hres;
        }

        InterlockedIncrement(&g_lInitCount);
        HANDLE hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("WINMGMT_COREDLL_LOADED"));
        if(hEvent)
        {
            SetEvent(hEvent);
            CloseHandle(hEvent);
        }

    }
    else
    {
        InterlockedDecrement(&g_lInitCount);
		g_csInit.Leave();
    }

    return S_OK;
}



//***************************************************************************
//
//  DllGetClassObject
//
//  Standard OLE In-Process Server entry point to return an class factory
//  instance. Before returning a class factory, this function performs an
//  additional round of initialization --- see ConfigMgr::SetReady in cfgmgr.h
//
//  PARAMETERS:
//
//      IN RECLSID rclsid   The CLSID of the object whose class factory is
//                          required.
//      IN REFIID riid      The interface required from the class factory.
//      OUT LPVOID* ppv     Destination for the class factory.
//
//  RETURNS:
//
//      S_OK                Success
//      E_NOINTERFACE       An interface other that IClassFactory was asked for
//      E_OUTOFMEMORY
//      E_FAILED            Initialization failed, or an unsupported clsid was
//                          asked for.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv
    )
{
#ifdef DBG
    if (ConfigMgr::DebugBreak())
        DebugBreak();
#endif

    HRESULT         hr;

    //
    // Check that we can provide the interface.
    //
    if (IID_IUnknown != riid && IID_IClassFactory != riid)
        return ResultFromScode(E_NOINTERFACE);

    IClassFactory *pFactory;

    //
    //  Verify the caller is asking for our type of object.
    //
    if (CLSID_InProcWbemLevel1Login == rclsid)
    {
        pFactory = new CFactory<CWbemLevel1Login>(TRUE, OBJECT_HANDLES_OWN_INIT);
    }
    else if(CLSID_ActualWbemAdministrativeLocator == rclsid)
    {
        pFactory = new CFactory<CWbemAdministrativeLocator>(FALSE, OBJECT_HANDLES_OWN_INIT);
    }
    else if(CLSID_ActualWbemAuthenticatedLocator == rclsid)
    {
        pFactory = new CFactory<CWbemAuthenticatedLocator>(TRUE, OBJECT_HANDLES_OWN_INIT);
    }
    else if(CLSID_ActualWbemUnauthenticatedLocator == rclsid)
    {
        pFactory = new CFactory<CWbemUnauthenticatedLocator>(TRUE, OBJECT_HANDLES_OWN_INIT);
    }
    else if(CLSID_IntProv == rclsid)
    {
        pFactory = new CFactory<CIntProv>(TRUE, ENSURE_INIT_WAIT_FOR_CLIENT);
    }
    else if(CLSID_IWmiCoreServices == rclsid)
    {
        pFactory = new CFactory<CCoreServices>(FALSE, ENSURE_INIT);
    }
    else
    {
        return E_FAIL;
    }

    if (!pFactory)
        return ResultFromScode(E_OUTOFMEMORY);

    hr = pFactory->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pFactory;

    return hr;
}

//***************************************************************************
//
//  DllCanUnloadNow
//
//  Standard OLE entry point for server shutdown request. Allows shutdown
//  only if no outstanding objects or locks are present.
//
//  RETURN VALUES:
//
//      S_OK        May unload now.
//      S_FALSE     May not.
//
//***************************************************************************
extern "C"
HRESULT APIENTRY DllCanUnloadNow(void)
{
    DEBUGTRACE((LOG_WBEMCORE,"DllCanUnloadNow was called\n"));
    if(!IsDcomEnabled())
        return S_FALSE;

    if(IsNtSetupRunning())
    {
        DEBUGTRACE((LOG_WBEMCORE, "DllCanUnloadNow is returning S_FALSE because setup is running\n"));
        return S_FALSE;
    }  
    if(gClientCounter.OkToUnload())
    {
        DEBUGTRACE((LOG_WBEMCORE, "DllCanUnloadNow is returning S_TRUE\n"));
        Shutdown(FALSE,FALSE); // NO Process , NO System
        return S_OK;
    }
    else
    {
        DEBUGTRACE((LOG_WBEMCORE, "DllCanUnloadNow is returning S_FALSE\n"));
        return S_FALSE;
    }
}

//***************************************************************************
//
//  UpdateBackupReg
//
//  Updates the backup default options in registry.
//
//  RETURN VALUES:
//
//***************************************************************************
void UpdateBackupReg()
{
    HKEY hKey = 0;

    if (RegOpenKey(HKEY_LOCAL_MACHINE, WBEM_REG_WINMGMT, &hKey) == ERROR_SUCCESS)
    {
        char szBuff[20];
        DWORD dwSize = sizeof(szBuff);
        unsigned long ulType = REG_SZ;
        if ((RegQueryValueEx(hKey, __TEXT("Backup Interval Threshold"), 0, &ulType, (unsigned char*)szBuff, &dwSize) == ERROR_SUCCESS) && (strcmp(szBuff, "60") == 0))
        {
            RegSetValueEx(hKey, __TEXT("Backup Interval Threshold"), 0, REG_SZ, (const BYTE*)(__TEXT("30")), (2+1) * sizeof(TCHAR));
        }
        RegCloseKey(hKey);
    }
}

//***************************************************************************
//
//  UpdateBackupReg
//
//  Updates the unchecked task count value for the arbitrator.
//
//  RETURN VALUES:
//
//***************************************************************************
#define ARB_DEFAULT_TASK_COUNT_LESSTHAN_SERVER			50
#define ARB_DEFAULT_TASK_COUNT_GREATERHAN_SERVER		250

void UpdateArbitratorValues ()
{
    HKEY hKey = 0;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, WBEM_REG_WINMGMT, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
    {
		DWORD dwValue = 0 ;
		DWORD dwSize = sizeof (DWORD)  ;
        DWORD ulType = 0 ;
        if ((RegQueryValueEx(hKey, __TEXT("Unchecked Task Count"), 0, &ulType, LPBYTE(&dwValue), &dwSize) == ERROR_SUCCESS) )
        {
			if ( !IsWhistlerPersonal ( ) && !IsWhistlerProfessional ( ) && ( dwValue == ARB_DEFAULT_TASK_COUNT_LESSTHAN_SERVER ) )
			{
				DWORD dwNewValue = ARB_DEFAULT_TASK_COUNT_GREATERHAN_SERVER ;
				RegSetValueEx(hKey, __TEXT("Unchecked Task Count"), 0, REG_DWORD, (const BYTE*)&dwNewValue, sizeof(DWORD));
			}
        }
		else
		{
			//
			// Registry key non-existent
			//
			if ( !IsWhistlerPersonal ( ) && !IsWhistlerProfessional ( ) )
			{
				DWORD dwNewValue = ARB_DEFAULT_TASK_COUNT_GREATERHAN_SERVER ;
				RegSetValueEx(hKey, __TEXT("Unchecked Task Count"), 0, REG_DWORD, (const BYTE*)&dwNewValue, sizeof(DWORD));
			}
			else
			{
				DWORD dwNewValue = ARB_DEFAULT_TASK_COUNT_LESSTHAN_SERVER ;
				RegSetValueEx(hKey, __TEXT("Unchecked Task Count"), 0, REG_DWORD, (const BYTE*)&dwNewValue, sizeof(DWORD));
			}
		}
        RegCloseKey(hKey);
    }
}


//***************************************************************************
//
//  BOOL IsWhistlerPersonal ()
//
//  Returns true if machine is running Whistler Personal
//
//
//***************************************************************************
BOOL IsWhistlerPersonal ()
{
	BOOL bRet = TRUE ;
	OSVERSIONINFOEXW verInfo ;
	verInfo.dwOSVersionInfoSize = sizeof ( OSVERSIONINFOEX ) ;

	if ( GetVersionExW ( (LPOSVERSIONINFOW) &verInfo ) == TRUE )
	{
		if ( ( verInfo.wSuiteMask != VER_SUITE_PERSONAL ) && ( verInfo.dwPlatformId == VER_PLATFORM_WIN32_NT ) )
		{
			bRet = FALSE ;
		}
	}

	return bRet ;
}



//***************************************************************************
//
//  BOOL IsWhistlerProfessional ()
//
//  Returns true if machine is running Whistler Professional
//
//
//***************************************************************************
BOOL IsWhistlerProfessional ()
{
	BOOL bRet = TRUE ;
	OSVERSIONINFOEXW verInfo ;
	verInfo.dwOSVersionInfoSize = sizeof ( OSVERSIONINFOEX ) ;

	if ( GetVersionExW ( (LPOSVERSIONINFOW) &verInfo ) == TRUE )
	{
		if ( ( verInfo.wProductType  != VER_NT_WORKSTATION ) && ( verInfo.dwPlatformId == VER_PLATFORM_WIN32_NT ) )
		{
			bRet = FALSE ;
		}
	}

	return bRet ;
}


//***************************************************************************
//
//  DllRegisterServer
//
//  Standard OLE entry point for registering the server.
//
//  RETURN VALUES:
//
//      S_OK        Registration was successful
//      E_FAIL      Registration failed.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllRegisterServer(void)
{
    TCHAR* szModel = (IsDcomEnabled() ? __TEXT("Both") : __TEXT("Apartment"));

    RegisterDLL(g_hInstance, CLSID_ActualWbemAdministrativeLocator, __TEXT(""), szModel,
                NULL);
    RegisterDLL(g_hInstance, CLSID_ActualWbemAuthenticatedLocator, __TEXT(""), szModel, NULL);
    RegisterDLL(g_hInstance, CLSID_ActualWbemUnauthenticatedLocator, __TEXT(""), szModel, NULL);
    RegisterDLL(g_hInstance, CLSID_InProcWbemLevel1Login, __TEXT(""), szModel, NULL);
    RegisterDLL(g_hInstance, CLSID_IntProv, __TEXT(""), szModel, NULL);
    RegisterDLL(g_hInstance, CLSID_IWmiCoreServices, __TEXT(""), szModel, NULL);

    // Write the setup time into the registry.  This isnt actually needed
    // by dcom, but the code did need to be stuck in some place which
    // is called upon setup

    long lRes;
    DWORD ignore;
    HKEY key;
    lRes = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                               WBEM_REG_WINMGMT,
                               NULL,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_READ | KEY_WRITE,
                               NULL,
                               &key,
                               &ignore);
    if(lRes == ERROR_SUCCESS)
    {
        SYSTEMTIME st;

        GetSystemTime(&st);     // get the gmt time
        TCHAR cTime[MAX_PATH];

        // convert to localized format!

        lRes = GetDateFormat(LOCALE_SYSTEM_DEFAULT, DATE_LONGDATE, &st,
                NULL, cTime, MAX_PATH);
        if(lRes)
        {
            _tcscat(cTime, __TEXT(" GMT"));
            lRes = RegSetValueEx(key, __TEXT("SetupDate"), 0, REG_SZ,
                                (BYTE *)cTime, (lstrlen(cTime)+1)  * sizeof(TCHAR));
        }

        lRes = GetTimeFormat(LOCALE_SYSTEM_DEFAULT, 0, &st,
                NULL, cTime, MAX_PATH);
        if(lRes)
        {
            lstrcat(cTime, __TEXT(" GMT"));
            lRes = RegSetValueEx(key, __TEXT("SetupTime"), 0, REG_SZ,
                                (BYTE *)cTime, (lstrlen(cTime)+1) * sizeof(TCHAR));

        }

        CloseHandle(key);
    }

    UpdateBackupReg();

	UpdateArbitratorValues ( ) ;

    return S_OK;
}

//***************************************************************************
//
//  DllUnregisterServer
//
//  Standard OLE entry point for unregistering the server.
//
//  RETURN VALUES:
//
//      S_OK        Unregistration was successful
//      E_FAIL      Unregistration failed.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllUnregisterServer(void)
{
    UnRegisterDLL(CLSID_ActualWbemAdministrativeLocator, NULL);
    UnRegisterDLL(CLSID_ActualWbemAuthenticatedLocator, NULL);
    UnRegisterDLL(CLSID_ActualWbemUnauthenticatedLocator, NULL);
    UnRegisterDLL(CLSID_InProcWbemLevel1Login, NULL);
    UnRegisterDLL(CLSID_IntProv, NULL);
    UnRegisterDLL(CLSID_IWmiCoreServices, NULL);

    HKEY hKey;
    long lRes = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                               WBEM_REG_WINMGMT,
                               0, KEY_ALL_ACCESS, &hKey);
    if(lRes == ERROR_SUCCESS)
    {
        RegDeleteValue(hKey, __TEXT("SetupDate"));
        RegDeleteValue(hKey, __TEXT("SetupTime"));
        RegCloseKey(hKey);
    }

    return S_OK;
}

static LONG ObjectTypeTable[MAX_OBJECT_TYPES] = { 0 };

void _ObjectCreated(DWORD dwType)
{
    InterlockedIncrement((LONG *) &g_cObj);
    InterlockedIncrement(&ObjectTypeTable[dwType]);
}

void _ObjectDestroyed(DWORD dwType)
{
    InterlockedDecrement((LONG *) &g_cObj);
    InterlockedDecrement(&ObjectTypeTable[dwType]);
}


//***************************************************************************
//
//  CFactory::CFactory
//
//  Constructs the class factory given the CLSID of the objects it is supposed
//  to create.
//
//***************************************************************************
template<class TObj>
CFactory<TObj>::CFactory(BOOL bUser, InitType it)
{
    DEBUGTRACE((LOG_WBEMCORE,"CFactory construct\n"));
    m_cRef = 0;
    m_bUser = bUser;
    m_it = it;
    _ObjectCreated(OBJECT_TYPE_FACTORY);

    // If this is not being used by a client, then dont add it to the client list

    if(bUser)
        gClientCounter.AddClientPtr(this, FACTORY);
}

//***************************************************************************
//
//  CFactory::~CFactory
//
//  Destructor.
//
//***************************************************************************
template<class TObj>
CFactory<TObj>::~CFactory()
{
    DEBUGTRACE((LOG_WBEMCORE,"CFactory destruct\n"));
    // nothing
    _ObjectDestroyed(OBJECT_TYPE_FACTORY);
    if(m_bUser)
        gClientCounter.RemoveClientPtr(this);
}

//***************************************************************************
//
//  CFactory::QueryInterface, AddRef and Release
//
//  Standard IUnknown methods.
//
//***************************************************************************
template<class TObj>
STDMETHODIMP CFactory<TObj>::QueryInterface(REFIID riid, LPVOID * ppv)
{
    *ppv = 0;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
    {
        *ppv = this;
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


template<class TObj>
ULONG CFactory<TObj>::AddRef()
{
    return ++m_cRef;
}


template<class TObj>
ULONG CFactory<TObj>::Release()
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}
//***************************************************************************
//
//  CFactory::CreateInstance
//
//  As mandated by IClassFactory, creates a new instance of its object
//  (CWbemLocator).
//
//  PARAMETERS:
//
//      LPUNKNOWN pUnkOuter     IUnknown of the aggregator. Must be NULL.
//      REFIID riid             Interface ID required.
//      LPVOID * ppvObj         Destination for the interface pointer.
//
//  RETURN VALUES:
//
//      S_OK                        Success
//      CLASS_E_NOAGGREGATION       pUnkOuter must be NULL
//      E_NOINTERFACE               No such interface supported.
//
//***************************************************************************

template<class TObj>
STDMETHODIMP CFactory<TObj>::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID * ppvObj)
{
    TObj* pObj;
    HRESULT  hr;

    //
    //  Defaults
    //
    *ppvObj=NULL;
    hr = ResultFromScode(E_OUTOFMEMORY);

	if(m_it == ENSURE_INIT || m_it == ENSURE_INIT_WAIT_FOR_CLIENT)
	{
		hr = EnsureInitialized();
		if(FAILED(hr)) return hr;

		if(m_it == ENSURE_INIT_WAIT_FOR_CLIENT)
		{
			// Wait until user-ready
			// =====================

			hr = ConfigMgr::WaitUntilClientReady();
			if(FAILED(hr)) return hr;
		}
	}
    //
    // We aren't supporting aggregation.
    //
    if (pUnkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    pObj = new TObj;
    if (!pObj)
        return hr;

    //
    //  Initialize the object and verify that it can return the
    //  interface in question.
    //
    hr = pObj->QueryInterface(riid, ppvObj);

    //
    // Kill the object if initial creation or Init failed.
    //
    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
//  CFactory::LockServer
//
//  Increments or decrements the lock count of the server. The DLL will not
//  unload while the lock count is positive.
//
//  PARAMETERS:
//
//      BOOL fLock      If TRUE, locks; otherwise, unlocks.
//
//  RETURN VALUES:
//
//      S_OK
//
//***************************************************************************
template<class TObj>
STDMETHODIMP CFactory<TObj>::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *) &g_cLock);
    else
        InterlockedDecrement((LONG *) &g_cLock);

    return NOERROR;
}


//***************************************************************************
//
//  ShowObjectCounts
//
//  Prints the number of outstanding objects of each category to the debug
//  output.
//
//***************************************************************************

void ShowObjectCounts()
{
    DEBUGTRACE((LOG_WBEMCORE,"---COM Object Ref Count Info---\n"));
    DEBUGTRACE((LOG_WBEMCORE,"Active Objects = %d\n", g_cObj));
    DEBUGTRACE((LOG_WBEMCORE,"Server locks   = %d\n", g_cLock));

    DEBUGTRACE((LOG_WBEMCORE,"Object counts by type:\n"));

    DEBUGTRACE((LOG_WBEMCORE,"IWbemLocator counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_LOCATOR]));
    DEBUGTRACE((LOG_WBEMCORE,"IWbemClassObject counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_CLSOBJ]));
    DEBUGTRACE((LOG_WBEMCORE,"IWbemServices counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_PROVIDER]));
    DEBUGTRACE((LOG_WBEMCORE,"IWbemQualifierSet counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_QUALIFIER]));
    DEBUGTRACE((LOG_WBEMCORE,"IWbemNotify counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_NOTIFY]));
    DEBUGTRACE((LOG_WBEMCORE,"IEnumWbemClassObject counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_OBJENUM]));
    DEBUGTRACE((LOG_WBEMCORE,"IClassFactory counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_FACTORY]));
    DEBUGTRACE((LOG_WBEMCORE,"IWbemLevel1Login counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_WBEMLOGIN]));

    DEBUGTRACE((LOG_WBEMCORE,"---End of ref count dump---\n"));
}

void WarnESSOfShutdown(LONG lSystemShutDown)
{
    try
    {
        if(g_lInitCount != -1)
        {
            IWbemEventSubsystem_m4* pEss = ConfigMgr::GetEssSink();
            if(pEss)
            {
                pEss->LastCallForCore(lSystemShutDown);
                pEss->Release();
            }
        }
    }
    catch(...)
    {
        ExceptionCounter c;    
    }
}

//
// we can have Shutdown called twice in a row, because
// DllCanUnloadNow will do that, once triggered by CoFreeUnusedLibraries
//

BOOL g_ShutdownCalled = FALSE;

extern "C"
HRESULT APIENTRY Shutdown(BOOL bProcessShutdown, BOOL bIsSystemShutdown)
{
    CEnterWbemCriticalSection enterCs(&g_csInit);

    if (g_ShutdownCalled) {
        return S_OK;
    } else {
        g_ShutdownCalled = TRUE;
    }
    
    if(bProcessShutdown)
    {
        WarnESSOfShutdown((LONG)bIsSystemShutdown);
    }
    
    if (!bIsSystemShutdown)
    {
        DEBUGTRACE((LOG_WBEMCORE, "OLESRVR Shutdown is called with %d\n",
                        bProcessShutdown));
    }

    if(g_lInitCount == -1)
    {
        if (!bIsSystemShutdown)
        {
            DEBUGTRACE((LOG_WBEMCORE,"\nWBEMCORE Shutdown was called while g_lInitCount was -1\n"));
        }
        return S_OK;
    }

    if(!bProcessShutdown)
        WarnESSOfShutdown((LONG)bIsSystemShutdown);

    g_lInitCount = -1;
    
    if (ConfigMgr::LoggingEnabled() == TRUE && !bIsSystemShutdown)
    {
        #ifdef TRACKING
        DEBUGTRACE(("\nTotal allocations before shutdow: %d\n",
                        DEBUG_TotalMemory()));
        #endif
    }

    ConfigMgr::Shutdown(bProcessShutdown,bIsSystemShutdown);

    if (!bIsSystemShutdown)
    {
	    ShowObjectCounts();
	    DEBUGTRACE((LOG_WBEMCORE,"\n****** WinMgmt Shutdown ******************\n\n"));
    }
    return S_OK;
}

extern "C" HRESULT APIENTRY Reinitialize(DWORD dwReserved)
{

	if(g_ShutdownCalled)
	{
        CEnterWbemCriticalSection enterCs(&g_csInit);
        if(g_ShutdownCalled == FALSE)
        	return S_OK;
	    g_bDebugBreak = FALSE;
	    g_dwQueueSize = 1;
	    g_pEss_m4 = NULL;
	    g_lInitCount = -1;
	    g_bDefaultMofLoadingNeeded = false;
	    g_bDontAllowNewConnections = FALSE;
	    g_bLogging = FALSE;
	    gClientCounter.Empty();
	    g_pContextFac = NULL;
	    g_pPathFac = NULL;
	    g_ShutdownCalled = FALSE;
		g_bPreviousFail = false;
		g_hrLastEnsuredInitializeError = WBEM_S_NO_ERROR;
    }
    return S_OK;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\sechelp.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    SECHELP.CPP

Abstract:

    Security Helper functions

History:

    raymcc  29-Apr-97   Created

--*/

#include "precomp.h"


#include <sechelp.h>
#include <md5wbem.h>

//***************************************************************************
//
//  WBEMSecurityHelp::ComputeMD5
//
//
//  Computes the MD5 digest of an arbitrary buffer.
//
//  Parameters:
//  pSrcBuffer      Points to the values to be digested.  Can be NULL or
//                  point to zero bytes as indicated in the next parameter.
//  nArrayLength    The number of bytes to be digested.  Can be zero.
//  pMD5Digest      Receives a pointer to memory allocated by operator new.
//                  The caller becomes the owner of the memory which must
//                  be deallocated by operator delete.
//
//  Return value:
//  NoError         Always succeeds.
//
//***************************************************************************

int WBEMSecurityHelp::ComputeMD5(
    LPBYTE pSrcBuffer,         
    int    nArrayLength,
    LPBYTE *pMD5Digest         
    )
{
    BYTE *pMem = new BYTE[16];

    MD5::Transform(pSrcBuffer, nArrayLength, pMem);

    *pMD5Digest = pMem;

    return NoError;    
}

//***************************************************************************
//
//  WBEMSecurityHelp::MakeWBEMAccessToken
//
//  Converts a plaintext password and a WBEM nonce into a WBEM Access Token.
//
//  Parameters:
//    pNonce          A pointer to a WBEM Nonce (a 16-byte array).
//    pszPassword     A pointer to a UNICODE password, which can be zero length
//                    or the pointer itself can be NULL.
//    pAccessToken    Receives the newly allocated access token if NoError
//                    is returned.  Use operator delete to deallocate the 
//                    token.
//
//  Return value:
//    NoError            
//    InvalidParameter
//  
//***************************************************************************
int WBEMSecurityHelp::MakeWBEMAccessToken(
    LPBYTE pNonce,             
    LPWSTR pszPassword,        
    LPBYTE *pAccessToken       
    )
{
    if (pNonce == NULL || pAccessToken == NULL)
        return InvalidParameter;

    // Digest the password.
    // ====================
    LPBYTE pWorkingDigest = 0;
    int nPassLen = 0;
    if (pszPassword)
        nPassLen = wcslen(pszPassword) * 2;

    ComputeMD5(
        (LPBYTE) pszPassword,
        nPassLen,
        &pWorkingDigest
        );

    int nRes = MakeWBEMAccessTokenFromMD5(pNonce, pWorkingDigest, pAccessToken);
    delete [] pWorkingDigest;
    return nRes;
}


//***************************************************************************
//
//***************************************************************************

int WBEMSecurityHelp::MakeWBEMAccessTokenFromMD5(
    LPBYTE pNonce,                 
    LPBYTE pPasswordDigest,        
    LPBYTE *pAccessToken       
    )
{
    BYTE pXOR[16];

    // XOR the digest with the nonce.
    // ==============================
    for (int i = 0; i < 16; i++)
        pXOR[i] = pPasswordDigest[i] ^ pNonce[i];

    // Digest the result.
    // ==================
    LPBYTE pResult = 0;

    ComputeMD5(
        pXOR,
        16,
        &pResult
        );

    *pAccessToken = pResult;

    return NoError;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\refrcach.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    REFRCACH.CPP

Abstract:

    Refresher Server Side Implementation

History:

--*/

#include "precomp.h"
#include <wbemcore.h>

//*****************************************************************************
//*****************************************************************************
//                         OBJECT REQUEST RECORD
//*****************************************************************************
//*****************************************************************************

CRefresherCache::CObjectRequestRecord::CObjectRequestRecord(
        long lExternalRequestId,
        CWbemObject* pRefreshedObject,
        long lProviderRequestId)
    : 
        CRequestRecord(lExternalRequestId), 
        m_pRefreshedObject(pRefreshedObject),
        m_lInternalRequestId(lProviderRequestId)
{
    if(m_pRefreshedObject)
        m_pRefreshedObject->AddRef();
}
        
HRESULT CRefresherCache::CObjectRequestRecord::Cancel(
                                CProviderRecord* pContainer)
{
    return pContainer->Cancel(m_lInternalRequestId);
}

CRefresherCache::CObjectRequestRecord::~CObjectRequestRecord()
{
    if(m_pRefreshedObject)
        m_pRefreshedObject->Release();
}

//*****************************************************************************
//*****************************************************************************
//                         ENUM REQUEST RECORD
//*****************************************************************************
//*****************************************************************************

CRefresherCache::CEnumRequestRecord::CEnumRequestRecord(
        long lExternalRequestId,
        CRemoteHiPerfEnum* pHPEnum,
        long lProviderRequestId)
    : 
        CRequestRecord(lExternalRequestId), 
        m_pHPEnum(pHPEnum),
        m_lInternalRequestId(lProviderRequestId)
{
    if(m_pHPEnum)
        m_pHPEnum->AddRef();
}
        
HRESULT CRefresherCache::CEnumRequestRecord::Cancel(
                                CProviderRecord* pContainer)
{
    return pContainer->Cancel(m_lInternalRequestId);
}

CRefresherCache::CEnumRequestRecord::~CEnumRequestRecord()
{
    if(m_pHPEnum)
        m_pHPEnum->Release();
}

//*****************************************************************************
//*****************************************************************************
//                              PROVIDER RECORD
//*****************************************************************************
//*****************************************************************************

CRefresherCache::CProviderRecord::CProviderRecord(
            CCommonProviderCacheRecord* pProviderCacheRecord, 
            IWbemRefresher* pRefresher, CWbemNamespace* pNamespace)
    : m_pProviderCacheRecord(pProviderCacheRecord), 
        m_pProvider(NULL), 
        m_pInternalRefresher(pRefresher), m_pNamespace(pNamespace), m_cs()
{
    if(m_pProviderCacheRecord)
    {
        m_pProviderCacheRecord->AddRef();
        m_pProvider = pProviderCacheRecord->GetHiPerf();
    }
    if(m_pProvider)
        m_pProvider->AddRef();
    if(m_pInternalRefresher)
        m_pInternalRefresher->AddRef();
    if(m_pNamespace)
        m_pNamespace->AddRef();
}

CRefresherCache::CProviderRecord::~CProviderRecord()
{
    if(m_pProviderCacheRecord)
        m_pProviderCacheRecord->Release();
    if(m_pProvider)
        m_pProvider->Release();
    if(m_pInternalRefresher)
        m_pInternalRefresher->Release();
    if(m_pNamespace)
        m_pNamespace->Release();
}

HRESULT CRefresherCache::CProviderRecord::AddObjectRequest(
            CWbemObject* pRefreshedObject, long lProviderRequestId, long lNewId)
{
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    CObjectRequestRecord* pRequest = NULL;

    // Watch for OOM exceptions
    try
    {
        pRequest = new CObjectRequestRecord(lNewId, pRefreshedObject, lProviderRequestId);
        m_apRequests.Add(pRequest);
        return WBEM_S_NO_ERROR;
    }
    catch( CX_MemoryException )
    {
        if ( NULL != pRequest )
        {
            delete pRequest;
        }
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        if ( NULL != pRequest )
        {
            delete pRequest;
        }
        return WBEM_E_FAILED;
    }

}

HRESULT CRefresherCache::CProviderRecord::AddEnumRequest(
            CRemoteHiPerfEnum* pHPEnum, long lProviderRequestId, long lNewId )
{
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    CEnumRequestRecord* pRequest = NULL;


    // Watch for OOM exceptions
    try
    {
        pRequest = new CEnumRequestRecord(lNewId, pHPEnum, lProviderRequestId);
        m_apEnumRequests.Add(pRequest);
        return WBEM_S_NO_ERROR;
    }
    catch( CX_MemoryException )
    {
        if ( NULL != pRequest )
        {
            delete pRequest;
        }
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        if ( NULL != pRequest )
        {
            delete pRequest;
        }
        return WBEM_E_FAILED;
    }

}
    
HRESULT CRefresherCache::CProviderRecord::Remove(long lId, BOOL* pfIsEnum )
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    // Need to know if we axed an enumerator or an actual object
    *pfIsEnum = FALSE;

    // Check object requests, then enum requests
    for(int i = 0; i < m_apRequests.GetSize(); i++)
    {
        CObjectRequestRecord* pRequest = m_apRequests[i];
        if(pRequest->GetExternalRequestId() == lId)
        {
            hres = pRequest->Cancel(this);
            m_apRequests.RemoveAt(i);
            return hres;
        }
    }

    for(i = 0; i < m_apEnumRequests.GetSize(); i++)
    {
        CEnumRequestRecord* pRequest = m_apEnumRequests[i];
        if(pRequest->GetExternalRequestId() == lId)
        {
            hres = pRequest->Cancel(this);
            m_apEnumRequests.RemoveAt(i);
            *pfIsEnum = TRUE;
            return hres;
        }
    }

    return WBEM_S_FALSE;
}

HRESULT CRefresherCache::CProviderRecord::Find( long lId )
{
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    // Check object requests, then enum requests
    for(int i = 0; i < m_apRequests.GetSize(); i++)
    {
        CObjectRequestRecord* pRequest = m_apRequests[i];
        if(pRequest->GetExternalRequestId() == lId)
        {
            return WBEM_S_NO_ERROR;
        }
    }

    for(i = 0; i < m_apEnumRequests.GetSize(); i++)
    {
        CEnumRequestRecord* pRequest = m_apEnumRequests[i];
        if(pRequest->GetExternalRequestId() == lId)
        {
            return WBEM_S_NO_ERROR;
        }
    }

    return WBEM_S_FALSE;
}

HRESULT CRefresherCache::CProviderRecord::Cancel(long lId)
{
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    if(m_pProvider)
    {
        // Watch for any exceptions that may get thrown
        try
        {
            return m_pProvider->StopRefreshing(m_pInternalRefresher, lId, 0);
        }
        catch(...)
        {
            return WBEM_E_PROVIDER_FAILURE;
        }
    }

    return WBEM_S_FALSE;
}

HRESULT CRefresherCache::CProviderRecord::Refresh(long lFlags)
{
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    if(m_pInternalRefresher)
    {
        try
        {
            return m_pInternalRefresher->Refresh(0L);
        }
        catch(...)
        {
            // The provider threw an exception.  Just return and let scoping
            // release anything we may be holding onto.

            return WBEM_E_PROVIDER_FAILURE;
        }
    }
    else 
        return WBEM_S_NO_ERROR;
}

HRESULT CRefresherCache::CProviderRecord::Store(
            WBEM_REFRESHED_OBJECT* aObjects, long* plIndex)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    // Error out if anything beefs

    // First handle the single objects, then we'll get the
    // enumerations
    for(int i = 0; SUCCEEDED( hres ) && i < m_apRequests.GetSize(); i++)
    {
        CObjectRequestRecord* pRequest = m_apRequests[i];
        CWbemInstance* pInst = (CWbemInstance*)pRequest->GetRefreshedObject();
        WBEM_REFRESHED_OBJECT* pRefreshed = aObjects + *plIndex;

        hres = pInst->GetTransferBlob(&(pRefreshed->m_lBlobType), 
                &(pRefreshed->m_lBlobLength), &(pRefreshed->m_pbBlob));

        if ( SUCCEEDED( hres ) )
        {
            pRefreshed->m_lRequestId = pRequest->GetExternalRequestId();
            (*plIndex)++;
        }
        else
        {
            // Clear all data in case of failure
            ZeroMemory( pRefreshed, sizeof(WBEM_REFRESHED_OBJECT) );
        }
    }

    // Now handle the enumerations.  Each enum will create an array
    // of BLOBs
    for( i = 0; SUCCEEDED( hres ) && i < m_apEnumRequests.GetSize(); i++)
    {
        CEnumRequestRecord* pRequest = m_apEnumRequests[i];

        WBEM_REFRESHED_OBJECT* pRefreshed = aObjects + *plIndex;
        hres = pRequest->GetEnum()->GetTransferArrayBlob( &(pRefreshed->m_lBlobType), 
                    &(pRefreshed->m_lBlobLength), &(pRefreshed->m_pbBlob) );

        if ( SUCCEEDED( hres ) )
        {
            pRefreshed->m_lRequestId = pRequest->GetExternalRequestId();
            (*plIndex)++;
        }
        else
        {
            // Clear all data in case of failure
            ZeroMemory( pRefreshed, sizeof(WBEM_REFRESHED_OBJECT) );
        }

    }

    // We need to cleanup any allocated sub-blobs now
    if ( FAILED( hres ) )
    {
        for ( int x = 0; x < *plIndex; x++ )
        {
            WBEM_REFRESHED_OBJECT* pRefreshed = aObjects + x;

            if ( NULL != pRefreshed->m_pbBlob )
            {
                CoTaskMemFree( pRefreshed->m_pbBlob );
                pRefreshed->m_pbBlob = NULL;
            }

        }   // FOR x

    }   // IF FAILED(hres


    return hres;
}

//*****************************************************************************
//*****************************************************************************
//                          REFRESHER RECORD
//*****************************************************************************
//*****************************************************************************

CRefresherCache::CRefresherRecord::CRefresherRecord(const WBEM_REFRESHER_ID& Id)
    : m_Id(Id), m_lRefCount(0), m_lNumObjects(0), m_lNumEnums(0), m_lLastId( 0 ), m_cs()
{
    // We need a guid to uniquely identify this bad boy for remote auto-connect
    CoCreateGuid( &m_Guid );
}


INTERNAL HRESULT CRefresherCache::CRefresherRecord::
AddProvider(CCommonProviderCacheRecord* pProviderCacheRecord, 
            IWbemRefresher* pRefresher, CWbemNamespace* pNamespace,
            CRefresherCache::CProviderRecord** ppRecord )
{
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    CProviderRecord* pProvRecord = NULL;

    // Watch for memory exceptions
    try
    {
        pProvRecord = new CProviderRecord(pProviderCacheRecord, pRefresher, pNamespace);
        m_apProviders.Add(pProvRecord);
        *ppRecord = pProvRecord;
        return WBEM_S_NO_ERROR;
    }
    catch( CX_MemoryException )
    {
        if ( NULL != pProvRecord )
        {
            delete pProvRecord;
        }

        return WBEM_E_OUT_OF_MEMORY;
    }
    catch( ... )
    {
        if ( NULL != pProvRecord )
        {
            delete pProvRecord;
        }

        return WBEM_E_FAILED;
    }

}

INTERNAL CRefresherCache::CProviderRecord* CRefresherCache::CRefresherRecord::
FindProviderRecord(CCommonProviderCacheRecord* pProviderCacheRecord)
{
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    for(int i = 0; i < m_apProviders.GetSize(); i++)
    {
        CProviderRecord* pProvRecord = m_apProviders[i];
        if(pProvRecord->GetCacheRecord() == pProviderCacheRecord)
            return pProvRecord;
    }
    return NULL;
}
    

HRESULT CRefresherCache::CRefresherRecord::Remove(long lId)
{
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    // Find it first
    // =============

    for(int i = 0; i < m_apProviders.GetSize(); i++)
    {
        CProviderRecord* pProvRecord = m_apProviders[i];
        BOOL    fIsEnum = FALSE;
        HRESULT hres = pProvRecord->Remove( lId, &fIsEnum );

        if(hres == WBEM_S_FALSE) continue;
        if(FAILED(hres)) return hres;
    
        // Found it
        // ========

        if(pProvRecord->IsEmpty())
            m_apProviders.RemoveAt(i);

        // Decrememt the proper counter
        if ( fIsEnum )
        {
            m_lNumEnums--;
        }
        else
        {
            m_lNumObjects--;
        }

        return WBEM_S_NO_ERROR;
    }
    return WBEM_S_FALSE;
}
    
ULONG STDMETHODCALLTYPE CRefresherCache::CRefresherRecord::AddRef()
{
    int x = 1;
    return InterlockedIncrement(&m_lRefCount);
}

ULONG STDMETHODCALLTYPE CRefresherCache::CRefresherRecord::Release()
{
    long lRef = InterlockedDecrement(&m_lRefCount);
    if(lRef == 0)
    {
        // The remove call will check that this guy has really been released
        // before axing him.  All functions go through FindRefresherRecord()
        // to get a record, which blocks on the same critical section as
        // remove.  Since it AddRef()s the record before it returns, we
        // are ensured that if a client requests the same record
        // twice and one operation fails, releasing its object, before the
        // other has returned from a Find, that the ref count will get
        // bumped up again, so IsReleased() will fail, and the record won't
        // really be removed.

        ConfigMgr::GetRefresherCache()->RemoveRefresherRecord(this); // deletes
    }
    return lRef;
}

STDMETHODIMP CRefresherCache::CRefresherRecord::QueryInterface(REFIID riid, 
                                                            void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemRemoteRefresher)
    {
        AddRef();
        *ppv = (IWbemRemoteRefresher*)this;
        return S_OK;
    }
    else if(riid == IID_IWbemRefresher)
    {
        AddRef();
        *ppv = (IWbemRefresher*)this;
        return S_OK;
    }
    else return E_NOINTERFACE;
}

STDMETHODIMP CRefresherCache::CRefresherRecord::Refresh(long lFlags)
{
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    // Go through all our providers and refresh them
    // =============================================

    long lObjectIndex = 0;
    HRESULT hres;
    for(int i = 0; i < m_apProviders.GetSize(); i++)  
    {
        CProviderRecord* pProvRecord = m_apProviders[i];
        hres = pProvRecord->Refresh(lFlags);
        if(FAILED(hres)) return hres;
    }

    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CRefresherCache::CRefresherRecord::RemoteRefresh(
                                    long lFlags, long* plNumObjects, 
                                    WBEM_REFRESHED_OBJECT** paObjects)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    // Use CoTaskMemAlloc()?
    if(paObjects)
    {
        // Original code
        //*paObjects = new WBEM_REFRESHED_OBJECT[m_lNumObjects];
        *paObjects = (WBEM_REFRESHED_OBJECT*) CoTaskMemAlloc( ( m_lNumObjects + m_lNumEnums ) * sizeof(WBEM_REFRESHED_OBJECT));

        if ( NULL != *paObjects )
        {
            // Zero out the BLOB
            ZeroMemory( *paObjects, ( m_lNumObjects + m_lNumEnums ) * sizeof(WBEM_REFRESHED_OBJECT) );
        }
        else
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    // This value needs to reflect the number of objects as well as the number of enumerators we are shipping
    // back to the client.

    if(plNumObjects)
    {
        *plNumObjects = m_lNumObjects + m_lNumEnums;
    }

    // Go through all our providers and refresh them
    // =============================================

    long    lObjectIndex = 0;
    HRESULT hrFirstRefresh = WBEM_S_NO_ERROR;
    BOOL    fOneSuccess = FALSE;
    BOOL    fOneRefresh = FALSE;
    BOOL    fPartialSuccess = FALSE;

    for(int i = 0; i < m_apProviders.GetSize(); i++)  
    {
        CProviderRecord* pProvRecord = m_apProviders[i];
        hres = pProvRecord->Refresh(lFlags);
    
        if ( SUCCEEDED( hres ) )
        {
            if(paObjects)
            {
                // Store the result
                // ================

                hres = pProvRecord->Store(*paObjects, &lObjectIndex);

                // If this fails, we will consider this catastrophic, since the
                // only reason this would fail is under out of memory conditions,
                // and in that case, since we are remoting, all sorts of things
                // could go wrong, so if this breaks, just cleanup and bail out.

                if ( FAILED( hres ) )
                {
                    if ( *paObjects )
                    {
                        CoTaskMemFree( *paObjects );
                        *paObjects = NULL;
                    }
                    
                    *plNumObjects = 0;

                    return hres;
                }

            }   // IF NULL != paObjects

        }   // IF Refresh Succeeded

        // Always keep the first return code.  We also need to track
        // whether or not we had at least one success, as well as if
        // the partial flag should be set.

        if ( !fOneRefresh )
        {
            fOneRefresh = TRUE;
            hrFirstRefresh = hres;
        }

        // All other codes indicate something went awry
        if ( WBEM_S_NO_ERROR == hres )
        {
            fOneSuccess = TRUE;

            // A prior refresh may have failed, a later one didn't
            if ( fOneRefresh && WBEM_S_NO_ERROR != hrFirstRefresh )
            {
                fPartialSuccess = TRUE;
            }
        }
        else if ( fOneSuccess )
        {
            // We must have had at least one success for the partial success
            // flag to be set.

            fPartialSuccess = TRUE;
        }

    }   // FOR enum providers

    // At this point, if the partial success flag is set, that will
    // be our return.  If we didn't have at least one success,  then
    // the return code will be the first one we got back. Otherwise,
    // hres should contain the proper value

    if ( fPartialSuccess )
    {
        hres = WBEM_S_PARTIAL_RESULTS;
    }
    else if ( !fOneSuccess )
    {
        hres = hrFirstRefresh;
    }

    // Finally, if the object index is less than the number of array elements we "thought"
    // we would be sending back, make sure we reflect this.  If it is zero, just delete the
    // elements (we wouldn't have allocated any sub-buffers anyway).  Since
    // *plNumObjects is a sizeof, only *plNumObjects elements will be sent back, although
    // CoTaskMemFree() should cleanup the entire array buffer.

    if ( lObjectIndex != *plNumObjects )
    {
        *plNumObjects = lObjectIndex;

        if ( 0 == lObjectIndex )
        {
            if ( *paObjects )
            {
                CoTaskMemFree( *paObjects );
                *paObjects = NULL;
            }

        }

    }

    return hres;
}
            
STDMETHODIMP CRefresherCache::CRefresherRecord::StopRefreshing(
                        long lNumIds, long* aplIds, long lFlags)
{
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    HRESULT hr = WBEM_S_NO_ERROR;
    HRESULT hrFirst = WBEM_S_NO_ERROR;
    BOOL    fOneSuccess = FALSE;
    BOOL    fOneRemove = FALSE;
    BOOL    fPartialSuccess = FALSE;

    for ( long lCtr = 0; lCtr < lNumIds; lCtr++ )
    {
        hr = Remove( aplIds[lCtr] );

        if ( !fOneRemove )
        {
            hrFirst = hr;
            fOneRemove = TRUE;
        }

        // Record the fact we got at least one success if we got one
        // All other codes indicate something went awry
        if ( WBEM_S_NO_ERROR == hr )
        {
            fOneSuccess = TRUE;

            // A prior refresh may have failed, a later one didn't
            if ( fOneRemove && WBEM_S_NO_ERROR != hrFirst )
            {
                fPartialSuccess = TRUE;
            }
        }
        else if ( fOneSuccess )
        {
            // We must have had at least one success for the partial success
            // flag to be set.

            fPartialSuccess = TRUE;
        }

    }   // FOR enum ids

    // At this point, if the partial success flag is set, that will
    // be our return.  If we didn't have at least one success,  then
    // the return code will be the first one we got back. Otherwise,
    // hres should contain the proper value

    if ( fPartialSuccess )
    {
        hr = WBEM_S_PARTIAL_RESULTS;
    }
    else if ( !fOneSuccess )
    {
        hr = hrFirst;
    }

    return hr;
}

STDMETHODIMP CRefresherCache::CRefresherRecord::GetGuid(
                        long lFlags, GUID* pGuid )
{
    
    if ( 0L != lFlags || NULL == pGuid )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *pGuid = m_Guid;

    return WBEM_S_NO_ERROR;

}



//*****************************************************************************
//*****************************************************************************
//                              REMOTE RECORD
//*****************************************************************************
//*****************************************************************************

CRefresherCache::CRemoteRecord::CRemoteRecord(const WBEM_REFRESHER_ID& Id)
    : CRefresherRecord(Id)
{
}

CRefresherCache::CRemoteRecord::~CRemoteRecord()
{
}

HRESULT CRefresherCache::CRemoteRecord::GetProviderRefreshInfo(
                                CCommonProviderCacheRecord* pProviderCacheRecord,
                                CWbemNamespace* pNamespace,
                                CProviderRecord** ppProvRecord,
                                IWbemRefresher** ppRefresher )
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Get a refresher from the provider, unless already available
    // ===========================================================

    *ppProvRecord = FindProviderRecord(pProviderCacheRecord);

    // We couldn't find the record so make sure we are able to get a refresher
    if ( NULL == *ppProvRecord )
    {
        try
        {
            hres = pProviderCacheRecord->GetHiPerf()->CreateRefresher(
                                                pNamespace, 0, ppRefresher);

            if ( SUCCEEDED(hres) && NULL == *ppRefresher )
            {
                hres = WBEM_E_PROVIDER_FAILURE;
            }
        }
        catch(...)
        {
            // The provider threw an exception.  Just return and let scoping
            // release anything we may be holding onto.

            return WBEM_E_PROVIDER_FAILURE;
        }
    }
    else
    {
        // Get the refresher pointer and AddRef it
        *ppRefresher = (*ppProvRecord)->GetInternalRefresher();
        if(*ppRefresher)
        {
            (*ppRefresher)->AddRef();
        }
    }

    return hres;
}

HRESULT CRefresherCache::CRemoteRecord::AddObjectRefresher(
                    CCommonProviderCacheRecord* pProviderCacheRecord, 
                    CWbemNamespace* pNamespace,
                    CWbemObject* pInstTemplate, long lFlags, 
                    IWbemContext* pContext,
                    CRefreshInfo* pInfo)
{
    // Enters and Leaves as a byproduct of scoping
    CInCritSec  ics(&m_cs);

    // Get a refresher from the provider, unless already available
    // ===========================================================

    IWbemRefresher* pProvRefresher = NULL;
    CProviderRecord* pProvRecord = NULL;

    HRESULT hres = GetProviderRefreshInfo( pProviderCacheRecord, pNamespace, &pProvRecord, &pProvRefresher );

    // Always release going out of scope
    CReleaseMe  rmRefresh( pProvRefresher );

    if ( SUCCEEDED( hres ) )
    {
        // Call provider for information
        // =============================

        IWbemObjectAccess* pRefreshedOA = NULL;
        long lProvRequestId;

        // Now try to add the object

        try
        {
            hres = pProviderCacheRecord->GetHiPerf()->CreateRefreshableObject(
                    pNamespace, pInstTemplate, pProvRefresher,
                    0, pContext, &pRefreshedOA,
                    &lProvRequestId);
        }
        catch(...)
        {
            // The provider threw an exception.  Just return and let scoping
            // release anything we may be holding onto.

            return WBEM_E_PROVIDER_FAILURE;
        }

        // Always release going out of scope
        CReleaseMe  rmRefreshed( pRefreshedOA );

        CWbemObject* pRefreshedObject = (CWbemObject*)pRefreshedOA;
        CWbemObject* pClientObject = NULL;

        if ( SUCCEEDED( hres ) )
        {

            // The object we return to the client, since we are remote, should
            // contain amended qualifiers if we are using localization, so to make
            // sure of this, we will clone an object off of the pInstTemplate and
            // the copy the instance data from the object the provider returned
            // to us. The provider can refresh the object it gave to us, since
            // we will only be sending the instance part

            hres = pInstTemplate->Clone( (IWbemClassObject**) &pClientObject );

            if ( SUCCEEDED( hres ) )
            {
                hres = pClientObject->CopyBlobOf( pRefreshedObject );

                if ( SUCCEEDED( hres ) )
                {
                    hres = pNamespace->DecorateObject( pClientObject );
                }

            }   // IF Clones

        }   // IF Object Created

        // Release going out of scope
        CReleaseMe  rmClient( (IWbemClassObject*) pClientObject );

        if ( SUCCEEDED( hres ) )
        {
            // Add a new provider record if necessary
            if(pProvRecord == NULL)
            {
                hres = AddProvider( pProviderCacheRecord, 
                                    pProvRefresher, pNamespace,
                                    &pProvRecord );
            }

            // Now we will add the actual request
            if ( SUCCEEDED( hres ) )
            {

                // Generate the new id from our datamember
                long    lNewId = GetNewRequestId();

                hres = pProvRecord->AddObjectRequest(pRefreshedObject, lProvRequestId, lNewId );

                if ( SUCCEEDED( hres ) )
                {
                    m_lNumObjects++;
                    pInfo->SetRemote(this, lNewId, pClientObject, &m_Guid);
                }

            }   // IF we have a provider record

        }   // IF created a client object


    }   // IF Got refresher


    return hres;
}

HRESULT CRefresherCache::CRemoteRecord::AddEnumRefresher(
                    CCommonProviderCacheRecord* pProviderCacheRecord, 
                    CWbemNamespace* pNamespace,
                    CWbemObject* pInstTemplate,
                    LPCWSTR wszClass, long lFlags, 
                    IWbemContext* pContext,
                    CRefreshInfo* pInfo)
{
    // Enters and Leaves as a byproduct of scoping
    CInCritSec  ics(&m_cs);

    // Get a refresher from the provider, unless already available
    // ===========================================================

    IWbemRefresher* pProvRefresher = NULL;
    CProviderRecord* pProvRecord = NULL;

    HRESULT hres = GetProviderRefreshInfo( pProviderCacheRecord, pNamespace, &pProvRecord, &pProvRefresher );

    // Always release going out of scope
    CReleaseMe  rmRefresh( pProvRefresher );

    if ( SUCCEEDED( hres ) )
    {
        // Call provider for information
        // =============================

        // Create a HiPerf Enumerator (We know we will need one
        // of these since we will only be in this code when we
        // go remote).
        CRemoteHiPerfEnum*  pHPEnum = NULL;
        
        // Watch for OOM exceptions
        try
        {
            pHPEnum = new CRemoteHiPerfEnum;
        }
        catch( CX_MemoryException )
        {
            hres = WBEM_E_OUT_OF_MEMORY;
        }
        catch( ... )
        {
            hres = WBEM_E_FAILED;
        }

        if ( SUCCEEDED( hres ) )
        {
            // Bump up the RefCount
            pHPEnum->AddRef();

            // Release this pointer when we drop out of scope
            CReleaseMe  rm( pHPEnum );

            // The enumerator will need to know this
            hres = pHPEnum->SetInstanceTemplate( (CWbemInstance*) pInstTemplate );

            if ( FAILED(hres) )
            {
                return hres;
            }

            long lProvRequestId = 0;

            try
            {
                hres = pProviderCacheRecord->GetHiPerf()->CreateRefreshableEnum(
                        pNamespace, wszClass, pProvRefresher,
                        0, pContext, pHPEnum, &lProvRequestId);
            }
            catch(...)
            {
                // The provider threw an exception.  Just return and let scoping
                // release anything we may be holding onto.

                return WBEM_E_PROVIDER_FAILURE;
            }

            // Add a new provider record if we need one
            if( SUCCEEDED( hres ) && ( pProvRecord == NULL ) )
            {
                hres = AddProvider(pProviderCacheRecord, 
                                            pProvRefresher, pNamespace,
                                            &pProvRecord);
            }
    
            // Now we will add the actual request
            if ( SUCCEEDED( hres ) )
            {

                // Generate the new id from our datamember
                long    lNewId = GetNewRequestId();

                HRESULT hres = pProvRecord->AddEnumRequest( pHPEnum, lProvRequestId, lNewId );

                if ( SUCCEEDED( hres ) )
                {
                    m_lNumEnums++;
                    pInfo->SetRemote(this, lNewId, pInstTemplate, &m_Guid);
                }

            }   // IF we have a provider record

        }   // IF Created HPEnum

    }   // IF Got Refresher

    return hres;
}

//*****************************************************************************
//*****************************************************************************
//                              REFRESHER CACHE
//*****************************************************************************
//*****************************************************************************


CRefresherCache::CRefresherCache()
: m_cs()
{
}

CRefresherCache::~CRefresherCache()
{
}

HRESULT CRefresherCache::FindRefresherRecord(CRefresherId* pRefresherId, BOOL bCreate,
                                                CRefresherCache::CRefresherRecord** ppRecord )
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Enters and exits using scoping
    CInCritSec  ics( &m_cs );

    // We always AddRef() the record before returning so multiple requests will keep the
    // refcount correct so we won't remove and delete a record that another thread wants to
    // use (Remove blocks on the same critical section).

    // Look for it
    // ===========

    for(int i = 0; i < m_apRefreshers.GetSize(); i++)
    {
        if(m_apRefreshers[i]->GetId() == *pRefresherId)
        {
            m_apRefreshers[i]->AddRef();
            *ppRecord = m_apRefreshers[i];
            return WBEM_S_NO_ERROR;
        }
    }

    // If we weren't told to create it, then this is not an error
    if(!bCreate)
    {
        *ppRecord = NULL;
        return WBEM_S_FALSE;
    }

    CRefresherRecord* pNewRecord = NULL;

    // Watch for memory exceptions
    try
    {
        pNewRecord = new CRemoteRecord(*pRefresherId);

        m_apRefreshers.Add(pNewRecord);
    
        pNewRecord->AddRef();
        *ppRecord = pNewRecord;
        return WBEM_S_NO_ERROR;
    }
    catch( CX_MemoryException )
    {
        if ( NULL != pNewRecord )
        {
            delete pNewRecord;
        }

        return WBEM_E_OUT_OF_MEMORY;
    }
    catch( ... )
    {
        if ( NULL != pNewRecord )
        {
            delete pNewRecord;
        }

        return WBEM_E_FAILED;
    }
}

HRESULT CRefresherCache::CreateInfoForProvider(CRefresherId* pDestRefresherId,
                    CCommonProviderCacheRecord* pProviderCacheRecord, 
                    CWbemNamespace* pNamespace,
                    REFCLSID rClientClsid, 
                    CWbemObject* pInstTemplate, long lFlags, 
                    IWbemContext* pContext,
                    CRefreshInfo* pInfo)
{
    HRESULT hres;

    // ClientLoadable ClassId MUST be present or this operation is a NO-GO
    if ( rClientClsid != CLSID_NULL )
    {
        MSHCTX dwDestContext = GetDestinationContext(pDestRefresherId);

        // If this is In-Proc or Local, we'll just let the normal
        // client loadable logic handle it

        if(     dwDestContext == MSHCTX_LOCAL
            ||  dwDestContext == MSHCTX_INPROC )
        {
            // By decorating the object, we will store namespace and
            // server info in the object

            hres = pNamespace->DecorateObject( pInstTemplate );

            if ( SUCCEEDED( hres ) )
            {
                // Set the info appropriately now baseed on whether we are local to
                // the machine or In-Proc to WMI

                if ( dwDestContext == MSHCTX_INPROC )
                {
                    // We will use the hiperf provider interface
                    // we already have loaded.

                    pInfo->SetDirect(rClientClsid, pNamespace->GetName(), 
                            pInstTemplate, pProviderCacheRecord->GetHiPerf() );
                }
                else
                {
                   if (!pInfo->SetClientLoadable(rClientClsid, pNamespace->GetName(), pInstTemplate))
                   	hres = WBEM_E_OUT_OF_MEMORY;
                }

            }

            return hres;
        }

        // Ensure that we will indeed have a refresher record.
        CRefresherRecord* pRecord = NULL;
        
        hres = FindRefresherRecord(pDestRefresherId, TRUE, &pRecord);
        
        if ( SUCCEEDED ( hres ) )
        {
            // Now let the record take care of getting the object inside itself
            hres = pRecord->AddObjectRefresher( pProviderCacheRecord, pNamespace, pInstTemplate, lFlags,
                                    pContext, pInfo );
        }

        if ( NULL != pRecord )
        {
            pRecord->Release();
        }
    }
    else
    {
        return WBEM_E_INVALID_OPERATION;
    }


    return hres;
}

HRESULT CRefresherCache::CreateEnumInfoForProvider(CRefresherId* pDestRefresherId,
                    CCommonProviderCacheRecord* pProviderCacheRecord, 
                    CWbemNamespace* pNamespace,
                    REFCLSID rClientClsid, 
                    CWbemObject* pInstTemplate,
                    LPCWSTR wszClass, long lFlags, 
                    IWbemContext* pContext,
                    CRefreshInfo* pInfo)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    MSHCTX dwDestContext = GetDestinationContext(pDestRefresherId);

    // The client loadable id must be set
    if ( rClientClsid != CLSID_NULL )
    {
        // By decorating the object, we will store namespace and
        // server info so that a client can auto-reconnect to
        // us if necessary

        hres = pNamespace->DecorateObject( pInstTemplate );

        if ( FAILED( hres ) )
        {
            return hres;
        }

        // If this is In-Proc or Local, we'll just let the normal
        // client loadable logic handle it

        if(     dwDestContext == MSHCTX_LOCAL
            ||  dwDestContext == MSHCTX_INPROC )
        {
            // By decorating the object, we will store namespace and
            // server info in the object

            hres = pNamespace->DecorateObject( pInstTemplate );

            if ( SUCCEEDED( hres ) )
            {
                // Set the info appropriately now baseed on whether we are local to
                // the machine or In-Proc to WMI

                if ( dwDestContext == MSHCTX_INPROC )
                {
                    // We will use the hiperf provider interface
                    // we already have loaded.

                    pInfo->SetDirect(rClientClsid, pNamespace->GetName(), 
                            pInstTemplate, pProviderCacheRecord->GetHiPerf() );
                }
                else
                {
                    if (!pInfo->SetClientLoadable(rClientClsid, pNamespace->GetName(), pInstTemplate))
                    	hres = WBEM_E_OUT_OF_MEMORY;
                }
            }

            return hres;
        }
         
        // Ensure that we will indeed have a refresher record.
        CRefresherRecord* pRecord = NULL;
        
        hres = FindRefresherRecord(pDestRefresherId, TRUE, &pRecord);
        if ( SUCCEEDED ( hres ) )
        {
            // Add an enumeration to the Refresher
            hres = pRecord->AddEnumRefresher(pProviderCacheRecord, pNamespace, 
                        pInstTemplate, wszClass, lFlags, pContext, pInfo );

        }

        if ( NULL != pRecord )
        {
            pRecord->Release();
        }

    }
    else
    {
        hres = WBEM_E_INVALID_OPERATION;
    }


    return hres;
}

HRESULT CRefresherCache::RemoveObjectFromRefresher(CRefresherId* pId,
                            long lId, long lFlags)
{

    // Enters and exits using scoping
    CInCritSec  ics( &m_cs );

    // Find the refresher
    // ==================

    CRefresherRecord* pRefresherRecord = NULL;
    
    HRESULT hres = FindRefresherRecord(pId, FALSE, &pRefresherRecord );

    // Make sure this guy is released
    CReleaseMe  rm( (IWbemRemoteRefresher*) pRefresherRecord );

    // Both are error conditions
    if ( FAILED( hres ) || pRefresherRecord == NULL )
    {
        return hres;
    }

    // Remove it from the record
    // =========================

    return pRefresherRecord->Remove(lId);
}

MSHCTX CRefresherCache::GetDestinationContext(CRefresherId* pRefresherId)
{
    char szBuffer[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwLen = MAX_COMPUTERNAME_LENGTH + 1;
    GetComputerNameA(szBuffer, &dwLen);

    if(_stricmp(szBuffer, pRefresherId->GetMachineName()))
        return MSHCTX_DIFFERENTMACHINE;

    if(pRefresherId->GetProcessId() != GetCurrentProcessId())
        return MSHCTX_LOCAL;
    else
        return MSHCTX_INPROC;
}

BOOL CRefresherCache::RemoveRefresherRecord(CRefresherRecord* pRecord)
{

    // Enters and exits using scoping
    CInCritSec  ics( &m_cs );

    // Check that the record is actually released, in case another thread successfully requested
    // the record from FindRefresherRecord() which will have AddRef'd the record again.

    if ( pRecord->IsReleased() )
    {
        for(int i = 0; i < m_apRefreshers.GetSize(); i++)
        {
            if(m_apRefreshers[i] == pRecord)
            {
                m_apRefreshers.RemoveAt(i);
                return TRUE;
            }
        }

    }

    return FALSE;
}
    

//*****************************************************************************
//*****************************************************************************
//                              OBJECT REFRESHER
//*****************************************************************************
//*****************************************************************************


CObjectRefresher::CObjectRefresher(CWbemObject* pTemplate)
{
    IWbemClassObject* pCopy;
    pTemplate->Clone(&pCopy);
    m_pRefreshedObject = (CWbemObject*)pCopy;
}

CObjectRefresher::~CObjectRefresher()
{
    if(m_pRefreshedObject)
        m_pRefreshedObject->Release();
}

ULONG STDMETHODCALLTYPE CObjectRefresher::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CObjectRefresher::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

STDMETHODIMP CObjectRefresher::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemRefresher)
    {
        AddRef();
        *ppv = (IWbemRefresher*)this;
        return S_OK;
    }
    else return E_NOINTERFACE;
}

// Remote Hi Perf Enum support

CRemoteHiPerfEnum::CRemoteHiPerfEnum()
{
}

CRemoteHiPerfEnum::~CRemoteHiPerfEnum()
{
}

HRESULT CRemoteHiPerfEnum::GetTransferArrayBlob( long *plBlobType, long *plBlobLen, BYTE** ppBlob)
{
    // This is the correct BLOB type.  Beware 800 series was sending WBEM_BLOB_TYPE_ENUM for everything
    *plBlobType = WBEM_BLOB_TYPE_ENUM;

    HRESULT hr = WBEM_S_NO_ERROR;
    long    lBuffSize = 0,
            lLastBuffSize = 0,
            lNumObjects = 0;
    BYTE*   pData = NULL;

        // Get through the lock first
    if ( m_Lock.Lock() )
    {

        // Make sure we have objects to enumerate
        if ( m_aIdToObject.Size() > 0 )
        {
            // Enumerate the objects in the array and add up the size of the
            // buffer we will have to allocate
            for ( DWORD dwCtr = 0; dwCtr < m_aIdToObject.Size(); dwCtr++ )
            {
                CWbemInstance*  pInst = (CWbemInstance*) ((CHiPerfEnumData*) m_aIdToObject[dwCtr])->m_pObj;;

                // Buffer Size
                lLastBuffSize = pInst->GetTransferArrayBlobSize();

                // Skip zero length
                if ( 0 != lLastBuffSize )
                {
                    lBuffSize += lLastBuffSize;
                    lNumObjects++;
                }
            }

            // Make sure we have a size to work with
            if ( lBuffSize > 0 )
            {
                long    lTempBuffSize = lBuffSize;

                // Entire buffer is prepended by a number of objects and a version
                lBuffSize += CWbemInstance::GetTransferArrayHeaderSize();

                // May require CoTaskMemAlloc()
                pData = (BYTE*) CoTaskMemAlloc( lBuffSize );

                if ( NULL != pData )
                {
                    BYTE*   pTemp = pData;

                    // Now write the header
                    CWbemInstance::WriteTransferArrayHeader( lNumObjects, &pTemp );

                    // Now enumerate the objects and transfer into the array BLOB
                    for ( dwCtr = 0; SUCCEEDED(hr) && dwCtr < m_aIdToObject.Size(); dwCtr++ )
                    {
                        CWbemInstance*  pInst = (CWbemInstance*) ((CHiPerfEnumData*) m_aIdToObject[dwCtr])->m_pObj;

                        lLastBuffSize = pInst->GetTransferArrayBlobSize();

                        if ( lLastBuffSize > 0 )
                        {
                            long    lUsedSize;
                            hr = pInst->GetTransferArrayBlob( lTempBuffSize, &pTemp, &lUsedSize );

#ifdef _DEBUG
                            // During DEBUG HeapValidate our BLOB
                            HeapValidate( GetProcessHeap(), 0, pData );
#endif

                            // Account for BLOB size used

                            if ( SUCCEEDED( hr ) )
                            {
                                lTempBuffSize -= lUsedSize;
                            }
                        }

                    }   // FOR dwCtr

                    // Cleanup if things exploded, otherwise perform garbage collection
                    if ( FAILED( hr ) )
                    {
                        CoTaskMemFree( pData );
                        pData = NULL;
                        lBuffSize = 0;
                    }
                    else
                    {
                        // if everything is okay, go ahead and do any necessary garbage collection on
                        // our arrays.

                        m_aReusable.GarbageCollect();
                    }
                }
                else
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }

            }   // IF lBuffSize > 0

        }   // IF Size() > 0
        
        m_Lock.Unlock();

    }   // IF Lock()
    else
    {
        // If we can't get access to the enumerator to figure out which
        // BLOBs to transfer, something is badly worng.
        hr = WBEM_E_REFRESHER_BUSY;
    }

    // Make sure we store appropriate data
    *ppBlob = pData;
    *plBlobLen = lBuffSize;

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\refrcach.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    REFRCACH.H

Abstract:

	Refresher Server Side Implementation

History:

--*/

#ifndef __REFRESH_CACHE__H_
#define __REFRESH_CACHE__H_

#include "hiperfenum.h"

// Update this for server side refresher code.  Make sure to update client
// version in refrcli.h as well.
#define WBEM_REFRESHER_VERSION 1

class CRemoteHiPerfEnum : public CHiPerfEnum
{
public:

	CRemoteHiPerfEnum(void);
	~CRemoteHiPerfEnum();

	// Arranges BLOB contents from an enumeration
	HRESULT GetTransferArrayBlob(long *plBlobType, long *plBlobLen, BYTE** ppBlob);

};

class CObjectRefresher : public IWbemRefresher
{
protected:
    long m_lRef;
    CWbemObject* m_pRefreshedObject;

public:
    CObjectRefresher(CWbemObject* pTemplate);
    virtual ~CObjectRefresher();

    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);
    STDMETHOD(Refresh)(long lFlags) = 0;

    INTERNAL CWbemObject* GetRefreshedObject() {return m_pRefreshedObject;}
};

class CCommonProviderCacheRecord;

class CRefresherCache
{
public:
    class CRequestRecord
    {
    protected:
        long m_lExternalRequestId;
    public:
        CRequestRecord(long lExternalRequestId = 0) 
            : m_lExternalRequestId(lExternalRequestId){}
        virtual ~CRequestRecord(){}
        long GetExternalRequestId() {return m_lExternalRequestId;}
    };

    class CProviderRecord;
    class CObjectRequestRecord : public CRequestRecord
    {
    public:
        CWbemObject* m_pRefreshedObject;
        long m_lInternalRequestId;
    public:
        CObjectRequestRecord(long lExternalRequestId, 
                                CWbemObject* pRefreshedObject, 
                                long lProviderRequestId);
        ~CObjectRequestRecord();
        HRESULT Cancel(CProviderRecord* pContainer);
    public:
        long GetInternalRequestId() {return m_lInternalRequestId;}
        INTERNAL CWbemObject* GetRefreshedObject() {return m_pRefreshedObject;}
    };

    class CEnumRequestRecord : public CRequestRecord
    {
    public:
        CRemoteHiPerfEnum* m_pHPEnum;
        long m_lInternalRequestId;

    public:
        CEnumRequestRecord(long lExternalRequestId, 
                                CRemoteHiPerfEnum* pHPEnum, 
                                long lProviderRequestId);
        ~CEnumRequestRecord();
        HRESULT Cancel(CProviderRecord* pContainer);
    public:
        long GetInternalRequestId() {return m_lInternalRequestId;}
        INTERNAL CRemoteHiPerfEnum* GetEnum() {return m_pHPEnum;}
    };

    friend CObjectRequestRecord;

    class CProviderRecord
    {
    protected:
        CWbemNamespace* m_pNamespace;
        CCommonProviderCacheRecord* m_pProviderCacheRecord;
        IWbemHiPerfProvider* m_pProvider;
        IWbemRefresher* m_pInternalRefresher;
		CCritSec	m_cs;

        CUniquePointerArray<CObjectRequestRecord> m_apRequests;
        CUniquePointerArray<CEnumRequestRecord>	m_apEnumRequests;

        HRESULT Cancel(long lId);
    public:
        CProviderRecord(CCommonProviderCacheRecord* pProviderCacheRecord, 
                                IWbemRefresher* pRefresher, 
                                CWbemNamespace* pNamespace);
        ~CProviderRecord();

        HRESULT AddObjectRequest(CWbemObject* pRefreshedObject, 
                                long lProviderRequestId,
								long lNewId );

        HRESULT AddEnumRequest(CRemoteHiPerfEnum* pHPEnum, 
                                long lProviderRequestId,
								long lNewId);

        HRESULT Remove(long lId, BOOL* pfIsEnum);
        HRESULT Find(long lId);
        HRESULT Refresh(long lFlags);
        HRESULT Store(WBEM_REFRESHED_OBJECT* aObjects, long* plIndex);
        BOOL IsEmpty() {return (m_apRequests.GetSize() == 0) && m_apEnumRequests.GetSize() == 0;}
    public:
        INTERNAL IWbemHiPerfProvider* GetProvider() {return m_pProvider;}
        INTERNAL IWbemRefresher* GetInternalRefresher( void )
		{ return m_pInternalRefresher; }

        INTERNAL CCommonProviderCacheRecord* GetCacheRecord() 
                    {return m_pProviderCacheRecord;}

        friend CObjectRequestRecord;
		friend CEnumRequestRecord;
    };
    friend CProviderRecord;
        
    class CRefresherRecord : public IWbemRemoteRefresher, public IWbemRefresher
    {
    protected:
        long m_lRefCount;
        CRefresherId m_Id;
        CUniquePointerArray<CProviderRecord> m_apProviders;
        long m_lNumObjects;
		long m_lNumEnums;
		long	m_lLastId;
		GUID	m_Guid;
		CCritSec	m_cs;

    public:
        CRefresherRecord(const WBEM_REFRESHER_ID& Id);
        virtual ~CRefresherRecord(){}

        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();
        STDMETHOD(QueryInterface)(REFIID riid, void** ppv);
        STDMETHOD(RemoteRefresh)(long lFlags, long* plNumObjects,
            WBEM_REFRESHED_OBJECT** paObjects);
		STDMETHOD(StopRefreshing)( long lNumIds, long* aplIds, long lFlags);
		STDMETHOD(GetGuid)( long lFlags, GUID* pGuid );

        STDMETHOD(Refresh)(long lFlags);

        CRefresherId& GetId() {return m_Id;}
        const CRefresherId& GetId() const {return m_Id;}

        INTERNAL CProviderRecord* FindProviderRecord(
                             CCommonProviderCacheRecord* pProviderCacheRecord);

        INTERNAL HRESULT AddProvider(
                             CCommonProviderCacheRecord* pProviderCacheRecord,
                             IWbemRefresher* pRefresher,
                             CWbemNamespace* pNamespace,
							 CProviderRecord** ppRecord);

		// Retrieves a new id for this remote refresher
	    long GetNewRequestId( void )
		{
			return InterlockedIncrement( &m_lLastId );
		}

		virtual HRESULT AddObjectRefresher(
							CCommonProviderCacheRecord* pProviderCacheRecord, 
							CWbemNamespace* pNamespace,
							CWbemObject* pInstTemplate, long lFlags, 
							IWbemContext* pContext,
							CRefreshInfo* pInfo) = 0;

		virtual HRESULT AddEnumRefresher(
							CCommonProviderCacheRecord* pProviderCacheRecord, 
							CWbemNamespace* pNamespace,
							CWbemObject* pInstTemplate,
							LPCWSTR wszClass, long lFlags, 
							IWbemContext* pContext,
							CRefreshInfo* pInfo) = 0;

        HRESULT Remove(long lRequestId);

		void GetGuid( GUID* pGuid ){ *pGuid = m_Guid; }

		BOOL IsReleased( void ) { return ( m_lRefCount == 0L ); }
    };
    friend CRefresherRecord;

    class CRemoteRecord : public CRefresherRecord
    {
	protected:

		HRESULT GetProviderRefreshInfo( CCommonProviderCacheRecord* pProviderCacheRecord,
										CWbemNamespace* pNamespace,
										CProviderRecord** ppProvRecord,
										IWbemRefresher** ppRefresher );

    public:
        CRemoteRecord(const WBEM_REFRESHER_ID& Id);
        ~CRemoteRecord();

		HRESULT AddObjectRefresher(
							CCommonProviderCacheRecord* pProviderCacheRecord, 
							CWbemNamespace* pNamespace,
							CWbemObject* pInstTemplate, long lFlags, 
							IWbemContext* pContext,
							CRefreshInfo* pInfo);

		HRESULT AddEnumRefresher(
							CCommonProviderCacheRecord* pProviderCacheRecord, 
							CWbemNamespace* pNamespace,
							CWbemObject* pInstTemplate,
							LPCWSTR wszClass, long lFlags, 
							IWbemContext* pContext,
							CRefreshInfo* pInfo);

    };

        
protected:
    CUniquePointerArray<CRefresherRecord> m_apRefreshers;
	CCritSec	m_cs;

protected:

    BOOL RemoveRefresherRecord(CRefresherRecord* pRecord);
public:
    CRefresherCache();
    ~CRefresherCache();

    static MSHCTX GetDestinationContext(CRefresherId* pRefresherId);

    HRESULT CreateInfoForProvider(CRefresherId* pDestRefresherId,
                    CCommonProviderCacheRecord* pProviderCacheRecord, 
                    CWbemNamespace* pNamespace,
                    REFCLSID rClientClsid, 
                    CWbemObject* pInstTemplate, long lFlags, 
                    IWbemContext* pContext,
                    CRefreshInfo* pInfo);

    HRESULT CreateEnumInfoForProvider(CRefresherId* pDestRefresherId,
                    CCommonProviderCacheRecord* pProviderCacheRecord, 
                    CWbemNamespace* pNamespace,
                    REFCLSID rClientClsid, 
                    CWbemObject* pInstTemplate,
					LPCWSTR wszClass, long lFlags, 
                    IWbemContext* pContext,
                    CRefreshInfo* pInfo);

    HRESULT RemoveObjectFromRefresher(CRefresherId* pId,
                            long lId, long lFlags);

    HRESULT FindRefresherRecord( CRefresherId* pRefresherId, BOOL bCreate,
								RELEASE_ME CRefresherRecord** ppRecord );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\sechelp.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    SECHELP.H

Abstract:

    Security Helper functions

History:

    raymcc  29-Apr-97   Created

--*/

#ifndef _SECHELP_H_
#define _SECHELP_H_
#include "corepol.h"

class  WBEMSecurityHelp
{
public:
    enum { NoError, InvalidParameter, Failed };

    static int ComputeMD5(
        LPBYTE pSrcBuffer,         
        int    nArrayLength,
        LPBYTE *pMD5Digest         // Use operator delete to deallocate
        );
        // Returns one of the enum values

    static int MakeWBEMAccessTokenFromMD5(
        LPBYTE pNonce,             // Points to a 16-byte nonce
        LPBYTE pPasswordDigest,    // MD5 of the password
        LPBYTE *pAccessToken       // Use operator delete to deallocate
        );

    static int MakeWBEMAccessToken(
        LPBYTE pNonce,             // Points to a 16-byte nonce
        LPWSTR pszPassword,        // Can be NULL, blank, or anything normal7
        LPBYTE *pAccessToken       // Use operator delete to deallocate        
        );
        // Returns one of the enum values
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\sinks.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SINKS.CPP

Abstract:

    Sink definitions

History:

--*/

#ifndef __WBEM_SINKS__H_
#define __WBEM_SINKS__H_

#include <sync.h>
#include <arrtempl.h>
#include <wstlallc.h>

//***************************************************************************
//
//***************************************************************************

class CObjDbNS;
class CWbemNamespace;


//***************************************************************************
//
//***************************************************************************

class CDestination
{
public:
    virtual HRESULT Add(ADDREF IWbemClassObject* pObj) = 0;
};


//***************************************************************************
//
//  For debugging
//
//***************************************************************************


//***************************************************************************
//
//***************************************************************************

class CBasicObjectSink : public IWbemObjectSink, public CDestination
{
public:
    CBasicObjectSink();
    virtual ~CBasicObjectSink();

    STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppvObj);

    inline HRESULT Add(IWbemClassObject* pObj)
        {return Indicate(1, &pObj);}
    inline HRESULT Return(HRESULT hres, IWbemClassObject* pErrorObj = NULL)
        {SetStatus(0, hres, NULL, pErrorObj); return hres;}

    virtual IWbemObjectSink* GetIndicateSink() {return this;}
    virtual IWbemObjectSink* GetStatusSink() {return this;}
    virtual BOOL IsApartmentSpecific() {return FALSE;}
    virtual BOOL IsTrusted() {return TRUE;}
};

class CStatusSink : public CBasicObjectSink
{
    HRESULT m_hRes;
	long	m_lRefCount;

public:

    CStatusSink( );
   ~CStatusSink();

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID* ppvObj);
    HRESULT STDMETHODCALLTYPE Indicate(long lObjectCount, IWbemClassObject** pObjArray);
    HRESULT STDMETHODCALLTYPE SetStatus(long lFlags, long lParam, BSTR strParam,
                             IWbemClassObject* pObjParam
                             );

	HRESULT GetLastStatus( void ) { return m_hRes; }
};

class CStdSink : public CBasicObjectSink
{
    IWbemObjectSink *m_pDest;
    HRESULT m_hRes;
    BOOL m_bCancelForwarded;
public:
    long    m_lRefCount;

    CStdSink(IWbemObjectSink *pRealDest);
   ~CStdSink();
    HRESULT Cancel();

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID* ppvObj);
    HRESULT STDMETHODCALLTYPE Indicate(long lObjectCount, IWbemClassObject** pObjArray);
    HRESULT STDMETHODCALLTYPE SetStatus(long lFlags, long lParam, BSTR strParam,
                             IWbemClassObject* pObjParam
                             );
};


//***************************************************************************
//
//  Decouples provider subsystem from the rest of the sink chain
//  for cancellation purposes.
//
//  This sink does not destruct until the Destruct() method is called
//
//***************************************************************************
//
class CProviderSink : public IWbemObjectSink
{
private:
    LONG m_lRefCount;
    LONG m_lIndicateCount;
    LPWSTR m_pszDebugInfo;

    IWbemObjectSink *m_pNextSink;
    HRESULT m_hRes;
    BOOL m_bDone;
    CRITICAL_SECTION m_cs;

public:
    static HRESULT WINAPI Dump(FILE *f);

    CProviderSink(LONG lStartingRefCount = 0, LPWSTR pszDebugInfo = 0);
   ~CProviderSink();

    ULONG LocalAddRef();    // Doesn't propagate AddRef()
    ULONG LocalRelease();   // Doesn't propagate Release()

    void SetNextSink(IWbemObjectSink *pSink) { m_pNextSink = pSink; m_pNextSink->AddRef(); }
    void Cancel();

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID* ppvObj);
    HRESULT STDMETHODCALLTYPE Indicate(long lObjectCount, IWbemClassObject** pObjArray);
    HRESULT STDMETHODCALLTYPE SetStatus(long lFlags, long lParam, BSTR strParam,
                             IWbemClassObject* pObjParam
                             );
};


//***************************************************************************
//
//***************************************************************************

class CObjectSink : public CBasicObjectSink
{
protected:
    long m_lRef;
public:
    CObjectSink(long lRef = 0) : m_lRef(lRef){}
    virtual ~CObjectSink(){}

    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray) = 0;
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam) = 0;
};

class CSynchronousSink : public CObjectSink
{
    HANDLE m_hEvent;
    HRESULT m_hres;
    BSTR m_str;
    IWbemClassObject* m_pErrorObj;
    IWbemObjectSink* m_pCurrentProxy;
    CRefedPointerArray<IWbemClassObject> m_apObjects;
    CCritSec m_cs;
public:
    CSynchronousSink(IWbemObjectSink* pProxy = NULL);
    virtual ~CSynchronousSink();

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);

public:
    void Block();
    void GetStatus(HRESULT* phres, BSTR* pstrParam,
                        IWbemClassObject** ppErrorObj);
    INTERNAL CRefedPointerArray<IWbemClassObject>& GetObjects()
        {return m_apObjects;}

	HRESULT GetHResult() { return m_hres; }
	void ClearHResult() { m_hres = WBEM_S_NO_ERROR; }
};



//***************************************************************************
//
//***************************************************************************

class CForwardingSink : public CObjectSink
{
protected:
    IWbemObjectSink* m_pDestIndicate;
    IWbemObjectSink* m_pDestStatus;
    CBasicObjectSink* m_pDest;
public:
    CForwardingSink(CBasicObjectSink* pDest, long lRef = 0);
    virtual ~CForwardingSink();

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);

    virtual IWbemObjectSink* GetIndicateSink() {return m_pDestIndicate;}
    virtual IWbemObjectSink* GetStatusSink() {return m_pDestStatus;}
    virtual BOOL IsTrusted() {return m_pDest->IsTrusted();}
    virtual BOOL IsApartmentSpecific() {return m_pDest->IsApartmentSpecific();}
};


//***************************************************************************
//
//***************************************************************************


class CDynPropsSink : public CForwardingSink
{
protected:
    CRefedPointerArray<IWbemClassObject> m_UnsentCache;
    CWbemNamespace * m_pNs;
public:
    CDynPropsSink(CBasicObjectSink* pSink, CWbemNamespace * pNs, long lRef = 0);
    virtual IWbemObjectSink* GetIndicateSink() {return this;}
    ~CDynPropsSink();
    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
};


//***************************************************************************
//
//***************************************************************************

class CDecoratingSink : public CForwardingSink
{
protected:
    CWbemNamespace* m_pNamespace;

public:
    CDecoratingSink(CBasicObjectSink* pDest, CWbemNamespace* pNamespace);
    ~CDecoratingSink();

    STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects);
    virtual IWbemObjectSink* GetIndicateSink() {return this;}
};


//***************************************************************************
//
//***************************************************************************

class CCombiningSink : public CForwardingSink
{
protected:
    HRESULT m_hresToIgnore;
    HRESULT m_hres;
    BSTR m_strParam;
    IWbemClassObject* m_pErrorObj;
    CCritSec m_cs;

public:
    CCombiningSink(CBasicObjectSink* pDest,
                    HRESULT hresToIgnore = WBEM_S_NO_ERROR);
    virtual ~CCombiningSink();

    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);
    virtual IWbemObjectSink* GetStatusSink() {return this;}

    HRESULT GetHResult() { return m_hres; }
    void ClearHResult() { m_hres = WBEM_S_NO_ERROR; }
	void SetHRESULTToIgnore( HRESULT hr ) { m_hresToIgnore = hr; }
};


//***************************************************************************
//
//***************************************************************************

class CAnySuccessSink : public CCombiningSink
{
    BOOL m_bSuccess;
    HRESULT m_hresNotError1;
    HRESULT m_hresNotError2;
    HRESULT m_hresIgnored;
public:
    CAnySuccessSink(CBasicObjectSink* pDest, HRESULT hresNotError1,
            HRESULT hresNotError2)
        : CCombiningSink(pDest), m_bSuccess(FALSE), m_hresIgnored(0),
            m_hresNotError1(hresNotError1), m_hresNotError2(hresNotError2)
    {}
    virtual ~CAnySuccessSink();
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);
    virtual IWbemObjectSink* GetStatusSink() {return this;}
};

//
//
//  this constructor thows, because the WString trows
//
//////////////////////////////////////////////////////////////////

class COperationErrorSink : public CForwardingSink
{
protected:
    WString m_wsOperation;
    WString m_wsParameter;
    WString m_wsProviderName;
    BOOL m_bFinal;

public:
    COperationErrorSink(CBasicObjectSink* pDest,
                        LPCWSTR wszOperation, LPCWSTR wszParameter,
                        BOOL bFinal = TRUE)
        : CForwardingSink(pDest, 0), m_wsOperation((LPWSTR)wszOperation),
            m_wsParameter((LPWSTR)wszParameter), m_wsProviderName(L"WinMgmt"),
            m_bFinal(bFinal)
    {}
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);
    void SetProviderName(LPCWSTR wszName);
    void SetParameterInfo(LPCWSTR wszParam);
    virtual IWbemObjectSink* GetStatusSink() {return this;}
};

//***************************************************************************
//
//***************************************************************************

class CSingleMergingSink : public CCombiningSink
{
protected:
    IWbemClassObject* m_pResult;
    CCritSec m_cs;
    WString m_wsTargetClass;

public:
    CSingleMergingSink(CBasicObjectSink* pDest, LPCWSTR wszTargetClass)
        : CCombiningSink(pDest, WBEM_E_NOT_FOUND), m_pResult(NULL),
            m_wsTargetClass(wszTargetClass)
    {}
    virtual ~CSingleMergingSink();

    STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects);
    virtual IWbemObjectSink* GetIndicateSink() {return this;}
};

//***************************************************************************
//
//***************************************************************************

class CLocaleMergingSink : public CCombiningSink
{
protected:
    CCritSec m_cs;
    WString m_wsLocale;
    WString m_pThisNamespace;

    //Primary pointers are to the specified locale
    IWmiDbHandle *m_pPrimaryNs;
    IWmiDbSession *m_pPrimarySession;
    IWmiDbController *m_pPrimaryDriver;

    //Default pointers are pointing at the ms_409 default locale in case there
    //is no specific locale loaded onto the machine.
    IWmiDbHandle *m_pDefaultNs;
    IWmiDbSession *m_pDefaultSession;
    IWmiDbController *m_pDefaultDriver;

    void GetDbPtr(const wchar_t *);
    bool hasLocale(const wchar_t *);
      void releaseNS(void);

    HRESULT LocalizeQualifiers(bool, bool, IWbemQualifierSet *, IWbemQualifierSet *, bool&);
    HRESULT LocalizeProperties(bool, bool, IWbemClassObject *, IWbemClassObject *, bool&);

public:
    CLocaleMergingSink(CBasicObjectSink *pDest, LPCWSTR wszLocale, LPCWSTR pNamespace);
    virtual ~CLocaleMergingSink();
    STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects);

    virtual IWbemObjectSink* GetIndicateSink() {return this;}
};

//***************************************************************************
//
//***************************************************************************

class CCountedSink : public CForwardingSink
{
    DWORD m_dwMax;
    DWORD m_dwSent;
public:
    CCountedSink(CBasicObjectSink* pDest, DWORD dwMax) : CForwardingSink(pDest),
        m_dwMax(dwMax), m_dwSent(0)
    {}
    STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects);
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);
    virtual IWbemObjectSink* GetIndicateSink() {return this;}
};


//***************************************************************************
//
//***************************************************************************

class CFilteringSink : public CForwardingSink
{
public:
    CFilteringSink(CBasicObjectSink* pDest) : CForwardingSink(pDest, 0){}
    virtual ~CFilteringSink(){}

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    virtual IWbemObjectSink* GetIndicateSink() {return this;}
    virtual BOOL Test(CWbemObject* pObj) = 0;
};

//***************************************************************************
//
//***************************************************************************

class CErrorChangingSink : public CForwardingSink
{
protected:
    HRESULT m_hresFrom;
    HRESULT m_hresTo;
public:
    CErrorChangingSink(CBasicObjectSink* pDest, HRESULT hresFrom, HRESULT hresTo)
        : CForwardingSink(pDest, 0), m_hresFrom(hresFrom), m_hresTo(hresTo)
    {}
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);
    virtual IWbemObjectSink* GetStatusSink() {return this;}
};

//***************************************************************************
//
//***************************************************************************

class CMethodSink : public CForwardingSink
{
protected:
    IWbemClassObject * m_pRes;
public:
    CMethodSink(CBasicObjectSink* pDest)
        : CForwardingSink(pDest, 0), m_pRes(0)
    {}
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);
    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    virtual IWbemObjectSink* GetStatusSink() {return this;}
    virtual IWbemObjectSink* GetIndicateSink() {return this;}
};

//***************************************************************************
//
//***************************************************************************

class CNoDuplicatesSink : public CFilteringSink
{
protected:
    std::map<WString, bool, WSiless> m_mapPaths;
    BSTR m_strDupClass;
    CCritSec m_cs;

public:
    CNoDuplicatesSink(CBasicObjectSink* pDest);
    ~CNoDuplicatesSink();

    BOOL Test(CWbemObject* pObj);

    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);
    virtual IWbemObjectSink* GetStatusSink() {return this;}
};

//***************************************************************************
//
//***************************************************************************

class CHandleClassProvErrorsSink : public CForwardingSink
{
protected:
    WString m_wsProvider;
    WString m_wsNamespace;
public:
    CHandleClassProvErrorsSink(CBasicObjectSink* pDest, LPCWSTR wszProvider,
               LPCWSTR wszNamespace)
        : CForwardingSink(pDest, 0), m_wsProvider(wszProvider),
            m_wsNamespace(wszNamespace)
    {}
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);
    virtual IWbemObjectSink* GetStatusSink() {return this;}
};

//***************************************************************************
//
//***************************************************************************

class CSuccessSuppressionSink : public CForwardingSink
{
protected:
    HRESULT m_hresNotError1;
    HRESULT m_hresNotError2;
public:
    CSuccessSuppressionSink(CBasicObjectSink* pDest, HRESULT hresNotError1,
            HRESULT hresNotError2)
        : CForwardingSink(pDest, 0), m_hresNotError1(hresNotError1),
            m_hresNotError2(hresNotError2)
    {}
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);
    virtual IWbemObjectSink* GetStatusSink() {return this;}
};

//***************************************************************************
//
//***************************************************************************

class CThreadSwitchSink : public CForwardingSink
{
protected:
    CRefedPointerQueue<IWbemClassObject> m_qpObjects;
    HRESULT m_hres;
    BOOL m_bSwitching;
    HANDLE m_hReady;


public:
    CThreadSwitchSink(CBasicObjectSink* pDest);
    ~CThreadSwitchSink();

    STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects);
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);

    HRESULT Next(IWbemClassObject** ppObj);
};


//***************************************************************************
//
//***************************************************************************


class CLessGuid : public binary_function<GUID, GUID, bool>
{
public:
    bool operator()(const GUID& x, const GUID& y) const
    {
        return (memcmp((void*)&x, (void*)&y, sizeof(GUID)) < 0);
    }
};


//***************************************************************************
//
//***************************************************************************

/*
class CLessPtr : public binary_function<__a, __a,bool>
{
public:
    inline
    bool operator()(__a const& x, __a const& y) const
    {
        return (IWbemObjectSink*)x < (IWbemObjectSink*)y;
    }
};
*/


class CSinkGUIDAlloc : public wbem_allocator<GUID>
{
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\secure.h ===
//depot/private/wmi_branch2/admin/wmi/wbem/Winmgmt/coredll/secure.h#3 - edit change 16081 (text)
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    SECURE.CPP

Abstract:

	defines various routines used for ACL based security.
	It is defined in secure.h

History:

	a-davj    05-NOV-98  Created.

--*/

#ifndef _SECURE_H_
#define _SECURE_H_

// Implements the methods that the __SystemSecurity class supports

// A variation of the CFlexArray which deletes the entries

class CFlexAceArray : public CFlexArray
{
public:
	CFlexAceArray(){};
	~CFlexAceArray();
    HRESULT Serialize(void ** pData, DWORD * pdwSize);
    HRESULT Deserialize(void * pData);
};


enum { SecFlagProvider = 0x2,
       SecFlagWin9XLocal = 0x4,
       SecFlagInProcLogin = 0x20000,
     };

#define FULL_RIGHTS WBEM_METHOD_EXECUTE | WBEM_FULL_WRITE_REP | WBEM_PARTIAL_WRITE_REP | \
                    WBEM_WRITE_PROVIDER | WRITE_DAC | READ_CONTROL | WBEM_ENABLE | WBEM_REMOTE_ACCESS

HRESULT GetAces(CFlexAceArray * pFlex, LPWSTR pNsName, bool bNT);
HRESULT PutAces(CFlexAceArray * pFlex, LPWSTR pNsName);
BOOL IsRemote(HANDLE hToken);
CBaseAce * ConvertOldObjectToAce(IWbemClassObject * pObj, bool bGroup);
HRESULT	SetSecurityForNS(IWmiDbSession * pSession,IWmiDbHandle *pNSToSet,
						 IWmiDbSession * pParentSession, IWmiDbHandle * pNSParent, BOOL bExisting = FALSE);
HRESULT CopyInheritAces(CNtSecurityDescriptor & sd, CNtSecurityDescriptor & sdParent);
HRESULT GetSDFromProperty(LPWSTR pPropName, CNtSecurityDescriptor &sd, IWbemClassObject *pThisNSObject);
HRESULT CopySDIntoProperty(LPWSTR pPropName, CNtSecurityDescriptor &sd, IWbemClassObject *pThisNSObject);
HRESULT AddDefaultRootAces(CNtAcl * pacl);
HRESULT StoreSDIntoNamespace(IWmiDbSession * pSession, IWmiDbHandle *pNSToSet, CNtSecurityDescriptor & sd);
bool IsAceValid(DWORD dwMask, DWORD dwType, DWORD dwFlag);
BOOL IsValidAclForNSSecurity (CNtAcl* acl);

//
//
//  this class will allow you to get back to the SYSTEM account
//
//
///////////////////////////////////////////////////////////////////

class CAutoImpersonate {
private:
    IServerSecurity * m_pSec;
    BOOL m_bImper;
public:
    CAutoImpersonate()
    {
		m_pSec   = NULL;
		m_bImper = FALSE;
		if (SUCCEEDED(CoGetCallContext(IID_IServerSecurity,(void **)&m_pSec)))
		{
		    if (m_pSec->IsImpersonating()){
		        m_pSec->RevertToSelf();
		        m_bImper = TRUE;
		    }
		}
    }
    ~CAutoImpersonate()
    {
        if(m_bImper)
        {
            m_pSec->ImpersonateClient();
        }
        if (m_pSec)
        {
           m_pSec->Release();
        }
    }


	HRESULT Impersonate ( )
	{
		if(m_bImper)
		{
			m_bImper = FALSE ;
			return m_pSec->ImpersonateClient();
		}
		else
		{
			return WBEM_S_NO_ERROR ;
		}
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\sinks.cpp ===
//***************************************************************************
//
//  (c) 1997-2001 by Microsoft Corporation
//
//  SINKS.CPP
//
//  raymcc      3-Mar-99        Updated for separately threaded proxies
//
//***************************************************************************

#include "precomp.h"

#include <stdio.h>
#include <wbemcore.h>
#include <thrpool.h>
#include <evtlog.h>
#include <oahelp.inl>
#include <genutils.h>
#include <stdarg.h>
#include <autoptr.h>

#define LOWER_AUTH_LEVEL_NOTSET 0xFFFFFFFF

HRESULT LowerAuthLevel( IWbemObjectSink * psink, DWORD* pdwLastAuthnLevel );

static HRESULT ZapWriteOnlyProps(IWbemClassObject *pObj);

extern LONG g_nSinkCount;
extern LONG g_nStdSinkCount;
extern LONG g_nSynchronousSinkCount;
extern LONG g_nProviderSinkCount;


int _Trace(char *pFile, const char *fmt, ...);


//***************************************************************************
//
//***************************************************************************

CBasicObjectSink::CBasicObjectSink()
{
    InterlockedIncrement(&g_nSinkCount);
}

CBasicObjectSink::~CBasicObjectSink()
{
    InterlockedDecrement(&g_nSinkCount);
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CBasicObjectSink::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    if(riid == CLSID_WbemLocator)
    {
        // internal test
        *ppvObj = NULL;
        return S_OK;
    }

    if(riid == IID_IUnknown || riid == IID_IWbemObjectSink)
    {
        *ppvObj = (IWbemObjectSink*)this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}

//***************************************************************************
//
//***************************************************************************

ULONG STDMETHODCALLTYPE CObjectSink::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

//***************************************************************************
//
//***************************************************************************

ULONG STDMETHODCALLTYPE CObjectSink::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

//***************************************************************************
//
//***************************************************************************


CSynchronousSink::CSynchronousSink(IWbemObjectSink* pProxy) :
        m_hEvent(CreateEvent(NULL, FALSE, FALSE, NULL)),
        m_str(NULL), m_pErrorObj(NULL), m_hres(WBEM_E_CRITICAL_ERROR)
{
    if(pProxy)
    {
        m_pCurrentProxy = pProxy;
        pProxy->AddRef();
    }
    else
        m_pCurrentProxy = NULL;
    InterlockedIncrement(&g_nSynchronousSinkCount);

};

//***************************************************************************
//
//***************************************************************************

CSynchronousSink::~CSynchronousSink()
{
    if(m_pCurrentProxy)
        m_pCurrentProxy->Release();

    CloseHandle(m_hEvent);
    SysFreeString(m_str);
    if(m_pErrorObj)
        m_pErrorObj->Release();
    InterlockedDecrement(&g_nSynchronousSinkCount);

}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CSynchronousSink::Indicate(long lNumObjects,
                                       IWbemClassObject** apObj)
{
    CInCritSec ics(&m_cs);
    for(long i = 0; i < lNumObjects; i++)
    {
        m_apObjects.Add(apObj[i]);
    }
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CSynchronousSink::SetStatus(long lFlags, long lParam,
                                    BSTR strParam, IWbemClassObject* pObjParam)
{
    if(lFlags == WBEM_STATUS_PROGRESS)
    {
        if(m_pCurrentProxy)
            return m_pCurrentProxy->SetStatus(lFlags, lParam, strParam, pObjParam);
        else
            return S_OK;
    }

    if(lFlags != 0) return WBEM_S_NO_ERROR;

    CInCritSec ics(&m_cs);

    m_hres = lParam;
    m_str = SysAllocString(strParam);
    if (m_pErrorObj)
        m_pErrorObj->Release();
    m_pErrorObj = pObjParam;
    if(m_pErrorObj)
        m_pErrorObj->AddRef();
    SetEvent(m_hEvent);

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

void CSynchronousSink::Block()
{
    if(m_hres != WBEM_E_CRITICAL_ERROR)
        return;

    CCoreQueue::QueueWaitForSingleObject(m_hEvent, INFINITE);
}

//***************************************************************************
//
//***************************************************************************

void CSynchronousSink::GetStatus(HRESULT* phres, BSTR* pstrParam,
                                IWbemClassObject** ppErrorObj)
{
    CInCritSec ics(&m_cs);

    if(phres)
        *phres = m_hres;
    if(pstrParam)
        *pstrParam = SysAllocString(m_str);
    if(ppErrorObj)
    {
        *ppErrorObj = m_pErrorObj;
        if(m_pErrorObj)
            m_pErrorObj->AddRef();
    }
}


HRESULT LowerAuthLevel(IWbemObjectSink * psink, DWORD* pdwLastAuthnLevel )
{
    IClientSecurity * pFromSec = NULL;
    SCODE sc = psink->QueryInterface(IID_IClientSecurity, (void **) &pFromSec);
    if(sc == S_OK)
    {
        OLECHAR * pPrincipal = NULL;
        DWORD dwAuthnSvc, dwAuthzSvc, dwAuthnLevel, dwImpLevel, dwCapabilities;
        sc = pFromSec->QueryBlanket(psink, &dwAuthnSvc, &dwAuthzSvc,
                                            &pPrincipal,
                                            &dwAuthnLevel, &dwImpLevel,
                                            NULL, &dwCapabilities);

        // If we have never retrieved the authentication level before, then we
        // should record what it currently is
        if ( LOWER_AUTH_LEVEL_NOTSET == *pdwLastAuthnLevel )
        {
            *pdwLastAuthnLevel = dwAuthnLevel;
        }

        if (FAILED(sc))
            return sc;
        if(*pdwLastAuthnLevel == RPC_C_AUTHN_LEVEL_NONE)
            return WBEM_E_FAILED;
        if(*pdwLastAuthnLevel == RPC_C_AUTHN_LEVEL_DEFAULT)
            *pdwLastAuthnLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
        else
            (*pdwLastAuthnLevel)--;      // normal case is to try one lower

        sc = pFromSec->SetBlanket(psink, dwAuthnSvc, dwAuthzSvc,
                                            pPrincipal,
                                            *pdwLastAuthnLevel, dwImpLevel,
                                            NULL, dwCapabilities);

        if(pPrincipal)
            CoTaskMemFree(pPrincipal);
        pFromSec->Release();

    }
    return sc;
}


//***************************************************************************
//
//***************************************************************************

CForwardingSink::CForwardingSink(CBasicObjectSink* pDest, long lRef)
    : CObjectSink(lRef),
        m_pDestIndicate(pDest->GetIndicateSink()),
        m_pDestStatus(pDest->GetStatusSink()),
        m_pDest(pDest)
{
    m_pDestIndicate->AddRef();
    m_pDestStatus->AddRef();
    m_pDest->AddRef();
}

//***************************************************************************
//
//***************************************************************************

CForwardingSink::~CForwardingSink()
{
    if(m_pDestIndicate)
        m_pDestIndicate->Release();
    if(m_pDestStatus)
        m_pDestStatus->Release();
    if(m_pDest)
        m_pDest->Release();
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CForwardingSink::Indicate(long lObjectCount,
                                       IWbemClassObject** pObjArray)
{
    return m_pDestIndicate->Indicate(lObjectCount, pObjArray);
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CForwardingSink::SetStatus(long lFlags, long lParam,
                                    BSTR strParam, IWbemClassObject* pObjParam)
{
    return m_pDestStatus->SetStatus(lFlags, lParam, strParam, pObjParam);
}


//***************************************************************************
//
//***************************************************************************

CCombiningSink::CCombiningSink(CBasicObjectSink* pDest, HRESULT hresToIgnore)
    : CForwardingSink(pDest, 0), m_hresToIgnore(hresToIgnore),
        m_hres(WBEM_S_NO_ERROR), m_pErrorObj(NULL), m_strParam(NULL)
{
}

//***************************************************************************
//
//***************************************************************************

CCombiningSink::~CCombiningSink()
{
    // Time to call SetStatus on the destination
    // =========================================

    m_pDestStatus->SetStatus(0, m_hres,
        (SUCCEEDED(m_hres)?m_strParam:NULL),
        (SUCCEEDED(m_hres)?NULL:m_pErrorObj)
    );

    if(m_pErrorObj)
        m_pErrorObj->Release();
    SysFreeString(m_strParam);
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCombiningSink::SetStatus(long lFlags, long lParam, BSTR strParam,
                     IWbemClassObject* pObjParam)
{
    if(lFlags != 0)
        return m_pDestStatus->SetStatus(lFlags, lParam, strParam, pObjParam);

    // An error occurred. For now, only store one
    // ==========================================

    if(strParam)
    {
        SysFreeString(m_strParam);
        m_strParam = SysAllocString(strParam);
    }
    CInCritSec ics(&m_cs);
    if(SUCCEEDED(m_hres) || (m_pErrorObj == NULL && pObjParam != NULL))
    {
        // This error needs to be recorded
        // ===============================

        if(FAILED(lParam))
        {
            // Record the error code, unless it is to be ignored
            // =================================================

            if(lParam != m_hresToIgnore)
            {
                m_hres = lParam;
            }

            // Record the error object anyway
            // ==============================

            if(m_pErrorObj)
                m_pErrorObj->Release();
            m_pErrorObj = pObjParam;
            if(m_pErrorObj)
                m_pErrorObj->AddRef();
        }
        else
        {
            if(lParam != m_hresToIgnore)
            {
                m_hres = lParam;
            }
        }
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

CAnySuccessSink::~CAnySuccessSink()
{
    // If no real success occurred, report a failure
    // =============================================

    if(!m_bSuccess && SUCCEEDED(m_hres))
    {
        // We must report a failure since there were no successes, but there
        // were no real failures either, so we must create an error code.
        // =================================================================
        if(m_hresIgnored == 0)
            m_hres = m_hresNotError1;
        else
            m_hres = m_hresIgnored;
    }
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CAnySuccessSink::SetStatus(long lFlags, long lParam, BSTR strParam,
                     IWbemClassObject* pObjParam)
{
    if(lFlags == 0)
    {
        if(SUCCEEDED(lParam))
            m_bSuccess = TRUE;
        else if(lParam == m_hresNotError1 && m_hresIgnored == 0)
        {
            m_hresIgnored = m_hresNotError1;
            lParam = WBEM_S_NO_ERROR;
        }
        else if(lParam == m_hresNotError2)
        {
            m_hresIgnored = m_hresNotError2;
            lParam = WBEM_S_NO_ERROR;
        }
    }
    return CCombiningSink::SetStatus(lFlags, lParam, strParam, pObjParam);
}

//***************************************************************************
//
//***************************************************************************


STDMETHODIMP COperationErrorSink::SetStatus(long lFlags, long lParam,
                     BSTR strParam, IWbemClassObject* pObjParam)
{
    if(lFlags == 0 && FAILED(lParam))
    {
        HRESULT hres = WBEM_S_NO_ERROR;
        IWbemClassObject* pErrorObj = NULL;
        bool    bErr = false;

        try
        {
            CErrorObject Error(pObjParam);
            Error.SetOperation(m_wsOperation);
            Error.SetParamInformation(m_wsParameter);
            Error.SetProviderName(m_wsProviderName);
            pErrorObj = Error.GetObject();
        }

        // If an exception occurs, send the error to the client and
        // return an error from the call.
        catch ( CX_MemoryException )
        {
            lParam = WBEM_E_OUT_OF_MEMORY;
            bErr = true;
        }
        catch(...)
        {
	        ExceptionCounter c;        
            lParam = WBEM_E_CRITICAL_ERROR;
            bErr = true;
        }

        hres = m_pDestStatus->SetStatus(lFlags, lParam, strParam, pErrorObj);

        if ( NULL != pErrorObj )
        {
            pErrorObj->Release();
        }

        if ( bErr )
        {
            hres = lParam;
        }

        return hres;
    }
    else if(m_bFinal &&
            lFlags != WBEM_STATUS_COMPLETE && lFlags != WBEM_STATUS_PROGRESS)
    {
        DEBUGTRACE((LOG_WBEMCORE, "Ignoring internal SetStatus call to the "
            "client: 0x%X 0x%X %S\n", lFlags, lParam, strParam));
        return WBEM_S_FALSE;
    }
    else if(lFlags == 0 && strParam &&
            !m_wsOperation.EqualNoCase(L"PutInstance"))
    {
        ERRORTRACE((LOG_WBEMCORE, "Provider used strParam in SetStatus "
            "outside of PutInstance! Actual operation was <%S>, string was <%S>. Ignoring\n", (const wchar_t*)m_wsOperation, strParam));

        return m_pDestStatus->SetStatus(lFlags, lParam, NULL, pObjParam);
    }
    else
    {
        return m_pDestStatus->SetStatus(lFlags, lParam, strParam, pObjParam);
    }
}

//***************************************************************************
//
//***************************************************************************

void COperationErrorSink::SetProviderName(LPCWSTR wszName)
{
    m_wsProviderName = wszName;
}

//***************************************************************************
//
//***************************************************************************

void COperationErrorSink::SetParameterInfo(LPCWSTR wszParam)
{
    m_wsParameter = wszParam;
}


//***************************************************************************
//
//***************************************************************************

CDecoratingSink::CDecoratingSink(CBasicObjectSink* pDest,
                                    CWbemNamespace* pNamespace)
    : CForwardingSink(pDest, 0), m_pNamespace(pNamespace)
{
    m_pNamespace->AddRef();
}

//***************************************************************************
//
//***************************************************************************

CDecoratingSink::~CDecoratingSink()
{
    m_pNamespace->Release();
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CDecoratingSink::Indicate(long lNumObjects,
                                           IWbemClassObject** apObjects)
{
    // Clone the indicated objects before decorating
    HRESULT hres = WBEM_S_NO_ERROR;

    if ( lNumObjects > 0 )
    {

        // We will optimize for indicates of a single object (which will probably
        // be the most likely type of indicate.  In which case we won't allocate any
        //  memory for the cloned object array, and rather will just use a stack variable.

        IWbemClassObject*   pClonedObject = NULL;
        IWbemClassObject**  apClonedObjects = &pClonedObject;

        if ( lNumObjects > 1 )
        {
            try
            {
                // Allocate an array and zero it out
                apClonedObjects = new IWbemClassObject*[lNumObjects];

                if ( NULL != apClonedObjects )
                {
                    ZeroMemory( apClonedObjects, lNumObjects * sizeof(IWbemClassObject*) );
                }
                else
                {
                    hres = WBEM_E_OUT_OF_MEMORY;
                }
            }
            catch( CX_MemoryException )
            {
                hres = WBEM_E_OUT_OF_MEMORY;
            }
            catch(...)
            {
		        ExceptionCounter c;            
                hres = WBEM_E_FAILED;
            }
        }

        if ( SUCCEEDED( hres ) )
        {
            // Clone the objects into the array (error out if this fails)
            for ( long lCtr = 0; SUCCEEDED( hres ) && lCtr < lNumObjects; lCtr++ )
            {
                if ( NULL != apObjects[lCtr] )
                {
                    hres = apObjects[lCtr]->Clone( &apClonedObjects[lCtr] );
                }
                else
                {
                    apClonedObjects[lCtr] = NULL;
                }
            }

            // Now decorate the cloned objects and indicate them
            if ( SUCCEEDED( hres ) )
            {
                for(int i = 0; i < lNumObjects; i++)
                {
                    m_pNamespace->DecorateObject(apClonedObjects[i]);
                }

                hres = m_pDestIndicate->Indicate(lNumObjects, apClonedObjects);
            }

            // Clean up the array
            for ( lCtr = 0; lCtr < lNumObjects; lCtr++ )
            {
                // Check for NULLs
                if ( NULL != apClonedObjects[lCtr] )
                {
                    apClonedObjects[lCtr]->Release();
                }
            }

            // If we actually allocated memory, we need to clean it up here
            if ( apClonedObjects != &pClonedObject )
            {
                delete [] apClonedObjects;
            }

        }   // IF we allocated our block appropriately

    }
    else
    {
        hres = m_pDestIndicate->Indicate(lNumObjects, apObjects);
    }

    return hres;
}


//***************************************************************************
//
//***************************************************************************

CSingleMergingSink::~CSingleMergingSink()
{
    if(SUCCEEDED(m_hres))
    {
        if(m_pResult == NULL)
        {
            // Nobody succeeded, but nobody failed either. Not found
            // =====================================================

            m_hres = WBEM_E_NOT_FOUND;
        }
        else if(m_pResult->InheritsFrom(m_wsTargetClass) == S_OK)
        {
            m_pDestIndicate->Indicate(1, &m_pResult);
        }
        else
        {
            // Found somewhere, but not in this class
            // ======================================

            m_hres = WBEM_E_NOT_FOUND;
        }
    }
    if(m_pResult)
        m_pResult->Release();
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CSingleMergingSink::Indicate(long lNumObjects,
                                           IWbemClassObject** apObjects)
{
    CInCritSec ics(&m_cs);
    if(lNumObjects != 1)
    {
        ERRORTRACE((LOG_WBEMCORE, "Provider gave %d objects for GetObject!\n",
            lNumObjects));
        return WBEM_S_NO_ERROR;
    }

    if(m_pResult == NULL)
    {
        apObjects[0]->Clone(&m_pResult);
        return WBEM_S_NO_ERROR;
    }

    CVar vName;
    ((CWbemInstance*)m_pResult)->GetClassName(&vName);

    if(apObjects[0]->InheritsFrom(vName.GetLPWSTR()) == S_OK)
    {
        IWbemClassObject* pClone;
        apObjects[0]->Clone(&pClone);

        HRESULT hres = CWbemInstance::AsymmetricMerge((CWbemInstance*)m_pResult,
                    (CWbemInstance*)pClone);

        if(FAILED(hres))
        {
            ERRORTRACE((LOG_WBEMCORE, "Failed to merge instances!!\n"));
            pClone->Release();
        }
        else
        {
            m_pResult->Release();
            m_pResult = pClone; // already AddRefed
        }
    }
    else
    {
        HRESULT hres = CWbemInstance::AsymmetricMerge(
                    (CWbemInstance*)apObjects[0], (CWbemInstance*)m_pResult);

        if(FAILED(hres))
        {
            ERRORTRACE((LOG_WBEMCORE, "Failed to merge instances!!\n"));
        }
    }
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

CLocaleMergingSink::CLocaleMergingSink(CBasicObjectSink *pDest, LPCWSTR wszLocale, LPCWSTR pNamespace)
    : CCombiningSink(pDest, WBEM_S_NO_ERROR),
      m_wsLocale(wszLocale),
      m_pPrimaryNs(NULL),
      m_pPrimarySession(NULL),
      m_pPrimaryDriver(NULL),

      m_pDefaultNs(NULL),
      m_pDefaultSession(NULL),
      m_pDefaultDriver(NULL)
{
    GetDbPtr(pNamespace);
}

CLocaleMergingSink::~CLocaleMergingSink()
{
    releaseNS();
}

//***************************************************************************
//
//***************************************************************************

HRESULT CLocaleMergingSink::LocalizeQualifiers(bool bInstance, bool bParentLocalized,
                                               IWbemQualifierSet *pBase, IWbemQualifierSet *pLocalized, bool &bChg)
{
    HRESULT hrInner;
    HRESULT hr = WBEM_S_NO_ERROR;

    pLocalized->BeginEnumeration(0);

    BSTR strName = NULL;
    VARIANT vVal;
    VariantInit(&vVal);

    long lFlavor;
    while(pLocalized->Next(0, &strName, &vVal, &lFlavor) == S_OK)
    {
        // Ignore if this is an instance.

        if (bInstance && !(lFlavor & WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE))
        {
            VariantClear(&vVal);
            SysFreeString(strName);
            continue;
        }

        if (!_wcsicmp(strName, L"amendment") ||
            !_wcsicmp(strName, L"key") ||
            !_wcsicmp(strName, L"singleton") ||
            !_wcsicmp(strName, L"dynamic") ||
            !_wcsicmp(strName, L"indexed") ||
            !_wcsicmp(strName, L"cimtype") ||
            !_wcsicmp(strName, L"static") ||
            !_wcsicmp(strName, L"implemented") ||
            !_wcsicmp(strName, L"abstract"))
        {
            VariantClear(&vVal);
            SysFreeString(strName);
            continue;
        }

        // If this is not a propagated qualifier,
        // ignore it.  (Bug #45799)
        // =====================================

        if (bParentLocalized &&
            !(lFlavor & WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS))
        {
            VariantClear(&vVal);
            SysFreeString(strName);
            continue;
        }

        // Now, we need to test for this in the other
        // class.
        // The only localized qualifiers that do not override the
        // default are where only parent qualifiers exist, but the
        // child has overriden its own parent.
        // =======================================================

        VARIANT vBasicVal;
        VariantInit(&vBasicVal);
        long lBasicFlavor;
         
        hrInner = pBase->Get(strName, 0, &vBasicVal, &lBasicFlavor);

        if (hrInner != WBEM_E_NOT_FOUND)
        {
            if (bParentLocalized &&                             // If there is no localized copy of this class
                (lBasicFlavor & WBEM_FLAVOR_OVERRIDABLE) &&     // .. and this is an overridable qualifier
                 (lBasicFlavor & WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS) && // and this is propogated
                 (lBasicFlavor & WBEM_FLAVOR_ORIGIN_LOCAL))     // .. and this was actualy overridden
            {
                VariantClear(&vVal);                            // .. DON'T DO IT.
                VariantClear(&vBasicVal);
                SysFreeString(strName);
                continue;
            }

            if (bParentLocalized &&
                !(lBasicFlavor & WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS))
            {
                VariantClear(&vVal);
                VariantClear(&vBasicVal);
                SysFreeString(strName);
                continue;
            }
        }

        pBase->Put(strName, &vVal, (lFlavor&~WBEM_FLAVOR_ORIGIN_PROPAGATED) | WBEM_FLAVOR_AMENDED);
        bChg = true;

        VariantClear(&vVal);
        VariantClear(&vBasicVal);
        SysFreeString(strName);

    }
    return hr;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CLocaleMergingSink::LocalizeProperties(bool bInstance, bool bParentLocalized, IWbemClassObject *pOriginal,
                                               IWbemClassObject *pLocalized, bool &bChg)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    pLocalized->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);

    BSTR strPropName;
    LONG lLong;
    CIMTYPE ct;
    VARIANT vNewVal;

    while(pLocalized->Next(0, &strPropName, &vNewVal, &ct, &lLong) == S_OK)
    {
        IWbemQualifierSet *pLocalizedQs = NULL, *pThisQs = NULL;
        VARIANT vBasicVal;
        VariantInit(&vBasicVal);

        if (FAILED(pLocalized->GetPropertyQualifierSet(strPropName,&pLocalizedQs)))
        {
            SysFreeString(strPropName);
            VariantClear(&vNewVal);
            continue;
        }
        CReleaseMe rm1(pLocalizedQs);

        if (FAILED(pOriginal->GetPropertyQualifierSet(strPropName, &pThisQs)))
        {
            SysFreeString(strPropName);
            VariantClear(&vNewVal);
            continue;
        }
        CReleaseMe rm2(pThisQs);

        hr = LocalizeQualifiers(bInstance, bParentLocalized, pThisQs, pLocalizedQs, bChg);
        if (FAILED(hr))
        {
            SysFreeString(strPropName);
            VariantClear(&vNewVal);
            continue;
        }

        SysFreeString(strPropName);
        VariantClear(&vNewVal);

    }

    pLocalized->EndEnumeration();

    return hr;
}

//***************************************************************************
//
//***************************************************************************

// This function sets up the pointer to the localized namespace.

void CLocaleMergingSink::GetDbPtr(const wchar_t * name_space)
{
    if (m_pThisNamespace.EqualNoCase(name_space))
      return;

    releaseNS();

    m_pThisNamespace = name_space;
        if (wcslen(name_space) == 0)
            return;


    WString sNsName;
    sNsName = m_pThisNamespace;
    sNsName += L"\\";
    sNsName += m_wsLocale;

    IWmiDbSession *pTempSession = NULL;
    HRESULT hRes = CRepository::GetDefaultSession(&pTempSession);
    if (FAILED(hRes))
        return;

    hRes = CRepository::OpenScope(pTempSession, sNsName, 0, &m_pPrimaryDriver, &m_pPrimarySession, 0, &m_pPrimaryNs);


    if (_wcsicmp(m_wsLocale, L"ms_409"))
    {
        sNsName = m_pThisNamespace;
        sNsName += L"\\ms_409";
        hRes = CRepository::OpenScope(pTempSession, sNsName, 0, &m_pDefaultDriver, &m_pDefaultSession, 0, &m_pDefaultNs);
    }

    pTempSession->Release();

}

void CLocaleMergingSink::releaseNS(void)
{
  ReleaseIfNotNULL(m_pPrimarySession);
  ReleaseIfNotNULL(m_pDefaultSession);
  ReleaseIfNotNULL(m_pPrimaryNs);
  ReleaseIfNotNULL(m_pPrimaryDriver);
  ReleaseIfNotNULL(m_pDefaultNs);
  ReleaseIfNotNULL(m_pDefaultDriver);

  m_pPrimarySession = 0;
  m_pDefaultSession = 0;
  m_pPrimaryNs = 0;
  m_pPrimaryDriver = 0;
  m_pDefaultNs = 0;
  m_pDefaultDriver = 0;
};

bool CLocaleMergingSink::hasLocale(const wchar_t * name_space)
{
  GetDbPtr(name_space) ;
  return (m_pPrimaryNs || m_pDefaultNs);
};

//***************************************************************************
//
//***************************************************************************

// Do the work.

STDMETHODIMP CLocaleMergingSink::Indicate(long lNumObjects,
                                           IWbemClassObject** apObjects)
{
    CInCritSec ics(&m_cs);
    IWbemQualifierSet *pLocalizedQs = NULL, *pThisQs = NULL;
    bool bParentLocalized = false;
    bool bInstance = false;
    HRESULT hr = WBEM_S_NO_ERROR;
    HRESULT hRes;

        for (int i = 0; i < lNumObjects; i++)
        {
                CWbemObject *pResult = (CWbemObject *)apObjects[i];

                CVar vServer;
                if (FAILED(pResult->GetProperty(L"__SERVER", &vServer)) || vServer.IsNull())
                        continue;
                if (_wcsicmp(LPWSTR(vServer), ConfigMgr::GetMachineName())!=0)
                        continue;
                VARIANT name_space;
                VariantInit(&name_space);
                CClearMe cm(&name_space);

                HRESULT hres = pResult->Get(L"__NAMESPACE", 0, &name_space, NULL, NULL);
                if (FAILED(hres) || hasLocale (V_BSTR(&name_space)) == false)
                  continue;

                if (pResult->IsInstance())
                        bInstance = true;

                CVar vName, vDeriv;
                if (FAILED(pResult->GetClassName(&vName)))
                	continue;
                
                WString wKey;
                int nRes = 0;
                bool bChg = false;

                // Does this instance exist in the localized namespace?
                // Does this class exist in the localized namespace?
                // If not, loop through all the parents until we
                // run out or we have a hit.
                // =================================================

                CWbemObject *pClassDef = NULL;

                if (wcslen(vName.GetLPWSTR()) > 0)
                {
                        WString sName = vName.GetLPWSTR();

                        hRes = WBEM_E_NOT_FOUND;
                        if (m_pPrimaryNs)
                                hRes = CRepository::GetObject(m_pPrimarySession, m_pPrimaryNs, sName, 0, (IWbemClassObject **) &pClassDef);

                        if (FAILED(hRes) && m_pDefaultNs)
                                hRes = CRepository::GetObject(m_pDefaultSession, m_pDefaultNs, sName, 0, (IWbemClassObject **) &pClassDef);

                        if (hRes == WBEM_E_NOT_FOUND)
                        {
                                bParentLocalized = TRUE;

                                pResult->GetDerivation(&vDeriv);
                                CVarVector *pvTemp = vDeriv.GetVarVector();

                                for (int j = 0; j < pvTemp->Size(); j++)
                                {
                                        CVar vParentName = pvTemp->GetAt(j);
                                        WString sParentName = vParentName.GetLPWSTR();

                                        hRes = WBEM_E_NOT_FOUND;

                                        if (m_pPrimaryNs)
                                                hRes = CRepository::GetObject(m_pPrimarySession, m_pPrimaryNs, sParentName, 0, (IWbemClassObject **) &pClassDef);

                                        if (FAILED(hRes) && m_pDefaultNs)
                                                hRes = CRepository::GetObject(m_pDefaultSession, m_pDefaultNs, sParentName, 0, (IWbemClassObject **) &pClassDef);
                                }
                        }
                }


                if (pClassDef == NULL)
                {
                        nRes = WBEM_S_NO_ERROR;
                        continue;
                }

                CReleaseMe rm11((IWbemClassObject*)pClassDef);

                // At this point, we have the localized copy, and are
                // ready to combine qualifiers.  Start with class qualifiers.
                // ============================================================

                if (FAILED(pClassDef->GetQualifierSet(&pLocalizedQs)))
                        continue;

                if (FAILED(pResult->GetQualifierSet(&pThisQs)))
                {
                        pLocalizedQs->Release();
                        continue;
                }

                hr = LocalizeQualifiers(bInstance, bParentLocalized, pThisQs, pLocalizedQs, bChg);

                pLocalizedQs->EndEnumeration();
                pLocalizedQs->Release();
                pThisQs->Release();
                if (FAILED(hr))
                        break;

                hr = LocalizeProperties(bInstance, bParentLocalized, pResult, pClassDef, bChg);

                // Methods.
                // Putting a method cancels enumeration, so we have to enumerate first.

                IWbemClassObject *pLIn = NULL, *pLOut = NULL;
                IWbemClassObject *pOIn = NULL, *pOOut = NULL;
                BSTR bstrMethodName = NULL ;
                int iPos = 0;

                pClassDef->BeginMethodEnumeration(0);
                while ( pClassDef->NextMethod(0, &bstrMethodName, 0, 0) == S_OK )
                {
                        pLIn = NULL;
                        pOIn = NULL;
                        pLOut = NULL;
                        pOOut = NULL;

                        pClassDef->GetMethod(bstrMethodName, 0, &pLIn, &pLOut);
                        hr = pResult->GetMethod(bstrMethodName, 0, &pOIn, &pOOut);

                        CSysFreeMe fm(bstrMethodName);
                        CReleaseMe rm0(pLIn);
                        CReleaseMe rm1(pOIn);
                        CReleaseMe rm2(pLOut);
                        CReleaseMe rm3(pOOut);

                        // METHOD IN PARAMETERS
                        if (pLIn)
                                if (pOIn)
                                        hr = LocalizeProperties(bInstance, bParentLocalized, pOIn, pLIn, bChg);

                        if (pLOut)
                                if (pOOut)
                                        hr = LocalizeProperties(bInstance, bParentLocalized, pOOut, pLOut, bChg);

                        // METHOD QUALIFIERS

                        hr = pResult->GetMethodQualifierSet(bstrMethodName, &pThisQs);
                        if (FAILED(hr))
                        {
                                continue;
                        }

                        hr = pClassDef->GetMethodQualifierSet(bstrMethodName, &pLocalizedQs);
                        if (FAILED(hr))
                        {
                                pThisQs->Release();
                                continue;
                        }

                        hr = LocalizeQualifiers(bInstance, bParentLocalized, pThisQs, pLocalizedQs, bChg);

                        pResult->PutMethod(bstrMethodName, 0, pOIn, pOOut);

                        pThisQs->Release();
                        pLocalizedQs->Release();

                }
                pClassDef->EndMethodEnumeration();

                if (bChg)
                        pResult->SetLocalized(true);


        }

    for(int i = 0; i < lNumObjects; i++)
    {
        CWbemObject *pResult = (CWbemObject *)apObjects[i];
        if (FAILED(pResult->ValidateObject(WMIOBJECT_VALIDATEOBJECT_FLAG_FORCE)))
        	DebugBreak();
    }

    m_pDestIndicate->Indicate(lNumObjects, apObjects);

    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCountedSink::Indicate(long lNumObjects,
                                    IWbemClassObject** apObjects)
{
    if(lNumObjects != 1)
        return WBEM_E_UNEXPECTED;

    DWORD dwNewSent = (DWORD)InterlockedIncrement((LONG*)&m_dwSent);
    if(dwNewSent > m_dwMax)
        return WBEM_E_UNEXPECTED;

    m_pDestIndicate->Indicate(1, apObjects);

    if(dwNewSent == m_dwMax)
    {
        m_pDestStatus->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);
        return WBEM_S_FALSE;
    }
    else return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCountedSink::SetStatus(long lFlags, long lParam,
                        BSTR strParam, IWbemClassObject* pObjParam)
{
    // If SetStatus is 0, indicating that the enum is finished, but we
    // didn't send back the requested number of objects, we should
    // SetStatus to WBEM_S_FALSE.

    if ( WBEM_S_NO_ERROR == lParam )
    {
        if ( m_dwSent != m_dwMax )
        {
            lParam = WBEM_S_FALSE;
        }
    }

    return m_pDestStatus->SetStatus( lFlags, lParam, strParam, pObjParam );

}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CFilteringSink::Indicate(long lObjectCount,
                                    IWbemClassObject** apObjects)
{
    try
    {
	    // Allocate new array
	    // ==================

	    IWbemClassObject** apNewArray = new IWbemClassObject*[lObjectCount];

	    wmilib::auto_buffer<IWbemClassObject*> rm_(apNewArray);

	    if (!apNewArray)
	        return WBEM_E_OUT_OF_MEMORY;

	    long lNewIndex = 0;
	    for(int i = 0; i < lObjectCount; i++)
	    {
	        if(Test((CWbemObject*)apObjects[i]))
	        {
	            apNewArray[lNewIndex++] = apObjects[i];
	        }
	    }

	    HRESULT hres = WBEM_S_NO_ERROR;
	    if(lNewIndex > 0)
	    {
	        hres = m_pDestIndicate->Indicate(lNewIndex, apNewArray);
	    }

	    return hres;
    }
    catch (CX_MemoryException &) // becasue Test uses CStack that throws
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CErrorChangingSink::SetStatus(long lFlags, long lParam,
                        BSTR strParam, IWbemClassObject* pObjParam)
{
    if(lFlags == 0 && lParam == m_hresFrom)
        return m_pDestStatus->SetStatus(0, m_hresTo, NULL, NULL);
    else
        return m_pDestStatus->SetStatus(lFlags, lParam, strParam, pObjParam);
}

//***************************************************************************
//
//***************************************************************************

CNoDuplicatesSink::CNoDuplicatesSink(CBasicObjectSink* pDest)
    : CFilteringSink(pDest), m_strDupClass(NULL)
{
}

//***************************************************************************
//
//***************************************************************************

CNoDuplicatesSink::~CNoDuplicatesSink()
{
    SysFreeString(m_strDupClass);
}

//***************************************************************************
//
//***************************************************************************

BOOL CNoDuplicatesSink::Test(CWbemObject* pObj)
{
    CInCritSec ics(&m_cs);

    // Get the path
    // ============

    CVar vPath;
    if(FAILED(pObj->GetPath(&vPath)) || vPath.IsNull()) return FALSE;

    if(m_mapPaths.find(vPath.GetLPWSTR()) == m_mapPaths.end())
    {
        m_mapPaths[vPath.GetLPWSTR()] = true;
        return TRUE;
    }
    else
    {
        // Duplicate!
        // ==========

        ERRORTRACE((LOG_WBEMCORE, "Duplicate objects returned with path %S\n",
            vPath.GetLPWSTR()));

        ConfigMgr::GetEventLog()->Report(EVENTLOG_ERROR_TYPE,
                            WBEM_MC_DUPLICATE_OBJECTS, vPath.GetLPWSTR());

        if(m_strDupClass == NULL)
        {
            m_strDupClass = SysAllocString(vPath.GetLPWSTR());
        }
        return FALSE;
    }
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CNoDuplicatesSink::SetStatus(long lFlags, long lParam,
                            BSTR strParam, IWbemClassObject* pObjParam)
{
    if(lFlags == WBEM_STATUS_COMPLETE && lParam == WBEM_S_NO_ERROR &&
        m_strDupClass != NULL)
    {
        // Success is being reported, but we have seen duplications
        // ========================================================

        return CFilteringSink::SetStatus(lFlags, WBEM_S_DUPLICATE_OBJECTS,
                                            m_strDupClass, pObjParam);
    }
    else
    {
        return CFilteringSink::SetStatus(lFlags, lParam, strParam, pObjParam);
    }
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CHandleClassProvErrorsSink::SetStatus(long lFlags, long lParam,
                        BSTR strParam, IWbemClassObject* pObjParam)
{
    if(lFlags == WBEM_STATUS_COMPLETE && FAILED(lParam) &&
        lParam != WBEM_E_NOT_FOUND)
    {
        // Log an error into the event log
        // ===============================

        ERRORTRACE((LOG_WBEMCORE,
            "Class provider '%S' installed in namespace '%S' failed to enumerate classes, "
            "returning error code 0x%lx. Operations will continue as if the class provider "
            "had no classes.  This provider-specific error condition needs to be corrected "
            "before this class provider can contribute to this namespace.\n",
            (LPWSTR)m_wsProvider, (LPWSTR) m_wsNamespace, lParam));

        lParam = WBEM_E_NOT_FOUND;
    }

    return CForwardingSink::SetStatus(lFlags, lParam, strParam, pObjParam);
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CSuccessSuppressionSink::SetStatus(long lFlags, long lParam,
                        BSTR strParam, IWbemClassObject* pObjParam)
{
    if(lFlags != WBEM_STATUS_COMPLETE ||
            (FAILED(lParam) && lParam != m_hresNotError1 &&
                lParam != m_hresNotError2))
    {
        return CForwardingSink::SetStatus(lFlags, lParam, strParam, pObjParam);
    }
    else
    {
        return WBEM_S_NO_ERROR;
    }
}

//***************************************************************************
//
//***************************************************************************
#ifdef OLD
CWrapperMap::CWrapperMap()
{
}

//***************************************************************************
//
//***************************************************************************

CWrapperMap::~CWrapperMap()
{
}

//***************************************************************************
//
//***************************************************************************

void CWrapperMap::Map(const REQUESTID& id, IWbemObjectSink* pSink,
                        CWrapperSink* pWrapper)
{
    CInCritSec ics(&m_cs);

    m_mapSink.insert(TValueType(pSink, id));
    m_mapGuid[id] = pWrapper;
}

//***************************************************************************
//
//***************************************************************************

RELEASE_ME CWrapperSink* CWrapperMap::FindWrapper(const GUID& id)
{
    CInCritSec ics(&m_cs);

    CWrapperSink* pWrapper = NULL;
    if(m_mapGuid.find(id) != m_mapGuid.end())
    {
        pWrapper = m_mapGuid[id];
        pWrapper->AddRef();
    }
    return pWrapper;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWrapperMap::FindWrappers(IWbemObjectSink* pSink,
                            CRefedPointerArray<CWrapperSink>& apWrappers)
{
    CInCritSec ics(&m_cs);

    TIterator it = m_mapSink.find(pSink);
    while(it != m_mapSink.end() && it->first == pSink)
    {
        GUID& rguid = it->second;
        apWrappers.Add(m_mapGuid[rguid]);
        it++;
    }
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

void CWrapperMap::Unmap(const REQUESTID& id, IWbemObjectSink* pSink)
{
    CInCritSec ics(&m_cs);

    m_mapGuid.erase(id);

    TIterator it = m_mapSink.find(pSink);
    while(it != m_mapSink.end() && it->first == pSink)
    {
        if(it->second == id)
        {
            m_mapSink.erase(it);
            return;
        }
        it++;
    }

    ERRORTRACE((LOG_WBEMCORE, "Unable to unmap a sink --- not found\n"));
}
#endif


//***************************************************************************
//
//***************************************************************************

CDynPropsSink::CDynPropsSink(CBasicObjectSink* pDest, CWbemNamespace * pNs, long lRef) : CForwardingSink(pDest, lRef)
{
    m_pNs = pNs;
    if(m_pNs)
        m_pNs->AddRef();
}

//***************************************************************************
//
//***************************************************************************

CDynPropsSink::~CDynPropsSink()
{
    //
	// Removing the impersonation at this point. There is no need to impersonate
	// at this point since the sink below it is the CCombiningSink eventually 
	// ending up at the finalizer which correctly makes the calls to the client
	//
	//CAutoImpersonate ai;
	//

    // Send all the cached entries

    DWORD dwCacheSize = m_UnsentCache.GetSize();
    for(DWORD dwCnt = 0; dwCnt < dwCacheSize; dwCnt++)
    {
        IWbemClassObject* pObj = m_UnsentCache[dwCnt];
        if(m_pNs)
            m_pNs->GetOrPutDynProps((CWbemObject *)pObj, CWbemNamespace::GET);
        m_pDestIndicate->Indicate(1, &pObj);
    }
    if(m_pNs)
        m_pNs->Release();

}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CDynPropsSink::Indicate(long lObjectCount,
                                       IWbemClassObject** pObjArray)
{
    // If there are no dyn props then immediately do the indicate

    IWbemClassObject** apNewArray = new IWbemClassObject*[lObjectCount];
    if (!apNewArray)
        return WBEM_E_OUT_OF_MEMORY;

    CVar vDynTest;
    HRESULT hRes = S_OK;
    long lIndex = 0 ;
    for(long lCnt = 0; lCnt < lObjectCount; lCnt++)
    {
        CWbemObject *pWbemObj = (CWbemObject *)pObjArray[lCnt];
        HRESULT hres = pWbemObj->GetQualifier(L"DYNPROPS", &vDynTest);
        if (hres == S_OK && vDynTest.GetBool() == VARIANT_TRUE)
        {
            hRes = m_UnsentCache.Add(pWbemObj);
        }
        else
        {
            apNewArray[lIndex++] = pObjArray[lCnt] ;
        }
    }

    if ( lIndex )
    {
        CAutoImpersonate ai;

        hRes = m_pDestIndicate->Indicate(lIndex, apNewArray);

		if ( FAILED ( ai.Impersonate ( ) ) )
		{
			hRes = WBEM_E_FAILED ;
		}
    }

    delete [] apNewArray ;

    return hRes;
}


//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CMethodSink::Indicate(long lObjectCount,
                                       IWbemClassObject** pObjArray)
{
    if(lObjectCount == 1 && m_pRes == NULL)
    {
        pObjArray[0]->Clone(&m_pRes);
    }
    return S_OK;
}

STDMETHODIMP CMethodSink::SetStatus(long lFlags, long lParam,
                        BSTR strParam, IWbemClassObject* pObjParam)
{
    if(lParam == S_OK && m_pRes)
    {
        m_pDestIndicate->Indicate(1, &m_pRes);
    }
    if(m_pRes)
        m_pRes->Release();

    return CForwardingSink::SetStatus(lFlags, lParam, strParam, pObjParam);
}

//***************************************************************************
//
//  ZapWriteOnlyProps
//
//  Removes write-only properties from an object.
//  Precondition: Object has been tested for presence of "HasWriteOnlyProps"
//  on the object itself.
//
//***************************************************************************

static HRESULT ZapWriteOnlyProps(IWbemClassObject *pObj)
{
    VARIANT v;
    VariantInit(&v);
    V_VT(&v) = VT_NULL;

    SAFEARRAY *pNames = 0;
    pObj->GetNames(L"WriteOnly", WBEM_FLAG_ONLY_IF_TRUE, 0, &pNames);
    LONG lUpper;
    SafeArrayGetUBound(pNames, 1, &lUpper);

    for (long i = 0; i <= lUpper; i++)
    {
        BSTR strName = 0;
        SafeArrayGetElement(pNames, &i, &strName);
        pObj->Put(strName, 0, &v, 0);
    }
    SafeArrayDestroy(pNames);

    return WBEM_S_NO_ERROR;
}



//***************************************************************************
//
//***************************************************************************
//

CStdSink::CStdSink(IWbemObjectSink *pRealDest)
{
    m_pDest = pRealDest;
    m_hRes = 0;
    m_bCancelForwarded = FALSE;
    m_lRefCount = 0L;

    if ( NULL != m_pDest )
        m_pDest->AddRef();

    InterlockedIncrement(&g_nStdSinkCount);
}

//***************************************************************************
//
//***************************************************************************
//

CStdSink::~CStdSink()
{
    if ( NULL != m_pDest )
        m_pDest->Release();

    InterlockedDecrement(&g_nStdSinkCount);
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CStdSink::Cancel()
{
    HRESULT hResTmp;
    m_hRes = WBEM_E_CALL_CANCELLED;

    if (m_bCancelForwarded)
        return m_hRes;

    try
    {
        hResTmp = m_pDest->SetStatus(0, m_hRes, 0, 0);
    }
    catch (...) // untrusted code ?
    {
        ExceptionCounter c;    
        m_hRes = WBEM_E_CRITICAL_ERROR;
    }

    m_bCancelForwarded = TRUE;
    return m_hRes;
}

//***************************************************************************
//
//***************************************************************************
//

ULONG STDMETHODCALLTYPE CStdSink::AddRef()
{
    return InterlockedIncrement( &m_lRefCount );
}

//***************************************************************************
//
//***************************************************************************
//

ULONG STDMETHODCALLTYPE CStdSink::Release()
{
    LONG lRes = InterlockedDecrement( &m_lRefCount );
    if (lRes == 0)
        delete this;
    return lRes;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT STDMETHODCALLTYPE CStdSink::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    return m_pDest->QueryInterface(riid, ppvObj);
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT STDMETHODCALLTYPE CStdSink::Indicate(
    long lObjectCount,
    IWbemClassObject** pObjArray
    )
{
    HRESULT hRes;

    if (m_hRes == WBEM_E_CALL_CANCELLED)
    {
        return Cancel();
    }

    try
    {
        hRes = m_pDest->Indicate(lObjectCount, pObjArray);
    }
    catch (...) // untrusted code ?
    {
        ExceptionCounter c;    
        hRes = Cancel();
    }
    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT STDMETHODCALLTYPE CStdSink::SetStatus(
    long lFlags,
    long lParam,
    BSTR strParam,
    IWbemClassObject* pObjParam
    )
{
    HRESULT hRes;

    if (m_hRes == WBEM_E_CALL_CANCELLED)
    {
        return Cancel();
    }

    try
    {
        hRes = m_pDest->SetStatus(lFlags, lParam, strParam, pObjParam);
    }
    catch (...) // untrusted code ?
    {
        ExceptionCounter c;    
        hRes = Cancel();
    }

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
//

CFlexArray g_aProviderSinks;
CCritSec  g_csProvSinkCs;

//***************************************************************************
//
//***************************************************************************
//

HRESULT WINAPI CProviderSink::Dump(FILE *f)
{

    CInCritSec ics(&g_csProvSinkCs);

    fprintf(f, "---Begin Provider Sink Info---\n");

    for (int i = 0; i < g_aProviderSinks.Size(); i++)
    {
        CProviderSink *pSink = (CProviderSink *) g_aProviderSinks[i];
        if (pSink)
        {
            fprintf(f, "Provider Sink 0x%p\n", pSink);
            fprintf(f, "    Total Indicates = %d\n", pSink->m_lIndicateCount);

			// Check that this is non-NULL
			if ( NULL != pSink->m_pszDebugInfo )
			{
				fprintf(f, "    Debug Info = %S\n", pSink->m_pszDebugInfo);
			}
			else
			{
				fprintf(f, "    Debug Info = NULL\n");
			}
            fprintf(f, "    SetStatus called? %d\n", pSink->m_bDone);
            fprintf(f, "    hRes = 0x%X\n", pSink->m_hRes);
            fprintf(f, "    m_pNextSink = 0x%p\n", pSink->m_pNextSink);
        }
    }

    fprintf(f, "---End Provider Sink Info---\n");
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//
CProviderSink::CProviderSink(
    LONG lStartingRefCount,
    LPWSTR pszDebugInf
    ):m_pNextSink(0)
{
    m_lRefCount = lStartingRefCount;
    InterlockedIncrement(&g_nSinkCount);
    InterlockedIncrement(&g_nProviderSinkCount);
    m_hRes = 0;
    m_bDone = FALSE;
    __try 
    {
        InitializeCriticalSection(&m_cs);
    } 
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        throw CX_MemoryException();
    }
    
    m_lIndicateCount = 0;
    m_pszDebugInfo = 0;

    if (pszDebugInf)
    {
        int nStrLen = wcslen(pszDebugInf);
        m_pszDebugInfo = new wchar_t[nStrLen+1];
        if (m_pszDebugInfo)
            wcscpy(m_pszDebugInfo, pszDebugInf);
    }

    EnterCriticalSection(&g_csProvSinkCs);
    g_aProviderSinks.Add(this);
    LeaveCriticalSection(&g_csProvSinkCs);
}

//***************************************************************************
//
//***************************************************************************
//
CProviderSink::~CProviderSink()
{

    {
        CInCritSec ics(&g_csProvSinkCs);
	    for (int i = 0; i < g_aProviderSinks.Size(); i++)
	    {
	        if (this == (CProviderSink *) g_aProviderSinks[i])
	        {
	            g_aProviderSinks.RemoveAt(i);
	            break;
	        }
	    }
    }

	// Cleanup AFTER we remove from the array so the Diagnostic Thread won't
	// crash.
    ReleaseIfNotNULL(m_pNextSink);
    InterlockedDecrement(&g_nSinkCount);
    InterlockedDecrement(&g_nProviderSinkCount);
    DeleteCriticalSection(&m_cs);
    delete [] m_pszDebugInfo;
}

//***************************************************************************
//
//***************************************************************************
//
ULONG CProviderSink::AddRef()
{
    LONG lRes = InterlockedIncrement(&m_lRefCount);
    return (ULONG) lRes;
}

//***************************************************************************
//
//***************************************************************************
//
ULONG CProviderSink::LocalAddRef()
{
    LONG lRes = InterlockedIncrement(&m_lRefCount);
    return lRes;
}

//***************************************************************************
//
//***************************************************************************
//
ULONG CProviderSink::LocalRelease()
{
    LONG lRes = InterlockedDecrement(&m_lRefCount);
    if (lRes == 0)
        delete this;
    return lRes;
}

//***************************************************************************
//
//***************************************************************************
//
ULONG CProviderSink::Release()
{
    LONG lRes = InterlockedDecrement(&m_lRefCount);

    if (lRes == 0)
        delete this;

    return (ULONG) lRes;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CProviderSink::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    if (riid == IID_IUnknown || riid == IID_IWbemObjectSink)
    {
        *ppvObj = (IWbemObjectSink*)this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CProviderSink::Indicate(
    long lObjectCount,
    IWbemClassObject** pObjArray
    )
{
    if (m_hRes)
        return m_hRes;

	IWbemObjectSink*	pNextSink = NULL;

    {
	    CInCritSec ics(&m_cs);

		pNextSink = m_pNextSink;

		if ( NULL != pNextSink )
		{
			pNextSink->AddRef();
		}
    }

	// AutoRelease
	CReleaseMe	rm( pNextSink );

	HRESULT	hRes;

	if ( NULL != pNextSink )
	{
		m_lIndicateCount += lObjectCount;
		hRes = pNextSink->Indicate(lObjectCount, pObjArray);
	}
	else
	{
		hRes = WBEM_E_CRITICAL_ERROR;
	}

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//
void CProviderSink::Cancel()
{
    if (m_bDone)
        return;

	IWbemObjectSink*	pNextSink = NULL;

    EnterCriticalSection(&m_cs);
    m_hRes = WBEM_E_CALL_CANCELLED;

	pNextSink = m_pNextSink;

	if ( NULL != m_pNextSink )
	{
		// We will release it outside the critical section
		m_pNextSink = NULL;
	}

    LeaveCriticalSection(&m_cs);

	// Auto Release
	CReleaseMe	rm( pNextSink );

    if ( pNextSink )
    {
        pNextSink->SetStatus(0, WBEM_E_CALL_CANCELLED, 0, 0);
	}

}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CProviderSink::SetStatus(
    long lFlags,
    long lParam,
    BSTR strParam,
    IWbemClassObject* pObjParam
    )
{
    if (m_hRes)
        return m_hRes;

	IWbemObjectSink*	pNextSink = NULL;

    EnterCriticalSection(&m_cs);

	pNextSink = m_pNextSink;

	if ( NULL != m_pNextSink )
	{
		// We will always release it outside the critical section

		// If this is the completion status, then we should go ahead and set
		// the member variable to NULL.  We're done with the sink.
		if ( lFlags == WBEM_STATUS_COMPLETE )
		{
			m_pNextSink = NULL;
		}
		else
		{
			pNextSink->AddRef();
		}
	}

    LeaveCriticalSection(&m_cs);

	// Auto Release
	CReleaseMe	rm( pNextSink );

    HRESULT hRes = WBEM_S_NO_ERROR;
	
	if ( NULL != pNextSink )
	{
		pNextSink->SetStatus(lFlags, lParam, strParam, pObjParam);
		m_bDone = TRUE;
	}

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//

long	g_lNumStatusSinks = 0L;

CStatusSink::CStatusSink( void )
:	m_hRes( WBEM_S_NO_ERROR ),
	m_lRefCount( 1 )
{
	InterlockedIncrement( &g_lNumStatusSinks );
}

//***************************************************************************
//
//***************************************************************************
//

CStatusSink::~CStatusSink()
{
	InterlockedDecrement( &g_lNumStatusSinks );
}

//***************************************************************************
//
//***************************************************************************
//

ULONG STDMETHODCALLTYPE CStatusSink::AddRef()
{
    return InterlockedIncrement( &m_lRefCount );
}

//***************************************************************************
//
//***************************************************************************
//

ULONG STDMETHODCALLTYPE CStatusSink::Release()
{
    LONG lRes = InterlockedDecrement( &m_lRefCount );
    if (lRes == 0)
        delete this;
    return lRes;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT STDMETHODCALLTYPE CStatusSink::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    if( riid == IID_IUnknown || riid == IID_IWbemObjectSink )
    {
        *ppvObj = (IWbemObjectSink*)this;
        AddRef();
        return S_OK;
    }

	return E_NOINTERFACE;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT STDMETHODCALLTYPE CStatusSink::Indicate(
    long lObjectCount,
    IWbemClassObject** pObjArray
    )
{
	// Why are we even here??!?!?!?
	_DBG_ASSERT( 0 );
    return WBEM_E_FAILED;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT STDMETHODCALLTYPE CStatusSink::SetStatus(
    long lFlags,
    long lParam,
    BSTR strParam,
    IWbemClassObject* pObjParam
    )
{
	if ( lFlags == WBEM_STATUS_COMPLETE )
	{
		if ( SUCCEEDED( m_hRes ) && FAILED( lParam ) )
		{
			m_hRes = lParam;
		}
	}

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\secure.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    SECURE.CPP

Abstract:

    Contains various routines used for ACL based security.
    It is defined in secure.h

History:

    a-davj    05-NOV-98  Created.

--*/

#include "precomp.h"
#include <wbemcore.h>
#include <oleauto.h>
#include <genutils.h>
#include <safearry.h>
#include <oahelp.inl>
#include <fcntl.h>
#define WBEM_WMISETUP       __TEXT("WMISetup")

class AutoRevert
{
private:
    BOOL m_bWasImpersonating;
public:
    AutoRevert();
    ~AutoRevert();
};

AutoRevert::AutoRevert()
{
    m_bWasImpersonating = WbemIsImpersonating();
    if(m_bWasImpersonating)
        CoRevertToSelf();
}
AutoRevert::~AutoRevert()
{
    if(m_bWasImpersonating)
		CoImpersonateClient();
}

//***************************************************************************
//
//  SetOwnerAndGroup
//
//  Sets the owner and group of the SD to the Admininstrators group
//
//***************************************************************************

BOOL SetOwnerAndGroup(CNtSecurityDescriptor &sd)
{
    PSID pRawSid;
    BOOL bRet = FALSE;

    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
    if(AllocateAndInitializeSid( &id, 2,
        SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
        0,0,0,0,0,0,&pRawSid))
    {
        CNtSid SidAdmins(pRawSid);
        bRet = sd.SetGroup(&SidAdmins);      // Access check doesnt really care what you put, so long as you
                                      // put something for the owner
        if(bRet)
            bRet = sd.SetOwner(&SidAdmins);
        FreeSid(pRawSid);
        return bRet;
    }
    return bRet;
}



//***************************************************************************
//
//  CFlexAceArray::~CFlexAceArray()
//
//  Cleans up safe array entries.
//
//***************************************************************************

CFlexAceArray::~CFlexAceArray()
{
    for(int iCnt = 0; iCnt < Size(); iCnt++)
    {
        CBaseAce * pace = (CBaseAce *)GetAt(iCnt);
        if(pace)
            delete pace;
    }
    Empty();
}

//***************************************************************************
//
//  SetStatusAndReturnOK
//
//  If there is an error, it dumps an error message.  It also sets the status
//
//***************************************************************************

HRESULT SetStatusAndReturnOK(SCODE sc, IWbemObjectSink* pSink, char * pMsg)
{
    if(sc != S_OK && pMsg)
        ERRORTRACE((LOG_WBEMCORE, "SecurityMethod failed doing %s, sc = 0x%x", pMsg, sc));
    pSink->SetStatus(0,sc, NULL, NULL);
    return S_OK;
}

//***************************************************************************
//
//  DumpErrorMsgAndReturn
//
//  Dumps out an error message
//
//***************************************************************************

HRESULT DumpErrorMsgAndReturn(SCODE sc, char * pMsg)
{
    if(pMsg)
        ERRORTRACE((LOG_WBEMCORE, "%s, sc = 0x%x", pMsg, sc));
    return sc;
}

//***************************************************************************
//
//  CWbemNamespace::GetSDMethod
//
//  Implements the GetSD method.  This method returns the security descriptor
//
//***************************************************************************

HRESULT CWbemNamespace::GetSDMethod(IWbemClassObject* pOutParams)
{
    // Load up the return object with the security descriptor

    SCODE sc = EnsureSecurity();
    if(sc != S_OK)
        return DumpErrorMsgAndReturn(sc, "GetSDMethod failed creating a SD");

    CNtSecurityDescriptor &sd = GetSDRef();

	sc = CopySDIntoProperty(L"SD", sd, pOutParams);
	return sc;

}

//***************************************************************************
//
//  SetSDMethod
//
//  Implements the SetSD method.  This method sets the security descriptor
//
//***************************************************************************
HRESULT CWbemNamespace::RecursiveSDMerge()
{
	// Enumerate the child namespaces

    CSynchronousSink* pSyncSink = new CSynchronousSink;
    if(pSyncSink == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pSyncSink->AddRef();
    CReleaseMe rm4(pSyncSink);
    //HRESULT hres = Exec_CreateInstanceEnum(L"__Namespace", WBEM_FLAG_DEEP, NULL,
      //              pSyncSink);

    HRESULT hres = CRepository::ExecQuery ( m_pSession, m_pNsHandle, L"select * from __Namespace", pSyncSink, WBEM_FLAG_DEEP );
    if(FAILED(hres))
        return hres;

    pSyncSink->Block();

	// For each child

	for(int i = 0; i < pSyncSink->GetObjects().GetSize(); i++)
    {

		// Get the child namespace

		CWbemNamespace* pNewNs = CWbemNamespace::CreateInstance();

		if (pNewNs == NULL)
		{
			return WBEM_E_OUT_OF_MEMORY;
		}
        IUnknown * pUnk = NULL;
        hres = pNewNs->QueryInterface(IID_IUnknown, (void **)&pUnk);
        if(FAILED(hres))
            return hres;
        pNewNs->Release();      // ref count held by pUnk
        CReleaseMe rm2(pUnk);

		VARIANT var;
		VariantInit(&var);
        CWbemObject* pObj = (CWbemObject*)pSyncSink->GetObjects().GetAt(i);
		hres = pObj->Get(L"name", 0, &var, NULL, NULL);
		if(SUCCEEDED(hres) && var.vt == VT_BSTR && var.bstrVal && m_pThisNamespace)
		{
            CClearMe cm(&var);
            DWORD dwLen = wcslen(m_pThisNamespace) + wcslen(var.bstrVal) + 2;
            WCHAR * pNewName = new WCHAR[dwLen];
            if(pNewName == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            CDeleteMe<WCHAR> dm(pNewName);
            wcscpy(pNewName, m_pThisNamespace);
            wcscat(pNewName, L"\\");
            wcscat(pNewName, var.bstrVal);

			hres = pNewNs->Initialize(pNewName,
								NULL,
								m_dwSecurityFlags, m_dwPermission, m_bForClient, FALSE,
								NULL, 0xFFFFFFFF, FALSE, NULL);
            if(FAILED(hres))
                return hres;
			// Merge parents SD into the child

            if(pNewNs->IsNamespaceSDProtected())
                continue;

			hres = SetSecurityForNS(pNewNs->m_pSession, pNewNs->m_pNsHandle, m_pSession, m_pNsHandle, TRUE);
            if(FAILED(hres))
                return hres;
			// Recursively call the child
			
			hres = pNewNs->RecursiveSDMerge();
			if (FAILED(hres))
				return hres;
		}
    }
	return S_OK;
}

BOOL IsProtected(CNtSecurityDescriptor & sd)
{
    PSECURITY_DESCRIPTOR pActual = sd.GetPtr();
    if(pActual == NULL)
        return FALSE;

    SECURITY_DESCRIPTOR_CONTROL Control;
    DWORD dwRevision;
    BOOL bRet = GetSecurityDescriptorControl(pActual, &Control, &dwRevision);
    if(bRet == FALSE)
        return FALSE;

    if(Control & SE_DACL_PROTECTED)
        return TRUE;
    else
        return FALSE;

}

BOOL CWbemNamespace::IsNamespaceSDProtected()
{
    // Get the SD for this namespace

    HRESULT hRes = EnsureSecurity();
    if(FAILED(hRes))
        return FALSE;

    // check the control flag

    return IsProtected(m_sd);

}


HRESULT StripOutInheritedAces(CNtSecurityDescriptor &sd)
{

    // Get the DACL

    CNtAcl * DestAcl;
    DestAcl = sd.GetDacl();
    if(DestAcl == FALSE)
        return WBEM_E_INVALID_PARAMETER;
    CDeleteMe<CNtAcl> dm(DestAcl);

    // enumerate through the aces

    DWORD dwNumAces = DestAcl->GetNumAces();
    BOOL bChanged = FALSE;
    for(long nIndex = (long)dwNumAces-1; nIndex >= 0; nIndex--)
    {
        CNtAce *pAce = DestAcl->GetAce(nIndex);
        if(pAce)
        {
            long lFlags = pAce->GetFlags();
            if(lFlags & INHERITED_ACE)
            {
                DestAcl->DeleteAce(nIndex);
                bChanged = TRUE;
				delete pAce;
            }
        }
    }
    if(bChanged)
        sd.SetDacl(DestAcl);
    return S_OK;
}


HRESULT CWbemNamespace::GetParentsInheritableAces(CNtSecurityDescriptor &sd)
{
    // Get the parent namespace's SD

    if(m_pThisNamespace == NULL)
        return WBEM_E_CRITICAL_ERROR;

    // Start by figuring out what the parents name is.  Do this by copying the namespace name,
    // then nulling out the last back slash.

    int iLen = wcslen(m_pThisNamespace);
    WCHAR * pParentName = new WCHAR[iLen + 1];
    if(pParentName == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    CDeleteMe<WCHAR> dm(pParentName);
    wcscpy(pParentName, m_pThisNamespace);

    BOOL bFoundBackSlash = FALSE;
    WCHAR * pTest = pParentName+iLen-1;

    for (; pTest >= pParentName; pTest--)
    {
        if ( *pTest == '\\' || *pTest == '/' )
        {
            bFoundBackSlash = TRUE;
            *pTest = 0;
            break;
        }
    }
    if(!bFoundBackSlash)
        return S_OK;        // probably already in root

    // Open the parent namespace

	CWbemNamespace* pNewNs = CWbemNamespace::CreateInstance();

	if (pNewNs == NULL)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
    IUnknown * pUnk = NULL;
    HRESULT hres = pNewNs->QueryInterface(IID_IUnknown, (void **)&pUnk);
    if(FAILED(hres))
        return hres;
    pNewNs->Release();      // ref count held by pUnk
    CReleaseMe rm2(pUnk);

	hres = pNewNs->Initialize(pParentName,
							NULL,
							m_dwSecurityFlags, m_dwPermission, m_bForClient, FALSE, 
							NULL, 0xFFFFFFFF, FALSE, NULL);
    if(FAILED(hres))
        return hres;

    hres = pNewNs->EnsureSecurity();
    if(FAILED(hres))
        return FALSE;

    // Go through the parents dacl and add and inheritiable aces to ours.

    hres = CopyInheritAces(sd, pNewNs->m_sd);
    return hres;
}


HRESULT CWbemNamespace::SetSDMethod(IWbemClassObject* pInParams)
{

    // Make sure that there is an input argument

    if(pInParams == NULL)
        return DumpErrorMsgAndReturn(WBEM_E_INVALID_PARAMETER, "SetSD failed due to null pInParams");

    // Get the security descriptor argument

	CNtSecurityDescriptor sd;
	HRESULT hr = GetSDFromProperty(L"SD", sd, pInParams);
	if(FAILED(hr))
		return hr;

    // Check to make sure the SD is valid before attempting to store it
	// CNtSecurityDescriptor does this via IsValidSecurityDescriptor so
	// all we need to do is check the status of sd before continuing.
	// NT RAID#:  152990		[marioh]
	if ( sd.GetStatus() != CNtSecurityDescriptor::NoError )
		return WBEM_E_INVALID_OBJECT;
	

	//
	// Reject SecurityDescriptors with NULL Owner or NULL group
	//
	// This is temporarily removed since _SOMEONE_ decided we need
	// to RI yesterday and test wasnt quite done with smoking this.
	//
	CNtSid *pTmpSid = sd.GetOwner ( ) ;
	CNtSid *pTmpSid2 = sd.GetGroup ( ) ;
	CDeleteMe<CNtSid> owner ( pTmpSid ) ;
	CDeleteMe<CNtSid> group ( pTmpSid2 ) ;

	if ( pTmpSid == NULL || pTmpSid2 == NULL )
	{
		return WBEM_E_FAILED ;
	}
	
	
	// Some editors return inherited aces, and others dont.  Strip the inherited ones so
    // that we have a consistent SD.

    StripOutInheritedAces(sd);

    // Get the inherited aces from the parent

    if(!IsProtected(sd))
        GetParentsInheritableAces(sd);

	// Store the sd.

	hr = StoreSDIntoNamespace(m_pSession, m_pNsHandle, sd);
	if(FAILED(hr))
		return hr;

	hr = RecursiveSDMerge();	
	return hr;
}

//***************************************************************************
//
//  IsAceValid()
//
//  Does a sanity check on aces
//
//***************************************************************************

bool IsAceValid(DWORD dwMask, DWORD dwType, DWORD dwFlag)
{
    bool bOK = true;
    if(dwMask & WBEM_FULL_WRITE_REP && ((dwMask & WBEM_PARTIAL_WRITE_REP) == 0 ||
        (dwMask & WBEM_WRITE_PROVIDER) == 0))
    {
        bOK = false;
        return false;
    }

    // DONT allow INHERIT_ONLY_ACE with out CONTAINER_INHERIT

    DWORD dwTemp = dwFlag & (INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE);
    if(dwTemp == INHERIT_ONLY_ACE)
        bOK = false;

    DWORD dwBadAccess = dwMask & ~(FULL_RIGHTS);
    DWORD dwBadFlag = dwFlag & ~(CONTAINER_INHERIT_ACE | NO_PROPAGATE_INHERIT_ACE |
                        INHERIT_ONLY_ACE | INHERITED_ACE);
    if(dwBadFlag || dwBadAccess)
        bOK = false;

    if((dwType != 0) && (dwType != 1))
        bOK = false;

    if(!bOK)
        ERRORTRACE((LOG_WBEMCORE, "Got passed a bad ace, dwMask=0x%x, dwType=0x%x, dwFlag=0x%x",
            dwMask, dwType, dwFlag));

    return bOK;
}


//***************************************************************************
//
//  GetCallerAccessRightsMethod
//
//  Implements the GetCallerAccessRights methods.  It returns the access rignts
//  of the current caller.
//
//***************************************************************************

HRESULT CWbemNamespace::GetCallerAccessRightsMethod(IWbemClassObject* pOutParams)
{
    VARIANT var;
    var.vt = VT_I4;
    var.lVal = m_dwPermission;
    SCODE sc = pOutParams->Put(L"rights" , 0, &var, 0);
    if(sc != S_OK)
        return DumpErrorMsgAndReturn(sc, "GetCallerAccessRights failed putting the dwAccesMask property");
    return S_OK;
}

//***************************************************************************
//
//  SecurityMethod
//
//  Implements the security methods.
//
//***************************************************************************

HRESULT CWbemNamespace::SecurityMethod(LPWSTR wszMethodName, long lFlags,
                       IWbemClassObject *pInParams, IWbemContext *pCtx,
                       IWbemObjectSink* pSink)
{
    SCODE sc;

    // Do some parameter checking

    if(pSink == NULL || wszMethodName == NULL)
        return WBEM_E_INVALID_PARAMETER;

    IWbemClassObject * pClass = NULL;
    IWbemClassObject * pOutClass = NULL;
    IWbemClassObject* pOutParams = NULL;

    // Get the class object

    sc = GetObject(L"__SystemSecurity", 0, pCtx, &pClass, NULL);
    if(sc != S_OK || pClass == NULL)
        return SetStatusAndReturnOK(sc, pSink, "getting the class object");

    // All the methods return data, so create an instance of the
    // output argument class.

    sc = pClass->GetMethod(wszMethodName, 0, NULL, &pOutClass);
    pClass->Release();
    if(sc != S_OK)
        return SetStatusAndReturnOK(sc, pSink, "getting the method");

    sc = pOutClass->SpawnInstance(0, &pOutParams);
    pOutClass->Release();
    if(sc != S_OK || pOutParams == NULL)
        return SetStatusAndReturnOK(sc, pSink, "spawning an instance of the output class");

    CReleaseMe rm(pOutParams);

    // Depending on the actual method, call the appropritate routine

    if(!_wcsicmp(wszMethodName, L"GetSD"))
    {
        if (!Allowed(READ_CONTROL))
            sc = WBEM_E_ACCESS_DENIED;
        else if(!m_bNT)
            sc = WBEM_E_METHOD_DISABLED;
        else
            sc = GetSDMethod(pOutParams);
    }
    else if(!_wcsicmp(wszMethodName, L"Get9XUserList"))
    {
        sc = WBEM_E_METHOD_DISABLED;
    }
    else if(!_wcsicmp(wszMethodName, L"SetSD"))
    {
        if (!Allowed(WRITE_DAC))
            sc = WBEM_E_ACCESS_DENIED;
        else if(!m_bNT)
            sc = WBEM_E_METHOD_DISABLED;
        else
            sc = SetSDMethod(pInParams);
    }
    else if(!_wcsicmp(wszMethodName, L"Set9XUserList"))
    {
        sc = WBEM_E_METHOD_DISABLED;
    }
    else if(!_wcsicmp(wszMethodName, L"GetCallerAccessRights"))
    {
        sc = GetCallerAccessRightsMethod(pOutParams);
    }
    else
    {
        return SetStatusAndReturnOK(WBEM_E_INVALID_PARAMETER, pSink, "Invalid method name");
    }
    if(sc != S_OK)
        return SetStatusAndReturnOK(sc, pSink, "calling method");

    // Set the return code

    VARIANT var;
    var.vt = VT_I4;
    var.lVal = 0;    // special name for return value.
    sc = pOutParams->Put(L"ReturnValue" , 0, &var, 0);
    if(sc != S_OK)
        return SetStatusAndReturnOK(sc, pSink, "setting the ReturnCode property");

    // Send the output object back to the client via the sink. Then
    // release the pointers and free the strings.

    sc = pSink->Indicate(1, &pOutParams);

    // all done now, set the status
    sc = pSink->SetStatus(0,WBEM_S_NO_ERROR,NULL,NULL);

    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//  GetUserAccess
//
//  Determines the allowed access for a user.
//
//***************************************************************************

DWORD CWbemNamespace::GetUserAccess()
{
    DWORD dwRet = 0;
    if(IsInAdminGroup())
        return FULL_RIGHTS;

    if(S_OK !=EnsureSecurity())
        return dwRet;   // nothing!

    dwRet = GetNTUserAccess();
    
    if((dwRet & WBEM_REMOTE_ACCESS) == 0) 
    {
        HANDLE hAccessToken;
        if(SUCCEEDED(GetAccessToken(hAccessToken)))
        {
            BOOL bRemote = IsRemote(hAccessToken);
            CloseHandle(hAccessToken);
            if(bRemote)
                dwRet = 0;
        }
    }
    if(m_pThisNamespace && (wbem_wcsicmp(L"root\\security", m_pThisNamespace) == 0 ||
                            wbem_wcsicmp(L"root/security", m_pThisNamespace) == 0))
        if((dwRet  & READ_CONTROL) == 0)
            dwRet = 0;
    return dwRet;

}

//***************************************************************************
//
//  GetNTUserAccess
//
//  Determines the allowed access for a user.
//
//***************************************************************************

DWORD CWbemNamespace::GetNTUserAccess()
{

    HANDLE hAccessToken = INVALID_HANDLE_VALUE;
    if(S_OK != GetAccessToken(hAccessToken))
        return FULL_RIGHTS;       // Not having a token indicates an internal thread

    CCloseHandle cm(hAccessToken);

    DWORD dwMask = 0;

    if(IsAdmin(hAccessToken))
        return FULL_RIGHTS;

    // use the SD

    GENERIC_MAPPING map;
    map.GenericRead = 1;
    map.GenericWrite = 0x1C;
    map.GenericExecute = 2;
    map.GenericAll = 0x6001f;
    PRIVILEGE_SET ps[3];
    DWORD dwSize = 3 * sizeof(PRIVILEGE_SET);
    BOOL bResult;
    long testbit = 1;
    for(int iCnt = 0; iCnt < 26; iCnt++, testbit <<= 1)
    {
        // dont bother testing bits that we dont use

        DWORD dwGranted = 0;
        if(testbit & (FULL_RIGHTS))
        {
            BOOL bOK = AccessCheck(m_sd.GetPtr(), hAccessToken, testbit, &map, ps, &dwSize, &dwGranted, &bResult);
            if(bOK && bResult && dwGranted)
            {
                // if the right is full repository, make sure the user also gets the lesser write
                // access or else the logic for putting/deleting classes will have problems.

                if(testbit == WBEM_FULL_WRITE_REP)
                    dwMask |= (WBEM_PARTIAL_WRITE_REP|WBEM_WRITE_PROVIDER);
                dwMask |= testbit;
            }
        }
    }

    return dwMask;
}

//***************************************************************************
//
//  bool CWbemNamespace::Allowed(DWORD dwRequired)
//
//  Description.  Tests if the user has the requested permission.  This is
//  called before something like a WRITE is done.  Since nt supports
//  supports impersonation, this is always called.  For 9X, a simple check
//  of the permissions strored at the time of connection is OK.
//
//***************************************************************************

bool CWbemNamespace::Allowed(DWORD dwRequired)
{
    //
    // Check for admin first
    //

    GENERIC_MAPPING map;
    map.GenericRead = 1;
    map.GenericWrite = 0x1C;
    map.GenericExecute = 2;
    map.GenericAll = 0x6001f;
    PRIVILEGE_SET ps[3];
    DWORD dwSize = 3 * sizeof(PRIVILEGE_SET);
    BOOL bResult;
    DWORD dwGranted = 0;
    BOOL bOK;

    HANDLE hAccessToken = INVALID_HANDLE_VALUE;

    if(S_OK != GetAccessToken(hAccessToken))
        return true;
    CCloseHandle cm(hAccessToken);

    bOK = AccessCheck(m_sdCheckAdmin.GetPtr(), hAccessToken, 1,
                            &map, ps, &dwSize, &dwGranted, &bResult);
    if(bOK && bResult && dwGranted)
        return true;

    //
    // Not an admin. Continue
    //

    if(EnsureSecurity() != S_OK)
        return false;

	//
	// Always include the check for account enabled right.
	// NOTE: This is safe. We dont really care about the explicit
	// checks for PARTIAL of FULL write below if the account is disabled.
	// 
	// NOTE: Why, oh, why did we go the anti-NT security path???????????????
	//
	DWORD dwRequiredCheck = dwRequired ;
	dwRequired |= WBEM_ENABLE ;

    // For nt, the current users priviledges are checked on the fly via access check

    CInCritSec ics(&m_cs);  // grab the cs since we are using the security desc.
    if(IsRemote(hAccessToken))
	{
		//
		// Check to see if the user is remote enabled before continuing. If they are not 
		// remote enabled, we fail (except in admin cases).
		//
		dwGranted = 0 ;
		bResult = FALSE ;
		bOK = AccessCheck(m_sd.GetPtr(), hAccessToken, WBEM_REMOTE_ACCESS, &map, ps, &dwSize,
                                                &dwGranted, &bResult);
		if ( !bOK || !bResult || !dwGranted )
		{
			return IsAdmin(hAccessToken) ? true : false ;
		}
	}
        
    bOK = AccessCheck(m_sd.GetPtr(), hAccessToken, dwRequired, &map, ps, &dwSize, &dwGranted, &bResult);
    bool bRet = (bOK && bResult && dwGranted);

    // Having full repository write gives access to the "lower" write capabilities.  So if the lower
    // right is rejected, double check for the full access right.

    if(bRet == false && (dwRequiredCheck == WBEM_PARTIAL_WRITE_REP || dwRequiredCheck == WBEM_WRITE_PROVIDER))
    {
		bOK = AccessCheck(m_sd.GetPtr(), hAccessToken, WBEM_FULL_WRITE_REP|WBEM_ENABLE, &map, ps, &dwSize,
                                                &dwGranted, &bResult);
        bRet = (bOK && bResult && dwGranted);
    }
    if(bRet == FALSE)
        bRet = TRUE == IsAdmin(hAccessToken);

    return bRet;
}


//***************************************************************************
//
//  HRESULT CWbemNamespace::InitializeSD()
//
//  Description.  Creates the SD
//
//***************************************************************************

HRESULT CWbemNamespace::InitializeSD(IWmiDbSession *pSession)
{
    HRESULT hr;
    if (pSession == NULL)
    {
        hr = CRepository::GetDefaultSession(&pSession);
        if (FAILED(hr))
            return hr;
    }
    else
        pSession->AddRef();
    CReleaseMe relMe2(pSession);
	IWbemClassObject * pThisNSObject = NULL;

	//AutoRevert av;          // switches to system and back to client
    BOOL bWasImpersonating = WbemIsImpersonating();
    if( bWasImpersonating )
	{
		CoRevertToSelf ( ) ;
	}
	
	hr = CRepository::GetObject(pSession, m_pNsHandle, L"__thisnamespace=@",
                                            WBEM_FLAG_USE_SECURITY_DESCRIPTOR | WMIDB_FLAG_ADMIN_VERIFIED,
                                            &pThisNSObject);
	if(FAILED(hr))
	{
	    if(bWasImpersonating)
		{
			if ( FAILED ( CoImpersonateClient ( ) ) )
			{
				hr = WBEM_E_FAILED ;
			}
		}
		return hr;
	}
	CReleaseMe rm1(pThisNSObject);
	hr = GetSDFromProperty(L"SECURITY_DESCRIPTOR", m_sd, pThisNSObject);

    if(bWasImpersonating)
	{
		if ( FAILED ( CoImpersonateClient ( ) ) )
		{
			hr = WBEM_E_FAILED ;
		}
	}
	return hr ;
}

//***************************************************************************
//
//  HRESULT CWbemNamespace::EnsureSecurity()
//
//  Description.  Generally doesnt do anything except for the first time
//  it is called under nt.
//
//***************************************************************************

HRESULT CWbemNamespace::EnsureSecurity()
{
    SCODE sc = S_OK;
    CInCritSec cs(&m_cs);

    if(m_bSecurityInitialized)
        return S_OK;
    if(m_bNT)
        sc = InitializeSD(NULL);
    else
        sc = S_OK;
    if(sc == S_OK)
        m_bSecurityInitialized = true;
    return sc;
}

CBaseAce * ConvertOldObjectToAce(IWbemClassObject * pObj, bool bGroup)
{
    // Get the properties out of the old object

    CVARIANT vName;
    pObj->Get(L"Name", 0, &vName, 0, 0);
    LPWSTR pName = NULL;
    if(vName.GetType() != VT_BSTR)
        return NULL;                // ignore this one.
    pName = LPWSTR(vName);

    CVARIANT vDomain;
    LPWSTR pDomain = L".";
    pObj->Get(L"Authority", 0, &vDomain, 0, 0);
    if(vDomain.GetType() == VT_BSTR)
        pDomain = LPWSTR(vDomain);

    bool bEditSecurity = false;
    bool bEnabled = false;
    bool bExecMethods = false;

    DWORD dwMask = 0;
    CVARIANT vEnabled;
    CVARIANT vEditSecurity;
    CVARIANT vExecMethods;
    CVARIANT vPermission;

    pObj->Get(L"Enabled", 0, &vEnabled, 0, 0);
    pObj->Get(L"EditSecurity", 0, &vEditSecurity, 0, 0);
    pObj->Get(L"ExecuteMethods", 0, &vExecMethods, 0, 0);
    pObj->Get(L"Permissions", 0, &vPermission, 0, 0);

    if (vEnabled.GetType() != VT_NULL && vEnabled.GetBool())
        bEnabled = true;

    if (vEditSecurity.GetType() != VT_NULL && vEditSecurity.GetBool())
        bEditSecurity = true;

    if (vExecMethods.GetType() != VT_NULL && vExecMethods.GetBool())
        bExecMethods = true;

    DWORD dwPermission = 0;
    if (vPermission.GetType() != VT_NULL && vPermission.GetLONG() > dwPermission)
            dwPermission = vPermission.GetLONG();

    // Now translate the old settings into new ones

    if(bEnabled)
        dwMask = WBEM_ENABLE | WBEM_REMOTE_ACCESS | WBEM_WRITE_PROVIDER;

    if(bEditSecurity)
        dwMask |= READ_CONTROL;

    if(bEditSecurity && dwPermission > 0)
        dwMask |= WRITE_DAC;

    if(bExecMethods)
        dwMask |= WBEM_METHOD_EXECUTE;

    if(dwPermission >= 1)
        dwMask |= WBEM_PARTIAL_WRITE_REP;

    if(dwPermission >= 2)
        dwMask |= WBEM_FULL_WRITE_REP | WBEM_PARTIAL_WRITE_REP | WBEM_WRITE_PROVIDER;


    // By default, CNtSid will look up the group name from either the local machine,
    // the domain, or a trusted domain.  So we need to be explicit

    WString wc;
    if(pDomain)
        if(_wcsicmp(pDomain, L".") || !IsNT())
        {
            wc = pDomain;
            wc += L"\\";
        }
    wc += pName;

    // under m1, groups that were not enabled were just ignored.  Therefore the bits
    // cannot be transfer over since m3 has allows and denies, but no noops.  Also,
    // win9x doesnt have denies, do we want to noop those users also.

    if(!bEnabled && (bGroup || !IsNT()))
        dwMask = 0;

    // In general, m1 just supported allows.  However, a user entry that was not enabled was
    // treated as a deny.  Note that win9x does not allow actual denies.

    DWORD dwType = ACCESS_ALLOWED_ACE_TYPE;
    if(!bGroup && !bEnabled && IsNT())
    {
        dwMask |= (WBEM_ENABLE | WBEM_REMOTE_ACCESS | WBEM_WRITE_PROVIDER);
        dwType = ACCESS_DENIED_ACE_TYPE;
    }

    if(IsNT())
    {

        CNtSid Sid(wc, NULL);
        if(Sid.GetStatus() != CNtSid::NoError)
        {
            ERRORTRACE((LOG_WBEMCORE, "Error converting m1 security ace, name = %S, error = 0x%x",
                wc, Sid.GetStatus()));
            return NULL;
        }
        CNtAce * pace = new CNtAce(dwMask, dwType, CONTAINER_INHERIT_ACE, Sid);
        return pace;
    }
    else
    {
        C9XAce * pace = new C9XAce(dwMask, dwType, CONTAINER_INHERIT_ACE, wc);
        return pace;
    }

}

//***************************************************************************
//
//  AddSubjectToArray
//
//  Description.  Adds a group or user to the ace array.
//
//***************************************************************************

HRESULT AddSubjectToArray(CFlexAceArray * pNew, IWbemClassObject * pObj, CWbemNamespace *pSecurity,
                               bool bGroup,
                               int & iNumConverted, int & iNumNotConverted)
{
return S_OK;
/*
    // Get the properties out of the old object

    CVARIANT vRelPath;

    pObj->Get(CBSTR(L"__RelPath"), 0, &vRelPath, 0, 0);
    CBaseAce * pace = ConvertOldObjectToAce(pObj, bGroup);
    if(pace)
    {
        pNew->Add(pace);
        iNumConverted++;
        if(vRelPath.GetType() == VT_BSTR && pSecurity)
        {
            CSynchronousSink* pSink = new CSynchronousSink;
            if(pSink == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            pSink->AddRef();
            CReleaseMe rm1(pSink);
            pSecurity->Exec_DeleteInstance(LPWSTR(vRelPath), WBEM_FLAG_ONLY_STATIC, NULL, pSink);
        }
        return S_OK;
    }
    else
    {
        iNumNotConverted++;
        return WBEM_E_OUT_OF_MEMORY;
    }*/
}

//***************************************************************************
//
//  EnumerateAndAddEntries
//
//  Description.  Enumerate either the users or groups class and adds an entry
//  for each instance.
//
//***************************************************************************

HRESULT EnumerateAndAddEntries(LPWSTR pClassName,CFlexAceArray * pNew,
                               CWbemNamespace *pSecurity, bool bGroup,
                               int & iNumConverted, int & iNumNotConverted)
{

    CSynchronousSink* pSyncSink = new CSynchronousSink;
    if(pSyncSink == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pSyncSink->AddRef();
    HRESULT hres = pSecurity->Exec_CreateInstanceEnum(pClassName, WBEM_FLAG_ONLY_STATIC, NULL,
                    pSyncSink);
    if(FAILED(hres))
    {
        pSyncSink->Release();
        return hres;
    }

    pSyncSink->Block();
    for(int i = 0; i < pSyncSink->GetObjects().GetSize(); i++)
    {
        CWbemObject* pObj = (CWbemObject*)pSyncSink->GetObjects().GetAt(i);
        AddSubjectToArray(pNew, pObj, pSecurity, bGroup, iNumConverted,iNumNotConverted);
    }
    pSyncSink->Release();
    return S_OK;

}

//***************************************************************************
//
//  HRESULT CWbemNamespace::PossibleDbUpgrade(CFlexAceArray * pNew)
//
//  Description.  Updates an M1 security db to M3
//
//***************************************************************************

HRESULT CWbemNamespace::PossibleDbUpgrade(CFlexAceArray * pNew)
{

	return S_OK;
	/*
    int iNumConverted = 0;
    int iNumNotConverted = 0;

    // Get the Security namespace

    CWbemNamespace *pSecurity = CWbemNamespace::CreateInstance();
    if (pSecurity == NULL)
        WBEM_E_OUT_OF_MEMORY;

    pSecurity->Initialize(L"root\\security", m_wszUserName,
                                    (IsNT()) ? 0 : SecFlagWin9XLocal,
                                    FULL_RIGHTS, true, false, FALSE, NULL);

    if (pSecurity->GetStatus() != 0)
    {
        DEBUGTRACE((LOG_WBEMCORE, "PossibleDbUpgrade failed since status on security namespace is %d. \n",
            pSecurity->GetStatus()));
        delete pSecurity;
        return S_OK; // Perfectly normal case since m1 may never have been installed
    }
    pSecurity->AddRef();

    // Loop through the groups and users

    HRESULT hRes = S_OK;
    if(IsNT())
        hRes = EnumerateAndAddEntries(L"__NTLMGroup",pNew, pSecurity, true,
                                                    iNumConverted, iNumNotConverted);
    if(!FAILED(hRes))
        hRes = EnumerateAndAddEntries(L"__NTLMUser",pNew, pSecurity, false,
                                                    iNumConverted, iNumNotConverted);

    pSecurity->Release();

    // If there are no more entries to convert, delete the security namespace.

//    if(iNumNotConverted == 0)
//    {
//        CSynchronousSink* pSink = new CSynchronousSink;
//        if(pSink == NULL)
//            return WBEM_E_OUT_OF_MEMORY;
//        pSink->AddRef();
//        CReleaseMe rm1(pSink);

//        Exec_DeleteInstance(L"__Namespace.name=\"security\"", 0, NULL, pSink);

//        HRESULT hres;
//        pSink->GetStatus(&hres, NULL, NULL);
//    }
    if(iNumConverted > 0)
        PutAceList(pNew);
    if(FAILED(hRes))
        return hRes;
    if(iNumNotConverted == 0)
        return S_OK;
    else
        return WBEM_E_FAILED;   // Usually caused by not being able to get user's sid. */
}



//***************************************************************************
//
//  BOOL IsRemote()
//
//  Description. returns true if the box is NT and the caller is not a member
//  of the interactive users.
//
//***************************************************************************

BOOL IsRemote(HANDLE hToken)
{
    PSID pRawSid;
    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
    BOOL bRet = TRUE;

    if(AllocateAndInitializeSid( &id, 1,
        SECURITY_INTERACTIVE_RID, 0,
        0,0,0,0,0,0,&pRawSid))                             // S-1-5-4
    {
        CNtSid Sid(pRawSid);

		if (CNtSid::NoError == Sid.GetStatus())
        {
			if(CNtSecurity::IsUserInGroup(hToken, Sid))
			{
				bRet = FALSE;
			}
		}
		FreeSid(pRawSid);
    }

	//
	//Add proper check for remotness. In addition to the INTERACTIVE group,
	//we also check NETWORK_RID membership
	//
	if ( bRet )
	{
		if(AllocateAndInitializeSid( &id, 1,
			SECURITY_NETWORK_RID, 0,
			0,0,0,0,0,0,&pRawSid))                             // S-1-5-4
		{
			CNtSid Sid(pRawSid);
			if (CNtSid::NoError == Sid.GetStatus())
			{
				if(!CNtSecurity::IsUserInGroup(hToken, Sid))
					bRet = FALSE;
			}
			FreeSid(pRawSid);
		}
	}
	return bRet;
}


////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////

HRESULT AddDefaultRootAces(CNtAcl * pacl)
{
    PSID pRawSid;
    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;

    if(AllocateAndInitializeSid( &id, 2,
        SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
        0,0,0,0,0,0,&pRawSid))
    {
        CNtSid SidAdmin(pRawSid);
        FreeSid(pRawSid);
        DWORD dwMask = FULL_RIGHTS;
        CNtAce * pace = new CNtAce(dwMask, ACCESS_ALLOWED_ACE_TYPE,
                                                CONTAINER_INHERIT_ACE, SidAdmin);
		if ( NULL == pace )
		{
			return WBEM_E_OUT_OF_MEMORY;
		}

        CDeleteMe<CNtAce> dm(pace);
        pacl->AddAce(pace);
    }
	else
	{
		ERRORTRACE((LOG_WBEMCORE, "ERROR: Unable to add default root aces (DOMAIN_ALIAS_RID_ADMINS)\n"));
	}

	//
	// Add ACE's for NETWORK_SERVICE ACCOUNT. These accounts have the following rights:
	// 1. WBEM_ENABLE
	// 2. WBEM_METHOD_EXECUTE
	// 3. WBEM_WRITE_PROVIDER
	//
	DWORD dwAccessMaskNetworkLocalService = WBEM_ENABLE | WBEM_METHOD_EXECUTE | WBEM_WRITE_PROVIDER ;

    if(AllocateAndInitializeSid( &id, 1,
        SECURITY_NETWORK_SERVICE_RID,0,0,0,0,0,0,0,&pRawSid))
    {
        CNtSid SidUsers(pRawSid);
        FreeSid(pRawSid);
        CNtAce * pace = new CNtAce(dwAccessMaskNetworkLocalService, ACCESS_ALLOWED_ACE_TYPE,
                                                CONTAINER_INHERIT_ACE, SidUsers);
		if ( NULL == pace )
		{
			return WBEM_E_OUT_OF_MEMORY;
		}

        CDeleteMe<CNtAce> dm(pace);
        pacl->AddAce(pace);
	}
	else
	{
		ERRORTRACE((LOG_WBEMCORE, "ERROR: Unable to add default root aces (SECURITY_NETWORK_SERVICE_RID)\n"));
	}



	//
	// Add ACE's for NETWORK_SERVICE ACCOUNT. These accounts have the following rights:
	// 1. WBEM_ENABLE
	// 2. WBEM_METHOD_EXECUTE
	// 3. WBEM_WRITE_PROVIDER
	//
    if(AllocateAndInitializeSid( &id, 1,
        SECURITY_LOCAL_SERVICE_RID,0,0,0,0,0,0,0,&pRawSid))
    {
        CNtSid SidUsers(pRawSid);
        FreeSid(pRawSid);
        CNtAce * pace = new CNtAce(dwAccessMaskNetworkLocalService, ACCESS_ALLOWED_ACE_TYPE,
                                                CONTAINER_INHERIT_ACE, SidUsers);
		if ( NULL == pace )
		{
			return WBEM_E_OUT_OF_MEMORY;
		}

        CDeleteMe<CNtAce> dm(pace);
        pacl->AddAce(pace);
	}
	else
	{
		ERRORTRACE((LOG_WBEMCORE, "ERROR: Unable to add default root aces (SECURITY_LOCAL_SERVICE_RID)\n"));
	}

	SID_IDENTIFIER_AUTHORITY id2 = SECURITY_WORLD_SID_AUTHORITY;

    if(AllocateAndInitializeSid( &id2, 1,
        0,0,0,0,0,0,0,0,&pRawSid))
    {
        CNtSid SidUsers(pRawSid);
        FreeSid(pRawSid);
        DWORD dwMask = WBEM_ENABLE | WBEM_METHOD_EXECUTE | WBEM_WRITE_PROVIDER;
        CNtAce * pace = new CNtAce(dwMask, ACCESS_ALLOWED_ACE_TYPE,
                                                CONTAINER_INHERIT_ACE, SidUsers);
		if ( NULL == pace )
		{
			return WBEM_E_OUT_OF_MEMORY;
		}

        CDeleteMe<CNtAce> dm(pace);
        pacl->AddAce(pace);
	}
	else
	{
		ERRORTRACE((LOG_WBEMCORE, "ERROR: Unable to add default root aces (SECURITY_WORLD_SID_AUTHORITY)\n"));
	}

	return S_OK;
}


HRESULT CopySDIntoProperty(LPWSTR pPropName, CNtSecurityDescriptor &sd, IWbemClassObject *pThisNSObject)
{
    // TMP: Check to make sure the owner or group is not NULL!!!!
	//delete sd.GetOwner();
	//delete sd.GetGroup();


    // move the SD into a variant.
    SAFEARRAY FAR* psa;
    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    long lSize = sd.GetSize();
    rgsabound[0].cElements = lSize;
    psa = SafeArrayCreate( VT_UI1, 1 , rgsabound );
    if(psa == NULL)
        return DumpErrorMsgAndReturn(WBEM_E_FAILED, "GetSDMethod failed creating a safe array");

    char * pData = NULL;
    SCODE sc = SafeArrayAccessData(psa, (void HUGEP* FAR*)&pData);
    if(sc != S_OK)
        return DumpErrorMsgAndReturn(sc, "GetSDMethod failed accessing safe array data");

    memcpy(pData, sd.GetPtr(), lSize);

    SafeArrayUnaccessData(psa);
    VARIANT var;
    var.vt = VT_UI1|VT_ARRAY;
    var.parray = psa;

    sc = pThisNSObject->Put(pPropName , 0, &var, 0);

    VariantClear(&var);
	return sc;
}

HRESULT GetSDFromProperty(LPWSTR pPropName, CNtSecurityDescriptor &sd, IWbemClassObject *pThisNSObject)
{
    // Get the security descriptor argument

    HRESULT hRes = S_OK ;

	VARIANT var;
    VariantInit(&var);
    SCODE sc = pThisNSObject->Get(pPropName , 0, &var, NULL, NULL);
    if (sc != S_OK)
    {
        VariantClear(&var);
        CVARIANT vPath;
        pThisNSObject->Get(L"__PATH", 0, &vPath, 0, 0);
        DEBUGTRACE((LOG_WBEMCORE, "Getting SD from %S failed due to code 0x%X\n", V_BSTR(&vPath), sc));
        return WBEM_E_CRITICAL_ERROR;
    }

    if(var.vt != (VT_ARRAY | VT_UI1))
    {
        VariantClear(&var);
        CVARIANT vPath;
        pThisNSObject->Get(L"__PATH", 0, &vPath, 0, 0);
        DEBUGTRACE((LOG_WBEMCORE, "Getting SD from %S failed due to incorrect VARIANT type\n", V_BSTR(&vPath) ));
        return WBEM_E_INVALID_PARAMETER;
    }

    SAFEARRAY * psa = var.parray;
    PSECURITY_DESCRIPTOR pSD;
    sc = SafeArrayAccessData(psa, (void HUGEP* FAR*)&pSD);
    if (sc != 0)
    {
        VariantClear(&var);
        return DumpErrorMsgAndReturn(WBEM_E_INVALID_PARAMETER, "SetSD failed trying accessing SD property");
    }

    BOOL bValid = IsValidSecurityDescriptor(pSD);
    if (!bValid)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    CNtSecurityDescriptor sdNew(pSD);

    // TMP: Check to make sure the owner and group is not NULL!!!!
	CNtSid *pTmpSid = sdNew.GetOwner();
	if ( pTmpSid == NULL )
	{
//		DebugBreak();
        ERRORTRACE((LOG_WBEMCORE, "ERROR: Security descriptor was retrieved and it had no owner\n"));
	}
	delete pTmpSid;

	pTmpSid = sdNew.GetGroup();
	if (pTmpSid  == NULL )
	{
//		DebugBreak();
        ERRORTRACE((LOG_WBEMCORE, "ERROR: Security descriptor was retrieved and it had no group\n"));
	}
	delete pTmpSid;


	
	sd = sdNew;
	if ( sd.GetStatus ( ) != CNtSecurityDescriptor::NoError )
	{
		hRes = WBEM_E_OUT_OF_MEMORY ;
	}
    SafeArrayUnaccessData(psa);
    VariantClear(&var);
	return hRes ;
}

HRESULT CopyInheritAces(CNtSecurityDescriptor & sd, CNtSecurityDescriptor & sdParent)
{
	// Get the acl list for both SDs

    CNtAcl * pacl = sd.GetDacl();
    if(pacl == NULL)
        return WBEM_E_FAILED;
    CDeleteMe<CNtAcl> dm0(pacl);

    CNtAcl * paclParent = sdParent.GetDacl();
    if(paclParent == NULL)
        return WBEM_E_FAILED;
    CDeleteMe<CNtAcl> dm1(paclParent);

	int iNumParent = paclParent->GetNumAces();
	for(int iCnt = 0; iCnt < iNumParent; iCnt++)
	{
	    CNtAce *pParentAce = paclParent->GetAce(iCnt);
        CDeleteMe<CNtAce> dm2(pParentAce);

		long lFlags = pParentAce->GetFlags();
		if(lFlags & CONTAINER_INHERIT_ACE)
		{

			if(lFlags & NO_PROPAGATE_INHERIT_ACE)
				lFlags ^= CONTAINER_INHERIT_ACE;
			lFlags |= INHERITED_ACE;

			// If this is an inherit only ace we need to clear this
			// in the children.
			// NT RAID: 161761		[marioh]
			if ( lFlags & INHERIT_ONLY_ACE )
				lFlags ^= INHERIT_ONLY_ACE;

			pParentAce->SetFlags(lFlags);
			pacl->AddAce(pParentAce);
		}
	}
	sd.SetDacl(pacl);
	return S_OK;
}


HRESULT StoreSDIntoNamespace(IWmiDbSession * pSession, IWmiDbHandle *pNSToSet, CNtSecurityDescriptor & sd)
{
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Check to make sure the SD DACL is valid before attempting to put
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	CNtAcl* pAcl = sd.GetDacl ( );
	if ( pAcl )
	{
		CDeleteMe<CNtAcl> dm (pAcl);
		if ( !IsValidAclForNSSecurity ( pAcl ) )
		{
			return WBEM_E_INVALID_PARAMETER;
		}
	}
	else
	{
		return WBEM_E_INVALID_PARAMETER;
	}
	
	IWbemClassObject * pThisNSObject = NULL;
	HRESULT hr = CRepository::GetObject(pSession, pNSToSet, L"__thisnamespace=@",
                                            WBEM_FLAG_USE_SECURITY_DESCRIPTOR, &pThisNSObject);
	if(FAILED(hr))
		return hr;
	CReleaseMe rm1(pThisNSObject);

	hr = CopySDIntoProperty(L"SECURITY_DESCRIPTOR", sd, pThisNSObject);
	if(FAILED(hr))
		return hr;
	return CRepository::PutObject(pSession, pNSToSet, IID_IWbemClassObject, pThisNSObject,
        WMIDB_DISABLE_EVENTS | WBEM_FLAG_USE_SECURITY_DESCRIPTOR);
}

HRESULT	SetSecurityForNS(IWmiDbSession * pSession, IWmiDbHandle *pNSToSet,
						 IWmiDbSession * pParentSession, IWmiDbHandle * pNSParent, BOOL bExisting)
{
	IWbemClassObject * pThisNSObject = NULL;

	// Get the __thisnamespace object
	
    HRESULT hr = CRepository::GetObject(pSession, pNSToSet, L"__thisnamespace=@",
                                WBEM_FLAG_USE_SECURITY_DESCRIPTOR, &pThisNSObject);
	if(FAILED(hr))
	{
		ERRORTRACE((LOG_WBEMCORE, "SetSecurityForNS: Failed to get __thisnamespace=@ object for current namespace <0x%X>!\n", hr));
		return hr;
	}
	CReleaseMe rm1(pThisNSObject);

	// Create the new SD

	CNtSecurityDescriptor sd;
	CNtAcl DestAcl;

	if(bExisting)
	{
		// Fill in the security descriptor
		hr = GetSDFromProperty(L"SECURITY_DESCRIPTOR", sd, pThisNSObject);
		if(FAILED(hr))
		{
			ERRORTRACE((LOG_WBEMCORE, "SetSecurityForNS: Failure in GetSDFromProperty <0x%X>!\n", hr));
			return hr;
		}
	
		hr = StripOutInheritedAces (sd);
		if ( FAILED (hr) )
		{
			ERRORTRACE((LOG_WBEMCORE, "SetSecurityForNS: Failure in StripOutInheritedAces <0x%X>!\n", hr));
			return hr;
		}

	}
	else
	{
		// NT RAID: 198935 Prefix    [marioh]
		if ( !SetOwnerAndGroup(sd) )
		{
			ERRORTRACE((LOG_WBEMCORE, "SetSecurityForNS: Failure in SetOwnerAndGroup <0x%X>!\n", hr));
			return WBEM_E_FAILED;
		}

		if ( !sd.SetDacl(&DestAcl) )
		{
			ERRORTRACE((LOG_WBEMCORE, "SetSecurityForNS: Failure in SetDacl <0x%X>!\n", hr));
			return WBEM_E_FAILED;
		}
	}


    CNtAcl * pacl = sd.GetDacl();
    if (pacl == NULL)
	{
		ERRORTRACE((LOG_WBEMCORE, "SetSecurityForNS: Failure in GetDacl <0x%X>!\n", hr));
        return WBEM_E_FAILED;
	}

    CDeleteMe<CNtAcl> del1(pacl);


	if(pNSParent == NULL)
	{
		// If there is no parent, this must be root.  Create a default one
		
		hr = AddDefaultRootAces(pacl);
		if (FAILED(hr))
		{
			ERRORTRACE((LOG_WBEMCORE, "SetSecurityForNS: Failure for AddDefaultRootAces <0x%X>!\n", hr));
			return hr;
		}
		BOOL bRet = sd.SetDacl(pacl);
		if (bRet == FALSE)
		{
			ERRORTRACE((LOG_WBEMCORE, "SetSecurityForNS: Failure for SetDacl (2) <0x%X>!\n", hr));
			return WBEM_E_FAILED ;
		}
	}
	else
	{
		// Get the parents __thisnamespace

		IWbemClassObject * pParentThisNSObject = NULL;
		hr = CRepository::GetObject(pParentSession, pNSParent, L"__thisnamespace=@",
                                WBEM_FLAG_USE_SECURITY_DESCRIPTOR, &pParentThisNSObject);
		if(FAILED(hr))
		{
			ERRORTRACE((LOG_WBEMCORE, "SetSecurityForNS: Failed to get __thisnamespace=@ object for parent namespace <0x%X>!\n", hr));
			return hr;
		}
		CReleaseMe rm11(pParentThisNSObject);
		CNtSecurityDescriptor sdParent;
		hr = GetSDFromProperty(L"SECURITY_DESCRIPTOR", sdParent, pParentThisNSObject);
		if(FAILED(hr))
		{
			ERRORTRACE((LOG_WBEMCORE, "SetSecurityForNS: Failure for GetSDFromProperty <0x%X>!\n", hr));
			return hr;
		}
		hr = CopyInheritAces(sd, sdParent);
		if (FAILED(hr))
		{
			ERRORTRACE((LOG_WBEMCORE, "SetSecurityForNS: Failure for CopyInheritAces <0x%X>!\n", hr));
			return hr;
		}
	}
	if(FAILED(hr))
		return hr;

	hr = CopySDIntoProperty(L"SECURITY_DESCRIPTOR", sd, pThisNSObject);
	if(FAILED(hr))
	{
		ERRORTRACE((LOG_WBEMCORE, "SetSecurityForNS: Failure for CopySDIntoProperty <0x%X>!\n", hr));
		return hr;
	}

    // Extract sd property once more.
    // ==============================

    CNtSecurityDescriptor VerifiedSd;
    hr = GetSDFromProperty(L"SECURITY_DESCRIPTOR", VerifiedSd, pThisNSObject);

    if (FAILED(hr))
    {
		ERRORTRACE((LOG_WBEMCORE, "SetSecurityForNS: Failure for GetSDFromProperty (2) <0x%X>!\n", hr));
        CVARIANT vPath;
        pThisNSObject->Get(L"__PATH", 0, &vPath, 0, 0);
        DEBUGTRACE((LOG_WBEMCORE, "Error creating security descriptor for new namespace %S", V_BSTR(&vPath) ));
        return WBEM_E_CRITICAL_ERROR;
    }

    // Go ahead and store the object.
    // ==============================

	hr = CRepository::PutObject(pSession, pNSToSet, IID_IWbemClassObject, pThisNSObject,
                        WMIDB_DISABLE_EVENTS  | WBEM_FLAG_USE_SECURITY_DESCRIPTOR);

	if (FAILED(hr))
	{
		ERRORTRACE((LOG_WBEMCORE, "SetSecurityForNS: Failed to put secured object back <0x%X>!\n", hr));
	}
    return hr;
}


//***************************************************************************
//
//  IsValidAclForNSSecurity
//
//	Checks the ACEs for the following:
//		2. Standard NT ACE correctness [IsValidAce]
//		1. ACE inheritance/propogation flag correctness for WMI namespace
//		   security
//
//  Parameters: 
//				<CNtAcl&>   ACL to be checked
//				
//  Return:
//				TRUE		if ACL is valid
//				FALSE		if ACL is invalid
//
//***************************************************************************
BOOL IsValidAclForNSSecurity (CNtAcl* pAcl)
{
	BOOL bRet = TRUE;

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Standard NT ACL check
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	bRet = pAcl->IsValid ( );
	if ( bRet )
	{
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Loop through all the ACEs in the list
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		ULONG ulNum = pAcl->GetNumAces( );
		for ( ULONG ulCnt = 0; ulCnt < ulNum; ulCnt++ )
		{
			CNtAce* pAce = pAcl->GetAce ( ulCnt );
			if ( pAce )
			{
				// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				// We have a non NULL ACE
				// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				CDeleteMe<CNtAce> autoDel ( pAce );
				if ( !IsAceValid ( pAce->GetAccessMask(), pAce->GetType(), pAce->GetFlags() ) )
				{
					bRet = FALSE;
					break;
				}
			}
			else
			{
				// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				// We have a NULL ACE! Fail!
				// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				bRet = FALSE;
				break;
			}
		}
	}
	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\stack.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    STACK.CPP

Abstract:

    CStack

History:

    26-Apr-96   a-raymcc    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "Arena.h"
#include "stack.h"
#include "corex.h"

CStack::CStack(DWORD dwInitSize, DWORD dwGrowBy)
{
    m_dwSize = dwInitSize;
    m_dwGrowBy = dwGrowBy * sizeof(DWORD);
    m_dwStackPtr = (DWORD) -1;
    m_pData = LPDWORD(CWin32DefaultArena::WbemMemAlloc(m_dwSize * sizeof(DWORD)));
    if (m_pData == 0)
        throw CX_MemoryException();
    ZeroMemory(m_pData, m_dwSize * sizeof(DWORD));
}

void CStack::Push(DWORD dwValue)
{
    if ( m_dwStackPtr + 1 == m_dwSize) {
        m_dwSize += m_dwGrowBy;
        m_pData = LPDWORD(CWin32DefaultArena::WbemMemReAlloc(m_pData, m_dwSize * sizeof(DWORD)));
        if (m_pData == 0)
            throw CX_MemoryException();
    }
    
    m_pData[++m_dwStackPtr] = dwValue;
}

CStack::CStack(CStack& Src)
{
    m_pData = 0;
    *this = Src;
}

CStack& CStack::operator =(CStack& Src)
{
    if (m_pData) 
        CWin32DefaultArena::WbemMemFree(m_pData);
        
    m_dwSize = Src.m_dwSize;
    m_dwGrowBy = Src.m_dwGrowBy;
    m_dwStackPtr = Src.m_dwStackPtr;
    m_pData = LPDWORD(CWin32DefaultArena::WbemMemAlloc(m_dwSize * sizeof(DWORD)));
    if (m_pData == 0)
        throw CX_MemoryException();
    ZeroMemory(m_pData, m_dwSize * sizeof(DWORD));
    memcpy(m_pData, Src.m_pData, sizeof(DWORD) * m_dwSize);
    return *this;
}

CStack::~CStack()
{
    CWin32DefaultArena::WbemMemFree(m_pData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\stack.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    STACK.H

Abstract:

    CStack

History:

	26-Apr-96   a-raymcc    Created.

--*/

#ifndef _STACK_H_
#define _STACK_H_


class CStack 
{
    DWORD m_dwSize;
    DWORD m_dwStackPtr;    
    DWORD* m_pData;
    DWORD m_dwGrowBy;
    
public:
    CStack(DWORD dwInitSize = 32, DWORD dwGrowBy = 32);
   ~CStack(); 
    CStack(CStack &);
    CStack& operator=(CStack &);

    void  Push(DWORD);

    DWORD Pop()     { return m_pData[m_dwStackPtr--]; }
    DWORD Peek()    { return m_pData[m_dwStackPtr]; }
    BOOL  IsEmpty() { return m_dwStackPtr == -1; }
    DWORD Size()    { return m_dwStackPtr + 1; }
    void  Empty()   { m_dwStackPtr = (DWORD) -1; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\str_res.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    STRRES.H

Abstract:

    String resource definitions

History:

--*/

#ifndef _STR_RES_H_
#define _STR_RES_H_


#define IDS_THIS_RELEASE            101
#define IDS_ADMIN_FULL_NAME         102
#define IDS_ADMIN_DESCRIPTION       103    
#define IDS_GUEST_FULL_NAME         104
#define IDS_GUEST_DESCRIPTION       105    
#define IDS_SYSINIT_FAILURE         106
#define IDS_WINMGMT_CRITICAL          107
#define IDS_MULTIPLE_NOT_SUPPORTED  108
#define IDS_INVALID_DATABASE        109
#define IDS_WBEM_USERS_GROUP        110
#define IDS_WBEM_USERS_COMMENT      112

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\stdclass.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    STDCLASS.CPP

Abstract:

    Class definitions for standard system classes.

History:

    raymcc    18-Jul-96       Created.

--*/

#include "precomp.h"

#include "sechelp.h"
#include "StdClass.h"
#include "Reg.h"
#include "CfgMgr.h"

#include <arrtempl.h>
#include <genutils.h>

#include <comdef.h>

#define NEW_CLASS_PRECREATE_SIZE 1000
#define NEW_INSTANCE_PRECREATE_SIZE 100

#define NOT_NULL_FLAVOR \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS | \
        WBEM_FLAVOR_NOT_OVERRIDABLE

#define READ_FLAVOR \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS | \
        WBEM_FLAVOR_NOT_OVERRIDABLE

#define UNITS_FLAVOR \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS | \
        WBEM_FLAVOR_NOT_OVERRIDABLE

#define SINGLETON_FLAVOR \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS | \
        WBEM_FLAVOR_NOT_OVERRIDABLE

#define SYNTAX_FLAVOR \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS

#define ABSTRACT_FLAVOR 0 // no propagation

#define ASSOC_FLAVOR \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS | \
        WBEM_FLAVOR_NOT_OVERRIDABLE

#define VALUES_FLAVOR \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS

void CThisNamespaceClass::Init()
{
    CSystemClass System;
    System.Init();
    HRESULT hRes = CreateDerivedClass(&System);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__thisNAMESPACE");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

//    CVar vNull;
//    vNull.SetAsNull();
//    hRes = SetPropValue(L"Name", &vNull, CIM_STRING);
//    if (hRes == WBEM_E_OUT_OF_MEMORY)
//        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"SECURITY_DESCRIPTOR", &vEmpty, CIM_FLAG_ARRAY | CIM_UINT8);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();


    CVar vTrue(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"singleton", &vTrue, SINGLETON_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

}

void CThisNamespaceInstance::Init(CThisNamespaceClass* pClass)
{
    InitNew(pClass, NEW_INSTANCE_PRECREATE_SIZE);
}

BOOL GetLocalSystemSid(CVar& v)
{
    if(!IsNT())
    {
        // Null SID
        v.SetAsNull();
        return TRUE;
    }

    PSID pSid;

    //
    // Allocate the SID for the LOCAL SYSTEM account
    //

    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
    if(AllocateAndInitializeSid( &id, 1,
        SECURITY_LOCAL_SYSTEM_RID, 0,0,0,0,0,0,0,&pSid))
    {
        BYTE* pBuffer = (BYTE*)pSid;

        //
        // Transfer its contents into a CVar
        //

        CVarVector* pvv = new CVarVector(VT_UI1);
        if(pvv == NULL)
        {
            FreeSid(pSid);
            return FALSE;
        }

        for(int i = 0; i < GetLengthSid(pSid); i++)
            pvv->Add(CVar(pBuffer[i]));

        FreeSid(pSid);
        v.SetVarVector(pvv, TRUE);
        return TRUE;
    }
    else
        return FALSE;
}

void CSystemClass::Init()
{
    if ( FAILED( InitEmpty(NEW_CLASS_PRECREATE_SIZE) ) )
	{
		throw CX_MemoryException();
	}

    CVar v(VT_BSTR, L"__SystemClass");
    HRESULT hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vt(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"abstract", &vt, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CParametersClass::Init()
{
    if ( FAILED( InitEmpty(NEW_CLASS_PRECREATE_SIZE) ) )
	{
		throw CX_MemoryException();
	}

    CVar v(VT_BSTR, L"__PARAMETERS");
    HRESULT hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vt(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"abstract", &vt, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

//******************************************************************************

void CGenericClass::Init()
{
    if ( FAILED( InitEmpty(NEW_CLASS_PRECREATE_SIZE) ) )
	{
		throw CX_MemoryException();
	}

    CVar v(VT_BSTR, L"__GENERIC");
    HRESULT hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vt(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"sample", &vt, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}


//******************************************************************************

void CNotifyStatusClass::Init()
{
    if ( FAILED( InitEmpty(NEW_CLASS_PRECREATE_SIZE) ) )
	{
		throw CX_MemoryException();
	}

    CVar v(VT_BSTR, L"__NotifyStatus");
    HRESULT hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    //CVar vs((LONG) 0);
    CVar vs;
    vs.SetAsNull();
    hRes = SetPropValue(L"StatusCode", &vs, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vt(VARIANT_TRUE, VT_BOOL);
    // all error classes are like that!
    hRes = SetQualifier(L"abstract", &vt, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE |
                                   WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS |
                                   WBEM_FLAVOR_NOT_OVERRIDABLE);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

//******************************************************************************

void CNamespaceClass::Init()
{
    CSystemClass System;
    System.Init();
    HRESULT hRes = CreateDerivedClass(&System);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__NAMESPACE");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"Name", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    // Mark name as 'key'.
    // ===================
    CVar vb(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"Name", L"key", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

CNamespaceClass* CNamespace::mstatic_pClass = NULL;
CCritSec CNamespace::mstatic_cs;
CNamespace::__CleanUp CNamespace::cleanup;

void CNamespace::Init(LPWSTR pName)
{
    CInCritSec local_lock (&mstatic_cs);
    if(mstatic_pClass == NULL)
    {
        mstatic_pClass = new CNamespaceClass;
        if (mstatic_pClass == 0)
        {
            throw CX_MemoryException();
        }
        mstatic_pClass->Init();
    }
    InitNew(mstatic_pClass, NEW_INSTANCE_PRECREATE_SIZE);

    CVar vk(VT_BSTR, pName);
    HRESULT hRes = SetPropValue(L"Name", &vk, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

//******************************************************************************

void CProviderClass::Init()
{
    CSystemClass System;
    System.Init();
    HRESULT hRes = CreateDerivedClass(&System);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__Provider");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"Name", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"Name", L"key", 0, &vk);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetQualifier(L"abstract", &vk, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CWin32ProviderClass::Init()
{
    CProviderClass ProviderClass;
    ProviderClass.Init();
    HRESULT hRes = CreateDerivedClass(&ProviderClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__Win32Provider");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();

    hRes = SetPropValue(L"CLSID", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"ClientLoadableCLSID", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"DefaultMachineName", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"UnloadTimeout", &vNull, CIM_DATETIME);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"InitializeAsAdminFirst", &vNull, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"Version", &vNull, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vZero;
    vZero.SetLong(0);
    hRes = SetPropValue(L"ImpersonationLevel", &vZero, CIM_SINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"InitializationReentrancy", &vZero, CIM_SINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vFalse(VARIANT_FALSE, VT_BOOL);
    hRes = SetPropValue(L"PerUserInitialization", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"PerLocaleInitialization", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vTrue(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropValue(L"Pure", &vTrue, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vInterval(VT_BSTR, L"interval");
    hRes = SetPropQualifier(L"UnloadTimeout", L"SUBTYPE", SYNTAX_FLAVOR, &vInterval);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vProtectedClsid(VT_BSTR, L"CLSID");
    CVar vProtectedNamespace(VT_BSTR, L"Namespace");
    CVar vProtectedComObject(VT_BSTR, L"COM Object");
    CVarVector *pvvReentrancy = new CVarVector(VT_BSTR);
    if (pvvReentrancy == 0)
        throw CX_MemoryException();
    if (pvvReentrancy->Add(vProtectedClsid) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvReentrancy->Add(vProtectedNamespace) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvReentrancy->Add(vProtectedComObject) != CVarVector::no_error)
        throw CX_MemoryException();
    CVar vReentrancy(pvvReentrancy, TRUE);
    hRes = SetPropQualifier(L"InitializationReentrancy", L"Values",
            WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS, &vReentrancy);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vLevelNone(VT_BSTR, L"None");
    CVarVector* pvvLevel = new CVarVector(VT_BSTR);
    if (pvvLevel == 0)
        throw CX_MemoryException();
    if (pvvLevel->Add(vLevelNone) != CVarVector::no_error)
        throw CX_MemoryException();
    CVar vLevel(pvvLevel, TRUE);
    hRes = SetPropQualifier(L"ImpersonationLevel", L"Values",
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS, &vLevel);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();


    hRes = SetPropValue(L"HostingModel", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

	CVar vHosting_WmiCore (VT_BSTR, L"WmiCore");
	CVar vHosting_WmiCoreSelfHost (VT_BSTR, L"WmiCoreOrSelfHost");
	CVar vHosting_SelfHost (VT_BSTR, L"SelfHost");
	CVar vHosting_ClientHost (VT_BSTR, L"ClientHost");
	CVar vHosting_Decoupled (VT_BSTR, L"Decoupled");
	CVar vHosting_LocalSystemHost (VT_BSTR, L"LocalSystemHost");
	CVar vHosting_LocalSystemHostOrSelfHost (VT_BSTR, L"LocalSystemHostOrSelfHost");
	CVar vHosting_LocalServiceHost (VT_BSTR, L"LocalServiceHost");
	CVar vHosting_NetworkServiceHost (VT_BSTR, L"NetworkServiceHost");
	CVar vHosting_UserHost (VT_BSTR, L"UserHost");

    CVarVector *pvvHostingModels = new CVarVector(VT_BSTR);
    if (pvvHostingModels == 0)
        throw CX_MemoryException();

    if (pvvLevel->Add(vHosting_WmiCore) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvLevel->Add(vHosting_WmiCoreSelfHost) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvLevel->Add(vHosting_SelfHost) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvLevel->Add(vHosting_ClientHost) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvLevel->Add(vHosting_Decoupled) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvLevel->Add(vHosting_LocalSystemHost) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvLevel->Add(vHosting_LocalSystemHostOrSelfHost) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvLevel->Add(vHosting_LocalServiceHost) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvLevel->Add(vHosting_NetworkServiceHost) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvLevel->Add(vHosting_UserHost) != CVarVector::no_error)
        throw CX_MemoryException();

    CVar vHostingModels(pvvHostingModels, TRUE);
    hRes = SetPropQualifier(L"HostingModel", L"Values",
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS, &vHostingModels);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"Concurrency", &vNull, CIM_SINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"SupportsSendStatus", &vNull, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"SupportsExplicitShutdown", &vNull, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"SupportsExtendedStatus", &vNull, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"SupportsThrottling", &vNull, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"OperationTimeoutInterval", &vNull, CIM_DATETIME);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropQualifier(L"OperationTimeoutInterval", L"SUBTYPE", SYNTAX_FLAVOR, &vInterval);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"InitializationTimeoutInterval", &vNull, CIM_DATETIME);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropQualifier(L"InitializationTimeoutInterval", L"SUBTYPE", SYNTAX_FLAVOR, &vInterval);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"SupportsQuotas", &vNull, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"Enabled", &vNull, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"SupportsShutdown", &vNull, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"SecurityDescriptor", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

}

void CProviderRegistrationClass::Init()
{
    CSystemClass System;
    System.Init();
    HRESULT hRes =CreateDerivedClass(&System);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__ProviderRegistration");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"Provider", &vNull, CIM_REFERENCE);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vCimtype(VT_BSTR, L"ref:__Provider");
    hRes = SetPropQualifier(L"Provider", L"cimtype", 0, &vCimtype);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"abstract", &vk, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
};

void CObjectProviderRegistrationClass::Init()
{
    CProviderRegistrationClass RegClass;
    RegClass.Init();
    HRESULT hRes = CreateDerivedClass(&RegClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__ObjectProviderRegistration");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();

    CVar vFalse(VARIANT_FALSE, VT_BOOL);

    hRes = SetPropValue(L"SupportsPut", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"SupportsGet", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"SupportsDelete", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"SupportsEnumeration", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"QuerySupportLevels", &vNull, CIM_STRING | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vZero;
    vZero.SetLong(0);
    hRes = SetPropValue(L"InteractionType", &vZero, CIM_SINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"abstract", &vk, ABSTRACT_FLAVOR);

    CVar vPull(VT_BSTR, L"Pull");
    CVar vPush(VT_BSTR, L"Push");
    CVar vPushVerify(VT_BSTR, L"PushVerify");
    CVarVector* pvvInteraction = new CVarVector(VT_BSTR);
    if (pvvInteraction == 0)
        throw CX_MemoryException();
    if (pvvInteraction->Add(vPull) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvInteraction->Add(vPush) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvInteraction->Add(vPushVerify) != CVarVector::no_error)
        throw CX_MemoryException();
    CVar vInteraction(pvvInteraction, TRUE);
    hRes = SetPropQualifier(L"InteractionType", L"Values",
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS, &vInteraction);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vUnarySelect(VT_BSTR, L"WQL:UnarySelect");
    CVar vProvDef(VT_BSTR, L"WQL:V1ProviderDefined");
    CVar vAssoc(VT_BSTR, L"WQL:Associators");
    CVar vRef(VT_BSTR, L"WQL:References");
    CVarVector* pvvQueries = new CVarVector(VT_BSTR);
    if (pvvQueries == 0)
        throw CX_MemoryException();
    if (pvvQueries->Add(vUnarySelect) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvQueries->Add(vRef) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvQueries->Add(vAssoc) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvQueries->Add(vProvDef) != CVarVector::no_error)
        throw CX_MemoryException();
    CVar vQueries(pvvQueries, TRUE);
    hRes = SetPropQualifier(L"QuerySupportLevels", L"ValueMap",
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS, &vQueries);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
	
    hRes = SetPropValue(L"SupportsBatching", &vNull, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"SupportsTransactions", &vNull, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CClassProviderRegistrationClass::Init()
{
    CObjectProviderRegistrationClass ObjectClass;
    ObjectClass.Init();
    HRESULT hRes = CreateDerivedClass(&ObjectClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__ClassProviderRegistration");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();

    hRes = SetPropValue(L"Version", &vNull, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"ResultSetQueries", &vNull, CIM_STRING | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"ReferencedSetQueries", &vNull, CIM_STRING | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"UnsupportedQueries", &vNull, CIM_STRING | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"Provider", L"key", 0, &vk);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"CacheRefreshInterval", &vNull, CIM_DATETIME);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vInterval(VT_BSTR, L"interval");
    hRes = SetPropQualifier(L"CacheRefreshInterval", L"SUBTYPE", SYNTAX_FLAVOR, &vInterval);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"PerUserSchema", &vNull, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"ReSynchroniseOnNamespaceOpen", &vNull, CIM_BOOLEAN );
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CInstanceProviderRegistrationClass::Init()
{
    CObjectProviderRegistrationClass ObjectClass;
    ObjectClass.Init();
    HRESULT hRes = CreateDerivedClass(&ObjectClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__InstanceProviderRegistration");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"Provider", L"key", 0, &vk);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CPropertyProviderRegistrationClass::Init()
{
    CProviderRegistrationClass ProvReg;
    ProvReg.Init();
    HRESULT hRes = CreateDerivedClass(&ProvReg);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__PropertyProviderRegistration");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vFalse(VARIANT_FALSE, VT_BOOL);
    hRes = SetPropValue(L"SupportsPut", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"SupportsGet", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"Provider", L"key", 0, &vk);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CMethodProviderRegistrationClass::Init()
{
    CProviderRegistrationClass ProvReg;
    ProvReg.Init();
    HRESULT hRes = CreateDerivedClass(&ProvReg);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__MethodProviderRegistration");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"Provider", L"key", 0, &vk);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CEventProviderRegistrationClass::Init()
{
    CProviderRegistrationClass ProvReg;
    ProvReg.Init();
    HRESULT hRes = CreateDerivedClass(&ProvReg);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__EventProviderRegistration");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"Provider", L"key", 0, &vk);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"EventQueryList", &vNull, CIM_STRING | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CEventConsumerProviderRegistrationClass::Init()
{
    CProviderRegistrationClass ProvReg;
    ProvReg.Init();
    HRESULT hRes = CreateDerivedClass(&ProvReg);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__EventConsumerProviderRegistration");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vProp;
    vProp.SetAsNull();
    hRes = SetPropValue(L"ConsumerClassNames", &vProp, CIM_STRING | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"Provider", L"key", 0, &vk);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}


void CCIMOMIdentificationClass::Init()
{
    CSystemClass System;
    System.Init();
    HRESULT hRes = CreateDerivedClass(&System);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__CIMOMIdentification");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

//  Registry r1(WBEM_REG_WBEM);
    Registry r(WBEM_REG_WINMGMT);
    SetPropFromReg(&r, __TEXT("Working Directory"), L"WorkingDirectory");
    SetPropFromReg(&r, __TEXT("SetupTime"), L"SetupTime");
    SetPropFromReg(&r, __TEXT("SetupDate"), L"SetupDate");

    // Get the current dll version info

    WCHAR wcVer[MAX_PATH];
    BOOL bRet = ConfigMgr::GetDllVersion(__TEXT("wbemcore.dll"), __TEXT("ProductVersion"),
                                                wcVer, MAX_PATH);
    if(bRet)
    {
        CVar v2(VT_BSTR, wcVer);
        hRes = SetPropValue(L"VersionUsedToCreateDB", &v2, CIM_STRING);
        if (hRes == WBEM_E_OUT_OF_MEMORY)
            throw CX_MemoryException();
    }
    else
    {
        hRes = Put(L"VersionUsedToCreateDB", 0, NULL, VT_BSTR);
        if (hRes == WBEM_E_OUT_OF_MEMORY)
            throw CX_MemoryException();
    }
    hRes = Put(L"VersionCurrentlyRunning", 0, NULL, VT_BSTR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"singleton", &vk, SINGLETON_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CCIMOMIdentificationClass::SetPropFromReg(Registry * pReg, TCHAR * pcRegName,
                                                    WCHAR * pwcPropName)
{

    WCHAR wcTemp[MAX_PATH];
    TCHAR *pTemp = NULL;
    int iRet = pReg->GetStr(pcRegName, &pTemp);
    if (((iRet != Registry::no_error) && (pReg->GetLastError() == 0)) || ((iRet != Registry::no_error) && (pReg->GetLastError() == ERROR_OUTOFMEMORY)))
        throw CX_MemoryException();
    if (pTemp == NULL)
        return;
#ifdef UNICODE
    lstrcpy(wcTemp, pTemp);
#else
    mbstowcs(wcTemp, pTemp, MAX_PATH-1);
#endif
    CVar vVersion(VT_BSTR, wcTemp);
    HRESULT hRes = SetPropValue(pwcPropName, &vVersion, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
    {
        delete pTemp;
        throw CX_MemoryException();
    }

    delete pTemp;
}

// __AdapStatus

void CAdapStatusClass::Init()
{
    CSystemClass System;
    System.Init();
    HRESULT hRes = CreateDerivedClass(&System);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__AdapStatus");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"singleton", &vk, SINGLETON_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"LastStartTime", &vEmpty, CIM_DATETIME);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"LastStopTime", &vEmpty, CIM_DATETIME);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"Status", &vEmpty, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

}

void CAdapStatusInstance::Init(CAdapStatusClass* pClass)
{
    InitNew(pClass, NEW_INSTANCE_PRECREATE_SIZE);

    WCHAR wszBuffer[100];
    swprintf(wszBuffer, L"%04u%02u%02u%02u%02u%02u.%06u:000",
                0, 0, 0, 0, 0, 0, 0);

    CVar v(VT_BSTR, wszBuffer);
    HRESULT hRes = SetPropValue(L"LastStartTime", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"LastStopTime", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar Var; //(VT_I4);
    Var.SetLong(0);
    hRes = SetPropValue(L"Status", &Var, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

}

// __CIMOMIdentification

void CIdentificationClass::Init()
{
    CSystemClass System;
    System.Init();
    HRESULT hRes = CreateDerivedClass(&System);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__CIMOMIdentification");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"singleton", &vk, SINGLETON_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"WorkingDirectory", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"SetupTime", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"SetupDate", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"VersionUsedToCreateDB", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"VersionCurrentlyRunning", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CIdentificationInstance::Init(CIdentificationClass* pClass)
{

    InitNew(pClass, NEW_INSTANCE_PRECREATE_SIZE);

    HRESULT hRes;
    WCHAR wcVer[MAX_PATH];
    BOOL bRet = ConfigMgr::GetDllVersion(__TEXT("wbemcore.dll"), __TEXT("ProductVersion"), wcVer, MAX_PATH);
    if(bRet)
    {
        TCHAR *szDate;
        TCHAR *szTime;
        TCHAR *szWorkDir;

        //Get the time of installation
        Registry r(WBEM_REG_WINMGMT);
        r.GetStr(__TEXT("SetupDate"), (TCHAR **)&szDate);
        CDeleteMe<TCHAR> delMe1(szDate);
        r.GetStr(__TEXT("SetupTime"), (TCHAR **)&szTime);
        CDeleteMe<TCHAR> delMe2(szTime);
        r.GetStr(__TEXT("Working Directory"), (TCHAR **)&szWorkDir);
        CDeleteMe<TCHAR> delMe3(szWorkDir);


        if ((szDate == NULL) || (szTime == NULL) || (szWorkDir == NULL))
        {
            return;
        }

        CVar v(VT_BSTR, wcVer);
        hRes = SetPropValue(L"VersionUsedToCreateDB", &v, CIM_STRING);
        if (hRes == WBEM_E_OUT_OF_MEMORY)
            throw CX_MemoryException();

        hRes = SetPropValue(L"VersionCurrentlyRunning", &v, CIM_STRING);
        if (hRes == WBEM_E_OUT_OF_MEMORY)
            throw CX_MemoryException();

        BSTR TmpBString = SysAllocString(szDate);
        if (TmpBString)
        {
	        CVar v2(VT_BSTR,TmpBString,TRUE);
	        hRes = SetPropValue(L"SetupDate", &v2, CIM_STRING);
	        if (hRes == WBEM_E_OUT_OF_MEMORY)
	            throw CX_MemoryException();
        }
        else
        {
            throw CX_MemoryException();
        }

        TmpBString = SysAllocString(szTime);
        if (TmpBString)
        {
	        CVar v3(VT_BSTR,TmpBString,TRUE);
	        hRes = SetPropValue(L"SetupTime", &v3, CIM_STRING);
	        if (hRes == WBEM_E_OUT_OF_MEMORY)
	            throw CX_MemoryException();
        }
        else
        {
            throw CX_MemoryException();
        }

        TmpBString = SysAllocString(szWorkDir);
        if (TmpBString)
        {
	        CVar v4(VT_BSTR,TmpBString,TRUE);
	        hRes = SetPropValue(L"WorkingDirectory", &v4, CIM_STRING);
	        if (hRes == WBEM_E_OUT_OF_MEMORY)
	            throw CX_MemoryException();
	    }
	    else
	    {
	        throw CX_MemoryException();
	    }


    }


}



void CCacheControlClass::Init()
{
    CSystemClass System;
    System.Init();
    HRESULT hRes = CreateDerivedClass(&System);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__CacheControl");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"abstract", &vk, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CSpecificCacheControlClass::Init(LPCWSTR wszClassName)
{
    CCacheControlClass CacheControl;
    CacheControl.Init();
    HRESULT hRes = CreateDerivedClass(&CacheControl);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, (LPWSTR)wszClassName);
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();

    hRes = SetPropValue(L"ClearAfter", &vNull, CIM_DATETIME);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    CVar vInterval(VT_BSTR, L"interval");
    hRes = SetPropQualifier(L"ClearAfter", L"SUBTYPE", SYNTAX_FLAVOR, &vInterval);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"singleton", &vk, SINGLETON_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CCacheControlInstance::Init(CSpecificCacheControlClass* pClass,
                                    DWORD dwSeconds)
{
    InitNew(pClass, NEW_INSTANCE_PRECREATE_SIZE);

    DWORD dwDays = dwSeconds / (3600 * 24);
    dwSeconds -= dwDays * 3600 * 24;

    DWORD dwHours = dwSeconds / 3600;
    dwSeconds -= dwHours * 3600;

    DWORD dwMinutes = dwSeconds / 60;
    dwSeconds -= dwMinutes * 60;

    WCHAR wszBuffer[100];
    swprintf(wszBuffer, L"%04u%02u%02u%02u%02u%02u.%06u:000",
                0, 0, dwDays, dwHours, dwMinutes, dwSeconds, 0);

    CVar v(VT_BSTR, wszBuffer);
    HRESULT hRes = SetPropValue(L"ClearAfter", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CActiveNamespacesClass::Init()
{
    CSystemClass System;
    System.Init();
    HRESULT hRes = CreateDerivedClass(&System);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__ListOfEventActiveNamespaces");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"Namespaces", &vNull, CIM_STRING | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"singleton", &vk, SINGLETON_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

//******************************************************************************

void CIndicationRelatedClass::Init()
{
    CSystemClass System;
    System.Init();
    HRESULT hRes = CreateDerivedClass(&System);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__IndicationRelated");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"abstract", &vk, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CEventClass::Init()
{
    CIndicationRelatedClass IndicationRelated;
    IndicationRelated.Init();
    HRESULT hRes = CreateDerivedClass(&IndicationRelated);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__Event");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
        
    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"TIME_CREATED", &vEmpty, CIM_UINT64);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    vEmpty.SetAsNull();
    hRes = SetPropValue(L"SECURITY_DESCRIPTOR", &vEmpty, CIM_FLAG_ARRAY | CIM_UINT8);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
            
    CVar vk(VARIANT_TRUE, VT_BOOL);
    // abstract forever --- all events are such.
    hRes = SetQualifier(L"abstract", &vk, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE |
                                   WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS |
                                   WBEM_FLAVOR_NOT_OVERRIDABLE);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CEmptyEventClass::Init(LPWSTR wszName)
{
    CEventClass EventClass;
    EventClass.Init();
    HRESULT hRes = CreateDerivedClass(&EventClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, wszName);
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CGenericDataEventClass::Init(LPWSTR wszCimType, LPWSTR wszPropSuffix)
{
    CEventClass EventClass;
    EventClass.Init();
    HRESULT hRes = CreateDerivedClass(&EventClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    WString wsClassName = L"__";
    wsClassName += wszPropSuffix;
    wsClassName += L"OperationEvent";

    CVar v(VT_BSTR, wsClassName);
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vCimType(VT_BSTR, wszCimType);
    CVar vEmpty;
    vEmpty.SetAsNull();

    WString wsPropName = L"Target";
    wsPropName += wszPropSuffix;
    hRes = SetPropValue(wsPropName, &vEmpty, CIM_OBJECT);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropQualifier(wsPropName, TYPEQUAL, SYNTAX_FLAVOR, &vCimType);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CDataEventClass::Init(CWbemClass& Parent,
                                LPWSTR wszCimType, LPWSTR wszPropSuffix,
                                int nFlags)
{
    HRESULT hRes = CreateDerivedClass(&Parent);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    WString wsClassName = L"__";
    wsClassName += wszPropSuffix;
    if(nFlags == include_new)
        wsClassName += L"Creation";
    else if(nFlags == include_old)
        wsClassName += L"Deletion";
    else
        wsClassName += L"Modification";
    wsClassName += L"Event";

    CVar v(VT_BSTR, wsClassName);
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    if(nFlags == (include_old | include_new))
    {
        CVar vCimType(VT_BSTR, wszCimType);
        CVar vEmpty;
        vEmpty.SetAsNull();

        WString wsPropName = L"Previous";
        wsPropName += wszPropSuffix;
        hRes = SetPropValue(wsPropName, &vEmpty, CIM_OBJECT);
        if (hRes == WBEM_E_OUT_OF_MEMORY)
            throw CX_MemoryException();

        hRes = SetPropQualifier(wsPropName, TYPEQUAL, SYNTAX_FLAVOR, &vCimType);
        if (hRes == WBEM_E_OUT_OF_MEMORY)
            throw CX_MemoryException();
    }
}

void CMethodEventClass::Init()
{
    CGenericDataEventClass InstanceOp;
    InstanceOp.Init(L"object", L"Instance");

    HRESULT hRes = CreateDerivedClass(&InstanceOp);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__MethodInvocationEvent");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes= SetPropValue(L"Method", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"PreCall", &vEmpty, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"Parameters", &vEmpty, CIM_OBJECT);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CTimerEventClass::Init()
{
    CEventClass EventClass;
    EventClass.Init();
    HRESULT hRes = CreateDerivedClass(&EventClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__TimerEvent");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes= SetPropValue(L"TimerId", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"NumFirings", &vEmpty, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CAggregateEventClass::Init()
{
    CIndicationRelatedClass IndClass;
    IndClass.Init();
    HRESULT hRes = CreateDerivedClass(&IndClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__AggregateEvent");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"NumberOfEvents", &vEmpty, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"Representative", &vEmpty, CIM_OBJECT);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CSystemEventClass::Init()
{
    CEmptyEventClass ExtClass;
    ExtClass.Init(L"__ExtrinsicEvent");
    HRESULT hRes = CreateDerivedClass(&ExtClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__SystemEvent");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CEventDroppedEventClass::Init()
{
    CSystemEventClass SysClass;
    SysClass.Init();
    HRESULT hRes = CreateDerivedClass(&SysClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__EventDroppedEvent");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"Event", &vEmpty, CIM_OBJECT);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"IntendedConsumer", &vEmpty, CIM_REFERENCE);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEventType(VT_BSTR, L"object:__Event");
    hRes = SetPropQualifier(L"Event", TYPEQUAL, SYNTAX_FLAVOR, &vEventType);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vConsType(VT_BSTR, L"ref:__EventConsumer");
    hRes = SetPropQualifier(L"IntendedConsumer", TYPEQUAL, SYNTAX_FLAVOR, &vConsType);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CQueueOverflowEventClass::Init()
{
    CEventDroppedEventClass DropClass;
    DropClass.Init();
    HRESULT hRes = CreateDerivedClass(&DropClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__EventQueueOverflowEvent");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"CurrentQueueSize", &vEmpty, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vBytes(VT_BSTR, L"bytes");
    hRes = SetPropQualifier(L"CurrentQueueSize", L"units", UNITS_FLAVOR, &vBytes);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CConsumerFailureEventClass::Init()
{
    CEventDroppedEventClass DropClass;
    DropClass.Init();
    HRESULT hRes = CreateDerivedClass(&DropClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__ConsumerFailureEvent");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();

    hRes = SetPropValue(L"ErrorCode", &vEmpty, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"ErrorDescription", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"ErrorObject", &vEmpty, CIM_OBJECT);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmbType(VT_BSTR, L"object:__ExtendedStatus");
    hRes = SetPropQualifier(L"ErrorObject", L"CIMTYPE", 0, &vEmbType);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CQoSFailureEventClass::Init()
{
    CEventDroppedEventClass DropClass;
    DropClass.Init();
    HRESULT hRes = CreateDerivedClass(&DropClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__QOSFailureEvent");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();

    hRes = SetPropValue(L"ErrorCode", &vEmpty, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"ErrorDescription", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

//******************************************************************************

void CEventConsumerClass::Init()
{
    CIndicationRelatedClass IndicationRelated;
    IndicationRelated.Init();
    HRESULT hRes = CreateDerivedClass(&IndicationRelated);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__EventConsumer");
    hRes = SetPropValue(L"__CLASS", &v, 0);

    CVar vProp;
    vProp.SetAsNull();

    hRes = SetPropValue(L"MachineName", &vProp, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"MaximumQueueSize", &vProp, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vSid;
    if(!GetLocalSystemSid(vSid))
        throw CX_MemoryException();

    hRes = SetPropValue(L"CreatorSID", &vSid, CIM_UINT8 | CIM_FLAG_ARRAY);

    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vt(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"abstract", &vt, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropQualifier(L"CreatorSID", L"read", READ_FLAVOR, &vt);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vBytes(VT_BSTR, L"bytes");
    hRes = SetPropQualifier(L"MaximumQueueSize", L"units", UNITS_FLAVOR, &vBytes);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

//******************************************************************************

void CConditionalInstructionClass::Init()
{
    CIndicationRelatedClass IndicationRelated;
    IndicationRelated.Init();
    HRESULT hRes = CreateDerivedClass(&IndicationRelated);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__ConditionalInstruction");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    CVar vTrue(VARIANT_TRUE, VT_BOOL);

    hRes = SetPropValue(L"Name", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"Condition", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"ConditionNamespace", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"ConditionLanguage", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vSid;
    if(!GetLocalSystemSid(vSid))
        throw CX_MemoryException();

    hRes = SetPropValue(L"CreatorSID", &vSid, CIM_UINT8 | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropQualifier(L"CreatorSID", L"read", READ_FLAVOR, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CEventFilterClass::Init()
{
#ifdef WHISTLER_UNCUT
    CConditionalInstructionClass ConditionalInstruction;
#else
    CIndicationRelatedClass ConditionalInstruction;
#endif

    ConditionalInstruction.Init();
    HRESULT hRes = CreateDerivedClass(&ConditionalInstruction);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__EventFilter");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    CVar vTrue(VARIANT_TRUE, VT_BOOL);

#ifdef WHISTLER_UNCUT
#else

    hRes = SetPropValue(L"Name", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vSid;
    if(!GetLocalSystemSid(vSid))
        throw CX_MemoryException();

    hRes = SetPropValue(L"CreatorSID", &vSid, CIM_UINT8 | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropQualifier(L"CreatorSID", L"read", READ_FLAVOR, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

#endif

    hRes = SetPropValue(L"QueryLanguage", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"Query", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"EventNamespace", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"EventAccess", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropQualifier(L"Name", L"key", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CEventMonitorClass::Init()
{
    CConditionalInstructionClass ConditionalInstruction;
    ConditionalInstruction.Init();
    HRESULT hRes = CreateDerivedClass(&ConditionalInstruction);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__MonitorInstruction");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    CVar vTrue(VARIANT_TRUE, VT_BOOL);

    hRes = SetPropValue(L"QueryLanguage", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"Query", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"TargetNamespace", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropQualifier(L"Name", L"key", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

//******************************************************************************

void CFilterConsumerBindingClass::Init()
{
    CIndicationRelatedClass IndicationRelated;
    IndicationRelated.Init();
    HRESULT hRes = CreateDerivedClass(&IndicationRelated);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__FilterToConsumerBinding");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    //CVar vEmpty(VT_BSTR, L"");
    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"Filter", &vEmpty, CIM_REFERENCE);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"Consumer", &vEmpty, CIM_REFERENCE);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vFilterRef(VT_BSTR, L"ref:__EventFilter");
    hRes = SetPropQualifier(L"Filter", TYPEQUAL, SYNTAX_FLAVOR, &vFilterRef);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vConsumerRef(VT_BSTR, L"ref:__EventConsumer");
    hRes = SetPropQualifier(L"Consumer", TYPEQUAL, SYNTAX_FLAVOR, &vConsumerRef);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vTrue(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"Filter", L"key", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropQualifier(L"Consumer", L"key", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetQualifier(L"Association", &vTrue, ASSOC_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue( L"DeliveryQoS", &vEmpty, CIM_UINT32 );
    if ( hRes == WBEM_E_OUT_OF_MEMORY )
        throw CX_MemoryException();

    CVar vFalse(VARIANT_FALSE, VT_BOOL);
    hRes = SetPropValue(L"DeliverSynchronously", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"MaintainSecurityContext", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"SlowDownProviders", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vSid;
    if(!GetLocalSystemSid(vSid))
        throw CX_MemoryException();

    hRes = SetPropValue(L"CreatorSID", &vSid, CIM_UINT8 | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropQualifier(L"DeliverSynchronously", L"not_null",
                        NOT_NULL_FLAVOR, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropQualifier(L"CreatorSID", L"read", READ_FLAVOR, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CMonitorEventClass::Init(CWbemClass& Parent, LPCWSTR wszClassName)
{
    HRESULT hRes = CreateDerivedClass(&Parent);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();


    CVar v(VT_BSTR, (LPWSTR)wszClassName);
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"MonitorName", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"TotalObjects", &vEmpty, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
};

void CMonitorDataEventClass::Init(CWbemClass& Parent, LPCWSTR wszClassName)
{
    HRESULT hRes = CreateDerivedClass(&Parent);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, (LPWSTR)wszClassName);
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"RowObject", &vEmpty, CIM_OBJECT);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"GuaranteedNew", &vEmpty, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
};


//*****************************************************************************

void CEventGeneratorClass::Init()
{
    CIndicationRelatedClass IndicationRelated;
    IndicationRelated.Init();
    HRESULT hRes = CreateDerivedClass(&IndicationRelated);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__EventGenerator");
    hRes = SetPropValue(L"__CLASS", &v, 0);

    CVar vt(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"abstract", &vt, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CTimerInstructionClass::Init()
{
    CEventGeneratorClass EventGenerator;
    EventGenerator.Init();
    HRESULT hRes = CreateDerivedClass(&EventGenerator);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__TimerInstruction");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    //CVar vEmpty(VT_BSTR, L"");
    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"TimerId", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vFalse(VARIANT_FALSE, VT_BOOL);
    hRes = SetPropValue(L"SkipIfPassed", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vTrue(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"TimerId", L"key", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vt(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"abstract", &vt, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CAbsoluteTimerInstructionClass::Init()
{
    CTimerInstructionClass TimerInstruction;
    TimerInstruction.Init();
    HRESULT hRes = CreateDerivedClass(&TimerInstruction);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__AbsoluteTimerInstruction");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    //CVar vEmpty(VT_BSTR, L"");
    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"EventDateTime", &vEmpty, CIM_DATETIME);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vTrue(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"EventDateTime", L"not_null", NOT_NULL_FLAVOR, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CIntervalTimerInstructionClass::Init()
{
    CTimerInstructionClass TimerInstruction;
    TimerInstruction.Init();
    HRESULT hRes = CreateDerivedClass(&TimerInstruction);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__IntervalTimerInstruction");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    //CVar vZero((LONG)0);
    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"IntervalBetweenEvents", &vEmpty, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vTrue(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"IntervalBetweenEvents", L"not_null", NOT_NULL_FLAVOR,
                        &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    CVar vSeconds(VT_BSTR, L"milliseconds");
    hRes = SetPropQualifier(L"IntervalBetweenEvents", L"units", UNITS_FLAVOR,
                        &vSeconds);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CTimerNextFiringClass::Init()
{
    CIndicationRelatedClass IndicationRelated;
    IndicationRelated.Init();
    HRESULT hRes = CreateDerivedClass(&IndicationRelated);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__TimerNextFiring");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    //CVar vEmpty(VT_BSTR, L"");
    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"TimerId", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"NextEvent64BitTime", &vEmpty, CIM_SINT64);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vTrue(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"TimerId", L"key", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropQualifier(L"NextEvent64BitTime", L"not_null", NOT_NULL_FLAVOR, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

//******************************************************************************

void CSecurityBaseClass::Init()
{
    if ( FAILED( InitEmpty(NEW_CLASS_PRECREATE_SIZE) ) )
	{
		throw CX_MemoryException();
	}

    CVar v(VT_BSTR, L"__SecurityRelatedClass");
    HRESULT hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vTrue;
    vTrue.SetBool(VARIANT_TRUE);
    hRes = SetQualifier(L"abstract", &vTrue, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CSubjectClass::Init()
{
    CSecurityBaseClass Base;
    Base.Init();
    HRESULT hRes = CreateDerivedClass(&Base);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__Subject");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"Name", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    CVar vDefAuth(VT_BSTR, L".");
    hRes = SetPropValue(L"Authority", &vDefAuth, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vFalse;
    vFalse.SetBool(VARIANT_FALSE);
    hRes = SetPropValue(L"Enabled", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"Permissions", &vEmpty, CIM_SINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"ExecuteMethods", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"EditSecurity", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vTrue;
    vTrue.SetBool(VARIANT_TRUE);
    hRes = SetPropQualifier(L"Name", L"key", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropQualifier(L"Authority", L"key", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetQualifier(L"abstract", &vTrue, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CUserClass::Init()
{
    CSubjectClass SubjectClass;
    SubjectClass.Init();
    HRESULT hRes = CreateDerivedClass(&SubjectClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__User");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vTrue;
    vTrue.SetBool(VARIANT_TRUE);
    hRes = SetQualifier(L"abstract", &vTrue, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CNTLMUserClass::Init()
{
    CUserClass UserClass;
    UserClass.Init();
    HRESULT hRes = CreateDerivedClass(&UserClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__NTLMUser");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"GroupType", &vEmpty, CIM_SINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CGroupClass::Init()
{
    CSubjectClass SubjectClass;
    SubjectClass.Init();
    HRESULT hRes = CreateDerivedClass(&SubjectClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__Group");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vTrue;
    vTrue.SetBool(VARIANT_TRUE);
    hRes = SetQualifier(L"abstract", &vTrue, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CNtlmGroupClass::Init()
{
    CSubjectClass SubjectClass;
    SubjectClass.Init();
    HRESULT hRes = CreateDerivedClass(&SubjectClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__NTLMGroup");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"GroupType", &vEmpty, CIM_SINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}


void CNTLM9XUserClass::Init()
{

    CSecurityBaseClass Base;
    Base.Init();
    HRESULT hRes = CreateDerivedClass(&Base);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();


    CVar v(VT_BSTR, L"__NTLMUser9X");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"Name", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    CVar vDefAuth(VT_BSTR, L".");
    hRes = SetPropValue(L"Authority", &vDefAuth, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"Flags", &vEmpty, CIM_SINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"Mask", &vEmpty, CIM_SINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"Type", &vEmpty, CIM_SINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}


void CSystemConfigClass::AddStaticQual(LPWSTR pMethodName)
{
    IWbemQualifierSet* pQualSet = NULL;
    HRESULT hRes = GetMethodQualifierSet(pMethodName, &pQualSet);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    if(pQualSet)
    {
        VARIANT var;
        var.vt = VT_BOOL; var.boolVal = VARIANT_TRUE;
        hRes = pQualSet->Put(L"Static", &var, 0);
        if (hRes == WBEM_E_OUT_OF_MEMORY)
            throw CX_MemoryException();
        pQualSet->Release();
    }
}

void CSystemConfigClass::Init()
{
    if ( FAILED( InitEmpty(NEW_CLASS_PRECREATE_SIZE) ) )
	{
		throw CX_MemoryException();
	}
    CVar v(VT_BSTR, L"__SystemSecurity");
    CVar vEmpty;
    vEmpty.SetAsNull();
    CVar vTrue;
    vTrue.SetBool(VARIANT_TRUE);
    CVar vID;
    vID.SetLong(0);

    HRESULT hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetQualifier(L"singleton", &vTrue, SINGLETON_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    // Add the "uint32 GetSD([out, id(0)]uint8 sd[])" method

    CParametersClass * pGetSDOutputArgs = new CParametersClass;
    if(pGetSDOutputArgs == NULL)
        throw CX_MemoryException();
	pGetSDOutputArgs->Init();

    CReleaseMe relMe((IWbemClassObject*)pGetSDOutputArgs);
    hRes = pGetSDOutputArgs->SetPropValue(L"ReturnValue", &vEmpty, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pGetSDOutputArgs->SetPropQualifier(L"ReturnValue", L"out", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = pGetSDOutputArgs->SetPropValue(L"SD", &vEmpty, CIM_UINT8 | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pGetSDOutputArgs->SetPropQualifier(L"SD", L"out", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pGetSDOutputArgs->SetPropQualifier(L"SD", L"ID", 0, &vID);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    // Add the method and clean up

    hRes = PutMethod(L"GetSD", 0, NULL, pGetSDOutputArgs);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    AddStaticQual(L"GetSD");

    // Add the "uint32 Get9XUserList([out, id(0)]instance of __NTLMUser9X ul[])" method

    CParametersClass * pGet9XOutputArgs = new CParametersClass;
    if(pGet9XOutputArgs == NULL)
        throw CX_MemoryException();
	pGet9XOutputArgs->Init();

    CReleaseMe relMe1((IWbemClassObject*)pGet9XOutputArgs);
    hRes = pGet9XOutputArgs->SetPropValue(L"ReturnValue", &vEmpty, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pGet9XOutputArgs->SetPropQualifier(L"ReturnValue", L"out", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = pGet9XOutputArgs->SetPropValue(L"ul", &vEmpty, CIM_OBJECT | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pGet9XOutputArgs->SetPropQualifier(L"ul", L"out", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pGet9XOutputArgs->SetPropQualifier(L"ul", L"ID", 0, &vID);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    CVar vType;
    vType.SetBSTR(L"object:__ntlmuser9x");
    hRes = pGet9XOutputArgs->SetPropQualifier(L"ul", L"CIMTYPE", 0, &vType);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    // Add the method and clean up

    hRes = PutMethod(L"Get9XUserList", 0, NULL, pGet9XOutputArgs);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    AddStaticQual(L"Get9XUserList");

    // Add the "uint32 SetSD([in, id(0)]uint8 sd[])" method

    CParametersClass * pSetSDInputArgs = new CParametersClass;
    if(pSetSDInputArgs == NULL)
        throw CX_MemoryException();
	pSetSDInputArgs->Init();

	CParametersClass * pSetSDOutputArgs = new CParametersClass;
    if(pSetSDOutputArgs == NULL)
        throw CX_MemoryException();
	pSetSDOutputArgs->Init();

    CReleaseMe relMe2((IWbemClassObject*)pSetSDInputArgs);
    CReleaseMe relMe3((IWbemClassObject*)pSetSDOutputArgs);
    hRes = pSetSDInputArgs->SetPropValue(L"SD", &vEmpty, CIM_UINT8 | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pSetSDInputArgs->SetPropQualifier(L"SD", L"in", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pSetSDInputArgs->SetPropQualifier(L"SD", L"ID", 0, &vID);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = pSetSDOutputArgs->SetPropValue(L"ReturnValue", &vEmpty, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pSetSDOutputArgs->SetPropQualifier(L"ReturnValue", L"out", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    // Add the method

    hRes = PutMethod(L"SetSD", 0, pSetSDInputArgs, pSetSDOutputArgs);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    AddStaticQual(L"SetSD");

    // Add the "uint32 Set9XUserList([in, id(0)]instance of __NTLMUser9X ul[])" method

    CParametersClass * pSet9XInputArgs = new CParametersClass;
    if(pSet9XInputArgs == NULL)
        throw CX_MemoryException();
	pSet9XInputArgs->Init();

    CParametersClass * pSet9XOutputArgs = new CParametersClass;
    if(pSet9XOutputArgs == NULL)
        throw CX_MemoryException();
	pSet9XOutputArgs->Init();

    CReleaseMe relMe4((IWbemClassObject*)pSet9XInputArgs);
    CReleaseMe relMe5((IWbemClassObject*)pSet9XOutputArgs);
    hRes = pSet9XInputArgs->SetPropValue(L"ul", &vEmpty, CIM_OBJECT | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pSet9XInputArgs->SetPropQualifier(L"ul", L"in", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pSet9XInputArgs->SetPropQualifier(L"ul", L"ID", 0, &vID);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    CVar vCimType;
    vCimType.SetBSTR(L"object:__ntlmuser9x");
    hRes = pSet9XInputArgs->SetPropQualifier(L"ul", L"CIMTYPE", 0, &vCimType);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = pSet9XOutputArgs->SetPropValue(L"ReturnValue", &vEmpty, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pSet9XOutputArgs->SetPropQualifier(L"ReturnValue", L"out", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    // Add the method

    hRes = PutMethod(L"Set9XUserList", 0, pSet9XInputArgs, pSet9XOutputArgs);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    AddStaticQual(L"Set9XUserList");

    // Add the "uint32 GetCallerAccessRights([out, id(0)]sint32 rights)" method

	CParametersClass * pGetCallerAccessOutputArgs = new CParametersClass;
    if(pGetCallerAccessOutputArgs == NULL)
        throw CX_MemoryException();
	pGetCallerAccessOutputArgs->Init();

    CReleaseMe relMe6((IWbemClassObject*)pGetCallerAccessOutputArgs);
    hRes = pGetCallerAccessOutputArgs->SetPropValue(L"ReturnValue", &vEmpty, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pGetCallerAccessOutputArgs->SetPropQualifier(L"ReturnValue", L"out", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = pGetCallerAccessOutputArgs->SetPropValue(L"rights", &vEmpty, CIM_SINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pGetCallerAccessOutputArgs->SetPropQualifier(L"rights", L"out", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pGetCallerAccessOutputArgs->SetPropQualifier(L"rights", L"ID", 0, &vID);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    // Add the method and clean up

    hRes = PutMethod(L"GetCallerAccessRights", 0, NULL, pGetCallerAccessOutputArgs);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    AddStaticQual(L"GetCallerAccessRights");

}


void CSystemConfigInstance::Init(CSystemConfigClass* pClass)
{
    InitNew(pClass, NEW_INSTANCE_PRECREATE_SIZE);
}


//******************************************************************************

void CErrorObjectClass::Init()
{
    CNotifyStatusClass NotifyClass;
    NotifyClass.Init();
    HRESULT hRes = CreateDerivedClass(&NotifyClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__ExtendedStatus");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"ProviderName", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"Operation", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"ParameterInfo", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"Description", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

CErrorObjectClass* CErrorObject::mstatic_pClass = NULL;
CCritSec CErrorObject::mstatic_cs;
CErrorObject::__CleanUp CErrorObject::cleanup;

CErrorObject::CErrorObject(ADDREF IWbemClassObject* pObject)
{
    // Check for proper inheritance if we have an object.
    // Throw an OOM exception if we hit an OOM error condition.

    HRESULT hres = ( NULL != pObject ?
        pObject->InheritsFrom( L"__ExtendedStatus" ) :
        WBEM_E_FAILED );

    if( S_OK == hres )
    {
        m_pObject = (CWbemInstance*)pObject;
        m_pObject->AddRef();
    }
    else if ( WBEM_E_OUT_OF_MEMORY == hres )
    {
        throw CX_MemoryException();
    }
    else
    {
        CInCritSec local_lock (&mstatic_cs);
        if(mstatic_pClass == NULL)
        {
            mstatic_pClass = new CErrorObjectClass;
            if (mstatic_pClass == 0)
            {
                throw CX_MemoryException();
            }
            mstatic_pClass->Init();
        }

        m_pObject = new CWbemInstance;
        if (m_pObject == 0)
            throw CX_MemoryException();

		// Only reason this fails is OOM
        if ( FAILED( m_pObject->InitNew(mstatic_pClass, NEW_INSTANCE_PRECREATE_SIZE) ) )
		{
            throw CX_MemoryException();
		}
    }
}

CErrorObject::~CErrorObject()
{
    m_pObject->Release();
}

RELEASE_ME IWbemClassObject* CErrorObject::GetObject()
{
    m_pObject->AddRef();
    return (IWbemClassObject*)m_pObject;
}

BOOL CErrorObject::SetStatusCode(SCODE sRes)
{
    CVar v((LONG)sRes);
    HRESULT hRes = m_pObject->SetPropValue(L"StatusCode", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    return SUCCEEDED(hRes);
}

BOOL CErrorObject::SetOperation(COPY LPWSTR wszOperation)
{
    CVar vOldOperation;
    HRESULT hRes = m_pObject->GetProperty(L"Operation", &vOldOperation);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
   if(vOldOperation.IsNull())
    {
        CVar v(VT_BSTR, wszOperation);
        hRes = m_pObject->SetPropValue(L"Operation", &v, 0);
        if (hRes == WBEM_E_OUT_OF_MEMORY)
            throw CX_MemoryException();

        return SUCCEEDED(hRes);
    }
    else return FALSE;
}

BOOL CErrorObject::SetParamInformation(COPY LPWSTR wszExtraInfo)
{
    CVar vOldInfo;
    HRESULT hRes = m_pObject->GetProperty(L"ParameterInfo", &vOldInfo);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    if(vOldInfo.IsNull())
    {
        CVar v(VT_BSTR, wszExtraInfo);
        hRes = m_pObject->SetPropValue(L"ParameterInfo", &v, 0);
        if (hRes == WBEM_E_OUT_OF_MEMORY)
            throw CX_MemoryException();

        return SUCCEEDED(hRes);
    }
    else return FALSE;
}

BOOL CErrorObject::SetProviderName(COPY LPWSTR wszName)
{
    // Check if already set
    // ====================

    CVar vOldName;
    HRESULT hRes = m_pObject->GetProperty(L"ProviderName", &vOldName);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    if(vOldName.IsNull() || vOldName.GetType() == VT_EMPTY ||
                                !wbem_wcsicmp(vOldName.GetLPWSTR(), L"WinMgmt"))
    {
        CVar v(VT_BSTR, wszName);
        hRes = m_pObject->SetPropValue(L"ProviderName", &v, 0);
        if (hRes == WBEM_E_OUT_OF_MEMORY)
            throw CX_MemoryException();

        return SUCCEEDED(hRes);
    }
    else return WBEM_S_NO_ERROR;
}

BOOL CErrorObject::MarkAsInternal()
{
    return SetProviderName(L"WinMgmt");
}

BOOL CErrorObject::ContainsOperationInfo()
{
    CVar v;
    HRESULT hRes = m_pObject->GetProperty(L"Operation", &v);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    if(FAILED(hRes))
        return FALSE;
    return !v.IsNull();
}

BOOL CErrorObject::ContainsStatusCode()
{
    CVar v;
    HRESULT hRes = m_pObject->GetProperty(L"StatusCode", &v);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    if(FAILED(hRes))
        return FALSE;
    return !v.IsNull();
}




//******************************************************************************

/*
Blackcomb only

LPCWSTR	g_awszTxnClass[] = { L"Prestart", L"Pending", L"Precommit", L"Commit", L"EventPlayback", L"Completed", L"RolledBack",
							L"Cleanup", L"Fatal" };
void CTransactionClass::Init()
{
    InitEmpty(NEW_CLASS_PRECREATE_SIZE);

    CVar v(VT_BSTR, L"__Transaction");
    HRESULT hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"GUID", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    // Mark GUID as key
    // ================
    CVar vb(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"GUID", L"key", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"ClientComment", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"ClientID", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"State", &vNull, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

	SAFEARRAY *pArray = NULL;
    SAFEARRAYBOUND aBounds[1];
    long lLBound = 0, lUBound = 9;

    aBounds[0].cElements = lUBound;
    aBounds[0].lLbound = 0;

    pArray = SafeArrayCreate(VT_BSTR, 1, aBounds);
    if (pArray)
    {
		long	lNumElements = sizeof(g_awszTxnClass)/sizeof(LPCWSTR);

		for ( long	lCtr = 0; lCtr < lNumElements; lCtr++ )
		{
			BSTR	bstrTemp = SysAllocString( g_awszTxnClass[lCtr] );
			if ( NULL == bstrTemp )
			{
				throw CX_MemoryException();
			}

			// SafeArrayPutElement copies the BSTR so we still have to free it
			CSysFreeMe	sfm( bstrTemp );
			long lTemp[1];
			lTemp[0] = lCtr;
			if ( FAILED( SafeArrayPutElement(pArray, lTemp, bstrTemp) ) )
			{
				throw CX_MemoryException();
			}
		}

        CVar vc(VT_BSTR, pArray);
        hRes = SetPropQualifier(L"State", L"values", VALUES_FLAVOR, &vc);
        if (hRes == WBEM_E_OUT_OF_MEMORY)
            throw CX_MemoryException();

		// We won't need the safe array anymore, so go ahead and destroy it
		SafeArrayDestroy( pArray );
    }

    hRes = SetPropValue(L"Start", &vNull, CIM_DATETIME);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"LastUpdate", &vNull, CIM_DATETIME);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

}


void CUncommittedEventClass::Init()
{
    InitEmpty(NEW_CLASS_PRECREATE_SIZE);

    CVar v(VT_BSTR, L"__UncommittedEvent");
    HRESULT hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"EventID", &vNull, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    // Mark EventID as key, keyhole.
    // =============================
    CVar vb(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"EventID", L"key", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropQualifier(L"EventID", L"keyhole", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    // Transaction GUID is indexed
    // ===========================

    hRes = SetPropValue(L"TransactionGUID", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropQualifier(L"TransactionGUID", L"indexed", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"NamespaceName", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"ClassName", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"OldObject", &vNull, CIM_OBJECT);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"NewObject", &vNull, CIM_OBJECT);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"Transacted", &vNull, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

*/



//******************************************************************************

void CNamespaceMapClass::Init()
{
    CNamespaceClass NsBase;
    NsBase.Init();
    HRESULT hRes = CreateDerivedClass(&NsBase);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__WmiMappedDriverNamespace");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"CLSID", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"Server", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"Database", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"UserID", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"Password", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"Config", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

//******************************************************************************

/* The following system classes were removed for Whistler, but may
   be reintroduced for Blackcomb

void CClassInstanceSecurity::Init()
{
    InitEmpty(NEW_CLASS_PRECREATE_SIZE);

    CVar v(VT_BSTR, L"__ClassInstancesSecurity");
    HRESULT hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"Name", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vb(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"Name", L"key", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

}

void CClassSecurity::Init()
{
    InitEmpty(NEW_CLASS_PRECREATE_SIZE);

    CVar v(VT_BSTR, L"__ClassSecurity");
    HRESULT hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"Name", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vb(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"Name", L"key", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

}
*/


void CClasses::Init()
{
    if ( FAILED( InitEmpty(NEW_CLASS_PRECREATE_SIZE) ) )
	{
		throw CX_MemoryException();
	}

    CVar v(VT_BSTR, L"__Classes");
    HRESULT hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vb(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"singleton", &vb, SINGLETON_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

}

//================================================================
struct { const wchar_t *wszPropName; DWORD dwPropValue; } g_arbitratorConfigurationDefaults[] =
{
		{ L"OutstandingTasksTotal",         3000 },		//Total
		{ L"OutstandingTasksPerUser",       30 },		//Total

		{ L"TaskThreadsTotal",              30 },		//Total
		{ L"TaskThreadsPerUser",            3 },		//Total

		{ L"QuotaRetryCount",               10 },		//Total
		{ L"QuotaRetryWaitInterval",        15000 },	//Milliseconds

		{ L"TotalUsers",                    50 },		//Total

		{ L"TotalCacheMemoryPerTask",       1024 },		//1 MB
		{ L"TotalCacheMemoryPerUser",       2048 },		//2 MB
		{ L"TotalCacheMemory",              10240 },	//10 MB

		{ L"TotalCacheDiskPerTask",         51250 },	//50 MB
		{ L"TotalCacheDiskPerUser",         102500 },	//100 MB
		{ L"TotalCacheDisk",                1048576 },	//1 GB

		{ L"TemporarySubscriptionsPerUser", 1000 },	    //Total
		{ L"PermanentSubscriptionsPerUser",	1000 },	    //Total
		{ L"PollingInstructionsPerUser",	1000 },	    //Total
		{ L"PollingMemoryPerUser",	5000000 },	    //Total

		{ L"TemporarySubscriptionsTotal",   10000 },	//Total
		{ L"PermanentSubscriptionsTotal",	10000 },	//Total
		{ L"PollingInstructionsTotal",	    10000 },	//Total
		{ L"PollingMemoryTotal",	    10000000 },	//Total

		{ NULL,							0 }
};
void CArbitratorConfiguration::Init()
{
	//This is derived from __SystemClass
    CSystemClass System;
    System.Init();
    HRESULT hRes = CreateDerivedClass(&System);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

	//Set class name
	{
		CVar v(VT_BSTR, L"__ArbitratorConfiguration");
		hRes = SetPropValue(L"__CLASS", &v, 0);
		if (hRes == WBEM_E_OUT_OF_MEMORY)
			throw CX_MemoryException();
	}

	//Singleton object
	{
		CVar vk(VARIANT_TRUE, VT_BOOL);
		hRes = SetQualifier(L"singleton", &vk, SINGLETON_FLAVOR);
		if (hRes == WBEM_E_OUT_OF_MEMORY)
			throw CX_MemoryException();
	}

	//Add properties
	CVar vs;
	vs.SetAsNull();
	for (int i = 0; g_arbitratorConfigurationDefaults[i].wszPropName != NULL; i++)
	{
		hRes = SetPropValue(g_arbitratorConfigurationDefaults[i].wszPropName, &vs, CIM_UINT32);
		if (hRes == WBEM_E_OUT_OF_MEMORY)
			throw CX_MemoryException();
	}

}


void CArbitratorConfigurationInstance::Init(CArbitratorConfiguration* pClass)
{
    InitNew(pClass, NEW_INSTANCE_PRECREATE_SIZE);

	//Set propery values
	for (int i = 0; g_arbitratorConfigurationDefaults[i].wszPropName != NULL; i++)
	{
		CVar var;
		var.SetLong(g_arbitratorConfigurationDefaults[i].dwPropValue);
		HRESULT hRes = SetPropValue(g_arbitratorConfigurationDefaults[i].wszPropName, &var, 0);
		if (hRes == WBEM_E_OUT_OF_MEMORY)
			throw CX_MemoryException();
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

struct { const wchar_t *wszPropName; UINT32 dwPropValue; } g_ProviderHostQuotaConfigurationDefaultsUint32[] =
{
		{ L"ThreadsPerHost",		0x00000100 },
		{ L"HandlesPerHost",		0x00001000 },
		{ L"ProcessLimitAllHosts",	0x00000020 },
		{ NULL,						0 }
} ;

struct { const wchar_t *wszPropName; UINT64 dwPropValue; } g_ProviderHostQuotaConfigurationDefaultsUint64[] =
{
		{ L"MemoryPerHost",			0x0000000008000000 },
		{ L"MemoryAllHosts",		0x0000000040000000 },
		{ NULL,						0 }
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CProviderHostQuotaConfiguration::Init()
{
	//This is derived from __SystemClass
    CSystemClass System;
    System.Init();
    HRESULT hRes = CreateDerivedClass(&System);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

	//Set class name
	{
		CVar v(VT_BSTR, L"__ProviderHostQuotaConfiguration");
		hRes = SetPropValue(L"__CLASS", &v, 0);
		if (hRes == WBEM_E_OUT_OF_MEMORY)
			throw CX_MemoryException();
	}

	//Singleton object
	{
		CVar vk(VARIANT_TRUE, VT_BOOL);
		hRes = SetQualifier(L"singleton", &vk, SINGLETON_FLAVOR);
		if (hRes == WBEM_E_OUT_OF_MEMORY)
			throw CX_MemoryException();
	}

	//Add properties
	CVar vs;
	vs.SetAsNull();
	for (int i = 0; g_ProviderHostQuotaConfigurationDefaultsUint32[i].wszPropName != NULL; i++)
	{
		hRes = SetPropValue(g_ProviderHostQuotaConfigurationDefaultsUint32[i].wszPropName, &vs, CIM_UINT32);
		if (hRes == WBEM_E_OUT_OF_MEMORY)
			throw CX_MemoryException();
	}

	for (i = 0; g_ProviderHostQuotaConfigurationDefaultsUint64[i].wszPropName != NULL; i++)
	{
		hRes = SetPropValue(g_ProviderHostQuotaConfigurationDefaultsUint64[i].wszPropName, &vs, CIM_UINT64);
		if (hRes == WBEM_E_OUT_OF_MEMORY)
			throw CX_MemoryException();
	}

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CProviderHostQuotaConfigurationInstance::Init(CProviderHostQuotaConfiguration* pClass)
{
    InitNew(pClass, NEW_INSTANCE_PRECREATE_SIZE);

	//Set propery values
	for (int i = 0; g_ProviderHostQuotaConfigurationDefaultsUint32[i].wszPropName != NULL; i++)
	{
		CVar var;
		var.SetLong(g_ProviderHostQuotaConfigurationDefaultsUint32[i].dwPropValue);
		HRESULT hRes = SetPropValue(g_ProviderHostQuotaConfigurationDefaultsUint32[i].wszPropName, &var, 0);
		if (hRes == WBEM_E_OUT_OF_MEMORY)
			throw CX_MemoryException();
	}

	_IWmiObject *t_FastThis = NULL ;
	HRESULT hRes = QueryInterface ( IID__IWmiObject , ( void ** ) & t_FastThis ) ;
	if ( SUCCEEDED ( hRes ) )
	{
		for (i = 0; g_ProviderHostQuotaConfigurationDefaultsUint64[i].wszPropName != NULL; i++)
		{
			hRes = t_FastThis->WriteProp (

				g_ProviderHostQuotaConfigurationDefaultsUint64[i].wszPropName,
				0 ,
				sizeof ( UINT64 ) ,
				1 ,
				CIM_UINT64 ,
				& g_ProviderHostQuotaConfigurationDefaultsUint64[i].dwPropValue
			) ;

			if (hRes == WBEM_E_OUT_OF_MEMORY)
				throw CX_MemoryException();
		}

		t_FastThis->Release () ;
	}
}

/*
Removed for Whistler

void CComTaxonomyClass::Init()
{
    InitEmpty(NEW_CLASS_PRECREATE_SIZE);

    CVar v(VT_BSTR, L"__COMTaxonomy");
    HRESULT	hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"abstract", &vk, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CComInterfaceSetClass::Init()
{
    CComTaxonomyClass ComTaxonomy;
    ComTaxonomy.Init();
    HRESULT hRes = CreateDerivedClass(&ComTaxonomy);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__COMInterfaceSet");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"CLSID", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    // Mark CLSID as 'key'.
    // ===================
    CVar vb(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"CLSID", L"key", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"Name", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"IID", &vNull, CIM_STRING | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"IIDNames", &vNull, CIM_STRING | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

}

void CComDispatchElementClass::Init()
{
    CComTaxonomyClass ComTaxonomy;
    ComTaxonomy.Init();
    HRESULT hRes = CreateDerivedClass(&ComTaxonomy);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__COMDispatchElement");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"CLSID", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"DISPID", &vNull, CIM_SINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();


    // Mark CLSID and DispId as 'key'.
    // ===================
    CVar vb(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"CLSID", L"key", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropQualifier(L"DISPID", L"key", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"Name", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"NamedArguments", &vNull, CIM_STRING | CIM_FLAG_ARRAY );
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"NamedArgumentDISPIDs", &vNull, CIM_SINT32 | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"NamedArgumentTypes", &vNull, CIM_STRING | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

}

void CComDispatchInfoClass::Init()
{
    InitEmpty(NEW_CLASS_PRECREATE_SIZE);

    CVar v(VT_BSTR, L"__COMDispatchInfo");
    HRESULT	hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"CLSID", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"DISPID", &vNull, CIM_SINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"NamedArgumentDISPIDs", &vNull, CIM_SINT32 | CIM_FLAG_ARRAY );
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

}

void CComBindingClass::Init()
{
    InitEmpty(NEW_CLASS_PRECREATE_SIZE);

    CVar v(VT_BSTR, L"__COMBinding");
    HRESULT	hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vt(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"abstract", &vt, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

}


void CComInterfaceSetBindingClass::Init()
{
    CComBindingClass ComBinding;
    ComBinding.Init();
    HRESULT hRes = CreateDerivedClass(&ComBinding);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__COMInterfaceSetToClassBinding");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

	// Association
    CVar vt(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"association", &vt, ASSOC_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

	// HasClassRefs
    hRes = SetQualifier(L"HasClassRefs", &vt, ASSOC_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"InterfaceSet", &vNull, CIM_REFERENCE);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"TargetClass", &vNull, CIM_REFERENCE);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    // Mark proeprties as 'key'.
    // ===================
    CVar vb(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"InterfaceSet", L"key", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropQualifier(L"TargetClass", L"key", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

	// Both properties are strongly typed references.
	v.Empty();
	v.SetBSTR( L"ref:__COMInterfaceSet" );
    hRes = SetPropQualifier(L"InterfaceSet", L"CIMTYPE", 0, &v);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

	v.Empty();
	v.SetBSTR( L"ref:__ClassVector" );
    hRes = SetPropQualifier(L"TargetClass", L"CIMTYPE", 0, &v);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();



}

void CComDispatchElementBindingClass::Init()
{
    CComBindingClass ComBinding;
    ComBinding.Init();
    HRESULT hRes = CreateDerivedClass(&ComBinding);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__COMDispatchElementToClassBinding");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

	// Association
    CVar vt(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"association", &vt, ASSOC_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

	// HasClassRefs
    hRes = SetQualifier(L"HasClassRefs", &vt, ASSOC_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"DispatchElement", &vNull, CIM_REFERENCE);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"TargetClass", &vNull, CIM_REFERENCE);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    // Mark proeprties as 'key'.
    // ===================
    CVar vb(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"DispatchElement", L"key", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropQualifier(L"TargetClass", L"key", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

	// Both properties are strongly typed references.
	v.Empty();
	v.SetBSTR( L"ref:__COMDispatchElement" );
    hRes = SetPropQualifier(L"DispatchElement", L"CIMTYPE", 0, &v);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

	v.Empty();
	v.SetBSTR( L"ref:__ClassVector" );
    hRes = SetPropQualifier(L"TargetClass", L"CIMTYPE", 0, &v);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();


}

void CClassVectorClass::Init()
{
    InitEmpty(NEW_CLASS_PRECREATE_SIZE);

    CVar v(VT_BSTR, L"__ClassVector");
    HRESULT	hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vt(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"vector", &vt, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"ClassPath", &vNull, CIM_REFERENCE);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vb(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"ClassPath", L"key", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\stdclass.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    STDCLASS.CPP

Abstract:

    Class definitions for standard system classes.

History:

	raymcc    18-Jul-96       Created.

--*/


#ifndef _STDCLASS_H_
#define _STDCLASS_H_

#include <WbemUtil.h>
#include <FastAll.h>
#include <Sync.h>

class Registry;

class CSystemClass : public CWbemClass
{
public:
    CSystemClass(){}
    void Init();
};

class CGenericClass : public CWbemClass
{
public:
    CGenericClass(){}
    void Init();
};

class CNotifyStatusClass : public CWbemClass
{
public:
    CNotifyStatusClass(){}
    void Init();
};


class CNamespaceClass : public CWbemClass
{
public:
    CNamespaceClass(){}
    void Init();
};

class CThisNamespaceClass : public CWbemClass
{
public:
    CThisNamespaceClass(){}
    void Init();
};


class CNamespace: public CWbemInstance
{
private:
    static CNamespaceClass* mstatic_pClass;
    static CCritSec mstatic_cs;

	class __CleanUp
	{
	public:
		__CleanUp() {}
		~__CleanUp() { delete CNamespace::mstatic_pClass; }
	};
	static __CleanUp cleanup;
	friend __CleanUp;

public:
    void Init(LPWSTR pName);
};

class CThisNamespaceInstance : public CWbemInstance
{
public:
    CThisNamespaceInstance(){}
    void Init(CThisNamespaceClass* pClass);
};

class CProviderClass : public CWbemClass
{
public:
    CProviderClass(){}
    void Init();
};

class CWin32ProviderClass : public CWbemClass
{
public:
    CWin32ProviderClass(){}
    void Init();
};

class CProviderRegistrationClass : public CWbemClass
{
public:
    CProviderRegistrationClass(){}
    void Init();
};

class CObjectProviderRegistrationClass : public CWbemClass
{
public:
    CObjectProviderRegistrationClass(){}
    void Init();
};

class CClassProviderRegistrationClass : public CWbemClass
{
public:
    CClassProviderRegistrationClass(){}
    void Init();
};

class CInstanceProviderRegistrationClass : public CWbemClass
{
public:
    CInstanceProviderRegistrationClass(){}
    void Init();
};

class CPropertyProviderRegistrationClass : public CWbemClass
{
public:
    CPropertyProviderRegistrationClass(){}
    void Init();
};

class CMethodProviderRegistrationClass : public CWbemClass
{
public:
    CMethodProviderRegistrationClass(){}
    void Init();
};

class CEventProviderRegistrationClass : public CWbemClass
{
public:
    CEventProviderRegistrationClass(){}
    void Init();
};

class CEventConsumerProviderRegistrationClass : public CWbemClass
{
public:
    CEventConsumerProviderRegistrationClass(){}
    void Init();
};

class CCIMOMIdentificationClass : public CWbemClass
{
public:
    CCIMOMIdentificationClass(){}
    void Init();
private:
    void SetPropFromReg(Registry * pReg, TCHAR * pcRegName, WCHAR * pwcPropName);
};

// __AdapStatus
class CAdapStatusClass : public CWbemClass
{
public:
    CAdapStatusClass(){};
    void Init();
};

class CAdapStatusInstance : public CWbemInstance
{
public:
    CAdapStatusInstance(){}
    void Init(CAdapStatusClass * pClass);
};

//__CIMOMIdentification
class CIdentificationClass : public CWbemClass
{
public:
    CIdentificationClass(){};
    void Init();
};

class CIdentificationInstance : public CWbemInstance
{
public:
    CIdentificationInstance(){}
    void Init(CIdentificationClass * pClass);
};


class CCacheControlClass : public CWbemClass
{
public:
    CCacheControlClass(){}
    void Init();
};

class CSpecificCacheControlClass : public CWbemClass
{
public:
    CSpecificCacheControlClass(){}
    void Init(LPCWSTR wszClassName);
};

class CCacheControlInstance : public CWbemInstance
{
public:
    CCacheControlInstance(){}
    void Init(CSpecificCacheControlClass* pClass, DWORD dwSeconds);
};

class CActiveNamespacesClass : public CWbemClass
{
public:
    CActiveNamespacesClass(){}
    void Init();
};
//*****************************************************************************

class CIndicationRelatedClass : public CWbemClass
{
public:
    CIndicationRelatedClass(){}
    void Init();
};

class CEventClass : public CWbemClass
{
public:
    CEventClass(){}
    void Init();
};

class CParametersClass : public CWbemClass
{
public:
    CParametersClass(){}
    void Init();
};

class CEmptyEventClass : public CWbemClass
{
public:
    CEmptyEventClass(){}
    void Init(LPWSTR wszName);
};

class CGenericDataEventClass : public CWbemClass
{
public:
    CGenericDataEventClass() {}
    void Init(LPWSTR wszCimType, LPWSTR wszPropName);
};

class CDataEventClass : public CWbemClass
{
public:
    enum {include_new = 1, include_old = 2,
          type_create = include_new,
          type_delete = include_old,
          type_change = include_new | include_old
    };
    CDataEventClass(){}
    void Init(CWbemClass& Parent,
                    LPWSTR wszCimType, LPWSTR wszPropName, int nFlags);
};

class CNamespaceEventClass : public CDataEventClass
{
public:
    CNamespaceEventClass(){}
    void Init(CWbemClass& Parent, int nFlags)
    {
        CDataEventClass::Init(Parent, L"object:__Namespace", L"Namespace",
            nFlags);
    }
};

class CClassEventClass : public CDataEventClass
{
public:
    CClassEventClass(){}
    void Init(CWbemClass& Parent, int nFlags)
    {
        CDataEventClass::Init(Parent, L"object", L"Class", nFlags);
    }

};

class CInstanceEventClass : public CDataEventClass
{
public:
    CInstanceEventClass(){}
    void Init(CWbemClass& Parent, int nFlags)
    {
        CDataEventClass::Init(Parent, L"object", L"Instance", nFlags);
    }
};

class CMethodEventClass : public CWbemClass
{
public:
    void Init();
};

class CTimerEventClass : public CWbemClass
{
public:
    CTimerEventClass(){}
    void Init();
};

class CAggregateEventClass : public CWbemClass
{
public:
    CAggregateEventClass(){}
    void Init();
};

class CSystemEventClass : public CWbemClass
{
public:
    void Init();
};

class CEventDroppedEventClass : public CWbemClass
{
public:
    void Init();
};

class CQueueOverflowEventClass : public CWbemClass
{
public:
    void Init();
};

class CConsumerFailureEventClass : public CWbemClass
{
public:
    void Init();
};

class CQoSFailureEventClass : public CWbemClass
{
public:
    void Init();
};

class CMonitorEventClass : public CWbemClass
{
public:
    void Init(CWbemClass& Parent, LPCWSTR wszClassName);
};

class CMonitorDataEventClass : public CWbemClass
{
public:
    void Init(CWbemClass& Parent, LPCWSTR wszClassName);
};

//*****************************************************************************

class CEventConsumerClass : public CWbemClass
{
public:
    CEventConsumerClass(){}
    void Init();
};

//*****************************************************************************

class CConditionalInstructionClass : public CWbemClass
{
public:
    void Init();
};

//*****************************************************************************

class CEventMonitorClass : public CWbemClass
{
public:
    void Init();
};

//*****************************************************************************

class CEventFilterClass : public CWbemClass
{
public:
    CEventFilterClass(){}
    void Init();
};

//*****************************************************************************

class CFilterConsumerBindingClass : public CWbemClass
{
public:
    CFilterConsumerBindingClass(){}
    void Init();
};

//*****************************************************************************

class CEventGeneratorClass : public CWbemClass
{
public:
    CEventGeneratorClass(){}
    void Init();
};

class CTimerInstructionClass : public CWbemClass
{
public:
    CTimerInstructionClass(){}
    void Init();
};

class CAbsoluteTimerInstructionClass : public CWbemClass
{
public:
    CAbsoluteTimerInstructionClass(){}
    void Init();
};

class CIntervalTimerInstructionClass : public CWbemClass
{
public:
    CIntervalTimerInstructionClass(){}
    void Init();
};


class CTimerNextFiringClass : public CWbemClass
{
public:
    CTimerNextFiringClass(){}
    void Init();
};


//*****************************************************************************
class CSecurityBaseClass : public CWbemClass
{
public:
    CSecurityBaseClass(){}
    void Init();
};

class CSubjectClass : public CWbemClass
{
public:
    CSubjectClass(){}
    void Init();
};

class CUserClass : public CWbemClass
{
public:
    CUserClass(){}
    void Init();
};

class CNTLMUserClass : public CWbemClass
{
public:
    CNTLMUserClass(){}
    void Init();
};

class CNTLM9XUserClass : public CWbemClass
{
public:
    CNTLM9XUserClass(){}
    void Init();
};

class CGroupClass : public CWbemClass
{
public:
    CGroupClass(){}
    void Init();
};


class CNtlmGroupClass : public CGroupClass
{
public:
    CNtlmGroupClass(){}
    void Init();
};






class CSystemConfigClass : public CWbemClass
{
public:
    CSystemConfigClass(){}
    void Init();
	void AddStaticQual(LPWSTR pMethodName);
};

class CSystemConfigInstance : public CWbemInstance
{
public:
    CSystemConfigInstance(){}
    void Init(CSystemConfigClass* pClass);
};



//*****************************************************************************

class CErrorObjectClass : public CWbemClass
{
public:
    CErrorObjectClass(){}
    void Init();
};

class CErrorObject
{
protected:
    static CErrorObjectClass* mstatic_pClass;
    static CCritSec mstatic_cs;

	class __CleanUp
	{
	public:
		__CleanUp() {}
		~__CleanUp() { delete CErrorObject::mstatic_pClass; }
	};
	static __CleanUp cleanup;
	friend __CleanUp;

    CWbemInstance* m_pObject;
public:
    CErrorObject(ADDREF IWbemClassObject* pObject = NULL);
    ~CErrorObject();

    BOOL SetStatusCode(SCODE sRes);
    BOOL SetOperation(COPY LPWSTR wszOperation);
    BOOL SetParamInformation(COPY LPWSTR wszExtraInfo);
    BOOL SetProviderName(COPY LPWSTR wszName);
    BOOL MarkAsInternal();
    BOOL ContainsStatusCode();
    BOOL ContainsOperationInfo();

    RELEASE_ME IWbemClassObject* GetObject();
};

//*****************************************************************************


class CNamespaceMapClass : public CWbemClass
{
public:
    CNamespaceMapClass(){}
    void Init();
};

/* The following system classes are removed for Whistler; may be reintroduced
   for Blackcomb.

class CClassInstanceSecurity: public CWbemClass
{
public:
    CClassInstanceSecurity(){};
    void Init();
};

class CClassSecurity: public CWbemClass
{
public:
    CClassSecurity(){};
    void Init();
};

//*****************************************************************************

class CClassVectorClass : public CWbemClass
{
public:
    CClassVectorClass(){}
    void Init();
};


class CUncommittedEventClass : public CWbemClass
{
public:
    CUncommittedEventClass() {};
    void Init();
};


class CTransactionClass : public CWbemClass
{
public:
    CTransactionClass() {};
    void Init();
};

//*****************************************************************************

class CComTaxonomyClass : public CWbemClass
{
public:
    CComTaxonomyClass(){}
    void Init();
};

//*****************************************************************************

class CComInterfaceSetClass : public CWbemClass
{
public:
    CComInterfaceSetClass(){}
    void Init();
};

//*****************************************************************************

class CComDispatchElementClass : public CWbemClass
{
public:
    CComDispatchElementClass(){}
    void Init();
};

//*****************************************************************************

class CComDispatchInfoClass : public CWbemClass
{
public:
    CComDispatchInfoClass(){}
    void Init();
};

//*****************************************************************************

class CComBindingClass : public CWbemClass
{
public:
    CComBindingClass(){}
    void Init();
};

//*****************************************************************************

class CComInterfaceSetBindingClass : public CWbemClass
{
public:
    CComInterfaceSetBindingClass(){}
    void Init();
};

//*****************************************************************************

class CComDispatchElementBindingClass : public CWbemClass
{
public:
    CComDispatchElementBindingClass(){}
    void Init();
};


*/

//****************************************************************************

class CArbitratorConfiguration : public CWbemClass
{
public:
	CArbitratorConfiguration() {};
	void Init();
};

class CArbitratorConfigurationInstance : public CWbemInstance
{
public:
    CArbitratorConfigurationInstance(){}
    void Init(CArbitratorConfiguration* pClass);
};

class CClasses : public CWbemClass
{
public:
    CClasses() {};
    void Init();
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CProviderHostQuotaConfiguration : public CWbemClass
{
public:

	CProviderHostQuotaConfiguration() {};

	void Init();
};

class CProviderHostQuotaConfigurationInstance : public CWbemInstance
{
public:
    CProviderHostQuotaConfigurationInstance(){}
    void Init(CProviderHostQuotaConfiguration* pClass);
};


#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\svcq.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SVCQ.CPP

Abstract:

    Implemntation of asynchronous request queue classes.

    Classes implemented:

    CAsyncReq and derivatives    Asynchrnous requests to WINMGMT.
    CAsyncServiceQueue           The queue of such requests.

History:

    raymcc        16-Jul-96       Created.
    levn          12-Sep-96       Implemented a few requests.
                                  Added LoadProviders

--*/

#include "precomp.h"
#include <wbemcore.h>
#include <svcq.h>
#include <oahelp.inl>

CAsyncServiceQueue::CAsyncServiceQueue(_IWmiArbitrator * pArb)
: m_bInit( FALSE )
{
    m_lRef = 1;
    m_bInit = SetThreadLimits(50, 60, 0);
    CCoreQueue::SetArbitrator(pArb);
}

void CAsyncServiceQueue::IncThreadLimit()
{
    InterlockedIncrement(&m_lMaxThreads);
    InterlockedIncrement(&m_lHiPriMaxThreads);
}

void CAsyncServiceQueue::DecThreadLimit()
{
    InterlockedDecrement(&m_lMaxThreads);
    InterlockedDecrement(&m_lHiPriMaxThreads);
}


void CAsyncServiceQueue::InitializeThread()
{
    DEBUGTRACE((LOG_WBEMCORE, "STARTING a main queue thread %d for a total of "
                    "%d\n", GetCurrentThreadId(), m_lNumThreads));
    CWbemQueue::InitializeThread();
}

void CAsyncServiceQueue::UninitializeThread()
{
    DEBUGTRACE((LOG_WBEMCORE, "STOPPING a main queue thread %d for a total of "
                    "%d\n", GetCurrentThreadId(), m_lNumThreads));
    CWbemQueue::UninitializeThread();
}


//***************************************************************************
//
//  See svcq.h for documentation.
//
//***************************************************************************
CAsyncReq::CAsyncReq(IWbemObjectSink* pHandler, IWbemContext* pContext,
                        bool bSeparatelyThreaded)
    : CWbemRequest(pContext, bSeparatelyThreaded)
{
    if(pHandler)
    {
        if(m_pContext == NULL)
        {
            // Oop!
            m_pHandler = NULL;
            m_fOk = false;
            return;
        }
        IWbemCausalityAccess* pCA = NULL;
        m_pContext->QueryInterface(IID_IWbemCausalityAccess, (void**)&pCA);
        REQUESTID id;
        pCA->GetRequestId(&id);
        pCA->Release();

        m_pHandler = new CStdSink(pHandler);
        if (m_pHandler)
        {
            m_pHandler->AddRef();
        }
        else
        {
            m_fOk = false;
        }

    }
    else
    {
        m_pHandler = NULL;
    }
}

//***************************************************************************
//
//  See svcq.h for documentation.
//
//***************************************************************************
CAsyncReq::~CAsyncReq()
{
    if(m_pHandler)
        m_pHandler->Release();
}

void CAsyncReq::TerminateRequest(HRESULT hRes)
{
    if(m_pHandler)
        m_pHandler->SetStatus( 0, hRes, NULL, NULL);
    return;
}


/*
    * =============================================================================
	|
	| HRESULT CAsyncReq::SetTaskHandle ( _IWmiCoreHandle *phTask )
	| ------------------------------------------------------------
	| 
	| Sets the task handle for the request. This is overrides the virtual 
	| SetTaskHandle declared in CCoreExecReq. We need additional functionality,
	| specifically the ability to set the request sink. In order to do so, we first
	| need a valid request sink which we have at this level.
	|
	|
	* =============================================================================
*/

HRESULT CAsyncReq::SetTaskHandle ( _IWmiCoreHandle *phTask )
{
	HRESULT hRes = WBEM_S_NO_ERROR ;
	
    if (phTask)
    {
        phTask->AddRef();
        m_phTask = phTask;
    }
	
	if ( m_pHandler )
	{
		((CWmiTask*)m_phTask)->SetRequestSink(m_pHandler) ;
	}
	return hRes ;
}


CWbemQueue* CAsyncReq::GetQueue()
{
    return ConfigMgr::GetAsyncSvcQueue();
}
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

//***************************************************************************
//
//  See svcq.h for documentation.
//
//***************************************************************************
CNamespaceReq::CNamespaceReq(CWbemNamespace* pNamespace,
                             IWbemObjectSink* pHandler, IWbemContext* pContext,
                             bool bSeparatelyThreaded)
                    : CAsyncReq(pHandler, pContext, bSeparatelyThreaded)
{
    m_pNamespace = pNamespace;
    pNamespace->AddRef();
}

//***************************************************************************
//
//  See svcq.h for documentation.
//
//***************************************************************************
CNamespaceReq::~CNamespaceReq()
{
    m_pNamespace->Release();
}


//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

//***************************************************************************
//
//  See svcq.h for documentation.
//
//***************************************************************************
CAsyncReq_OpenNamespace::CAsyncReq_OpenNamespace(CWbemNamespace* pParentNs,
                                                 LPWSTR wszNamespace,
                                                 long lSecurityFlags,
                                                 DWORD dwPermission,
                                                 IWbemContext* pContext,
                                                 CCallResult* pResult, bool bForClient)
              : CAsyncReq(NULL, pContext), m_wsNamespace(wszNamespace),
                m_lSecurityFlags(lSecurityFlags), m_dwPermission(dwPermission), m_pResult(pResult),
                m_pParentNs(pParentNs), m_bForClient(bForClient)
{
    m_pResult->AddRef();
    m_pParentNs->AddRef();
}

//***************************************************************************
//
//  See svcq.h for documentation.
//
//***************************************************************************
CAsyncReq_OpenNamespace::~CAsyncReq_OpenNamespace()
{
    m_pResult->Release();
    m_pParentNs->Release();
}

//***************************************************************************
//
//  See svcq.h for documentation.
//
//***************************************************************************
HRESULT CAsyncReq_OpenNamespace::Execute()
{
    SCODE hres;

    BOOL bRepositoryOnly = (m_lSecurityFlags & WBEM_FLAG_CONNECT_REPOSITORY_ONLY);
    m_lSecurityFlags &= ~WBEM_FLAG_CONNECT_REPOSITORY_ONLY;

    CWbemNamespace* pNewNs = CWbemNamespace::CreateInstance();

    if (pNewNs == NULL)
    {
        m_pResult->SetStatus(WBEM_E_OUT_OF_MEMORY, NULL, NULL);
        return WBEM_E_OUT_OF_MEMORY;
    }

    CWmiTask *pTask = (CWmiTask *) m_phTask;
    if (pTask)
    {
//        pTask->printf("TID=%d;", GetCurrentThreadId());
//        pTask->printf("<OpenNamespace=%S>", LPWSTR(m_wsNamespace));
    }

    hres = pNewNs->Initialize(m_wsNamespace,
                        m_pParentNs->GetUserName(),
                        m_lSecurityFlags, m_dwPermission, m_bForClient, bRepositoryOnly,
                        m_pParentNs->GetClientMachine(), m_pParentNs->GetClientProcID(), FALSE, NULL);

    if (FAILED(hres))
    {
        m_pResult->SetStatus(hres, NULL, NULL);
        pNewNs->Release();
        return hres;
    }
    if (hres = pNewNs->GetStatus())
    {
        m_pResult->SetStatus(hres, NULL, NULL);
        pNewNs->Release();
        return hres;
    }

    // check for security if this isnt the local 9x case

    if((m_lSecurityFlags & SecFlagWin9XLocal) == 0)
    {
        DWORD dwAccess = pNewNs->GetUserAccess();
        if((dwAccess  & WBEM_ENABLE) == 0)
        {
            pNewNs->Release();
            m_pResult->SetStatus(WBEM_E_ACCESS_DENIED, NULL, NULL);
            return WBEM_E_ACCESS_DENIED;
        }
        pNewNs->SetPermissions(dwAccess);
    }

    pNewNs->SetLocale(m_pParentNs->GetLocale());
    m_pResult->SetResultServices(pNewNs);
    pNewNs->Release();

    m_pResult->SetStatus(WBEM_S_NO_ERROR, NULL, NULL);
    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//******************************************************************************
//
HRESULT CAsyncReq_DeleteClassAsync::Execute()
{
    HRESULT hRes;

    CWmiTask *pTask = (CWmiTask *) m_phTask;

    /*
    if (pTask)
    {
        pTask->printf("TID=%d;", GetCurrentThreadId());
        pTask->printf("<DeleteClass=%S>", LPWSTR(m_wsClass));
    }
    */

    try
    {
        hRes = m_pNamespace->Exec_DeleteClass(m_wsClass, m_lFlags, m_pContext,
                                            m_pHandler);
    }
    catch (...)
    {
        ExceptionCounter c;    
        hRes = WBEM_E_CRITICAL_ERROR;
        m_pHandler->SetStatus( 0, hRes, NULL, NULL);
    }
    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//
HRESULT CAsyncReq_ExecQueryAsync::Execute()
{
    HRESULT hRes;

    CWmiTask *pTask = (CWmiTask *) m_phTask;
    /*
    if (pTask)
    {
        pTask->printf("TID=%d;", GetCurrentThreadId());
        pTask->printf("<Query=%S>", LPWSTR(m_wsQuery));
    }
    */

    //pTask->SetRequestSink(m_pHandler);

    try
    {
        hRes = CQueryEngine::ExecQuery(m_pNamespace, m_wsQueryFormat, m_wsQuery,
                            m_lFlags, m_pContext, m_pHandler);
    }
    catch (...)
    {
        ExceptionCounter c;    
        hRes = WBEM_E_CRITICAL_ERROR;
        m_pHandler->SetStatus( 0, hRes, NULL, NULL);
    }
    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//
HRESULT CAsyncReq_PutClassAsync::Execute()
{
    HRESULT hRes;

    CWmiTask *pTask = (CWmiTask *) m_phTask;
    /*
    if (pTask)
    {
        pTask->printf("TID=%d;", GetCurrentThreadId());
        CVARIANT v;
        hRes = m_pClass->Get(L"__CLASS", 0, &v, 0, 0);
        pTask->printf("<PutClass=%S>", v.GetStr());
    }
    */

    try
    {
        hRes = m_pNamespace->Exec_PutClass(m_pClass, m_lFlags, m_pContext,
            m_pHandler
            );
    }
    catch (...)
    {
        ExceptionCounter c;    
        hRes = WBEM_E_CRITICAL_ERROR;
        m_pHandler->SetStatus( 0, hRes, NULL, NULL);
    }
    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//
HRESULT CAsyncReq_DeleteInstanceAsync::Execute()
{
    HRESULT hRes;

    CWmiTask *pTask = (CWmiTask *) m_phTask;
    /*
    if (pTask)
    {
        pTask->printf("TID=%d;", GetCurrentThreadId());
        pTask->printf("<DeleteInst=%S>", LPWSTR(m_wsPath));
    }
    */

    try
    {
        hRes = m_pNamespace->Exec_DeleteInstance(m_wsPath, m_lFlags, m_pContext,
            m_pHandler);
    }
    catch (...)
    {
        ExceptionCounter c;    
        hRes = WBEM_E_CRITICAL_ERROR;
        m_pHandler->SetStatus( 0, hRes, NULL, NULL);
    }
    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//
HRESULT CAsyncReq_PutInstanceAsync::Execute()
{
    HRESULT hRes;

    CWmiTask *pTask = (CWmiTask *) m_phTask;
    /*
    if (pTask)
    {
        pTask->printf("TID=%d;", GetCurrentThreadId());
        CVARIANT v;
        hRes = m_pInstance->Get(L"__PATH", 0, &v, 0, 0);
        pTask->printf("<PutInstance=%S>", v.GetStr());
    }
    */

    try
    {
      hRes= m_pNamespace->Exec_PutInstance(m_pInstance, m_lFlags, m_pContext,
        m_pHandler);
    }
    catch (...)
    {
        ExceptionCounter c;    
        hRes = WBEM_E_CRITICAL_ERROR;
        m_pHandler->SetStatus( 0, hRes, NULL, NULL);
    }
    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//
HRESULT CAsyncReq_CreateClassEnumAsync::Execute()
{
    HRESULT hRes;

    CWmiTask *pTask = (CWmiTask *) m_phTask;
    /*
    if (pTask)
    {
        pTask->printf("TID=%d;", GetCurrentThreadId());
        pTask->printf("<CreateClassEnum: superclass=%S>", LPWSTR(m_wsParent));
    }
    */

    //pTask->SetRequestSink(m_pHandler);

    try
    {
        hRes = m_pNamespace->Exec_CreateClassEnum(m_wsParent, m_lFlags,
            m_pContext, m_pHandler);
    }
    catch (...)
    {
        ExceptionCounter c;    
        hRes = WBEM_E_CRITICAL_ERROR;
        m_pHandler->SetStatus( 0, hRes, NULL, NULL);
    }
    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//
HRESULT CAsyncReq_CreateInstanceEnumAsync::Execute()
{
    HRESULT hRes;

    CWmiTask *pTask = (CWmiTask *) m_phTask;
    /*
    if (pTask)
    {
        pTask->printf("TID=%d;", GetCurrentThreadId());
        pTask->printf("<CreateInstanceEnum=%S>", LPWSTR(m_wsClass));
    }
    */

    //pTask->SetRequestSink(m_pHandler);

    try
    {
        hRes = m_pNamespace->Exec_CreateInstanceEnum(m_wsClass, m_lFlags,
            m_pContext, m_pHandler
            );
    }
    catch (...)
    {
        ExceptionCounter c;    
        hRes = WBEM_E_CRITICAL_ERROR;
        m_pHandler->SetStatus( 0, hRes, NULL, NULL);
    }
    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//
HRESULT CAsyncReq_GetObjectAsync::Execute()
{
    HRESULT hRes;

    CWmiTask *pTask = (CWmiTask *) m_phTask;
    /*
    if (pTask)
    {
        pTask->printf("TID=%d;", GetCurrentThreadId());
        pTask->printf("<GetObject=%S>", LPWSTR(m_wsObjectPath));
    }
    */

    try
    {
        hRes = m_pNamespace->Exec_GetObject(m_wsObjectPath, m_lFlags,
            m_pContext, m_pHandler);
    }
    catch (...)
    {
        ExceptionCounter c;    
        hRes = WBEM_E_CRITICAL_ERROR;
        m_pHandler->SetStatus( 0, hRes, NULL, NULL);
    }
    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//
HRESULT CAsyncReq_ExecMethodAsync::Execute()
{
    HRESULT hRes;

    CWmiTask *pTask = (CWmiTask *) m_phTask;
    /*
    if (pTask)
    {
        pTask->printf("TID=%d;", GetCurrentThreadId());
        pTask->printf("<ExecMethod=[%S] %S>", LPWSTR(m_wsMethodName), LPWSTR(m_wsObjectPath));
    }
    */

    try
    {
        hRes = m_pNamespace->Exec_ExecMethod(m_wsObjectPath, m_wsMethodName,
            m_lFlags, m_pInParams, m_pContext, m_pHandler
            );
    }
    catch (...)
    {
        ExceptionCounter c;    
        hRes = WBEM_E_CRITICAL_ERROR;
        m_pHandler->SetStatus( 0, hRes, NULL, NULL);
    }
    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//
CAsyncReq_ExecNotificationQueryAsync::CAsyncReq_ExecNotificationQueryAsync(
    CWbemNamespace* pNamespace,
    IWbemEventSubsystem_m4* pEss,
    BSTR QueryFormat, BSTR Query, long lFlags,
    IWbemObjectSink *pHandler, IWbemContext* pContext, HRESULT* phRes,
    HANDLE hEssDoneEvent
    ) :
        CNamespaceReq(pNamespace, pHandler, pContext, false),// no threadswitch!
        m_wsQueryFormat(QueryFormat), m_wsQuery(Query), m_lFlags(lFlags),
        m_phRes(phRes), m_pEss(pEss)
{
    if (m_pEss)
        m_pEss->AddRef();

    m_hEssDoneEvent = hEssDoneEvent;
}

//******************************************************************************
//
//******************************************************************************
//
CAsyncReq_ExecNotificationQueryAsync::~CAsyncReq_ExecNotificationQueryAsync()
{
    if (m_pEss)
        m_pEss->Release();
}


//******************************************************************************
//
//******************************************************************************
//
HRESULT CAsyncReq_ExecNotificationQueryAsync::Execute()
{
    HRESULT hRes;

    CWmiTask *pTask = (CWmiTask *) m_phTask;
    
    if (pTask)
    {
//        pTask->printf("TID=%d;", GetCurrentThreadId());
//        pTask->printf("<ExecNotificationQuery=%S>", LPWSTR(m_wsQuery));
    }
    else
    {
        DEBUGTRACE((LOG_WBEMCORE, "NotificationQuery %S without a Task!!\n", LPWSTR(m_wsQuery)));
        SetEvent(m_hEssDoneEvent);
        hRes = WBEM_E_CRITICAL_ERROR;
        m_pHandler->SetStatus( 0, hRes, NULL, NULL);
        return hRes;
    }

    //pTask->SetRequestSink(m_pHandler);

    try
    {
        WString sAdjustedNs = "\\\\.\\";
        sAdjustedNs += m_pNamespace->GetName();

        hRes = m_pEss->RegisterNotificationSink(sAdjustedNs, m_wsQueryFormat, m_wsQuery, m_lFlags,
                    m_pContext, m_pHandler);

        *m_phRes = hRes;
    }
    catch(...)
    {
        ExceptionCounter c;
        hRes = WBEM_E_CRITICAL_ERROR;
        m_pHandler->SetStatus( 0, hRes, NULL, NULL);
    }

    SetEvent(m_hEssDoneEvent);

    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//
CAsyncReq_CancelAsyncCall::CAsyncReq_CancelAsyncCall(
                            IWbemObjectSink* pSink, HRESULT* phres)
    : CAsyncReq(NULL, NULL), m_phres(phres), m_pSink(pSink)
{
    if (m_pSink)
        m_pSink->AddRef();
}

//******************************************************************************
//
//******************************************************************************
//
CAsyncReq_CancelAsyncCall::~CAsyncReq_CancelAsyncCall()
{
    if(m_pSink)
        m_pSink->Release();
}

//******************************************************************************
//
//******************************************************************************
//
HRESULT CAsyncReq_CancelAsyncCall::Execute()
{
    CWmiTask *pTask = (CWmiTask *) m_phTask;
    /*
    if (pTask)
    {
        pTask->printf("TID=%d;", GetCurrentThreadId());
        pTask->printf("<CancelAsyncCall [sink = 0x%X]>", m_pSink);
    }
    */

    HRESULT hres = CWbemNamespace::Exec_CancelAsyncCall(m_pSink);
    if(m_phres)
        *m_phres = hres;
    return hres;
}

//******************************************************************************
//
//******************************************************************************
//
CAsyncReq_CancelProvAsyncCall::CAsyncReq_CancelProvAsyncCall(
                            IWbemServices* pProv, IWbemObjectSink* pSink,
							IWbemObjectSink* pStatusSink )
    : CAsyncReq(NULL, NULL), m_pProv(pProv), m_pSink(pSink), m_pStatusSink( pStatusSink )
{
    if ( NULL != m_pProv )
        m_pProv->AddRef();

    if ( NULL != m_pSink )
        m_pSink->AddRef();

    if ( NULL != m_pStatusSink )
        m_pStatusSink->AddRef();

}

//******************************************************************************
//
//******************************************************************************
//
CAsyncReq_CancelProvAsyncCall::~CAsyncReq_CancelProvAsyncCall()
{
    if ( NULL != m_pProv )
        m_pProv->Release();

    if ( NULL != m_pSink )
        m_pSink->Release();

    if ( NULL != m_pStatusSink )
        m_pStatusSink->Release();
}

//******************************************************************************
//
//******************************************************************************
//
HRESULT CAsyncReq_CancelProvAsyncCall::Execute()
{
    HRESULT hres = CWbemNamespace::Exec_CancelProvAsyncCall( m_pProv, m_pSink );

	if ( NULL != m_pStatusSink )
	{
		m_pStatusSink->SetStatus( 0L, hres, NULL, NULL );
	}

    return hres;
}

//******************************************************************************
//
//******************************************************************************
//
CAsyncReq_RemoveNotifySink::CAsyncReq_RemoveNotifySink(
                            IWbemObjectSink* pSink, IWbemObjectSink* pStatusSink)
    : CAsyncReq(NULL, NULL), m_pSink(pSink),m_pStatusSink( pStatusSink )
{
    if (m_pSink)
        m_pSink->AddRef();

	if ( m_pStatusSink )
	{
		m_pStatusSink->AddRef();
	}
}

//******************************************************************************
//
//******************************************************************************
//
CAsyncReq_RemoveNotifySink::~CAsyncReq_RemoveNotifySink()
{
    if(m_pSink)
        m_pSink->Release();

	if ( m_pStatusSink )
	{
		m_pStatusSink->Release();
	}

}

//******************************************************************************
//
//******************************************************************************
//
HRESULT CAsyncReq_RemoveNotifySink::Execute()
{
	HRESULT hRes = WBEM_E_FAILED;
    IWbemEventSubsystem_m4* pEss = ConfigMgr::GetEssSink();
    if (pEss)
    {
        if (m_pSink)
            hRes = pEss->RemoveNotificationSink(m_pSink);
        pEss->Release();
    }

	if ( NULL != m_pStatusSink )
	{
		m_pStatusSink->SetStatus( 0L, hRes, NULL, NULL );
	}

    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//
void CAsyncReq_OpenNamespace::DumpError()
{    DEBUGTRACE((LOG_WBEMCORE,
        "CAsyncReq_OpenNamespace, Name= %S, in parent namespace %S\n", m_wsNamespace,
        m_pParentNs->GetName()));
}

//******************************************************************************
//
//******************************************************************************
//
void CAsyncReq_DeleteClassAsync::DumpError()
{    DEBUGTRACE((LOG_WBEMCORE,
        "CAsyncReq_DeleteClassAsync, class=%S in namespace %S using flags 0x%x\n", m_wsClass, m_pNamespace->GetName(), m_lFlags));
};

//******************************************************************************
//
//******************************************************************************
//
void CAsyncReq_ExecQueryAsync::DumpError()
{
    DEBUGTRACE((LOG_WBEMCORE,
        "CAsyncReq_ExecQueryAsync, Query= %S in namespace %S using flags 0x%x\n", m_wsQuery,
        m_pNamespace->GetName(), m_lFlags));
}

//******************************************************************************
//
//******************************************************************************
//
void CAsyncReq_PutClassAsync::DumpError()
{
    CVar var;
    CWbemClass * pCls = (CWbemClass *)m_pClass;
    if(0 == pCls->GetProperty(L"__class", &var))
        DEBUGTRACE((LOG_WBEMCORE,
        "CAsyncReq_PutClassAsync, class=%S in namespace %S using flags 0x%x\n", var.GetLPWSTR(),
        m_pNamespace->GetName(), m_lFlags));
}

//******************************************************************************
//
//******************************************************************************
//
void CAsyncReq_PutInstanceAsync::DumpError()
{
    BSTR mof = 0;
    if(0 == m_pInstance->GetObjectText(0, &mof))
    {
        DEBUGTRACE((LOG_WBEMCORE,
        "CAsyncReq_PutInstanceAsync instance= %S in namespace %S using flags 0x%x\n", mof, m_pNamespace->GetName(), m_lFlags));
        SysFreeString(mof);
    }
}

//******************************************************************************
//
//******************************************************************************
//
void CAsyncReq_CreateClassEnumAsync::DumpError()
{
    DEBUGTRACE((LOG_WBEMCORE,
        "CAsyncReq_CreateClassEnumAsync, Parent= %S in namespace %S using flags 0x%x\n",
         m_wsParent, m_pNamespace->GetName(), m_lFlags));
}

//******************************************************************************
//
//******************************************************************************
//
void CAsyncReq_CreateInstanceEnumAsync::DumpError()
{    DEBUGTRACE((LOG_WBEMCORE,
        "CAsyncReq_CreateInstanceEnumAsync, Class= %S in namespace %S using flags 0x%x\n",
            m_wsClass, m_pNamespace->GetName(), m_lFlags));
}

//******************************************************************************
//
//******************************************************************************
//
void CAsyncReq_GetObjectAsync::DumpError()
{    DEBUGTRACE((LOG_WBEMCORE,
        "CAsyncReq_GetObjectAsync, Path= %S in namespace %S using flags 0x%x\n", m_wsObjectPath,
        m_pNamespace->GetName(), m_lFlags));
}

//******************************************************************************
//
//******************************************************************************
//
void CAsyncReq_ExecMethodAsync::DumpError()
{
    BSTR bstrArgs = NULL;
    if(m_pInParams)
        m_pInParams->GetObjectText(0, &bstrArgs);

    DEBUGTRACE((LOG_WBEMCORE,
    "CAsyncReq_ExecMethodAsync, Path= %S, Method=%S, args=%S in namespace %S using flags 0x%x\n",
        m_wsObjectPath, m_wsMethodName, (bstrArgs) ? bstrArgs : L"<no args>",
        m_pNamespace->GetName(), m_lFlags));
    if(bstrArgs)
        SysFreeString(bstrArgs);
}

//******************************************************************************
//
//******************************************************************************

void CAsyncReq_ExecNotificationQueryAsync::DumpError()
{    DEBUGTRACE((LOG_WBEMCORE,
        "CAsyncReq_ExecNotificationQueryAsync, Query= %S in namespace %S using flags 0x%x\n", m_wsQuery,
        m_pNamespace->GetName(), m_lFlags));
}

//******************************************************************************
//
//******************************************************************************

void CAsyncReq_DeleteInstanceAsync::DumpError()
{    DEBUGTRACE((LOG_WBEMCORE,
        "CAsyncReq_DeleteInstanceAsync, path=%S in namespace %S using flags 0x%x\n", m_wsPath, m_pNamespace->GetName(), m_lFlags));
};


//******************************************************************************
//
//******************************************************************************
// ok
CAsyncReq_Open::CAsyncReq_Open(
        CWbemNamespace *pNs,
        LPWSTR strScope,
        LPWSTR strParam,
        long lFlags,
        IWbemContext *pCtx,
        IWbemObjectSinkEx *pSink
        )
        :
        CAsyncReq(pSink, pCtx)
{
    m_pNs = pNs;
    m_pNs->AddRef();
    m_pszScope = Macro_CloneLPWSTR(strScope);
    m_pszParam = Macro_CloneLPWSTR(strParam);
    m_lUserFlags = lFlags;
    m_pSink = pSink;
    m_pSink->AddRef();
}

//******************************************************************************
//
//******************************************************************************
// ok
CAsyncReq_Open::~CAsyncReq_Open()
{
    delete [] m_pszScope;
    delete [] m_pszParam;
    ReleaseIfNotNULL(m_pNs);
    ReleaseIfNotNULL(m_pSink);
}

//******************************************************************************
//
//******************************************************************************
// ok
HRESULT CAsyncReq_Open::Execute()
{
    HRESULT hRes;
    hRes = m_pNs->Exec_Open(m_pszScope, m_pszParam, m_lUserFlags,
        m_pContext, m_pSink);
    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//
void CAsyncReq_Open::DumpError()
{
}

//******************************************************************************
//
//******************************************************************************
//
CAsyncReq_Add::CAsyncReq_Add(
        CWbemNamespace *pNs,
        LPWSTR strObjectPath,
        long lFlags,
        IWbemContext *pCtx,
        IWbemObjectSink *pSink
        )
        :
        CAsyncReq(pSink, pCtx)
{
    m_pszObjectPath = Macro_CloneLPWSTR(strObjectPath);
    m_lUserFlags = lFlags;
    m_pNs = pNs;
    m_pNs->AddRef();
    m_pSink = pSink;
    m_pSink->AddRef();
}


//******************************************************************************
//
//******************************************************************************
//

CAsyncReq_Add::~CAsyncReq_Add()
{
    delete m_pszObjectPath;
    ReleaseIfNotNULL(m_pNs);
    ReleaseIfNotNULL(m_pSink);
}

//******************************************************************************
//
//******************************************************************************
//

HRESULT CAsyncReq_Add::Execute()
{
    HRESULT hRes;
    hRes = m_pNs->Exec_Add(m_pszObjectPath, m_lUserFlags, m_pContext, m_pSink);
    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//

void CAsyncReq_Add::DumpError()
{
    // nothing
}

//******************************************************************************
//
//******************************************************************************
//
CAsyncReq_Remove::CAsyncReq_Remove(
        CWbemNamespace *pNs,
        LPWSTR strObjectPath,
        long lFlags,
        IWbemContext *pCtx,
        IWbemObjectSink *pSink
        )
        : CAsyncReq(pSink, pCtx)

{
    m_pszObjectPath = Macro_CloneLPWSTR(strObjectPath);
    m_lUserFlags = lFlags;
    m_pNs = pNs;
    m_pNs->AddRef();
    m_pSink = pSink;
    m_pSink->AddRef();
}

//******************************************************************************
//
//******************************************************************************
//
CAsyncReq_Remove::~CAsyncReq_Remove()
{
    delete m_pszObjectPath;
    ReleaseIfNotNULL(m_pNs);
    ReleaseIfNotNULL(m_pSink);
}

//******************************************************************************
//
//******************************************************************************
//
HRESULT CAsyncReq_Remove::Execute()
{
    HRESULT hRes;
    hRes = m_pNs->Exec_Add(m_pszObjectPath, m_lUserFlags, m_pContext, m_pSink);
    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//
void CAsyncReq_Remove::DumpError()
{
    // nothing
}

//******************************************************************************
//
//******************************************************************************
//
CAsyncReq_Refresh::CAsyncReq_Refresh(
        CWbemNamespace *pNs,
        IWbemClassObject **pTarget,
        long lFlags,
        IWbemContext *pCtx,
        IWbemObjectSinkEx *pSink
        )
        : CAsyncReq(pSink, pCtx)

{
    m_pNs = pNs;
    m_pNs->AddRef();
    m_pTarget = 0;
    if (pTarget)
    {
        m_pTarget = *pTarget;
        m_pTarget->AddRef();
    }
    m_lUserFlags = lFlags;
    m_pSink = pSink;
    m_pSink->AddRef();
}


//******************************************************************************
//
//******************************************************************************
//
CAsyncReq_Refresh::~CAsyncReq_Refresh()
{
    ReleaseIfNotNULL(m_pNs);
    ReleaseIfNotNULL(m_pTarget);
    ReleaseIfNotNULL(m_pSink);
}

//******************************************************************************
//
//******************************************************************************
//
HRESULT CAsyncReq_Refresh::Execute()
{
    HRESULT hRes;
    hRes = m_pNs->Exec_Refresh(m_pTarget, m_lUserFlags, m_pContext, m_pSink);
    return hRes;
}


//******************************************************************************
//
//******************************************************************************
//
void CAsyncReq_Refresh::DumpError()
{
    // none
}


//******************************************************************************
//
//******************************************************************************
//
CAsyncReq_Rename::CAsyncReq_Rename(
        CWbemNamespace *pNs,
        LPWSTR strOldObjectPath,
        LPWSTR strNewObjectPath,
        long lFlags,
        IWbemContext *pCtx,
        IWbemObjectSink *pSink
        )
        : CAsyncReq(pSink, pCtx)

{
    m_pszOldObjectPath = Macro_CloneLPWSTR(strOldObjectPath);
    m_pszNewObjectPath = Macro_CloneLPWSTR(strNewObjectPath);
    m_lUserFlags = lFlags;
    m_pNs = pNs;
    m_pNs->AddRef();
    m_pSink = pSink;
    m_pSink->AddRef();
}

//******************************************************************************
//
//******************************************************************************
//
CAsyncReq_Rename::~CAsyncReq_Rename()
{
    delete m_pszOldObjectPath;
    delete m_pszNewObjectPath;
    ReleaseIfNotNULL(m_pNs);
    ReleaseIfNotNULL(m_pSink);
}

//******************************************************************************
//
//******************************************************************************
//
HRESULT CAsyncReq_Rename::Execute()
{
    HRESULT hRes;
    hRes = m_pNs->Exec_Rename(m_pszOldObjectPath, m_pszNewObjectPath,
        m_lUserFlags, m_pContext, m_pSink);
    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//
void CAsyncReq_Rename::DumpError()
{
    // none
}

//******************************************************************************
//
//******************************************************************************
//

HRESULT CAsyncReq_DynAux_GetInstances :: Execute ()
{
    HRESULT hRes = m_pNamespace->Exec_DynAux_GetInstances (

        m_pClassDef ,
        m_lFlags ,
        m_pContext ,
        m_pSink
    ) ;

    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//
void CAsyncReq_DynAux_GetInstances ::DumpError()
{
    // none
}

//******************************************************************************
//
//******************************************************************************
//

HRESULT CAsyncReq_DynAux_ExecQueryAsync :: Execute ()
{
    HRESULT hRes = m_pNamespace->Exec_DynAux_ExecQueryAsync (

        m_pClassDef ,
        m_Query,
        m_QueryFormat,
        m_lFlags ,
        m_pContext ,
        m_pSink
    ) ;

    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//
void CAsyncReq_DynAux_ExecQueryAsync ::DumpError()
{
    // none
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\svcq.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SVCQ.H

Abstract:

	Declarations for asynchronous request queue classes.

	Classes defined:

	CAsyncReq and derivatives    Asynchrnous requests to WINMGMT.
	CAsyncServiceQueue           The queue of such requests.

History:

	a-raymcc        16-Jul-96       Created.
	a-levn          12-Sep-96       Implemented a few requests.
								  Added LoadProviders

--*/

#ifndef _ASYNC_Q_H_
#define _ASYNC_Q_H_

class CWbemNamespace;
class CBasicObjectSink;
class CWbemObject;

//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq
//
//  Represents an asynchrnous request to WINMGMT, such as GetObjectAsync.
//  This class is derived from CExecRequest (execq.h), a generic request for
//  execution queues. For more information on queues and requests, see execq.h
//
//******************************************************************************
//
//  Contructor
//
//  Every asynchrnous request has an IWbemObjectSink pointer associated with it.
//  In addition, assigns a unique integer to this object which becomes its
//  request handle.
//
//  PARAMETERS:
//
//      IWbemObjectSink* pHandler    The handler associated with this request.
//                                  AddRefs and stores this pointer.
//
//******************************************************************************
//
//  Destructor
//
//  Releases the stored handler.
//
//******************************************************************************
//
//  GetRequestHandle
//
//  Returns the unique request handle assigned to this request in constructor.
//
//  RETURN VALUES:
//
//      long
//
//******************************************************************************

class CAsyncReq : public CWbemRequest
{
protected:
    CStdSink *m_pHandler;
    long m_lRequestHandle;

    void SetRequestHandle(long lHandle) {m_lRequestHandle = lHandle;}
    void SetNoAuthentication(IWbemObjectSink* pHandler);
public:
    CAsyncReq(IWbemObjectSink* pHandler, IWbemContext* pContext,
                bool bSeparatelyThreaded = false);
    virtual ~CAsyncReq();
    virtual HRESULT Execute() = 0;

    virtual CWbemQueue* GetQueue();
    virtual BOOL IsInternal() {return TRUE;}
    void TerminateRequest(HRESULT hRes);
	HRESULT SetTaskHandle(_IWmiCoreHandle *phTask);
};

//******************************************************************************
//******************************************************************************
//
//  class CAsyncServiceQueue
//
//  This class represents the queue of asynchrnous requests into WINMGMT (every
//  request into WINMGMT becomes asynchronous, since synchronous methods call
//  asynchrnous ones and wait). There is almost no additional functionality
//  here, see CExecQueue in execq.h for all details
//
//******************************************************************************
//
//  Constructor
//
//  In addition to normal CExecQueue construction, launches the processing
//  thread by calling Run.
//
//******************************************************************************

class CAsyncServiceQueue : public CWbemQueue
{
private:
    BOOL m_bInit;
public:
    CAsyncServiceQueue(_IWmiArbitrator * pArb);
    void InitializeThread();
    void UninitializeThread();
    void IncThreadLimit();
    void DecThreadLimit();
    BOOL IsInit(){ return m_bInit; };
};



//******************************************************************************
//******************************************************************************
//
//  class CNamespaceReq
//
//  Another abstract class, albeit derived from CAsyncReq. This one is for
//  asynchrnous requests to a particular namespace.
//
//******************************************************************************
//
//  Constructor.
//
//  In addition to the CAsyncReq's IWbemObjectSink*, takes the
//  namespace pointer against which the request is to be executed. Most of
//  the time, the execute function calls one of Exec_... members of
//  CWbemNamespace.
//
//******************************************************************************
class CNamespaceReq : public CAsyncReq
{
protected:
    CWbemNamespace* m_pNamespace;
public:
    CNamespaceReq(CWbemNamespace* pNamespace, IWbemObjectSink* pHandler,
                    IWbemContext* pContext, bool bSeparatelyThreaded = false);
    virtual ~CNamespaceReq();
    virtual HRESULT Execute() = 0;
};


//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq_DeleteClassAsync
//
//  Encapsulates a request to execute DeleteClassAsync against a particular
//  namespace. Does it by calling Exec_DeleteClass and converting the
//  results to the asynchrnous format.
//
//******************************************************************************
//
//  Constructor.
//
//  PARAMETERS:
//
//      IN CWbemNamespace* pNamespace    The namespace to execute against.
//      IN LPWSTR wszClass              The class to delete.
//      IN LONG lFlags                  Flags
//      IN IWbemObjectSink* pHandler     The handler to put results in.
//
//******************************************************************************
class CAsyncReq_DeleteClassAsync : public CNamespaceReq
{
    WString m_wsClass;
    LONG m_lFlags;

public:
    CAsyncReq_DeleteClassAsync(
        ADDREF CWbemNamespace *pNamespace,
        READONLY LPWSTR wszClass,
        LONG lFlags,
        ADDREF IWbemObjectSink *pHandler,
        IWbemContext* pContext
        ) : CNamespaceReq(pNamespace, pHandler, pContext),
            m_wsClass(wszClass), m_lFlags(lFlags)
    {}

    HRESULT Execute();
    void DumpError();

};

//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq_DeleteInstanceAsync
//
//  Encapsulates a request to execute DeleteInstanceAsync against a particular
//  namespace. Does it by calling Exec_DeleteInstance and converting the
//  results to the asynchrnous format.
//
//******************************************************************************
//
//  Constructor.
//
//  PARAMETERS:
//
//      IN CWbemNamespace* pNamespace    The namespace to execute against.
//      IN LPWSTR wszObjectPath         The path to the instance to delete.
//      IN LONG lFlags                  Flags
//      IN IWbemObjectSink* pHandler     The handler to put results in.
//
//******************************************************************************
class CAsyncReq_DeleteInstanceAsync : public CNamespaceReq
{
    WString m_wsPath;
    LONG m_lFlags;

public:
    CAsyncReq_DeleteInstanceAsync(
        ADDREF CWbemNamespace *pNamespace,
        READONLY LPWSTR wszPath,
        LONG lFlags,
        ADDREF IWbemObjectSink *pHandler,
        IWbemContext* pContext
        ) : CNamespaceReq(pNamespace, pHandler, pContext), m_wsPath(wszPath),
            m_lFlags(lFlags)
    {}

    HRESULT Execute();
    void DumpError();

};

//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq_PutClassAsync
//
//  Encapsulates a request to execute PutClassAsync against a particular
//  namespace. Does it by calling Exec_PutClass and converting the
//  results to the asynchrnous format.
//
//******************************************************************************
//
//  Constructor.
//
//  PARAMETERS:
//
//      IN CWbemNamespace* pNamespace    The namespace to execute against.
//      IN IWbemClassObject* pClass      The class to put.
//      IN LONG lFlags                  Flags
//      IN IWbemObjectSink* pHandler     The handler to put results in.
//
//******************************************************************************
class CAsyncReq_PutClassAsync : public CNamespaceReq
{
    IWbemClassObject* m_pClass;
    LONG m_lFlags;

public:
    CAsyncReq_PutClassAsync(
        ADDREF CWbemNamespace *pNamespace,
        ADDREF IWbemClassObject* pClass,
        LONG lFlags,
        ADDREF IWbemObjectSink *pHandler,
        ADDREF IWbemContext* pContext
        ) : CNamespaceReq(pNamespace, pHandler, pContext), m_pClass(pClass),
            m_lFlags(lFlags)
    {
        m_pClass->AddRef();
    }

    ~CAsyncReq_PutClassAsync()
    {
        m_pClass->Release();
    }
    HRESULT Execute();
    void DumpError();

};

//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq_PutInstanceAsync
//
//  Encapsulates a request to execute PutInstanceAsync against a particular
//  namespace. Does it by calling Exec_PutInstance and converting the
//  results to the asynchrnous format.
//
//******************************************************************************
//
//  Constructor.
//
//  PARAMETERS:
//
//      IN CWbemNamespace* pNamespace    The namespace to execute against.
//      IN IWbemClassObject* pInstance   The instance to put.
//      IN LONG lFlags                  Flags
//      IN IWbemObjectSink* pHandler     The handler to put results in.
//
//******************************************************************************
class CAsyncReq_PutInstanceAsync : public CNamespaceReq
{
    IWbemClassObject* m_pInstance;
    LONG m_lFlags;

public:
    CAsyncReq_PutInstanceAsync(
        ADDREF CWbemNamespace *pNamespace,
        ADDREF IWbemClassObject* pInstance,
        LONG lFlags,
        ADDREF IWbemObjectSink *pHandler,
        ADDREF IWbemContext* pContext
        ) : CNamespaceReq(pNamespace, pHandler, pContext),
            m_pInstance(pInstance), m_lFlags(lFlags)
    {
        m_pInstance->AddRef();
    }

    ~CAsyncReq_PutInstanceAsync()
    {
        m_pInstance->Release();
    }
    HRESULT Execute();
    void DumpError();

};

//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq_CreateClassEnumAsync
//
//  Encapsulates a request to execute CreateClassEnumAsync against a particular
//  namespace. Does it by calling Exec_CreateClassEnum and converting the
//  results to the asynchrnous format.
//
//******************************************************************************
//
//  Constructor.
//
//  PARAMETERS:
//
//      IN CWbemNamespace* pNamespace    The namespace to execute against.
//      IN BSTR Parent                  The name of the parent class. If NULL,
//                                      start at the top level.
//      IN LONG lFlags                  Flags
//      IN IWbemObjectSink* pHandler     The handler to put results in.
//
//******************************************************************************
class CAsyncReq_CreateClassEnumAsync : public CNamespaceReq
{
    WString m_wsParent;
    LONG m_lFlags;

public:
    CAsyncReq_CreateClassEnumAsync(CWbemNamespace* pNamespace,
        BSTR Parent, LONG lFlags, ADDREF IWbemObjectSink* pHandler,
        ADDREF IWbemContext* pContext
        ) : CNamespaceReq(pNamespace, pHandler, pContext), m_wsParent(Parent),
            m_lFlags(lFlags)
    {}
    HRESULT Execute();
    virtual BOOL IsLongRunning() {return TRUE;}
    void DumpError();
};

//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq_CreateInstanceEnumAsync
//
//  Encapsulates a request to execute CreateInstanceEnumAsync against a
//  particular
//  namespace. Does it by calling Exec_CreateInstanceEnum and converting the
//  results to the asynchrnous format.
//
//******************************************************************************
//
//  Constructor.
//
//  PARAMETERS:
//
//      IN CWbemNamespace* pNamespace    The namespace to execute against.
//      IN BSTR Class                   The name of the class.
//      IN LONG lFlags                  Flags
//      IN IWbemObjectSink* pHandler     The handler to put results in.
//
//******************************************************************************

class CAsyncReq_CreateInstanceEnumAsync : public CNamespaceReq
{
    WString m_wsClass;
    LONG m_lFlags;
public:
    CAsyncReq_CreateInstanceEnumAsync(
        CWbemNamespace* pNamespace, BSTR Class, LONG lFlags,
        ADDREF IWbemObjectSink *pHandler,
        ADDREF IWbemContext* pContext)
        : CNamespaceReq(pNamespace, pHandler, pContext), m_wsClass(Class),
            m_lFlags(lFlags)
    {}
    HRESULT Execute();
    virtual BOOL IsLongRunning() {return TRUE;}
    void DumpError();
};

//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq_GetObjectByPathAsync
//
//  Encapsulates a request to execute GetObjectAsync against a
//  particular
//  namespace. Does it by calling Exec_GetObjectByPath and converting the
//  results to the asynchrnous format.
//
//******************************************************************************
//
//  Constructor.
//
//  PARAMETERS:
//
//      IN CWbemNamespace* pNamespace    The namespace to execute against.
//      IN BSTR ObjectPath              The path to the object to get.
//      IN LONG lFlags                  Flags
//      IN IWbemObjectSink* pHandler     The handler to put results in.
//
//******************************************************************************
class CAsyncReq_GetObjectAsync : public CNamespaceReq
{
    WString m_wsObjectPath;
    long m_lFlags;

public:
    CAsyncReq_GetObjectAsync(
        CWbemNamespace* pNamespace, BSTR ObjectPath,  long lFlags,
        ADDREF IWbemObjectSink *pHandler, ADDREF IWbemContext* pContext) :
            CNamespaceReq(pNamespace, pHandler, pContext),
            m_wsObjectPath(ObjectPath), m_lFlags(lFlags)
    {}

    HRESULT Execute();
    void DumpError();
};


//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq_ExecMethodAsync
//
//  Encapsulates a request to execute ExecMethodAsync against a
//  particular
//  namespace. Does it by calling Exec_ExecMethodAsync and converting the
//  results to the asynchrnous format.
//
//******************************************************************************
//
//  Constructor.
//
//  PARAMETERS:
//
//      IN CWbemNamespace* pNamespace    The namespace to execute against.
//      IN BSTR ObjectPath              The path to the object to get.
//      IN BSTR MethodName              The name of the method
//      IN LONG lFlags                  Flags
//      IN IWbemClassObject* pInParams   The in-parameter of the method
//      IN IWbemObjectSink* pHandler     The handler to put results in.
//
//******************************************************************************
class CAsyncReq_ExecMethodAsync : public CNamespaceReq
{
    WString m_wsObjectPath;
    WString m_wsMethodName;
    IWbemClassObject* m_pInParams;
    long m_lFlags;

public:
    CAsyncReq_ExecMethodAsync(
        CWbemNamespace* pNamespace,
        BSTR ObjectPath,
        BSTR MethodName,
        long lFlags,
        IWbemClassObject* pInParams,
        ADDREF IWbemObjectSink *pHandler,
        ADDREF IWbemContext* pContext)
         : CNamespaceReq(pNamespace, pHandler, pContext),
            m_wsObjectPath(ObjectPath), m_wsMethodName(MethodName),
            m_pInParams(pInParams), m_lFlags(lFlags)
    {
        if(m_pInParams)
            m_pInParams->AddRef();
    }

    ~CAsyncReq_ExecMethodAsync()
    {
        if(m_pInParams)
            m_pInParams->Release();
    }
    HRESULT Execute();
    void DumpError();

};

//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq_ExecQueryAsync
//
//  Encapsulates a request to execute ExecQueryAsync against a
//  particular
//  namespace. Does it by calling CQueryEngine::ExecQuery and converting the
//  results to the asynchrnous format.
//
//******************************************************************************
//
//  Constructor.
//
//  PARAMETERS:
//
//      IN CWbemNamespace* pNamespace    The namespace to execute against.
//      IN BSTR QueryFormat             The query language
//      IN BSTR Query                   The query string.
//      IN LONG lFlags                  Flags
//      IN IWbemObjectSink* pHandler     The handler to put results in.
//
//******************************************************************************
class CAsyncReq_ExecQueryAsync : public CNamespaceReq
{
    WString m_wsQueryFormat;
    WString m_wsQuery;
    long m_lFlags;

public:
    CAsyncReq_ExecQueryAsync(CWbemNamespace* pNamespace,
        BSTR QueryFormat, BSTR Query, long lFlags,
        IWbemObjectSink *pHandler, IWbemContext* pContext) :
            CNamespaceReq(pNamespace, pHandler, pContext),
            m_wsQueryFormat(QueryFormat), m_wsQuery(Query), m_lFlags(lFlags)
    {}
    HRESULT Execute();
    virtual BOOL IsLongRunning() {return TRUE;}

    void DumpError();
};


//******************************************************************************
//
//******************************************************************************
//
class CCallResult;
class CAsyncReq_OpenNamespace : public CAsyncReq
{
    CWbemNamespace* m_pParentNs;
    WString m_wsNamespace;
    long m_lSecurityFlags;
    DWORD m_dwPermission;
    CCallResult* m_pResult;
    bool m_bForClient;

public:
    CAsyncReq_OpenNamespace(CWbemNamespace* pParentNs, LPWSTR wszNamespace,
        long lSecurityFlags, DWORD dwPermission,
        IWbemContext* pContext, CCallResult* pResult, bool bForClient);
    ~CAsyncReq_OpenNamespace();
    HRESULT Execute();
    void DumpError();

};

//******************************************************************************
//
//******************************************************************************
//
class CAsyncReq_Open : public CAsyncReq
{
    CWbemNamespace *m_pNs;
    LPWSTR m_pszScope;
    LPWSTR m_pszParam;
    LONG m_lUserFlags;
    IWbemObjectSinkEx *m_pSink;

public:
    CAsyncReq_Open(
        CWbemNamespace *pNs,
        LPWSTR strScope,
        LPWSTR strParam,
        long lFlags,
        IWbemContext *pCtx,
        IWbemObjectSinkEx *pSink
        );

   ~CAsyncReq_Open();
   HRESULT Execute();
   void DumpError();
};


//******************************************************************************
//
//******************************************************************************
//
class CAsyncReq_Add : public CAsyncReq
{
    CWbemNamespace *m_pNs;
    LPWSTR m_pszObjectPath;
    LONG m_lUserFlags;
    IWbemObjectSink *m_pSink;

public:
    CAsyncReq_Add(
        CWbemNamespace *pNs,
        LPWSTR strObjectPath,
        long lFlags,
        IWbemContext *pCtx,
        IWbemObjectSink *pSink
        );

   ~CAsyncReq_Add();
   HRESULT Execute();
   void DumpError();
};

//******************************************************************************
//
//******************************************************************************
//
class CAsyncReq_Remove : public CAsyncReq
{
    CWbemNamespace *m_pNs;
    LPWSTR m_pszObjectPath;
    LONG m_lUserFlags;
    IWbemObjectSink *m_pSink;

public:
    CAsyncReq_Remove(
        CWbemNamespace *pNs,
        LPWSTR strObjectPath,
        long lFlags,
        IWbemContext *pCtx,
        IWbemObjectSink *pSink
        );

   ~CAsyncReq_Remove();
   HRESULT Execute();
   void DumpError();
};

//******************************************************************************
//
//******************************************************************************
//
class CAsyncReq_Refresh : public CAsyncReq
{
    CWbemNamespace *m_pNs;
    LONG m_lUserFlags;
    IWbemObjectSink *m_pSink;
    IWbemClassObject *m_pTarget;

public:
    CAsyncReq_Refresh(
        CWbemNamespace *pNs,
        IWbemClassObject **pTarget,
        long lFlags,
        IWbemContext *pCtx,
        IWbemObjectSinkEx *pSink
        );

   ~CAsyncReq_Refresh();
   HRESULT Execute();
   void DumpError();
};


//******************************************************************************
//
//******************************************************************************
//
class CAsyncReq_Rename : public CAsyncReq
{
    CWbemNamespace *m_pNs;
    LPWSTR m_pszOldObjectPath;
    LPWSTR m_pszNewObjectPath;
    LONG m_lUserFlags;
    IWbemObjectSink *m_pSink;

public:
    CAsyncReq_Rename(
        CWbemNamespace *pNs,
        LPWSTR strOldObjectPath,
        LPWSTR strNewObjectPath,
        long lFlags,
        IWbemContext *pCtx,
        IWbemObjectSink *pSink
        );

   ~CAsyncReq_Rename();
   HRESULT Execute();
   void DumpError();
};




//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq_ExecNotificationQueryAsync
//
//  Encapsulates a request to execute ExecNotificationQueryAsync against a
//  particular
//  namespace. Does it by calling ESS RegisterNotificationSink.
//
//******************************************************************************
//
//  Constructor.
//
//  PARAMETERS:
//
//      IN CWbemNamespace* pNamespace    The namespace to execute against.
//      IN BSTR QueryFormat             The query language
//      IN BSTR Query                   The query string.
//      IN LONG lFlags                  Flags
//      IN IWbemObjectSink* pHandler     The handler to put results in.
//
//******************************************************************************
class CAsyncReq_ExecNotificationQueryAsync : public CNamespaceReq
{
    WString m_wsQueryFormat;
    WString m_wsQuery;
    long m_lFlags;
    HRESULT *m_phRes;
    IWbemEventSubsystem_m4* m_pEss;
    HANDLE m_hEssDoneEvent;

public:
    CAsyncReq_ExecNotificationQueryAsync(CWbemNamespace* pNamespace,
        IWbemEventSubsystem_m4* pEss,
        BSTR QueryFormat, BSTR Query, long lFlags,
        IWbemObjectSink *pHandler, IWbemContext* pContext, HRESULT* phRes,
        HANDLE hEssApprovalEvent
        );
    ~CAsyncReq_ExecNotificationQueryAsync();
    HRESULT Execute();
    virtual BOOL IsLongRunning() {return TRUE;}
    void DumpError();
};

//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq_CancelAsyncCall
//
//
//******************************************************************************
//
//  Constructor.
//
//  PARAMETERS:
//
//
//******************************************************************************

class CAsyncReq_CancelAsyncCall : public CAsyncReq
{
protected:
    HRESULT* m_phres;
    IWbemObjectSink* m_pSink;

public:
    CAsyncReq_CancelAsyncCall(IWbemObjectSink* pSink, HRESULT* phres);
    ~CAsyncReq_CancelAsyncCall();
    HRESULT Execute();
    void DumpError(){    DEBUGTRACE((LOG_WBEMCORE,
        "CAsyncReq_CancelAsyncCall call failed\n"));};

};

//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq_CancelProvAsyncCall
//
//
//******************************************************************************
//
//  Constructor.
//
//  PARAMETERS:
//
//
//******************************************************************************

class CAsyncReq_CancelProvAsyncCall : public CAsyncReq
{
protected:
	IWbemServices* m_pProv;
    IWbemObjectSink* m_pSink;
	IWbemObjectSink* m_pStatusSink;

public:
    CAsyncReq_CancelProvAsyncCall( IWbemServices* pProv, IWbemObjectSink* pSink,
									IWbemObjectSink* pStatusSink );
    ~CAsyncReq_CancelProvAsyncCall();
    HRESULT Execute();
    void DumpError(){    DEBUGTRACE((LOG_WBEMCORE,
        "CAsyncReq_CancelProvAsyncCall call failed\n"));};

};

//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq_DynAux_GetInstances
//
//
//******************************************************************************
//
//  Constructor.
//
//  PARAMETERS:
//
//
//    READONLY CWbemObject *pClassDef,
//    long lFlags,
//    IWbemContext* pCtx,
//    CBasicObjectSink* pSink
//
//******************************************************************************

class CAsyncReq_DynAux_GetInstances : public CNamespaceReq
{
private:

	CWbemObject *m_pClassDef ;
	IWbemContext *m_pCtx ;
    long m_lFlags ;
    CBasicObjectSink *m_pSink ;

public:

    CAsyncReq_DynAux_GetInstances (

		CWbemNamespace *pNamespace ,
		CWbemObject *pClassDef ,
		long lFlags ,
		IWbemContext *pCtx ,
		CBasicObjectSink *pSink

	) :	CNamespaceReq (

			pNamespace , 
			pSink , 
			pCtx, true
		) ,
        m_pClassDef(pClassDef), 
		m_pCtx(pCtx), 
		m_pSink(pSink),
		m_lFlags(lFlags)
	{
		if (m_pClassDef)
		{
			m_pClassDef->AddRef () ;
		}

		if (m_pCtx)
		{
			m_pCtx->AddRef () ;
		}

		if (m_pSink)
		{
			m_pSink->AddRef () ;
		}
	}

	CAsyncReq_DynAux_GetInstances :: ~CAsyncReq_DynAux_GetInstances ()
	{
		if (m_pClassDef)
		{
			m_pClassDef->Release () ;
		}

		if (m_pCtx)
		{
			m_pCtx->Release () ;
		}

		if (m_pSink)
		{
			m_pSink->Release () ;
		}
	}

    HRESULT Execute ();

    virtual BOOL IsLongRunning() {return TRUE;}

    void DumpError();
};

//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq_DynAux_ExecQueryAsync
//
//
//******************************************************************************
//
//  Constructor.
//
//  PARAMETERS:
//
//
//		CWbemNamespace *pNamespace ,
//		CWbemObject *pClassDef ,
//		LPWSTR Query,
//		LPWSTR QueryFormat,
//		long lFlags ,
//		IWbemContext *pCtx ,
//		CBasicObjectSink *pSink
//
//******************************************************************************

class CAsyncReq_DynAux_ExecQueryAsync : public CNamespaceReq
{
private:

	CWbemObject *m_pClassDef ;
    LPWSTR m_Query ;
    LPWSTR m_QueryFormat ;
	IWbemContext *m_pCtx ;
    long m_lFlags ;
    CBasicObjectSink *m_pSink ;
	HRESULT m_Result ;

public:

    CAsyncReq_DynAux_ExecQueryAsync (

		CWbemNamespace *pNamespace ,
		CWbemObject *pClassDef ,
		LPWSTR Query,
		LPWSTR QueryFormat,
		long lFlags ,
		IWbemContext *pCtx ,
		CBasicObjectSink *pSink

	) :	CNamespaceReq (

			pNamespace , 
			pSink , 
			pCtx, true
		) ,
        m_pClassDef(pClassDef), 
		m_pCtx(pCtx), 
		m_pSink(pSink),
		m_lFlags(lFlags),
		m_Query(NULL),
		m_QueryFormat(NULL),
		m_Result (S_OK)
	{
		if (m_pClassDef)
		{
			m_pClassDef->AddRef () ;
		}

		if (m_pCtx)
		{
			m_pCtx->AddRef () ;
		}

		if (m_pSink)
		{
			m_pSink->AddRef () ;
		}

		if (Query)
		{
			m_Query = SysAllocString ( Query ) ;
			if ( m_Query == NULL )
			{
				m_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		if (QueryFormat)
		{
			m_QueryFormat = SysAllocString ( QueryFormat ) ;
			if ( m_QueryFormat == NULL )
			{
				m_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	HRESULT Initialize () 
	{
		return m_Result ;
	}

	CAsyncReq_DynAux_ExecQueryAsync :: ~CAsyncReq_DynAux_ExecQueryAsync ()
	{
		if (m_pClassDef)
		{
			m_pClassDef->Release () ;
		}

		if (m_pCtx)
		{
			m_pCtx->Release () ;
		}

		if (m_pSink)
		{
			m_pSink->Release () ;
		}

		if (m_Query)
		{
			SysFreeString ( m_Query ) ;
		}

		if (m_QueryFormat)
		{
			SysFreeString ( m_QueryFormat ) ;
		}
	}

    HRESULT Execute ();

    virtual BOOL IsLongRunning() {return TRUE;}

    void DumpError();
};

class CAsyncReq_RemoveNotifySink : public CAsyncReq
{
private:
    IWbemObjectSink * m_pSink;
	IWbemObjectSink* m_pStatusSink;
public:
    CAsyncReq_RemoveNotifySink(IWbemObjectSink* pSink, IWbemObjectSink* pStatusSink);
    ~CAsyncReq_RemoveNotifySink();
    HRESULT Execute();
    void DumpError(){};

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\sysclass.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    sysclass.CPP

Abstract:

    System class generation function.

History:

--*/

#include "precomp.h"
#include "wbemcore.h"

HRESULT GetSystemStdObjects(CFlexArray * pResults)
{
	HRESULT hr = S_OK;

    // Create system classes
    // =====================

    CSystemClass * pSystemClass = new CSystemClass;
	if(pSystemClass) pSystemClass->Init();
	if(pSystemClass == NULL || CFlexArray::no_error != pResults->Add(pSystemClass))
		return WBEM_E_OUT_OF_MEMORY;
	

    CNamespaceClass * pNamespaceClass = new CNamespaceClass;
    if(pNamespaceClass) pNamespaceClass->Init();
	if(pNamespaceClass == NULL || CFlexArray::no_error != pResults->Add(pNamespaceClass))
		return WBEM_E_OUT_OF_MEMORY;

    CThisNamespaceClass * pThisNamespaceClass = new CThisNamespaceClass;
    if(pThisNamespaceClass) pThisNamespaceClass->Init();
	if(pThisNamespaceClass == NULL || CFlexArray::no_error != pResults->Add(pThisNamespaceClass))
		return WBEM_E_OUT_OF_MEMORY;

    CProviderClass * pProviderClass = new CProviderClass;
    if(pProviderClass) pProviderClass->Init();
	if(pProviderClass == NULL || CFlexArray::no_error != pResults->Add(pProviderClass))
		return WBEM_E_OUT_OF_MEMORY;

    CWin32ProviderClass * pWin32Prov = new CWin32ProviderClass;
    if(pWin32Prov) pWin32Prov->Init();
	if(pWin32Prov == NULL || CFlexArray::no_error != pResults->Add(pWin32Prov))
		return WBEM_E_OUT_OF_MEMORY;

    CProviderRegistrationClass * pProvRegistration = new CProviderRegistrationClass;
    if(pProvRegistration) pProvRegistration->Init();
	if(pProvRegistration == NULL || CFlexArray::no_error != pResults->Add(pProvRegistration))
		return WBEM_E_OUT_OF_MEMORY;

    CObjectProviderRegistrationClass *  pObjectProvReg = new CObjectProviderRegistrationClass;
    if(pObjectProvReg) pObjectProvReg->Init();
	if(pObjectProvReg == NULL || CFlexArray::no_error != pResults->Add(pObjectProvReg))
		return WBEM_E_OUT_OF_MEMORY;

    CClassProviderRegistrationClass  * pClassProvReg = new CClassProviderRegistrationClass;
    if(pClassProvReg) pClassProvReg->Init();
	if(pClassProvReg == NULL || CFlexArray::no_error != pResults->Add(pClassProvReg))
		return WBEM_E_OUT_OF_MEMORY;

    CInstanceProviderRegistrationClass * pInstProvReg = new CInstanceProviderRegistrationClass;
    if(pInstProvReg) pInstProvReg->Init();
	if(pInstProvReg == NULL || CFlexArray::no_error != pResults->Add(pInstProvReg))
		return WBEM_E_OUT_OF_MEMORY;

    CPropertyProviderRegistrationClass * pPropProvReg = new CPropertyProviderRegistrationClass;
    if(pPropProvReg) pPropProvReg->Init();
	if(pPropProvReg == NULL || CFlexArray::no_error != pResults->Add(pPropProvReg))
		return WBEM_E_OUT_OF_MEMORY;

    CMethodProviderRegistrationClass * pMethodProvReg = new CMethodProviderRegistrationClass;
    if(pMethodProvReg) pMethodProvReg->Init();
	if(pMethodProvReg == NULL || CFlexArray::no_error != pResults->Add(pMethodProvReg))
		return WBEM_E_OUT_OF_MEMORY;

    CEventProviderRegistrationClass *pEventProvReg = new CEventProviderRegistrationClass;
    if(pEventProvReg) pEventProvReg->Init();
	if(pEventProvReg == NULL || CFlexArray::no_error != pResults->Add(pEventProvReg))
		return WBEM_E_OUT_OF_MEMORY;

    CEventConsumerProviderRegistrationClass *  pEventConsumer = new CEventConsumerProviderRegistrationClass;
    if(pEventConsumer) pEventConsumer->Init();
	if(pEventConsumer == NULL || CFlexArray::no_error != pResults->Add(pEventConsumer))
		return WBEM_E_OUT_OF_MEMORY;

    CNotifyStatusClass  * pNotifyStatusClass = new CNotifyStatusClass;
    if(pNotifyStatusClass) pNotifyStatusClass->Init();
	if(pNotifyStatusClass == NULL || CFlexArray::no_error != pResults->Add(pNotifyStatusClass))
		return WBEM_E_OUT_OF_MEMORY;

    CErrorObjectClass * pErrorObjectClass = new CErrorObjectClass;
    if(pErrorObjectClass) pErrorObjectClass->Init();
	if(pErrorObjectClass == NULL || CFlexArray::no_error != pResults->Add(pErrorObjectClass))
		return WBEM_E_OUT_OF_MEMORY;

    CSecurityBaseClass * pSecurityBaseClass = new CSecurityBaseClass;
    if(pSecurityBaseClass) pSecurityBaseClass->Init();
	if(pSecurityBaseClass == NULL || CFlexArray::no_error != pResults->Add(pSecurityBaseClass))
		return WBEM_E_OUT_OF_MEMORY;

    CNTLM9XUserClass * pNTLM9XUser = new CNTLM9XUserClass;
    if(pNTLM9XUser) pNTLM9XUser->Init();
	if(pNTLM9XUser == NULL || CFlexArray::no_error != pResults->Add(pNTLM9XUser))
		return WBEM_E_OUT_OF_MEMORY;


    // Create event classes
    // ====================

    CIndicationRelatedClass * IndicationRelated = new CIndicationRelatedClass;
    if(IndicationRelated)IndicationRelated->Init();
	if(IndicationRelated == NULL || CFlexArray::no_error != pResults->Add(IndicationRelated))
		return WBEM_E_OUT_OF_MEMORY;

    CEventClass * Event = new CEventClass;
    if(Event)Event->Init();
	if(Event == NULL || CFlexArray::no_error != pResults->Add(Event))
		return WBEM_E_OUT_OF_MEMORY;

    CParametersClass * Parameters = new CParametersClass;
    if(Parameters)Parameters->Init();
	if(Parameters == NULL || CFlexArray::no_error != pResults->Add(Parameters))
		return WBEM_E_OUT_OF_MEMORY;

    CEmptyEventClass * pExtrinsicEvent = new CEmptyEventClass;
    if(pExtrinsicEvent)pExtrinsicEvent->Init(L"__ExtrinsicEvent");
	if(pExtrinsicEvent == NULL ||
            CFlexArray::no_error != pResults->Add(pExtrinsicEvent))
		return WBEM_E_OUT_OF_MEMORY;

    CGenericDataEventClass * NamespaceEvent = new CGenericDataEventClass;
    if(NamespaceEvent)NamespaceEvent->Init(L"object:__Namespace", L"Namespace");
	if(NamespaceEvent == NULL || CFlexArray::no_error != pResults->Add(NamespaceEvent))
		return WBEM_E_OUT_OF_MEMORY;

    CNamespaceEventClass * E1 = new CNamespaceEventClass;
    if(E1)E1->Init(*NamespaceEvent, CDataEventClass::type_create);
	if(E1 == NULL || CFlexArray::no_error != pResults->Add(E1))
		return WBEM_E_OUT_OF_MEMORY;

	CNamespaceEventClass * E2 = new CNamespaceEventClass;
    if(E2)E2->Init(*NamespaceEvent, CDataEventClass::type_delete);
	if(E2 == NULL || CFlexArray::no_error != pResults->Add(E2))
		return WBEM_E_OUT_OF_MEMORY;

	CNamespaceEventClass * E3 = new CNamespaceEventClass;
    E3->Init(*NamespaceEvent, CDataEventClass::type_change);
	if(E3 == NULL || CFlexArray::no_error != pResults->Add(E3))
		return WBEM_E_OUT_OF_MEMORY;

    CGenericDataEventClass * ClassEvent = new CGenericDataEventClass;
    if(ClassEvent)ClassEvent->Init(L"object", L"Class");
	if(ClassEvent == NULL || CFlexArray::no_error != pResults->Add(ClassEvent))
		return WBEM_E_OUT_OF_MEMORY;


    CClassEventClass * E4 = new CClassEventClass;
    if(E4)E4->Init(*ClassEvent, CDataEventClass::type_create);
	if(E4 == NULL || CFlexArray::no_error != pResults->Add(E4))
		return WBEM_E_OUT_OF_MEMORY;

    CClassEventClass * E5 = new CClassEventClass;
    if(E5)E5->Init(*ClassEvent, CDataEventClass::type_delete);
	if(E5 == NULL || CFlexArray::no_error != pResults->Add(E5))
		return WBEM_E_OUT_OF_MEMORY;

    CClassEventClass * E6 = new CClassEventClass;
    if(E6)E6->Init(*ClassEvent, CDataEventClass::type_change);
	if(E6 == NULL || CFlexArray::no_error != pResults->Add(E6))
		return WBEM_E_OUT_OF_MEMORY;

    CGenericDataEventClass * InstanceEvent = new CGenericDataEventClass;
    if(InstanceEvent)InstanceEvent->Init(L"object", L"Instance");
	if(InstanceEvent == NULL || CFlexArray::no_error != pResults->Add(InstanceEvent))
		return WBEM_E_OUT_OF_MEMORY;

    CInstanceEventClass * E7 = new CInstanceEventClass;
    if(E7)E7->Init(*InstanceEvent, CDataEventClass::type_create);
	if(E7 == NULL || CFlexArray::no_error != pResults->Add(E7))
		return WBEM_E_OUT_OF_MEMORY;

    CInstanceEventClass * E8 = new CInstanceEventClass;
    if(E8)E8->Init(*InstanceEvent, CDataEventClass::type_delete);
	if(E8 == NULL || CFlexArray::no_error != pResults->Add(E8))
		return WBEM_E_OUT_OF_MEMORY;

    CInstanceEventClass * E9 = new CInstanceEventClass;
    if(E9)E9->Init(*InstanceEvent, CDataEventClass::type_change);
	if(E9 == NULL || CFlexArray::no_error != pResults->Add(E9))
		return WBEM_E_OUT_OF_MEMORY;

    CMethodEventClass * EE9 = new CMethodEventClass;
    if(EE9)EE9->Init();
	if(EE9 == NULL || CFlexArray::no_error != pResults->Add(EE9))
		return WBEM_E_OUT_OF_MEMORY;

    CTimerEventClass * Event14 = new CTimerEventClass;
    if(Event14)Event14->Init();
	if(Event14 == NULL || CFlexArray::no_error != pResults->Add(Event14))
		return WBEM_E_OUT_OF_MEMORY;

    CAggregateEventClass * Event15 = new CAggregateEventClass;
    if(Event15)Event15->Init();
	if(Event15 == NULL || CFlexArray::no_error != pResults->Add(Event15))
		return WBEM_E_OUT_OF_MEMORY;

#ifdef __WHISTLER_UNCUT

    // Add monitor events
    // ==================

    CMonitorEventClass* pMonitorEvent = new CMonitorEventClass;
    if(pMonitorEvent) pMonitorEvent->Init(*pExtrinsicEvent, L"__MonitorEvent");
	if(pMonitorEvent == NULL ||
            CFlexArray::no_error != pResults->Add(pMonitorEvent))
		return WBEM_E_OUT_OF_MEMORY;

    CMonitorEventClass* pMEUp = new CMonitorEventClass;
    if(pMEUp) pMEUp->Init(*pMonitorEvent, L"__MonitorUpEvent");
	if(pMEUp == NULL || CFlexArray::no_error != pResults->Add(pMEUp))
		return WBEM_E_OUT_OF_MEMORY;

    CMonitorEventClass* pMEDown = new CMonitorEventClass;
    if(pMEDown) pMEDown->Init(*pMonitorEvent, L"__MonitorDownEvent");
	if(pMEDown == NULL || CFlexArray::no_error != pResults->Add(pMEDown))
		return WBEM_E_OUT_OF_MEMORY;

    CMonitorEventClass* pMEError = new CMonitorEventClass;
    if(pMEError) pMEError->Init(*pMonitorEvent, L"__MonitorErrorEvent");
	if(pMEError == NULL || CFlexArray::no_error != pResults->Add(pMEError))
		return WBEM_E_OUT_OF_MEMORY;

    CMonitorDataEventClass* pMEData = new CMonitorDataEventClass;
    if(pMEData) pMEData->Init(*pMonitorEvent, L"__MonitorDataEvent");
	if(pMEData == NULL || CFlexArray::no_error != pResults->Add(pMEData))
		return WBEM_E_OUT_OF_MEMORY;

    CMonitorDataEventClass* pMEAssert = new CMonitorDataEventClass;
    if(pMEAssert) pMEAssert->Init(*pMEData, L"__MonitorAssertEvent");
	if(pMEAssert == NULL || CFlexArray::no_error != pResults->Add(pMEAssert))
		return WBEM_E_OUT_OF_MEMORY;

    CMonitorDataEventClass* pMERetract = new CMonitorDataEventClass;
    if(pMERetract) pMERetract->Init(*pMEData, L"__MonitorRetractEvent");
	if(pMERetract == NULL || CFlexArray::no_error != pResults->Add(pMERetract))
		return WBEM_E_OUT_OF_MEMORY;

#endif

    // Create event consumer class
    // ===========================

    CEventConsumerClass * Consumer = new CEventConsumerClass;
    if(Consumer)Consumer->Init();
	if(Consumer == NULL || CFlexArray::no_error != pResults->Add(Consumer))
		return WBEM_E_OUT_OF_MEMORY;


    // Create event filter classes
    // ===========================


#ifdef __WHISTLER_UNCUT
    CConditionalInstructionClass * CondInst = new CConditionalInstructionClass;
    if(CondInst)CondInst->Init();
	if(CondInst == NULL || CFlexArray::no_error != pResults->Add(CondInst))
		return WBEM_E_OUT_OF_MEMORY;

    CEventMonitorClass * EventMonitor = new CEventMonitorClass;
    if(EventMonitor)EventMonitor->Init();
	if(EventMonitor == NULL ||
            CFlexArray::no_error != pResults->Add(EventMonitor))
		return WBEM_E_OUT_OF_MEMORY;

#endif

    CEventFilterClass * Filter = new CEventFilterClass;
    if(Filter)Filter->Init();
	if(Filter == NULL || CFlexArray::no_error != pResults->Add(Filter))
		return WBEM_E_OUT_OF_MEMORY;

    // Create the binding class
    // ========================

    CFilterConsumerBindingClass * Binding = new CFilterConsumerBindingClass;
    if(Binding)Binding->Init();
	if(Binding == NULL || CFlexArray::no_error != pResults->Add(Binding))
		return WBEM_E_OUT_OF_MEMORY;

    // Create timer generators
    // =======================

    CEventGeneratorClass * Generator = new CEventGeneratorClass;
    if(Generator)Generator->Init();
	if(Generator == NULL || CFlexArray::no_error != pResults->Add(Generator))
		return WBEM_E_OUT_OF_MEMORY;

    CTimerInstructionClass * TI = new CTimerInstructionClass;
    if(TI)TI->Init();
	if(TI == NULL || CFlexArray::no_error != pResults->Add(TI))
		return WBEM_E_OUT_OF_MEMORY;

    CAbsoluteTimerInstructionClass * ATI = new CAbsoluteTimerInstructionClass;
    if(ATI)ATI->Init();
	if(ATI == NULL || CFlexArray::no_error != pResults->Add(ATI))
		return WBEM_E_OUT_OF_MEMORY;

    CIntervalTimerInstructionClass * ITI = new CIntervalTimerInstructionClass;
    if(ITI)ITI->Init();
	if(ITI == NULL || CFlexArray::no_error != pResults->Add(ITI))
		return WBEM_E_OUT_OF_MEMORY;

    CTimerNextFiringClass * TNF = new CTimerNextFiringClass;
    if(TNF)TNF->Init();
	if(TNF == NULL || CFlexArray::no_error != pResults->Add(TNF))
		return WBEM_E_OUT_OF_MEMORY;

    // Create error event classes
    // ==========================


    CSystemEventClass * Event16 = new CSystemEventClass;
    if(Event16)Event16->Init();
	if(Event16 == NULL || CFlexArray::no_error != pResults->Add(Event16))
		return WBEM_E_OUT_OF_MEMORY;

    CEventDroppedEventClass * Event17 = new CEventDroppedEventClass;
    if(Event17)Event17->Init();
	if(Event17 == NULL || CFlexArray::no_error != pResults->Add(Event17))
		return WBEM_E_OUT_OF_MEMORY;

    CQueueOverflowEventClass * Event18 = new CQueueOverflowEventClass;
    if(Event18)Event18->Init();
	if(Event18 == NULL || CFlexArray::no_error != pResults->Add(Event18))
		return WBEM_E_OUT_OF_MEMORY;

    CConsumerFailureEventClass * Event19 = new CConsumerFailureEventClass;
    if(Event19)Event19->Init();
	if(Event19 == NULL || CFlexArray::no_error != pResults->Add(Event19))
		return WBEM_E_OUT_OF_MEMORY;


    CQoSFailureEventClass * Event20 = new CQoSFailureEventClass;
    if(Event20)Event20->Init();
	if(Event20 == NULL || CFlexArray::no_error != pResults->Add(Event20))
		return WBEM_E_OUT_OF_MEMORY;

/*
    CTransactionClass * TransactionClass = new CTransactionClass;
    if(TransactionClass)TransactionClass->Init();
	if(TransactionClass == NULL || CFlexArray::no_error != pResults->Add(TransactionClass))
		return WBEM_E_OUT_OF_MEMORY;

    CUncommittedEventClass * UncommittedEventClass = new CUncommittedEventClass;
    if(UncommittedEventClass)UncommittedEventClass->Init();
	if(UncommittedEventClass == NULL || CFlexArray::no_error != pResults->Add(UncommittedEventClass))
		return WBEM_E_OUT_OF_MEMORY;

    CClassSecurity * ClassSecurity = new CClassSecurity;
    if(ClassSecurity)ClassSecurity->Init();
	if(ClassSecurity == NULL || CFlexArray::no_error != pResults->Add(ClassSecurity))
		return WBEM_E_OUT_OF_MEMORY;

    CClassInstanceSecurity * ClassInstanceSecurity = new CClassInstanceSecurity;
    if(ClassInstanceSecurity)ClassInstanceSecurity->Init();
	if(ClassInstanceSecurity == NULL || CFlexArray::no_error != pResults->Add(ClassInstanceSecurity))
		return WBEM_E_OUT_OF_MEMORY;

    CClasses * Classes = new CClasses;
    if(Classes)Classes->Init();
	if(Classes == NULL || CFlexArray::no_error != pResults->Add(Classes))
		return WBEM_E_OUT_OF_MEMORY;
*/

    // Add the security object which provides methods for getting/setting
    // the security descriptor
    // ==================================================================
    CSystemConfigClass  * pConfigClass = new CSystemConfigClass;
    pConfigClass->Init();
	if(pConfigClass == NULL || CFlexArray::no_error != pResults->Add(pConfigClass))
		return WBEM_E_OUT_OF_MEMORY;

   // Add in namespace mapping classes.
    // =================================
    CNamespaceMapClass *pNsClass = new CNamespaceMapClass;
    pNsClass->Init();
	if (pNsClass == NULL || CFlexArray::no_error != pResults->Add(pNsClass))
		return WBEM_E_OUT_OF_MEMORY;

	// New Class Vector class
/* Removed for Whistler

    CClassVectorClass *pClassVectorClass = new CClassVectorClass;
    pClassVectorClass->Init();
	if (pClassVectorClass == NULL || CFlexArray::no_error != pResults->Add(pClassVectorClass))
		return WBEM_E_OUT_OF_MEMORY;

	// COM Taxonomy classes
    CComTaxonomyClass *pComTaxonomyClass = new CComTaxonomyClass;
    pComTaxonomyClass->Init();
	if (pComTaxonomyClass == NULL || CFlexArray::no_error != pResults->Add(pComTaxonomyClass))
		return WBEM_E_OUT_OF_MEMORY;

    CComInterfaceSetClass *pComInterfaceSetClass = new CComInterfaceSetClass;
    pComInterfaceSetClass->Init();
	if (pComInterfaceSetClass == NULL || CFlexArray::no_error != pResults->Add(pComInterfaceSetClass))
		return WBEM_E_OUT_OF_MEMORY;

    CComDispatchElementClass *pComDispatchElementClass = new CComDispatchElementClass;
    pComDispatchElementClass->Init();
	if (pComDispatchElementClass == NULL || CFlexArray::no_error != pResults->Add(pComDispatchElementClass))
		return WBEM_E_OUT_OF_MEMORY;

    CComDispatchInfoClass *pComDispatchInfoClass = new CComDispatchInfoClass;
    pComDispatchInfoClass->Init();
	if (pComDispatchInfoClass == NULL || CFlexArray::no_error != pResults->Add(pComDispatchInfoClass))
		return WBEM_E_OUT_OF_MEMORY;

    CComBindingClass *pComBindingClass = new CComBindingClass;
    pComBindingClass->Init();
	if (pComBindingClass == NULL || CFlexArray::no_error != pResults->Add(pComBindingClass))
		return WBEM_E_OUT_OF_MEMORY;

    CComInterfaceSetBindingClass *pComInterfaceSetBindingClass = new CComInterfaceSetBindingClass;
    pComInterfaceSetBindingClass->Init();
	if (pComInterfaceSetBindingClass == NULL || CFlexArray::no_error != pResults->Add(pComInterfaceSetBindingClass))
		return WBEM_E_OUT_OF_MEMORY;

    CComDispatchElementBindingClass *pComDispatchElementBindingClass = new CComDispatchElementBindingClass;
    pComDispatchElementBindingClass->Init();
	if (pComDispatchElementBindingClass == NULL || CFlexArray::no_error != pResults->Add(pComDispatchElementBindingClass))
		return WBEM_E_OUT_OF_MEMORY;
*/

    return 0;
}

HRESULT GetSystemSecurityObjects(CFlexArray * pResults)
{
	
	HRESULT hr = S_OK;
    CSubjectClass * pSubject = new CSubjectClass;
	if(pSubject)pSubject->Init();
	if(pSubject == NULL || CFlexArray::no_error != pResults->Add(pSubject))
		return WBEM_E_OUT_OF_MEMORY;

    CUserClass * pUser = new CUserClass;
	if(pUser)pUser->Init();
	if(pUser == NULL || CFlexArray::no_error != pResults->Add(pUser))
		return WBEM_E_OUT_OF_MEMORY;

    CNTLMUserClass * pNTLMUser = new CNTLMUserClass;
	if(pNTLMUser)pNTLMUser->Init();
	if(pNTLMUser == NULL || CFlexArray::no_error != pResults->Add(pNTLMUser))
		return WBEM_E_OUT_OF_MEMORY;

    CGroupClass * pGroup = new CGroupClass;
	if(pGroup)pGroup->Init();
	if(pGroup == NULL || CFlexArray::no_error != pResults->Add(pGroup))
		return WBEM_E_OUT_OF_MEMORY;

    CNtlmGroupClass * pNtlmGroup = new CNtlmGroupClass;
	if(pNtlmGroup)pNtlmGroup->Init();
	if(pNtlmGroup == NULL || CFlexArray::no_error != pResults->Add(pNtlmGroup))
		return WBEM_E_OUT_OF_MEMORY;
	return S_OK;
}

HRESULT GetStandardInstances(CFlexArray * pResults)
{
	HRESULT hr = S_OK;

    // Create the __systemsecurity=@ instance

    CSystemConfigClass  * pConfigClass = new CSystemConfigClass;
	if(pConfigClass == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	CDeleteMe<CSystemConfigClass> dm(pConfigClass);
	pConfigClass->Init();

    CSystemConfigInstance * pConfigInstance = new CSystemConfigInstance;
    if(pConfigInstance == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	pConfigInstance->Init(pConfigClass);
	if(CFlexArray::no_error != pResults->Add(pConfigInstance))
		return WBEM_E_OUT_OF_MEMORY;

    CThisNamespaceClass * pThisNamespaceClass = new CThisNamespaceClass;
    if(pThisNamespaceClass == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	CDeleteMe<CThisNamespaceClass> dm2(pThisNamespaceClass);
	pThisNamespaceClass->Init();

    CThisNamespaceInstance * pThisNamespaceInstance = new CThisNamespaceInstance;
    if(pThisNamespaceInstance == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	pThisNamespaceInstance->Init(pThisNamespaceClass);
	if(CFlexArray::no_error != pResults->Add(pThisNamespaceInstance))
		return WBEM_E_OUT_OF_MEMORY;

    return 0;
}

HRESULT CreateCacheControl2(CFlexArray * pResults, LPCWSTR wszClassName, DWORD dwSeconds)
{
    CSpecificCacheControlClass * ControlClass = new CSpecificCacheControlClass;
    if(ControlClass)ControlClass->Init(wszClassName);
	if(ControlClass == NULL || CFlexArray::no_error != pResults->Add(ControlClass))
		return WBEM_E_OUT_OF_MEMORY;

    CCacheControlInstance * ControlInstance = new CCacheControlInstance;
    if(ControlInstance)ControlInstance->Init(ControlClass, dwSeconds);
	if(ControlInstance == NULL || CFlexArray::no_error != pResults->Add(ControlInstance))
		return WBEM_E_OUT_OF_MEMORY;

    return 0;
}

HRESULT GetSystemRootObjects(CFlexArray * pResults)
{

    CCacheControlClass * pCacheControlCache = new CCacheControlClass;
    if(pCacheControlCache) pCacheControlCache->Init();
	if(pCacheControlCache == NULL || CFlexArray::no_error != pResults->Add(pCacheControlCache))
		return WBEM_E_OUT_OF_MEMORY;

	BOOL t_ShortTimeout = TRUE ;

	OSVERSIONINFOEX t_VersionInfo ;
	t_VersionInfo.dwOSVersionInfoSize = sizeof ( t_VersionInfo ) ;

	BOOL t_Status = GetVersionEx ( ( OSVERSIONINFO * ) & t_VersionInfo ) ;
	if ( t_Status )
	{
		if ( t_VersionInfo.wProductType != VER_NT_WORKSTATION )
		{
			t_ShortTimeout = FALSE ;
		}
	}

	HRESULT hr;
    hr = CreateCacheControl2(pResults, L"__ObjectProviderCacheControl", t_ShortTimeout ? 30 : 300 );
	if(FAILED(hr))
		return hr;
    hr = CreateCacheControl2(pResults, L"__PropertyProviderCacheControl", t_ShortTimeout ? 30 : 300 );
	if(FAILED(hr))
		return hr;
    hr = CreateCacheControl2(pResults, L"__EventProviderCacheControl", t_ShortTimeout ? 30 : 300 );
	if(FAILED(hr))
		return hr;
    hr = CreateCacheControl2(pResults, L"__EventConsumerProviderCacheControl", t_ShortTimeout ? 30 : 300 );
	if(FAILED(hr))
		return hr;
    hr = CreateCacheControl2(pResults, L"__EventSinkCacheControl", t_ShortTimeout ? 15 : 150  );
	if(FAILED(hr))
		return hr;

	//Provider Host class
	CProviderHostQuotaConfiguration *pProviderHostQuotaConfigurationClass = new CProviderHostQuotaConfiguration;
	if (pProviderHostQuotaConfigurationClass == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	pProviderHostQuotaConfigurationClass->Init();
	if (CFlexArray::no_error != pResults->Add(pProviderHostQuotaConfigurationClass))
		return WBEM_E_OUT_OF_MEMORY;

	//Provider Host  class
	CProviderHostQuotaConfigurationInstance *pProviderHostQuotaConfigurationInstance = new CProviderHostQuotaConfigurationInstance;
	if (pProviderHostQuotaConfigurationInstance == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	pProviderHostQuotaConfigurationInstance->Init(pProviderHostQuotaConfigurationClass);
	if (CFlexArray::no_error != pResults->Add(pProviderHostQuotaConfigurationInstance))
		return WBEM_E_OUT_OF_MEMORY;

    CActiveNamespacesClass * pActiveNSClass = new CActiveNamespacesClass;
    if(pActiveNSClass) pActiveNSClass->Init();
	if(pActiveNSClass == NULL || CFlexArray::no_error != pResults->Add(pActiveNSClass))
		return WBEM_E_OUT_OF_MEMORY;

	//Arbitrator class
	CArbitratorConfiguration *pArbClass = new CArbitratorConfiguration;
	if (pArbClass == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	pArbClass->Init();
	if (CFlexArray::no_error != pResults->Add(pArbClass))
		return WBEM_E_OUT_OF_MEMORY;
	
	//Arbitrator instance
	CArbitratorConfigurationInstance *pArbInstance = new CArbitratorConfigurationInstance;
	if (pArbInstance == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	pArbInstance->Init(pArbClass);
	if (CFlexArray::no_error != pResults->Add(pArbInstance))
		return WBEM_E_OUT_OF_MEMORY;

    CCIMOMIdentificationClass * pIdentClass = new CCIMOMIdentificationClass;
    if(pIdentClass) pIdentClass->Init();
	if(pIdentClass == NULL || CFlexArray::no_error != pResults->Add(pIdentClass))
		return WBEM_E_OUT_OF_MEMORY;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\sysclass.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SYSCLASS.H

Abstract:

    System class generation function.


History:

--*/

#ifndef __SYSCLASS__H_
#define __SYSCLASS__H_

HRESULT GetSystemStdObjects(CFlexArray * Results);
HRESULT GetSystemSecurityObjects(CFlexArray * Results);
HRESULT GetSystemRootObjects(CFlexArray * Results);
HRESULT GetStandardInstances(CFlexArray * Results);

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\wbemcore.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMCORE.H

Abstract:

	Master include files. Include everything WinMgmt includes..

History:

	23-Jul-96   raymcc    Created.
	3/10/97     a-levn    Fully documented

--*/

#ifndef _WBEMIMPL_H_
#define _WBEMIMPL_H_

#include <stdio.h>
#include <time.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <io.h>

//************************** WARNING ***************************************
// STL collections insist on protecting themselves against multi-threaded
// access. We don't want that --- we protect ourselves. This protection
// involves an extra DLL (msvcp50.dll) which we don't want to deal with. So
// we trick it into believing that we are compiling single-threaded.
//**************************************************************************
/*
#ifdef _MT
  #undef _MT
  #include <yvals.h>
  #define _MT
#endif
*/

//#include <dbgalloc.h>
#include <wbemidl.h>
#include <wbemint.h>
#include "CliCnt.h"
#include <reposit.h>

// This keeps track of when the core can be unloaded

extern CClientCnt gClientCounter;

// Parameter flow indicators.
// ==========================

#define READONLY
    // The value should be treated as read-only

#define ACQUIRED
    // Ownership of the object/pointer is acquired.

#define COPIED
    // The function makes a copy of the object/pointer.

#define PREALLOCATED
    // The out-param uses caller's memory.

#define NEWOBJECT
    // The return value or out parameter is a new
    // allocation which must be deallocated by
    // the caller if the call succeeds.

#define READWRITE
    // The in-param is will be treated as read-write,
    // but will not be deallocated.

#define INTERNAL
    // Returns a pointer to internal memory object
    // which should not be deleted.

#define ADDREF
    // On a parameter, indicates that the called
    // function will do an AddRef() on the interface
    // and retain it after the call completes.

#define TYPEQUAL L"CIMTYPE"
#define ADMINISTRATIVE_USER L".\\SYSTEM"

#define ReleaseIfNotNULL(p) if(p) p->Release()

#include <WinMgmtR.h>
#include <cominit.h>
#include <str_res.h>
#include <wbemutil.h>
#include <fastall.h>
#include <genlex.h>
#include <qllex.h>
#include <ql.h>
#include <lock.h>
#include <objpath.h>
#include <arena.h>
#include <reg.h>
#include <wstring.h>
#include <flexarry.h>
#include <flexq.h>
#include <arrtempl.h>

#include <sinks.h>
#include <winntsec.h>
#include <callsec.h>
#include <coreq.h>
#include <wbemq.h>
#include <event.h>
#include <safearry.h>
#include <var.h>
#include <strm.h>
#include <refrhelp.h>
#include <refrcach.h>
#include <dynasty.h>
#include <stdclass.h>
#include <objenum.h>
#include <svcq.h>
#include <cwbemtime.h>
#include <evtlog.h>
#include <decor.h>
#include <crep.h>
#include <wmiuser.h>
#include <wmitask.h>
#include <cfgmgr.h>
#include "wqlnode.h"
#include "wqlscan.h"
#include <protoq.h>
#include <assocqp.h>
#include <assocqe.h>
#include <qengine.h>
#include <callres.h>
#include <coreapi.h>
#include <wbemname.h>
#include <login.h>
#include "secure.h"
#include "coresvc.h"
#include "sysclass.h"

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\sysclass2.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    sysclass.CPP

Abstract:

    System class generation function.

History:

--*/

#include "precomp.h"
#include "wbemcore.h"
#include <WbemUtil.h>
#include <FastAll.h>
#include <Sync.h>

#define NOT_NULL_FLAVOR \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS | \
        WBEM_FLAVOR_NOT_OVERRIDABLE

#define READ_FLAVOR \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS | \
        WBEM_FLAVOR_NOT_OVERRIDABLE

#define UNITS_FLAVOR \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS | \
        WBEM_FLAVOR_NOT_OVERRIDABLE

#define SINGLETON_FLAVOR \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS | \
        WBEM_FLAVOR_NOT_OVERRIDABLE

#define SYNTAX_FLAVOR \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS

#define ABSTRACT_FLAVOR 0 // no propagation

#define ASSOC_FLAVOR \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS | \
        WBEM_FLAVOR_NOT_OVERRIDABLE
#define NEW_CLASS_PRECREATE_SIZE 1000

qual SystemClassQuals[] = {{L"abstract", NULL, VT_BOOL, L"TRUE", ABSTRACT_FLAVOR}};
ObjectDef SystemClass = {L"__SystemClass", NULL, 0, NULL,1, SystemClassQuals,0,NULL};

prop NamespaceClassProps[] = {{L"Name", CIM_STRING, NULL}};
qual NamespaceClassQuals[] = {{L"KEY", L"Name", CIM_BOOLEAN, L"TRUE", 0}};
ObjectDef NamespaceClass = {L"__Namespace", &SystemClass, 1, NamespaceClassProps, 1, NamespaceClassQuals, 0, NULL};

prop ProviderClassProps[] = {{L"Name", CIM_STRING, NULL}};
qual ProviderClassQuals[] = {{L"KEY", L"Name", CIM_BOOLEAN, L"TRUE", 0},
							{L"abstract", NULL, VT_BOOL, L"TRUE", ABSTRACT_FLAVOR}};
ObjectDef ProviderClass = {L"__Provider", &SystemClass, 1, ProviderClassProps, 2, ProviderClassQuals, 0, NULL};

prop Win32ProviderClassProps[] = {{L"CLSID", CIM_STRING, NULL},
{L"ClientLoadableCLSID", CIM_STRING, NULL},
{L"DefaultMachineName", CIM_STRING, NULL},
{L"UnloadTimeout", CIM_DATETIME, NULL},
{L"InitializeAsAdminFirst", CIM_BOOLEAN, NULL},
{L"ImpersonationLevel", CIM_SINT32, L"0"},
{L"InitializationReentrancy", CIM_SINT32, L"0"},
{L"PerUserInitialization", CIM_BOOLEAN, L"false"},
{L"PerLocaleInitialization", CIM_BOOLEAN, L"false"},
{L"Pure", CIM_BOOLEAN, L"true"}};
qual Win32ProviderClassQuals[] = {{L"not_null", L"CLSID", CIM_BOOLEAN, L"TRUE", NOT_NULL_FLAVOR},
{L"SUBTYPE", L"UnloadTimeout", VT_BSTR, L"interval", SYNTAX_FLAVOR},
{L"Values", L"InitializationReentrancy", CIM_FLAG_ARRAY|VT_BSTR,L"clsid,Namespace,COM Object", WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS},
{L"Values", L"ImpersonationLevel", CIM_FLAG_ARRAY|VT_BSTR, L"None", WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS}};
ObjectDef Win32ProviderClass = {L"__Win32Provider", &ProviderClass, 10, Win32ProviderClassProps, 4, Win32ProviderClassQuals, 0, NULL};

prop ProviderRegistrationClassProps[] = {{L"Provider", CIM_REFERENCE, NULL}};
qual ProviderRegistrationClassQuals[] = {{L"cimtype", L"Provider", VT_BSTR, L"ref:__Provider", 0},
							{L"abstract", NULL, VT_BOOL, L"TRUE", ABSTRACT_FLAVOR}};
ObjectDef ProviderRegistrationClass = {L"__ProviderRegistration", &SystemClass, 1, ProviderRegistrationClassProps,
2, ProviderRegistrationClassQuals, 0, NULL};

prop ObjectProviderRegistrationClassProps[] = {
	{L"SupportsPut",  CIM_BOOLEAN, L"false"},
	{L"SupportsGet",  CIM_BOOLEAN, L"false"},
	{L"SupportsDelete",  CIM_BOOLEAN, L"false"},
	{L"SupportsEnumeration",  CIM_BOOLEAN, L"false"},
	{L"QuerySupportLevels",  CIM_STRING | CIM_FLAG_ARRAY, NULL},
	{L"InteractionType", CIM_SINT32, L"0"}};
qual ObjectProviderRegistrationClassQuals[] = {
	{L"abstract", NULL, VT_BOOL, L"TRUE", ABSTRACT_FLAVOR},
	{L"Values",L"InteractionType", CIM_FLAG_ARRAY|VT_BSTR,L"WQL:UnarySelect,WQL:V1ProviderDefined,WQL:Associators,WQL:References", WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS},
	{L"QuerySupportLevels", L"ValueMap", CIM_FLAG_ARRAY|VT_BSTR,L"Pull,Push,PushVerify", WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS}};

ObjectDef ObjectProviderRegistrationClass = { L"__ObjectProviderRegistration", &ProviderRegistrationClass, 
6, ObjectProviderRegistrationClassProps, 3, ObjectProviderRegistrationClassQuals, 0, NULL};

void SetVar(CVar & var, VARTYPE vtCimType, LPWSTR pValue)
{
	if(pValue == NULL)
	{
		var.SetAsNull();
	}
	else if(vtCimType == VT_BSTR)
	{
		if(!var.SetBSTR(pValue))
	        throw CX_MemoryException();
	}
	else if(vtCimType == CIM_STRING)
	{
		if(!var.SetLPWSTR(pValue))
	        throw CX_MemoryException();
	}
	else if(vtCimType == (CIM_STRING | CIM_FLAG_ARRAY) || vtCimType == (VT_BSTR | CIM_FLAG_ARRAY))
	{
		WCHAR * wTemp = new WCHAR[wcslen(pValue)+1];
		if(wTemp == NULL)
	        throw CX_MemoryException();
		CDeleteMe<WCHAR> dm(wTemp);

		CVarVector vec(VT_BSTR);
		wcscpy(wTemp, pValue);
		WCHAR * pToken = wcstok( wTemp, L",");
		while(pToken)
		{
			CVar vartok(VT_BSTR, pToken);
			vec.Add(vartok);
			pToken = wcstok(NULL, L",");
		}
		var.SetVarVector(&vec, FALSE);
	}
	else if(vtCimType == CIM_SINT32)
	{
		long l = _wtol(pValue);
		var.SetLong(l);
	}
	else if(vtCimType == CIM_BOOLEAN)
	{
		if(_wcsicmp(L"true", pValue) == 0)
			var.SetBool(VARIANT_TRUE);
		else
			var.SetBool(VARIANT_FALSE);
	}

}

void AddTheProps(CWbemObject * pObj, prop * pProps,int iNumProp)
{
	for(int i = 0; i < iNumProp; i++, pProps++)
	{
		CVar var;
		SetVar(var, pProps->vtCimType, pProps->pValue);
		HRESULT hr = pObj->SetPropValue(pProps->pName, &var, pProps->vtCimType);
		if(FAILED(hr))
	        throw CX_MemoryException();
	}
}

void AddTheQuals(CWbemObject * pObj, qual * pQuals, int iNumQual)
{
	for(int i = 0; i < iNumQual; i++, pQuals++)
	{
		CVar var;
		HRESULT hr;
		SetVar(var, pQuals->vtCimType, pQuals->pValue);
		if(pQuals->pPropName)
			hr = pObj->SetPropQualifier(pQuals->pPropName, pQuals->pName, 
							pQuals->dwFlavor, &var);
		else
			hr = pObj->SetQualifier(pQuals->pName, &var, pQuals->dwFlavor);
		if(FAILED(hr))
	        throw CX_MemoryException();
	}

}

void CreateNewClass(ObjectDef * pObjDef, CWbemClass ** pNewObj)
{
	HRESULT hr;
	CWbemClass * pNew = NULL;
	pNew = new CGenClass;
	if(pNew == NULL)
	    throw CX_MemoryException();
	if(pObjDef->pParent)
	{
		CWbemClass * pParent = NULL;
		CreateNewClass(pObjDef->pParent, &pParent);
//		hr = pParent->SpawnDerivedClass(0,(IWbemClassObject **)&pNew);
		hr = pNew->CreateDerivedClass(pParent);
		pParent->Release();
		if(FAILED(hr))
	        throw CX_MemoryException();
	}
	else
	{
		pNew->InitEmpty(NEW_CLASS_PRECREATE_SIZE);

	}
	*pNewObj = pNew;
	CVar v(VT_BSTR, pObjDef->pName);
	hr = pNew->SetPropValue(L"__Class", &v, 0);
	if(FAILED(hr))
	    throw CX_MemoryException();

	if(pObjDef->pProps)
		AddTheProps(pNew,pObjDef->pProps, pObjDef->iNumProps);
	if(pObjDef->pQuals)
		AddTheQuals(pNew,pObjDef->pQuals, pObjDef->iNumQuals);


	/////////////////test test test //////////////////////////

    BSTR bstrArgs = NULL;
    if(pNew)
        pNew->GetObjectText(0, &bstrArgs);
	SysFreeString(bstrArgs);

	/////////////////test test test //////////////////////////

	// todo, methods
}

void CreateAndAdd(ObjectDef * pObjDef, CFlexArray * pResults)
{
	CWbemClass * pNewObj = NULL;
	CreateNewClass(pObjDef, &pNewObj);

	/////////////////test test test //////////////////////////

    BSTR bstrArgs = NULL;
    if(pNewObj)
        pNewObj->GetObjectText(0, &bstrArgs);
    ERRORTRACE((LOG_WBEMCORE, "\n%S\n", bstrArgs));
	SysFreeString(bstrArgs);

	/////////////////test test test //////////////////////////



	if(CFlexArray::no_error != pResults->Add(pNewObj))
	{
		pNewObj->Release();
        throw CX_MemoryException();
	}
	return;
}

HRESULT GetSystemStdObjects(CFlexArray * pResults)
{
	HRESULT hr = S_OK;

	try
	{
		CreateAndAdd(&SystemClass, pResults);
		CreateAndAdd(&NamespaceClass, pResults);
		CreateAndAdd(&ProviderClass, pResults);
		CreateAndAdd(&Win32ProviderClass, pResults);
		CreateAndAdd(&ProviderRegistrationClass, pResults);
		CreateAndAdd(&ObjectProviderRegistrationClass, pResults);
	}
	catch(CX_MemoryException)
	{
		return WBEM_E_OUT_OF_MEMORY;

	}
	catch(...)
	{
        ExceptionCounter c;	
		return WBEM_E_FAILED;
	}
    // Create system classes
    // =====================

/*
    {
        CProviderClass * init = new CProviderClass;
        init->Init();
		if(CFlexArray::no_error != pResults->Add(init))
			return WBEM_E_OUT_OF_MEMORY;
    }
    {
        CWin32ProviderClass * init = new CWin32ProviderClass;
        init->Init();
		if(CFlexArray::no_error != pResults->Add(init))
			return WBEM_E_OUT_OF_MEMORY;
    } 
    {
        CProviderRegistrationClass * init = new CProviderRegistrationClass;
        init->Init();
		if(CFlexArray::no_error != pResults->Add(init))
			return WBEM_E_OUT_OF_MEMORY;
    }
    {
        CObjectProviderRegistrationClass *  init = new CObjectProviderRegistrationClass;
        init->Init();
		if(CFlexArray::no_error != pResults->Add(init))
			return WBEM_E_OUT_OF_MEMORY;
    }*/
    {
        CClassProviderRegistrationClass  * init = new CClassProviderRegistrationClass;
        init->Init();
		if(CFlexArray::no_error != pResults->Add(init))
			return WBEM_E_OUT_OF_MEMORY;
    }
    {
        CInstanceProviderRegistrationClass * init = new CInstanceProviderRegistrationClass;
        init->Init();
		if(CFlexArray::no_error != pResults->Add(init))
			return WBEM_E_OUT_OF_MEMORY;
    }
    {
        CPropertyProviderRegistrationClass * init = new CPropertyProviderRegistrationClass;
        init->Init();
		if(CFlexArray::no_error != pResults->Add(init))
			return WBEM_E_OUT_OF_MEMORY;
    }
    {
        CMethodProviderRegistrationClass * init = new CMethodProviderRegistrationClass;
        init->Init();
		if(CFlexArray::no_error != pResults->Add(init))
			return WBEM_E_OUT_OF_MEMORY;
    }
    {
        CEventProviderRegistrationClass *init = new CEventProviderRegistrationClass;
        init->Init();
		if(CFlexArray::no_error != pResults->Add(init))
			return WBEM_E_OUT_OF_MEMORY;
    }
    {
        CEventConsumerProviderRegistrationClass *  init = new CEventConsumerProviderRegistrationClass;
        init->Init();
		if(CFlexArray::no_error != pResults->Add(init))
			return WBEM_E_OUT_OF_MEMORY;
    }
    {
        CNotifyStatusClass  * init = new CNotifyStatusClass;
        init->Init();
		if(CFlexArray::no_error != pResults->Add(init))
			return WBEM_E_OUT_OF_MEMORY;
    }
    {
        CErrorObjectClass * init = new CErrorObjectClass;
        init->Init();
		if(CFlexArray::no_error != pResults->Add(init))
			return WBEM_E_OUT_OF_MEMORY;
    }
    {
        CCIMOMIdentificationClass * init = new CCIMOMIdentificationClass;
        init->Init();
		if(CFlexArray::no_error != pResults->Add(init))
			return WBEM_E_OUT_OF_MEMORY;
    }
    {
        CSecurityBaseClass * init = new CSecurityBaseClass;
        init->Init();
		if(CFlexArray::no_error != pResults->Add(init))
			return WBEM_E_OUT_OF_MEMORY;
    }
    {
        CNTLM9XUserClass * init = new CNTLM9XUserClass;
        init->Init();
		if(CFlexArray::no_error != pResults->Add(init))
			return WBEM_E_OUT_OF_MEMORY;
    }


    // Create event classes
    // ====================

    {
        CIndicationRelatedClass * IndicationRelated = new CIndicationRelatedClass;
        IndicationRelated->Init();
		if(CFlexArray::no_error != pResults->Add(IndicationRelated))
			return WBEM_E_OUT_OF_MEMORY;
    }

    {
        CEventClass * Event = new CEventClass;
        Event->Init();
		if(CFlexArray::no_error != pResults->Add(Event))
			return WBEM_E_OUT_OF_MEMORY;
    }

    {
        CParametersClass * Parameters = new CParametersClass;
        Parameters->Init();
		if(CFlexArray::no_error != pResults->Add(Parameters))
			return WBEM_E_OUT_OF_MEMORY;
    }

    {
        CEmptyEventClass * Event20 = new CEmptyEventClass;
        Event20->Init(L"__ExtrinsicEvent");
		if(CFlexArray::no_error != pResults->Add(Event20))
			return WBEM_E_OUT_OF_MEMORY;
    }

    {
        CGenericDataEventClass * NamespaceEvent = new CGenericDataEventClass;
        NamespaceEvent->Init(L"object:__Namespace", L"Namespace");
		if(CFlexArray::no_error != pResults->Add(NamespaceEvent))
			return WBEM_E_OUT_OF_MEMORY;

        CNamespaceEventClass * E1 = new CNamespaceEventClass;
        E1->Init(*NamespaceEvent, CDataEventClass::type_create);
		if(CFlexArray::no_error != pResults->Add(E1))
			return WBEM_E_OUT_OF_MEMORY;
        CNamespaceEventClass * E2 = new CNamespaceEventClass;
        E2->Init(*NamespaceEvent, CDataEventClass::type_delete);
		if(CFlexArray::no_error != pResults->Add(E2))
			return WBEM_E_OUT_OF_MEMORY;
        CNamespaceEventClass * E3 = new CNamespaceEventClass;
        E3->Init(*NamespaceEvent, CDataEventClass::type_change);
		if(CFlexArray::no_error != pResults->Add(E3))
			return WBEM_E_OUT_OF_MEMORY;
    }

    {
        CGenericDataEventClass * ClassEvent = new CGenericDataEventClass;
        ClassEvent->Init(L"object", L"Class");
		if(CFlexArray::no_error != pResults->Add(ClassEvent))
			return WBEM_E_OUT_OF_MEMORY;


        CClassEventClass * E4 = new CClassEventClass;
        E4->Init(*ClassEvent, CDataEventClass::type_create);
		if(CFlexArray::no_error != pResults->Add(E4))
			return WBEM_E_OUT_OF_MEMORY;

        CClassEventClass * E5 = new CClassEventClass;
        E5->Init(*ClassEvent, CDataEventClass::type_delete);
		if(CFlexArray::no_error != pResults->Add(E5))
			return WBEM_E_OUT_OF_MEMORY;

        CClassEventClass * E6 = new CClassEventClass;
        E6->Init(*ClassEvent, CDataEventClass::type_change);
		if(CFlexArray::no_error != pResults->Add(E6))
			return WBEM_E_OUT_OF_MEMORY;
    }

    {
        CGenericDataEventClass * InstanceEvent = new CGenericDataEventClass;
        InstanceEvent->Init(L"object", L"Instance");
		if(CFlexArray::no_error != pResults->Add(InstanceEvent))
			return WBEM_E_OUT_OF_MEMORY;

        CInstanceEventClass * E7 = new CInstanceEventClass;
        E7->Init(*InstanceEvent, CDataEventClass::type_create);
		if(CFlexArray::no_error != pResults->Add(E7))
			return WBEM_E_OUT_OF_MEMORY;
        CInstanceEventClass * E8 = new CInstanceEventClass;
        E8->Init(*InstanceEvent, CDataEventClass::type_delete);
		if(CFlexArray::no_error != pResults->Add(E8))
			return WBEM_E_OUT_OF_MEMORY;
        CInstanceEventClass * E9 = new CInstanceEventClass;
        E9->Init(*InstanceEvent, CDataEventClass::type_change);
		if(CFlexArray::no_error != pResults->Add(E9))
			return WBEM_E_OUT_OF_MEMORY;
    }


    {
        CTimerEventClass * Event14 = new CTimerEventClass;
        Event14->Init();
		if(CFlexArray::no_error != pResults->Add(Event14))
			return WBEM_E_OUT_OF_MEMORY;
    }

    {
        CAggregateEventClass * Event15 = new CAggregateEventClass;
        Event15->Init();
		if(CFlexArray::no_error != pResults->Add(Event15))
			return WBEM_E_OUT_OF_MEMORY;
    }

    // Create event consumer class
    // ===========================
    {
        CEventConsumerClass * Consumer = new CEventConsumerClass;
        Consumer->Init();
		if(CFlexArray::no_error != pResults->Add(Consumer))
			return WBEM_E_OUT_OF_MEMORY;
    }

    // Create event filter classes
    // ===========================
    {
        CEventFilterClass * Filter = new CEventFilterClass;
        Filter->Init();
		if(CFlexArray::no_error != pResults->Add(Filter))
			return WBEM_E_OUT_OF_MEMORY;
    }

    // Create the binding class
    // ========================
    {
        CFilterConsumerBindingClass * Binding = new CFilterConsumerBindingClass;
        Binding->Init();
		if(CFlexArray::no_error != pResults->Add(Binding))
			return WBEM_E_OUT_OF_MEMORY;
    }

    // Create timer generators
    // =======================
    {
        CEventGeneratorClass * Generator = new CEventGeneratorClass;
        Generator->Init();
		if(CFlexArray::no_error != pResults->Add(Generator))
			return WBEM_E_OUT_OF_MEMORY;
    }
    {
        CTimerInstructionClass * TI = new CTimerInstructionClass;
        TI->Init();
		if(CFlexArray::no_error != pResults->Add(TI))
			return WBEM_E_OUT_OF_MEMORY;
    }
    {
        CAbsoluteTimerInstructionClass * ATI = new CAbsoluteTimerInstructionClass;
        ATI->Init();
		if(CFlexArray::no_error != pResults->Add(ATI))
			return WBEM_E_OUT_OF_MEMORY;
    }
    {
        CIntervalTimerInstructionClass * ITI = new CIntervalTimerInstructionClass;
        ITI->Init();
		if(CFlexArray::no_error != pResults->Add(ITI))
			return WBEM_E_OUT_OF_MEMORY;
    }
    {
        CTimerNextFiringClass * TNF = new CTimerNextFiringClass;
        TNF->Init();
		if(CFlexArray::no_error != pResults->Add(TNF))
			return WBEM_E_OUT_OF_MEMORY;
    }

    // Create error event classes
    // ==========================

    {
        CSystemEventClass * Event16 = new CSystemEventClass;
        Event16->Init();
		if(CFlexArray::no_error != pResults->Add(Event16))
			return WBEM_E_OUT_OF_MEMORY;
    }

    {
        CEventDroppedEventClass * Event17 = new CEventDroppedEventClass;
        Event17->Init();
		if(CFlexArray::no_error != pResults->Add(Event17))
			return WBEM_E_OUT_OF_MEMORY;
    }

    {
        CQueueOverflowEventClass * Event18 = new CQueueOverflowEventClass;
        Event18->Init();
		if(CFlexArray::no_error != pResults->Add(Event18))
			return WBEM_E_OUT_OF_MEMORY;
    }

    {
        CConsumerFailureEventClass * Event19 = new CConsumerFailureEventClass;
        Event19->Init();
		if(CFlexArray::no_error != pResults->Add(Event19))
			return WBEM_E_OUT_OF_MEMORY;
    }

    // Add the security object which provides methods for getting/setting 
    // the security descriptor
/*  todo, todo, todo

    CSystemConfigClass ConfigClass;
    ConfigClass->Init(poThis);
	if(CFlexArray::no_error != pResults->Add(ConfigClass))
		return WBEM_E_OUT_OF_MEMORY;

    CSystemConfigInstance ConfigInstance;
    ConfigInstance->Init(&ConfigClass);
	if(CFlexArray::no_error != pResults->Add(ConfigInstance))
		return WBEM_E_OUT_OF_MEMORY;
*/    
    return 0;
}

HRESULT GetSystemSecurityObjects(CFlexArray * pResults)
{
	
	HRESULT hr = S_OK;
    CSubjectClass * Subject = new CSubjectClass;
	/*hr = */Subject->Init();
//	if(FAILED(hr))
//		return hr;
	if(CFlexArray::no_error != pResults->Add(Subject))
		return WBEM_E_OUT_OF_MEMORY;

    CUserClass * User = new CUserClass;
	/*hr = */User->Init();
//	if(FAILED(hr))
//		return hr;
	if(CFlexArray::no_error != pResults->Add(User))
		return WBEM_E_OUT_OF_MEMORY;

    CNTLMUserClass * NTLMUser = new CNTLMUserClass;
	/*hr = */NTLMUser->Init();
//	if(FAILED(hr))
//		return hr;
	if(CFlexArray::no_error != pResults->Add(NTLMUser))
		return WBEM_E_OUT_OF_MEMORY;

    CGroupClass * Group = new CGroupClass;
	/*hr = */Group->Init();
//	if(FAILED(hr))
//		return hr;
	if(CFlexArray::no_error != pResults->Add(Group))
		return WBEM_E_OUT_OF_MEMORY;

    CNtlmGroupClass * NtlmGroup = new CNtlmGroupClass;
	/*hr = */NtlmGroup->Init();
//	if(FAILED(hr))
//		return hr;
	if(CFlexArray::no_error != pResults->Add(NtlmGroup))
		return WBEM_E_OUT_OF_MEMORY;

	return S_OK;
}

HRESULT CreateCacheControl2(CFlexArray * pResults, LPCWSTR wszClassName, DWORD dwSeconds)
{
    CSpecificCacheControlClass * ControlClass = new CSpecificCacheControlClass;
    ControlClass->Init(wszClassName);
	if(CFlexArray::no_error != pResults->Add(ControlClass))
		return WBEM_E_OUT_OF_MEMORY;

    CCacheControlInstance * ControlInstance = new CCacheControlInstance;
    ControlInstance->Init(ControlClass, dwSeconds);
	if(CFlexArray::no_error != pResults->Add(ControlInstance))
		return WBEM_E_OUT_OF_MEMORY;

    return 0;
}

HRESULT GetSystemRootObjects(CFlexArray * pResults)
{
    {
        CCacheControlClass * init = new CCacheControlClass;
        init->Init();
		if(CFlexArray::no_error != pResults->Add(init))
			return WBEM_E_OUT_OF_MEMORY;
    }

	//todo, check retur codes here

    CreateCacheControl2(pResults, L"__ObjectProviderCacheControl", 120);
    CreateCacheControl2(pResults, L"__PropertyProviderCacheControl", 120);
    CreateCacheControl2(pResults, L"__EventProviderCacheControl", 10);
    CreateCacheControl2(pResults, L"__EventConsumerProviderCacheControl", 10);
    CreateCacheControl2(pResults, L"__EventSinkCacheControl", 10);

    {
        CActiveNamespacesClass * init = new CActiveNamespacesClass;
        init->Init();
		if(CFlexArray::no_error != pResults->Add(init))
			return WBEM_E_OUT_OF_MEMORY;
    }
    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\wbemname.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMNAME.H

Abstract:

    Implements the COM layer of WINMGMT --- the class representing a namespace.
    It is defined in wbemname.h

History:

    23-Jul-96   raymcc    Created.
    3/10/97     levn      Fully documented (ha ha)
    22-Feb-00   raymcc    Whistler revisions/extensions

--*/

#ifndef _WBEM_NAME_H_
#define _WBEM_NAME_H_

#define WBEM_FLAG_NO_STATIC 0x80000000
#define WBEM_FLAG_ONLY_STATIC 0x40000000

class CFlexAceArray;

struct SAssocTriad
{
    IWbemClassObject *m_pEp1;
    IWbemClassObject *m_pEp2;
    IWbemClassObject *m_pAssoc;

    SAssocTriad() { m_pEp1 = 0; m_pEp2 = 0; m_pAssoc = 0; }
   ~SAssocTriad() {  ReleaseIfNotNULL(m_pEp1); ReleaseIfNotNULL(m_pEp2); ReleaseIfNotNULL(m_pAssoc); }

    static void ArrayCleanup(CFlexArray &Array)
    {
        for (int i = 0; i < Array.Size(); i++)
            delete (SAssocTriad *) Array[i];
        Array.Empty();
    }
};

//******************************************************************************
//******************************************************************************
//
//  class CWbemNamespace
//
//  This class represents the COM layer of WINMGMT --- what the client sees. An
//  instance of this class is created whenever a namespace is opened by a client
//  (at the moment, we don't cache namespace pointers, so if a client opens the
//  same namespace twice, we will create to of these).
//
//******************************************************************************
//
//  Constructor
//
//  Enumerates all the class providers in this namespace (instances of
//  __Win32Provider with the method mask indicating a class provider), loads
//  them all and initializes them by calling ConnectServer.
//
//******************************************************************************
//*************************** interface IWbemServices **************************
//
//  See help for documentation of the IWbemServices interface.
//
//******************************************************************************
//************************** helper functions **********************************
//
//  Are documented in the wbemname.cpp file.
//
//******************************************************************************

class CWbemNamespace :
    public IWbemServicesEx,
    public IWbemInternalServices,
    public IWbemShutdown,
    public IWbemUnloadingControl
{
public:
    enum ERestriction
    {
        e_NoRestriction = 0,
        e_RestrictionDisabled,
        e_RestrictionNoClassProv,
        e_RestrictionStaticOnly
    };

    enum EIFaceType
    {
        eNull = 0,
        eNamespace = 1,
        eScope = 2,
        eCollection = 3
    };

protected:
    friend class CQueryEngine;

    DWORD m_dwIfaceType;
    BOOL m_bShutDown;
    // Collection-related
    IWbemClassObject *m_pCollectionClass;
    IWbemClassObject *m_pCollectionEp;
    LPWSTR m_pszCollectionEpPath;
    long m_lEpRefPropHandle;
    long m_lTargetRefPropHandle;

    //
    DWORD Status;
    ULONG m_uSecondaryRefCount;
    ULONG m_uPrimaryRefCount;       // owned by the arbitrator
    LONG m_lConfigFlags;

    IWmiDbSession *m_pSession;
    IWmiDbController *m_pDriver;
    IWmiDbHandle *m_pNsHandle;
    IWmiDbHandle *m_pScopeHandle;
    _IWmiArbitrator *m_pArb;
    BOOL          m_bSubscope;

    LPWSTR m_pThisNamespace;

    DWORD m_dwPermission;
    DWORD m_dwSecurityFlags;
    LPWSTR m_wszUserName;
    ERestriction m_eRestriction;
    BOOL m_bProvider;
    BOOL m_bESS;
    BOOL m_bForClient;
    ULONG m_uClientMask;
    CRITICAL_SECTION m_cs;
    WString m_wsLocale;
    CNtSecurityDescriptor m_sd;
    CNtSecurityDescriptor m_sdCheckAdmin;
    BOOL m_bSecurityInitialized;
    BOOL m_bNT;

    DWORD m_dwTransactionState;
    GUID *m_pTransGuid;

    _IWmiProviderFactory    *m_pProvFact;
    _IWmiCoreServices       *m_pCoreSvc;

    BOOL                     m_bRepositOnly;
    IUnknown                *m_pRefreshingSvc;
    IUnknown                *m_pWbemComBinding;
    LPWSTR                   m_pszClientMachineName;
    DWORD                    m_dwClientProcessID;

    // No access
    CWbemNamespace();
   ~CWbemNamespace();


    // Async impl entry points

        virtual HRESULT STDMETHODCALLTYPE _GetObjectAsync(
            IN ULONG uInternalFlags,
            IN _IWmiFinalizer *p,
            IN _IWmiCoreHandle *phTask,
            IN const BSTR strObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler
            );

        virtual HRESULT STDMETHODCALLTYPE _PutClassAsync(
            IN ULONG uInternalFlags,
            IN _IWmiFinalizer *p,
            IN _IWmiCoreHandle *phTask,
            IN IWbemClassObject __RPC_FAR *pObject,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE _DeleteClassAsync(
            IN ULONG uInternalFlags,
            IN _IWmiFinalizer *p,
            IN _IWmiCoreHandle *phTask,
            IN const BSTR strClass,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE _CreateClassEnumAsync(
            IN ULONG uInternalFlags,
            IN _IWmiFinalizer *p,
            IN _IWmiCoreHandle *phTask,
            IN const BSTR strSuperclass,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE _PutInstanceAsync(
            IN ULONG uInternalFlags,
            IN _IWmiFinalizer *p,
            IN _IWmiCoreHandle *phTask,
            IN IWbemClassObject __RPC_FAR *pInst,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE _DeleteInstanceAsync(
            IN ULONG uInternalFlags,
            IN _IWmiFinalizer *p,
            IN _IWmiCoreHandle *phTask,
            IN const BSTR strObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE _CreateInstanceEnumAsync(
            IN ULONG uInternalFlags,
            IN _IWmiFinalizer *p,
            IN _IWmiCoreHandle *phTask,
            IN const BSTR strFilter,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE _ExecQueryAsync(
            IN ULONG uInternalFlags,
            IN _IWmiFinalizer *p,
            IN _IWmiCoreHandle *phTask,
            IN const BSTR strQueryLanguage,
            IN const BSTR strQuery,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE _ExecNotificationQueryAsync(
            IN ULONG uInternalFlags,
            IN _IWmiFinalizer *p,
            IN _IWmiCoreHandle *phTask,
            IN const BSTR strQueryLanguage,
            IN const BSTR strQuery,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE _ExecMethodAsync(
            IN ULONG uInternalFlags,
            IN _IWmiFinalizer *p,
            IN _IWmiCoreHandle *phTask,
            IN const BSTR strObjectPath,
            IN const BSTR strMethodName,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemClassObject __RPC_FAR *pInParams,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE _OpenAsync(
            IN ULONG uInternalFlags,
            IN _IWmiFinalizer *p,
            IN _IWmiCoreHandle *phTask,
            IN const BSTR strScope,
            IN const BSTR strParam,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSinkEx __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE _AddAsync(
            IN ULONG uInternalFlags,
            IN _IWmiFinalizer *p,
            IN _IWmiCoreHandle *phTask,
            IN const BSTR strObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE _RemoveAsync(
            IN ULONG uInternalFlags,
            IN _IWmiFinalizer *p,
            IN _IWmiCoreHandle *phTask,
            IN const BSTR strObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE _RefreshObjectAsync(
            IN ULONG uInternalFlags,
            IN _IWmiFinalizer *p,
            IN _IWmiCoreHandle *phTask,
            IN OUT IWbemClassObject __RPC_FAR *__RPC_FAR *pTarget,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSinkEx __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE _RenameObjectAsync(
            IN ULONG uInternalFlags,
            IN _IWmiFinalizer *p,
            IN _IWmiCoreHandle *phTask,
            IN const BSTR strOldObjectPath,
            IN const BSTR strNewObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

    HRESULT CreateNamespace(CWbemInstance *pNewInst);

public:
    /* IUnknown methods */
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    // Real entry points


    // IWbemServices

        virtual HRESULT STDMETHODCALLTYPE OpenNamespace(
            IN const BSTR strNamespace,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult);

        virtual HRESULT STDMETHODCALLTYPE CancelAsyncCall(
            IN IWbemObjectSink __RPC_FAR *pSink);

        virtual HRESULT STDMETHODCALLTYPE QueryObjectSink(
            IN long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE GetObject(
            IN const BSTR strObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

        virtual HRESULT STDMETHODCALLTYPE GetObjectAsync(
            IN const BSTR strObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE PutClass(
            IN IWbemClassObject __RPC_FAR *pObject,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

        virtual HRESULT STDMETHODCALLTYPE PutClassAsync(
            IN IWbemClassObject __RPC_FAR *pObject,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE DeleteClass(
            IN const BSTR strClass,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

        virtual HRESULT STDMETHODCALLTYPE DeleteClassAsync(
            IN const BSTR strClass,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE CreateClassEnum(
            IN const BSTR strSuperclass,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);

        virtual HRESULT STDMETHODCALLTYPE CreateClassEnumAsync(
            IN const BSTR strSuperclass,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE PutInstance(
            IN IWbemClassObject __RPC_FAR *pInst,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

        virtual HRESULT STDMETHODCALLTYPE PutInstanceAsync(
            IN IWbemClassObject __RPC_FAR *pInst,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE DeleteInstance(
            IN const BSTR strObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

        virtual HRESULT STDMETHODCALLTYPE DeleteInstanceAsync(
            IN const BSTR strObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum(
            IN const BSTR strFilter,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);

        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync(
            IN const BSTR strFilter,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE ExecQuery(
            IN const BSTR strQueryLanguage,
            IN const BSTR strQuery,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);

        virtual HRESULT STDMETHODCALLTYPE ExecQueryAsync(
            IN const BSTR strQueryLanguage,
            IN const BSTR strQuery,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQuery(
            IN const BSTR strQueryLanguage,
            IN const BSTR strQuery,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);

        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync(
            IN const BSTR strQueryLanguage,
            IN const BSTR strQuery,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE ExecMethod(
            IN const BSTR strObjectPath,
            IN const BSTR strMethodName,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

        virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync(
            IN const BSTR strObjectPath,
            IN const BSTR strMethodName,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemClassObject __RPC_FAR *pInParams,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);



    // IWbemServicesEx


        virtual HRESULT STDMETHODCALLTYPE Open(
            IN const BSTR strScope,
            IN const BSTR strParam,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServicesEx __RPC_FAR *__RPC_FAR *ppScope,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppResult);

        virtual HRESULT STDMETHODCALLTYPE OpenAsync(
            IN const BSTR strScope,
            IN const BSTR strParam,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSinkEx __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE Add(
            IN const BSTR strObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult);

        virtual HRESULT STDMETHODCALLTYPE AddAsync(
            IN const BSTR strObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE Remove(
            IN const BSTR strObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult);

        virtual HRESULT STDMETHODCALLTYPE RemoveAsync(
            IN const BSTR strObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE RefreshObject(
            /* [out][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pTarget,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult);

        virtual HRESULT STDMETHODCALLTYPE RefreshObjectAsync(
            /* [out][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pTarget,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSinkEx __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE RenameObject(
            IN const BSTR strOldObjectPath,
            IN const BSTR strNewObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult);

        virtual HRESULT STDMETHODCALLTYPE RenameObjectAsync(
            IN const BSTR strOldObjectPath,
            IN const BSTR strNewObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE DeleteObject(
            IN const BSTR strObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

        virtual HRESULT STDMETHODCALLTYPE DeleteObjectAsync(
            IN const BSTR strObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);


        virtual HRESULT STDMETHODCALLTYPE PutObject(
            IN IWbemClassObject __RPC_FAR *pObj,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

        virtual HRESULT STDMETHODCALLTYPE PutObjectAsync(
            IN IWbemClassObject __RPC_FAR *pObj,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

    // IWbemInternalServices

    STDMETHOD(FindKeyRoot)(LPCWSTR wszClassName,
                                IWbemClassObject** ppKeyRootClass);
    STDMETHOD(InternalGetClass)(
             LPCWSTR wszClassName,
             IWbemClassObject** ppClass);

    STDMETHOD(InternalGetInstance)(
             LPCWSTR wszPath,
             IWbemClassObject** ppInstance);

    STDMETHOD(InternalExecQuery)(
             LPCWSTR wszQueryLanguage,
             LPCWSTR wszQuery,
             long lFlags,
             IWbemObjectSink* pSink);

    STDMETHOD(InternalCreateInstanceEnum)(
             LPCWSTR wszClassName,
             long lFlags,
             IWbemObjectSink* pSink);

    STDMETHOD(GetDbInstance)(
             LPCWSTR wszDbKey,
             IWbemClassObject** ppInstance);

    STDMETHOD(GetDbReferences)(
             IWbemClassObject* pEndpoint,
             IWbemObjectSink* pSink);

    STDMETHOD(InternalPutInstance)(
             IWbemClassObject* pInst);


    // IWbemShutdown


        virtual HRESULT STDMETHODCALLTYPE Shutdown(
            IN LONG uReason,
            IN ULONG uMaxMilliseconds,
            IN IWbemContext __RPC_FAR *pCtx);


    /* IWbemUnloadingControl methods */

    STDMETHOD(SetMustPreventUnloading)(boolean bPrevent);


    // Other

    STDMETHOD(GetNormalizedPath)( BSTR pstrPath, BSTR* pstrStandardPath );


    static CWbemNamespace* CreateInstance();

    HRESULT Initialize(
        LPWSTR pName,
        LPWSTR wszUserName,
        DWORD dwSecFlags,
        DWORD dwPermission,
        BOOL  bForClient,
        BOOL  bRepositOnly,
        LPCWSTR pszClientMachineName,
        DWORD dwClientProcessID,
        BOOL  bSkipSDInitialize,
        IWmiDbSession *pParentSession
        );

    int __cdecl taskprintf(const char *fmt, ...);

public:

    IWmiDbHandle  *GetNsHandle() { return m_pNsHandle; }
    IWmiDbSession *GetNsSession() { return m_pSession; }
    IWmiDbHandle  *GetScope() { return m_pScopeHandle; }
    BOOL IsSubscope() { return m_bSubscope; }

    INTERNAL LPWSTR GetName() {return m_pThisNamespace;}

    DWORD& GetStatus() {return Status;}
    LONG GetConfigurationFlags();
    INTERNAL LPWSTR GetUserName() {return m_wszUserName;}
    INTERNAL void SetUserName(LPWSTR wName);
    DWORD GetSecurityFlags() {return m_dwSecurityFlags;}
    bool Allowed(DWORD dwRequired);
    void SetRestriction(ERestriction eRestriction)
        {m_eRestriction = eRestriction;}
    
    void SetIsProvider(BOOL bProvider)
        {m_bProvider = bProvider;}

    void SetIsESS ( BOOL bESS )
        { m_bESS = bESS; }

    BOOL GetIsESS ( ) { return m_bESS; }
	BOOL GetIsProvider ( ) { return m_bProvider ; }
    
//    void MapSink(IWbemObjectSink* pSink, CWrapperSink* pWrapper);
//    void UnmapSink(IWbemObjectSink* pSink, CWrapperSink* pWrapper);
//    CWrapperSink* FindWrapper(IWbemObjectSink* pSink);

    void SetLocale(LPCWSTR wszLocale) {m_wsLocale = wszLocale;}
    LPCWSTR GetLocale() {return m_wsLocale;}
    LPWSTR GetClientMachine(){return m_pszClientMachineName;};
    DWORD GetClientProcID(){return m_dwClientProcessID;};

    HRESULT AdjustPutContext(IWbemContext *pCtx);
    HRESULT MergeGetKeysCtx(IN IWbemContext *pCtx);


    HRESULT SplitLocalized (CWbemObject *pOriginal, CWbemObject *pStoredObj = NULL);
    HRESULT FixAmendedQualifiers(IWbemQualifierSet *pOriginal, IWbemQualifierSet *pNew);

    // Worker functions for sync/async
    // ===============================

    HRESULT Exec_DeleteClass(LPWSTR wszClass, long lFlags,
        IWbemContext* pContext, CBasicObjectSink* pSink);
    HRESULT Exec_GetObjectByPath(READONLY LPWSTR wszObjectPath, long lFlags,
        IWbemContext* pContext, IWbemClassObject** ppObj,
        IWbemClassObject** ppErrorObj);
    HRESULT Exec_GetObject(READONLY LPWSTR wszObjectPath, long lFlags,
        IWbemContext* pContext, CBasicObjectSink* pSink);
    HRESULT Exec_DeleteInstance(LPWSTR wszObjectPath, long lFlags,
        IWbemContext* pContext, CBasicObjectSink* pSink);
    HRESULT Exec_PutClass(IWbemClassObject* pClass, long lFlags,
        IWbemContext* pContext, CBasicObjectSink* pSink, BOOL fIsInternal = FALSE);
    HRESULT Exec_PutInstance(IWbemClassObject* pInstance, long lFlags,
        IWbemContext* pContext, CBasicObjectSink* pSink);
    HRESULT Exec_CreateClassEnum(LPWSTR wszParent, long lFlags,
        IWbemContext* pContext, CBasicObjectSink* pSink);
    HRESULT Exec_CreateInstanceEnum(LPWSTR wszClass, long lFlags,
        IWbemContext* pContext, CBasicObjectSink* pSink);
    HRESULT Exec_ExecMethod(LPWSTR wszObjectPath, LPWSTR wszMethodName,
        long lFlags, IWbemClassObject *pInParams, IWbemContext *pCtx,
        CBasicObjectSink* pSink);
    static HRESULT Exec_CancelAsyncCall(IWbemObjectSink* pSink);
    static HRESULT Exec_CancelProvAsyncCall( IWbemServices* pProv, IWbemObjectSink* pSink );
    HRESULT GetImplementationClass(IWbemClassObject *pTestObj,
                                    LPWSTR wszMethodName, IWbemContext* pCtx,
                                    IWbemClassObject **pClassObj);
    HRESULT Exec_GetInstance(LPCWSTR wszObjectPath,
        IWbemPath* pParsedPath, long lFlags, IWbemContext* Context,
        CBasicObjectSink* pSink);

    HRESULT Exec_GetClass(LPCWSTR wszClassName,
        long lFlags, IWbemContext* Context, CBasicObjectSink* pSink);

    HRESULT Exec_Open(LPWSTR pszScope, LPWSTR pszParam,
        LONG lUserFlags, IWbemContext *pCtx, IWbemObjectSinkEx *pSink
        );

    HRESULT Exec_Rename(LPWSTR pszOld, LPWSTR pszNew, LONG lUserFlags, IWbemContext *pCtx, IWbemObjectSink *pSink);

    HRESULT Exec_Add(LPWSTR pszPath, LONG lUserFlags, IWbemContext *pCtx, IWbemObjectSink *pSink);
    HRESULT Exec_Remove(LPWSTR pszPath, LONG lUserFlags, IWbemContext *pCtx, IWbemObjectSink *pSink);
    HRESULT Exec_Refresh(IWbemClassObject *pObj, LONG lUserFlags, IWbemContext *pCtx, IWbemObjectSink *pSink);

    HRESULT SetErrorObj(IWbemClassObject* pErrorObj);
    HRESULT RecursivePutInstance(CWbemInstance* pInst,
            CWbemClass* pClassDef, long lFlags, IWbemContext* pContext,
            CBasicObjectSink* pSink, BOOL bLast);

    HRESULT RecursiveDeleteInstance(LPCWSTR wszObjectPath,
            CDynasty* pDynasty, long lFlags, IWbemContext* pContext,
            CBasicObjectSink* pSink);
    HRESULT DeleteSingleInstance(
        READONLY LPWSTR wszObjectPath, long lFlags, IWbemContext* pContext,
        CBasicObjectSink* pSink);

    HRESULT InternalPutStaticClass( IWbemClassObject* pClass );


    // Assoc-by-rule helpers
    // =====================

    HRESULT ManufactureAssocs(
        IN  IWbemClassObject *pAssocClass,
        IN  IWbemClassObject *pEp,          // Optional
        IN  IWbemContext *pCtx,
        IN  LPWSTR pszJoinQuery,
        OUT CFlexArray &aTriads
        );

    HRESULT BuildAssocTriads(
        IN  IWbemClassObject *pAssocClass,
        IN  IWbemClassObject *pClsDef1,
        IN  IWbemClassObject *pClsDef2,
        IN  LPWSTR pszJoinProp1,
        IN  LPWSTR pszJoinProp2,
        IN  LPWSTR pszAssocRef1,                        // Prop which points to EP1
        IN  LPWSTR pszAssocRef2,                        // Prop which points to EP2
        IN  CFlexArray &aEp1,
        IN  CFlexArray &aEp2,
        IN OUT CFlexArray &aTriads
        );

    HRESULT BuildRuleBasedPathToInst(
        IN IWbemClassObject *pEp,
        IN LPWSTR pszJoinProp1,
        IN IWbemClassObject *pEp2,
        IN LPWSTR pszJoinProp2,
        OUT WString &wsNewPath
        );

    HRESULT ExtractEpInfoFromQuery(
        IWbemQuery *pQuery,
        LPWSTR *pszClass1,
        LPWSTR *pszProp1,
        LPWSTR *pClass2,
        LPWSTR *pszProp2
        );

    HRESULT MapAssocRefsToClasses(
        IN  IWbemClassObject *pAssocClass,
        IN  IWbemClassObject *pClsDef1,
        IN  IWbemClassObject *pClsDef2,
        IN  LPWSTR *pszAssocRef1,
        OUT LPWSTR *pszAssocRef2
        );


    // Property provider access.
    // =========================

    typedef enum {GET, PUT} Operation;

    HRESULT GetOrPutDynProps (

        IWbemClassObject *pObj,
        Operation op,
        BOOL bIsDynamic = false
    );

    HRESULT Exec_DynAux_GetInstances (

        READONLY CWbemObject *pClassDef,
        long lFlags,
        IWbemContext* pCtx,
        CBasicObjectSink* pSink
    ) ;

    HRESULT DynAux_GetInstances (

        CWbemObject *pClassDef,
        long lFlags,
        IWbemContext* pContext,
        CBasicObjectSink* pSink,
        BOOL bComplexQuery
    ) ;

    HRESULT DynAux_GetInstance (

        LPWSTR pObjPath,
        long lFlags,
        IWbemContext* pContext,
        CBasicObjectSink* pSink
    );

    HRESULT DynAux_AskRecursively (

        CDynasty* pDynasty,
        long lFlags,
        LPWSTR wszObjectPath,
        IWbemContext* pContext,
        CBasicObjectSink* pSink
    );

    HRESULT DynAux_GetSingleInstance (

        CWbemClass* pClassDef,
        long lFlags,
        LPWSTR wszObjectPath,
        IWbemContext* pContext,
        CBasicObjectSink* pSink
    );

    HRESULT Exec_DynAux_ExecQueryAsync (

        CWbemObject* pClassDef,
        LPWSTR Query,
        LPWSTR QueryFormat,
        long lFlags,
        IWbemContext* pCtx,
        CBasicObjectSink* pSink
    ) ;

    HRESULT DynAux_ExecQueryAsync (

        CWbemObject* pClassDef,
        LPWSTR Query,
        LPWSTR QueryFormat,
        long lFlags,
        IWbemContext* pContext,
        CBasicObjectSink* pSink,
        BOOL bComplexQuery
    );

    HRESULT DynAux_ExecQueryExtendedAsync(

        LPWSTR wsProvider,
        LPWSTR Query,
        LPWSTR QueryFormat,
        long lFlags,
        IWbemContext* pCtx,
        CComplexProjectionSink* pSink
    ) ;

    HRESULT GetObjectByFullPath(
        READONLY LPWSTR wszObjectPath,
        IWbemPath * pOutput,
        long lFlags,
        IWbemContext* pContext,
        CBasicObjectSink* pSink
        );

    HRESULT DynAux_BuildClassHierarchy(IN LPWSTR wszClassName,
                                       IN LONG lFlags,
                                       IN IWbemContext* pContext,
                                       OUT CDynasty** ppDynasty,
                                       OUT IWbemClassObject** ppErrorObj);
    HRESULT DynAux_BuildChainUp(IN CDynasty* pOriginal,
                                        IN IWbemContext* pContext,
                                        OUT CDynasty** ppTop,
                                        OUT IWbemClassObject** ppErrorObj);

    HRESULT DecorateObject(IWbemClassObject* pObject);
    BOOL IsDerivableClass(LPCWSTR wszClassName, CWbemClass* pClass);

    static HRESULT IsPutRequiredForClass(CWbemClass* pClass,
                            CWbemInstance* pInst, IWbemContext* pContext,
                            BOOL bParentTakenCareOf);

    static HRESULT DoesNeedToBePut(LPCWSTR wszName, CWbemInstance* pInst,
            BOOL bRestrictedPut, BOOL bStrictNulls, BOOL bPropertyList,
            CWStringArray& awsProperties);

    static HRESULT GetContextPutExtensions(IWbemContext* pContext,
            BOOL& bRestrictedPut, BOOL& bStrictNulls, BOOL& bPropertyList,
            CWStringArray& awsProperties);

    static HRESULT GetContextBoolean(IWbemContext* pContext,
                LPCWSTR wszName, BOOL* pbValue);

    void Enter() {EnterCriticalSection(&m_cs);}
    void Leave() {LeaveCriticalSection(&m_cs);}
    HRESULT GetAceList(CFlexAceArray **);
    HRESULT PutAceList(CFlexAceArray *);
    HRESULT InitializeSD(IWmiDbSession *pSession);
    CNtSecurityDescriptor & GetSDRef(){return m_sd;};
    DWORD GetUserAccess();
    DWORD GetWin9XUserAccess();
    DWORD GetNTUserAccess();
    HRESULT EnsureSecurity();
    void SetPermissions(DWORD dwPerm){m_dwPermission = dwPerm;};
    HRESULT InitializeUserLists(CFlexAceArray & AllowList,CFlexAceArray & DenyList);
    HRESULT SecurityMethod(LPWSTR wszMethodName, long lFlags,
        IWbemClassObject *pInParams, IWbemContext *pCtx, IWbemObjectSink* pSink);
    HRESULT GetSDMethod(IWbemClassObject* pOutParams);
    HRESULT Get9XUserListMethod(IWbemClassObject* pOutParams);
    HRESULT RecursiveSDMerge();
    BOOL IsNamespaceSDProtected();
    HRESULT GetParentsInheritableAces(CNtSecurityDescriptor &sd);

    HRESULT SetSDMethod(IWbemClassObject* pInParams);
    HRESULT Set9XUserListMethod(IWbemClassObject* pInParams);
    HRESULT GetCallerAccessRightsMethod(IWbemClassObject* pOutParams);

    static void EmptyObjectList(CFlexArray &);

    // Helper function for refresher operations
    HRESULT CreateRefreshableObjectTemplate(
            LPCWSTR wszObjectPath, long lFlags,
            IWbemClassObject** ppInst );
    BOOL IsForClient(){return m_bForClient;};
    HRESULT PossibleDbUpgrade(CFlexAceArray * pNew);
    HRESULT EnumerateSecurityClassInstances(LPWSTR wszClassName,
                    IWbemObjectSink* pOwnSink, IWbemContext* pContext, long lFlags);
    HRESULT PutSecurityClassInstances(LPWSTR wszClassName,  IWbemClassObject * pClass,
                    IWbemObjectSink* pSink, IWbemContext* pContext, long lFlags);
    HRESULT DeleteSecurityClassInstances(ParsedObjectPath* pParsedPath,
                    IWbemObjectSink* pSink, IWbemContext* pContext, long lFlags);
    HRESULT GetSecurityClassInstances(ParsedObjectPath* pParsedPath, CBasicObjectSink* pSink,
                    IWbemContext* pContext,long lFlags);


    HRESULT CheckNs();

    HRESULT TestForVector(
        IN  IWbemClassObject *pVector,
        OUT BSTR* strVectorPath
        );

    HRESULT InitNewTask(
        IN CAsyncReq *pReq,
        IN _IWmiFinalizer *pFnz,
        IN ULONG uTaskType,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pAsyncClientSink
        );

    HRESULT CreateAsyncFinalizer(
        IN  IWbemContext *pContext,
        IN  IWbemObjectSink *pStartingSink,
        IN _IWmiFinalizer **pFnz,
        OUT IWbemObjectSinkEx **pResultSinkEx
        );

    HRESULT CreateSyncFinalizer(
        IN  IWbemContext *pContext,
        IN _IWmiFinalizer **pFnz
        );

    HRESULT ExecSyncQuery(
        IN  LPWSTR pszQuery,
        IN  IWbemContext *pCtx,
        IN  LONG lFlags,
        OUT CFlexArray &aDest
        );
	
	// Helper function to shell db queries out to different threads as appropriate
	HRESULT Static_QueryRepository(
		READONLY CWbemObject *pClassDef,
		long lFlags,
		IWbemContext* pCtx,
		CBasicObjectSink* pSink ,
		QL_LEVEL_1_RPN_EXPRESSION* pParsedQuery,
		LPCWSTR pwszClassName,
		CWmiMerger* pWmiMerger
		);

    // Two primary connect functions.
    // ==============================

    static HRESULT UniversalConnect(
        IN CWbemNamespace  *pParent,
        IN IWbemContext    *pCtx,
        IN LPCWSTR pszNewScope,
        IN LPCWSTR pszAssocSelector,
        IN LPCWSTR pszUserName,
        IN _IWmiCallSec    *pCallSec,
        IN _IWmiUserHandle *pUser,
        IN DWORD  dwUserFlags,
        IN DWORD  dwInternalFlags,
        IN DWORD  dwSecFlags,
        IN DWORD  dwPermission,
        IN BOOL   bForClient,
        IN BOOL   bRepositOnly,
        IN LPCWSTR pszClientMachineName,
        IN DWORD dwClientProcessID,
        IN  REFIID riid,
        OUT LPVOID *pConnection
        );

    static HRESULT PathBasedConnect(
            IN LPCWSTR pszPath,
            IN LPCWSTR pszUser,
            IN IWbemContext __RPC_FAR *pCtx,
            IN ULONG uClientFlags,
            IN DWORD dwSecFlags,
            IN DWORD dwPermissions,
            IN ULONG uInternalFlags,
            IN LPCWSTR pszClientMachineName,
            IN DWORD dwClientProcessID,
            IN REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pServices
            );
    ULONG AddRefPrimary();
    ULONG ReleasePrimary();
    void StopClientCalls(){m_bShutDown = TRUE;};
    HRESULT Dump(FILE *f);  // Debug only

    _IWmiCoreServices*  GetCoreServices( void ) { return m_pCoreSvc; }

	HRESULT GetDynamicReferenceClasses( long lFlags, IWbemContext* pCtx, IWbemObjectSink* pSink );
};




class COperationError
{
    bool                m_fOk;
    COperationErrorSink* m_pSink;
public:
    COperationError(CBasicObjectSink* pDest, LPCWSTR wszOperation,
                        LPCWSTR wszParam, BOOL bFinal = TRUE);
    ~COperationError();
    HRESULT ErrorOccurred(HRESULT hres, IWbemClassObject* pErrorObj = NULL);
    HRESULT ProviderReturned(LPCWSTR wszProviderName, HRESULT hres,
                                IWbemClassObject* pErrorObj = NULL);
    void SetParameterInfo(LPCWSTR wszParam);
    void SetProviderName(LPCWSTR wszName);
    INTERNAL CBasicObjectSink* GetSink() {return m_pSink;}

    bool IsOk( void ) { return m_fOk; }
};



class CFinalizingSink : public CForwardingSink
{
protected:
    CWbemNamespace* m_pNamespace;
public:
    CFinalizingSink(CWbemNamespace* pNamespace, CBasicObjectSink* pDest);
    virtual ~CFinalizingSink();

    STDMETHOD(Indicate)(long, IWbemClassObject**);
    virtual IWbemObjectSink* GetIndicateSink() {return this;}

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\wbemq.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMQ.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcore.h>
#include <genutils.h>


CWbemRequest::CWbemRequest(IWbemContext* pContext, BOOL bInternallyIssued)
{
    try
    {
	    m_pContext = NULL;
	    m_pCA = NULL;
	    m_pCallSec = NULL;
	    m_ulForceRun = 0;

	    if(pContext == NULL)
	    {
	        // See if we can discern the context from the thread
	        // =================================================

	        CWbemRequest* pPrev = CWbemQueue::GetCurrentRequest();
	        if(pPrev)
	        {
	            pContext = pPrev->m_pContext;
	            DEBUGTRACE((LOG_WBEMCORE, "Derived context %p from thread. "
	                "Request was %p\n", pContext, pPrev));
	        }
	    }

	    if(pContext)
	    {
	        // Create a derived context
	        // ========================

	        IWbemCausalityAccess* pParentCA;
	        pContext->QueryInterface(IID_IWbemCausalityAccess, (void**)&pParentCA);

	        if (SUCCEEDED(pParentCA->CreateChild(&m_pCA)))
	        {
	            m_pCA->QueryInterface(IID_IWbemContext, (void**)&m_pContext);
	        }
	        pParentCA->Release();
	    }
	    else
	    {

	        // Create a fresh context
	        // ======================

	        m_pContext = ConfigMgr::GetNewContext();
	        if (m_pContext)
	           m_pContext->QueryInterface(IID_IWbemCausalityAccess, (void**)&m_pCA);
	        m_lPriority = 0;
	    }


	    // Clone the call context.
	    // =======================

	    m_pCallSec = CWbemCallSecurity::CreateInst();
	    if (m_pCallSec == 0)
	        return;

	    if(IsNT())
	    {
	        IServerSecurity *pSec = 0;

	        HRESULT hRes = m_pCallSec->CloneThreadContext(bInternallyIssued);
	        if(FAILED(hRes))
	        {
	            m_pCallSec->Release();
	            m_pCallSec = NULL;
	        }
	    }

    }   // end try
    catch(...) 
    {
        ExceptionCounter c;    
        ERRORTRACE((LOG_WBEMCORE, "CWbemRequest() constructor exception\n"));
        m_fOk = false;
    }
}


CWbemRequest::~CWbemRequest()
{
    try
    {
	    if (m_pContext)
	        m_pContext->Release();
	    if(m_pCA)
	        m_pCA->Release();
	    if (m_pCallSec)
	        m_pCallSec->Release();
    }
    catch(...) 
    {
        ExceptionCounter c;    
        ERRORTRACE((LOG_WBEMCORE, "CWbemRequest() destructor exception\n"));
    }
}

BOOL CWbemRequest::IsChildOf(CWbemRequest* pOther)
{
    try
    {
	    GUID guid;
	    pOther->m_pCA->GetRequestId(&guid);
	    return (m_pCA->IsChildOf(guid) == S_OK);
    }
    catch(...) 
    {
        ExceptionCounter c;    
        ERRORTRACE((LOG_WBEMCORE, "CWbemRequest::IsChildOf() exception\n"));
        return FALSE;
    }
}

BOOL CWbemRequest::IsSpecial()
{
    return (m_pCA->IsSpecial() == S_OK);
}

// Returns TRUE iff this request has otherts that depend on it.
BOOL CWbemRequest::IsDependee()
{
    try
    {
	    if(m_pCA == NULL)
	        return FALSE;

	    // Check if the context has any "parents".  Note: this test has
	    // false-positives if the client uses a context object.
	    // ============================================================

	    long lNumParents, lNumSiblings;
	    m_pCA->GetHistoryInfo(&lNumParents, &lNumSiblings);
	    return (lNumParents > 0);
    }
    catch(...) 
    {
        ExceptionCounter c;    
        ERRORTRACE((LOG_WBEMCORE, "CWbemQueue::IsDependee() exception\n"));
        return FALSE;
    }
}

// Returns TRUE iff this request has otherts that depend on it.
BOOL CWbemRequest::IsIssuedByProvider()
{
    try
    {

	    if (m_pCA == NULL)
	        return FALSE;

	    // Check if the context has any "parents".  Note: this test has
	    // false-positives if the client uses a context object.
	    // ============================================================

	    long lNumParents, lNumSiblings;
	    m_pCA->GetHistoryInfo(&lNumParents, &lNumSiblings);
	    return (lNumParents > 1);

    } // end try
    catch(...) // To protect svchost.exe; we know this isn't a good recovery for WMI
    {
        ExceptionCounter c;    
        ERRORTRACE((LOG_WBEMCORE, "CWbemQueue::IsIssuedByProvider() exception\n"));
        return FALSE;
    }
}

BOOL CWbemRequest::IsAcceptableByParent()
{
    return (!IsLongRunning() || !IsIssuedByProvider());
}

// Returns TRUE iff this request must have a thread created for it if one is
// not available
BOOL CWbemRequest::IsCritical()
{
    return (IsDependee() && !IsAcceptableByParent());
}


BOOL CWbemRequest::IsChildOf(IWbemContext* pOther)
{
    try
    {

    IWbemCausalityAccess* pOtherCA;
    pOther->QueryInterface(IID_IWbemCausalityAccess, (void**)&pOtherCA);

    GUID guid;
    pOtherCA->GetRequestId(&guid);
    pOtherCA->Release();

    return (m_pCA->IsChildOf(guid) == S_OK);

    } // end try

    catch(...) 
    {
        ExceptionCounter c;    
        ERRORTRACE((LOG_WBEMCORE, "CWbemQueue::IsChildOf() exception\n"));
        return FALSE;
    }

}

void CWbemRequest::GetHistoryInfo(long* plNumParents, long* plNumSiblings)
{
    m_pCA->GetHistoryInfo(plNumParents, plNumSiblings);
}



CWbemQueue::CWbemQueue()
{
    SetRequestLimits(2000, 1500, 1950);
    SetRequestPenalties(1, 1, 1);
    // thread limits are left to derived classes
}

BOOL CWbemQueue::IsSuitableThread(CThreadRecord* pRecord, CCoreExecReq* pReq)
{
    try
    {
	    CWbemRequest* pParentWbemReq = (CWbemRequest*)pRecord->m_pCurrentRequest;
	    if(pParentWbemReq == NULL)
	    {
	        return TRUE;
	    }

	    CWbemRequest* pNewWbemReq = (CWbemRequest*)pReq;
	    if(pNewWbemReq->IsChildOf(pParentWbemReq))
	    {
	        // This request is a child of the one this thread is processing.
	        // We could use this thread, unless this is a long-running request and
	        // this thread might be the one consuming the results.  In that case,
	        // we want to create another thread (to avoid the possibility of a
	        // deadlock) and let this one continue.
	        // ===================================================================

	        return pNewWbemReq->IsAcceptableByParent();
	    }
	    else
	    {
	        return FALSE;
	    }
    }
    catch(...)
    {
        ExceptionCounter c;    
        return FALSE;
    }
}

CWbemRequest* CWbemQueue::GetCurrentRequest()
{
    try
    {
	    CThreadRecord* pRecord = (CThreadRecord*)TlsGetValue(GetTlsIndex());
	    if(pRecord)
	    {
	        if(!wcsncmp(pRecord->m_pQueue->GetType(), L"WBEMQ", 5))
	        {
	            return (CWbemRequest*)pRecord->m_pCurrentRequest;
	        }
	    }
	    return NULL;
    }
    catch(...)
    {
        ExceptionCounter c;    
        return NULL;
    }
}

void CWbemQueue::AdjustInitialPriority(CCoreExecReq* pReq)
{
    CWbemRequest* pRequest = (CWbemRequest*) pReq;

    if(pRequest->IsSpecial() || pRequest->IsCritical())
    {
        pRequest->SetPriority(0x80000000);
    }
    else
    {
        // Get information from the context
        // ================================

        long lNumParents, lNumSiblings;
        pRequest->GetHistoryInfo(&lNumParents, &lNumSiblings);
        pRequest->SetPriority(lNumParents * m_lChildPenalty +
                                lNumSiblings * m_lSiblingPenalty);
    }
}

void CWbemQueue::AdjustPriorityForPassing(CCoreExecReq* pReq)
{
    pReq->SetPriority(pReq->GetPriority() - m_lPassingPenalty);
}

void CWbemQueue::SetRequestPenalties(long lChildPenalty, long lSiblingPenalty,
                                        long lPassingPenalty)
{
    m_lChildPenalty = lChildPenalty;
    m_lSiblingPenalty = lSiblingPenalty;
    m_lPassingPenalty = lPassingPenalty;
}


BOOL CWbemQueue::Execute(CThreadRecord* pRecord)
{
    try
    {
	    CWbemRequest* pReq = (CWbemRequest *) pRecord->m_pCurrentRequest;

	    IWbemCallSecurity*  pServerSec = pReq->GetCallSecurity();

	    if(pServerSec == NULL)
	    {
	        // An error occurred retrieving security for this request
	        // ======================================================

	        ERRORTRACE((LOG_WBEMCORE, "Failing request due to an error retrieving "
	            "security settings\n"));

	        pReq->TerminateRequest(WBEM_E_FAILED);
	        HANDLE hWhenDone = pReq->GetWhenDoneHandle();
	        if(hWhenDone != NULL)
	        {
	            SetEvent(hWhenDone);
	        }
	        delete pReq;
	        pRecord->m_pCurrentRequest = NULL;
	        return FALSE;
	    }
	    else
	    {
	        pServerSec->AddRef();
	    }

	    // Release this guy when done
	    CReleaseMe  rmss( pServerSec );

	    IUnknown *pOld = 0, *pNew = 0;

	    // CoSwitchCallContext
	    // ===================
	    WbemCoSwitchCallContext( pServerSec,  &pOld );

	    // Save the old impersonation level
	    // ================================

	    BOOL bImpersonating = FALSE;
	    IServerSecurity* pOldSec = NULL;
	    if(pOld)
	    {
	        if(SUCCEEDED(pOld->QueryInterface(IID_IServerSecurity,
	                                            (void**)&pOldSec)))
	        {
	            bImpersonating = pOldSec->IsImpersonating();
	            pOldSec->RevertToSelf();
	        }
	    }

	    // Base Execute
	    // ============
	    BOOL bRes = CCoreQueue::Execute(pRecord);

	    // CoSwitchCallContext
	    // ===================
	    WbemCoSwitchCallContext(pOld, &pNew);

	    // Restore the old impersonation level
	    // ===================================

	    if(pOldSec)
	    {
	        if(bImpersonating)
			{
				HRESULT	hr = pOldSec->ImpersonateClient();

				if ( FAILED(hr ) )
				{
					ERRORTRACE((LOG_WBEMCORE, "CWbemQueue::Execute() failed to reimpersonate client: hr = %d\n", hr));
					bRes = FALSE;
				}
			}

	        pOldSec->Release();
	    }

	    return bRes;

    } // end try
    catch(...) 
    {
        ExceptionCounter c;    
        ERRORTRACE((LOG_WBEMCORE, "CWbemQueue::Execute() exception\n"));
        return FALSE;
    }
}


BOOL CWbemQueue::DoesNeedNewThread(CCoreExecReq* pRequest, bool bIgnoreNumRequests )
{
    try
    {
	    // Check the base class
	    // ====================

	    if(CCoreQueue::DoesNeedNewThread(pRequest, bIgnoreNumRequests))
	        return TRUE;

	    if(pRequest)
	    {
	        // Check if the request is "special".  Special requests are issued by
	        // the sink proxy of an out-of-proc event provider. Such requests must
	        // be processed at all costs, because their parent thread is stuck in
	        // RPC. Additionally, check if this request is marked as "critical",
	        // which would mean that its parent thread didn't take it.
	        // ===================================================================

	        CWbemRequest* pWbemRequest = (CWbemRequest*)pRequest;
	        return (pWbemRequest->IsSpecial() || pWbemRequest->IsCritical());
	    }
	    else
	    {
	        return FALSE;
	    }

    } // end try
    catch(...) 
    {
        ExceptionCounter c;    
        ERRORTRACE((LOG_WBEMCORE, "CWbemQueue::DoesNeedNewThread() exception\n"));
        return FALSE;
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\wbemq.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMQ.H

Abstract:

History:

--*/

#ifndef __WBEM_QUEUE__H_
#define __WBEM_QUEUE__H_

class CWbemQueue;

class CWbemRequest : public CCoreExecReq
{
protected:
    IWbemContext* m_pContext;
    IWbemCausalityAccess* m_pCA;
    IWbemCallSecurity *m_pCallSec;

	// 
	// This flag was added to allow requests to be run immediately rather than being
	// enqueued and serviced at a later point. This is done
	// by bumping the priority of the request up.
	//
	// CAUTION!!!IF THIS FLAG IS SET TO > 0 THE REQUEST WILL RUN NO MATTER WHAT!
	// IF WE'RE OUT OF THREADS ANOTHER THREAD WILL BE CREATED TO HANDLE
	// THE REQUEST! ****** USE CAUTION ******
	//
	// By default this flag is 0.
	// 
    ULONG m_ulForceRun;


public:
    CWbemRequest(IWbemContext* pContext, BOOL bInternallyIssued);
    ~CWbemRequest();

    BOOL IsChildOf(CWbemRequest* pOther);
    BOOL IsChildOf(IWbemContext* pOther);

public:
    virtual CWbemQueue* GetQueue() {return NULL;}
    INTERNAL IWbemContext* GetContext() {return m_pContext;}
    void GetHistoryInfo(long* plNumParents, long* plNumSiblings);

    INTERNAL IWbemCallSecurity *GetCallSecurity() { return m_pCallSec; }
    BOOL IsSpecial();
    BOOL IsCritical();
    BOOL IsDependee();
    BOOL IsAcceptableByParent();
    BOOL IsIssuedByProvider();
    VOID SetForceRun ( ULONG ulForce ) { m_ulForceRun = ulForce; }
    ULONG GetForceRun ( ) { return m_ulForceRun; }
    virtual BOOL IsLongRunning() {return FALSE;}
    virtual BOOL IsInternal() = 0;
    virtual void TerminateRequest(HRESULT hRes){return;};
};

class CWbemQueue : public CCoreQueue
{
protected:
    long m_lChildPenalty;
    long m_lSiblingPenalty;
    long m_lPassingPenalty;

public:
    CWbemQueue();

    virtual BOOL IsSuitableThread(CThreadRecord* pRecord, CCoreExecReq* pReq);
    virtual LPCWSTR GetType() {return L"WBEMQ";}
    virtual void AdjustPriorityForPassing(CCoreExecReq* pReq);
    virtual void AdjustInitialPriority(CCoreExecReq* pReq);

    static CWbemRequest* GetCurrentRequest();

    void SetRequestPenalties(long lChildPenalty, long lSiblingPenalty,
                                long lPassingPenalty);

    virtual BOOL Execute(CThreadRecord* pRecord);
    virtual BOOL DoesNeedNewThread(CCoreExecReq* pReq, bool bIgnoreNumRequests = false );
};

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\wbemname.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMNAME.CPP

Abstract:

    Implements the COM layer of WINMGMT --- the class representing a namespace.
    It is defined in wbemname.h

History:

    raymcc    05-Apr-96  Created.
    raymcc    23-Apr-00  Whistler extensions

--*/

#include "precomp.h"

#pragma warning (disable : 4786)
#include <wbemcore.h>
#include <map>
#include <vector>
#include <perfhelp.h>
#include <genutils.h>
#include <oahelp.inl>
#include <wqllex.h>
#include <autoptr.h>
#include <comutl.h>

#include "wmiarbitrator.h"
#include "wmifinalizer.h"
#include "wmimerger.h"
extern BOOL g_bDontAllowNewConnections;

//***************************************************************************
//
//***************************************************************************

#define WBEM_MASK_DEPTH (WBEM_FLAG_DEEP | WBEM_FLAG_SHALLOW)
#define WBEM_MASK_CREATE_UPDATE (WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_CREATE_OR_UPDATE)

bool illFormatedClass2 (const wchar_t * pszSuperclass)
{
  for (const wchar_t * p = pszSuperclass; *p != L'\0'; ++p)
  {
    if (!(isunialphanum (*p) ||  *p == L'_'))
    {
      return true;  //Ill formated
    }
  }
  return false;
};


//***************************************************************************
//
//***************************************************************************

COperationError::COperationError(
    CBasicObjectSink* pDest,
    LPCWSTR wszOperation,
    LPCWSTR wszParam,
    BOOL bFinal
    )
        : m_fOk( true )
{
    m_pSink = new COperationErrorSink(pDest, wszOperation, wszParam, bFinal);

    if (m_pSink)
    {
        m_pSink->AddRef();
    }
    else
    {
        // OOM, set the status now.  Caller will verify that we're not ok
        if (NULL != pDest)
        {
            pDest->SetStatus(0, WBEM_E_OUT_OF_MEMORY, NULL, NULL);
        }

        m_fOk = false;
    }
}

//***************************************************************************
//
//***************************************************************************

COperationError::~COperationError()
{
    if (m_pSink)
        m_pSink->Release();
}

//***************************************************************************
//
//***************************************************************************

HRESULT COperationError::ErrorOccurred(
    HRESULT hRes,
    IWbemClassObject* pErrorObj
    )
{
    if (m_pSink)
        m_pSink->SetStatus(0, hRes, NULL, pErrorObj);
    return hRes;
}

//***************************************************************************
//
//***************************************************************************

HRESULT COperationError::ProviderReturned(
    LPCWSTR wszProviderName,
    HRESULT hRes,
    IWbemClassObject* pErrorObj
    )
{
    m_pSink->SetProviderName(wszProviderName);
    m_pSink->SetStatus(0, hRes, NULL, pErrorObj);
    return hRes;
}

//***************************************************************************
//
//***************************************************************************

void COperationError::SetParameterInfo(LPCWSTR wszParam)
{
    m_pSink->SetParameterInfo(wszParam);
}

//***************************************************************************
//
//***************************************************************************

void COperationError::SetProviderName(LPCWSTR wszName)
{
    m_pSink->SetProviderName(wszName);
}

//***************************************************************************
//
//***************************************************************************

CFinalizingSink::CFinalizingSink(
    CWbemNamespace* pNamespace,
    CBasicObjectSink* pDest
    )
        : CForwardingSink(pDest, 0), m_pNamespace(pNamespace)
{
    m_pNamespace->AddRef();
}

//***************************************************************************
//
//***************************************************************************

CFinalizingSink::~CFinalizingSink()
{
    m_pNamespace->Release();
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CFinalizingSink::Indicate(
    long lNumObjects,
    IWbemClassObject** apObj
    )
{
    HRESULT hRes;

    for (long i = 0; i < lNumObjects; i++)
    {
        CWbemObject *pObj = (CWbemObject *) apObj[i];

        if (pObj == 0)
        {
                ERRORTRACE((LOG_WBEMCORE, "CFinalizingSink::Indicate() -- Null pointer Indicate\n"));
                continue;
        }

        // If object is an instance, we have to deal with dynamic
        // properties.
        // ======================================================

        if (pObj->IsInstance())
        {
            hRes = m_pNamespace->GetOrPutDynProps((CWbemObject*)apObj[i],
                                        CWbemNamespace::GET);
            if (FAILED(hRes))
            {
                ERRORTRACE((LOG_WBEMCORE, "CFinalizingSink::Indicate() -- Failed to post-process an instance "
                    "using a property provider. Error code %X\n", hRes));
            }
        }
    }

    return m_pDest->Indicate(lNumObjects, apObj);
}


//***************************************************************************
//
//  StripServer
//
//***************************************************************************


LPWSTR StripServer(LPWSTR pszNamespace)
{
    LPWSTR lpRet = NULL;
    WCHAR * lpPtr = pszNamespace;
    if (*lpPtr == L'\\' || *lpPtr == L'/')
    {
        lpPtr++;
        if (*lpPtr == L'\\' || *lpPtr == L'/')
        {
            BOOL bSlash = FALSE;
            while (*lpPtr)
            {
                lpPtr++;
                if (*lpPtr == L'\\' || *lpPtr == L'/')
                {
                    bSlash = TRUE;
                    break;
                }
            }
            if (bSlash)
            {
                lpPtr++;
                lpRet = Macro_CloneLPWSTR(lpPtr);
            }
        }
    }

    if (!lpRet)
        lpRet = Macro_CloneLPWSTR(pszNamespace);

    return lpRet;
}


//***************************************************************************
//
//***************************************************************************
//
CWbemNamespace::CWbemNamespace()
{
    m_uSecondaryRefCount = 0;
    m_uPrimaryRefCount = 0;
    m_lConfigFlags = 0;
    m_bShutDown = FALSE;

    m_pSession = 0;
    m_pDriver = 0;
    m_pNsHandle = 0;
    m_pScopeHandle = 0;

    m_pThisNamespace = 0;
    m_dwPermission = 0;
    m_dwSecurityFlags = 0;
    m_wszUserName = 0;
    m_eRestriction = e_NoRestriction;

    m_bProvider = FALSE;
    m_bForClient = FALSE;
    m_bESS = FALSE;

    InitializeCriticalSection(&m_cs);
    m_bSecurityInitialized = FALSE;
    m_bNT = FALSE;

    m_pProvFact = 0;
    m_pCoreSvc = 0;
    m_bRepositOnly = FALSE;
    m_pRefreshingSvc = NULL;
    m_pWbemComBinding = NULL;
    m_pArb = 0;
    m_uClientMask = 0;

    m_dwTransactionState = 0;
    m_pTransGuid = 0;

    m_dwIfaceType = 0;
    m_pCollectionClass = 0;
    m_pCollectionEp = 0;
    m_lEpRefPropHandle = 0;
    m_lTargetRefPropHandle = 0;
    m_pszCollectionEpPath = 0;
    m_pszClientMachineName = NULL;
    m_dwClientProcessID = -1;

    _IWmiArbitrator *pArb = CWmiArbitrator::GetUnrefedArbitrator();
    if (pArb)
        pArb->RegisterNamespace((_IWmiCoreHandle *)this);

}



//***************************************************************************
//
//***************************************************************************
//
CWbemNamespace *CWbemNamespace::CreateInstance()
{
    try
    {
        CWbemNamespace *pNs = new CWbemNamespace;
        if (pNs)
            pNs->AddRef();
        return pNs;
    }
    catch(...)
    {
        ExceptionCounter c;    
        return 0;
    }
}


//***************************************************************************
//
//  CWbemNamespace::Initialize
//
//  Real constructor. In addition to finding the namespace in the database, this
//  function also enumerates all the class providers in the namespace and
//  loads them. It also notifies the ESS of the opening.
//
//  PARAMETERS:
//
//      LPWSTR Namespace        The full of the namespace to create.
//
//  RETURN VALUES:
//
//      Even though this function has no return values, it indicates success
//      or failure by setting the Status member variable to the error code.
//      WBEM_S_NO_ERROR              On Success
//      WBEM_E_INVALID_NAMESPACE     No such namespace
//      WBEM_E_CRITICAL_ERROR        Other database error.
//
//***************************************************************************

HRESULT CWbemNamespace::Initialize(
    LPWSTR pszNamespace,
    LPWSTR wszUserName,
    DWORD dwSecFlags,
    DWORD dwPermission,
    BOOL  bForClient,
    BOOL  bRepositOnly,
    LPCWSTR pszClientMachineName,
    DWORD dwClientProcessID,
    BOOL  bSkipSDInitialize,
    IWmiDbSession *pParentSession
    )
{
    try
    {

    m_dwSecurityFlags = dwSecFlags;
    m_dwPermission = dwPermission;
    if(g_bDontAllowNewConnections)
        return WBEM_E_SHUTTING_DOWN;

    PSID pRawSid;
    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;

    if (!AllocateAndInitializeSid( &id, 2,
        SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
        0,0,0,0,0,0,&pRawSid))
        return WBEM_E_OUT_OF_MEMORY;

    CNtSid Sid(pRawSid);
    FreeSid( pRawSid );

    CNtAce ace(1,ACCESS_ALLOWED_ACE_TYPE,0,Sid);
    if(ace.GetStatus() != 0)
        return WBEM_E_OUT_OF_MEMORY;

    CNtAcl acl;
    acl.AddAce(&ace);
    m_sdCheckAdmin.SetDacl(&acl);
    CNtSid owner(CNtSid::CURRENT_USER);
    m_sdCheckAdmin.SetGroup(&owner);
    m_sdCheckAdmin.SetOwner(&owner);

    m_bForClient = bForClient;

    if (m_bForClient)
        gClientCounter.AddClientPtr((IWbemServices *)this, NAMESPACE);

    m_bNT = (IsNT() != 0);

    m_pThisNamespace = StripServer(pszNamespace);
    if(m_pThisNamespace == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    m_pCoreSvc = CCoreServices::CreateInstance();
    if(m_pCoreSvc == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    m_pProvFact = 0;


    m_bRepositOnly = bRepositOnly;

    // Flip the slashes
    // ================

    WCHAR* pwc = m_pThisNamespace;
    while(*pwc)
    {
        if(*pwc == '/')
            *pwc = '\\';
        pwc++;
    }

    m_wszUserName = (wszUserName?Macro_CloneLPWSTR(wszUserName):NULL);

    // Repository binding.
    // ===================

    m_pNsHandle = 0;
    HRESULT hRes;
    IWmiDbSession *pTempSession= pParentSession;
    if (pTempSession == NULL)
    {
        hRes = CRepository::GetDefaultSession(&pTempSession);
        if (FAILED(hRes))
            return hRes;
    }
    else
        pTempSession->AddRef();

    hRes = CRepository::OpenScope(pTempSession, m_pThisNamespace, 0, &m_pDriver, &m_pSession, &m_pScopeHandle, &m_pNsHandle);
    if (FAILED(hRes))
    {
        pTempSession->Release();
        Status = WBEM_E_INVALID_NAMESPACE;
        return hRes;
    }

    if (m_pScopeHandle == 0)
    {
        m_bSubscope = FALSE;
        m_pScopeHandle = m_pNsHandle;
        if(m_pScopeHandle == NULL)
        {
            ERRORTRACE((LOG_WBEMCORE, "OpenScope returned success, yet m_pNsHandle is null!\n"));
            return WBEM_E_CRITICAL_ERROR;
        }
        m_pScopeHandle->AddRef();
    }
    else
        m_bSubscope = TRUE;

    m_pProvFact = 0;
    if (!bRepositOnly)
    {
        _IWmiProvSS *pProvSS = 0;
        m_pCoreSvc->GetProviderSubsystem(0, &pProvSS);
        CReleaseMe _(pProvSS);

        if(pProvSS)
        {
            HRESULT hr = pProvSS->Create(
                this,                           // Stupid because v-table access can occur before constructor completion
                0,                              // lFlags
                0,                              // pCtx
                m_pThisNamespace,               // Path
                IID__IWmiProviderFactory,
                (LPVOID *) &m_pProvFact
                );

            if ( FAILED ( hr ) )
            {
                pTempSession->Release();
                return hr ;
            }
        }
    }

    if(pszClientMachineName)
    {
        delete m_pszClientMachineName;
        int iLen = wcslen(pszClientMachineName) + 1;
        m_pszClientMachineName = new WCHAR[iLen];
        if(m_pszClientMachineName == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        wcscpy(m_pszClientMachineName, pszClientMachineName);
    }
    m_dwClientProcessID = dwClientProcessID;

    Status = WBEM_S_NO_ERROR;

    //Initialize Security descriptor
    if (!bSkipSDInitialize)
    {
        hRes = InitializeSD(pTempSession);
        if ( FAILED(hRes) )
        {
            pTempSession->Release();
            return hRes;
        }
    }
    pTempSession->Release();

    m_pArb = CWmiArbitrator::GetRefedArbitrator();

    m_pCoreSvc->IncrementCounter(WMICORE_SELFINST_CONNECTIONS, 1);

    return Status;

    }
    catch(...)
    {
        ExceptionCounter c;    
        return WBEM_E_FAILED;
    }
}



//***************************************************************************
//
//  CWbemNamespace::~CWbemNamespace
//
//  Notifies the ESS of namespace closure and frees up all the class providers.
//
//***************************************************************************

CWbemNamespace::~CWbemNamespace()
{
    try
    {
    if (m_pCoreSvc)
        m_pCoreSvc->DecrementCounter(WMICORE_SELFINST_CONNECTIONS, 1);

    ReleaseIfNotNULL(m_pProvFact);
    ReleaseIfNotNULL(m_pCoreSvc);
    ReleaseIfNotNULL(m_pSession);
    ReleaseIfNotNULL(m_pDriver);
    ReleaseIfNotNULL(m_pNsHandle);
    ReleaseIfNotNULL(m_pScopeHandle);
    ReleaseIfNotNULL(m_pRefreshingSvc);
    ReleaseIfNotNULL(m_pWbemComBinding);
    ReleaseIfNotNULL(m_pArb);
    ReleaseIfNotNULL(m_pCollectionClass);
    ReleaseIfNotNULL(m_pCollectionEp);

    delete m_pTransGuid;
    delete m_pThisNamespace;
    delete m_wszUserName;
    delete m_pszCollectionEpPath;
    delete m_pszClientMachineName;

    if(m_bForClient)
        gClientCounter.RemoveClientPtr((IWbemServices *)this);

    DeleteCriticalSection(&m_cs);

    }
    catch(...)
    {
        ExceptionCounter c;    
    }
}

//***************************************************************************
//
//  CWbemNamespace::QueryInterface
//
//  Exports IWbemServices interface.
//
//***************************************************************************

STDMETHODIMP CWbemNamespace::QueryInterface(
    IN REFIID riid,
    OUT LPVOID *ppvObj
    )
{
    try
    {
    *ppvObj = 0;

    if (IID_IUnknown==riid || IID_IWbemServices==riid || IID_IWbemServicesEx==riid)
    {
        *ppvObj = (IWbemServicesEx*)this;
        AddRef();
        return S_OK;
    }
    else if (IID_IWbemRefreshingServices == riid)
    {
        CInCritSec  ics( &m_cs );

        // Check if we already have this one
        if ( NULL != m_pRefreshingSvc )
        {
            return m_pRefreshingSvc->QueryInterface( IID_IWbemRefreshingServices, ppvObj );
        }

        // Aggregate this interface - We MUST use IUnknown, so the aggregee does not AddRef us.
        HRESULT hr = CoCreateInstance( CLSID__WbemConfigureRefreshingSvcs, (IWbemServicesEx*) this, CLSCTX_INPROC_SERVER, IID_IUnknown, (void**) &m_pRefreshingSvc );

        if ( SUCCEEDED( hr ) )
        {

            _IWbemConfigureRefreshingSvcs*  pCfgRefrSvc = NULL;

            // This will AddRef() us if everything is proper
            hr = m_pRefreshingSvc->QueryInterface( IID__IWbemConfigureRefreshingSvcs, (void**) &pCfgRefrSvc );

            if ( SUCCEEDED( hr ) )
            {
                // Must release this INSIDE here, because the m_pRefreshingService is the true Unknown of the
                // cocreated object, and this guy lives inside, so if we release the Unk fella first, we'll
                // wipe out pCfgRefrSvc - which if we don't release, will not fixup an AddRef on the namespace
                // this is bad.

                CReleaseMe  rm(pCfgRefrSvc);

                // Use BSTR's in case any marshaling takes place
                BSTR pstrMachineName = SysAllocString( ConfigMgr::GetMachineName() );
                CSysFreeMe  sfm1( pstrMachineName );

                BSTR    pstrNamespace = SysAllocString( m_pThisNamespace );
                CSysFreeMe  sfm2( pstrNamespace );

                if ( NULL != pstrMachineName && NULL != pstrNamespace )
                {

                    hr = pCfgRefrSvc->SetServiceData( pstrMachineName, pstrNamespace );

                    if ( SUCCEEDED( hr ) )
                    {
                        return m_pRefreshingSvc->QueryInterface( IID_IWbemRefreshingServices, ppvObj );
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }

            // If anything goes wrong, cleanup the variable
            if ( FAILED( hr ) )
            {
                m_pRefreshingSvc->Release();
                m_pRefreshingSvc = NULL;
            }
        }

        return E_FAIL;

    }
    else if(IID_IWbemUnloadingControl == riid)
    {
        *ppvObj = (IWbemUnloadingControl*)this;
        AddRef();
        return S_OK;
    }
    else if(IID_IWbemInternalServices == riid)
    {
        *ppvObj = (IWbemInternalServices*)this;
        AddRef();
        return S_OK;
    }
    else if(IID_IWbemComBinding == riid)
    {
        CInCritSec  ics( &m_cs );

        // Check if we already have this one
        if ( NULL == m_pWbemComBinding )
        {
            // Aggregate this interface - We MUST use IUnknown, so the aggregee does not AddRef us.
            HRESULT hr = CoCreateInstance( CLSID__WbemComBinding, (IWbemServicesEx*) this, CLSCTX_INPROC_SERVER, IID_IUnknown, (void**) &m_pWbemComBinding );

            if ( FAILED( hr ) )
            {
                return hr;
            }

        }

        return m_pWbemComBinding->QueryInterface( riid, ppvObj );
    }

    }
    catch(...)
    {
        ExceptionCounter c;    
    }

    return E_NOINTERFACE;
}

//***************************************************************************
//
//***************************************************************************
//
ULONG CWbemNamespace::AddRef()
{
    InterlockedIncrement((LONG *) &m_uSecondaryRefCount);
    return m_uSecondaryRefCount;
}

//***************************************************************************
//
//***************************************************************************
//
ULONG CWbemNamespace::Release()
{
    ULONG uNewCount = InterlockedDecrement((LONG *) &m_uSecondaryRefCount);
    if (0 != uNewCount)
        return uNewCount;

    // The arbitrator holds the primary thread count.  Once all the normal clients have gone
    // away, notify the arbitrator which will call back in to the ReleasePrimary function
    // which will do the actual delete

    try
    {
    
	    if (m_uPrimaryRefCount)
	    {
	        _IWmiArbitrator *pArb = CWmiArbitrator::GetUnrefedArbitrator();
	        if (pArb)
	        {
	        	HRESULT hRes = pArb->UnregisterNamespace((_IWmiCoreHandle *)this);
	        	if (FAILED(hRes))
	        	{
	        	    // namespace not registred with the current Arbitrator, self destruct
	        	}
	        	else
	        	{
	        	    return 0;
	        	}
	        }
	        else
	        {
	            // self destruction without arbitrator available
	        }
	    }

     }
     catch (...)
     {
         ExceptionCounter c;
     }

    delete this;
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//
ULONG CWbemNamespace::AddRefPrimary()
{
    InterlockedIncrement((LONG *) &m_uPrimaryRefCount);
    return m_uPrimaryRefCount;
}

//***************************************************************************
//
//***************************************************************************
//
ULONG CWbemNamespace::ReleasePrimary()
{
    ULONG uNewCount = InterlockedDecrement((LONG *) &m_uPrimaryRefCount);
    if (0 != uNewCount)
        return uNewCount;

    delete this;
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::Dump(FILE *f)
{
    fprintf(f, "---Namespace = 0x%p----------------------------\n", this);
    fprintf(f, "    Secondary Refcount = %d\n", m_uSecondaryRefCount);
    fprintf(f, "    Primary Refcount = %d\n", m_uPrimaryRefCount);
    if(m_pThisNamespace)
        fprintf(f,  "    Name = %ls\n", m_pThisNamespace);
    if(m_wszUserName)
        fprintf(f,  "    User Name = %ls\n", m_wszUserName);
    if(m_pszClientMachineName)
        fprintf(f,  "    Client Machine Name = %ls\n", m_pszClientMachineName);
    else
        fprintf(f,  "    Client Machine Name = <unknown>\n");
    if(m_dwClientProcessID)
        fprintf(f,  "    Client Process = 0X%X\n", m_dwClientProcessID);
    else
        fprintf(f,  "    Client Process = <unknown>\n");


    return S_OK;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::SetErrorObj(IWbemClassObject* pErrorObj)
{
    if (pErrorObj == NULL)
    {
        return S_OK;
    }

    IErrorInfo* pInfo;
    HRESULT hRes = pErrorObj->QueryInterface(IID_IErrorInfo, (void**)&pInfo);
    if (FAILED(hRes))
        return hRes;

    hRes = SetErrorInfo(0, pInfo);
    pInfo->Release();
    return hRes;
}

//***************************************************************************
//
//  CWbemNamespace::GetConfigurationFlags
//
//  Returns the curent setting of the configuration flags.
//
//  RETURN VALUES:
//
//      WBEM_CONFIGURATION_NORMAL
//      WBEM_CONFIGURATION_FLAG_CRITICAL_USER
//
//***************************************************************************
LONG CWbemNamespace::GetConfigurationFlags()
{
    return m_lConfigFlags;
}

//***************************************************************************
//
//  CWbemNamespace::SplitLocalized
//
//***************************************************************************

HRESULT CWbemNamespace::SplitLocalized (
    CWbemObject *pOriginal,
    CWbemObject *pStoredObj
    )
{
    HRESULT hres = 0;

    CVar vProv;

    IWbemQualifierSet *pOrigQs = NULL, *pStoredQs = NULL;
    VARIANT vVal;
    VariantInit(&vVal);

    hres = pOriginal->GetQualifierSet(&pOrigQs);
    if (FAILED(hres))
        return hres;

    if (pStoredObj)
    {
        hres = pStoredObj->GetQualifierSet(&pStoredQs);
        if (FAILED(hres))
            return hres;
    }

    hres = FixAmendedQualifiers(pOrigQs, pStoredQs);
    pOrigQs->Release();
    if (pStoredQs)
        pStoredQs->Release();


    if (SUCCEEDED(hres))
    {
        pOriginal->BeginEnumeration(0);
        LONG lLong;
        CIMTYPE ct;
        VARIANT vNewVal;
        BSTR strPropName;

        while((hres = pOriginal->Next(0, &strPropName, &vNewVal, &ct, &lLong)) == S_OK)
        {
            CWStringArray arrDel;
            pOrigQs = NULL;
            pStoredQs = NULL;

            // Ignore system qualifiers.

            if (strPropName[0] == L'_')
            {
                SysFreeString(strPropName);
                VariantClear(&vNewVal);
                continue;
            }

            hres = pOriginal->GetPropertyQualifierSet(strPropName, &pOrigQs);
            if (FAILED(hres))
            {
                SysFreeString(strPropName);
                VariantClear(&vNewVal);
                return hres;
            }

            pStoredQs = NULL;
            if (pStoredObj)
            {
                pStoredObj->GetPropertyQualifierSet(strPropName, &pStoredQs);
            }

            hres = FixAmendedQualifiers(pOrigQs, pStoredQs);
            pOrigQs->Release();
            if (pStoredQs)
                pStoredQs->Release();

            VariantClear(&vNewVal);
            SysFreeString(strPropName);
        }

        pOriginal->EndEnumeration();

        // Unfortunately, we have to enumerate the methods,
        // and *then* update them...

        BSTR bstrMethodName;

        pOriginal->BeginMethodEnumeration(0);
        IWbemClassObject *pLIn = NULL, *pLOut = NULL, *pOIn = NULL, *pOOut = NULL;

        // first count the number of methods

        while ( pOriginal->NextMethod( 0, &bstrMethodName, 0, 0 ) == S_OK )
        {
            pLIn = pLOut = pOIn = pOOut = NULL;
			pOrigQs = NULL ;
			pStoredQs = NULL ;

            hres = pOriginal->GetMethod(bstrMethodName, 0, &pLIn, &pLOut);
			if ( FAILED ( hres ) )
			{
				continue ;
			}

            CSysFreeMe fm(bstrMethodName);
            CReleaseMe rm0(pLIn);
            CReleaseMe rm2(pLOut);
    
            hres = pOriginal->GetMethodQualifierSet(bstrMethodName, &pOrigQs);
            if (FAILED(hres))
            {
                continue;
            }

            CReleaseMe rm4 ( pOrigQs ) ;
            
			if (pStoredObj)
            {
                hres = pStoredObj->GetMethodQualifierSet(bstrMethodName, &pStoredQs);
				if ( FAILED ( hres ) )
				{
					continue ;
				}
            }

			CReleaseMe rm5 ( pStoredQs ) ;

            // Method qualifiers...

            hres = FixAmendedQualifiers(pOrigQs, pStoredQs);

			if (SUCCEEDED(hres))
            {
                if (pStoredObj)
                    hres = pStoredObj->GetMethod(bstrMethodName, 0, &pOIn, &pOOut);

				CReleaseMe rm1(pOIn);
				CReleaseMe rm3(pOOut);

                if (pLIn)
                    hres = SplitLocalized((CWbemObject *)pLIn, (CWbemObject *)pOIn);

                if (pLOut)
                    hres = SplitLocalized((CWbemObject *)pLOut, (CWbemObject *)pOOut);

                hres = pOriginal->PutMethod(bstrMethodName, 0, pLIn, pLOut);
            }
            else
                break;
        }
        pOriginal->EndMethodEnumeration();

    }

    hres = 0;

    return hres;

}

//***************************************************************************
//
//  CWbemNamespace::FixAmendedQualifiers
//
//***************************************************************************

HRESULT CWbemNamespace::FixAmendedQualifiers(
    IWbemQualifierSet *pOriginal,
    IWbemQualifierSet *pNew
    )
 {
    HRESULT hres = 0;
    CWStringArray arrDelete;
    CWStringArray arrProps;
    BSTR strName = 0;
    long lFlavor;
    VARIANT vVal;
    VariantInit(&vVal);

    int i;

    pOriginal->BeginEnumeration(0);
    while(pOriginal->Next(0, &strName, NULL, NULL) == S_OK)
    {
        arrProps.Add(strName);
        SysFreeString(strName);
    }

    for (i = 0; i < arrProps.Size(); i++)
    {
        pOriginal->Get(arrProps.GetAt(i), 0, &vVal, &lFlavor);
        if (lFlavor & WBEM_FLAVOR_AMENDED)
        {
            // Delete the "amended" qualifier.

            arrDelete.Add(arrProps.GetAt(i));

            // Restore any original qualifier value.
            if (pNew)
            {
                VARIANT vOldVal;
                long lOldFlavor;
                VariantInit(&vOldVal);
                if (pNew->Get(arrProps.GetAt(i), 0, &vOldVal, &lOldFlavor) != WBEM_E_NOT_FOUND)
                {
                    pOriginal->Put(arrProps.GetAt(i), &vOldVal, lOldFlavor);
                    VariantClear(&vOldVal);
                    arrDelete.RemoveAt(arrDelete.Size()-1);
                }
            }
        }
        VariantClear(&vVal);
    }
    pOriginal->EndEnumeration();

    for (i = 0; i < arrDelete.Size(); i++)
    {
        pOriginal->Delete(arrDelete.GetAt(i));
    }

    arrDelete.Empty();

    return hres;

 }

//***************************************************************************
//
//  CWbemNamespace::Exec_DeleteClass
//
//  Actually deletes the class from the database. No class provider support.
//  Raises class deletion event.
//
//  Parameters and return values are exacly the same as those for DeleteClass
//  as described in help
//
//***************************************************************************

HRESULT CWbemNamespace::Exec_DeleteClass(
    LPWSTR pszClassName,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink
    )
{
    HRESULT hRes;
    IWbemClassObject* pErrorObj = 0;
    IWbemServices *pClassProv = 0;
    CSynchronousSink* pSyncSink = 0;
    BSTR bstrClass = 0;
    IWbemClassObject* pStaticClassDef = 0;
    BOOL bInRepository = FALSE;

    if (pszClassName == 0 || pSink == 0)
        return pSink->Return(WBEM_E_INVALID_PARAMETER);

    if (pszClassName[0] == L'_')
        return pSink->Return(WBEM_E_INVALID_OPERATION);

    // Bring up the dynamic class provider symposium for consultation.
    // ===============================================================

    if (!m_bRepositOnly && m_pProvFact)
    {
        hRes = m_pProvFact->GetClassProvider(
                    0,                  // lFlags
                    pCtx,
                    m_wszUserName,
                    m_wsLocale,
                    m_pThisNamespace,                     // IWbemPath pointer
                    0,
                    IID_IWbemServices,
                    (LPVOID *) &pClassProv
                    );

        if (FAILED(hRes))
            return pSink->Return(hRes);
    }

    CReleaseMe _2(pClassProv);

    _IWmiCoreWriteHook *pHook = 0;
    hRes = m_pCoreSvc->NewPerTaskHook(&pHook);
    if (FAILED(hRes))
        return pSink->Return(hRes);
    CReleaseMe _(pHook);
    HRESULT hHookResult = 0;


    // First, try repository.
    // ======================

    if (m_bRepositOnly || m_pProvFact == NULL)
    {

        if (!Allowed(WBEM_FULL_WRITE_REP))
            return pSink->Return(WBEM_E_ACCESS_DENIED);

        if (pHook)
            pHook->PreDelete(WBEM_FLAG_CLASS_DELETE, lFlags, pCtx, NULL,
                                       m_pThisNamespace, pszClassName );

        hRes = CRepository::DeleteByPath(m_pSession, m_pNsHandle, pszClassName, 0);

        if (pHook)
            pHook->PostDelete(WBEM_FLAG_CLASS_DELETE, hRes, pCtx, NULL, m_pThisNamespace, pszClassName, NULL);

        return pSink->Return(hRes);
    }

    // If here, we have to get it first because dynamic class providers
    // could be seriously affected by the removal of the class.
    // ===============================================